/*
Package shaders provides a ShaderMaterial.Instance with the shader pipeline written within Go.

Shaders are multi-stage programs executed on the GPU. They can be used to gain precise control
over rendering calculations, such as lighting, shadows, and post-processing effects.

To create a new 2D shader in Go, define a struct that embeds shaders.Type2D and implements the
pipeline methods you would like to overide. For example:

	type MyShader struct {
		shaders.Type2D

		MyUniform vec2.XY `gd:"my_uniform"`
	}

	// The pipeline functions are named after what they return, not what they accept as
	// input.

	// Fragment returns a fragment for the given vertex (also known as a vertex shader).
	func (MyShader) Fragment(vertex shaders.Vertex2D) shaders.Fragment2D {
		return shaders.Fragment2D{
			Position: vertex.Position,
		}
	}

	// Material returns a material for the given fragment (also known as a fragment shader).
	func (MyShader) Material(fragment shaders.Fragment2D) shaders.Material2D {
		return shaders.Material2D{
			Color: rgba.New(1, 0, 0, 1),
		}
	}

	// Lighting calculates the lighting for the given material (also known as a lighting pass).
	func (MyShader) Lighting(material shaders.Material2D) vec4.RGBA {
		return material.Color
	}

Each sub-package provides GPU-specific shader types that can be used within a shader pipeline.
Keep in mind that the Go code is compiled to run on the GPU, so non-GPU values, function
calls or branches will only take affect during compilation and not when rendering.

All for loops will be unrolled. The shaders package does not currently support non-constant
loops.
*/
package shaders

import (
	"fmt"
	"io"
	"reflect"
	"strings"

	"graphics.gd/classdb/Shader"
	"graphics.gd/classdb/ShaderMaterial"
	vec1 "graphics.gd/shaders/float"
	"graphics.gd/shaders/internal/gpu"
	dsl "graphics.gd/shaders/internal/gpu"
	"graphics.gd/shaders/vec2"
	"graphics.gd/shaders/vec4"
)

// Globals are available everywhere, including custom functions.
var (
	Time = gpu.NewFloatExpression(gpu.New(gpu.Identifier("TIME")))
	PI   = gpu.NewFloatExpression(gpu.New(gpu.Identifier("PI")))
	TAU  = gpu.NewFloatExpression(gpu.New(gpu.Identifier("TAU")))
	E    = gpu.NewFloatExpression(gpu.New(gpu.Identifier("E")))
)

type Program[Vertex, Fragment, Material, Lighting any, RenderMode ~string] interface {
	Super() ShaderMaterial.Instance

	ShaderType() string
	RenderMode() []RenderMode

	Pipeline() [3]string

	Fragment(Vertex) Fragment
	Material(Fragment) Material
	Lighting(Material) Lighting
}

func Compile[V, F, M, L comparable, RM ~string](prog Program[V, F, M, L, RM]) {
	super := prog.Super()
	shader := Shader.New()
	writer := strings.Builder{}
	fmt.Fprintf(&writer, "// Code generated by graphics.gd/shaders DO NOT EDIT!\n")
	fmt.Fprintf(&writer, "shader_type %s;\n\n", prog.ShaderType())

	render_modes := prog.RenderMode()
	if len(render_modes) > 0 {
		fmt.Fprintf(&writer, "render_mode ")
		for i, mode := range render_modes {
			if i > 0 {
				fmt.Fprintf(&writer, ", ")
			}
			fmt.Fprintf(&writer, "%s", mode)
		}
		fmt.Fprintf(&writer, ";\n")
	}

	pipeline := prog.Pipeline()

	linkup(prog)
	var vertices V
	linkup(&vertices)
	var fragment F
	linkup(&fragment)
	var material M
	linkup(&material)

	compileUniforms(&writer, prog)
	if frag := prog.Fragment(vertices); frag != [1]F{}[0] && pipeline[0] != "" {
		compileFunction(&writer, frag, pipeline[0])
	}
	if matl := prog.Material(fragment); matl != [1]M{}[0] && pipeline[1] != "" {
		compileFunction(&writer, matl, pipeline[1])
	}
	if lght := prog.Lighting(material); lght != [1]L{}[0] && pipeline[2] != "" {
		compileFunction(&writer, lght, pipeline[2])
	}
	fmt.Println(writer.String())
	shader.SetCode(writer.String())
	super.SetShader(shader)
}

func linkup(in any) {
	value := reflect.ValueOf(in).Elem()
	rtype := value.Type()
	for i := range rtype.NumField() {
		if value.Field(i).Kind() == reflect.Struct && rtype.Field(i).IsExported() {
			linkup(value.Field(i).Addr().Interface())
		}
		if tag := rtype.Field(i).Tag.Get("gd"); tag != "" {
			field := value.Field(i)
			switch ptr := field.Addr().Interface().(type) {
			case *vec2.XY:
				dsl.Set(&ptr.X, dsl.Identifier(tag+".x"))
				dsl.Set(&ptr.Y, dsl.Identifier(tag+".y"))
			}
			dsl.Set(value.Field(i).Addr().Interface().(dsl.Pointer), dsl.Identifier(tag))
		}
	}
}

func compileUniforms(w io.Writer, uniforms any) {
	value := reflect.ValueOf(uniforms).Elem()
	rtype := value.Type()
	for i := range rtype.NumField() {
		if tag := rtype.Field(i).Tag.Get("gd"); tag != "" {
			fmt.Fprintf(w, "uniform ")
			switch field := rtype.Field(i); reflect.Zero(field.Type).Interface().(type) {
			case vec2.XY:
				fmt.Fprintf(w, "vec2 %s;\n", tag)
			case vec4.RGBA:
				fmt.Fprintf(w, "vec4 %s;\n", tag)
			case vec1.X:
				fmt.Fprintf(w, "float %s;\n", tag)
			default:
				panic(fmt.Sprintf("unsupported uniform type %s", field.Type))
			}
		}
	}
	fmt.Fprintln(w)
}

func compileFunction(w io.Writer, data any, name string) {
	fmt.Fprintf(w, "void %s() {\n", name)
	value := reflect.ValueOf(data)
	rtype := value.Type()
	for i := range rtype.NumField() {
		field := rtype.Field(i)
		expr, ok := value.Field(i).Interface().(dsl.Evaluator)
		if ok && !value.Field(i).IsZero() {
			fmt.Fprintf(w, "\t%s = ", field.Tag.Get("gd"))
			compileExpression(w, expr)
			fmt.Fprintf(w, ";\n")
		}
	}
	fmt.Fprintf(w, "}\n")
}

func compileExpression(w io.Writer, expression dsl.Evaluator) {
	if expr := dsl.Evaluate(expression); expr != nil {
		expression = expr
	}
	rtype := reflect.TypeOf(expression)
	switch {
	case rtype.ConvertibleTo(reflect.TypeFor[gpu.RGBA]()):
		value := reflect.ValueOf(expression).Convert(reflect.TypeFor[gpu.RGBA]()).Interface().(gpu.RGBA)
		compileCall(w, "vec4", value.R, value.G, value.B, value.A)
	case rtype.ConvertibleTo(reflect.TypeFor[gpu.Vec4]()):
		value := reflect.ValueOf(expression).Convert(reflect.TypeFor[gpu.Vec4]()).Interface().(gpu.Vec4)
		compileCall(w, "vec4", value.X, value.Y, value.Z, value.W)
	case rtype.ConvertibleTo(reflect.TypeFor[gpu.Vec4i]()):
		value := reflect.ValueOf(expression).Convert(reflect.TypeFor[gpu.Vec4i]()).Interface().(gpu.Vec4i)
		compileCall(w, "ivec4", value.X, value.Y, value.Z, value.W)
	case rtype.ConvertibleTo(reflect.TypeFor[gpu.Vec4u]()):
		value := reflect.ValueOf(expression).Convert(reflect.TypeFor[gpu.Vec4u]()).Interface().(gpu.Vec4u)
		compileCall(w, "uvec4", value.X, value.Y, value.Z, value.W)
	case rtype.ConvertibleTo(reflect.TypeFor[gpu.Vec4b]()):
		value := reflect.ValueOf(expression).Convert(reflect.TypeFor[gpu.Vec4b]()).Interface().(gpu.Vec4b)
		compileCall(w, "bvec4", value.X, value.Y, value.Z, value.W)
	case rtype.ConvertibleTo(reflect.TypeFor[gpu.Vec3]()):
		value := reflect.ValueOf(expression).Convert(reflect.TypeFor[gpu.Vec3]()).Interface().(gpu.Vec3)
		compileCall(w, "vec3", value.X, value.Y, value.Z)
	case rtype.ConvertibleTo(reflect.TypeFor[gpu.RGB]()):
		value := reflect.ValueOf(expression).Convert(reflect.TypeFor[gpu.RGB]()).Interface().(gpu.RGB)
		compileCall(w, "vec3", value.R, value.G, value.B)
	case rtype.ConvertibleTo(reflect.TypeFor[gpu.Vec3i]()):
		value := reflect.ValueOf(expression).Convert(reflect.TypeFor[gpu.Vec3i]()).Interface().(gpu.Vec3i)
		compileCall(w, "ivec3", value.X, value.Y, value.Z)
	case rtype.ConvertibleTo(reflect.TypeFor[gpu.Vec3u]()):
		value := reflect.ValueOf(expression).Convert(reflect.TypeFor[gpu.Vec3u]()).Interface().(gpu.Vec3u)
		compileCall(w, "uvec3", value.X, value.Y, value.Z)
	case rtype.ConvertibleTo(reflect.TypeFor[gpu.Vec3b]()):
		value := reflect.ValueOf(expression).Convert(reflect.TypeFor[gpu.Vec3b]()).Interface().(gpu.Vec3b)
		compileCall(w, "bvec3", value.X, value.Y, value.Z)
	case rtype.ConvertibleTo(reflect.TypeFor[gpu.Vec2]()):
		value := reflect.ValueOf(expression).Convert(reflect.TypeFor[gpu.Vec2]()).Interface().(gpu.Vec2)
		compileCall(w, "vec2", value.X, value.Y)
	case rtype.ConvertibleTo(reflect.TypeFor[gpu.Vec2i]()):
		value := reflect.ValueOf(expression).Convert(reflect.TypeFor[gpu.Vec2i]()).Interface().(gpu.Vec2i)
		compileCall(w, "ivec2", value.X, value.Y)
	case rtype.ConvertibleTo(reflect.TypeFor[gpu.Vec2u]()):
		value := reflect.ValueOf(expression).Convert(reflect.TypeFor[gpu.Vec2u]()).Interface().(gpu.Vec2u)
		compileCall(w, "uvec2", value.X, value.Y)
	case rtype.ConvertibleTo(reflect.TypeFor[gpu.Vec2b]()):
		value := reflect.ValueOf(expression).Convert(reflect.TypeFor[gpu.Vec2b]()).Interface().(gpu.Vec2b)
		compileCall(w, "bvec2", value.X, value.Y)
	case rtype.ConvertibleTo(reflect.TypeFor[gpu.Float]()):
		value := reflect.ValueOf(expression).Convert(reflect.TypeFor[gpu.Float]()).Interface().(gpu.Float)
		fmt.Fprintf(w, "%f", value.X)
	case rtype.ConvertibleTo(reflect.TypeFor[gpu.Int]()):
		value := reflect.ValueOf(expression).Convert(reflect.TypeFor[gpu.Int]()).Interface().(gpu.Int)
		fmt.Fprintf(w, "%d", value.X)
	case rtype.ConvertibleTo(reflect.TypeFor[gpu.Uint]()):
		value := reflect.ValueOf(expression).Convert(reflect.TypeFor[gpu.Uint]()).Interface().(gpu.Uint)
		fmt.Fprintf(w, "%d", value.X)
	case rtype.ConvertibleTo(reflect.TypeFor[gpu.Bool]()):
		value := reflect.ValueOf(expression).Convert(reflect.TypeFor[gpu.Bool]()).Interface().(gpu.Bool)
		fmt.Fprintf(w, "%t", value.X)
	case rtype.ConvertibleTo(reflect.TypeFor[gpu.Mat2]()):
		value := reflect.ValueOf(expression).Convert(reflect.TypeFor[gpu.Mat2]()).Interface().(gpu.Mat2)
		compileCall(w, "mat2", value.Columns[0][0], value.Columns[0][1], value.Columns[1][0], value.Columns[1][1])
	case rtype.ConvertibleTo(reflect.TypeFor[gpu.Mat3]()):
		value := reflect.ValueOf(expression).Convert(reflect.TypeFor[gpu.Mat3]()).Interface().(gpu.Mat3)
		compileCall(w, "mat3", value.Columns[0][0], value.Columns[0][1], value.Columns[0][2], value.Columns[1][0], value.Columns[1][1], value.Columns[1][2], value.Columns[2][0], value.Columns[2][1], value.Columns[2][2])
	case rtype.ConvertibleTo(reflect.TypeFor[gpu.Mat4]()):
		value := reflect.ValueOf(expression).Convert(reflect.TypeFor[gpu.Mat4]()).Interface().(gpu.Mat4)
		compileCall(w, "mat4", value.Columns[0][0], value.Columns[0][1], value.Columns[0][2], value.Columns[0][3], value.Columns[1][0], value.Columns[1][1], value.Columns[1][2], value.Columns[1][3], value.Columns[2][0], value.Columns[2][1], value.Columns[2][2], value.Columns[2][3], value.Columns[3][0], value.Columns[3][1], value.Columns[3][2], value.Columns[3][3])
	default:
		switch value := expression.(type) {
		case dsl.Operation:
			fmt.Fprintf(w, "(")
			compileExpression(w, value.A)
			fmt.Fprintf(w, " %s ", value.Op)
			compileExpression(w, value.B)
			fmt.Fprintf(w, ")")
		case dsl.Identifier:
			fmt.Fprintf(w, "%s", value)
		case dsl.Ternary:
			fmt.Fprintf(w, "(")
			compileExpression(w, value.If)
			fmt.Fprintf(w, " ? ")
			compileExpression(w, value.A)
			fmt.Fprintf(w, " : ")
			compileExpression(w, value.B)
			fmt.Fprintf(w, ")")
		case dsl.FunctionCall:
			compileCall(w, string(value.Name), value.Args...)
		default:
			panic(fmt.Sprintf("unsupported expression type %T", expression))
		}
	}
}

func compileCall(w io.Writer, name string, args ...dsl.Evaluator) {
	fmt.Fprintf(w, "%s(", name)
	for i, arg := range args {
		if i > 0 {
			fmt.Fprintf(w, ", ")
		}
		compileExpression(w, arg)
	}
	fmt.Fprintf(w, ")")
}
