package main

import (
	"errors"
	"fmt"
	"io"
	"iter"
	"os"
	"reflect"
	"strings"

	"graphics.gd/internal/gdextension"
	"runtime.link/api"
)

func generate_header_file() error {
	h, err := os.Create("startup_cgo_v2.h")
	if err != nil {
		return err
	}
	defer h.Close()

	fmt.Fprint(h, "// Code generated by ./internal/cmd/generate; DO NOT EDIT.\n")
	fmt.Fprint(h, "#include <stdlib.h>\n#include <stdbool.h>\n\n")

	fmt.Fprint(h, "GDExtensionBool cgo_extension_init(GDExtensionInterfaceGetProcAddress p_get_proc_address, GDExtensionClassLibraryPtr p_library, GDExtensionInitialization *r_initialization);\n")

	for fn := range api.StructureOf(&gdextension.Host).Iter() {
		var out = "void"
		for result := range fn.Type.NumOut() {
			if ctype := ctypeOf(fn.Type.Out(result)); ctype != "" {
				out = ctype
				break
			}
		}
		fmt.Fprintf(h, "%s gd_%s(", out, fn.Tags.Get("gd"))
		for i, arg := range args_flat(fn.Type) {
			if i > 0 {
				fmt.Fprint(h, ", ")
			}
			if ctype := ctypeOf(arg); ctype != "" {
				fmt.Fprintf(h, "%s", ctype)
			} else {
				panic(fmt.Sprintf("unsupported type %s for parameter %d in function %s", arg, i, fn.Tags.Get("gd")))
			}
		}
		fmt.Fprint(h, ");\n")
	}
	return nil
}

func generate_startup_cgo() error {
	f, err := os.Create("startup_cgo_v2.go")
	if err != nil {
		return err
	}
	defer f.Close()

	fmt.Fprint(f, "// Code generated by ./internal/cmd/generate; DO NOT EDIT.\n")
	fmt.Fprint(f, "//go:build cgo\n\n")
	fmt.Fprint(f, "package startup\n\n")
	fmt.Fprint(f, "import \"unsafe\"\n")
	fmt.Fprint(f, "import \"graphics.gd/internal/gdextension\"\n\n")
	fmt.Fprint(f, "// #include \"gdextension_interface.h\"\n")
	fmt.Fprint(f, "// #include \"startup_cgo_v2.h\"\n")
	fmt.Fprint(f, "// #include <stdlib.h>\n")
	fmt.Fprint(f, "// #include <stdbool.h>\n")
	fmt.Fprint(f, "import \"C\"\n\n")

	for fn := range api.StructureOf(&gdextension.On).Iter() {
		name := fn.Tags.Get("gd")
		fmt.Fprintf(f, "//export go_%s\nfunc go_%[1]s", name)
		writeGoFunctionArguments(f, fn, true, cgoTypeOf)
		var out = ""
		if result := getReturn(fn.Type); result != nil {
			if ctype := cgoTypeOf(result); ctype != "" {
				out = ctype
			}
		}
		fmt.Fprintf(f, "%s", out)
		fmt.Fprintf(f, " {\n\t")
		if result := getReturn(fn.Type); fn.NumOut() == 1 && result != nil {
			fmt.Fprintf(f, "return %s(", cgoTypeOf(result))
		} else if fn.NumOut() > 0 && result != nil {
			for i := 0; i < fn.NumOut(); i++ {
				if i > 0 {
					fmt.Fprint(f, ", ")
				}
				if fn.Type.Out(i).Size() > 0 {
					fmt.Fprintf(f, "result")
				} else {
					fmt.Fprint(f, "_")
				}
			}
			fmt.Fprint(f, " := ")
		}
		fmt.Fprintf(f, "gdextension.On.%s(", strings.Join(append(fn.Path, fn.Name), "."))
		var n int
		for i := range fn.NumIn() {
			if n > 0 {
				fmt.Fprint(f, ", ")
			}
			arg := fn.Type.In(i)
			switch arg.Kind() {
			case reflect.Array:
				fmt.Fprintf(f, "%s{", toGoValue(arg))
				for j := 0; j < arg.Len(); j++ {
					if j > 0 {
						fmt.Fprint(f, ", ")
					}
					fmt.Fprintf(f, "%s(p%d)", toGoValue(arg.Elem()), n)
					n++
				}
				fmt.Fprint(f, "}")
			default:
				fmt.Fprintf(f, "%s(p%d)", toGoValue(arg), n)
				n++
			}

		}
		if result := getReturn(fn.Type); fn.NumOut() == 1 && result != nil {
			fmt.Fprint(f, "))")
		} else if fn.NumOut() > 0 && result != nil {
			fmt.Fprintf(f, ")\n\treturn %s(result)", cgoTypeOf(result))
		} else {
			fmt.Fprint(f, ")")
		}
		fmt.Fprint(f, "\n}\n\n")
	}

	fmt.Fprint(f, "func init() {\n")
	for fn := range api.StructureOf(&gdextension.Host).Iter() {
		name := fn.Tags.Get("gd")
		if name == "" {
			continue
		}
		fmt.Fprintf(f, "\tgdextension.Host.%s = func", strings.Join(append(fn.Path, fn.Name), "."))
		writeGoFunctionArguments(f, fn, false, goTypeOf)
		if fn.NumOut() > 0 {
			fmt.Fprintf(f, " (")
		}
		for i := 0; i < fn.NumOut(); i++ {
			if i > 0 {
				fmt.Fprint(f, ", ")
			}
			result := fn.Type.Out(i)
			if result.Size() > 0 {
				fmt.Fprintf(f, "result %s", goTypeOf(result))
			} else {
				fmt.Fprintf(f, "_ %s", goTypeOf(result))
			}
		}
		if fn.NumOut() > 0 {
			fmt.Fprintf(f, " )")
		}
		fmt.Fprintf(f, " {\n")
		if result := getReturn(fn.Type); result != nil {
			fmt.Fprintf(f, "\t\tresult = %s(", goTypeOf(result))
		}
		fmt.Fprintf(f, "\t\tC.gd_%s(", name)
		for i := range fn.NumIn() {
			if i > 0 {
				fmt.Fprint(f, ", ")
			}
			arg := fn.Type.In(i)
			switch arg.Kind() {
			case reflect.Array:
				for j := 0; j < arg.Len(); j++ {
					if j > 0 {
						fmt.Fprint(f, ", ")
					}
					fmt.Fprintf(f, "%s(p%d[%d])", cgoTypeOf(arg.Elem()), i, j)
				}
			case reflect.String:
				fmt.Fprintf(f, "(%s)(unsafe.Pointer(unsafe.StringData(p%d))), C.uint64_t(len(p%d))", cgoTypeOf(arg), i, i)
			case reflect.Slice:
				fmt.Fprintf(f, "(%s)(unsafe.Pointer(unsafe.SliceData(p%d))), C.uint64_t(len(p%d))", cgoTypeOf(arg), i, i)
			default:
				fmt.Fprintf(f, "%s", toCValue(arg, fmt.Sprintf("p%d", i)))
			}
		}
		if result := getReturn(fn.Type); result != nil {
			fmt.Fprint(f, ")")
		}
		fmt.Fprint(f, ")\n")
		fmt.Fprintf(f, "\t\treturn\n")
		fmt.Fprintf(f, "\t}\n")
	}
	fmt.Fprint(f, "}\n")

	return nil
}

func writeGoFunctionArguments(w io.Writer, fn api.Function, flat bool, typeOf func(reflect.Type) string) {
	name := fn.Name
	fmt.Fprint(w, "(")
	do := func(i int, arg reflect.Type) {
		if i > 0 {
			fmt.Fprint(w, ", ")
		}
		if ctype := typeOf(arg); ctype != "" {
			fmt.Fprintf(w, "%s%d %s", "p", i, ctype)
		} else {
			panic(fmt.Sprintf("unsupported type %s for parameter %d in function %s", arg, i, name))
		}
	}
	if flat {
		for i, arg := range args_flat(fn.Type) {
			do(i, arg)
		}
	} else {
		for i := 0; i < fn.Type.NumIn(); i++ {
			do(i, fn.Type.In(i))
		}
	}
	fmt.Fprint(w, ")")
}

func goTypeOf(rtype reflect.Type) string {
	if rtype.PkgPath() != "" {
		return fmt.Sprintf("gdextension.%s", strings.ReplaceAll(rtype.Name(), "graphics.gd/internal/", ""))
	}
	if rtype.Kind() == reflect.Slice && rtype.Elem().Kind() == reflect.Uint8 {
		return "[]byte"
	}
	if rtype.Kind() == reflect.Array {
		return fmt.Sprintf("[%d]%s", rtype.Len(), goTypeOf(rtype.Elem()))
	}
	return fmt.Sprintf("%s", rtype.Name())
}

func toGoValue(rtype reflect.Type) string {
	if rtype.PkgPath() != "" {
		return fmt.Sprintf("gdextension.%s", strings.ReplaceAll(rtype.Name(), "graphics.gd/internal/", ""))
	}
	switch rtype.Kind() {
	case reflect.String:
		return "C.GoString"
	case reflect.Slice:
		if rtype.Elem().Kind() == reflect.Uint8 {
			return "C.GoBytes"
		}
		fallthrough
	default:
		return fmt.Sprintf("%s", rtype.Name())
	}
}

func toCValue(rtype reflect.Type, value string) string {
	switch rtype.Kind() {
	case reflect.String:
		return fmt.Sprintf("C.CString(%s)", value)
	case reflect.UnsafePointer:
		return fmt.Sprintf("unsafe.Pointer(%s)", value)
	case reflect.Slice:
		if rtype.Elem().Kind() == reflect.Uint8 {
			return fmt.Sprintf("(*C.char)(unsafe.Pointer(unsafe.SliceData(%s)))", value)
		}
		fallthrough
	default:
		return fmt.Sprintf("%s(%s)", cgoTypeOf(rtype), value)
	}
}

func args_flat(rtype reflect.Type) iter.Seq2[int, reflect.Type] {
	return func(yield func(int, reflect.Type) bool) {
		var n int
		for i := range rtype.NumIn() {
			arg := rtype.In(i)
			if arg.Kind() == reflect.Array {
				for j := 0; j < arg.Len(); j++ {
					if !yield(n, arg.Elem()) {
						return
					}
					n++
				}
			} else if arg.Kind() == reflect.Slice {
				if !yield(n, arg) {
					return
				}
				if !yield(n+1, reflect.TypeOf(uint64(0))) {
					return
				}
				n += 2
			} else if arg.Kind() == reflect.String {
				if !yield(n, reflect.TypeOf("")) {
					return
				}
				if !yield(n+1, reflect.TypeOf(uint64(0))) {
					return
				}
				n += 2
			} else {
				if !yield(n, arg) {
					return
				}
				n++
			}
		}
	}
}

func getReturn(rtype reflect.Type) reflect.Type {
	var out reflect.Type
	for i := 0; i < rtype.NumOut(); i++ {
		if rtype.Out(i).Size() > 0 {
			out = rtype.Out(i)
			break
		}
	}
	return out
}

func cgoTypeOf(rtype reflect.Type) string {
	switch rtype.Kind() {
	case reflect.String:
		return "*C.char"
	case reflect.UnsafePointer:
		return "*C.void"
	case reflect.Uintptr:
		return "C.uintptr_t"
	case reflect.Array:
		return cgoTypeOf(rtype.Elem())
	case reflect.Slice:
		if rtype.Elem().Kind() == reflect.Uint8 {
			return "*C.char"
		}
		fallthrough
	default:
		return "C." + ctypeOf(rtype)
	}
}

func ctypeOf(rtype reflect.Type) string {
	if rtype.Size() == 0 {
		return ""
	}
	switch rtype.Kind() {
	case reflect.UnsafePointer:
		return "void*"
	case reflect.Uintptr:
		return "uintptr_t"
	case reflect.Uint64:
		return "uint64_t"
	case reflect.Uint32:
		return "uint32_t"
	case reflect.Uint8:
		return "uint8_t"
	case reflect.Uint16:
		return "uint16_t"
	case reflect.Int64:
		return "int64_t"
	case reflect.Int32:
		return "int32_t"
	case reflect.Float32:
		return "float"
	case reflect.Float64:
		return "double"
	case reflect.Bool:
		return "bool"
	case reflect.String:
		return "const char*"
	case reflect.Slice:
		if rtype.Elem().Kind() == reflect.Uint8 {
			return "char*"
		}
		fallthrough
	default:
		panic(fmt.Sprintf("unsupported type %s", rtype))
	}
}

func main() {
	if err := errors.Join(
		generate_header_file(),
		generate_startup_js(),
		generate_startup_cgo(),
		generate_gdextension_web_cgo(),
		generate_gdextension_web_cgo_callbacks(),
	); err != nil {
		fmt.Fprintf(os.Stderr, "Error generating files: %v\n", err)
		os.Exit(1)
	}
}
