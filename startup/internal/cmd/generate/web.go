package main

import (
	"bytes"
	"fmt"
	"os"
	"reflect"
	"strings"

	"graphics.gd/internal/gdextension"
	"runtime.link/api"
)

func generate_gdextension_web_cgo() error {
	f, err := os.Create("./internal/gdextension_web_cgo.cpp")
	if err != nil {
		return err
	}
	defer f.Close()
	existing, err := os.ReadFile("startup_cgo_v2.c")
	if err != nil {
		return err
	}
	_, contents, _ := bytes.Cut(existing, []byte(`#include "_cgo_export.h"`))
	fmt.Fprintln(f, "// Code generated by ./internal/cmd/generate; DO NOT EDIT.")
	fmt.Fprintln(f, `#include "core/extension/gdextension_interface.h"`)
	fmt.Fprintln(f, `#include "gdextension_web_cgo_callbacks.cpp"`)
	fmt.Fprintln(f, `#include <emscripten/bind.h>`)
	f.Write(contents)
	fmt.Fprintln(f)
	fmt.Fprintln(f, `using namespace emscripten;`)
	fmt.Fprintln(f, `EMSCRIPTEN_BINDINGS(my_module) {`)
	for fn := range api.StructureOf(&gdextension.Host).Iter() {
		name := fn.Tags.Get("gd")
		if name == "" {
			continue
		}
		fmt.Fprint(f, "\t")
		fmt.Fprintf(f, `function("gd_%s", &gd_%[1]s, allow_raw_pointers());`, name)
		fmt.Fprint(f, "\n")
	}
	fmt.Fprintln(f, `}`)
	return nil
}

func generate_gdextension_web_cgo_callbacks() error {
	h, err := os.Create("./internal/gdextension_web_cgo_callbacks.cpp")
	if err != nil {
		return err
	}
	defer h.Close()

	fmt.Fprint(h, "// Code generated by ./internal/cmd/generate; DO NOT EDIT.\n")
	fmt.Fprint(h, "#include <stdlib.h>\n#include <stdbool.h>\n#include <emscripten/bind.h>\n\n")

	fmt.Fprint(h, "emscripten::val Go;\n\n")
	fmt.Fprint(h, "void go_on_init(uint32_t level) {")
	fmt.Fprint(h, "\n\tif (level == GDEXTENSION_INITIALIZATION_CORE) Go = emscripten::val::global(\"Go\");\n")
	fmt.Fprint(h, "\tGo.call<void>(\"on_init\", level);\n")
	fmt.Fprint(h, "}\n\n")

	for fn := range api.StructureOf(&gdextension.On).Iter() {
		name := fn.Tags.Get("gd")
		if name == "on_init" {
			continue
		}
		returns := getReturn(fn.Type)
		if returns != nil {
			if ctype := ctypeOf(returns); ctype != "" {
				fmt.Fprintf(h, "%s go_%s(", ctype, name)
			} else {
				return fmt.Errorf("unsupported return type %s for function %s", returns, name)
			}
		} else {
			fmt.Fprintf(h, "void go_%s(", name)
		}
		for i, arg := range args_flat(fn.Type) {
			if i > 0 {
				fmt.Fprint(h, ", ")
			}
			if ctype := ctypeOf(arg); ctype != "" {
				if ctype == "int64_t" || ctype == "uint64_t" {
					ctype = "double"
				}
				fmt.Fprintf(h, "%s p%d", ctype, i)
			} else {
				panic(fmt.Sprintf("unsupported type %s for parameter %d in function %s", arg, i, fn.Tags.Get("gd")))
			}
		}
		fmt.Fprint(h, ") {\n\t")
		if returns != nil {
			if ctype := ctypeOf(returns); ctype != "" {
				fmt.Fprintf(h, "return Go.call<%s", ctype)
			} else {
				return fmt.Errorf("unsupported return type %s for function %s", returns, name)
			}
		} else {
			fmt.Fprint(h, "Go.call<void")
		}
		fmt.Fprintf(h, ">(\"%s\"", name)
		for i, arg := range args_flat(fn.Type) {
			if arg.Kind() == reflect.UnsafePointer {
				fmt.Fprintf(h, ", uintptr_t(p%d)", i)
			} else {
				fmt.Fprintf(h, ",p%d", i)
			}
		}
		fmt.Fprint(h, ");\n")
		fmt.Fprintf(h, "}\n")
	}

	return nil
}

func generate_startup_js() error {
	f, err := os.Create("startup_js_v2.go")
	if err != nil {
		return err
	}
	defer f.Close()

	fmt.Fprint(f, "// Code generated by ./internal/cmd/generate; DO NOT EDIT.\n")
	fmt.Fprint(f, "//go:build js\n\n")
	fmt.Fprint(f, "package startup\n\n")
	fmt.Fprint(f, "import \"graphics.gd/internal/gdextension\"\n\n")
	fmt.Fprint(f, "import \"syscall/js\"\n\n")
	fmt.Fprint(f, "import \"math\"\n")
	fmt.Fprint(f, "import \"unsafe\"\n")

	fmt.Fprint(f, "func init() {\n")

	fmt.Fprint(f, "js.Global().Set(\"Go\", js.Global().Get(\"Object\").New())\n")
	fmt.Fprint(f, "Go := js.Global().Get(\"Go\")\n")
	for fn := range api.StructureOf(&gdextension.On).Iter() {
		name := fn.Tags.Get("gd")
		fmt.Fprintf(f, "\tGo.Set(\"%s\", js.FuncOf(func(self js.Value, args []js.Value) any {\n\t\t", name)
		if result := getReturn(fn.Type); fn.NumOut() == 1 && result != nil {
			fmt.Fprintf(f, "return %s(", jsTypeOf(result))
		} else if fn.NumOut() > 0 && result != nil {
			for i := 0; i < fn.NumOut(); i++ {
				if i > 0 {
					fmt.Fprint(f, ", ")
				}
				if fn.Type.Out(i).Size() > 0 {
					fmt.Fprintf(f, "result")
				} else {
					fmt.Fprint(f, "_")
				}
			}
			fmt.Fprint(f, " := ")
		}
		fmt.Fprintf(f, "gdextension.On.%s(", strings.Join(append(fn.Path, fn.Name), "."))
		var n int
		for i := range fn.NumIn() {
			if n > 0 {
				fmt.Fprint(f, ", ")
			}
			arg := fn.Type.In(i)
			switch arg.Kind() {
			case reflect.Array:
				fmt.Fprintf(f, "%s{", toGoValue(arg))
				for j := 0; j < arg.Len(); j++ {
					if j > 0 {
						fmt.Fprint(f, ", ")
					}
					fmt.Fprintf(f, "%s(%s)", toGoValue(arg.Elem()), fromJS(arg.Elem(), fmt.Sprintf("args[%d]", n)))
					n++
				}
				fmt.Fprint(f, "}")
			default:
				fmt.Fprintf(f, "%s(%s)", toGoValue(arg), fromJS(arg, fmt.Sprintf("args[%d]", n)))
				n++
			}

		}
		if result := getReturn(fn.Type); fn.NumOut() == 1 && result != nil {
			fmt.Fprint(f, "))")
		} else if fn.NumOut() > 0 && result != nil {
			fmt.Fprintf(f, ")\n\t\treturn %s(result)\n", toGoValue(result))
		} else {
			fmt.Fprint(f, ")\n\t\treturn nil\n")
		}
		fmt.Fprint(f, "\t}))\n")
	}
	for fn := range api.StructureOf(&gdextension.Host).Iter() {
		name := fn.Tags.Get("gd")
		if name == "" {
			continue
		}
		fmt.Fprintf(f, "\tgdextension.Host.%s = func", strings.Join(append(fn.Path, fn.Name), "."))
		writeGoFunctionArguments(f, fn, false, goTypeOf)
		if fn.NumOut() > 0 {
			fmt.Fprintf(f, " (")
		}
		for i := 0; i < fn.NumOut(); i++ {
			if i > 0 {
				fmt.Fprint(f, ", ")
			}
			result := fn.Type.Out(i)
			if result.Size() > 0 {
				fmt.Fprintf(f, "result %s", goTypeOf(result))
			} else {
				fmt.Fprintf(f, "_ %s", goTypeOf(result))
			}
		}
		if fn.NumOut() > 0 {
			fmt.Fprintf(f, " )")
		}
		fmt.Fprintf(f, " {\n")
		for i := range fn.NumIn() {
			arg := fn.Type.In(i)
			if arg.Kind() == reflect.Slice {
				fmt.Fprintf(f, "\t\tbuf%d := js.Global().Get(\"Uint8Array\").New(len(p%[1]d))", i)
				fmt.Fprintf(f, "\n\t\tjs.CopyBytesToJS(buf%d, p%[1]d)\n", i)
			}
		}
		if result := getReturn(fn.Type); result != nil {
			fmt.Fprintf(f, "\t\tresult = %s(", goTypeOf(result))
		}
		fmt.Fprintf(f, "\t\tjs.Global().Get(\"GD\").Call(\"%s\"", name)
		for i := range fn.NumIn() {
			fmt.Fprint(f, ", ")
			arg := fn.Type.In(i)
			switch arg.Kind() {
			case reflect.Array:
				for j := 0; j < arg.Len(); j++ {
					if j > 0 {
						fmt.Fprint(f, ", ")
					}
					fmt.Fprint(f, toJSValue(fmt.Sprintf("p%d[%d]", i, j), arg.Elem()))
				}
			case reflect.String:
				fmt.Fprintf(f, "string(p%d), len(p%[1]d)", i)
			case reflect.Slice:
				fmt.Fprintf(f, "buf%d, len(p%d)", i, i)
			default:
				fmt.Fprint(f, toJSValue(fmt.Sprintf("p%d", i), arg))
			}
		}
		if result := getReturn(fn.Type); result != nil {
			fmt.Fprint(f, ")")
			switch result.Kind() {
			case reflect.Uint8, reflect.Uintptr, reflect.Int32, reflect.Int64, reflect.Uint32, reflect.Uint64, reflect.UnsafePointer, reflect.Uint16:
				fmt.Fprintf(f, ".Int()")
			case reflect.Float32, reflect.Float64:
				fmt.Fprintf(f, ".Float()")
			case reflect.Bool:
				fmt.Fprintf(f, ".Bool()")
			}
		}
		fmt.Fprint(f, ")\n")
		for i := range fn.NumIn() {
			arg := fn.Type.In(i)
			if arg.Kind() == reflect.Slice {
				fmt.Fprintf(f, "\t\tjs.CopyBytesToGo(p%[1]d, buf%[1]d)\n", i)
			}
		}
		fmt.Fprintf(f, "\t\treturn\n")
		fmt.Fprintf(f, "\t}\n")
	}
	fmt.Fprint(f, "}\n")

	return nil
}

func jsTypeOf(rtype reflect.Type) string {
	switch rtype.Kind() {
	case reflect.Uintptr:
		return "uint32"
	default:
		return goTypeOf(rtype)
	}
}

func fromJS(rtype reflect.Type, value string) string {
	switch rtype.Kind() {
	case reflect.Uint8, reflect.Uintptr, reflect.Int32, reflect.Int64, reflect.Uint32, reflect.Uint64, reflect.UnsafePointer:
		return fmt.Sprintf("%s.Int()", value)
	case reflect.Bool:
		return fmt.Sprintf("%s.Bool()", value)
	default:
		return value
	}
}

func toJSValue(value string, rtype reflect.Type) string {
	switch rtype.Kind() {
	case reflect.Int32, reflect.Uint32:
		return fmt.Sprintf("%s(%s)", strings.ToLower(rtype.Kind().String()), value)
	case reflect.Uintptr, reflect.UnsafePointer:
		return fmt.Sprintf("uint32(%s)", value)
	case reflect.Int64, reflect.Uint64:
		return fmt.Sprintf("math.Float64frombits(*(*uint64)(unsafe.Pointer(&%s)))", value)
	default:
		return value
	}
}
