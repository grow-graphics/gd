package main

import (
	"fmt"
	"os"
	"reflect"
	"strings"

	"graphics.gd/internal/gdextension"
	"graphics.gd/variant/Color"
	"graphics.gd/variant/Vector2"
	"graphics.gd/variant/Vector3"
	"graphics.gd/variant/Vector4"
	"runtime.link/api"
)

func generate_gdextension_web_cgo_callbacks() error {
	h, err := os.Create("./internal/gdextension_web_cgo_callbacks.cpp")
	if err != nil {
		return err
	}
	defer h.Close()

	fmt.Fprint(h, "// Code generated by ./internal/cmd/generate; DO NOT EDIT.\n")
	fmt.Fprint(h, "#include <stdlib.h>\n#include <stdbool.h>\n#include <emscripten/bind.h>\n\n")

	fmt.Fprint(h, "emscripten::val Go;\n\n")
	fmt.Fprint(h, "void go_on_init(uint32_t level) {")
	fmt.Fprint(h, "\n\tif (level == GDEXTENSION_INITIALIZATION_CORE) Go = emscripten::val::global(\"GO\");\n")
	fmt.Fprint(h, "\tGo.call<void>(\"on_init\", level);\n")
	fmt.Fprint(h, "}\n\n")

	for fn := range api.StructureOf(&gdextension.On).Iter() {
		name := fn.Tags.Get("gd")
		if name == "on_init" {
			continue
		}
		returns := getReturn(fn.Type)
		if returns != nil {
			if returns == reflect.TypeFor[int]() {
				returns = reflect.TypeFor[int32]()
			}
			if ctype := ctypeOf(returns); ctype != "" {
				fmt.Fprintf(h, "%s go_%s(", ctype, name)
			} else {
				return fmt.Errorf("unsupported return type %s for function %s", returns, name)
			}
		} else {
			fmt.Fprintf(h, "void go_%s(", name)
		}
		for i, arg := range args_flat(fn.Type) {
			if i > 0 {
				fmt.Fprint(h, ", ")
			}
			if ctype := ctypeOf(arg); ctype != "" {
				if ctype == "int64_t" || ctype == "uint64_t" {
					ctype = "double"
				}
				fmt.Fprintf(h, "%s p%d", ctype, i)
			} else {
				panic(fmt.Sprintf("unsupported type %s for parameter %d in function %s", arg, i, fn.Tags.Get("gd")))
			}
		}
		fmt.Fprint(h, ") {\n\t")
		if returns != nil {
			if returns == reflect.TypeFor[int]() {
				returns = reflect.TypeFor[int32]()
			}
			if ctype := ctypeOf(returns); ctype != "" {
				goType := ctype
				if ctype == "int64_t" || ctype == "uint64_t" {
					goType = "double"
				}
				cast := ""
				if goType != ctype {
					cast = fmt.Sprintf("std::__bit_cast<%s>(", ctype)
				}
				fmt.Fprintf(h, "return %sGo.call<%s", cast, goType)
			} else {
				return fmt.Errorf("unsupported return type %s for function %s", returns, name)
			}
		} else {
			fmt.Fprint(h, "Go.call<void")
		}
		fmt.Fprintf(h, ">(\"%s\"", name)
		for i, arg := range args_flat(fn.Type) {
			if arg.Kind() == reflect.UnsafePointer {
				fmt.Fprintf(h, ", uintptr_t(p%d)", i)
			} else {
				fmt.Fprintf(h, ",p%d", i)
			}
		}
		if returns != nil {
			if ctype := ctypeOf(returns); ctype != "" {
				goType := ctype
				if ctype == "int64_t" || ctype == "uint64_t" {
					goType = "double"
				}
				if goType != ctype {
					fmt.Fprintf(h, ")")
				}
			}
		}
		fmt.Fprint(h, ");\n")
		fmt.Fprintf(h, "}\n")
	}

	return nil
}

func generate_startup_js() error {
	f, err := os.Create("startup_js_v2.go")
	if err != nil {
		return err
	}
	defer f.Close()

	fmt.Fprint(f, "// Code generated by ./internal/cmd/generate; DO NOT EDIT.\n")
	fmt.Fprint(f, "//go:build js\n\n")
	fmt.Fprint(f, "package startup\n\n")
	fmt.Fprint(f, "import \"graphics.gd/internal/gdextension\"\n\n")
	fmt.Fprintln(f, `import "graphics.gd/internal/gdmemory"`)
	fmt.Fprint(f, "import \"syscall/js\"\n\n")
	fmt.Fprint(f, "import \"math\"\n")
	fmt.Fprint(f, "import \"unsafe\"\n")
	fmt.Fprint(f, "import \"sync\"\n\n")

	fmt.Fprint(f, "func init() {\n")

	fmt.Fprint(f, "js.Global().Set(\"GO\", js.Global().Get(\"Object\").New())\n")
	fmt.Fprint(f, "Go := js.Global().Get(\"GO\")\n")

	fmt.Fprint(f, "var (\n")
	for fn := range api.StructureOf(&gdextension.Host).Iter() {
		name := fn.Tags.Get("gd")
		fmt.Fprintf(f, "gd_%s js.Value\n", name)
	}
	fmt.Fprint(f, ")\nsetup := sync.OnceFunc(func() {\n")
	fmt.Fprintln(f, `GD := js.Global().Get("GD")`)
	for fn := range api.StructureOf(&gdextension.Host).Iter() {
		name := fn.Tags.Get("gd")
		fmt.Fprintf(f, `gd_%s = GD.Get("%[1]s")`, name)
		fmt.Fprintln(f)
	}
	fmt.Fprint(f, "})\n")

	for fn := range api.StructureOf(&gdextension.On).Iter() {
		name := fn.Tags.Get("gd")
		fmt.Fprintf(f, "\tGo.Set(\"%s\", js.FuncOf(func(self js.Value, args []js.Value) any {\n\t\t", name)
		if result := getReturn(fn.Type); fn.NumOut() == 1 && result != nil {
			fmt.Fprintf(f, "return %s(", jsTypeOf(result))
		} else if fn.NumOut() > 0 && result != nil {
			for i := 0; i < fn.NumOut(); i++ {
				if i > 0 {
					fmt.Fprint(f, ", ")
				}
				if fn.Type.Out(i).Size() > 0 {
					fmt.Fprintf(f, "result")
				} else {
					fmt.Fprint(f, "_")
				}
			}
			fmt.Fprint(f, " := ")
		}
		fmt.Fprintf(f, "gdextension.On.%s(", strings.Join(append(fn.Path, fn.Name), "."))
		var n int
		for i := range fn.NumIn() {
			if n > 0 {
				fmt.Fprint(f, ", ")
			}
			arg := fn.Type.In(i)
			switch arg.Kind() {
			case reflect.Array:
				length := arg.Len()
				if strings.HasPrefix(arg.Name(), "PackedArray[") {
					length = 1
				}
				fmt.Fprintf(f, "%s{", toGoValue(arg))
				for j := 0; j < length; j++ {
					if j > 0 {
						fmt.Fprint(f, ", ")
					}
					fmt.Fprintf(f, "%s(%s)", toGoValue(arg.Elem()), fromJS(arg.Elem(), fmt.Sprintf("args[%d]", n)))
					n++
				}
				fmt.Fprint(f, "}")
			default:
				fmt.Fprintf(f, "%s(%s)", toGoValue(arg), fromJS(arg, fmt.Sprintf("args[%d]", n)))
				n++
			}

		}
		if result := getReturn(fn.Type); fn.NumOut() == 1 && result != nil {
			fmt.Fprint(f, "))")
		} else if fn.NumOut() > 0 && result != nil {
			fmt.Fprintf(f, ")\n\t\treturn %s(result)\n", toGoValue(result))
		} else {
			fmt.Fprint(f, ")\n\t\treturn nil\n")
		}
		fmt.Fprint(f, "\t}))\n")
	}
	for fn := range api.StructureOf(&gdextension.Host).Iter() {
		name := fn.Tags.Get("gd")
		if name == "" {
			continue
		}
		fmt.Fprintf(f, "\tgdextension.Host.%s = func", strings.Join(append(fn.Path, fn.Name), "."))
		writeGoFunctionArguments(f, fn, false, goTypeOf)
		if fn.NumOut() > 0 {
			fmt.Fprintf(f, " (")
		}
		for i := 0; i < fn.NumOut(); i++ {
			if i > 0 {
				fmt.Fprint(f, ", ")
			}
			result := fn.Type.Out(i)
			if result.Size() > 0 {
				fmt.Fprintf(f, "result %s", goTypeOf(result))
			} else {
				fmt.Fprintf(f, "_ %s", goTypeOf(result))
			}
		}
		if fn.NumOut() > 0 {
			fmt.Fprintf(f, " )")
		}
		fmt.Fprintf(f, " {\nsetup()\n")
		for i := range fn.NumIn() {
			arg := fn.Type.In(i)
			if arg.Kind() == reflect.Slice {
				fmt.Fprintf(f, "\t\tbuf%d := gdmemory.CopyBufferToEngine(p%[1]d)\n", i)
			}
			if strings.HasPrefix(arg.Name(), "PackedArray[") {
				fmt.Fprintf(f, "\t\tpak%d := p%[1]d.JS()\n", i)
			}
			if arg.Kind() == reflect.UnsafePointer {
				switch arg {
				case reflect.TypeFor[gdextension.CallAccepts[any]]():
					fmt.Fprintf(f, "\t\tmem%d := gdmemory.CopyArguments(shape, p%[1]d)\n", i)
				case reflect.TypeFor[gdextension.CallReturns[any]]():
					fmt.Fprintf(f, "\t\tmem%d := gdmemory.MakeResult(shape)\n", i)
				case reflect.TypeFor[gdextension.CallAccepts[gdextension.Variant]]():
					fmt.Fprintf(f, "\t\tmem%d := gdmemory.CopyVariants(p%[1]d, p%d)\n", i, i-1)
				case reflect.TypeFor[gdextension.CallReturns[gdextension.Variant]](), reflect.TypeFor[gdextension.CallReturns[gdextension.Iterator]]():
					fmt.Fprintf(f, "\t\tmem%d := gdmemory.MakeResult(gdextension.SizeVariant)\n", i)
				case reflect.TypeFor[gdextension.CallReturns[gdextension.CallError]](), reflect.TypeFor[gdextension.CallReturns[Vector3.XYZ]]():
					fmt.Fprintf(f, "\t\tmem%d := gdmemory.MakeResult(gdextension.SizeVariant)\n", i)
				case reflect.TypeFor[gdextension.CallReturns[Vector2.XY]]():
					fmt.Fprintf(f, "\t\tmem%d := gdmemory.MakeResult(gdextension.SizeVector2)\n", i)
				case reflect.TypeFor[gdextension.CallReturns[gdextension.Callable]]():
					fmt.Fprintf(f, "\t\tmem%d := gdmemory.MakeResult(gdextension.SizeCallable)\n", i)
				case reflect.TypeFor[gdextension.CallReturns[Color.RGBA]]():
					fmt.Fprintf(f, "\t\tmem%d := gdmemory.MakeResult(gdextension.SizeColor)\n", i)
				case reflect.TypeFor[gdextension.CallReturns[Vector4.XYZW]]():
					fmt.Fprintf(f, "\t\tmem%d := gdmemory.MakeResult(gdextension.SizeVector4)\n", i)
				case reflect.TypeFor[gdextension.CallMutates[any]]():
					fmt.Fprintf(f, "\t\tmem%d := gdmemory.CopyReceiver(shape, p%[1]d)\n", i)
				case reflect.TypeFor[gdextension.CallMutates[gdextension.Iterator]]():
					fmt.Fprintf(f, "\t\tmem%d := gdmemory.CopyReceiver(gdextension.SizeVariant, p%[1]d)\n", i)
				}
			}
		}
		if result := getReturn(fn.Type); result != nil {
			switch result.Kind() {
			case reflect.Uint64:
				fmt.Fprintf(f, "\t\tresult = %s(math.Float64bits(", goTypeOf(result))
			case reflect.Int64:
				fmt.Fprintf(f, "\t\tresult = %s(gdmemory.Int64frombits(math.Float64bits(", goTypeOf(result))
			case reflect.Array:
				fmt.Fprintf(f, "\t\tresult = %s{%s(", goTypeOf(result), goTypeOf(result.Elem()))
			default:
				fmt.Fprintf(f, "\t\tresult = %s(", goTypeOf(result))
			}
		}
		fmt.Fprintf(f, "gd_%s.Invoke(", name)
		for i := range fn.NumIn() {
			if i > 0 {
				fmt.Fprint(f, ", ")
			}
			arg := fn.Type.In(i)
			switch arg.Kind() {
			case reflect.Array:
				var length = arg.Len()
				if strings.HasPrefix(arg.Name(), "PackedArray[") {
					fmt.Fprintf(f, "pak%d[0], pak%[1]d[1]", i)
				} else {
					for j := range length {
						if j > 0 {
							fmt.Fprint(f, ", ")
						}
						fmt.Fprint(f, toJSValue(fmt.Sprintf("p%d[%d]", i, j), arg.Elem()))
					}
				}
			case reflect.String:
				fmt.Fprintf(f, "string(p%d), len(p%[1]d)", i)
			case reflect.Slice:
				fmt.Fprintf(f, "uint32(buf%d), len(p%d)", i, i)
			case reflect.UnsafePointer:
				fmt.Fprintf(f, "uint32(mem%d)", i)
			default:
				fmt.Fprint(f, toJSValue(argName(arg, i), arg))
			}
		}
		if result := getReturn(fn.Type); result != nil {

			switch result.Kind() {
			case reflect.Uint8, reflect.Uintptr, reflect.Int32, reflect.Uint32, reflect.UnsafePointer, reflect.Uint16, reflect.Int:
				fmt.Fprintf(f, ").Int())")
			case reflect.Float32, reflect.Float64:
				fmt.Fprintf(f, ").Float())")
			case reflect.Bool:
				fmt.Fprintf(f, ").Bool())")
			case reflect.Int64:
				fmt.Fprintf(f, ").Float())))")
			case reflect.Uint64:
				fmt.Fprintf(f, ").Float()))")
			case reflect.Array:
				fmt.Fprintf(f, ")")
				switch result.Elem().Kind() {
				case reflect.Uint8, reflect.Uintptr, reflect.Int32, reflect.Uint32, reflect.UnsafePointer, reflect.Uint16, reflect.Int:
					fmt.Fprintf(f, ".Int()")
				case reflect.Float32, reflect.Float64:
					fmt.Fprintf(f, ".Float()")
				case reflect.Bool:
					fmt.Fprintf(f, ".Bool()")
				}
				fmt.Fprintf(f, ")}")

			default:
				fmt.Fprintf(f, "))")
			}
		} else {
			fmt.Fprint(f, ")")
		}
		fmt.Fprintln(f)
		for i := range fn.NumIn() {
			arg := fn.Type.In(i)
			if arg.Kind() == reflect.Slice {
				fmt.Fprintf(f, "\t\tgdmemory.CopyBufferToGo(buf%[1]d, p%[1]d)\n", i)
			}
			if arg.Kind() == reflect.UnsafePointer {
				switch arg {
				case reflect.TypeFor[gdextension.CallReturns[any]]():
					fmt.Fprintf(f, "\t\tgdmemory.LoadResult(shape, p%d, mem%[1]d)\n", i)
				case reflect.TypeFor[gdextension.CallReturns[gdextension.Variant]](), reflect.TypeFor[gdextension.CallReturns[gdextension.Iterator]]():
					fmt.Fprintf(f, "\t\tgdmemory.LoadResult(gdextension.SizeVariant, p%d, mem%[1]d)\n", i)
				case reflect.TypeFor[gdextension.CallReturns[gdextension.CallError]](), reflect.TypeFor[gdextension.CallReturns[Vector3.XYZ]]():
					fmt.Fprintf(f, "\t\tgdmemory.LoadResult(gdextension.SizeVector3, p%d, mem%[1]d)\n", i)
				case reflect.TypeFor[gdextension.CallReturns[Vector2.XY]]():
					fmt.Fprintf(f, "\t\tgdmemory.LoadResult(gdextension.SizeVector2, p%d, mem%[1]d)\n", i)
				case reflect.TypeFor[gdextension.CallReturns[gdextension.Callable]]():
					fmt.Fprintf(f, "\t\tgdmemory.LoadResult(gdextension.SizeCallable, p%d, mem%[1]d)\n", i)
				case reflect.TypeFor[gdextension.CallReturns[Color.RGBA]]():
					fmt.Fprintf(f, "\t\tgdmemory.LoadResult(gdextension.SizeColor, p%d, mem%[1]d)\n", i)
				case reflect.TypeFor[gdextension.CallReturns[Vector4.XYZW]]():
					fmt.Fprintf(f, "\t\tgdmemory.LoadResult(gdextension.SizeVector4, p%d, mem%[1]d)\n", i)
				case reflect.TypeFor[gdextension.CallMutates[any]]():
					fmt.Fprintf(f, "\t\tgdmemory.LoadResult(shape>>4, p%d, mem%[1]d)\n", i)
				case reflect.TypeFor[gdextension.CallMutates[gdextension.Iterator]]():
					fmt.Fprintf(f, "\t\tgdmemory.LoadResult(gdextension.SizeVariant, p%d, mem%[1]d)\n", i)
				}
			}
		}
		fmt.Fprintf(f, "\t\treturn\n")
		fmt.Fprintf(f, "\t}\n")
	}
	fmt.Fprint(f, "}\n")

	return nil
}

func jsTypeOf(rtype reflect.Type) string {
	switch rtype.Kind() {
	case reflect.Uintptr:
		return "uint32"
	default:
		return goTypeOf(rtype)
	}
}

func fromJS(rtype reflect.Type, value string) string {
	switch rtype.Kind() {
	case reflect.Uint8, reflect.Uintptr, reflect.Int32, reflect.Uint32, reflect.UnsafePointer, reflect.Int:
		return fmt.Sprintf("%s.Int()", value)
	case reflect.Bool:
		return fmt.Sprintf("%s.Bool()", value)
	case reflect.Uint64:
		return fmt.Sprintf("math.Float64bits(%s.Float())", value)
	case reflect.Int64:
		return fmt.Sprintf("gdmemory.Int64frombits(math.Float64bits(%s.Float()))", value)
	default:
		return value
	}
}

func toJSValue(value string, rtype reflect.Type) string {
	if strings.HasPrefix(rtype.Name(), "PackedArray[") {
		return toJSValue(value, reflect.TypeFor[[1]uint64]())
	}
	if rtype == reflect.TypeFor[gdextension.Pointer]() {
		return toJSValue(value, reflect.TypeFor[uint32]())
	}
	switch rtype.Kind() {
	case reflect.Int32, reflect.Uint32:
		return fmt.Sprintf("%s(%s)", strings.ToLower(rtype.Kind().String()), value)
	case reflect.Uintptr, reflect.UnsafePointer:
		return fmt.Sprintf("uint32(%s)", value)
	case reflect.Int64, reflect.Uint64:
		return fmt.Sprintf("math.Float64frombits(*(*uint64)(unsafe.Pointer(&%s)))", value)
	default:
		return value
	}
}
