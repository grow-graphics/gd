---
title: The Development Workflow
slug: guide/workflow
sidebar:
  order: 10
---
import { Aside } from '@astrojs/starlight/components';
import { Badge } from '@astrojs/starlight/components';

You can add `graphics.gd` to your Go project by running `go get -u graphics.gd@release`, run
this whenever you want to update to the latest rolling release version of `graphics.gd`.

<Aside>
    Don't forget to update the `gd` command too! It doesn't stay in sync automatically.
    Run `go install graphics.gd/cmd/gd@release` outside of your project directory to do this.
</Aside>

### Best Practices

Start with a `main.go` file, model your project in Go using structs to represent the
world, space or state of your project. With its simple type-safe syntax, Go is an
excellent language for theory building and conceptual representation.

```go
package idea

import "graphics.gd/classdb/Node"

type Project struct {
	Node.Extension[Project]
}
````

Keep creating more data structures to represent the concepts of what you are aiming to
build. Explore the `classdb` to discover all the functionality the engine provides.
Think about how you can use these features to build your project.

When you want to organise the visual appearance of the project, use the `gd` command to
launch the engine's editor. The editor is excellent for importing media, managing assets
and designing the visual + spatial elements of your project.


### Hot Reloads <Badge text="planned feature" variant="note" />
<Aside type="caution">
    This feature is not available yet but you can still use the information here to help inform
    the architecture of your project in case you want to be able to levarage hot reloading as
    soon as it becomes supported.
</Aside>

`graphics.gd` aims to support hot-reloading during `gd` or `gd run` so that when you
make any changes to Go source files whilst the project or editor is running, they will
be recompiled into either a wasm binary or a Go plugin and the running application will
switch over to using any newly compiled code.

If you stick to using exported struct fields, `startup.Scene` and avoid depending on
globals or anonymous functions, this may "just work" for you, otherwise, if you are using
`startup.Rendering` or require globals or persistent callables, then there will be internal
state not available to the new version of the code. Register `startup.OnSuspend` and
`startup.OnRestore` functions to coordinate and transfer this state.

If any non-serializable state is required for specific class extensions, you can also implement
`Suspend(Dictionary.Any)` and `Restore(Dictionary.Any)` methods in order to record any required
information to reconstruct this state.

Each hot-reload will permanently increase memory usage until the application is restarted.
This feature is only available for the purpose of convenience and to keep the editor running
whilst editing code, do not expect the equivalent runtime performance of a freshly launched application.

### Snapshots <Badge text="planned feature" variant="note" />
<Aside type="caution">
    This feature is not available yet but you can still use the information here to help inform
    the architecture of your project in case you want to be able to levarage shapshots as
    soon as they become available.
</Aside>

As a consequence of supporting hot-reloads, `graphics.gd` will also feature the functionality to take
snapshots of the entire application state, as if it were being hot-reloaded. This enables an application
to be resumed from a previously captured state. The same limitations apply to snapshots as to
hot-reloads.

Snapshots will be suitable to use as a quick save/load function for an application. On mobile platforms,
snapshots can be used to preserve application state when the device sleeps or the application is suspended.
