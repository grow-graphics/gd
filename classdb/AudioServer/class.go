// Code generated by the generate package DO NOT EDIT

// Package AudioServer provides methods for working with AudioServer object instances.
package AudioServer

import "unsafe"
import "sync"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/AudioBusLayout"
import "graphics.gd/classdb/AudioEffect"
import "graphics.gd/classdb/AudioEffectInstance"
import "graphics.gd/classdb/AudioStream"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
[AudioServer] is a low-level server interface for audio access. It is in charge of creating sample data (playable audio) as well as its playback via a voice interface.
*/
type Instance [1]gdclass.AudioServer

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	set_bus_count                         gdextension.MethodForClass `hash:"1286410249"`
	get_bus_count                         gdextension.MethodForClass `hash:"3905245786"`
	remove_bus                            gdextension.MethodForClass `hash:"1286410249"`
	add_bus                               gdextension.MethodForClass `hash:"1025054187"`
	move_bus                              gdextension.MethodForClass `hash:"3937882851"`
	set_bus_name                          gdextension.MethodForClass `hash:"501894301"`
	get_bus_name                          gdextension.MethodForClass `hash:"844755477"`
	get_bus_index                         gdextension.MethodForClass `hash:"2458036349"`
	get_bus_channels                      gdextension.MethodForClass `hash:"923996154"`
	set_bus_volume_db                     gdextension.MethodForClass `hash:"1602489585"`
	get_bus_volume_db                     gdextension.MethodForClass `hash:"2339986948"`
	set_bus_volume_linear                 gdextension.MethodForClass `hash:"1602489585"`
	get_bus_volume_linear                 gdextension.MethodForClass `hash:"2339986948"`
	set_bus_send                          gdextension.MethodForClass `hash:"3780747571"`
	get_bus_send                          gdextension.MethodForClass `hash:"659327637"`
	set_bus_solo                          gdextension.MethodForClass `hash:"300928843"`
	is_bus_solo                           gdextension.MethodForClass `hash:"1116898809"`
	set_bus_mute                          gdextension.MethodForClass `hash:"300928843"`
	is_bus_mute                           gdextension.MethodForClass `hash:"1116898809"`
	set_bus_bypass_effects                gdextension.MethodForClass `hash:"300928843"`
	is_bus_bypassing_effects              gdextension.MethodForClass `hash:"1116898809"`
	add_bus_effect                        gdextension.MethodForClass `hash:"4068819785"`
	remove_bus_effect                     gdextension.MethodForClass `hash:"3937882851"`
	get_bus_effect_count                  gdextension.MethodForClass `hash:"3744713108"`
	get_bus_effect                        gdextension.MethodForClass `hash:"726064442"`
	get_bus_effect_instance               gdextension.MethodForClass `hash:"1829771234"`
	swap_bus_effects                      gdextension.MethodForClass `hash:"1649997291"`
	set_bus_effect_enabled                gdextension.MethodForClass `hash:"1383440665"`
	is_bus_effect_enabled                 gdextension.MethodForClass `hash:"2522259332"`
	get_bus_peak_volume_left_db           gdextension.MethodForClass `hash:"3085491603"`
	get_bus_peak_volume_right_db          gdextension.MethodForClass `hash:"3085491603"`
	set_playback_speed_scale              gdextension.MethodForClass `hash:"373806689"`
	get_playback_speed_scale              gdextension.MethodForClass `hash:"1740695150"`
	lock                                  gdextension.MethodForClass `hash:"3218959716"`
	unlock                                gdextension.MethodForClass `hash:"3218959716"`
	get_speaker_mode                      gdextension.MethodForClass `hash:"2549190337"`
	get_mix_rate                          gdextension.MethodForClass `hash:"1740695150"`
	get_input_mix_rate                    gdextension.MethodForClass `hash:"1740695150"`
	get_driver_name                       gdextension.MethodForClass `hash:"201670096"`
	get_output_device_list                gdextension.MethodForClass `hash:"2981934095"`
	get_output_device                     gdextension.MethodForClass `hash:"2841200299"`
	set_output_device                     gdextension.MethodForClass `hash:"83702148"`
	get_time_to_next_mix                  gdextension.MethodForClass `hash:"1740695150"`
	get_time_since_last_mix               gdextension.MethodForClass `hash:"1740695150"`
	get_output_latency                    gdextension.MethodForClass `hash:"1740695150"`
	get_input_device_list                 gdextension.MethodForClass `hash:"2981934095"`
	get_input_device                      gdextension.MethodForClass `hash:"2841200299"`
	set_input_device                      gdextension.MethodForClass `hash:"83702148"`
	set_bus_layout                        gdextension.MethodForClass `hash:"3319058824"`
	generate_bus_layout                   gdextension.MethodForClass `hash:"3769973890"`
	set_enable_tagging_used_audio_streams gdextension.MethodForClass `hash:"2586408642"`
	is_stream_registered_as_sample        gdextension.MethodForClass `hash:"500225754"`
	register_stream_as_sample             gdextension.MethodForClass `hash:"2210767741"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("AudioServer")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		gdextension.Free(gdextension.TypeStringName, &sname)
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

var self [1]gdclass.AudioServer
var once sync.Once

func singleton() {
	self[0] = pointers.Raw[gdclass.AudioServer]([3]uint64{uint64(gdextension.Host.Objects.Global(sname))})
}

/*
Removes the bus at index [param index].
*/
func RemoveBus(index Bus) { //gd:AudioServer.remove_bus
	once.Do(singleton)
	Advanced().RemoveBus(int64(index))
}

/*
Adds a bus at [param at_position].
*/
func AddBus() { //gd:AudioServer.add_bus
	once.Do(singleton)
	Advanced().AddBus(int64(-1))
}

/*
Adds a bus at [param at_position].
*/
func AddBusOptions(at_position int) { //gd:AudioServer.add_bus
	once.Do(singleton)
	Advanced().AddBus(int64(at_position))
}

/*
Moves the bus from index [param index] to index [param to_index].
*/
func MoveBus(index Bus, to_index Bus) { //gd:AudioServer.move_bus
	once.Do(singleton)
	Advanced().MoveBus(int64(index), int64(to_index))
}

/*
Sets the name of the bus at index [param bus_idx] to [param name].
*/
func SetBusName(bus_idx Bus, name string) { //gd:AudioServer.set_bus_name
	once.Do(singleton)
	Advanced().SetBusName(int64(bus_idx), String.New(name))
}

/*
Returns the name of the bus with the index [param bus_idx].
*/
func GetBusName(bus_idx Bus) string { //gd:AudioServer.get_bus_name
	once.Do(singleton)
	return string(Advanced().GetBusName(int64(bus_idx)).String())
}

/*
Returns the index of the bus with the name [param bus_name]. Returns [code]-1[/code] if no bus with the specified name exist.
*/
func GetBusIndex(bus_name string) int { //gd:AudioServer.get_bus_index
	once.Do(singleton)
	return int(int(Advanced().GetBusIndex(String.Name(String.New(bus_name)))))
}

/*
Returns the number of channels of the bus at index [param bus_idx].
*/
func GetBusChannels(bus_idx Bus) int { //gd:AudioServer.get_bus_channels
	once.Do(singleton)
	return int(int(Advanced().GetBusChannels(int64(bus_idx))))
}

/*
Sets the volume in decibels of the bus at index [param bus_idx] to [param volume_db].
*/
func SetBusVolumeDb(bus_idx Bus, volume_db Float.X) { //gd:AudioServer.set_bus_volume_db
	once.Do(singleton)
	Advanced().SetBusVolumeDb(int64(bus_idx), float64(volume_db))
}

/*
Returns the volume of the bus at index [param bus_idx] in dB.
*/
func GetBusVolumeDb(bus_idx Bus) Float.X { //gd:AudioServer.get_bus_volume_db
	once.Do(singleton)
	return Float.X(Float.X(Advanced().GetBusVolumeDb(int64(bus_idx))))
}

/*
Sets the volume as a linear value of the bus at index [param bus_idx] to [param volume_linear].
[b]Note:[/b] Using this method is equivalent to calling [method set_bus_volume_db] with the result of [method @GlobalScope.linear_to_db] on a value.
*/
func SetBusVolumeLinear(bus_idx Bus, volume_linear Float.X) { //gd:AudioServer.set_bus_volume_linear
	once.Do(singleton)
	Advanced().SetBusVolumeLinear(int64(bus_idx), float64(volume_linear))
}

/*
Returns the volume of the bus at index [param bus_idx] as a linear value.
[b]Note:[/b] The returned value is equivalent to the result of [method @GlobalScope.db_to_linear] on the result of [method get_bus_volume_db].
*/
func GetBusVolumeLinear(bus_idx Bus) Float.X { //gd:AudioServer.get_bus_volume_linear
	once.Do(singleton)
	return Float.X(Float.X(Advanced().GetBusVolumeLinear(int64(bus_idx))))
}

/*
Connects the output of the bus at [param bus_idx] to the bus named [param send].
*/
func SetBusSend(bus_idx Bus, send string) { //gd:AudioServer.set_bus_send
	once.Do(singleton)
	Advanced().SetBusSend(int64(bus_idx), String.Name(String.New(send)))
}

/*
Returns the name of the bus that the bus at index [param bus_idx] sends to.
*/
func GetBusSend(bus_idx Bus) string { //gd:AudioServer.get_bus_send
	once.Do(singleton)
	return string(Advanced().GetBusSend(int64(bus_idx)).String())
}

/*
If [code]true[/code], the bus at index [param bus_idx] is in solo mode.
*/
func SetBusSolo(bus_idx Bus, enable bool) { //gd:AudioServer.set_bus_solo
	once.Do(singleton)
	Advanced().SetBusSolo(int64(bus_idx), enable)
}

/*
If [code]true[/code], the bus at index [param bus_idx] is in solo mode.
*/
func IsBusSolo(bus_idx Bus) bool { //gd:AudioServer.is_bus_solo
	once.Do(singleton)
	return bool(Advanced().IsBusSolo(int64(bus_idx)))
}

/*
If [code]true[/code], the bus at index [param bus_idx] is muted.
*/
func SetBusMute(bus_idx Bus, enable bool) { //gd:AudioServer.set_bus_mute
	once.Do(singleton)
	Advanced().SetBusMute(int64(bus_idx), enable)
}

/*
If [code]true[/code], the bus at index [param bus_idx] is muted.
*/
func IsBusMute(bus_idx Bus) bool { //gd:AudioServer.is_bus_mute
	once.Do(singleton)
	return bool(Advanced().IsBusMute(int64(bus_idx)))
}

/*
If [code]true[/code], the bus at index [param bus_idx] is bypassing effects.
*/
func SetBusBypassEffects(bus_idx Bus, enable bool) { //gd:AudioServer.set_bus_bypass_effects
	once.Do(singleton)
	Advanced().SetBusBypassEffects(int64(bus_idx), enable)
}

/*
If [code]true[/code], the bus at index [param bus_idx] is bypassing effects.
*/
func IsBusBypassingEffects(bus_idx Bus) bool { //gd:AudioServer.is_bus_bypassing_effects
	once.Do(singleton)
	return bool(Advanced().IsBusBypassingEffects(int64(bus_idx)))
}

/*
Adds an [AudioEffect] effect to the bus [param bus_idx] at [param at_position].
*/
func AddBusEffect(bus_idx Bus, effect AudioEffect.Instance) { //gd:AudioServer.add_bus_effect
	once.Do(singleton)
	Advanced().AddBusEffect(int64(bus_idx), effect, int64(-1))
}

/*
Adds an [AudioEffect] effect to the bus [param bus_idx] at [param at_position].
*/
func AddBusEffectOptions(bus_idx Bus, effect AudioEffect.Instance, at_position int) { //gd:AudioServer.add_bus_effect
	once.Do(singleton)
	Advanced().AddBusEffect(int64(bus_idx), effect, int64(at_position))
}

/*
Removes the effect at index [param effect_idx] from the bus at index [param bus_idx].
*/
func RemoveBusEffect(bus_idx Bus, effect_idx Effect) { //gd:AudioServer.remove_bus_effect
	once.Do(singleton)
	Advanced().RemoveBusEffect(int64(bus_idx), int64(effect_idx))
}

/*
Returns the number of effects on the bus at [param bus_idx].
*/
func GetBusEffectCount(bus_idx Bus) int { //gd:AudioServer.get_bus_effect_count
	once.Do(singleton)
	return int(int(Advanced().GetBusEffectCount(int64(bus_idx))))
}

/*
Returns the [AudioEffect] at position [param effect_idx] in bus [param bus_idx].
*/
func GetBusEffect(bus_idx Bus, effect_idx Effect) AudioEffect.Instance { //gd:AudioServer.get_bus_effect
	once.Do(singleton)
	return AudioEffect.Instance(Advanced().GetBusEffect(int64(bus_idx), int64(effect_idx)))
}

/*
Returns the [AudioEffectInstance] assigned to the given bus and effect indices (and optionally channel).
*/
func GetBusEffectInstance(bus_idx Bus, effect_idx Effect, channel int) AudioEffectInstance.Instance { //gd:AudioServer.get_bus_effect_instance
	once.Do(singleton)
	return AudioEffectInstance.Instance(Advanced().GetBusEffectInstance(int64(bus_idx), int64(effect_idx), int64(channel)))
}

/*
Returns the [AudioEffectInstance] assigned to the given bus and effect indices (and optionally channel).
*/
func GetBusEffectInstanceOptions(bus_idx Bus, effect_idx Effect, channel int) AudioEffectInstance.Instance { //gd:AudioServer.get_bus_effect_instance
	once.Do(singleton)
	return AudioEffectInstance.Instance(Advanced().GetBusEffectInstance(int64(bus_idx), int64(effect_idx), int64(channel)))
}

/*
Swaps the position of two effects in bus [param bus_idx].
*/
func SwapBusEffects(bus_idx Bus, effect_idx Effect, by_effect_idx Effect) { //gd:AudioServer.swap_bus_effects
	once.Do(singleton)
	Advanced().SwapBusEffects(int64(bus_idx), int64(effect_idx), int64(by_effect_idx))
}

/*
If [code]true[/code], the effect at index [param effect_idx] on the bus at index [param bus_idx] is enabled.
*/
func SetBusEffectEnabled(bus_idx Bus, effect_idx Effect, enabled bool) { //gd:AudioServer.set_bus_effect_enabled
	once.Do(singleton)
	Advanced().SetBusEffectEnabled(int64(bus_idx), int64(effect_idx), enabled)
}

/*
If [code]true[/code], the effect at index [param effect_idx] on the bus at index [param bus_idx] is enabled.
*/
func IsBusEffectEnabled(bus_idx Bus, effect_idx Effect) bool { //gd:AudioServer.is_bus_effect_enabled
	once.Do(singleton)
	return bool(Advanced().IsBusEffectEnabled(int64(bus_idx), int64(effect_idx)))
}

/*
Returns the peak volume of the left speaker at bus index [param bus_idx] and channel index [param channel].
*/
func GetBusPeakVolumeLeftDb(bus_idx Bus, channel int) Float.X { //gd:AudioServer.get_bus_peak_volume_left_db
	once.Do(singleton)
	return Float.X(Float.X(Advanced().GetBusPeakVolumeLeftDb(int64(bus_idx), int64(channel))))
}

/*
Returns the peak volume of the right speaker at bus index [param bus_idx] and channel index [param channel].
*/
func GetBusPeakVolumeRightDb(bus_idx Bus, channel int) Float.X { //gd:AudioServer.get_bus_peak_volume_right_db
	once.Do(singleton)
	return Float.X(Float.X(Advanced().GetBusPeakVolumeRightDb(int64(bus_idx), int64(channel))))
}

/*
Locks the audio driver's main loop.
[b]Note:[/b] Remember to unlock it afterwards.
*/
func Lock() { //gd:AudioServer.lock
	once.Do(singleton)
	Advanced().Lock()
}

/*
Unlocks the audio driver's main loop. (After locking it, you should always unlock it.)
*/
func Unlock() { //gd:AudioServer.unlock
	once.Do(singleton)
	Advanced().Unlock()
}

/*
Returns the speaker configuration.
*/
func GetSpeakerMode() SpeakerMode { //gd:AudioServer.get_speaker_mode
	once.Do(singleton)
	return SpeakerMode(Advanced().GetSpeakerMode())
}

/*
Returns the sample rate at the output of the [AudioServer].
*/
func GetMixRate() Float.X { //gd:AudioServer.get_mix_rate
	once.Do(singleton)
	return Float.X(Float.X(Advanced().GetMixRate()))
}

/*
Returns the sample rate at the input of the [AudioServer].
*/
func GetInputMixRate() Float.X { //gd:AudioServer.get_input_mix_rate
	once.Do(singleton)
	return Float.X(Float.X(Advanced().GetInputMixRate()))
}

/*
Returns the name of the current audio driver. The default usually depends on the operating system, but may be overridden via the [code]--audio-driver[/code] [url=$DOCS_URL/tutorials/editor/command_line_tutorial.html]command line argument[/url]. [code]--headless[/code] also automatically sets the audio driver to [code]Dummy[/code]. See also [member ProjectSettings.audio/driver/driver].
*/
func GetDriverName() string { //gd:AudioServer.get_driver_name
	once.Do(singleton)
	return string(Advanced().GetDriverName().String())
}

/*
Returns the names of all audio output devices detected on the system.
*/
func GetOutputDeviceList() []string { //gd:AudioServer.get_output_device_list
	once.Do(singleton)
	return []string(Advanced().GetOutputDeviceList().Strings())
}

/*
Returns the relative time until the next mix occurs.
*/
func GetTimeToNextMix() Float.X { //gd:AudioServer.get_time_to_next_mix
	once.Do(singleton)
	return Float.X(Float.X(Advanced().GetTimeToNextMix()))
}

/*
Returns the relative time since the last mix occurred.
*/
func GetTimeSinceLastMix() Float.X { //gd:AudioServer.get_time_since_last_mix
	once.Do(singleton)
	return Float.X(Float.X(Advanced().GetTimeSinceLastMix()))
}

/*
Returns the audio driver's effective output latency. This is based on [member ProjectSettings.audio/driver/output_latency], but the exact returned value will differ depending on the operating system and audio driver.
[b]Note:[/b] This can be expensive; it is not recommended to call [method get_output_latency] every frame.
*/
func GetOutputLatency() Float.X { //gd:AudioServer.get_output_latency
	once.Do(singleton)
	return Float.X(Float.X(Advanced().GetOutputLatency()))
}

/*
Returns the names of all audio input devices detected on the system.
[b]Note:[/b] [member ProjectSettings.audio/driver/enable_input] must be [code]true[/code] for audio input to work. See also that setting's description for caveats related to permissions and operating system privacy settings.
*/
func GetInputDeviceList() []string { //gd:AudioServer.get_input_device_list
	once.Do(singleton)
	return []string(Advanced().GetInputDeviceList().Strings())
}

/*
Overwrites the currently used [AudioBusLayout].
*/
func SetBusLayout(bus_layout AudioBusLayout.Instance) { //gd:AudioServer.set_bus_layout
	once.Do(singleton)
	Advanced().SetBusLayout(bus_layout)
}

/*
Generates an [AudioBusLayout] using the available buses and effects.
*/
func GenerateBusLayout() AudioBusLayout.Instance { //gd:AudioServer.generate_bus_layout
	once.Do(singleton)
	return AudioBusLayout.Instance(Advanced().GenerateBusLayout())
}

/*
If set to [code]true[/code], all instances of [AudioStreamPlayback] will call [method AudioStreamPlayback._tag_used_streams] every mix step.
[b]Note:[/b] This is enabled by default in the editor, as it is used by editor plugins for the audio stream previews.
*/
func SetEnableTaggingUsedAudioStreams(enable bool) { //gd:AudioServer.set_enable_tagging_used_audio_streams
	once.Do(singleton)
	Advanced().SetEnableTaggingUsedAudioStreams(enable)
}

/*
If [code]true[/code], the stream is registered as a sample. The engine will not have to register it before playing the sample.
If [code]false[/code], the stream will have to be registered before playing it. To prevent lag spikes, register the stream as sample with [method register_stream_as_sample].
*/
func IsStreamRegisteredAsSample(stream AudioStream.Instance) bool { //gd:AudioServer.is_stream_registered_as_sample
	once.Do(singleton)
	return bool(Advanced().IsStreamRegisteredAsSample(stream))
}

/*
Forces the registration of a stream as a sample.
[b]Note:[/b] Lag spikes may occur when calling this method, especially on single-threaded builds. It is suggested to call this method while loading assets, where the lag spike could be masked, instead of registering the sample right before it needs to be played.
*/
func RegisterStreamAsSample(stream AudioStream.Instance) { //gd:AudioServer.register_stream_as_sample
	once.Do(singleton)
	Advanced().RegisterStreamAsSample(stream)
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
func Advanced() class { once.Do(singleton); return self }

type class [1]gdclass.AudioServer

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.AudioServer)(unsafe.Pointer(&obj))
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.AudioServer)(unsafe.Pointer(&obj))
		return true
	}
	return false
}

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }

func BusCount() int {
	once.Do(singleton)
	return int(int(class(self).GetBusCount()))
}

func SetBusCount(value int) {
	once.Do(singleton)
	class(self).SetBusCount(int64(value))
}

func OutputDevice() string {
	once.Do(singleton)
	return string(class(self).GetOutputDevice().String())
}

func SetOutputDevice(value string) {
	once.Do(singleton)
	class(self).SetOutputDevice(String.New(value))
}

func InputDevice() string {
	once.Do(singleton)
	return string(class(self).GetInputDevice().String())
}

func SetInputDevice(value string) {
	once.Do(singleton)
	class(self).SetInputDevice(String.New(value))
}

func PlaybackSpeedScale() Float.X {
	once.Do(singleton)
	return Float.X(Float.X(class(self).GetPlaybackSpeedScale()))
}

func SetPlaybackSpeedScale(value Float.X) {
	once.Do(singleton)
	class(self).SetPlaybackSpeedScale(float64(value))
}

//go:nosplit
func (self class) SetBusCount(amount int64) { //gd:AudioServer.set_bus_count
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_bus_count, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ amount int64 }{amount}))
}

//go:nosplit
func (self class) GetBusCount() int64 { //gd:AudioServer.get_bus_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_bus_count, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Removes the bus at index [param index].
*/
//go:nosplit
func (self class) RemoveBus(index int64) { //gd:AudioServer.remove_bus
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.remove_bus, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ index int64 }{index}))
}

/*
Adds a bus at [param at_position].
*/
//go:nosplit
func (self class) AddBus(at_position int64) { //gd:AudioServer.add_bus
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_bus, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ at_position int64 }{at_position}))
}

/*
Moves the bus from index [param index] to index [param to_index].
*/
//go:nosplit
func (self class) MoveBus(index int64, to_index int64) { //gd:AudioServer.move_bus
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.move_bus, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		index    int64
		to_index int64
	}{index, to_index}))
}

/*
Sets the name of the bus at index [param bus_idx] to [param name].
*/
//go:nosplit
func (self class) SetBusName(bus_idx int64, name String.Readable) { //gd:AudioServer.set_bus_name
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_bus_name, 0|(gdextension.SizeInt<<4)|(gdextension.SizeString<<8), unsafe.Pointer(&struct {
		bus_idx int64
		name    gdextension.String
	}{bus_idx, pointers.Get(gd.InternalString(name))}))
}

/*
Returns the name of the bus with the index [param bus_idx].
*/
//go:nosplit
func (self class) GetBusName(bus_idx int64) String.Readable { //gd:AudioServer.get_bus_name
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_bus_name, gdextension.SizeString|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ bus_idx int64 }{bus_idx}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Returns the index of the bus with the name [param bus_name]. Returns [code]-1[/code] if no bus with the specified name exist.
*/
//go:nosplit
func (self class) GetBusIndex(bus_name String.Name) int64 { //gd:AudioServer.get_bus_index
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_bus_index, gdextension.SizeInt|(gdextension.SizeStringName<<4), unsafe.Pointer(&struct{ bus_name gdextension.StringName }{pointers.Get(gd.InternalStringName(bus_name))}))
	var ret = r_ret
	return ret
}

/*
Returns the number of channels of the bus at index [param bus_idx].
*/
//go:nosplit
func (self class) GetBusChannels(bus_idx int64) int64 { //gd:AudioServer.get_bus_channels
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_bus_channels, gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ bus_idx int64 }{bus_idx}))
	var ret = r_ret
	return ret
}

/*
Sets the volume in decibels of the bus at index [param bus_idx] to [param volume_db].
*/
//go:nosplit
func (self class) SetBusVolumeDb(bus_idx int64, volume_db float64) { //gd:AudioServer.set_bus_volume_db
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_bus_volume_db, 0|(gdextension.SizeInt<<4)|(gdextension.SizeFloat<<8), unsafe.Pointer(&struct {
		bus_idx   int64
		volume_db float64
	}{bus_idx, volume_db}))
}

/*
Returns the volume of the bus at index [param bus_idx] in dB.
*/
//go:nosplit
func (self class) GetBusVolumeDb(bus_idx int64) float64 { //gd:AudioServer.get_bus_volume_db
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_bus_volume_db, gdextension.SizeFloat|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ bus_idx int64 }{bus_idx}))
	var ret = r_ret
	return ret
}

/*
Sets the volume as a linear value of the bus at index [param bus_idx] to [param volume_linear].
[b]Note:[/b] Using this method is equivalent to calling [method set_bus_volume_db] with the result of [method @GlobalScope.linear_to_db] on a value.
*/
//go:nosplit
func (self class) SetBusVolumeLinear(bus_idx int64, volume_linear float64) { //gd:AudioServer.set_bus_volume_linear
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_bus_volume_linear, 0|(gdextension.SizeInt<<4)|(gdextension.SizeFloat<<8), unsafe.Pointer(&struct {
		bus_idx       int64
		volume_linear float64
	}{bus_idx, volume_linear}))
}

/*
Returns the volume of the bus at index [param bus_idx] as a linear value.
[b]Note:[/b] The returned value is equivalent to the result of [method @GlobalScope.db_to_linear] on the result of [method get_bus_volume_db].
*/
//go:nosplit
func (self class) GetBusVolumeLinear(bus_idx int64) float64 { //gd:AudioServer.get_bus_volume_linear
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_bus_volume_linear, gdextension.SizeFloat|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ bus_idx int64 }{bus_idx}))
	var ret = r_ret
	return ret
}

/*
Connects the output of the bus at [param bus_idx] to the bus named [param send].
*/
//go:nosplit
func (self class) SetBusSend(bus_idx int64, send String.Name) { //gd:AudioServer.set_bus_send
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_bus_send, 0|(gdextension.SizeInt<<4)|(gdextension.SizeStringName<<8), unsafe.Pointer(&struct {
		bus_idx int64
		send    gdextension.StringName
	}{bus_idx, pointers.Get(gd.InternalStringName(send))}))
}

/*
Returns the name of the bus that the bus at index [param bus_idx] sends to.
*/
//go:nosplit
func (self class) GetBusSend(bus_idx int64) String.Name { //gd:AudioServer.get_bus_send
	var r_ret = gdextension.Call[gdextension.StringName](gd.ObjectChecked(self.AsObject()), methods.get_bus_send, gdextension.SizeStringName|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ bus_idx int64 }{bus_idx}))
	var ret = String.Name(String.Via(gd.StringNameProxy{}, pointers.Pack(pointers.New[gd.StringName](r_ret))))
	return ret
}

/*
If [code]true[/code], the bus at index [param bus_idx] is in solo mode.
*/
//go:nosplit
func (self class) SetBusSolo(bus_idx int64, enable bool) { //gd:AudioServer.set_bus_solo
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_bus_solo, 0|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		bus_idx int64
		enable  bool
	}{bus_idx, enable}))
}

/*
If [code]true[/code], the bus at index [param bus_idx] is in solo mode.
*/
//go:nosplit
func (self class) IsBusSolo(bus_idx int64) bool { //gd:AudioServer.is_bus_solo
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_bus_solo, gdextension.SizeBool|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ bus_idx int64 }{bus_idx}))
	var ret = r_ret
	return ret
}

/*
If [code]true[/code], the bus at index [param bus_idx] is muted.
*/
//go:nosplit
func (self class) SetBusMute(bus_idx int64, enable bool) { //gd:AudioServer.set_bus_mute
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_bus_mute, 0|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		bus_idx int64
		enable  bool
	}{bus_idx, enable}))
}

/*
If [code]true[/code], the bus at index [param bus_idx] is muted.
*/
//go:nosplit
func (self class) IsBusMute(bus_idx int64) bool { //gd:AudioServer.is_bus_mute
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_bus_mute, gdextension.SizeBool|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ bus_idx int64 }{bus_idx}))
	var ret = r_ret
	return ret
}

/*
If [code]true[/code], the bus at index [param bus_idx] is bypassing effects.
*/
//go:nosplit
func (self class) SetBusBypassEffects(bus_idx int64, enable bool) { //gd:AudioServer.set_bus_bypass_effects
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_bus_bypass_effects, 0|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		bus_idx int64
		enable  bool
	}{bus_idx, enable}))
}

/*
If [code]true[/code], the bus at index [param bus_idx] is bypassing effects.
*/
//go:nosplit
func (self class) IsBusBypassingEffects(bus_idx int64) bool { //gd:AudioServer.is_bus_bypassing_effects
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_bus_bypassing_effects, gdextension.SizeBool|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ bus_idx int64 }{bus_idx}))
	var ret = r_ret
	return ret
}

/*
Adds an [AudioEffect] effect to the bus [param bus_idx] at [param at_position].
*/
//go:nosplit
func (self class) AddBusEffect(bus_idx int64, effect [1]gdclass.AudioEffect, at_position int64) { //gd:AudioServer.add_bus_effect
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_bus_effect, 0|(gdextension.SizeInt<<4)|(gdextension.SizeObject<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		bus_idx     int64
		effect      gdextension.Object
		at_position int64
	}{bus_idx, gdextension.Object(gd.ObjectChecked(effect[0].AsObject())), at_position}))
}

/*
Removes the effect at index [param effect_idx] from the bus at index [param bus_idx].
*/
//go:nosplit
func (self class) RemoveBusEffect(bus_idx int64, effect_idx int64) { //gd:AudioServer.remove_bus_effect
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.remove_bus_effect, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		bus_idx    int64
		effect_idx int64
	}{bus_idx, effect_idx}))
}

/*
Returns the number of effects on the bus at [param bus_idx].
*/
//go:nosplit
func (self class) GetBusEffectCount(bus_idx int64) int64 { //gd:AudioServer.get_bus_effect_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_bus_effect_count, gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ bus_idx int64 }{bus_idx}))
	var ret = r_ret
	return ret
}

/*
Returns the [AudioEffect] at position [param effect_idx] in bus [param bus_idx].
*/
//go:nosplit
func (self class) GetBusEffect(bus_idx int64, effect_idx int64) [1]gdclass.AudioEffect { //gd:AudioServer.get_bus_effect
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_bus_effect, gdextension.SizeObject|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		bus_idx    int64
		effect_idx int64
	}{bus_idx, effect_idx}))
	var ret = [1]gdclass.AudioEffect{gd.PointerWithOwnershipTransferredToGo[gdclass.AudioEffect](r_ret)}
	return ret
}

/*
Returns the [AudioEffectInstance] assigned to the given bus and effect indices (and optionally channel).
*/
//go:nosplit
func (self class) GetBusEffectInstance(bus_idx int64, effect_idx int64, channel int64) [1]gdclass.AudioEffectInstance { //gd:AudioServer.get_bus_effect_instance
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_bus_effect_instance, gdextension.SizeObject|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		bus_idx    int64
		effect_idx int64
		channel    int64
	}{bus_idx, effect_idx, channel}))
	var ret = [1]gdclass.AudioEffectInstance{gd.PointerWithOwnershipTransferredToGo[gdclass.AudioEffectInstance](r_ret)}
	return ret
}

/*
Swaps the position of two effects in bus [param bus_idx].
*/
//go:nosplit
func (self class) SwapBusEffects(bus_idx int64, effect_idx int64, by_effect_idx int64) { //gd:AudioServer.swap_bus_effects
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.swap_bus_effects, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		bus_idx       int64
		effect_idx    int64
		by_effect_idx int64
	}{bus_idx, effect_idx, by_effect_idx}))
}

/*
If [code]true[/code], the effect at index [param effect_idx] on the bus at index [param bus_idx] is enabled.
*/
//go:nosplit
func (self class) SetBusEffectEnabled(bus_idx int64, effect_idx int64, enabled bool) { //gd:AudioServer.set_bus_effect_enabled
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_bus_effect_enabled, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeBool<<12), unsafe.Pointer(&struct {
		bus_idx    int64
		effect_idx int64
		enabled    bool
	}{bus_idx, effect_idx, enabled}))
}

/*
If [code]true[/code], the effect at index [param effect_idx] on the bus at index [param bus_idx] is enabled.
*/
//go:nosplit
func (self class) IsBusEffectEnabled(bus_idx int64, effect_idx int64) bool { //gd:AudioServer.is_bus_effect_enabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_bus_effect_enabled, gdextension.SizeBool|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		bus_idx    int64
		effect_idx int64
	}{bus_idx, effect_idx}))
	var ret = r_ret
	return ret
}

/*
Returns the peak volume of the left speaker at bus index [param bus_idx] and channel index [param channel].
*/
//go:nosplit
func (self class) GetBusPeakVolumeLeftDb(bus_idx int64, channel int64) float64 { //gd:AudioServer.get_bus_peak_volume_left_db
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_bus_peak_volume_left_db, gdextension.SizeFloat|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		bus_idx int64
		channel int64
	}{bus_idx, channel}))
	var ret = r_ret
	return ret
}

/*
Returns the peak volume of the right speaker at bus index [param bus_idx] and channel index [param channel].
*/
//go:nosplit
func (self class) GetBusPeakVolumeRightDb(bus_idx int64, channel int64) float64 { //gd:AudioServer.get_bus_peak_volume_right_db
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_bus_peak_volume_right_db, gdextension.SizeFloat|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		bus_idx int64
		channel int64
	}{bus_idx, channel}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetPlaybackSpeedScale(scale float64) { //gd:AudioServer.set_playback_speed_scale
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_playback_speed_scale, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ scale float64 }{scale}))
}

//go:nosplit
func (self class) GetPlaybackSpeedScale() float64 { //gd:AudioServer.get_playback_speed_scale
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_playback_speed_scale, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Locks the audio driver's main loop.
[b]Note:[/b] Remember to unlock it afterwards.
*/
//go:nosplit
func (self class) Lock() { //gd:AudioServer.lock
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.lock, 0, unsafe.Pointer(&struct{}{}))
}

/*
Unlocks the audio driver's main loop. (After locking it, you should always unlock it.)
*/
//go:nosplit
func (self class) Unlock() { //gd:AudioServer.unlock
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.unlock, 0, unsafe.Pointer(&struct{}{}))
}

/*
Returns the speaker configuration.
*/
//go:nosplit
func (self class) GetSpeakerMode() SpeakerMode { //gd:AudioServer.get_speaker_mode
	var r_ret = gdextension.Call[SpeakerMode](gd.ObjectChecked(self.AsObject()), methods.get_speaker_mode, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the sample rate at the output of the [AudioServer].
*/
//go:nosplit
func (self class) GetMixRate() float64 { //gd:AudioServer.get_mix_rate
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_mix_rate, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the sample rate at the input of the [AudioServer].
*/
//go:nosplit
func (self class) GetInputMixRate() float64 { //gd:AudioServer.get_input_mix_rate
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_input_mix_rate, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the name of the current audio driver. The default usually depends on the operating system, but may be overridden via the [code]--audio-driver[/code] [url=$DOCS_URL/tutorials/editor/command_line_tutorial.html]command line argument[/url]. [code]--headless[/code] also automatically sets the audio driver to [code]Dummy[/code]. See also [member ProjectSettings.audio/driver/driver].
*/
//go:nosplit
func (self class) GetDriverName() String.Readable { //gd:AudioServer.get_driver_name
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_driver_name, gdextension.SizeString, unsafe.Pointer(&struct{}{}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Returns the names of all audio output devices detected on the system.
*/
//go:nosplit
func (self class) GetOutputDeviceList() Packed.Strings { //gd:AudioServer.get_output_device_list
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.get_output_device_list, gdextension.SizePackedArray, unsafe.Pointer(&struct{}{}))
	var ret = Packed.Strings(Array.Through(gd.PackedStringArrayProxy{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

//go:nosplit
func (self class) GetOutputDevice() String.Readable { //gd:AudioServer.get_output_device
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_output_device, gdextension.SizeString, unsafe.Pointer(&struct{}{}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

//go:nosplit
func (self class) SetOutputDevice(name String.Readable) { //gd:AudioServer.set_output_device
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_output_device, 0|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ name gdextension.String }{pointers.Get(gd.InternalString(name))}))
}

/*
Returns the relative time until the next mix occurs.
*/
//go:nosplit
func (self class) GetTimeToNextMix() float64 { //gd:AudioServer.get_time_to_next_mix
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_time_to_next_mix, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the relative time since the last mix occurred.
*/
//go:nosplit
func (self class) GetTimeSinceLastMix() float64 { //gd:AudioServer.get_time_since_last_mix
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_time_since_last_mix, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the audio driver's effective output latency. This is based on [member ProjectSettings.audio/driver/output_latency], but the exact returned value will differ depending on the operating system and audio driver.
[b]Note:[/b] This can be expensive; it is not recommended to call [method get_output_latency] every frame.
*/
//go:nosplit
func (self class) GetOutputLatency() float64 { //gd:AudioServer.get_output_latency
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_output_latency, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the names of all audio input devices detected on the system.
[b]Note:[/b] [member ProjectSettings.audio/driver/enable_input] must be [code]true[/code] for audio input to work. See also that setting's description for caveats related to permissions and operating system privacy settings.
*/
//go:nosplit
func (self class) GetInputDeviceList() Packed.Strings { //gd:AudioServer.get_input_device_list
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.get_input_device_list, gdextension.SizePackedArray, unsafe.Pointer(&struct{}{}))
	var ret = Packed.Strings(Array.Through(gd.PackedStringArrayProxy{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

//go:nosplit
func (self class) GetInputDevice() String.Readable { //gd:AudioServer.get_input_device
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_input_device, gdextension.SizeString, unsafe.Pointer(&struct{}{}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

//go:nosplit
func (self class) SetInputDevice(name String.Readable) { //gd:AudioServer.set_input_device
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_input_device, 0|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ name gdextension.String }{pointers.Get(gd.InternalString(name))}))
}

/*
Overwrites the currently used [AudioBusLayout].
*/
//go:nosplit
func (self class) SetBusLayout(bus_layout [1]gdclass.AudioBusLayout) { //gd:AudioServer.set_bus_layout
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_bus_layout, 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ bus_layout gdextension.Object }{gdextension.Object(gd.ObjectChecked(bus_layout[0].AsObject()))}))
}

/*
Generates an [AudioBusLayout] using the available buses and effects.
*/
//go:nosplit
func (self class) GenerateBusLayout() [1]gdclass.AudioBusLayout { //gd:AudioServer.generate_bus_layout
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.generate_bus_layout, gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.AudioBusLayout{gd.PointerWithOwnershipTransferredToGo[gdclass.AudioBusLayout](r_ret)}
	return ret
}

/*
If set to [code]true[/code], all instances of [AudioStreamPlayback] will call [method AudioStreamPlayback._tag_used_streams] every mix step.
[b]Note:[/b] This is enabled by default in the editor, as it is used by editor plugins for the audio stream previews.
*/
//go:nosplit
func (self class) SetEnableTaggingUsedAudioStreams(enable bool) { //gd:AudioServer.set_enable_tagging_used_audio_streams
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_enable_tagging_used_audio_streams, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

/*
If [code]true[/code], the stream is registered as a sample. The engine will not have to register it before playing the sample.
If [code]false[/code], the stream will have to be registered before playing it. To prevent lag spikes, register the stream as sample with [method register_stream_as_sample].
*/
//go:nosplit
func (self class) IsStreamRegisteredAsSample(stream [1]gdclass.AudioStream) bool { //gd:AudioServer.is_stream_registered_as_sample
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_stream_registered_as_sample, gdextension.SizeBool|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ stream gdextension.Object }{gdextension.Object(gd.ObjectChecked(stream[0].AsObject()))}))
	var ret = r_ret
	return ret
}

/*
Forces the registration of a stream as a sample.
[b]Note:[/b] Lag spikes may occur when calling this method, especially on single-threaded builds. It is suggested to call this method while loading assets, where the lag spike could be masked, instead of registering the sample right before it needs to be played.
*/
//go:nosplit
func (self class) RegisterStreamAsSample(stream [1]gdclass.AudioStream) { //gd:AudioServer.register_stream_as_sample
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.register_stream_as_sample, 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ stream gdextension.Object }{gdextension.Object(gd.ObjectChecked(stream[0].AsObject()))}))
}
func OnBusLayoutChanged(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("bus_layout_changed"), gd.NewCallable(cb), 0)
}

func OnBusRenamed(cb func(bus_index int, old_name string, new_name string)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("bus_renamed"), gd.NewCallable(cb), 0)
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Object.Advanced(self.AsObject()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Object.Instance(self.AsObject()), name)
	}
}
func init() {
	gdclass.Register("AudioServer", func(ptr gd.Object) any { return *(*Instance)(unsafe.Pointer(&ptr)) })
}

type SpeakerMode int //gd:AudioServer.SpeakerMode

const (
	/*Two or fewer speakers were detected.*/
	SpeakerModeStereo SpeakerMode = 0
	/*A 3.1 channel surround setup was detected.*/
	SpeakerSurround31 SpeakerMode = 1
	/*A 5.1 channel surround setup was detected.*/
	SpeakerSurround51 SpeakerMode = 2
	/*A 7.1 channel surround setup was detected.*/
	SpeakerSurround71 SpeakerMode = 3
)

type PlaybackType int //gd:AudioServer.PlaybackType

const (
	/*The playback will be considered of the type declared at [member ProjectSettings.audio/general/default_playback_type].*/
	PlaybackTypeDefault PlaybackType = 0
	/*Force the playback to be considered as a stream.*/
	PlaybackTypeStream PlaybackType = 1
	/*Force the playback to be considered as a sample. This can provide lower latency and more stable playback (with less risk of audio crackling), at the cost of having less flexibility.
	  [b]Note:[/b] Only currently supported on the web platform.
	  [b]Note:[/b] [AudioEffect]s are not supported when playback is considered as a sample.*/
	PlaybackTypeSample PlaybackType = 2
	/*Represents the size of the [enum PlaybackType] enum.*/
	PlaybackTypeMax PlaybackType = 3
)
