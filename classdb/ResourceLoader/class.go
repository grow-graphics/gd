// Code generated by the generate package DO NOT EDIT

// Package ResourceLoader provides methods for working with ResourceLoader object instances.
package ResourceLoader

import "sync"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/variant/Signal"
import "graphics.gd/classdb/Resource"
import "graphics.gd/classdb/ResourceFormatLoader"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Signal.Any
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
A singleton used to load resource files from the filesystem.
It uses the many [ResourceFormatLoader] classes registered in the engine (either built-in or from a plugin) to load files into memory and convert them to a format that can be used by the engine.
[b]Note:[/b] You have to import the files into the engine first to load them using [method load]. If you want to load [Image]s at run-time, you may use [method Image.load]. If you want to import audio files, you can use the snippet described in [member AudioStreamMP3.data].
[b]Note:[/b] Non-resource files such as plain text files cannot be read using [ResourceLoader]. Use [FileAccess] for those files instead, and be aware that non-resource files are not exported by default (see notes in the [FileAccess] class description for instructions on exporting them).
*/
type Instance [1]gdclass.ResourceLoader

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	load_threaded_request              gdextension.MethodForClass `hash:"3614384323"`
	load_threaded_get_status           gdextension.MethodForClass `hash:"4137685479"`
	load_threaded_get                  gdextension.MethodForClass `hash:"1748875256"`
	load                               gdextension.MethodForClass `hash:"3358495409"`
	get_recognized_extensions_for_type gdextension.MethodForClass `hash:"3538744774"`
	add_resource_format_loader         gdextension.MethodForClass `hash:"2896595483"`
	remove_resource_format_loader      gdextension.MethodForClass `hash:"405397102"`
	set_abort_on_missing_resources     gdextension.MethodForClass `hash:"2586408642"`
	get_dependencies                   gdextension.MethodForClass `hash:"3538744774"`
	has_cached                         gdextension.MethodForClass `hash:"2323990056"`
	get_cached_ref                     gdextension.MethodForClass `hash:"1748875256"`
	exists                             gdextension.MethodForClass `hash:"4185558881"`
	get_resource_uid                   gdextension.MethodForClass `hash:"1597066294"`
	list_directory                     gdextension.MethodForClass `hash:"3538744774"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("ResourceLoader")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		gdextension.Free(gdextension.TypeStringName, &sname)
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

var self [1]gdclass.ResourceLoader
var once sync.Once

func singleton() {
	self[0] = pointers.Raw[gdclass.ResourceLoader]([3]uint64{uint64(gdextension.Host.Objects.Global(sname))})
}

/*
Loads the resource using threads. If [param use_sub_threads] is [code]true[/code], multiple threads will be used to load the resource, which makes loading faster, but may affect the main thread (and thus cause game slowdowns).
The [param cache_mode] property defines whether and how the cache should be used or updated when loading the resource. See [enum CacheMode] for details.
*/
func LoadThreadedRequest(path string, type_hint string, use_sub_threads bool) error { //gd:ResourceLoader.load_threaded_request
	once.Do(singleton)
	return error(gd.ToError(Advanced().LoadThreadedRequest(String.New(path), String.New(type_hint), use_sub_threads, 1)))
}

/*
Loads the resource using threads. If [param use_sub_threads] is [code]true[/code], multiple threads will be used to load the resource, which makes loading faster, but may affect the main thread (and thus cause game slowdowns).
The [param cache_mode] property defines whether and how the cache should be used or updated when loading the resource. See [enum CacheMode] for details.
*/
func LoadThreadedRequestOptions(path string, type_hint string, use_sub_threads bool, cache_mode CacheMode) error { //gd:ResourceLoader.load_threaded_request
	once.Do(singleton)
	return error(gd.ToError(Advanced().LoadThreadedRequest(String.New(path), String.New(type_hint), use_sub_threads, cache_mode)))
}

/*
Returns the status of a threaded loading operation started with [method load_threaded_request] for the resource at [param path]. See [enum ThreadLoadStatus] for possible return values.
An array variable can optionally be passed via [param progress], and will return a one-element array containing the ratio of completion of the threaded loading (between [code]0.0[/code] and [code]1.0[/code]).
[b]Note:[/b] The recommended way of using this method is to call it during different frames (e.g., in [method Node._process], instead of a loop).
*/
func LoadThreadedGetStatus(path string, progress []any) ThreadLoadStatus { //gd:ResourceLoader.load_threaded_get_status
	once.Do(singleton)
	return ThreadLoadStatus(Advanced().LoadThreadedGetStatus(String.New(path), gd.EngineArrayFromSlice(progress)))
}

/*
Returns the status of a threaded loading operation started with [method load_threaded_request] for the resource at [param path]. See [enum ThreadLoadStatus] for possible return values.
An array variable can optionally be passed via [param progress], and will return a one-element array containing the ratio of completion of the threaded loading (between [code]0.0[/code] and [code]1.0[/code]).
[b]Note:[/b] The recommended way of using this method is to call it during different frames (e.g., in [method Node._process], instead of a loop).
*/
func LoadThreadedGetStatusOptions(path string, progress []any) ThreadLoadStatus { //gd:ResourceLoader.load_threaded_get_status
	once.Do(singleton)
	return ThreadLoadStatus(Advanced().LoadThreadedGetStatus(String.New(path), gd.EngineArrayFromSlice(progress)))
}

/*
Returns the resource loaded by [method load_threaded_request].
If this is called before the loading thread is done (i.e. [method load_threaded_get_status] is not [constant THREAD_LOAD_LOADED]), the calling thread will be blocked until the resource has finished loading. However, it's recommended to use [method load_threaded_get_status] to known when the load has actually completed.
*/
func LoadThreadedGet(path string) Resource.Instance { //gd:ResourceLoader.load_threaded_get
	once.Do(singleton)
	return Resource.Instance(Advanced().LoadThreadedGet(String.New(path)))
}

/*
Loads a resource at the given [param path], caching the result for further access.
The registered [ResourceFormatLoader]s are queried sequentially to find the first one which can handle the file's extension, and then attempt loading. If loading fails, the remaining ResourceFormatLoaders are also attempted.
An optional [param type_hint] can be used to further specify the [Resource] type that should be handled by the [ResourceFormatLoader]. Anything that inherits from [Resource] can be used as a type hint, for example [Image].
The [param cache_mode] property defines whether and how the cache should be used or updated when loading the resource. See [enum CacheMode] for details.
Returns an empty resource if no [ResourceFormatLoader] could handle the file, and prints an error if no file is found at the specified path.
GDScript has a simplified [method @GDScript.load] built-in method which can be used in most situations, leaving the use of [ResourceLoader] for more advanced scenarios.
[b]Note:[/b] If [member ProjectSettings.editor/export/convert_text_resources_to_binary] is [code]true[/code], [method @GDScript.load] will not be able to read converted files in an exported project. If you rely on run-time loading of files present within the PCK, set [member ProjectSettings.editor/export/convert_text_resources_to_binary] to [code]false[/code].
[b]Note:[/b] Relative paths will be prefixed with [code]"res://"[/code] before loading, to avoid unexpected results make sure your paths are absolute.
*/
func Load(path string, type_hint string) Resource.Instance { //gd:ResourceLoader.load
	once.Do(singleton)
	return Resource.Instance(Advanced().Load(String.New(path), String.New(type_hint), 1))
}

/*
Loads a resource at the given [param path], caching the result for further access.
The registered [ResourceFormatLoader]s are queried sequentially to find the first one which can handle the file's extension, and then attempt loading. If loading fails, the remaining ResourceFormatLoaders are also attempted.
An optional [param type_hint] can be used to further specify the [Resource] type that should be handled by the [ResourceFormatLoader]. Anything that inherits from [Resource] can be used as a type hint, for example [Image].
The [param cache_mode] property defines whether and how the cache should be used or updated when loading the resource. See [enum CacheMode] for details.
Returns an empty resource if no [ResourceFormatLoader] could handle the file, and prints an error if no file is found at the specified path.
GDScript has a simplified [method @GDScript.load] built-in method which can be used in most situations, leaving the use of [ResourceLoader] for more advanced scenarios.
[b]Note:[/b] If [member ProjectSettings.editor/export/convert_text_resources_to_binary] is [code]true[/code], [method @GDScript.load] will not be able to read converted files in an exported project. If you rely on run-time loading of files present within the PCK, set [member ProjectSettings.editor/export/convert_text_resources_to_binary] to [code]false[/code].
[b]Note:[/b] Relative paths will be prefixed with [code]"res://"[/code] before loading, to avoid unexpected results make sure your paths are absolute.
*/
func LoadOptions(path string, type_hint string, cache_mode CacheMode) Resource.Instance { //gd:ResourceLoader.load
	once.Do(singleton)
	return Resource.Instance(Advanced().Load(String.New(path), String.New(type_hint), cache_mode))
}

/*
Returns the list of recognized extensions for a resource type.
*/
func GetRecognizedExtensionsForType(atype string) []string { //gd:ResourceLoader.get_recognized_extensions_for_type
	once.Do(singleton)
	return []string(Advanced().GetRecognizedExtensionsForType(String.New(atype)).Strings())
}

/*
Registers a new [ResourceFormatLoader]. The ResourceLoader will use the ResourceFormatLoader as described in [method load].
This method is performed implicitly for ResourceFormatLoaders written in GDScript (see [ResourceFormatLoader] for more information).
*/
func AddResourceFormatLoader(format_loader ResourceFormatLoader.Instance, at_front bool) { //gd:ResourceLoader.add_resource_format_loader
	once.Do(singleton)
	Advanced().AddResourceFormatLoader(format_loader, at_front)
}

/*
Registers a new [ResourceFormatLoader]. The ResourceLoader will use the ResourceFormatLoader as described in [method load].
This method is performed implicitly for ResourceFormatLoaders written in GDScript (see [ResourceFormatLoader] for more information).
*/
func AddResourceFormatLoaderOptions(format_loader ResourceFormatLoader.Instance, at_front bool) { //gd:ResourceLoader.add_resource_format_loader
	once.Do(singleton)
	Advanced().AddResourceFormatLoader(format_loader, at_front)
}

/*
Unregisters the given [ResourceFormatLoader].
*/
func RemoveResourceFormatLoader(format_loader ResourceFormatLoader.Instance) { //gd:ResourceLoader.remove_resource_format_loader
	once.Do(singleton)
	Advanced().RemoveResourceFormatLoader(format_loader)
}

/*
Changes the behavior on missing sub-resources. The default behavior is to abort loading.
*/
func SetAbortOnMissingResources(abort bool) { //gd:ResourceLoader.set_abort_on_missing_resources
	once.Do(singleton)
	Advanced().SetAbortOnMissingResources(abort)
}

/*
Returns the dependencies for the resource at the given [param path].
[b]Note:[/b] The dependencies are returned with slices separated by [code]::[/code]. You can use [method String.get_slice] to get their components.
[codeblock]
for dependency in ResourceLoader.get_dependencies(path):

	print(dependency.get_slice("::", 0)) # Prints the UID.
	print(dependency.get_slice("::", 2)) # Prints the path.

[/codeblock]
*/
func GetDependencies(path string) []string { //gd:ResourceLoader.get_dependencies
	once.Do(singleton)
	return []string(Advanced().GetDependencies(String.New(path)).Strings())
}

/*
Returns whether a cached resource is available for the given [param path].
Once a resource has been loaded by the engine, it is cached in memory for faster access, and future calls to the [method load] method will use the cached version. The cached resource can be overridden by using [method Resource.take_over_path] on a new resource for that same path.
*/
func HasCached(path string) bool { //gd:ResourceLoader.has_cached
	once.Do(singleton)
	return bool(Advanced().HasCached(String.New(path)))
}

/*
Returns the cached resource reference for the given [param path].
[b]Note:[/b] If the resource is not cached, the returned [Resource] will be invalid.
*/
func GetCachedRef(path string) Resource.Instance { //gd:ResourceLoader.get_cached_ref
	once.Do(singleton)
	return Resource.Instance(Advanced().GetCachedRef(String.New(path)))
}

/*
Returns whether a recognized resource exists for the given [param path].
An optional [param type_hint] can be used to further specify the [Resource] type that should be handled by the [ResourceFormatLoader]. Anything that inherits from [Resource] can be used as a type hint, for example [Image].
[b]Note:[/b] If you use [method Resource.take_over_path], this method will return [code]true[/code] for the taken path even if the resource wasn't saved (i.e. exists only in resource cache).
*/
func Exists(path string, type_hint string) bool { //gd:ResourceLoader.exists
	once.Do(singleton)
	return bool(Advanced().Exists(String.New(path), String.New(type_hint)))
}

/*
Returns whether a recognized resource exists for the given [param path].
An optional [param type_hint] can be used to further specify the [Resource] type that should be handled by the [ResourceFormatLoader]. Anything that inherits from [Resource] can be used as a type hint, for example [Image].
[b]Note:[/b] If you use [method Resource.take_over_path], this method will return [code]true[/code] for the taken path even if the resource wasn't saved (i.e. exists only in resource cache).
*/
func ExistsOptions(path string, type_hint string) bool { //gd:ResourceLoader.exists
	once.Do(singleton)
	return bool(Advanced().Exists(String.New(path), String.New(type_hint)))
}

/*
Returns the ID associated with a given resource path, or [code]-1[/code] when no such ID exists.
*/
func GetResourceUid(path string) int { //gd:ResourceLoader.get_resource_uid
	once.Do(singleton)
	return int(int(Advanced().GetResourceUid(String.New(path))))
}

/*
Lists a directory (as example: "res://assets/enemies"), returning all resources contained within. The resource files are the original file names as visible in the editor before exporting.
*/
func ListDirectory(directory_path string) []string { //gd:ResourceLoader.list_directory
	once.Do(singleton)
	return []string(Advanced().ListDirectory(String.New(directory_path)).Strings())
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
func Advanced() class { once.Do(singleton); return self }

type class [1]gdclass.ResourceLoader

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = pointers.AsA[gdclass.ResourceLoader](obj[0])
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = pointers.AsA[gdclass.ResourceLoader](obj[0])
		return true
	}
	return false
}
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }
func (self *Extension[T]) AsObject() [1]gd.Object { return self.Super().AsObject() }

/*
Loads the resource using threads. If [param use_sub_threads] is [code]true[/code], multiple threads will be used to load the resource, which makes loading faster, but may affect the main thread (and thus cause game slowdowns).
The [param cache_mode] property defines whether and how the cache should be used or updated when loading the resource. See [enum CacheMode] for details.
*/
//go:nosplit
func (self class) LoadThreadedRequest(path String.Readable, type_hint String.Readable, use_sub_threads bool, cache_mode CacheMode) Error.Code { //gd:ResourceLoader.load_threaded_request
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.load_threaded_request, gdextension.SizeInt|(gdextension.SizeString<<4)|(gdextension.SizeString<<8)|(gdextension.SizeBool<<12)|(gdextension.SizeInt<<16), &struct {
		path            gdextension.String
		type_hint       gdextension.String
		use_sub_threads bool
		cache_mode      CacheMode
	}{pointers.Get(gd.InternalString(path)), pointers.Get(gd.InternalString(type_hint)), use_sub_threads, cache_mode})
	var ret = Error.Code(r_ret)
	return ret
}

/*
Returns the status of a threaded loading operation started with [method load_threaded_request] for the resource at [param path]. See [enum ThreadLoadStatus] for possible return values.
An array variable can optionally be passed via [param progress], and will return a one-element array containing the ratio of completion of the threaded loading (between [code]0.0[/code] and [code]1.0[/code]).
[b]Note:[/b] The recommended way of using this method is to call it during different frames (e.g., in [method Node._process], instead of a loop).
*/
//go:nosplit
func (self class) LoadThreadedGetStatus(path String.Readable, progress Array.Any) ThreadLoadStatus { //gd:ResourceLoader.load_threaded_get_status
	var r_ret = gdextension.Call[ThreadLoadStatus](gd.ObjectChecked(self.AsObject()), methods.load_threaded_get_status, gdextension.SizeInt|(gdextension.SizeString<<4)|(gdextension.SizeArray<<8), &struct {
		path     gdextension.String
		progress gdextension.Array
	}{pointers.Get(gd.InternalString(path)), pointers.Get(gd.InternalArray(progress))})
	var ret = r_ret
	return ret
}

/*
Returns the resource loaded by [method load_threaded_request].
If this is called before the loading thread is done (i.e. [method load_threaded_get_status] is not [constant THREAD_LOAD_LOADED]), the calling thread will be blocked until the resource has finished loading. However, it's recommended to use [method load_threaded_get_status] to known when the load has actually completed.
*/
//go:nosplit
func (self class) LoadThreadedGet(path String.Readable) [1]gdclass.Resource { //gd:ResourceLoader.load_threaded_get
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.load_threaded_get, gdextension.SizeObject|(gdextension.SizeString<<4), &struct{ path gdextension.String }{pointers.Get(gd.InternalString(path))})
	var ret = [1]gdclass.Resource{gd.PointerWithOwnershipTransferredToGo[gdclass.Resource](r_ret)}
	return ret
}

/*
Loads a resource at the given [param path], caching the result for further access.
The registered [ResourceFormatLoader]s are queried sequentially to find the first one which can handle the file's extension, and then attempt loading. If loading fails, the remaining ResourceFormatLoaders are also attempted.
An optional [param type_hint] can be used to further specify the [Resource] type that should be handled by the [ResourceFormatLoader]. Anything that inherits from [Resource] can be used as a type hint, for example [Image].
The [param cache_mode] property defines whether and how the cache should be used or updated when loading the resource. See [enum CacheMode] for details.
Returns an empty resource if no [ResourceFormatLoader] could handle the file, and prints an error if no file is found at the specified path.
GDScript has a simplified [method @GDScript.load] built-in method which can be used in most situations, leaving the use of [ResourceLoader] for more advanced scenarios.
[b]Note:[/b] If [member ProjectSettings.editor/export/convert_text_resources_to_binary] is [code]true[/code], [method @GDScript.load] will not be able to read converted files in an exported project. If you rely on run-time loading of files present within the PCK, set [member ProjectSettings.editor/export/convert_text_resources_to_binary] to [code]false[/code].
[b]Note:[/b] Relative paths will be prefixed with [code]"res://"[/code] before loading, to avoid unexpected results make sure your paths are absolute.
*/
//go:nosplit
func (self class) Load(path String.Readable, type_hint String.Readable, cache_mode CacheMode) [1]gdclass.Resource { //gd:ResourceLoader.load
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.load, gdextension.SizeObject|(gdextension.SizeString<<4)|(gdextension.SizeString<<8)|(gdextension.SizeInt<<12), &struct {
		path       gdextension.String
		type_hint  gdextension.String
		cache_mode CacheMode
	}{pointers.Get(gd.InternalString(path)), pointers.Get(gd.InternalString(type_hint)), cache_mode})
	var ret = [1]gdclass.Resource{gd.PointerWithOwnershipTransferredToGo[gdclass.Resource](r_ret)}
	return ret
}

/*
Returns the list of recognized extensions for a resource type.
*/
//go:nosplit
func (self class) GetRecognizedExtensionsForType(atype String.Readable) Packed.Strings { //gd:ResourceLoader.get_recognized_extensions_for_type
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.get_recognized_extensions_for_type, gdextension.SizePackedArray|(gdextension.SizeString<<4), &struct{ atype gdextension.String }{pointers.Get(gd.InternalString(atype))})
	var ret = Packed.Strings(Array.Through(gd.PackedStringArrayProxy{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

/*
Registers a new [ResourceFormatLoader]. The ResourceLoader will use the ResourceFormatLoader as described in [method load].
This method is performed implicitly for ResourceFormatLoaders written in GDScript (see [ResourceFormatLoader] for more information).
*/
//go:nosplit
func (self class) AddResourceFormatLoader(format_loader [1]gdclass.ResourceFormatLoader, at_front bool) { //gd:ResourceLoader.add_resource_format_loader
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_resource_format_loader, 0|(gdextension.SizeObject<<4)|(gdextension.SizeBool<<8), &struct {
		format_loader gdextension.Object
		at_front      bool
	}{gdextension.Object(gd.ObjectChecked(format_loader[0].AsObject())), at_front})
}

/*
Unregisters the given [ResourceFormatLoader].
*/
//go:nosplit
func (self class) RemoveResourceFormatLoader(format_loader [1]gdclass.ResourceFormatLoader) { //gd:ResourceLoader.remove_resource_format_loader
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.remove_resource_format_loader, 0|(gdextension.SizeObject<<4), &struct{ format_loader gdextension.Object }{gdextension.Object(gd.ObjectChecked(format_loader[0].AsObject()))})
}

/*
Changes the behavior on missing sub-resources. The default behavior is to abort loading.
*/
//go:nosplit
func (self class) SetAbortOnMissingResources(abort bool) { //gd:ResourceLoader.set_abort_on_missing_resources
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_abort_on_missing_resources, 0|(gdextension.SizeBool<<4), &struct{ abort bool }{abort})
}

/*
Returns the dependencies for the resource at the given [param path].
[b]Note:[/b] The dependencies are returned with slices separated by [code]::[/code]. You can use [method String.get_slice] to get their components.
[codeblock]
for dependency in ResourceLoader.get_dependencies(path):
    print(dependency.get_slice("::", 0)) # Prints the UID.
    print(dependency.get_slice("::", 2)) # Prints the path.
[/codeblock]
*/
//go:nosplit
func (self class) GetDependencies(path String.Readable) Packed.Strings { //gd:ResourceLoader.get_dependencies
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.get_dependencies, gdextension.SizePackedArray|(gdextension.SizeString<<4), &struct{ path gdextension.String }{pointers.Get(gd.InternalString(path))})
	var ret = Packed.Strings(Array.Through(gd.PackedStringArrayProxy{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

/*
Returns whether a cached resource is available for the given [param path].
Once a resource has been loaded by the engine, it is cached in memory for faster access, and future calls to the [method load] method will use the cached version. The cached resource can be overridden by using [method Resource.take_over_path] on a new resource for that same path.
*/
//go:nosplit
func (self class) HasCached(path String.Readable) bool { //gd:ResourceLoader.has_cached
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.has_cached, gdextension.SizeBool|(gdextension.SizeString<<4), &struct{ path gdextension.String }{pointers.Get(gd.InternalString(path))})
	var ret = r_ret
	return ret
}

/*
Returns the cached resource reference for the given [param path].
[b]Note:[/b] If the resource is not cached, the returned [Resource] will be invalid.
*/
//go:nosplit
func (self class) GetCachedRef(path String.Readable) [1]gdclass.Resource { //gd:ResourceLoader.get_cached_ref
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_cached_ref, gdextension.SizeObject|(gdextension.SizeString<<4), &struct{ path gdextension.String }{pointers.Get(gd.InternalString(path))})
	var ret = [1]gdclass.Resource{gd.PointerWithOwnershipTransferredToGo[gdclass.Resource](r_ret)}
	return ret
}

/*
Returns whether a recognized resource exists for the given [param path].
An optional [param type_hint] can be used to further specify the [Resource] type that should be handled by the [ResourceFormatLoader]. Anything that inherits from [Resource] can be used as a type hint, for example [Image].
[b]Note:[/b] If you use [method Resource.take_over_path], this method will return [code]true[/code] for the taken path even if the resource wasn't saved (i.e. exists only in resource cache).
*/
//go:nosplit
func (self class) Exists(path String.Readable, type_hint String.Readable) bool { //gd:ResourceLoader.exists
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.exists, gdextension.SizeBool|(gdextension.SizeString<<4)|(gdextension.SizeString<<8), &struct {
		path      gdextension.String
		type_hint gdextension.String
	}{pointers.Get(gd.InternalString(path)), pointers.Get(gd.InternalString(type_hint))})
	var ret = r_ret
	return ret
}

/*
Returns the ID associated with a given resource path, or [code]-1[/code] when no such ID exists.
*/
//go:nosplit
func (self class) GetResourceUid(path String.Readable) int64 { //gd:ResourceLoader.get_resource_uid
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_resource_uid, gdextension.SizeInt|(gdextension.SizeString<<4), &struct{ path gdextension.String }{pointers.Get(gd.InternalString(path))})
	var ret = r_ret
	return ret
}

/*
Lists a directory (as example: "res://assets/enemies"), returning all resources contained within. The resource files are the original file names as visible in the editor before exporting.
*/
//go:nosplit
func (self class) ListDirectory(directory_path String.Readable) Packed.Strings { //gd:ResourceLoader.list_directory
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.list_directory, gdextension.SizePackedArray|(gdextension.SizeString<<4), &struct{ directory_path gdextension.String }{pointers.Get(gd.InternalString(directory_path))})
	var ret = Packed.Strings(Array.Through(gd.PackedStringArrayProxy{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}
func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Object.Advanced(self.AsObject()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Object.Instance(self.AsObject()), name)
	}
}
func init() {
	gdclass.Register("ResourceLoader", func(ptr gd.Object) any { return Instance{pointers.AsA[gdclass.ResourceLoader](ptr)} })
}

type ThreadLoadStatus int //gd:ResourceLoader.ThreadLoadStatus

const (
	/*The resource is invalid, or has not been loaded with [method load_threaded_request].*/
	ThreadLoadInvalidResource ThreadLoadStatus = 0
	/*The resource is still being loaded.*/
	ThreadLoadInProgress ThreadLoadStatus = 1
	/*Some error occurred during loading and it failed.*/
	ThreadLoadFailed ThreadLoadStatus = 2
	/*The resource was loaded successfully and can be accessed via [method load_threaded_get].*/
	ThreadLoadLoaded ThreadLoadStatus = 3
)

type CacheMode int //gd:ResourceLoader.CacheMode

const (
	/*Neither the main resource (the one requested to be loaded) nor any of its subresources are retrieved from cache nor stored into it. Dependencies (external resources) are loaded with [constant CACHE_MODE_REUSE].*/
	CacheModeIgnore CacheMode = 0
	/*The main resource (the one requested to be loaded), its subresources, and its dependencies (external resources) are retrieved from cache if present, instead of loaded. Those not cached are loaded and then stored into the cache. The same rules are propagated recursively down the tree of dependencies (external resources).*/
	CacheModeReuse CacheMode = 1
	/*Like [constant CACHE_MODE_REUSE], but the cache is checked for the main resource (the one requested to be loaded) as well as for each of its subresources. Those already in the cache, as long as the loaded and cached types match, have their data refreshed from storage into the already existing instances. Otherwise, they are recreated as completely new objects.*/
	CacheModeReplace CacheMode = 2
	/*Like [constant CACHE_MODE_IGNORE], but propagated recursively down the tree of dependencies (external resources).*/
	CacheModeIgnoreDeep CacheMode = 3
	/*Like [constant CACHE_MODE_REPLACE], but propagated recursively down the tree of dependencies (external resources).*/
	CacheModeReplaceDeep CacheMode = 4
)
