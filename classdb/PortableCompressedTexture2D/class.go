// Code generated by the generate package DO NOT EDIT

// Package PortableCompressedTexture2D provides methods for working with PortableCompressedTexture2D object instances.
package PortableCompressedTexture2D

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/variant/Signal"
import "graphics.gd/classdb/Image"
import "graphics.gd/classdb/Resource"
import "graphics.gd/classdb/Texture"
import "graphics.gd/classdb/Texture2D"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"
import "graphics.gd/variant/Vector2"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Signal.Any
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
This class allows storing compressed textures as self contained (not imported) resources.
For 2D usage (compressed on disk, uncompressed on VRAM), the lossy and lossless modes are recommended. For 3D usage (compressed on VRAM) it depends on the target platform.
If you intend to only use desktop, S3TC or BPTC are recommended. For only mobile, ETC2 is recommended.
For portable, self contained 3D textures that work on both desktop and mobile, Basis Universal is recommended (although it has a small quality cost and longer compression time as a tradeoff).
This resource is intended to be created from code.
*/
type Instance [1]gdclass.PortableCompressedTexture2D

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	create_from_image                 gdextension.MethodForClass `hash:"3679243433"`
	get_format                        gdextension.MethodForClass `hash:"3847873762"`
	get_compression_mode              gdextension.MethodForClass `hash:"3265612739"`
	set_size_override                 gdextension.MethodForClass `hash:"743155724"`
	get_size_override                 gdextension.MethodForClass `hash:"3341600327"`
	set_keep_compressed_buffer        gdextension.MethodForClass `hash:"2586408642"`
	is_keeping_compressed_buffer      gdextension.MethodForClass `hash:"36873697"`
	set_keep_all_compressed_buffers   gdextension.MethodForClass `hash:"2586408642"`
	is_keeping_all_compressed_buffers gdextension.MethodForClass `hash:"2240911060"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("PortableCompressedTexture2D")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		gdextension.Free(gdextension.TypeStringName, &sname)
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

type Expanded [1]gdclass.PortableCompressedTexture2D

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsPortableCompressedTexture2D() Instance
}

/*
Initializes the compressed texture from a base image. The compression mode must be provided.
[param normal_map] is recommended to ensure optimum quality if this image will be used as a normal map.
If lossy compression is requested, the quality setting can optionally be provided. This maps to Lossy WebP compression quality.
*/
func (self Instance) CreateFromImage(image Image.Instance, compression_mode CompressionMode) { //gd:PortableCompressedTexture2D.create_from_image
	Advanced(self).CreateFromImage(image, compression_mode, false, float64(0.8))
}

/*
Initializes the compressed texture from a base image. The compression mode must be provided.
[param normal_map] is recommended to ensure optimum quality if this image will be used as a normal map.
If lossy compression is requested, the quality setting can optionally be provided. This maps to Lossy WebP compression quality.
*/
func (self Expanded) CreateFromImage(image Image.Instance, compression_mode CompressionMode, normal_map bool, lossy_quality Float.X) { //gd:PortableCompressedTexture2D.create_from_image
	Advanced(self).CreateFromImage(image, compression_mode, normal_map, float64(lossy_quality))
}

/*
Return the image format used (valid after initialized).
*/
func (self Instance) GetFormat() Image.Format { //gd:PortableCompressedTexture2D.get_format
	return Image.Format(Advanced(self).GetFormat())
}

/*
Return the compression mode used (valid after initialized).
*/
func (self Instance) GetCompressionMode() CompressionMode { //gd:PortableCompressedTexture2D.get_compression_mode
	return CompressionMode(Advanced(self).GetCompressionMode())
}

/*
Overrides the flag globally for all textures of this type. This is used primarily by the editor.
*/
func SetKeepAllCompressedBuffers(keep bool) { //gd:PortableCompressedTexture2D.set_keep_all_compressed_buffers
	self := Instance{}
	Advanced(self).SetKeepAllCompressedBuffers(keep)
}

/*
Return whether the flag is overridden for all textures of this type.
*/
func IsKeepingAllCompressedBuffers() bool { //gd:PortableCompressedTexture2D.is_keeping_all_compressed_buffers
	self := Instance{}
	return bool(Advanced(self).IsKeepingAllCompressedBuffers())
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.PortableCompressedTexture2D

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = pointers.AsA[gdclass.PortableCompressedTexture2D](obj[0])
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = pointers.AsA[gdclass.PortableCompressedTexture2D](obj[0])
		return true
	}
	return false
}
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }
func (self *Extension[T]) AsObject() [1]gd.Object { return self.Super().AsObject() }
func New() Instance {
	if !gd.Linked {
		var placeholder = Instance([1]gdclass.PortableCompressedTexture2D{pointers.Add[gdclass.PortableCompressedTexture2D]([3]uint64{})})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(pointers.AsA[gd.Object](placeholder[0]), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	casted := Instance([1]gdclass.PortableCompressedTexture2D{pointers.New[gdclass.PortableCompressedTexture2D]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})})
	casted.AsRefCounted()[0].InitRef()
	casted.AsObject()[0].Notification(0, false)
	return casted
}

func (self Instance) SizeOverride() Vector2.XY {
	return Vector2.XY(class(self).GetSizeOverride())
}

func (self Instance) SetSizeOverride(value Vector2.XY) {
	class(self).SetSizeOverride(Vector2.XY(value))
}

func (self Instance) KeepCompressedBuffer() bool {
	return bool(class(self).IsKeepingCompressedBuffer())
}

func (self Instance) SetKeepCompressedBuffer(value bool) {
	class(self).SetKeepCompressedBuffer(value)
}

/*
Initializes the compressed texture from a base image. The compression mode must be provided.
[param normal_map] is recommended to ensure optimum quality if this image will be used as a normal map.
If lossy compression is requested, the quality setting can optionally be provided. This maps to Lossy WebP compression quality.
*/
//go:nosplit
func (self class) CreateFromImage(image [1]gdclass.Image, compression_mode CompressionMode, normal_map bool, lossy_quality float64) { //gd:PortableCompressedTexture2D.create_from_image
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.create_from_image, 0|(gdextension.SizeObject<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeBool<<12)|(gdextension.SizeFloat<<16), unsafe.Pointer(&struct {
		image            gdextension.Object
		compression_mode CompressionMode
		normal_map       bool
		lossy_quality    float64
	}{gdextension.Object(gd.ObjectChecked(image[0].AsObject())), compression_mode, normal_map, lossy_quality}))
}

/*
Return the image format used (valid after initialized).
*/
//go:nosplit
func (self class) GetFormat() Image.Format { //gd:PortableCompressedTexture2D.get_format
	var r_ret = gdextension.Call[Image.Format](gd.ObjectChecked(self.AsObject()), methods.get_format, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Return the compression mode used (valid after initialized).
*/
//go:nosplit
func (self class) GetCompressionMode() CompressionMode { //gd:PortableCompressedTexture2D.get_compression_mode
	var r_ret = gdextension.Call[CompressionMode](gd.ObjectChecked(self.AsObject()), methods.get_compression_mode, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetSizeOverride(size Vector2.XY) { //gd:PortableCompressedTexture2D.set_size_override
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_size_override, 0|(gdextension.SizeVector2<<4), unsafe.Pointer(&struct{ size Vector2.XY }{size}))
}

//go:nosplit
func (self class) GetSizeOverride() Vector2.XY { //gd:PortableCompressedTexture2D.get_size_override
	var r_ret = gdextension.Call[Vector2.XY](gd.ObjectChecked(self.AsObject()), methods.get_size_override, gdextension.SizeVector2, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetKeepCompressedBuffer(keep bool) { //gd:PortableCompressedTexture2D.set_keep_compressed_buffer
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_keep_compressed_buffer, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ keep bool }{keep}))
}

//go:nosplit
func (self class) IsKeepingCompressedBuffer() bool { //gd:PortableCompressedTexture2D.is_keeping_compressed_buffer
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_keeping_compressed_buffer, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Overrides the flag globally for all textures of this type. This is used primarily by the editor.
*/
//go:nosplit
func (self class) SetKeepAllCompressedBuffers(keep bool) { //gd:PortableCompressedTexture2D.set_keep_all_compressed_buffers
	gdextension.CallStatic[struct{}](methods.set_keep_all_compressed_buffers, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ keep bool }{keep}))
}

/*
Return whether the flag is overridden for all textures of this type.
*/
//go:nosplit
func (self class) IsKeepingAllCompressedBuffers() bool { //gd:PortableCompressedTexture2D.is_keeping_all_compressed_buffers
	var r_ret = gdextension.CallStatic[bool](methods.is_keeping_all_compressed_buffers, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}
func (self class) AsPortableCompressedTexture2D() Advanced {
	return Advanced{pointers.AsA[gdclass.PortableCompressedTexture2D](self[0])}
}
func (self Instance) AsPortableCompressedTexture2D() Instance {
	return Instance{pointers.AsA[gdclass.PortableCompressedTexture2D](self[0])}
}
func (self *Extension[T]) AsPortableCompressedTexture2D() Instance {
	return self.Super().AsPortableCompressedTexture2D()
}
func (self class) AsTexture2D() Texture2D.Advanced {
	return Texture2D.Advanced{pointers.AsA[gdclass.Texture2D](self[0])}
}
func (self *Extension[T]) AsTexture2D() Texture2D.Instance { return self.Super().AsTexture2D() }
func (self Instance) AsTexture2D() Texture2D.Instance {
	return Texture2D.Instance{pointers.AsA[gdclass.Texture2D](self[0])}
}
func (self class) AsTexture() Texture.Advanced {
	return Texture.Advanced{pointers.AsA[gdclass.Texture](self[0])}
}
func (self *Extension[T]) AsTexture() Texture.Instance { return self.Super().AsTexture() }
func (self Instance) AsTexture() Texture.Instance {
	return Texture.Instance{pointers.AsA[gdclass.Texture](self[0])}
}
func (self class) AsResource() Resource.Advanced {
	return Resource.Advanced{pointers.AsA[gdclass.Resource](self[0])}
}
func (self *Extension[T]) AsResource() Resource.Instance { return self.Super().AsResource() }
func (self Instance) AsResource() Resource.Instance {
	return Resource.Instance{pointers.AsA[gdclass.Resource](self[0])}
}
func (self class) AsRefCounted() [1]gd.RefCounted {
	return [1]gd.RefCounted{gd.RefCounted(pointers.AsA[gd.Object](self[0]))}
}
func (self *Extension[T]) AsRefCounted() [1]gd.RefCounted { return self.Super().AsRefCounted() }
func (self Instance) AsRefCounted() [1]gd.RefCounted {
	return [1]gd.RefCounted{gd.RefCounted(pointers.AsA[gd.Object](self[0]))}
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Texture2D.Advanced(self.AsTexture2D()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Texture2D.Instance(self.AsTexture2D()), name)
	}
}
func init() {
	gdclass.Register("PortableCompressedTexture2D", func(ptr gd.Object) any { return Instance{pointers.AsA[gdclass.PortableCompressedTexture2D](ptr)} })
}

type CompressionMode int //gd:PortableCompressedTexture2D.CompressionMode

const (
	CompressionModeLossless       CompressionMode = 0
	CompressionModeLossy          CompressionMode = 1
	CompressionModeBasisUniversal CompressionMode = 2
	CompressionModeS3tc           CompressionMode = 3
	CompressionModeEtc2           CompressionMode = 4
	CompressionModeBptc           CompressionMode = 5
)
