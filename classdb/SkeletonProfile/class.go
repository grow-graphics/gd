// Code generated by the generate package DO NOT EDIT

// Package SkeletonProfile provides methods for working with SkeletonProfile object instances.
package SkeletonProfile

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/Resource"
import "graphics.gd/classdb/Texture2D"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"
import "graphics.gd/variant/Transform3D"
import "graphics.gd/variant/Vector2"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
This resource is used in [EditorScenePostImport]. Some parameters are referring to bones in [Skeleton3D], [Skin], [Animation], and some other nodes are rewritten based on the parameters of [SkeletonProfile].
[b]Note:[/b] These parameters need to be set only when creating a custom profile. In [SkeletonProfileHumanoid], they are defined internally as read-only values.
*/
type Instance [1]gdclass.SkeletonProfile

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	set_root_bone       gdextension.MethodForClass `hash:"3304788590"`
	get_root_bone       gdextension.MethodForClass `hash:"2737447660"`
	set_scale_base_bone gdextension.MethodForClass `hash:"3304788590"`
	get_scale_base_bone gdextension.MethodForClass `hash:"2737447660"`
	set_group_size      gdextension.MethodForClass `hash:"1286410249"`
	get_group_size      gdextension.MethodForClass `hash:"2455072627"`
	get_group_name      gdextension.MethodForClass `hash:"659327637"`
	set_group_name      gdextension.MethodForClass `hash:"3780747571"`
	get_texture         gdextension.MethodForClass `hash:"3536238170"`
	set_texture         gdextension.MethodForClass `hash:"666127730"`
	set_bone_size       gdextension.MethodForClass `hash:"1286410249"`
	get_bone_size       gdextension.MethodForClass `hash:"2455072627"`
	find_bone           gdextension.MethodForClass `hash:"2458036349"`
	get_bone_name       gdextension.MethodForClass `hash:"659327637"`
	set_bone_name       gdextension.MethodForClass `hash:"3780747571"`
	get_bone_parent     gdextension.MethodForClass `hash:"659327637"`
	set_bone_parent     gdextension.MethodForClass `hash:"3780747571"`
	get_tail_direction  gdextension.MethodForClass `hash:"2675997574"`
	set_tail_direction  gdextension.MethodForClass `hash:"1231951015"`
	get_bone_tail       gdextension.MethodForClass `hash:"659327637"`
	set_bone_tail       gdextension.MethodForClass `hash:"3780747571"`
	get_reference_pose  gdextension.MethodForClass `hash:"1965739696"`
	set_reference_pose  gdextension.MethodForClass `hash:"3616898986"`
	get_handle_offset   gdextension.MethodForClass `hash:"2299179447"`
	set_handle_offset   gdextension.MethodForClass `hash:"163021252"`
	get_group           gdextension.MethodForClass `hash:"659327637"`
	set_group           gdextension.MethodForClass `hash:"3780747571"`
	is_required         gdextension.MethodForClass `hash:"1116898809"`
	set_required        gdextension.MethodForClass `hash:"300928843"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("SkeletonProfile")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		gdextension.Free(gdextension.TypeStringName, &sname)
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsSkeletonProfile() Instance
}

/*
Returns the name of the group at [param group_idx] that will be the drawing group in the [BoneMap] editor.
*/
func (self Instance) GetGroupName(group_idx int) string { //gd:SkeletonProfile.get_group_name
	return string(Advanced(self).GetGroupName(int64(group_idx)).String())
}

/*
Sets the name of the group at [param group_idx] that will be the drawing group in the [BoneMap] editor.
*/
func (self Instance) SetGroupName(group_idx int, group_name string) { //gd:SkeletonProfile.set_group_name
	Advanced(self).SetGroupName(int64(group_idx), String.Name(String.New(group_name)))
}

/*
Returns the texture of the group at [param group_idx] that will be the drawing group background image in the [BoneMap] editor.
*/
func (self Instance) GetTexture(group_idx int) Texture2D.Instance { //gd:SkeletonProfile.get_texture
	return Texture2D.Instance(Advanced(self).GetTexture(int64(group_idx)))
}

/*
Sets the texture of the group at [param group_idx] that will be the drawing group background image in the [BoneMap] editor.
*/
func (self Instance) SetTexture(group_idx int, texture Texture2D.Instance) { //gd:SkeletonProfile.set_texture
	Advanced(self).SetTexture(int64(group_idx), texture)
}

/*
Returns the bone index that matches [param bone_name] as its name.
*/
func (self Instance) FindBone(bone_name string) int { //gd:SkeletonProfile.find_bone
	return int(int(Advanced(self).FindBone(String.Name(String.New(bone_name)))))
}

/*
Returns the name of the bone at [param bone_idx] that will be the key name in the [BoneMap].
In the retargeting process, the returned bone name is the bone name of the target skeleton.
*/
func (self Instance) GetBoneName(bone_idx int) string { //gd:SkeletonProfile.get_bone_name
	return string(Advanced(self).GetBoneName(int64(bone_idx)).String())
}

/*
Sets the name of the bone at [param bone_idx] that will be the key name in the [BoneMap].
In the retargeting process, the setting bone name is the bone name of the target skeleton.
*/
func (self Instance) SetBoneName(bone_idx int, bone_name string) { //gd:SkeletonProfile.set_bone_name
	Advanced(self).SetBoneName(int64(bone_idx), String.Name(String.New(bone_name)))
}

/*
Returns the name of the bone which is the parent to the bone at [param bone_idx]. The result is empty if the bone has no parent.
*/
func (self Instance) GetBoneParent(bone_idx int) string { //gd:SkeletonProfile.get_bone_parent
	return string(Advanced(self).GetBoneParent(int64(bone_idx)).String())
}

/*
Sets the bone with name [param bone_parent] as the parent of the bone at [param bone_idx]. If an empty string is passed, then the bone has no parent.
*/
func (self Instance) SetBoneParent(bone_idx int, bone_parent string) { //gd:SkeletonProfile.set_bone_parent
	Advanced(self).SetBoneParent(int64(bone_idx), String.Name(String.New(bone_parent)))
}

/*
Returns the tail direction of the bone at [param bone_idx].
*/
func (self Instance) GetTailDirection(bone_idx int) TailDirection { //gd:SkeletonProfile.get_tail_direction
	return TailDirection(Advanced(self).GetTailDirection(int64(bone_idx)))
}

/*
Sets the tail direction of the bone at [param bone_idx].
[b]Note:[/b] This only specifies the method of calculation. The actual coordinates required should be stored in an external skeleton, so the calculation itself needs to be done externally.
*/
func (self Instance) SetTailDirection(bone_idx int, tail_direction TailDirection) { //gd:SkeletonProfile.set_tail_direction
	Advanced(self).SetTailDirection(int64(bone_idx), tail_direction)
}

/*
Returns the name of the bone which is the tail of the bone at [param bone_idx].
*/
func (self Instance) GetBoneTail(bone_idx int) string { //gd:SkeletonProfile.get_bone_tail
	return string(Advanced(self).GetBoneTail(int64(bone_idx)).String())
}

/*
Sets the bone with name [param bone_tail] as the tail of the bone at [param bone_idx].
*/
func (self Instance) SetBoneTail(bone_idx int, bone_tail string) { //gd:SkeletonProfile.set_bone_tail
	Advanced(self).SetBoneTail(int64(bone_idx), String.Name(String.New(bone_tail)))
}

/*
Returns the reference pose transform for bone [param bone_idx].
*/
func (self Instance) GetReferencePose(bone_idx int) Transform3D.BasisOrigin { //gd:SkeletonProfile.get_reference_pose
	return Transform3D.BasisOrigin(Advanced(self).GetReferencePose(int64(bone_idx)))
}

/*
Sets the reference pose transform for bone [param bone_idx].
*/
func (self Instance) SetReferencePose(bone_idx int, bone_name Transform3D.BasisOrigin) { //gd:SkeletonProfile.set_reference_pose
	Advanced(self).SetReferencePose(int64(bone_idx), Transform3D.BasisOrigin(bone_name))
}

/*
Returns the offset of the bone at [param bone_idx] that will be the button position in the [BoneMap] editor.
This is the offset with origin at the top left corner of the square.
*/
func (self Instance) GetHandleOffset(bone_idx int) Vector2.XY { //gd:SkeletonProfile.get_handle_offset
	return Vector2.XY(Advanced(self).GetHandleOffset(int64(bone_idx)))
}

/*
Sets the offset of the bone at [param bone_idx] that will be the button position in the [BoneMap] editor.
This is the offset with origin at the top left corner of the square.
*/
func (self Instance) SetHandleOffset(bone_idx int, handle_offset Vector2.XY) { //gd:SkeletonProfile.set_handle_offset
	Advanced(self).SetHandleOffset(int64(bone_idx), Vector2.XY(handle_offset))
}

/*
Returns the group of the bone at [param bone_idx].
*/
func (self Instance) GetGroup(bone_idx int) string { //gd:SkeletonProfile.get_group
	return string(Advanced(self).GetGroup(int64(bone_idx)).String())
}

/*
Sets the group of the bone at [param bone_idx].
*/
func (self Instance) SetGroup(bone_idx int, group string) { //gd:SkeletonProfile.set_group
	Advanced(self).SetGroup(int64(bone_idx), String.Name(String.New(group)))
}

/*
Returns whether the bone at [param bone_idx] is required for retargeting.
This value is used by the bone map editor. If this method returns [code]true[/code], and no bone is assigned, the handle color will be red on the bone map editor.
*/
func (self Instance) IsRequired(bone_idx int) bool { //gd:SkeletonProfile.is_required
	return bool(Advanced(self).IsRequired(int64(bone_idx)))
}

/*
Sets the required status for bone [param bone_idx] to [param required].
*/
func (self Instance) SetRequired(bone_idx int, required bool) { //gd:SkeletonProfile.set_required
	Advanced(self).SetRequired(int64(bone_idx), required)
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.SkeletonProfile

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.SkeletonProfile)(unsafe.Pointer(&obj))
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.SkeletonProfile)(unsafe.Pointer(&obj))
		return true
	}
	return false
}

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {

	if !gd.Linked {
		var placeholder Instance
		*(*gd.Object)(unsafe.Pointer(&placeholder)) = pointers.Add[gd.Object]([3]uint64{})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(*(*gd.Object)(unsafe.Pointer(&placeholder)), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	object := [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})}
	casted := Instance{*(*gdclass.SkeletonProfile)(unsafe.Pointer(&object))}
	object[0].Notification(0, false)
	return casted
}

func (self Instance) RootBone() string {
	return string(class(self).GetRootBone().String())
}

func (self Instance) SetRootBone(value string) {
	class(self).SetRootBone(String.Name(String.New(value)))
}

func (self Instance) ScaleBaseBone() string {
	return string(class(self).GetScaleBaseBone().String())
}

func (self Instance) SetScaleBaseBone(value string) {
	class(self).SetScaleBaseBone(String.Name(String.New(value)))
}

func (self Instance) GroupSize() int {
	return int(int(class(self).GetGroupSize()))
}

func (self Instance) SetGroupSize(value int) {
	class(self).SetGroupSize(int64(value))
}

func (self Instance) BoneSize() int {
	return int(int(class(self).GetBoneSize()))
}

func (self Instance) SetBoneSize(value int) {
	class(self).SetBoneSize(int64(value))
}

//go:nosplit
func (self class) SetRootBone(bone_name String.Name) { //gd:SkeletonProfile.set_root_bone
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_root_bone, 0|(gdextension.SizeStringName<<4), unsafe.Pointer(&struct{ bone_name gdextension.StringName }{pointers.Get(gd.InternalStringName(bone_name))}))
}

//go:nosplit
func (self class) GetRootBone() String.Name { //gd:SkeletonProfile.get_root_bone
	var r_ret = gdextension.Call[gdextension.StringName](gd.ObjectChecked(self.AsObject()), methods.get_root_bone, gdextension.SizeStringName, unsafe.Pointer(&struct{}{}))
	var ret = String.Name(String.Via(gd.StringNameProxy{}, pointers.Pack(pointers.New[gd.StringName](r_ret))))
	return ret
}

//go:nosplit
func (self class) SetScaleBaseBone(bone_name String.Name) { //gd:SkeletonProfile.set_scale_base_bone
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_scale_base_bone, 0|(gdextension.SizeStringName<<4), unsafe.Pointer(&struct{ bone_name gdextension.StringName }{pointers.Get(gd.InternalStringName(bone_name))}))
}

//go:nosplit
func (self class) GetScaleBaseBone() String.Name { //gd:SkeletonProfile.get_scale_base_bone
	var r_ret = gdextension.Call[gdextension.StringName](gd.ObjectChecked(self.AsObject()), methods.get_scale_base_bone, gdextension.SizeStringName, unsafe.Pointer(&struct{}{}))
	var ret = String.Name(String.Via(gd.StringNameProxy{}, pointers.Pack(pointers.New[gd.StringName](r_ret))))
	return ret
}

//go:nosplit
func (self class) SetGroupSize(size int64) { //gd:SkeletonProfile.set_group_size
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_group_size, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ size int64 }{size}))
}

//go:nosplit
func (self class) GetGroupSize() int64 { //gd:SkeletonProfile.get_group_size
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_group_size, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the name of the group at [param group_idx] that will be the drawing group in the [BoneMap] editor.
*/
//go:nosplit
func (self class) GetGroupName(group_idx int64) String.Name { //gd:SkeletonProfile.get_group_name
	var r_ret = gdextension.Call[gdextension.StringName](gd.ObjectChecked(self.AsObject()), methods.get_group_name, gdextension.SizeStringName|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ group_idx int64 }{group_idx}))
	var ret = String.Name(String.Via(gd.StringNameProxy{}, pointers.Pack(pointers.New[gd.StringName](r_ret))))
	return ret
}

/*
Sets the name of the group at [param group_idx] that will be the drawing group in the [BoneMap] editor.
*/
//go:nosplit
func (self class) SetGroupName(group_idx int64, group_name String.Name) { //gd:SkeletonProfile.set_group_name
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_group_name, 0|(gdextension.SizeInt<<4)|(gdextension.SizeStringName<<8), unsafe.Pointer(&struct {
		group_idx  int64
		group_name gdextension.StringName
	}{group_idx, pointers.Get(gd.InternalStringName(group_name))}))
}

/*
Returns the texture of the group at [param group_idx] that will be the drawing group background image in the [BoneMap] editor.
*/
//go:nosplit
func (self class) GetTexture(group_idx int64) [1]gdclass.Texture2D { //gd:SkeletonProfile.get_texture
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_texture, gdextension.SizeObject|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ group_idx int64 }{group_idx}))
	var ret = [1]gdclass.Texture2D{gd.PointerWithOwnershipTransferredToGo[gdclass.Texture2D](r_ret)}
	return ret
}

/*
Sets the texture of the group at [param group_idx] that will be the drawing group background image in the [BoneMap] editor.
*/
//go:nosplit
func (self class) SetTexture(group_idx int64, texture [1]gdclass.Texture2D) { //gd:SkeletonProfile.set_texture
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_texture, 0|(gdextension.SizeInt<<4)|(gdextension.SizeObject<<8), unsafe.Pointer(&struct {
		group_idx int64
		texture   gdextension.Object
	}{group_idx, gdextension.Object(gd.CallerIncrements(texture[0].AsObject()))}))
}

//go:nosplit
func (self class) SetBoneSize(size int64) { //gd:SkeletonProfile.set_bone_size
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_bone_size, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ size int64 }{size}))
}

//go:nosplit
func (self class) GetBoneSize() int64 { //gd:SkeletonProfile.get_bone_size
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_bone_size, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the bone index that matches [param bone_name] as its name.
*/
//go:nosplit
func (self class) FindBone(bone_name String.Name) int64 { //gd:SkeletonProfile.find_bone
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.find_bone, gdextension.SizeInt|(gdextension.SizeStringName<<4), unsafe.Pointer(&struct{ bone_name gdextension.StringName }{pointers.Get(gd.InternalStringName(bone_name))}))
	var ret = r_ret
	return ret
}

/*
Returns the name of the bone at [param bone_idx] that will be the key name in the [BoneMap].
In the retargeting process, the returned bone name is the bone name of the target skeleton.
*/
//go:nosplit
func (self class) GetBoneName(bone_idx int64) String.Name { //gd:SkeletonProfile.get_bone_name
	var r_ret = gdextension.Call[gdextension.StringName](gd.ObjectChecked(self.AsObject()), methods.get_bone_name, gdextension.SizeStringName|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ bone_idx int64 }{bone_idx}))
	var ret = String.Name(String.Via(gd.StringNameProxy{}, pointers.Pack(pointers.New[gd.StringName](r_ret))))
	return ret
}

/*
Sets the name of the bone at [param bone_idx] that will be the key name in the [BoneMap].
In the retargeting process, the setting bone name is the bone name of the target skeleton.
*/
//go:nosplit
func (self class) SetBoneName(bone_idx int64, bone_name String.Name) { //gd:SkeletonProfile.set_bone_name
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_bone_name, 0|(gdextension.SizeInt<<4)|(gdextension.SizeStringName<<8), unsafe.Pointer(&struct {
		bone_idx  int64
		bone_name gdextension.StringName
	}{bone_idx, pointers.Get(gd.InternalStringName(bone_name))}))
}

/*
Returns the name of the bone which is the parent to the bone at [param bone_idx]. The result is empty if the bone has no parent.
*/
//go:nosplit
func (self class) GetBoneParent(bone_idx int64) String.Name { //gd:SkeletonProfile.get_bone_parent
	var r_ret = gdextension.Call[gdextension.StringName](gd.ObjectChecked(self.AsObject()), methods.get_bone_parent, gdextension.SizeStringName|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ bone_idx int64 }{bone_idx}))
	var ret = String.Name(String.Via(gd.StringNameProxy{}, pointers.Pack(pointers.New[gd.StringName](r_ret))))
	return ret
}

/*
Sets the bone with name [param bone_parent] as the parent of the bone at [param bone_idx]. If an empty string is passed, then the bone has no parent.
*/
//go:nosplit
func (self class) SetBoneParent(bone_idx int64, bone_parent String.Name) { //gd:SkeletonProfile.set_bone_parent
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_bone_parent, 0|(gdextension.SizeInt<<4)|(gdextension.SizeStringName<<8), unsafe.Pointer(&struct {
		bone_idx    int64
		bone_parent gdextension.StringName
	}{bone_idx, pointers.Get(gd.InternalStringName(bone_parent))}))
}

/*
Returns the tail direction of the bone at [param bone_idx].
*/
//go:nosplit
func (self class) GetTailDirection(bone_idx int64) TailDirection { //gd:SkeletonProfile.get_tail_direction
	var r_ret = gdextension.Call[TailDirection](gd.ObjectChecked(self.AsObject()), methods.get_tail_direction, gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ bone_idx int64 }{bone_idx}))
	var ret = r_ret
	return ret
}

/*
Sets the tail direction of the bone at [param bone_idx].
[b]Note:[/b] This only specifies the method of calculation. The actual coordinates required should be stored in an external skeleton, so the calculation itself needs to be done externally.
*/
//go:nosplit
func (self class) SetTailDirection(bone_idx int64, tail_direction TailDirection) { //gd:SkeletonProfile.set_tail_direction
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_tail_direction, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		bone_idx       int64
		tail_direction TailDirection
	}{bone_idx, tail_direction}))
}

/*
Returns the name of the bone which is the tail of the bone at [param bone_idx].
*/
//go:nosplit
func (self class) GetBoneTail(bone_idx int64) String.Name { //gd:SkeletonProfile.get_bone_tail
	var r_ret = gdextension.Call[gdextension.StringName](gd.ObjectChecked(self.AsObject()), methods.get_bone_tail, gdextension.SizeStringName|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ bone_idx int64 }{bone_idx}))
	var ret = String.Name(String.Via(gd.StringNameProxy{}, pointers.Pack(pointers.New[gd.StringName](r_ret))))
	return ret
}

/*
Sets the bone with name [param bone_tail] as the tail of the bone at [param bone_idx].
*/
//go:nosplit
func (self class) SetBoneTail(bone_idx int64, bone_tail String.Name) { //gd:SkeletonProfile.set_bone_tail
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_bone_tail, 0|(gdextension.SizeInt<<4)|(gdextension.SizeStringName<<8), unsafe.Pointer(&struct {
		bone_idx  int64
		bone_tail gdextension.StringName
	}{bone_idx, pointers.Get(gd.InternalStringName(bone_tail))}))
}

/*
Returns the reference pose transform for bone [param bone_idx].
*/
//go:nosplit
func (self class) GetReferencePose(bone_idx int64) Transform3D.BasisOrigin { //gd:SkeletonProfile.get_reference_pose
	var r_ret = gdextension.Call[Transform3D.BasisOrigin](gd.ObjectChecked(self.AsObject()), methods.get_reference_pose, gdextension.SizeTransform3D|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ bone_idx int64 }{bone_idx}))
	var ret = gd.Transposed(r_ret)
	return ret
}

/*
Sets the reference pose transform for bone [param bone_idx].
*/
//go:nosplit
func (self class) SetReferencePose(bone_idx int64, bone_name Transform3D.BasisOrigin) { //gd:SkeletonProfile.set_reference_pose
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_reference_pose, 0|(gdextension.SizeInt<<4)|(gdextension.SizeTransform3D<<8), unsafe.Pointer(&struct {
		bone_idx  int64
		bone_name Transform3D.BasisOrigin
	}{bone_idx, gd.Transposed(bone_name)}))
}

/*
Returns the offset of the bone at [param bone_idx] that will be the button position in the [BoneMap] editor.
This is the offset with origin at the top left corner of the square.
*/
//go:nosplit
func (self class) GetHandleOffset(bone_idx int64) Vector2.XY { //gd:SkeletonProfile.get_handle_offset
	var r_ret = gdextension.Call[Vector2.XY](gd.ObjectChecked(self.AsObject()), methods.get_handle_offset, gdextension.SizeVector2|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ bone_idx int64 }{bone_idx}))
	var ret = r_ret
	return ret
}

/*
Sets the offset of the bone at [param bone_idx] that will be the button position in the [BoneMap] editor.
This is the offset with origin at the top left corner of the square.
*/
//go:nosplit
func (self class) SetHandleOffset(bone_idx int64, handle_offset Vector2.XY) { //gd:SkeletonProfile.set_handle_offset
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_handle_offset, 0|(gdextension.SizeInt<<4)|(gdextension.SizeVector2<<8), unsafe.Pointer(&struct {
		bone_idx      int64
		handle_offset Vector2.XY
	}{bone_idx, handle_offset}))
}

/*
Returns the group of the bone at [param bone_idx].
*/
//go:nosplit
func (self class) GetGroup(bone_idx int64) String.Name { //gd:SkeletonProfile.get_group
	var r_ret = gdextension.Call[gdextension.StringName](gd.ObjectChecked(self.AsObject()), methods.get_group, gdextension.SizeStringName|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ bone_idx int64 }{bone_idx}))
	var ret = String.Name(String.Via(gd.StringNameProxy{}, pointers.Pack(pointers.New[gd.StringName](r_ret))))
	return ret
}

/*
Sets the group of the bone at [param bone_idx].
*/
//go:nosplit
func (self class) SetGroup(bone_idx int64, group String.Name) { //gd:SkeletonProfile.set_group
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_group, 0|(gdextension.SizeInt<<4)|(gdextension.SizeStringName<<8), unsafe.Pointer(&struct {
		bone_idx int64
		group    gdextension.StringName
	}{bone_idx, pointers.Get(gd.InternalStringName(group))}))
}

/*
Returns whether the bone at [param bone_idx] is required for retargeting.
This value is used by the bone map editor. If this method returns [code]true[/code], and no bone is assigned, the handle color will be red on the bone map editor.
*/
//go:nosplit
func (self class) IsRequired(bone_idx int64) bool { //gd:SkeletonProfile.is_required
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_required, gdextension.SizeBool|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ bone_idx int64 }{bone_idx}))
	var ret = r_ret
	return ret
}

/*
Sets the required status for bone [param bone_idx] to [param required].
*/
//go:nosplit
func (self class) SetRequired(bone_idx int64, required bool) { //gd:SkeletonProfile.set_required
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_required, 0|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		bone_idx int64
		required bool
	}{bone_idx, required}))
}
func (self Instance) OnProfileUpdated(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("profile_updated"), gd.NewCallable(cb), 0)
}

func (self class) AsSkeletonProfile() Advanced         { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsSkeletonProfile() Instance      { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsSkeletonProfile() Instance { return self.Super().AsSkeletonProfile() }
func (self class) AsResource() Resource.Advanced {
	return *((*Resource.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsResource() Resource.Instance { return self.Super().AsResource() }
func (self Instance) AsResource() Resource.Instance {
	return *((*Resource.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsRefCounted() [1]gd.RefCounted { return self.Super().AsRefCounted() }
func (self Instance) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Resource.Advanced(self.AsResource()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Resource.Instance(self.AsResource()), name)
	}
}
func init() {
	gdclass.Register("SkeletonProfile", func(ptr gd.Object) any { return *(*Instance)(unsafe.Pointer(&ptr)) })
}

type TailDirection int //gd:SkeletonProfile.TailDirection

const (
	/*Direction to the average coordinates of bone children.*/
	TailDirectionAverageChildren TailDirection = 0
	/*Direction to the coordinates of specified bone child.*/
	TailDirectionSpecificChild TailDirection = 1
	/*Direction is not calculated.*/
	TailDirectionEnd TailDirection = 2
)
