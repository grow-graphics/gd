// Code generated by the generate package DO NOT EDIT

// Package Font provides methods for working with Font object instances.
package Font

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdunsafe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/GUI"
import "graphics.gd/classdb/Resource"
import "graphics.gd/classdb/TextServer"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Color"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"
import "graphics.gd/variant/Transform2D"
import "graphics.gd/variant/Vector2"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = gdunsafe.Use{}
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
Abstract base class for different font types. It has methods for drawing text and font character introspection.
*/
type Instance [1]gdclass.Font

func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

type Expanded [1]gdclass.Font

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsFont() Instance
}

/*
Returns [TextServer] RID of the font cache for specific variation.
*/
func (self Instance) FindVariation(variation_coordinates map[string]float32) RID.Font { //gd:Font.find_variation
	return RID.Font(Advanced(self).FindVariation(gd.DictionaryFromMap(variation_coordinates), int64(0), float64(0.0), Transform2D.OriginXY(gd.NewTransform2D(1, 0, 0, 1, 0, 0)), int64(0), int64(0), int64(0), int64(0), float64(0.0)))
}

/*
Returns [TextServer] RID of the font cache for specific variation.
*/
func (self Expanded) FindVariation(variation_coordinates map[string]float32, face_index int, strength Float.X, transform Transform2D.OriginXY, spacing_top int, spacing_bottom int, spacing_space int, spacing_glyph int, baseline_offset Float.X) RID.Font { //gd:Font.find_variation
	return RID.Font(Advanced(self).FindVariation(gd.DictionaryFromMap(variation_coordinates), int64(face_index), float64(strength), Transform2D.OriginXY(transform), int64(spacing_top), int64(spacing_bottom), int64(spacing_space), int64(spacing_glyph), float64(baseline_offset)))
}

/*
Returns [Array] of valid [Font] [RID]s, which can be passed to the [TextServer] methods.
*/
func (self Instance) GetRids() [][]RID.Font { //gd:Font.get_rids
	return [][]RID.Font(gd.ArrayAs[[][]RID.Font](gd.InternalArray(Advanced(self).GetRids())))
}

/*
Returns the total average font height (ascent plus descent) in pixels.
[b]Note:[/b] Real height of the string is context-dependent and can be significantly different from the value returned by this function. Use it only as rough estimate (e.g. as the height of empty line).
*/
func (self Instance) GetHeight() Float.X { //gd:Font.get_height
	return Float.X(Float.X(Advanced(self).GetHeight(int64(16))))
}

/*
Returns the total average font height (ascent plus descent) in pixels.
[b]Note:[/b] Real height of the string is context-dependent and can be significantly different from the value returned by this function. Use it only as rough estimate (e.g. as the height of empty line).
*/
func (self Expanded) GetHeight(font_size int) Float.X { //gd:Font.get_height
	return Float.X(Float.X(Advanced(self).GetHeight(int64(font_size))))
}

/*
Returns the average font ascent (number of pixels above the baseline).
[b]Note:[/b] Real ascent of the string is context-dependent and can be significantly different from the value returned by this function. Use it only as rough estimate (e.g. as the ascent of empty line).
*/
func (self Instance) GetAscent() Float.X { //gd:Font.get_ascent
	return Float.X(Float.X(Advanced(self).GetAscent(int64(16))))
}

/*
Returns the average font ascent (number of pixels above the baseline).
[b]Note:[/b] Real ascent of the string is context-dependent and can be significantly different from the value returned by this function. Use it only as rough estimate (e.g. as the ascent of empty line).
*/
func (self Expanded) GetAscent(font_size int) Float.X { //gd:Font.get_ascent
	return Float.X(Float.X(Advanced(self).GetAscent(int64(font_size))))
}

/*
Returns the average font descent (number of pixels below the baseline).
[b]Note:[/b] Real descent of the string is context-dependent and can be significantly different from the value returned by this function. Use it only as rough estimate (e.g. as the descent of empty line).
*/
func (self Instance) GetDescent() Float.X { //gd:Font.get_descent
	return Float.X(Float.X(Advanced(self).GetDescent(int64(16))))
}

/*
Returns the average font descent (number of pixels below the baseline).
[b]Note:[/b] Real descent of the string is context-dependent and can be significantly different from the value returned by this function. Use it only as rough estimate (e.g. as the descent of empty line).
*/
func (self Expanded) GetDescent(font_size int) Float.X { //gd:Font.get_descent
	return Float.X(Float.X(Advanced(self).GetDescent(int64(font_size))))
}

/*
Returns average pixel offset of the underline below the baseline.
[b]Note:[/b] Real underline position of the string is context-dependent and can be significantly different from the value returned by this function. Use it only as rough estimate.
*/
func (self Instance) GetUnderlinePosition() Float.X { //gd:Font.get_underline_position
	return Float.X(Float.X(Advanced(self).GetUnderlinePosition(int64(16))))
}

/*
Returns average pixel offset of the underline below the baseline.
[b]Note:[/b] Real underline position of the string is context-dependent and can be significantly different from the value returned by this function. Use it only as rough estimate.
*/
func (self Expanded) GetUnderlinePosition(font_size int) Float.X { //gd:Font.get_underline_position
	return Float.X(Float.X(Advanced(self).GetUnderlinePosition(int64(font_size))))
}

/*
Returns average thickness of the underline.
[b]Note:[/b] Real underline thickness of the string is context-dependent and can be significantly different from the value returned by this function. Use it only as rough estimate.
*/
func (self Instance) GetUnderlineThickness() Float.X { //gd:Font.get_underline_thickness
	return Float.X(Float.X(Advanced(self).GetUnderlineThickness(int64(16))))
}

/*
Returns average thickness of the underline.
[b]Note:[/b] Real underline thickness of the string is context-dependent and can be significantly different from the value returned by this function. Use it only as rough estimate.
*/
func (self Expanded) GetUnderlineThickness(font_size int) Float.X { //gd:Font.get_underline_thickness
	return Float.X(Float.X(Advanced(self).GetUnderlineThickness(int64(font_size))))
}

/*
Returns font family name.
*/
func (self Instance) GetFontName() string { //gd:Font.get_font_name
	return string(Advanced(self).GetFontName().String())
}

/*
Returns font style name.
*/
func (self Instance) GetFontStyleName() string { //gd:Font.get_font_style_name
	return string(Advanced(self).GetFontStyleName().String())
}

/*
Returns [Dictionary] with OpenType font name strings (localized font names, version, description, license information, sample text, etc.).
*/
func (self Instance) GetOtNameStrings() map[string]string { //gd:Font.get_ot_name_strings
	return map[string]string(gd.DictionaryAs[map[string]string](Advanced(self).GetOtNameStrings()))
}

/*
Returns font style flags, see [enum TextServer.FontStyle].
*/
func (self Instance) GetFontStyle() TextServer.FontStyle { //gd:Font.get_font_style
	return TextServer.FontStyle(Advanced(self).GetFontStyle())
}

/*
Returns weight (boldness) of the font. A value in the [code]100...999[/code] range, normal font weight is [code]400[/code], bold font weight is [code]700[/code].
*/
func (self Instance) GetFontWeight() int { //gd:Font.get_font_weight
	return int(int(Advanced(self).GetFontWeight()))
}

/*
Returns font stretch amount, compared to a normal width. A percentage value between [code]50%[/code] and [code]200%[/code].
*/
func (self Instance) GetFontStretch() int { //gd:Font.get_font_stretch
	return int(int(Advanced(self).GetFontStretch()))
}

/*
Returns the spacing for the given [code]type[/code] (see [enum TextServer.SpacingType]).
*/
func (self Instance) GetSpacing(spacing TextServer.SpacingType) int { //gd:Font.get_spacing
	return int(int(Advanced(self).GetSpacing(spacing)))
}

/*
Returns a set of OpenType feature tags. More info: [url=https://docs.microsoft.com/en-us/typography/opentype/spec/featuretags]OpenType feature tags[/url].
*/
func (self Instance) GetOpentypeFeatures() map[string]string { //gd:Font.get_opentype_features
	return map[string]string(gd.DictionaryAs[map[string]string](Advanced(self).GetOpentypeFeatures()))
}

/*
Sets LRU cache capacity for [code]draw_*[/code] methods.
*/
func (self Instance) SetCacheCapacity(single_line int, multi_line int) { //gd:Font.set_cache_capacity
	Advanced(self).SetCacheCapacity(int64(single_line), int64(multi_line))
}

/*
Returns the size of a bounding box of a single-line string, taking kerning, advance and subpixel positioning into account. See also [method get_multiline_string_size] and [method draw_string].
For example, to get the string size as displayed by a single-line Label, use:
[codeblocks]
[gdscript]
var string_size = $Label.get_theme_font("font").get_string_size($Label.text, HORIZONTAL_ALIGNMENT_LEFT, -1, $Label.get_theme_font_size("font_size"))
[/gdscript]
[csharp]
Label label = GetNode<Label>("Label");
Vector2 stringSize = label.GetThemeFont("font").GetStringSize(label.Text, HorizontalAlignment.Left, -1, label.GetThemeFontSize("font_size"));
[/csharp]
[/codeblocks]
[b]Note:[/b] Since kerning, advance and subpixel positioning are taken into account by [method get_string_size], using separate [method get_string_size] calls on substrings of a string then adding the results together will return a different result compared to using a single [method get_string_size] call on the full string.
[b]Note:[/b] Real height of the string is context-dependent and can be significantly different from the value returned by [method get_height].
*/
func (self Instance) GetStringSize(text string) Vector2.XY { //gd:Font.get_string_size
	return Vector2.XY(Advanced(self).GetStringSize(String.New(text), 0, float64(-1), int64(16), 3, 0, 0))
}

/*
Returns the size of a bounding box of a single-line string, taking kerning, advance and subpixel positioning into account. See also [method get_multiline_string_size] and [method draw_string].
For example, to get the string size as displayed by a single-line Label, use:
[codeblocks]
[gdscript]
var string_size = $Label.get_theme_font("font").get_string_size($Label.text, HORIZONTAL_ALIGNMENT_LEFT, -1, $Label.get_theme_font_size("font_size"))
[/gdscript]
[csharp]
Label label = GetNode<Label>("Label");
Vector2 stringSize = label.GetThemeFont("font").GetStringSize(label.Text, HorizontalAlignment.Left, -1, label.GetThemeFontSize("font_size"));
[/csharp]
[/codeblocks]
[b]Note:[/b] Since kerning, advance and subpixel positioning are taken into account by [method get_string_size], using separate [method get_string_size] calls on substrings of a string then adding the results together will return a different result compared to using a single [method get_string_size] call on the full string.
[b]Note:[/b] Real height of the string is context-dependent and can be significantly different from the value returned by [method get_height].
*/
func (self Expanded) GetStringSize(text string, alignment GUI.HorizontalAlignment, width Float.X, font_size int, justification_flags TextServer.JustificationFlag, direction TextServer.Direction, orientation TextServer.Orientation) Vector2.XY { //gd:Font.get_string_size
	return Vector2.XY(Advanced(self).GetStringSize(String.New(text), alignment, float64(width), int64(font_size), justification_flags, direction, orientation))
}

/*
Returns the size of a bounding box of a string broken into the lines, taking kerning and advance into account.
See also [method draw_multiline_string].
*/
func (self Instance) GetMultilineStringSize(text string) Vector2.XY { //gd:Font.get_multiline_string_size
	return Vector2.XY(Advanced(self).GetMultilineStringSize(String.New(text), 0, float64(-1), int64(16), int64(-1), 3, 3, 0, 0))
}

/*
Returns the size of a bounding box of a string broken into the lines, taking kerning and advance into account.
See also [method draw_multiline_string].
*/
func (self Expanded) GetMultilineStringSize(text string, alignment GUI.HorizontalAlignment, width Float.X, font_size int, max_lines int, brk_flags TextServer.LineBreakFlag, justification_flags TextServer.JustificationFlag, direction TextServer.Direction, orientation TextServer.Orientation) Vector2.XY { //gd:Font.get_multiline_string_size
	return Vector2.XY(Advanced(self).GetMultilineStringSize(String.New(text), alignment, float64(width), int64(font_size), int64(max_lines), brk_flags, justification_flags, direction, orientation))
}

/*
Draw [param text] into a canvas item using the font, at a given position, with [param modulate] color, optionally clipping the width and aligning horizontally. [param pos] specifies the baseline, not the top. To draw from the top, [i]ascent[/i] must be added to the Y axis.
See also [method CanvasItem.draw_string].
*/
func (self Instance) DrawString(canvas_item RID.CanvasItem, pos Vector2.XY, text string) { //gd:Font.draw_string
	Advanced(self).DrawString(RID.Any(canvas_item), Vector2.XY(pos), String.New(text), 0, float64(-1), int64(16), Color.RGBA(gd.Color{1, 1, 1, 1}), 3, 0, 0)
}

/*
Draw [param text] into a canvas item using the font, at a given position, with [param modulate] color, optionally clipping the width and aligning horizontally. [param pos] specifies the baseline, not the top. To draw from the top, [i]ascent[/i] must be added to the Y axis.
See also [method CanvasItem.draw_string].
*/
func (self Expanded) DrawString(canvas_item RID.CanvasItem, pos Vector2.XY, text string, alignment GUI.HorizontalAlignment, width Float.X, font_size int, modulate Color.RGBA, justification_flags TextServer.JustificationFlag, direction TextServer.Direction, orientation TextServer.Orientation) { //gd:Font.draw_string
	Advanced(self).DrawString(RID.Any(canvas_item), Vector2.XY(pos), String.New(text), alignment, float64(width), int64(font_size), Color.RGBA(modulate), justification_flags, direction, orientation)
}

/*
Breaks [param text] into lines using rules specified by [param brk_flags] and draws it into a canvas item using the font, at a given position, with [param modulate] color, optionally clipping the width and aligning horizontally. [param pos] specifies the baseline of the first line, not the top. To draw from the top, [i]ascent[/i] must be added to the Y axis.
See also [method CanvasItem.draw_multiline_string].
*/
func (self Instance) DrawMultilineString(canvas_item RID.CanvasItem, pos Vector2.XY, text string) { //gd:Font.draw_multiline_string
	Advanced(self).DrawMultilineString(RID.Any(canvas_item), Vector2.XY(pos), String.New(text), 0, float64(-1), int64(16), int64(-1), Color.RGBA(gd.Color{1, 1, 1, 1}), 3, 3, 0, 0)
}

/*
Breaks [param text] into lines using rules specified by [param brk_flags] and draws it into a canvas item using the font, at a given position, with [param modulate] color, optionally clipping the width and aligning horizontally. [param pos] specifies the baseline of the first line, not the top. To draw from the top, [i]ascent[/i] must be added to the Y axis.
See also [method CanvasItem.draw_multiline_string].
*/
func (self Expanded) DrawMultilineString(canvas_item RID.CanvasItem, pos Vector2.XY, text string, alignment GUI.HorizontalAlignment, width Float.X, font_size int, max_lines int, modulate Color.RGBA, brk_flags TextServer.LineBreakFlag, justification_flags TextServer.JustificationFlag, direction TextServer.Direction, orientation TextServer.Orientation) { //gd:Font.draw_multiline_string
	Advanced(self).DrawMultilineString(RID.Any(canvas_item), Vector2.XY(pos), String.New(text), alignment, float64(width), int64(font_size), int64(max_lines), Color.RGBA(modulate), brk_flags, justification_flags, direction, orientation)
}

/*
Draw [param text] outline into a canvas item using the font, at a given position, with [param modulate] color and [param size] outline size, optionally clipping the width and aligning horizontally. [param pos] specifies the baseline, not the top. To draw from the top, [i]ascent[/i] must be added to the Y axis.
See also [method CanvasItem.draw_string_outline].
*/
func (self Instance) DrawStringOutline(canvas_item RID.CanvasItem, pos Vector2.XY, text string) { //gd:Font.draw_string_outline
	Advanced(self).DrawStringOutline(RID.Any(canvas_item), Vector2.XY(pos), String.New(text), 0, float64(-1), int64(16), int64(1), Color.RGBA(gd.Color{1, 1, 1, 1}), 3, 0, 0)
}

/*
Draw [param text] outline into a canvas item using the font, at a given position, with [param modulate] color and [param size] outline size, optionally clipping the width and aligning horizontally. [param pos] specifies the baseline, not the top. To draw from the top, [i]ascent[/i] must be added to the Y axis.
See also [method CanvasItem.draw_string_outline].
*/
func (self Expanded) DrawStringOutline(canvas_item RID.CanvasItem, pos Vector2.XY, text string, alignment GUI.HorizontalAlignment, width Float.X, font_size int, size int, modulate Color.RGBA, justification_flags TextServer.JustificationFlag, direction TextServer.Direction, orientation TextServer.Orientation) { //gd:Font.draw_string_outline
	Advanced(self).DrawStringOutline(RID.Any(canvas_item), Vector2.XY(pos), String.New(text), alignment, float64(width), int64(font_size), int64(size), Color.RGBA(modulate), justification_flags, direction, orientation)
}

/*
Breaks [param text] to the lines using rules specified by [param brk_flags] and draws text outline into a canvas item using the font, at a given position, with [param modulate] color and [param size] outline size, optionally clipping the width and aligning horizontally. [param pos] specifies the baseline of the first line, not the top. To draw from the top, [i]ascent[/i] must be added to the Y axis.
See also [method CanvasItem.draw_multiline_string_outline].
*/
func (self Instance) DrawMultilineStringOutline(canvas_item RID.CanvasItem, pos Vector2.XY, text string) { //gd:Font.draw_multiline_string_outline
	Advanced(self).DrawMultilineStringOutline(RID.Any(canvas_item), Vector2.XY(pos), String.New(text), 0, float64(-1), int64(16), int64(-1), int64(1), Color.RGBA(gd.Color{1, 1, 1, 1}), 3, 3, 0, 0)
}

/*
Breaks [param text] to the lines using rules specified by [param brk_flags] and draws text outline into a canvas item using the font, at a given position, with [param modulate] color and [param size] outline size, optionally clipping the width and aligning horizontally. [param pos] specifies the baseline of the first line, not the top. To draw from the top, [i]ascent[/i] must be added to the Y axis.
See also [method CanvasItem.draw_multiline_string_outline].
*/
func (self Expanded) DrawMultilineStringOutline(canvas_item RID.CanvasItem, pos Vector2.XY, text string, alignment GUI.HorizontalAlignment, width Float.X, font_size int, max_lines int, size int, modulate Color.RGBA, brk_flags TextServer.LineBreakFlag, justification_flags TextServer.JustificationFlag, direction TextServer.Direction, orientation TextServer.Orientation) { //gd:Font.draw_multiline_string_outline
	Advanced(self).DrawMultilineStringOutline(RID.Any(canvas_item), Vector2.XY(pos), String.New(text), alignment, float64(width), int64(font_size), int64(max_lines), int64(size), Color.RGBA(modulate), brk_flags, justification_flags, direction, orientation)
}

/*
Returns the size of a character. Does not take kerning into account.
[b]Note:[/b] Do not use this function to calculate width of the string character by character, use [method get_string_size] or [TextLine] instead. The height returned is the font height (see also [method get_height]) and has no relation to the glyph height.
*/
func (self Instance) GetCharSize(char int, font_size int) Vector2.XY { //gd:Font.get_char_size
	return Vector2.XY(Advanced(self).GetCharSize(int64(char), int64(font_size)))
}

/*
Draw a single Unicode character [param char] into a canvas item using the font, at a given position, with [param modulate] color. [param pos] specifies the baseline, not the top. To draw from the top, [i]ascent[/i] must be added to the Y axis.
[b]Note:[/b] Do not use this function to draw strings character by character, use [method draw_string] or [TextLine] instead.
*/
func (self Instance) DrawChar(canvas_item RID.CanvasItem, pos Vector2.XY, char int, font_size int) Float.X { //gd:Font.draw_char
	return Float.X(Float.X(Advanced(self).DrawChar(RID.Any(canvas_item), Vector2.XY(pos), int64(char), int64(font_size), Color.RGBA(gd.Color{1, 1, 1, 1}))))
}

/*
Draw a single Unicode character [param char] into a canvas item using the font, at a given position, with [param modulate] color. [param pos] specifies the baseline, not the top. To draw from the top, [i]ascent[/i] must be added to the Y axis.
[b]Note:[/b] Do not use this function to draw strings character by character, use [method draw_string] or [TextLine] instead.
*/
func (self Expanded) DrawChar(canvas_item RID.CanvasItem, pos Vector2.XY, char int, font_size int, modulate Color.RGBA) Float.X { //gd:Font.draw_char
	return Float.X(Float.X(Advanced(self).DrawChar(RID.Any(canvas_item), Vector2.XY(pos), int64(char), int64(font_size), Color.RGBA(modulate))))
}

/*
Draw a single Unicode character [param char] outline into a canvas item using the font, at a given position, with [param modulate] color and [param size] outline size. [param pos] specifies the baseline, not the top. To draw from the top, [i]ascent[/i] must be added to the Y axis.
[b]Note:[/b] Do not use this function to draw strings character by character, use [method draw_string] or [TextLine] instead.
*/
func (self Instance) DrawCharOutline(canvas_item RID.CanvasItem, pos Vector2.XY, char int, font_size int) Float.X { //gd:Font.draw_char_outline
	return Float.X(Float.X(Advanced(self).DrawCharOutline(RID.Any(canvas_item), Vector2.XY(pos), int64(char), int64(font_size), int64(-1), Color.RGBA(gd.Color{1, 1, 1, 1}))))
}

/*
Draw a single Unicode character [param char] outline into a canvas item using the font, at a given position, with [param modulate] color and [param size] outline size. [param pos] specifies the baseline, not the top. To draw from the top, [i]ascent[/i] must be added to the Y axis.
[b]Note:[/b] Do not use this function to draw strings character by character, use [method draw_string] or [TextLine] instead.
*/
func (self Expanded) DrawCharOutline(canvas_item RID.CanvasItem, pos Vector2.XY, char int, font_size int, size int, modulate Color.RGBA) Float.X { //gd:Font.draw_char_outline
	return Float.X(Float.X(Advanced(self).DrawCharOutline(RID.Any(canvas_item), Vector2.XY(pos), int64(char), int64(font_size), int64(size), Color.RGBA(modulate))))
}

/*
Returns [code]true[/code] if a Unicode [param char] is available in the font.
*/
func (self Instance) HasChar(char int) bool { //gd:Font.has_char
	return bool(Advanced(self).HasChar(int64(char)))
}

/*
Returns a string containing all the characters available in the font.
If a given character is included in more than one font data source, it appears only once in the returned string.
*/
func (self Instance) GetSupportedChars() string { //gd:Font.get_supported_chars
	return string(Advanced(self).GetSupportedChars().String())
}

/*
Returns [code]true[/code], if font supports given language ([url=https://en.wikipedia.org/wiki/ISO_639-1]ISO 639[/url] code).
*/
func (self Instance) IsLanguageSupported(language string) bool { //gd:Font.is_language_supported
	return bool(Advanced(self).IsLanguageSupported(String.New(language)))
}

/*
Returns [code]true[/code], if font supports given script ([url=https://en.wikipedia.org/wiki/ISO_15924]ISO 15924[/url] code).
*/
func (self Instance) IsScriptSupported(script string) bool { //gd:Font.is_script_supported
	return bool(Advanced(self).IsScriptSupported(String.New(script)))
}

/*
Returns list of OpenType features supported by font.
*/
func (self Instance) GetSupportedFeatureList() map[string]string { //gd:Font.get_supported_feature_list
	return map[string]string(gd.DictionaryAs[map[string]string](Advanced(self).GetSupportedFeatureList()))
}

/*
Returns list of supported [url=https://docs.microsoft.com/en-us/typography/opentype/spec/dvaraxisreg]variation coordinates[/url], each coordinate is returned as [code]tag: Vector3i(min_value,max_value,default_value)[/code].
Font variations allow for continuous change of glyph characteristics along some given design axis, such as weight, width or slant.
To print available variation axes of a variable font:
[codeblock]
var fv = FontVariation.new()
fv.base_font = load("res://RobotoFlex.ttf")
var variation_list = fv.get_supported_variation_list()
for tag in variation_list:

	var name = TextServerManager.get_primary_interface().tag_to_name(tag)
	var values = variation_list[tag]
	print("variation axis: %s (%d)\n\tmin, max, default: %s" % [name, tag, values])

[/codeblock]
[b]Note:[/b] To set and get variation coordinates of a [FontVariation], use [member FontVariation.variation_opentype].
*/
func (self Instance) GetSupportedVariationList() map[string]string { //gd:Font.get_supported_variation_list
	return map[string]string(gd.DictionaryAs[map[string]string](Advanced(self).GetSupportedVariationList()))
}

/*
Returns number of faces in the TrueType / OpenType collection.
*/
func (self Instance) GetFaceCount() int { //gd:Font.get_face_count
	return int(int(Advanced(self).GetFaceCount()))
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.Font

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {
	object := gd.Global.ClassDB.ConstructObject(gd.NewStringName("Font"))
	casted := Instance{*(*gdclass.Font)(unsafe.Pointer(&object))}
	casted.AsRefCounted()[0].Reference()
	return casted
}

func (self Instance) Fallbacks() []Instance {
	return []Instance(gd.ArrayAs[[]Instance](gd.InternalArray(class(self).GetFallbacks())))
}

func (self Instance) SetFallbacks(value []Instance) {
	class(self).SetFallbacks(gd.ArrayFromSlice[Array.Contains[[1]gdclass.Font]](value))
}

//go:nosplit
func (self class) SetFallbacks(fallbacks Array.Contains[[1]gdclass.Font]) { //gd:Font.set_fallbacks
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.Font.Bind_set_fallbacks, 0|(gdextension.SizeArray<<4), unsafe.Pointer(&struct{ fallbacks gdextension.Array }{gdextension.Array(pointers.Get(gd.InternalArray(fallbacks))[0])}))
}

//go:nosplit
func (self class) GetFallbacks() Array.Contains[[1]gdclass.Font] { //gd:Font.get_fallbacks
	var r_ret = gdunsafe.Call[[1]gd.EnginePointer](self.AsObject(), gd.Global.Methods.Font.Bind_get_fallbacks, gdextension.SizeArray, unsafe.Pointer(&struct{}{}))
	var ret = Array.Through(gd.ArrayProxy[[1]gdclass.Font]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

/*
Returns [TextServer] RID of the font cache for specific variation.
*/
//go:nosplit
func (self class) FindVariation(variation_coordinates Dictionary.Any, face_index int64, strength float64, transform Transform2D.OriginXY, spacing_top int64, spacing_bottom int64, spacing_space int64, spacing_glyph int64, baseline_offset float64) RID.Any { //gd:Font.find_variation
	var r_ret = gdunsafe.Call[RID.Any](self.AsObject(), gd.Global.Methods.Font.Bind_find_variation, gdextension.SizeRID|(gdextension.SizeDictionary<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeFloat<<12)|(gdextension.SizeTransform2D<<16)|(gdextension.SizeInt<<20)|(gdextension.SizeInt<<24)|(gdextension.SizeInt<<28)|(gdextension.SizeInt<<32)|(gdextension.SizeFloat<<36), unsafe.Pointer(&struct {
		variation_coordinates gdextension.Dictionary
		face_index            int64
		strength              float64
		transform             Transform2D.OriginXY
		spacing_top           int64
		spacing_bottom        int64
		spacing_space         int64
		spacing_glyph         int64
		baseline_offset       float64
	}{gdextension.Dictionary(pointers.Get(gd.InternalDictionary(variation_coordinates))[0]), face_index, strength, transform, spacing_top, spacing_bottom, spacing_space, spacing_glyph, baseline_offset}))
	var ret = r_ret
	return ret
}

/*
Returns [Array] of valid [Font] [RID]s, which can be passed to the [TextServer] methods.
*/
//go:nosplit
func (self class) GetRids() Array.Contains[RID.Any] { //gd:Font.get_rids
	var r_ret = gdunsafe.Call[[1]gd.EnginePointer](self.AsObject(), gd.Global.Methods.Font.Bind_get_rids, gdextension.SizeArray, unsafe.Pointer(&struct{}{}))
	var ret = Array.Through(gd.ArrayProxy[RID.Any]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

/*
Returns the total average font height (ascent plus descent) in pixels.
[b]Note:[/b] Real height of the string is context-dependent and can be significantly different from the value returned by this function. Use it only as rough estimate (e.g. as the height of empty line).
*/
//go:nosplit
func (self class) GetHeight(font_size int64) float64 { //gd:Font.get_height
	var r_ret = gdunsafe.Call[float64](self.AsObject(), gd.Global.Methods.Font.Bind_get_height, gdextension.SizeFloat|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ font_size int64 }{font_size}))
	var ret = r_ret
	return ret
}

/*
Returns the average font ascent (number of pixels above the baseline).
[b]Note:[/b] Real ascent of the string is context-dependent and can be significantly different from the value returned by this function. Use it only as rough estimate (e.g. as the ascent of empty line).
*/
//go:nosplit
func (self class) GetAscent(font_size int64) float64 { //gd:Font.get_ascent
	var r_ret = gdunsafe.Call[float64](self.AsObject(), gd.Global.Methods.Font.Bind_get_ascent, gdextension.SizeFloat|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ font_size int64 }{font_size}))
	var ret = r_ret
	return ret
}

/*
Returns the average font descent (number of pixels below the baseline).
[b]Note:[/b] Real descent of the string is context-dependent and can be significantly different from the value returned by this function. Use it only as rough estimate (e.g. as the descent of empty line).
*/
//go:nosplit
func (self class) GetDescent(font_size int64) float64 { //gd:Font.get_descent
	var r_ret = gdunsafe.Call[float64](self.AsObject(), gd.Global.Methods.Font.Bind_get_descent, gdextension.SizeFloat|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ font_size int64 }{font_size}))
	var ret = r_ret
	return ret
}

/*
Returns average pixel offset of the underline below the baseline.
[b]Note:[/b] Real underline position of the string is context-dependent and can be significantly different from the value returned by this function. Use it only as rough estimate.
*/
//go:nosplit
func (self class) GetUnderlinePosition(font_size int64) float64 { //gd:Font.get_underline_position
	var r_ret = gdunsafe.Call[float64](self.AsObject(), gd.Global.Methods.Font.Bind_get_underline_position, gdextension.SizeFloat|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ font_size int64 }{font_size}))
	var ret = r_ret
	return ret
}

/*
Returns average thickness of the underline.
[b]Note:[/b] Real underline thickness of the string is context-dependent and can be significantly different from the value returned by this function. Use it only as rough estimate.
*/
//go:nosplit
func (self class) GetUnderlineThickness(font_size int64) float64 { //gd:Font.get_underline_thickness
	var r_ret = gdunsafe.Call[float64](self.AsObject(), gd.Global.Methods.Font.Bind_get_underline_thickness, gdextension.SizeFloat|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ font_size int64 }{font_size}))
	var ret = r_ret
	return ret
}

/*
Returns font family name.
*/
//go:nosplit
func (self class) GetFontName() String.Readable { //gd:Font.get_font_name
	var r_ret = gdunsafe.Call[[1]gd.EnginePointer](self.AsObject(), gd.Global.Methods.Font.Bind_get_font_name, gdextension.SizeString, unsafe.Pointer(&struct{}{}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Returns font style name.
*/
//go:nosplit
func (self class) GetFontStyleName() String.Readable { //gd:Font.get_font_style_name
	var r_ret = gdunsafe.Call[[1]gd.EnginePointer](self.AsObject(), gd.Global.Methods.Font.Bind_get_font_style_name, gdextension.SizeString, unsafe.Pointer(&struct{}{}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Returns [Dictionary] with OpenType font name strings (localized font names, version, description, license information, sample text, etc.).
*/
//go:nosplit
func (self class) GetOtNameStrings() Dictionary.Any { //gd:Font.get_ot_name_strings
	var r_ret = gdunsafe.Call[[1]gd.EnginePointer](self.AsObject(), gd.Global.Methods.Font.Bind_get_ot_name_strings, gdextension.SizeDictionary, unsafe.Pointer(&struct{}{}))
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret)))
	return ret
}

/*
Returns font style flags, see [enum TextServer.FontStyle].
*/
//go:nosplit
func (self class) GetFontStyle() TextServer.FontStyle { //gd:Font.get_font_style
	var r_ret = gdunsafe.Call[TextServer.FontStyle](self.AsObject(), gd.Global.Methods.Font.Bind_get_font_style, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns weight (boldness) of the font. A value in the [code]100...999[/code] range, normal font weight is [code]400[/code], bold font weight is [code]700[/code].
*/
//go:nosplit
func (self class) GetFontWeight() int64 { //gd:Font.get_font_weight
	var r_ret = gdunsafe.Call[int64](self.AsObject(), gd.Global.Methods.Font.Bind_get_font_weight, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns font stretch amount, compared to a normal width. A percentage value between [code]50%[/code] and [code]200%[/code].
*/
//go:nosplit
func (self class) GetFontStretch() int64 { //gd:Font.get_font_stretch
	var r_ret = gdunsafe.Call[int64](self.AsObject(), gd.Global.Methods.Font.Bind_get_font_stretch, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the spacing for the given [code]type[/code] (see [enum TextServer.SpacingType]).
*/
//go:nosplit
func (self class) GetSpacing(spacing TextServer.SpacingType) int64 { //gd:Font.get_spacing
	var r_ret = gdunsafe.Call[int64](self.AsObject(), gd.Global.Methods.Font.Bind_get_spacing, gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ spacing TextServer.SpacingType }{spacing}))
	var ret = r_ret
	return ret
}

/*
Returns a set of OpenType feature tags. More info: [url=https://docs.microsoft.com/en-us/typography/opentype/spec/featuretags]OpenType feature tags[/url].
*/
//go:nosplit
func (self class) GetOpentypeFeatures() Dictionary.Any { //gd:Font.get_opentype_features
	var r_ret = gdunsafe.Call[[1]gd.EnginePointer](self.AsObject(), gd.Global.Methods.Font.Bind_get_opentype_features, gdextension.SizeDictionary, unsafe.Pointer(&struct{}{}))
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret)))
	return ret
}

/*
Sets LRU cache capacity for [code]draw_*[/code] methods.
*/
//go:nosplit
func (self class) SetCacheCapacity(single_line int64, multi_line int64) { //gd:Font.set_cache_capacity
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.Font.Bind_set_cache_capacity, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		single_line int64
		multi_line  int64
	}{single_line, multi_line}))
}

/*
Returns the size of a bounding box of a single-line string, taking kerning, advance and subpixel positioning into account. See also [method get_multiline_string_size] and [method draw_string].
For example, to get the string size as displayed by a single-line Label, use:
[codeblocks]
[gdscript]
var string_size = $Label.get_theme_font("font").get_string_size($Label.text, HORIZONTAL_ALIGNMENT_LEFT, -1, $Label.get_theme_font_size("font_size"))
[/gdscript]
[csharp]
Label label = GetNode<Label>("Label");
Vector2 stringSize = label.GetThemeFont("font").GetStringSize(label.Text, HorizontalAlignment.Left, -1, label.GetThemeFontSize("font_size"));
[/csharp]
[/codeblocks]
[b]Note:[/b] Since kerning, advance and subpixel positioning are taken into account by [method get_string_size], using separate [method get_string_size] calls on substrings of a string then adding the results together will return a different result compared to using a single [method get_string_size] call on the full string.
[b]Note:[/b] Real height of the string is context-dependent and can be significantly different from the value returned by [method get_height].
*/
//go:nosplit
func (self class) GetStringSize(text String.Readable, alignment GUI.HorizontalAlignment, width float64, font_size int64, justification_flags TextServer.JustificationFlag, direction TextServer.Direction, orientation TextServer.Orientation) Vector2.XY { //gd:Font.get_string_size
	var r_ret = gdunsafe.Call[Vector2.XY](self.AsObject(), gd.Global.Methods.Font.Bind_get_string_size, gdextension.SizeVector2|(gdextension.SizeString<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeFloat<<12)|(gdextension.SizeInt<<16)|(gdextension.SizeInt<<20)|(gdextension.SizeInt<<24)|(gdextension.SizeInt<<28), unsafe.Pointer(&struct {
		text                gdextension.String
		alignment           GUI.HorizontalAlignment
		width               float64
		font_size           int64
		justification_flags TextServer.JustificationFlag
		direction           TextServer.Direction
		orientation         TextServer.Orientation
	}{gdextension.String(pointers.Get(gd.InternalString(text))[0]), alignment, width, font_size, justification_flags, direction, orientation}))
	var ret = r_ret
	return ret
}

/*
Returns the size of a bounding box of a string broken into the lines, taking kerning and advance into account.
See also [method draw_multiline_string].
*/
//go:nosplit
func (self class) GetMultilineStringSize(text String.Readable, alignment GUI.HorizontalAlignment, width float64, font_size int64, max_lines int64, brk_flags TextServer.LineBreakFlag, justification_flags TextServer.JustificationFlag, direction TextServer.Direction, orientation TextServer.Orientation) Vector2.XY { //gd:Font.get_multiline_string_size
	var r_ret = gdunsafe.Call[Vector2.XY](self.AsObject(), gd.Global.Methods.Font.Bind_get_multiline_string_size, gdextension.SizeVector2|(gdextension.SizeString<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeFloat<<12)|(gdextension.SizeInt<<16)|(gdextension.SizeInt<<20)|(gdextension.SizeInt<<24)|(gdextension.SizeInt<<28)|(gdextension.SizeInt<<32)|(gdextension.SizeInt<<36), unsafe.Pointer(&struct {
		text                gdextension.String
		alignment           GUI.HorizontalAlignment
		width               float64
		font_size           int64
		max_lines           int64
		brk_flags           TextServer.LineBreakFlag
		justification_flags TextServer.JustificationFlag
		direction           TextServer.Direction
		orientation         TextServer.Orientation
	}{gdextension.String(pointers.Get(gd.InternalString(text))[0]), alignment, width, font_size, max_lines, brk_flags, justification_flags, direction, orientation}))
	var ret = r_ret
	return ret
}

/*
Draw [param text] into a canvas item using the font, at a given position, with [param modulate] color, optionally clipping the width and aligning horizontally. [param pos] specifies the baseline, not the top. To draw from the top, [i]ascent[/i] must be added to the Y axis.
See also [method CanvasItem.draw_string].
*/
//go:nosplit
func (self class) DrawString(canvas_item RID.Any, pos Vector2.XY, text String.Readable, alignment GUI.HorizontalAlignment, width float64, font_size int64, modulate Color.RGBA, justification_flags TextServer.JustificationFlag, direction TextServer.Direction, orientation TextServer.Orientation) { //gd:Font.draw_string
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.Font.Bind_draw_string, 0|(gdextension.SizeRID<<4)|(gdextension.SizeVector2<<8)|(gdextension.SizeString<<12)|(gdextension.SizeInt<<16)|(gdextension.SizeFloat<<20)|(gdextension.SizeInt<<24)|(gdextension.SizeColor<<28)|(gdextension.SizeInt<<32)|(gdextension.SizeInt<<36)|(gdextension.SizeInt<<40), unsafe.Pointer(&struct {
		canvas_item         RID.Any
		pos                 Vector2.XY
		text                gdextension.String
		alignment           GUI.HorizontalAlignment
		width               float64
		font_size           int64
		modulate            Color.RGBA
		justification_flags TextServer.JustificationFlag
		direction           TextServer.Direction
		orientation         TextServer.Orientation
	}{canvas_item, pos, gdextension.String(pointers.Get(gd.InternalString(text))[0]), alignment, width, font_size, modulate, justification_flags, direction, orientation}))
}

/*
Breaks [param text] into lines using rules specified by [param brk_flags] and draws it into a canvas item using the font, at a given position, with [param modulate] color, optionally clipping the width and aligning horizontally. [param pos] specifies the baseline of the first line, not the top. To draw from the top, [i]ascent[/i] must be added to the Y axis.
See also [method CanvasItem.draw_multiline_string].
*/
//go:nosplit
func (self class) DrawMultilineString(canvas_item RID.Any, pos Vector2.XY, text String.Readable, alignment GUI.HorizontalAlignment, width float64, font_size int64, max_lines int64, modulate Color.RGBA, brk_flags TextServer.LineBreakFlag, justification_flags TextServer.JustificationFlag, direction TextServer.Direction, orientation TextServer.Orientation) { //gd:Font.draw_multiline_string
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.Font.Bind_draw_multiline_string, 0|(gdextension.SizeRID<<4)|(gdextension.SizeVector2<<8)|(gdextension.SizeString<<12)|(gdextension.SizeInt<<16)|(gdextension.SizeFloat<<20)|(gdextension.SizeInt<<24)|(gdextension.SizeInt<<28)|(gdextension.SizeColor<<32)|(gdextension.SizeInt<<36)|(gdextension.SizeInt<<40)|(gdextension.SizeInt<<44)|(gdextension.SizeInt<<48), unsafe.Pointer(&struct {
		canvas_item         RID.Any
		pos                 Vector2.XY
		text                gdextension.String
		alignment           GUI.HorizontalAlignment
		width               float64
		font_size           int64
		max_lines           int64
		modulate            Color.RGBA
		brk_flags           TextServer.LineBreakFlag
		justification_flags TextServer.JustificationFlag
		direction           TextServer.Direction
		orientation         TextServer.Orientation
	}{canvas_item, pos, gdextension.String(pointers.Get(gd.InternalString(text))[0]), alignment, width, font_size, max_lines, modulate, brk_flags, justification_flags, direction, orientation}))
}

/*
Draw [param text] outline into a canvas item using the font, at a given position, with [param modulate] color and [param size] outline size, optionally clipping the width and aligning horizontally. [param pos] specifies the baseline, not the top. To draw from the top, [i]ascent[/i] must be added to the Y axis.
See also [method CanvasItem.draw_string_outline].
*/
//go:nosplit
func (self class) DrawStringOutline(canvas_item RID.Any, pos Vector2.XY, text String.Readable, alignment GUI.HorizontalAlignment, width float64, font_size int64, size int64, modulate Color.RGBA, justification_flags TextServer.JustificationFlag, direction TextServer.Direction, orientation TextServer.Orientation) { //gd:Font.draw_string_outline
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.Font.Bind_draw_string_outline, 0|(gdextension.SizeRID<<4)|(gdextension.SizeVector2<<8)|(gdextension.SizeString<<12)|(gdextension.SizeInt<<16)|(gdextension.SizeFloat<<20)|(gdextension.SizeInt<<24)|(gdextension.SizeInt<<28)|(gdextension.SizeColor<<32)|(gdextension.SizeInt<<36)|(gdextension.SizeInt<<40)|(gdextension.SizeInt<<44), unsafe.Pointer(&struct {
		canvas_item         RID.Any
		pos                 Vector2.XY
		text                gdextension.String
		alignment           GUI.HorizontalAlignment
		width               float64
		font_size           int64
		size                int64
		modulate            Color.RGBA
		justification_flags TextServer.JustificationFlag
		direction           TextServer.Direction
		orientation         TextServer.Orientation
	}{canvas_item, pos, gdextension.String(pointers.Get(gd.InternalString(text))[0]), alignment, width, font_size, size, modulate, justification_flags, direction, orientation}))
}

/*
Breaks [param text] to the lines using rules specified by [param brk_flags] and draws text outline into a canvas item using the font, at a given position, with [param modulate] color and [param size] outline size, optionally clipping the width and aligning horizontally. [param pos] specifies the baseline of the first line, not the top. To draw from the top, [i]ascent[/i] must be added to the Y axis.
See also [method CanvasItem.draw_multiline_string_outline].
*/
//go:nosplit
func (self class) DrawMultilineStringOutline(canvas_item RID.Any, pos Vector2.XY, text String.Readable, alignment GUI.HorizontalAlignment, width float64, font_size int64, max_lines int64, size int64, modulate Color.RGBA, brk_flags TextServer.LineBreakFlag, justification_flags TextServer.JustificationFlag, direction TextServer.Direction, orientation TextServer.Orientation) { //gd:Font.draw_multiline_string_outline
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.Font.Bind_draw_multiline_string_outline, 0|(gdextension.SizeRID<<4)|(gdextension.SizeVector2<<8)|(gdextension.SizeString<<12)|(gdextension.SizeInt<<16)|(gdextension.SizeFloat<<20)|(gdextension.SizeInt<<24)|(gdextension.SizeInt<<28)|(gdextension.SizeInt<<32)|(gdextension.SizeColor<<36)|(gdextension.SizeInt<<40)|(gdextension.SizeInt<<44)|(gdextension.SizeInt<<48)|(gdextension.SizeInt<<52), unsafe.Pointer(&struct {
		canvas_item         RID.Any
		pos                 Vector2.XY
		text                gdextension.String
		alignment           GUI.HorizontalAlignment
		width               float64
		font_size           int64
		max_lines           int64
		size                int64
		modulate            Color.RGBA
		brk_flags           TextServer.LineBreakFlag
		justification_flags TextServer.JustificationFlag
		direction           TextServer.Direction
		orientation         TextServer.Orientation
	}{canvas_item, pos, gdextension.String(pointers.Get(gd.InternalString(text))[0]), alignment, width, font_size, max_lines, size, modulate, brk_flags, justification_flags, direction, orientation}))
}

/*
Returns the size of a character. Does not take kerning into account.
[b]Note:[/b] Do not use this function to calculate width of the string character by character, use [method get_string_size] or [TextLine] instead. The height returned is the font height (see also [method get_height]) and has no relation to the glyph height.
*/
//go:nosplit
func (self class) GetCharSize(char int64, font_size int64) Vector2.XY { //gd:Font.get_char_size
	var r_ret = gdunsafe.Call[Vector2.XY](self.AsObject(), gd.Global.Methods.Font.Bind_get_char_size, gdextension.SizeVector2|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		char      int64
		font_size int64
	}{char, font_size}))
	var ret = r_ret
	return ret
}

/*
Draw a single Unicode character [param char] into a canvas item using the font, at a given position, with [param modulate] color. [param pos] specifies the baseline, not the top. To draw from the top, [i]ascent[/i] must be added to the Y axis.
[b]Note:[/b] Do not use this function to draw strings character by character, use [method draw_string] or [TextLine] instead.
*/
//go:nosplit
func (self class) DrawChar(canvas_item RID.Any, pos Vector2.XY, char int64, font_size int64, modulate Color.RGBA) float64 { //gd:Font.draw_char
	var r_ret = gdunsafe.Call[float64](self.AsObject(), gd.Global.Methods.Font.Bind_draw_char, gdextension.SizeFloat|(gdextension.SizeRID<<4)|(gdextension.SizeVector2<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeInt<<16)|(gdextension.SizeColor<<20), unsafe.Pointer(&struct {
		canvas_item RID.Any
		pos         Vector2.XY
		char        int64
		font_size   int64
		modulate    Color.RGBA
	}{canvas_item, pos, char, font_size, modulate}))
	var ret = r_ret
	return ret
}

/*
Draw a single Unicode character [param char] outline into a canvas item using the font, at a given position, with [param modulate] color and [param size] outline size. [param pos] specifies the baseline, not the top. To draw from the top, [i]ascent[/i] must be added to the Y axis.
[b]Note:[/b] Do not use this function to draw strings character by character, use [method draw_string] or [TextLine] instead.
*/
//go:nosplit
func (self class) DrawCharOutline(canvas_item RID.Any, pos Vector2.XY, char int64, font_size int64, size int64, modulate Color.RGBA) float64 { //gd:Font.draw_char_outline
	var r_ret = gdunsafe.Call[float64](self.AsObject(), gd.Global.Methods.Font.Bind_draw_char_outline, gdextension.SizeFloat|(gdextension.SizeRID<<4)|(gdextension.SizeVector2<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeInt<<16)|(gdextension.SizeInt<<20)|(gdextension.SizeColor<<24), unsafe.Pointer(&struct {
		canvas_item RID.Any
		pos         Vector2.XY
		char        int64
		font_size   int64
		size        int64
		modulate    Color.RGBA
	}{canvas_item, pos, char, font_size, size, modulate}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if a Unicode [param char] is available in the font.
*/
//go:nosplit
func (self class) HasChar(char int64) bool { //gd:Font.has_char
	var r_ret = gdunsafe.Call[bool](self.AsObject(), gd.Global.Methods.Font.Bind_has_char, gdextension.SizeBool|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ char int64 }{char}))
	var ret = r_ret
	return ret
}

/*
Returns a string containing all the characters available in the font.
If a given character is included in more than one font data source, it appears only once in the returned string.
*/
//go:nosplit
func (self class) GetSupportedChars() String.Readable { //gd:Font.get_supported_chars
	var r_ret = gdunsafe.Call[[1]gd.EnginePointer](self.AsObject(), gd.Global.Methods.Font.Bind_get_supported_chars, gdextension.SizeString, unsafe.Pointer(&struct{}{}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Returns [code]true[/code], if font supports given language ([url=https://en.wikipedia.org/wiki/ISO_639-1]ISO 639[/url] code).
*/
//go:nosplit
func (self class) IsLanguageSupported(language String.Readable) bool { //gd:Font.is_language_supported
	var r_ret = gdunsafe.Call[bool](self.AsObject(), gd.Global.Methods.Font.Bind_is_language_supported, gdextension.SizeBool|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ language gdextension.String }{gdextension.String(pointers.Get(gd.InternalString(language))[0])}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code], if font supports given script ([url=https://en.wikipedia.org/wiki/ISO_15924]ISO 15924[/url] code).
*/
//go:nosplit
func (self class) IsScriptSupported(script String.Readable) bool { //gd:Font.is_script_supported
	var r_ret = gdunsafe.Call[bool](self.AsObject(), gd.Global.Methods.Font.Bind_is_script_supported, gdextension.SizeBool|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ script gdextension.String }{gdextension.String(pointers.Get(gd.InternalString(script))[0])}))
	var ret = r_ret
	return ret
}

/*
Returns list of OpenType features supported by font.
*/
//go:nosplit
func (self class) GetSupportedFeatureList() Dictionary.Any { //gd:Font.get_supported_feature_list
	var r_ret = gdunsafe.Call[[1]gd.EnginePointer](self.AsObject(), gd.Global.Methods.Font.Bind_get_supported_feature_list, gdextension.SizeDictionary, unsafe.Pointer(&struct{}{}))
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret)))
	return ret
}

/*
Returns list of supported [url=https://docs.microsoft.com/en-us/typography/opentype/spec/dvaraxisreg]variation coordinates[/url], each coordinate is returned as [code]tag: Vector3i(min_value,max_value,default_value)[/code].
Font variations allow for continuous change of glyph characteristics along some given design axis, such as weight, width or slant.
To print available variation axes of a variable font:
[codeblock]
var fv = FontVariation.new()
fv.base_font = load("res://RobotoFlex.ttf")
var variation_list = fv.get_supported_variation_list()
for tag in variation_list:
    var name = TextServerManager.get_primary_interface().tag_to_name(tag)
    var values = variation_list[tag]
    print("variation axis: %s (%d)\n\tmin, max, default: %s" % [name, tag, values])
[/codeblock]
[b]Note:[/b] To set and get variation coordinates of a [FontVariation], use [member FontVariation.variation_opentype].
*/
//go:nosplit
func (self class) GetSupportedVariationList() Dictionary.Any { //gd:Font.get_supported_variation_list
	var r_ret = gdunsafe.Call[[1]gd.EnginePointer](self.AsObject(), gd.Global.Methods.Font.Bind_get_supported_variation_list, gdextension.SizeDictionary, unsafe.Pointer(&struct{}{}))
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret)))
	return ret
}

/*
Returns number of faces in the TrueType / OpenType collection.
*/
//go:nosplit
func (self class) GetFaceCount() int64 { //gd:Font.get_face_count
	var r_ret = gdunsafe.Call[int64](self.AsObject(), gd.Global.Methods.Font.Bind_get_face_count, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}
func (self class) AsFont() Advanced         { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsFont() Instance      { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsFont() Instance { return self.Super().AsFont() }
func (self class) AsResource() Resource.Advanced {
	return *((*Resource.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsResource() Resource.Instance { return self.Super().AsResource() }
func (self Instance) AsResource() Resource.Instance {
	return *((*Resource.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsRefCounted() [1]gd.RefCounted { return self.Super().AsRefCounted() }
func (self Instance) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Resource.Advanced(self.AsResource()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Resource.Instance(self.AsResource()), name)
	}
}
func init() {
	gdclass.Register("Font", func(ptr gd.Object) any { return [1]gdclass.Font{*(*gdclass.Font)(unsafe.Pointer(&ptr))} })
}
