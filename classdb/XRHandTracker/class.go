// Code generated by the generate package DO NOT EDIT

// Package XRHandTracker provides methods for working with XRHandTracker object instances.
package XRHandTracker

import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/variant/Signal"
import "graphics.gd/classdb/XRPositionalTracker"
import "graphics.gd/classdb/XRTracker"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"
import "graphics.gd/variant/Transform3D"
import "graphics.gd/variant/Vector3"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Signal.Any
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
A hand tracking system will create an instance of this object and add it to the [XRServer]. This tracking system will then obtain skeleton data, convert it to the Godot Humanoid hand skeleton and store this data on the [XRHandTracker] object.
Use [XRHandModifier3D] to animate a hand mesh using hand tracking data.
*/
type Instance [1]gdclass.XRHandTracker

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	set_has_tracking_data           gdextension.MethodForClass `hash:"2586408642"`
	get_has_tracking_data           gdextension.MethodForClass `hash:"36873697"`
	set_hand_tracking_source        gdextension.MethodForClass `hash:"2958308861"`
	get_hand_tracking_source        gdextension.MethodForClass `hash:"2475045250"`
	set_hand_joint_flags            gdextension.MethodForClass `hash:"3028437365"`
	get_hand_joint_flags            gdextension.MethodForClass `hash:"1730972401"`
	set_hand_joint_transform        gdextension.MethodForClass `hash:"2529959613"`
	get_hand_joint_transform        gdextension.MethodForClass `hash:"1090840196"`
	set_hand_joint_radius           gdextension.MethodForClass `hash:"2723659615"`
	get_hand_joint_radius           gdextension.MethodForClass `hash:"3400025734"`
	set_hand_joint_linear_velocity  gdextension.MethodForClass `hash:"1978646737"`
	get_hand_joint_linear_velocity  gdextension.MethodForClass `hash:"547240792"`
	set_hand_joint_angular_velocity gdextension.MethodForClass `hash:"1978646737"`
	get_hand_joint_angular_velocity gdextension.MethodForClass `hash:"547240792"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("XRHandTracker")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		gdextension.Free(gdextension.TypeStringName, &sname)
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsXRHandTracker() Instance
}

/*
Sets flags about the validity of the tracking data for the given hand joint.
*/
func (self Instance) SetHandJointFlags(joint HandJoint, flags HandJointFlags) { //gd:XRHandTracker.set_hand_joint_flags
	Advanced(self).SetHandJointFlags(joint, flags)
}

/*
Returns flags about the validity of the tracking data for the given hand joint (see [enum XRHandTracker.HandJointFlags]).
*/
func (self Instance) GetHandJointFlags(joint HandJoint) HandJointFlags { //gd:XRHandTracker.get_hand_joint_flags
	return HandJointFlags(Advanced(self).GetHandJointFlags(joint))
}

/*
Sets the transform for the given hand joint.
*/
func (self Instance) SetHandJointTransform(joint HandJoint, transform Transform3D.BasisOrigin) { //gd:XRHandTracker.set_hand_joint_transform
	Advanced(self).SetHandJointTransform(joint, Transform3D.BasisOrigin(transform))
}

/*
Returns the transform for the given hand joint.
*/
func (self Instance) GetHandJointTransform(joint HandJoint) Transform3D.BasisOrigin { //gd:XRHandTracker.get_hand_joint_transform
	return Transform3D.BasisOrigin(Advanced(self).GetHandJointTransform(joint))
}

/*
Sets the radius of the given hand joint.
*/
func (self Instance) SetHandJointRadius(joint HandJoint, radius Float.X) { //gd:XRHandTracker.set_hand_joint_radius
	Advanced(self).SetHandJointRadius(joint, float64(radius))
}

/*
Returns the radius of the given hand joint.
*/
func (self Instance) GetHandJointRadius(joint HandJoint) Float.X { //gd:XRHandTracker.get_hand_joint_radius
	return Float.X(Float.X(Advanced(self).GetHandJointRadius(joint)))
}

/*
Sets the linear velocity for the given hand joint.
*/
func (self Instance) SetHandJointLinearVelocity(joint HandJoint, linear_velocity Vector3.XYZ) { //gd:XRHandTracker.set_hand_joint_linear_velocity
	Advanced(self).SetHandJointLinearVelocity(joint, Vector3.XYZ(linear_velocity))
}

/*
Returns the linear velocity for the given hand joint.
*/
func (self Instance) GetHandJointLinearVelocity(joint HandJoint) Vector3.XYZ { //gd:XRHandTracker.get_hand_joint_linear_velocity
	return Vector3.XYZ(Advanced(self).GetHandJointLinearVelocity(joint))
}

/*
Sets the angular velocity for the given hand joint.
*/
func (self Instance) SetHandJointAngularVelocity(joint HandJoint, angular_velocity Vector3.XYZ) { //gd:XRHandTracker.set_hand_joint_angular_velocity
	Advanced(self).SetHandJointAngularVelocity(joint, Vector3.XYZ(angular_velocity))
}

/*
Returns the angular velocity for the given hand joint.
*/
func (self Instance) GetHandJointAngularVelocity(joint HandJoint) Vector3.XYZ { //gd:XRHandTracker.get_hand_joint_angular_velocity
	return Vector3.XYZ(Advanced(self).GetHandJointAngularVelocity(joint))
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.XRHandTracker

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = pointers.AsA[gdclass.XRHandTracker](obj[0])
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = pointers.AsA[gdclass.XRHandTracker](obj[0])
		return true
	}
	return false
}
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }
func (self *Extension[T]) AsObject() [1]gd.Object { return self.Super().AsObject() }
func New() Instance {
	if !gd.Linked {
		var placeholder = Instance([1]gdclass.XRHandTracker{pointers.Add[gdclass.XRHandTracker]([3]uint64{})})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(pointers.AsA[gd.Object](placeholder[0]), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	casted := Instance([1]gdclass.XRHandTracker{pointers.New[gdclass.XRHandTracker]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})})
	casted.AsRefCounted()[0].InitRef()
	casted.AsObject()[0].Notification(0, false)
	return casted
}

func (self Instance) HasTrackingData() bool {
	return bool(class(self).GetHasTrackingData())
}

func (self Instance) SetHasTrackingData(value bool) {
	class(self).SetHasTrackingData(value)
}

func (self Instance) HandTrackingSource() HandTrackingSource {
	return HandTrackingSource(class(self).GetHandTrackingSource())
}

func (self Instance) SetHandTrackingSource(value HandTrackingSource) {
	class(self).SetHandTrackingSource(value)
}

//go:nosplit
func (self class) SetHasTrackingData(has_data bool) { //gd:XRHandTracker.set_has_tracking_data
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_has_tracking_data, 0|(gdextension.SizeBool<<4), &struct{ has_data bool }{has_data})
}

//go:nosplit
func (self class) GetHasTrackingData() bool { //gd:XRHandTracker.get_has_tracking_data
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.get_has_tracking_data, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetHandTrackingSource(source HandTrackingSource) { //gd:XRHandTracker.set_hand_tracking_source
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_hand_tracking_source, 0|(gdextension.SizeInt<<4), &struct{ source HandTrackingSource }{source})
}

//go:nosplit
func (self class) GetHandTrackingSource() HandTrackingSource { //gd:XRHandTracker.get_hand_tracking_source
	var r_ret = gdextension.Call[HandTrackingSource](gd.ObjectChecked(self.AsObject()), methods.get_hand_tracking_source, gdextension.SizeInt, &struct{}{})
	var ret = r_ret
	return ret
}

/*
Sets flags about the validity of the tracking data for the given hand joint.
*/
//go:nosplit
func (self class) SetHandJointFlags(joint HandJoint, flags HandJointFlags) { //gd:XRHandTracker.set_hand_joint_flags
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_hand_joint_flags, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), &struct {
		joint HandJoint
		flags HandJointFlags
	}{joint, flags})
}

/*
Returns flags about the validity of the tracking data for the given hand joint (see [enum XRHandTracker.HandJointFlags]).
*/
//go:nosplit
func (self class) GetHandJointFlags(joint HandJoint) HandJointFlags { //gd:XRHandTracker.get_hand_joint_flags
	var r_ret = gdextension.Call[HandJointFlags](gd.ObjectChecked(self.AsObject()), methods.get_hand_joint_flags, gdextension.SizeInt|(gdextension.SizeInt<<4), &struct{ joint HandJoint }{joint})
	var ret = r_ret
	return ret
}

/*
Sets the transform for the given hand joint.
*/
//go:nosplit
func (self class) SetHandJointTransform(joint HandJoint, transform Transform3D.BasisOrigin) { //gd:XRHandTracker.set_hand_joint_transform
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_hand_joint_transform, 0|(gdextension.SizeInt<<4)|(gdextension.SizeTransform3D<<8), &struct {
		joint     HandJoint
		transform Transform3D.BasisOrigin
	}{joint, gd.Transposed(transform)})
}

/*
Returns the transform for the given hand joint.
*/
//go:nosplit
func (self class) GetHandJointTransform(joint HandJoint) Transform3D.BasisOrigin { //gd:XRHandTracker.get_hand_joint_transform
	var r_ret = gdextension.Call[Transform3D.BasisOrigin](gd.ObjectChecked(self.AsObject()), methods.get_hand_joint_transform, gdextension.SizeTransform3D|(gdextension.SizeInt<<4), &struct{ joint HandJoint }{joint})
	var ret = gd.Transposed(r_ret)
	return ret
}

/*
Sets the radius of the given hand joint.
*/
//go:nosplit
func (self class) SetHandJointRadius(joint HandJoint, radius float64) { //gd:XRHandTracker.set_hand_joint_radius
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_hand_joint_radius, 0|(gdextension.SizeInt<<4)|(gdextension.SizeFloat<<8), &struct {
		joint  HandJoint
		radius float64
	}{joint, radius})
}

/*
Returns the radius of the given hand joint.
*/
//go:nosplit
func (self class) GetHandJointRadius(joint HandJoint) float64 { //gd:XRHandTracker.get_hand_joint_radius
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_hand_joint_radius, gdextension.SizeFloat|(gdextension.SizeInt<<4), &struct{ joint HandJoint }{joint})
	var ret = r_ret
	return ret
}

/*
Sets the linear velocity for the given hand joint.
*/
//go:nosplit
func (self class) SetHandJointLinearVelocity(joint HandJoint, linear_velocity Vector3.XYZ) { //gd:XRHandTracker.set_hand_joint_linear_velocity
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_hand_joint_linear_velocity, 0|(gdextension.SizeInt<<4)|(gdextension.SizeVector3<<8), &struct {
		joint           HandJoint
		linear_velocity Vector3.XYZ
	}{joint, linear_velocity})
}

/*
Returns the linear velocity for the given hand joint.
*/
//go:nosplit
func (self class) GetHandJointLinearVelocity(joint HandJoint) Vector3.XYZ { //gd:XRHandTracker.get_hand_joint_linear_velocity
	var r_ret = gdextension.Call[Vector3.XYZ](gd.ObjectChecked(self.AsObject()), methods.get_hand_joint_linear_velocity, gdextension.SizeVector3|(gdextension.SizeInt<<4), &struct{ joint HandJoint }{joint})
	var ret = r_ret
	return ret
}

/*
Sets the angular velocity for the given hand joint.
*/
//go:nosplit
func (self class) SetHandJointAngularVelocity(joint HandJoint, angular_velocity Vector3.XYZ) { //gd:XRHandTracker.set_hand_joint_angular_velocity
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_hand_joint_angular_velocity, 0|(gdextension.SizeInt<<4)|(gdextension.SizeVector3<<8), &struct {
		joint            HandJoint
		angular_velocity Vector3.XYZ
	}{joint, angular_velocity})
}

/*
Returns the angular velocity for the given hand joint.
*/
//go:nosplit
func (self class) GetHandJointAngularVelocity(joint HandJoint) Vector3.XYZ { //gd:XRHandTracker.get_hand_joint_angular_velocity
	var r_ret = gdextension.Call[Vector3.XYZ](gd.ObjectChecked(self.AsObject()), methods.get_hand_joint_angular_velocity, gdextension.SizeVector3|(gdextension.SizeInt<<4), &struct{ joint HandJoint }{joint})
	var ret = r_ret
	return ret
}
func (self class) AsXRHandTracker() Advanced {
	return Advanced{pointers.AsA[gdclass.XRHandTracker](self[0])}
}
func (self Instance) AsXRHandTracker() Instance {
	return Instance{pointers.AsA[gdclass.XRHandTracker](self[0])}
}
func (self *Extension[T]) AsXRHandTracker() Instance { return self.Super().AsXRHandTracker() }
func (self class) AsXRPositionalTracker() XRPositionalTracker.Advanced {
	return XRPositionalTracker.Advanced{pointers.AsA[gdclass.XRPositionalTracker](self[0])}
}
func (self *Extension[T]) AsXRPositionalTracker() XRPositionalTracker.Instance {
	return self.Super().AsXRPositionalTracker()
}
func (self Instance) AsXRPositionalTracker() XRPositionalTracker.Instance {
	return XRPositionalTracker.Instance{pointers.AsA[gdclass.XRPositionalTracker](self[0])}
}
func (self class) AsXRTracker() XRTracker.Advanced {
	return XRTracker.Advanced{pointers.AsA[gdclass.XRTracker](self[0])}
}
func (self *Extension[T]) AsXRTracker() XRTracker.Instance { return self.Super().AsXRTracker() }
func (self Instance) AsXRTracker() XRTracker.Instance {
	return XRTracker.Instance{pointers.AsA[gdclass.XRTracker](self[0])}
}
func (self class) AsRefCounted() [1]gd.RefCounted {
	return [1]gd.RefCounted{gd.RefCounted(pointers.AsA[gd.Object](self[0]))}
}
func (self *Extension[T]) AsRefCounted() [1]gd.RefCounted { return self.Super().AsRefCounted() }
func (self Instance) AsRefCounted() [1]gd.RefCounted {
	return [1]gd.RefCounted{gd.RefCounted(pointers.AsA[gd.Object](self[0]))}
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(XRPositionalTracker.Advanced(self.AsXRPositionalTracker()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(XRPositionalTracker.Instance(self.AsXRPositionalTracker()), name)
	}
}
func init() {
	gdclass.Register("XRHandTracker", func(ptr gd.Object) any { return Instance{pointers.AsA[gdclass.XRHandTracker](ptr)} })
}

type HandTrackingSource int //gd:XRHandTracker.HandTrackingSource

const (
	/*The source of hand tracking data is unknown.*/
	HandTrackingSourceUnknown HandTrackingSource = 0
	/*The source of hand tracking data is unobstructed, meaning that an accurate method of hand tracking is used. These include optical hand tracking, data gloves, etc.*/
	HandTrackingSourceUnobstructed HandTrackingSource = 1
	/*The source of hand tracking data is a controller, meaning that joint positions are inferred from controller inputs.*/
	HandTrackingSourceController HandTrackingSource = 2
	/*No hand tracking data is tracked, this either means the hand is obscured, the controller is turned off, or tracking is not supported for the current input type.*/
	HandTrackingSourceNotTracked HandTrackingSource = 3
	/*Represents the size of the [enum HandTrackingSource] enum.*/
	HandTrackingSourceMax HandTrackingSource = 4
)

type HandJoint int //gd:XRHandTracker.HandJoint

const (
	/*Palm joint.*/
	HandJointPalm HandJoint = 0
	/*Wrist joint.*/
	HandJointWrist HandJoint = 1
	/*Thumb metacarpal joint.*/
	HandJointThumbMetacarpal HandJoint = 2
	/*Thumb phalanx proximal joint.*/
	HandJointThumbPhalanxProximal HandJoint = 3
	/*Thumb phalanx distal joint.*/
	HandJointThumbPhalanxDistal HandJoint = 4
	/*Thumb tip joint.*/
	HandJointThumbTip HandJoint = 5
	/*Index finger metacarpal joint.*/
	HandJointIndexFingerMetacarpal HandJoint = 6
	/*Index finger phalanx proximal joint.*/
	HandJointIndexFingerPhalanxProximal HandJoint = 7
	/*Index finger phalanx intermediate joint.*/
	HandJointIndexFingerPhalanxIntermediate HandJoint = 8
	/*Index finger phalanx distal joint.*/
	HandJointIndexFingerPhalanxDistal HandJoint = 9
	/*Index finger tip joint.*/
	HandJointIndexFingerTip HandJoint = 10
	/*Middle finger metacarpal joint.*/
	HandJointMiddleFingerMetacarpal HandJoint = 11
	/*Middle finger phalanx proximal joint.*/
	HandJointMiddleFingerPhalanxProximal HandJoint = 12
	/*Middle finger phalanx intermediate joint.*/
	HandJointMiddleFingerPhalanxIntermediate HandJoint = 13
	/*Middle finger phalanx distal joint.*/
	HandJointMiddleFingerPhalanxDistal HandJoint = 14
	/*Middle finger tip joint.*/
	HandJointMiddleFingerTip HandJoint = 15
	/*Ring finger metacarpal joint.*/
	HandJointRingFingerMetacarpal HandJoint = 16
	/*Ring finger phalanx proximal joint.*/
	HandJointRingFingerPhalanxProximal HandJoint = 17
	/*Ring finger phalanx intermediate joint.*/
	HandJointRingFingerPhalanxIntermediate HandJoint = 18
	/*Ring finger phalanx distal joint.*/
	HandJointRingFingerPhalanxDistal HandJoint = 19
	/*Ring finger tip joint.*/
	HandJointRingFingerTip HandJoint = 20
	/*Pinky finger metacarpal joint.*/
	HandJointPinkyFingerMetacarpal HandJoint = 21
	/*Pinky finger phalanx proximal joint.*/
	HandJointPinkyFingerPhalanxProximal HandJoint = 22
	/*Pinky finger phalanx intermediate joint.*/
	HandJointPinkyFingerPhalanxIntermediate HandJoint = 23
	/*Pinky finger phalanx distal joint.*/
	HandJointPinkyFingerPhalanxDistal HandJoint = 24
	/*Pinky finger tip joint.*/
	HandJointPinkyFingerTip HandJoint = 25
	/*Represents the size of the [enum HandJoint] enum.*/
	HandJointMax HandJoint = 26
)

type HandJointFlags int //gd:XRHandTracker.HandJointFlags

const (
	/*The hand joint's orientation data is valid.*/
	HandJointFlagOrientationValid HandJointFlags = 1
	/*The hand joint's orientation is actively tracked. May not be set if tracking has been temporarily lost.*/
	HandJointFlagOrientationTracked HandJointFlags = 2
	/*The hand joint's position data is valid.*/
	HandJointFlagPositionValid HandJointFlags = 4
	/*The hand joint's position is actively tracked. May not be set if tracking has been temporarily lost.*/
	HandJointFlagPositionTracked HandJointFlags = 8
	/*The hand joint's linear velocity data is valid.*/
	HandJointFlagLinearVelocityValid HandJointFlags = 16
	/*The hand joint's angular velocity data is valid.*/
	HandJointFlagAngularVelocityValid HandJointFlags = 32
)
