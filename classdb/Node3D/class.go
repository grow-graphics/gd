// Code generated by the generate package DO NOT EDIT

// Package Node3D provides methods for working with Node3D object instances.
package Node3D

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/Node"
import "graphics.gd/classdb/Node3DGizmo"
import "graphics.gd/classdb/World3D"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Basis"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/Quaternion"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"
import "graphics.gd/variant/Transform3D"
import "graphics.gd/variant/Vector3"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
Most basic 3D game object, with a [Transform3D] and visibility settings. All other 3D game objects inherit from [Node3D]. Use [Node3D] as a parent node to move, scale, rotate and show/hide children in a 3D project.
Affine operations (rotate, scale, translate) happen in parent's local coordinate system, unless the [Node3D] object is set as top-level. Affine operations in this coordinate system correspond to direct affine operations on the [Node3D]'s transform. The word local below refers to this coordinate system. The coordinate system that is attached to the [Node3D] object itself is referred to as object-local coordinate system.
[b]Note:[/b] Unless otherwise specified, all methods that have angle parameters must have angles specified as [i]radians[/i]. To convert degrees to radians, use [method @GlobalScope.deg_to_rad].
[b]Note:[/b] Be aware that "Spatial" nodes are now called "Node3D" starting with Godot 4. Any Godot 3.x references to "Spatial" nodes refer to "Node3D" in Godot 4.
*/
type Instance [1]gdclass.Node3D

func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

type Expanded [1]gdclass.Node3D

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsNode3D() Instance
}

/*
When using physics interpolation, there will be circumstances in which you want to know the interpolated (displayed) transform of a node rather than the standard transform (which may only be accurate to the most recent physics tick).
This is particularly important for frame-based operations that take place in [method Node._process], rather than [method Node._physics_process]. Examples include [Camera3D]s focusing on a node, or finding where to fire lasers from on a frame rather than physics tick.
[b]Note:[/b] This function creates an interpolation pump on the [Node3D] the first time it is called, which can respond to physics interpolation resets. If you get problems with "streaking" when initially following a [Node3D], be sure to call [method get_global_transform_interpolated] at least once [i]before[/i] resetting the [Node3D] physics interpolation.
*/
func (self Instance) GetGlobalTransformInterpolated() Transform3D.BasisOrigin { //gd:Node3D.get_global_transform_interpolated
	return Transform3D.BasisOrigin(Advanced(self).GetGlobalTransformInterpolated())
}

/*
Returns the parent [Node3D], or [code]null[/code] if no parent exists, the parent is not of type [Node3D], or [member top_level] is [code]true[/code].
[b]Note:[/b] Calling this method is not equivalent to [code]get_parent() as Node3D[/code], which does not take [member top_level] into account.
*/
func (self Instance) GetParentNode3d() Instance { //gd:Node3D.get_parent_node_3d
	return Instance(Advanced(self).GetParentNode3d())
}

/*
Sets whether the node ignores notification that its transformation (global or local) changed.
*/
func (self Instance) SetIgnoreTransformNotification(enabled bool) { //gd:Node3D.set_ignore_transform_notification
	Advanced(self).SetIgnoreTransformNotification(enabled)
}

/*
Sets whether the node uses a scale of [code](1, 1, 1)[/code] or its local transformation scale. Changes to the local transformation scale are preserved.
*/
func (self Instance) SetDisableScale(disable bool) { //gd:Node3D.set_disable_scale
	Advanced(self).SetDisableScale(disable)
}

/*
Returns whether this node uses a scale of [code](1, 1, 1)[/code] or its local transformation scale.
*/
func (self Instance) IsScaleDisabled() bool { //gd:Node3D.is_scale_disabled
	return bool(Advanced(self).IsScaleDisabled())
}

/*
Returns the current [World3D] resource this [Node3D] node is registered to.
*/
func (self Instance) GetWorld3d() World3D.Instance { //gd:Node3D.get_world_3d
	return World3D.Instance(Advanced(self).GetWorld3d())
}

/*
Forces the transform to update. Transform changes in physics are not instant for performance reasons. Transforms are accumulated and then set. Use this if you need an up-to-date transform when doing physics operations.
*/
func (self Instance) ForceUpdateTransform() { //gd:Node3D.force_update_transform
	Advanced(self).ForceUpdateTransform()
}

/*
Updates all the [Node3D] gizmos attached to this node.
*/
func (self Instance) UpdateGizmos() { //gd:Node3D.update_gizmos
	Advanced(self).UpdateGizmos()
}

/*
Attach an editor gizmo to this [Node3D].
[b]Note:[/b] The gizmo object would typically be an instance of [EditorNode3DGizmo], but the argument type is kept generic to avoid creating a dependency on editor classes in [Node3D].
*/
func (self Instance) AddGizmo(gizmo Node3DGizmo.Instance) { //gd:Node3D.add_gizmo
	Advanced(self).AddGizmo(gizmo)
}

/*
Returns all the gizmos attached to this [Node3D].
*/
func (self Instance) GetGizmos() []Node3DGizmo.Instance { //gd:Node3D.get_gizmos
	return []Node3DGizmo.Instance(gd.ArrayAs[[]Node3DGizmo.Instance](gd.InternalArray(Advanced(self).GetGizmos())))
}

/*
Clear all gizmos attached to this [Node3D].
*/
func (self Instance) ClearGizmos() { //gd:Node3D.clear_gizmos
	Advanced(self).ClearGizmos()
}

/*
Set subgizmo selection for this node in the editor.
[b]Note:[/b] The gizmo object would typically be an instance of [EditorNode3DGizmo], but the argument type is kept generic to avoid creating a dependency on editor classes in [Node3D].
*/
func (self Instance) SetSubgizmoSelection(gizmo Node3DGizmo.Instance, id int, transform Transform3D.BasisOrigin) { //gd:Node3D.set_subgizmo_selection
	Advanced(self).SetSubgizmoSelection(gizmo, int64(id), Transform3D.BasisOrigin(transform))
}

/*
Clears subgizmo selection for this node in the editor. Useful when subgizmo IDs become invalid after a property change.
*/
func (self Instance) ClearSubgizmoSelection() { //gd:Node3D.clear_subgizmo_selection
	Advanced(self).ClearSubgizmoSelection()
}

/*
Returns [code]true[/code] if the node is present in the [SceneTree], its [member visible] property is [code]true[/code] and all its ancestors are also visible. If any ancestor is hidden, this node will not be visible in the scene tree.
Visibility is checked only in parent nodes that inherit from [Node3D]. If the parent is of any other type (such as [Node], [AnimationPlayer], or [Node2D]), it is assumed to be visible.
[b]Note:[/b] This method does not take [member VisualInstance3D.layers] into account, so even if this method returns [code]true[/code], the node might end up not being rendered.
*/
func (self Instance) IsVisibleInTree() bool { //gd:Node3D.is_visible_in_tree
	return bool(Advanced(self).IsVisibleInTree())
}

/*
Enables rendering of this node. Changes [member visible] to [code]true[/code].
*/
func (self Instance) Show() { //gd:Node3D.show
	Advanced(self).Show()
}

/*
Disables rendering of this node. Changes [member visible] to [code]false[/code].
*/
func (self Instance) Hide() { //gd:Node3D.hide
	Advanced(self).Hide()
}

/*
Sets whether the node notifies about its local transformation changes. [Node3D] will not propagate this by default.
*/
func (self Instance) SetNotifyLocalTransform(enable bool) { //gd:Node3D.set_notify_local_transform
	Advanced(self).SetNotifyLocalTransform(enable)
}

/*
Returns whether node notifies about its local transformation changes. [Node3D] will not propagate this by default.
*/
func (self Instance) IsLocalTransformNotificationEnabled() bool { //gd:Node3D.is_local_transform_notification_enabled
	return bool(Advanced(self).IsLocalTransformNotificationEnabled())
}

/*
Sets whether the node notifies about its global and local transformation changes. [Node3D] will not propagate this by default, unless it is in the editor context and it has a valid gizmo.
*/
func (self Instance) SetNotifyTransform(enable bool) { //gd:Node3D.set_notify_transform
	Advanced(self).SetNotifyTransform(enable)
}

/*
Returns whether the node notifies about its global and local transformation changes. [Node3D] will not propagate this by default.
*/
func (self Instance) IsTransformNotificationEnabled() bool { //gd:Node3D.is_transform_notification_enabled
	return bool(Advanced(self).IsTransformNotificationEnabled())
}

/*
Rotates the local transformation around axis, a unit [Vector3], by specified angle in radians.
*/
func (self Instance) Rotate(axis Vector3.XYZ, angle Angle.Radians) { //gd:Node3D.rotate
	Advanced(self).Rotate(Vector3.XYZ(axis), float64(angle))
}

/*
Rotates the global (world) transformation around axis, a unit [Vector3], by specified angle in radians. The rotation axis is in global coordinate system.
*/
func (self Instance) GlobalRotate(axis Vector3.XYZ, angle Angle.Radians) { //gd:Node3D.global_rotate
	Advanced(self).GlobalRotate(Vector3.XYZ(axis), float64(angle))
}

/*
Scales the global (world) transformation by the given [Vector3] scale factors.
*/
func (self Instance) GlobalScale(scale Vector3.XYZ) { //gd:Node3D.global_scale
	Advanced(self).GlobalScale(Vector3.XYZ(scale))
}

/*
Moves the global (world) transformation by [Vector3] offset. The offset is in global coordinate system.
*/
func (self Instance) GlobalTranslate(offset Vector3.XYZ) { //gd:Node3D.global_translate
	Advanced(self).GlobalTranslate(Vector3.XYZ(offset))
}

/*
Rotates the local transformation around axis, a unit [Vector3], by specified angle in radians. The rotation axis is in object-local coordinate system.
*/
func (self Instance) RotateObjectLocal(axis Vector3.XYZ, angle Angle.Radians) { //gd:Node3D.rotate_object_local
	Advanced(self).RotateObjectLocal(Vector3.XYZ(axis), float64(angle))
}

/*
Scales the local transformation by given 3D scale factors in object-local coordinate system.
*/
func (self Instance) ScaleObjectLocal(scale Vector3.XYZ) { //gd:Node3D.scale_object_local
	Advanced(self).ScaleObjectLocal(Vector3.XYZ(scale))
}

/*
Changes the node's position by the given offset [Vector3] in local space.
*/
func (self Instance) TranslateObjectLocal(offset Vector3.XYZ) { //gd:Node3D.translate_object_local
	Advanced(self).TranslateObjectLocal(Vector3.XYZ(offset))
}

/*
Rotates the local transformation around the X axis by angle in radians.
*/
func (self Instance) RotateX(angle Angle.Radians) { //gd:Node3D.rotate_x
	Advanced(self).RotateX(float64(angle))
}

/*
Rotates the local transformation around the Y axis by angle in radians.
*/
func (self Instance) RotateY(angle Angle.Radians) { //gd:Node3D.rotate_y
	Advanced(self).RotateY(float64(angle))
}

/*
Rotates the local transformation around the Z axis by angle in radians.
*/
func (self Instance) RotateZ(angle Angle.Radians) { //gd:Node3D.rotate_z
	Advanced(self).RotateZ(float64(angle))
}

/*
Changes the node's position by the given offset [Vector3].
Note that the translation [param offset] is affected by the node's scale, so if scaled by e.g. [code](10, 1, 1)[/code], a translation by an offset of [code](2, 0, 0)[/code] would actually add 20 ([code]2 * 10[/code]) to the X coordinate.
*/
func (self Instance) Translate(offset Vector3.XYZ) { //gd:Node3D.translate
	Advanced(self).Translate(Vector3.XYZ(offset))
}

/*
Resets this node's transformations (like scale, skew and taper) preserving its rotation and translation by performing Gram-Schmidt orthonormalization on this node's [Transform3D].
*/
func (self Instance) Orthonormalize() { //gd:Node3D.orthonormalize
	Advanced(self).Orthonormalize()
}

/*
Reset all transformations for this node (sets its [Transform3D] to the identity matrix).
*/
func (self Instance) SetIdentity() { //gd:Node3D.set_identity
	Advanced(self).SetIdentity()
}

/*
Rotates the node so that the local forward axis (-Z, [constant Vector3.FORWARD]) points toward the [param target] position.
The local up axis (+Y) points as close to the [param up] vector as possible while staying perpendicular to the local forward axis. The resulting transform is orthogonal, and the scale is preserved. Non-uniform scaling may not work correctly.
The [param target] position cannot be the same as the node's position, the [param up] vector cannot be zero.
The [param target] and the [param up] cannot be [constant Vector3.ZERO], and shouldn't be colinear to avoid unintended rotation around local Z axis.
Operations take place in global space, which means that the node must be in the scene tree.
If [param use_model_front] is [code]true[/code], the +Z axis (asset front) is treated as forward (implies +X is left) and points toward the [param target] position. By default, the -Z axis (camera forward) is treated as forward (implies +X is right).
*/
func (self Instance) LookAt(target Vector3.XYZ) { //gd:Node3D.look_at
	Advanced(self).LookAt(Vector3.XYZ(target), Vector3.XYZ(gd.Vector3{0, 1, 0}), false)
}

/*
Rotates the node so that the local forward axis (-Z, [constant Vector3.FORWARD]) points toward the [param target] position.
The local up axis (+Y) points as close to the [param up] vector as possible while staying perpendicular to the local forward axis. The resulting transform is orthogonal, and the scale is preserved. Non-uniform scaling may not work correctly.
The [param target] position cannot be the same as the node's position, the [param up] vector cannot be zero.
The [param target] and the [param up] cannot be [constant Vector3.ZERO], and shouldn't be colinear to avoid unintended rotation around local Z axis.
Operations take place in global space, which means that the node must be in the scene tree.
If [param use_model_front] is [code]true[/code], the +Z axis (asset front) is treated as forward (implies +X is left) and points toward the [param target] position. By default, the -Z axis (camera forward) is treated as forward (implies +X is right).
*/
func (self Expanded) LookAt(target Vector3.XYZ, up Vector3.XYZ, use_model_front bool) { //gd:Node3D.look_at
	Advanced(self).LookAt(Vector3.XYZ(target), Vector3.XYZ(up), use_model_front)
}

/*
Moves the node to the specified [param position], and then rotates the node to point toward the [param target] as per [method look_at]. Operations take place in global space.
*/
func (self Instance) LookAtFromPosition(position Vector3.XYZ, target Vector3.XYZ) { //gd:Node3D.look_at_from_position
	Advanced(self).LookAtFromPosition(Vector3.XYZ(position), Vector3.XYZ(target), Vector3.XYZ(gd.Vector3{0, 1, 0}), false)
}

/*
Moves the node to the specified [param position], and then rotates the node to point toward the [param target] as per [method look_at]. Operations take place in global space.
*/
func (self Expanded) LookAtFromPosition(position Vector3.XYZ, target Vector3.XYZ, up Vector3.XYZ, use_model_front bool) { //gd:Node3D.look_at_from_position
	Advanced(self).LookAtFromPosition(Vector3.XYZ(position), Vector3.XYZ(target), Vector3.XYZ(up), use_model_front)
}

/*
Transforms [param global_point] from world space to this node's local space.
*/
func (self Instance) ToLocal(global_point Vector3.XYZ) Vector3.XYZ { //gd:Node3D.to_local
	return Vector3.XYZ(Advanced(self).ToLocal(Vector3.XYZ(global_point)))
}

/*
Transforms [param local_point] from this node's local space to world space.
*/
func (self Instance) ToGlobal(local_point Vector3.XYZ) Vector3.XYZ { //gd:Node3D.to_global
	return Vector3.XYZ(Advanced(self).ToGlobal(Vector3.XYZ(local_point)))
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.Node3D

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {
	object := [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gdextension.Host.Objects.Make(pointers.Get(gd.NewStringName("Node3D"))))})}
	casted := Instance{*(*gdclass.Node3D)(unsafe.Pointer(&object))}
	object[0].Notification(0, false)
	return casted
}

func (self Instance) Transform() Transform3D.BasisOrigin {
	return Transform3D.BasisOrigin(class(self).GetTransform())
}

func (self Instance) SetTransform(value Transform3D.BasisOrigin) {
	class(self).SetTransform(Transform3D.BasisOrigin(value))
}

func (self Instance) GlobalTransform() Transform3D.BasisOrigin {
	return Transform3D.BasisOrigin(class(self).GetGlobalTransform())
}

func (self Instance) SetGlobalTransform(value Transform3D.BasisOrigin) {
	class(self).SetGlobalTransform(Transform3D.BasisOrigin(value))
}

func (self Instance) Position() Vector3.XYZ {
	return Vector3.XYZ(class(self).GetPosition())
}

func (self Instance) SetPosition(value Vector3.XYZ) {
	class(self).SetPosition(Vector3.XYZ(value))
}

func (self Instance) Rotation() Euler.Radians {
	return Euler.Radians(Vector3.EulerRadians(class(self).GetRotation()))
}

func (self Instance) SetRotation(value Euler.Radians) {
	class(self).SetRotation(value.Vector3())
}

func (self Instance) RotationDegrees() Euler.Degrees {
	return Euler.Degrees(Vector3.EulerDegrees(class(self).GetRotationDegrees()))
}

func (self Instance) SetRotationDegrees(value Euler.Degrees) {
	class(self).SetRotationDegrees(value.Vector3())
}

func (self Instance) Quaternion() Quaternion.IJKX {
	return Quaternion.IJKX(class(self).GetQuaternion())
}

func (self Instance) SetQuaternion(value Quaternion.IJKX) {
	class(self).SetQuaternion(value)
}

func (self Instance) Basis() Basis.XYZ {
	return Basis.XYZ(class(self).GetBasis())
}

func (self Instance) SetBasis(value Basis.XYZ) {
	class(self).SetBasis(Basis.XYZ(value))
}

func (self Instance) Scale() Vector3.XYZ {
	return Vector3.XYZ(class(self).GetScale())
}

func (self Instance) SetScale(value Vector3.XYZ) {
	class(self).SetScale(Vector3.XYZ(value))
}

func (self Instance) RotationEditMode() RotationEditMode {
	return RotationEditMode(class(self).GetRotationEditMode())
}

func (self Instance) SetRotationEditMode(value RotationEditMode) {
	class(self).SetRotationEditMode(value)
}

func (self Instance) RotationOrder() Angle.Order {
	return Angle.Order(class(self).GetRotationOrder())
}

func (self Instance) SetRotationOrder(value Angle.Order) {
	class(self).SetRotationOrder(value)
}

func (self Instance) TopLevel() bool {
	return bool(class(self).IsSetAsTopLevel())
}

func (self Instance) SetTopLevel(value bool) {
	class(self).SetAsTopLevel(value)
}

func (self Instance) GlobalPosition() Vector3.XYZ {
	return Vector3.XYZ(class(self).GetGlobalPosition())
}

func (self Instance) SetGlobalPosition(value Vector3.XYZ) {
	class(self).SetGlobalPosition(Vector3.XYZ(value))
}

func (self Instance) GlobalBasis() Basis.XYZ {
	return Basis.XYZ(class(self).GetGlobalBasis())
}

func (self Instance) SetGlobalBasis(value Basis.XYZ) {
	class(self).SetGlobalBasis(Basis.XYZ(value))
}

func (self Instance) GlobalRotation() Euler.Radians {
	return Euler.Radians(Vector3.EulerRadians(class(self).GetGlobalRotation()))
}

func (self Instance) SetGlobalRotation(value Euler.Radians) {
	class(self).SetGlobalRotation(value.Vector3())
}

func (self Instance) GlobalRotationDegrees() Euler.Degrees {
	return Euler.Degrees(Vector3.EulerDegrees(class(self).GetGlobalRotationDegrees()))
}

func (self Instance) SetGlobalRotationDegrees(value Euler.Degrees) {
	class(self).SetGlobalRotationDegrees(value.Vector3())
}

func (self Instance) Visible() bool {
	return bool(class(self).IsVisible())
}

func (self Instance) SetVisible(value bool) {
	class(self).SetVisible(value)
}

func (self Instance) VisibilityParent() string {
	return string(class(self).GetVisibilityParent().String())
}

func (self Instance) SetVisibilityParent(value string) {
	class(self).SetVisibilityParent(Path.ToNode(String.New(value)))
}

//go:nosplit
func (self class) SetTransform(local Transform3D.BasisOrigin) { //gd:Node3D.set_transform
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_set_transform), 0|(gdextension.SizeTransform3D<<4), unsafe.Pointer(&struct{ local Transform3D.BasisOrigin }{gd.Transposed(local)}))
}

//go:nosplit
func (self class) GetTransform() Transform3D.BasisOrigin { //gd:Node3D.get_transform
	var r_ret = gdextension.Call[Transform3D.BasisOrigin](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_get_transform), gdextension.SizeTransform3D, unsafe.Pointer(&struct{}{}))
	var ret = gd.Transposed(r_ret)
	return ret
}

//go:nosplit
func (self class) SetPosition(position Vector3.XYZ) { //gd:Node3D.set_position
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_set_position), 0|(gdextension.SizeVector3<<4), unsafe.Pointer(&struct{ position Vector3.XYZ }{position}))
}

//go:nosplit
func (self class) GetPosition() Vector3.XYZ { //gd:Node3D.get_position
	var r_ret = gdextension.Call[Vector3.XYZ](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_get_position), gdextension.SizeVector3, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetRotation(euler_radians Vector3.XYZ) { //gd:Node3D.set_rotation
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_set_rotation), 0|(gdextension.SizeVector3<<4), unsafe.Pointer(&struct{ euler_radians Vector3.XYZ }{euler_radians}))
}

//go:nosplit
func (self class) GetRotation() Vector3.XYZ { //gd:Node3D.get_rotation
	var r_ret = gdextension.Call[Vector3.XYZ](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_get_rotation), gdextension.SizeVector3, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetRotationDegrees(euler_degrees Vector3.XYZ) { //gd:Node3D.set_rotation_degrees
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_set_rotation_degrees), 0|(gdextension.SizeVector3<<4), unsafe.Pointer(&struct{ euler_degrees Vector3.XYZ }{euler_degrees}))
}

//go:nosplit
func (self class) GetRotationDegrees() Vector3.XYZ { //gd:Node3D.get_rotation_degrees
	var r_ret = gdextension.Call[Vector3.XYZ](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_get_rotation_degrees), gdextension.SizeVector3, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetRotationOrder(order Angle.Order) { //gd:Node3D.set_rotation_order
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_set_rotation_order), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ order Angle.Order }{order}))
}

//go:nosplit
func (self class) GetRotationOrder() Angle.Order { //gd:Node3D.get_rotation_order
	var r_ret = gdextension.Call[Angle.Order](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_get_rotation_order), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetRotationEditMode(edit_mode RotationEditMode) { //gd:Node3D.set_rotation_edit_mode
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_set_rotation_edit_mode), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ edit_mode RotationEditMode }{edit_mode}))
}

//go:nosplit
func (self class) GetRotationEditMode() RotationEditMode { //gd:Node3D.get_rotation_edit_mode
	var r_ret = gdextension.Call[RotationEditMode](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_get_rotation_edit_mode), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetScale(scale Vector3.XYZ) { //gd:Node3D.set_scale
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_set_scale), 0|(gdextension.SizeVector3<<4), unsafe.Pointer(&struct{ scale Vector3.XYZ }{scale}))
}

//go:nosplit
func (self class) GetScale() Vector3.XYZ { //gd:Node3D.get_scale
	var r_ret = gdextension.Call[Vector3.XYZ](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_get_scale), gdextension.SizeVector3, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetQuaternion(quaternion Quaternion.IJKX) { //gd:Node3D.set_quaternion
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_set_quaternion), 0|(gdextension.SizeQuaternion<<4), unsafe.Pointer(&struct{ quaternion Quaternion.IJKX }{quaternion}))
}

//go:nosplit
func (self class) GetQuaternion() Quaternion.IJKX { //gd:Node3D.get_quaternion
	var r_ret = gdextension.Call[Quaternion.IJKX](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_get_quaternion), gdextension.SizeQuaternion, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetBasis(basis Basis.XYZ) { //gd:Node3D.set_basis
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_set_basis), 0|(gdextension.SizeBasis<<4), unsafe.Pointer(&struct{ basis Basis.XYZ }{Basis.Transposed(basis)}))
}

//go:nosplit
func (self class) GetBasis() Basis.XYZ { //gd:Node3D.get_basis
	var r_ret = gdextension.Call[Basis.XYZ](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_get_basis), gdextension.SizeBasis, unsafe.Pointer(&struct{}{}))
	var ret = Basis.Transposed(r_ret)
	return ret
}

//go:nosplit
func (self class) SetGlobalTransform(global Transform3D.BasisOrigin) { //gd:Node3D.set_global_transform
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_set_global_transform), 0|(gdextension.SizeTransform3D<<4), unsafe.Pointer(&struct{ global Transform3D.BasisOrigin }{gd.Transposed(global)}))
}

//go:nosplit
func (self class) GetGlobalTransform() Transform3D.BasisOrigin { //gd:Node3D.get_global_transform
	var r_ret = gdextension.Call[Transform3D.BasisOrigin](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_get_global_transform), gdextension.SizeTransform3D, unsafe.Pointer(&struct{}{}))
	var ret = gd.Transposed(r_ret)
	return ret
}

/*
When using physics interpolation, there will be circumstances in which you want to know the interpolated (displayed) transform of a node rather than the standard transform (which may only be accurate to the most recent physics tick).
This is particularly important for frame-based operations that take place in [method Node._process], rather than [method Node._physics_process]. Examples include [Camera3D]s focusing on a node, or finding where to fire lasers from on a frame rather than physics tick.
[b]Note:[/b] This function creates an interpolation pump on the [Node3D] the first time it is called, which can respond to physics interpolation resets. If you get problems with "streaking" when initially following a [Node3D], be sure to call [method get_global_transform_interpolated] at least once [i]before[/i] resetting the [Node3D] physics interpolation.
*/
//go:nosplit
func (self class) GetGlobalTransformInterpolated() Transform3D.BasisOrigin { //gd:Node3D.get_global_transform_interpolated
	var r_ret = gdextension.Call[Transform3D.BasisOrigin](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_get_global_transform_interpolated), gdextension.SizeTransform3D, unsafe.Pointer(&struct{}{}))
	var ret = gd.Transposed(r_ret)
	return ret
}

//go:nosplit
func (self class) SetGlobalPosition(position Vector3.XYZ) { //gd:Node3D.set_global_position
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_set_global_position), 0|(gdextension.SizeVector3<<4), unsafe.Pointer(&struct{ position Vector3.XYZ }{position}))
}

//go:nosplit
func (self class) GetGlobalPosition() Vector3.XYZ { //gd:Node3D.get_global_position
	var r_ret = gdextension.Call[Vector3.XYZ](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_get_global_position), gdextension.SizeVector3, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetGlobalBasis(basis Basis.XYZ) { //gd:Node3D.set_global_basis
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_set_global_basis), 0|(gdextension.SizeBasis<<4), unsafe.Pointer(&struct{ basis Basis.XYZ }{Basis.Transposed(basis)}))
}

//go:nosplit
func (self class) GetGlobalBasis() Basis.XYZ { //gd:Node3D.get_global_basis
	var r_ret = gdextension.Call[Basis.XYZ](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_get_global_basis), gdextension.SizeBasis, unsafe.Pointer(&struct{}{}))
	var ret = Basis.Transposed(r_ret)
	return ret
}

//go:nosplit
func (self class) SetGlobalRotation(euler_radians Vector3.XYZ) { //gd:Node3D.set_global_rotation
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_set_global_rotation), 0|(gdextension.SizeVector3<<4), unsafe.Pointer(&struct{ euler_radians Vector3.XYZ }{euler_radians}))
}

//go:nosplit
func (self class) GetGlobalRotation() Vector3.XYZ { //gd:Node3D.get_global_rotation
	var r_ret = gdextension.Call[Vector3.XYZ](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_get_global_rotation), gdextension.SizeVector3, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetGlobalRotationDegrees(euler_degrees Vector3.XYZ) { //gd:Node3D.set_global_rotation_degrees
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_set_global_rotation_degrees), 0|(gdextension.SizeVector3<<4), unsafe.Pointer(&struct{ euler_degrees Vector3.XYZ }{euler_degrees}))
}

//go:nosplit
func (self class) GetGlobalRotationDegrees() Vector3.XYZ { //gd:Node3D.get_global_rotation_degrees
	var r_ret = gdextension.Call[Vector3.XYZ](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_get_global_rotation_degrees), gdextension.SizeVector3, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the parent [Node3D], or [code]null[/code] if no parent exists, the parent is not of type [Node3D], or [member top_level] is [code]true[/code].
[b]Note:[/b] Calling this method is not equivalent to [code]get_parent() as Node3D[/code], which does not take [member top_level] into account.
*/
//go:nosplit
func (self class) GetParentNode3d() [1]gdclass.Node3D { //gd:Node3D.get_parent_node_3d
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_get_parent_node_3d), gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.Node3D{gd.PointerMustAssertInstanceID[gdclass.Node3D](r_ret)}
	return ret
}

/*
Sets whether the node ignores notification that its transformation (global or local) changed.
*/
//go:nosplit
func (self class) SetIgnoreTransformNotification(enabled bool) { //gd:Node3D.set_ignore_transform_notification
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_set_ignore_transform_notification), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enabled bool }{enabled}))
}

//go:nosplit
func (self class) SetAsTopLevel(enable bool) { //gd:Node3D.set_as_top_level
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_set_as_top_level), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

//go:nosplit
func (self class) IsSetAsTopLevel() bool { //gd:Node3D.is_set_as_top_level
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_is_set_as_top_level), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Sets whether the node uses a scale of [code](1, 1, 1)[/code] or its local transformation scale. Changes to the local transformation scale are preserved.
*/
//go:nosplit
func (self class) SetDisableScale(disable bool) { //gd:Node3D.set_disable_scale
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_set_disable_scale), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ disable bool }{disable}))
}

/*
Returns whether this node uses a scale of [code](1, 1, 1)[/code] or its local transformation scale.
*/
//go:nosplit
func (self class) IsScaleDisabled() bool { //gd:Node3D.is_scale_disabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_is_scale_disabled), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the current [World3D] resource this [Node3D] node is registered to.
*/
//go:nosplit
func (self class) GetWorld3d() [1]gdclass.World3D { //gd:Node3D.get_world_3d
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_get_world_3d), gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.World3D{gd.PointerWithOwnershipTransferredToGo[gdclass.World3D](r_ret)}
	return ret
}

/*
Forces the transform to update. Transform changes in physics are not instant for performance reasons. Transforms are accumulated and then set. Use this if you need an up-to-date transform when doing physics operations.
*/
//go:nosplit
func (self class) ForceUpdateTransform() { //gd:Node3D.force_update_transform
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_force_update_transform), 0, unsafe.Pointer(&struct{}{}))
}

//go:nosplit
func (self class) SetVisibilityParent(path Path.ToNode) { //gd:Node3D.set_visibility_parent
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_set_visibility_parent), 0|(gdextension.SizeNodePath<<4), unsafe.Pointer(&struct{ path gdextension.NodePath }{pointers.Get(gd.InternalNodePath(path))}))
}

//go:nosplit
func (self class) GetVisibilityParent() Path.ToNode { //gd:Node3D.get_visibility_parent
	var r_ret = gdextension.Call[gdextension.NodePath](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_get_visibility_parent), gdextension.SizeNodePath, unsafe.Pointer(&struct{}{}))
	var ret = Path.ToNode(String.Via(gd.NodePathProxy{}, pointers.Pack(pointers.New[gd.NodePath](r_ret))))
	return ret
}

/*
Updates all the [Node3D] gizmos attached to this node.
*/
//go:nosplit
func (self class) UpdateGizmos() { //gd:Node3D.update_gizmos
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_update_gizmos), 0, unsafe.Pointer(&struct{}{}))
}

/*
Attach an editor gizmo to this [Node3D].
[b]Note:[/b] The gizmo object would typically be an instance of [EditorNode3DGizmo], but the argument type is kept generic to avoid creating a dependency on editor classes in [Node3D].
*/
//go:nosplit
func (self class) AddGizmo(gizmo [1]gdclass.Node3DGizmo) { //gd:Node3D.add_gizmo
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_add_gizmo), 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ gizmo gdextension.Object }{gdextension.Object(gd.ObjectChecked(gizmo[0].AsObject()))}))
}

/*
Returns all the gizmos attached to this [Node3D].
*/
//go:nosplit
func (self class) GetGizmos() Array.Contains[[1]gdclass.Node3DGizmo] { //gd:Node3D.get_gizmos
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_get_gizmos), gdextension.SizeArray, unsafe.Pointer(&struct{}{}))
	var ret = Array.Through(gd.ArrayProxy[[1]gdclass.Node3DGizmo]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

/*
Clear all gizmos attached to this [Node3D].
*/
//go:nosplit
func (self class) ClearGizmos() { //gd:Node3D.clear_gizmos
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_clear_gizmos), 0, unsafe.Pointer(&struct{}{}))
}

/*
Set subgizmo selection for this node in the editor.
[b]Note:[/b] The gizmo object would typically be an instance of [EditorNode3DGizmo], but the argument type is kept generic to avoid creating a dependency on editor classes in [Node3D].
*/
//go:nosplit
func (self class) SetSubgizmoSelection(gizmo [1]gdclass.Node3DGizmo, id int64, transform Transform3D.BasisOrigin) { //gd:Node3D.set_subgizmo_selection
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_set_subgizmo_selection), 0|(gdextension.SizeObject<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeTransform3D<<12), unsafe.Pointer(&struct {
		gizmo     gdextension.Object
		id        int64
		transform Transform3D.BasisOrigin
	}{gdextension.Object(gd.ObjectChecked(gizmo[0].AsObject())), id, gd.Transposed(transform)}))
}

/*
Clears subgizmo selection for this node in the editor. Useful when subgizmo IDs become invalid after a property change.
*/
//go:nosplit
func (self class) ClearSubgizmoSelection() { //gd:Node3D.clear_subgizmo_selection
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_clear_subgizmo_selection), 0, unsafe.Pointer(&struct{}{}))
}

//go:nosplit
func (self class) SetVisible(visible bool) { //gd:Node3D.set_visible
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_set_visible), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ visible bool }{visible}))
}

//go:nosplit
func (self class) IsVisible() bool { //gd:Node3D.is_visible
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_is_visible), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if the node is present in the [SceneTree], its [member visible] property is [code]true[/code] and all its ancestors are also visible. If any ancestor is hidden, this node will not be visible in the scene tree.
Visibility is checked only in parent nodes that inherit from [Node3D]. If the parent is of any other type (such as [Node], [AnimationPlayer], or [Node2D]), it is assumed to be visible.
[b]Note:[/b] This method does not take [member VisualInstance3D.layers] into account, so even if this method returns [code]true[/code], the node might end up not being rendered.
*/
//go:nosplit
func (self class) IsVisibleInTree() bool { //gd:Node3D.is_visible_in_tree
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_is_visible_in_tree), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Enables rendering of this node. Changes [member visible] to [code]true[/code].
*/
//go:nosplit
func (self class) Show() { //gd:Node3D.show
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_show), 0, unsafe.Pointer(&struct{}{}))
}

/*
Disables rendering of this node. Changes [member visible] to [code]false[/code].
*/
//go:nosplit
func (self class) Hide() { //gd:Node3D.hide
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_hide), 0, unsafe.Pointer(&struct{}{}))
}

/*
Sets whether the node notifies about its local transformation changes. [Node3D] will not propagate this by default.
*/
//go:nosplit
func (self class) SetNotifyLocalTransform(enable bool) { //gd:Node3D.set_notify_local_transform
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_set_notify_local_transform), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

/*
Returns whether node notifies about its local transformation changes. [Node3D] will not propagate this by default.
*/
//go:nosplit
func (self class) IsLocalTransformNotificationEnabled() bool { //gd:Node3D.is_local_transform_notification_enabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_is_local_transform_notification_enabled), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Sets whether the node notifies about its global and local transformation changes. [Node3D] will not propagate this by default, unless it is in the editor context and it has a valid gizmo.
*/
//go:nosplit
func (self class) SetNotifyTransform(enable bool) { //gd:Node3D.set_notify_transform
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_set_notify_transform), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

/*
Returns whether the node notifies about its global and local transformation changes. [Node3D] will not propagate this by default.
*/
//go:nosplit
func (self class) IsTransformNotificationEnabled() bool { //gd:Node3D.is_transform_notification_enabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_is_transform_notification_enabled), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Rotates the local transformation around axis, a unit [Vector3], by specified angle in radians.
*/
//go:nosplit
func (self class) Rotate(axis Vector3.XYZ, angle float64) { //gd:Node3D.rotate
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_rotate), 0|(gdextension.SizeVector3<<4)|(gdextension.SizeFloat<<8), unsafe.Pointer(&struct {
		axis  Vector3.XYZ
		angle float64
	}{axis, angle}))
}

/*
Rotates the global (world) transformation around axis, a unit [Vector3], by specified angle in radians. The rotation axis is in global coordinate system.
*/
//go:nosplit
func (self class) GlobalRotate(axis Vector3.XYZ, angle float64) { //gd:Node3D.global_rotate
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_global_rotate), 0|(gdextension.SizeVector3<<4)|(gdextension.SizeFloat<<8), unsafe.Pointer(&struct {
		axis  Vector3.XYZ
		angle float64
	}{axis, angle}))
}

/*
Scales the global (world) transformation by the given [Vector3] scale factors.
*/
//go:nosplit
func (self class) GlobalScale(scale Vector3.XYZ) { //gd:Node3D.global_scale
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_global_scale), 0|(gdextension.SizeVector3<<4), unsafe.Pointer(&struct{ scale Vector3.XYZ }{scale}))
}

/*
Moves the global (world) transformation by [Vector3] offset. The offset is in global coordinate system.
*/
//go:nosplit
func (self class) GlobalTranslate(offset Vector3.XYZ) { //gd:Node3D.global_translate
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_global_translate), 0|(gdextension.SizeVector3<<4), unsafe.Pointer(&struct{ offset Vector3.XYZ }{offset}))
}

/*
Rotates the local transformation around axis, a unit [Vector3], by specified angle in radians. The rotation axis is in object-local coordinate system.
*/
//go:nosplit
func (self class) RotateObjectLocal(axis Vector3.XYZ, angle float64) { //gd:Node3D.rotate_object_local
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_rotate_object_local), 0|(gdextension.SizeVector3<<4)|(gdextension.SizeFloat<<8), unsafe.Pointer(&struct {
		axis  Vector3.XYZ
		angle float64
	}{axis, angle}))
}

/*
Scales the local transformation by given 3D scale factors in object-local coordinate system.
*/
//go:nosplit
func (self class) ScaleObjectLocal(scale Vector3.XYZ) { //gd:Node3D.scale_object_local
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_scale_object_local), 0|(gdextension.SizeVector3<<4), unsafe.Pointer(&struct{ scale Vector3.XYZ }{scale}))
}

/*
Changes the node's position by the given offset [Vector3] in local space.
*/
//go:nosplit
func (self class) TranslateObjectLocal(offset Vector3.XYZ) { //gd:Node3D.translate_object_local
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_translate_object_local), 0|(gdextension.SizeVector3<<4), unsafe.Pointer(&struct{ offset Vector3.XYZ }{offset}))
}

/*
Rotates the local transformation around the X axis by angle in radians.
*/
//go:nosplit
func (self class) RotateX(angle float64) { //gd:Node3D.rotate_x
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_rotate_x), 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ angle float64 }{angle}))
}

/*
Rotates the local transformation around the Y axis by angle in radians.
*/
//go:nosplit
func (self class) RotateY(angle float64) { //gd:Node3D.rotate_y
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_rotate_y), 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ angle float64 }{angle}))
}

/*
Rotates the local transformation around the Z axis by angle in radians.
*/
//go:nosplit
func (self class) RotateZ(angle float64) { //gd:Node3D.rotate_z
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_rotate_z), 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ angle float64 }{angle}))
}

/*
Changes the node's position by the given offset [Vector3].
Note that the translation [param offset] is affected by the node's scale, so if scaled by e.g. [code](10, 1, 1)[/code], a translation by an offset of [code](2, 0, 0)[/code] would actually add 20 ([code]2 * 10[/code]) to the X coordinate.
*/
//go:nosplit
func (self class) Translate(offset Vector3.XYZ) { //gd:Node3D.translate
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_translate), 0|(gdextension.SizeVector3<<4), unsafe.Pointer(&struct{ offset Vector3.XYZ }{offset}))
}

/*
Resets this node's transformations (like scale, skew and taper) preserving its rotation and translation by performing Gram-Schmidt orthonormalization on this node's [Transform3D].
*/
//go:nosplit
func (self class) Orthonormalize() { //gd:Node3D.orthonormalize
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_orthonormalize), 0, unsafe.Pointer(&struct{}{}))
}

/*
Reset all transformations for this node (sets its [Transform3D] to the identity matrix).
*/
//go:nosplit
func (self class) SetIdentity() { //gd:Node3D.set_identity
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_set_identity), 0, unsafe.Pointer(&struct{}{}))
}

/*
Rotates the node so that the local forward axis (-Z, [constant Vector3.FORWARD]) points toward the [param target] position.
The local up axis (+Y) points as close to the [param up] vector as possible while staying perpendicular to the local forward axis. The resulting transform is orthogonal, and the scale is preserved. Non-uniform scaling may not work correctly.
The [param target] position cannot be the same as the node's position, the [param up] vector cannot be zero.
The [param target] and the [param up] cannot be [constant Vector3.ZERO], and shouldn't be colinear to avoid unintended rotation around local Z axis.
Operations take place in global space, which means that the node must be in the scene tree.
If [param use_model_front] is [code]true[/code], the +Z axis (asset front) is treated as forward (implies +X is left) and points toward the [param target] position. By default, the -Z axis (camera forward) is treated as forward (implies +X is right).
*/
//go:nosplit
func (self class) LookAt(target Vector3.XYZ, up Vector3.XYZ, use_model_front bool) { //gd:Node3D.look_at
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_look_at), 0|(gdextension.SizeVector3<<4)|(gdextension.SizeVector3<<8)|(gdextension.SizeBool<<12), unsafe.Pointer(&struct {
		target          Vector3.XYZ
		up              Vector3.XYZ
		use_model_front bool
	}{target, up, use_model_front}))
}

/*
Moves the node to the specified [param position], and then rotates the node to point toward the [param target] as per [method look_at]. Operations take place in global space.
*/
//go:nosplit
func (self class) LookAtFromPosition(position Vector3.XYZ, target Vector3.XYZ, up Vector3.XYZ, use_model_front bool) { //gd:Node3D.look_at_from_position
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_look_at_from_position), 0|(gdextension.SizeVector3<<4)|(gdextension.SizeVector3<<8)|(gdextension.SizeVector3<<12)|(gdextension.SizeBool<<16), unsafe.Pointer(&struct {
		position        Vector3.XYZ
		target          Vector3.XYZ
		up              Vector3.XYZ
		use_model_front bool
	}{position, target, up, use_model_front}))
}

/*
Transforms [param global_point] from world space to this node's local space.
*/
//go:nosplit
func (self class) ToLocal(global_point Vector3.XYZ) Vector3.XYZ { //gd:Node3D.to_local
	var r_ret = gdextension.Call[Vector3.XYZ](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_to_local), gdextension.SizeVector3|(gdextension.SizeVector3<<4), unsafe.Pointer(&struct{ global_point Vector3.XYZ }{global_point}))
	var ret = r_ret
	return ret
}

/*
Transforms [param local_point] from this node's local space to world space.
*/
//go:nosplit
func (self class) ToGlobal(local_point Vector3.XYZ) Vector3.XYZ { //gd:Node3D.to_global
	var r_ret = gdextension.Call[Vector3.XYZ](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Node3D.Bind_to_global), gdextension.SizeVector3|(gdextension.SizeVector3<<4), unsafe.Pointer(&struct{ local_point Vector3.XYZ }{local_point}))
	var ret = r_ret
	return ret
}
func (self Instance) OnVisibilityChanged(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("visibility_changed"), gd.NewCallable(cb), 0)
}

func (self class) AsNode3D() Advanced            { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsNode3D() Instance         { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsNode3D() Instance    { return self.Super().AsNode3D() }
func (self class) AsNode() Node.Advanced         { return *((*Node.Advanced)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsNode() Node.Instance { return self.Super().AsNode() }
func (self Instance) AsNode() Node.Instance      { return *((*Node.Instance)(unsafe.Pointer(&self))) }

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Node.Advanced(self.AsNode()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Node.Instance(self.AsNode()), name)
	}
}
func init() {
	gdclass.Register("Node3D", func(ptr gd.Object) any { return [1]gdclass.Node3D{*(*gdclass.Node3D)(unsafe.Pointer(&ptr))} })
}

type RotationEditMode int //gd:Node3D.RotationEditMode

const (
	/*The rotation is edited using [Vector3] Euler angles.*/
	RotationEditModeEuler RotationEditMode = 0
	/*The rotation is edited using a [Quaternion].*/
	RotationEditModeQuaternion RotationEditMode = 1
	/*The rotation is edited using a [Basis]. In this mode, [member scale] can't be edited separately.*/
	RotationEditModeBasis RotationEditMode = 2
)
const NotificationTransformChanged Object.Notification = 2000    //gd:Node3D.NOTIFICATION_TRANSFORM_CHANGED
const NotificationEnterWorld Object.Notification = 41            //gd:Node3D.NOTIFICATION_ENTER_WORLD
const NotificationExitWorld Object.Notification = 42             //gd:Node3D.NOTIFICATION_EXIT_WORLD
const NotificationVisibilityChanged Object.Notification = 43     //gd:Node3D.NOTIFICATION_VISIBILITY_CHANGED
const NotificationLocalTransformChanged Object.Notification = 44 //gd:Node3D.NOTIFICATION_LOCAL_TRANSFORM_CHANGED
