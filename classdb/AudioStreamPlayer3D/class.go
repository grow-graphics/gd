// Code generated by the generate package DO NOT EDIT

// Package AudioStreamPlayer3D provides methods for working with AudioStreamPlayer3D object instances.
package AudioStreamPlayer3D

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdunsafe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/AudioServer"
import "graphics.gd/classdb/AudioStream"
import "graphics.gd/classdb/AudioStreamPlayback"
import "graphics.gd/classdb/Node"
import "graphics.gd/classdb/Node3D"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = gdunsafe.Use{}
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
Plays audio with positional sound effects, based on the relative position of the audio listener. Positional effects include distance attenuation, directionality, and the Doppler effect. For greater realism, a low-pass filter is applied to distant sounds. This can be disabled by setting [member attenuation_filter_cutoff_hz] to [code]20500[/code].
By default, audio is heard from the camera position. This can be changed by adding an [AudioListener3D] node to the scene and enabling it by calling [method AudioListener3D.make_current] on it.
See also [AudioStreamPlayer] to play a sound non-positionally.
[b]Note:[/b] Hiding an [AudioStreamPlayer3D] node does not disable its audio output. To temporarily disable an [AudioStreamPlayer3D]'s audio output, set [member volume_db] to a very low value like [code]-100[/code] (which isn't audible to human hearing).
*/
type Instance [1]gdclass.AudioStreamPlayer3D

func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

type Expanded [1]gdclass.AudioStreamPlayer3D

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsAudioStreamPlayer3D() Instance
}

/*
Queues the audio to play on the next physics frame, from the given position [param from_position], in seconds.
*/
func (self Instance) Play() { //gd:AudioStreamPlayer3D.play
	Advanced(self).Play(float64(0.0))
}

/*
Queues the audio to play on the next physics frame, from the given position [param from_position], in seconds.
*/
func (self Expanded) Play(from_position Float.X) { //gd:AudioStreamPlayer3D.play
	Advanced(self).Play(float64(from_position))
}

/*
Sets the position from which audio will be played, in seconds.
*/
func (self Instance) SeekTo(to_position Float.X) { //gd:AudioStreamPlayer3D.seek
	Advanced(self).SeekTo(float64(to_position))
}

/*
Stops the audio.
*/
func (self Instance) Stop() { //gd:AudioStreamPlayer3D.stop
	Advanced(self).Stop()
}

/*
Returns the position in the [AudioStream].
*/
func (self Instance) GetPlaybackPosition() Float.X { //gd:AudioStreamPlayer3D.get_playback_position
	return Float.X(Float.X(Advanced(self).GetPlaybackPosition()))
}

/*
Returns whether the [AudioStreamPlayer] can return the [AudioStreamPlayback] object or not.
*/
func (self Instance) HasStreamPlayback() bool { //gd:AudioStreamPlayer3D.has_stream_playback
	return bool(Advanced(self).HasStreamPlayback())
}

/*
Returns the [AudioStreamPlayback] object associated with this [AudioStreamPlayer3D].
*/
func (self Instance) GetStreamPlayback() AudioStreamPlayback.Instance { //gd:AudioStreamPlayer3D.get_stream_playback
	return AudioStreamPlayback.Instance(Advanced(self).GetStreamPlayback())
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.AudioStreamPlayer3D

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {
	object := gd.Global.ClassDB.ConstructObject(gd.NewStringName("AudioStreamPlayer3D"))
	casted := Instance{*(*gdclass.AudioStreamPlayer3D)(unsafe.Pointer(&object))}
	return casted
}

func (self Instance) Stream() AudioStream.Instance {
	return AudioStream.Instance(class(self).GetStream())
}

func (self Instance) SetStream(value AudioStream.Instance) {
	class(self).SetStream(value)
}

func (self Instance) AttenuationModel() AttenuationModel {
	return AttenuationModel(class(self).GetAttenuationModel())
}

func (self Instance) SetAttenuationModel(value AttenuationModel) {
	class(self).SetAttenuationModel(value)
}

func (self Instance) VolumeDb() Float.X {
	return Float.X(Float.X(class(self).GetVolumeDb()))
}

func (self Instance) SetVolumeDb(value Float.X) {
	class(self).SetVolumeDb(float64(value))
}

func (self Instance) VolumeLinear() Float.X {
	return Float.X(Float.X(class(self).GetVolumeLinear()))
}

func (self Instance) SetVolumeLinear(value Float.X) {
	class(self).SetVolumeLinear(float64(value))
}

func (self Instance) UnitSize() Float.X {
	return Float.X(Float.X(class(self).GetUnitSize()))
}

func (self Instance) SetUnitSize(value Float.X) {
	class(self).SetUnitSize(float64(value))
}

func (self Instance) MaxDb() Float.X {
	return Float.X(Float.X(class(self).GetMaxDb()))
}

func (self Instance) SetMaxDb(value Float.X) {
	class(self).SetMaxDb(float64(value))
}

func (self Instance) PitchScale() Float.X {
	return Float.X(Float.X(class(self).GetPitchScale()))
}

func (self Instance) SetPitchScale(value Float.X) {
	class(self).SetPitchScale(float64(value))
}

func (self Instance) Playing() bool {
	return bool(class(self).IsPlaying())
}

func (self Instance) SetPlaying(value bool) {
	class(self).SetPlaying(value)
}

func (self Instance) Autoplay() bool {
	return bool(class(self).IsAutoplayEnabled())
}

func (self Instance) SetAutoplay(value bool) {
	class(self).SetAutoplay(value)
}

func (self Instance) StreamPaused() bool {
	return bool(class(self).GetStreamPaused())
}

func (self Instance) SetStreamPaused(value bool) {
	class(self).SetStreamPaused(value)
}

func (self Instance) MaxDistance() Float.X {
	return Float.X(Float.X(class(self).GetMaxDistance()))
}

func (self Instance) SetMaxDistance(value Float.X) {
	class(self).SetMaxDistance(float64(value))
}

func (self Instance) MaxPolyphony() int {
	return int(int(class(self).GetMaxPolyphony()))
}

func (self Instance) SetMaxPolyphony(value int) {
	class(self).SetMaxPolyphony(int64(value))
}

func (self Instance) PanningStrength() Float.X {
	return Float.X(Float.X(class(self).GetPanningStrength()))
}

func (self Instance) SetPanningStrength(value Float.X) {
	class(self).SetPanningStrength(float64(value))
}

func (self Instance) Bus() string {
	return string(class(self).GetBus().String())
}

func (self Instance) SetBus(value string) {
	class(self).SetBus(String.Name(String.New(value)))
}

func (self Instance) AreaMask() int {
	return int(int(class(self).GetAreaMask()))
}

func (self Instance) SetAreaMask(value int) {
	class(self).SetAreaMask(int64(value))
}

func (self Instance) PlaybackType() AudioServer.PlaybackType {
	return AudioServer.PlaybackType(class(self).GetPlaybackType())
}

func (self Instance) SetPlaybackType(value AudioServer.PlaybackType) {
	class(self).SetPlaybackType(value)
}

func (self Instance) EmissionAngleEnabled() bool {
	return bool(class(self).IsEmissionAngleEnabled())
}

func (self Instance) SetEmissionAngleEnabled(value bool) {
	class(self).SetEmissionAngleEnabled(value)
}

func (self Instance) EmissionAngleDegrees() Angle.Radians {
	return Angle.Radians(Float.X(class(self).GetEmissionAngle()))
}

func (self Instance) SetEmissionAngleDegrees(value Angle.Radians) {
	class(self).SetEmissionAngle(float64(value))
}

func (self Instance) EmissionAngleFilterAttenuationDb() Angle.Radians {
	return Angle.Radians(Float.X(class(self).GetEmissionAngleFilterAttenuationDb()))
}

func (self Instance) SetEmissionAngleFilterAttenuationDb(value Angle.Radians) {
	class(self).SetEmissionAngleFilterAttenuationDb(float64(value))
}

func (self Instance) AttenuationFilterCutoffHz() Float.X {
	return Float.X(Float.X(class(self).GetAttenuationFilterCutoffHz()))
}

func (self Instance) SetAttenuationFilterCutoffHz(value Float.X) {
	class(self).SetAttenuationFilterCutoffHz(float64(value))
}

func (self Instance) AttenuationFilterDb() Float.X {
	return Float.X(Float.X(class(self).GetAttenuationFilterDb()))
}

func (self Instance) SetAttenuationFilterDb(value Float.X) {
	class(self).SetAttenuationFilterDb(float64(value))
}

func (self Instance) DopplerTracking() DopplerTracking {
	return DopplerTracking(class(self).GetDopplerTracking())
}

func (self Instance) SetDopplerTracking(value DopplerTracking) {
	class(self).SetDopplerTracking(value)
}

//go:nosplit
func (self class) SetStream(stream [1]gdclass.AudioStream) { //gd:AudioStreamPlayer3D.set_stream
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.AudioStreamPlayer3D.Bind_set_stream, 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ stream gdextension.Object }{gdextension.Object(pointers.Get(stream[0])[0])}))
}

//go:nosplit
func (self class) GetStream() [1]gdclass.AudioStream { //gd:AudioStreamPlayer3D.get_stream
	var r_ret = gdunsafe.Call[gd.EnginePointer](self.AsObject(), gd.Global.Methods.AudioStreamPlayer3D.Bind_get_stream, gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.AudioStream{gd.PointerWithOwnershipTransferredToGo[gdclass.AudioStream](r_ret)}
	return ret
}

//go:nosplit
func (self class) SetVolumeDb(volume_db float64) { //gd:AudioStreamPlayer3D.set_volume_db
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.AudioStreamPlayer3D.Bind_set_volume_db, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ volume_db float64 }{volume_db}))
}

//go:nosplit
func (self class) GetVolumeDb() float64 { //gd:AudioStreamPlayer3D.get_volume_db
	var r_ret = gdunsafe.Call[float64](self.AsObject(), gd.Global.Methods.AudioStreamPlayer3D.Bind_get_volume_db, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetVolumeLinear(volume_linear float64) { //gd:AudioStreamPlayer3D.set_volume_linear
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.AudioStreamPlayer3D.Bind_set_volume_linear, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ volume_linear float64 }{volume_linear}))
}

//go:nosplit
func (self class) GetVolumeLinear() float64 { //gd:AudioStreamPlayer3D.get_volume_linear
	var r_ret = gdunsafe.Call[float64](self.AsObject(), gd.Global.Methods.AudioStreamPlayer3D.Bind_get_volume_linear, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetUnitSize(unit_size float64) { //gd:AudioStreamPlayer3D.set_unit_size
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.AudioStreamPlayer3D.Bind_set_unit_size, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ unit_size float64 }{unit_size}))
}

//go:nosplit
func (self class) GetUnitSize() float64 { //gd:AudioStreamPlayer3D.get_unit_size
	var r_ret = gdunsafe.Call[float64](self.AsObject(), gd.Global.Methods.AudioStreamPlayer3D.Bind_get_unit_size, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetMaxDb(max_db float64) { //gd:AudioStreamPlayer3D.set_max_db
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.AudioStreamPlayer3D.Bind_set_max_db, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ max_db float64 }{max_db}))
}

//go:nosplit
func (self class) GetMaxDb() float64 { //gd:AudioStreamPlayer3D.get_max_db
	var r_ret = gdunsafe.Call[float64](self.AsObject(), gd.Global.Methods.AudioStreamPlayer3D.Bind_get_max_db, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetPitchScale(pitch_scale float64) { //gd:AudioStreamPlayer3D.set_pitch_scale
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.AudioStreamPlayer3D.Bind_set_pitch_scale, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ pitch_scale float64 }{pitch_scale}))
}

//go:nosplit
func (self class) GetPitchScale() float64 { //gd:AudioStreamPlayer3D.get_pitch_scale
	var r_ret = gdunsafe.Call[float64](self.AsObject(), gd.Global.Methods.AudioStreamPlayer3D.Bind_get_pitch_scale, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Queues the audio to play on the next physics frame, from the given position [param from_position], in seconds.
*/
//go:nosplit
func (self class) Play(from_position float64) { //gd:AudioStreamPlayer3D.play
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.AudioStreamPlayer3D.Bind_play, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ from_position float64 }{from_position}))
}

/*
Sets the position from which audio will be played, in seconds.
*/
//go:nosplit
func (self class) SeekTo(to_position float64) { //gd:AudioStreamPlayer3D.seek
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.AudioStreamPlayer3D.Bind_seek, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ to_position float64 }{to_position}))
}

/*
Stops the audio.
*/
//go:nosplit
func (self class) Stop() { //gd:AudioStreamPlayer3D.stop
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.AudioStreamPlayer3D.Bind_stop, 0, unsafe.Pointer(&struct{}{}))
}

//go:nosplit
func (self class) IsPlaying() bool { //gd:AudioStreamPlayer3D.is_playing
	var r_ret = gdunsafe.Call[bool](self.AsObject(), gd.Global.Methods.AudioStreamPlayer3D.Bind_is_playing, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the position in the [AudioStream].
*/
//go:nosplit
func (self class) GetPlaybackPosition() float64 { //gd:AudioStreamPlayer3D.get_playback_position
	var r_ret = gdunsafe.Call[float64](self.AsObject(), gd.Global.Methods.AudioStreamPlayer3D.Bind_get_playback_position, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetBus(bus String.Name) { //gd:AudioStreamPlayer3D.set_bus
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.AudioStreamPlayer3D.Bind_set_bus, 0|(gdextension.SizeStringName<<4), unsafe.Pointer(&struct{ bus gdextension.StringName }{gdextension.StringName(pointers.Get(gd.InternalStringName(bus))[0])}))
}

//go:nosplit
func (self class) GetBus() String.Name { //gd:AudioStreamPlayer3D.get_bus
	var r_ret = gdunsafe.Call[[1]gd.EnginePointer](self.AsObject(), gd.Global.Methods.AudioStreamPlayer3D.Bind_get_bus, gdextension.SizeStringName, unsafe.Pointer(&struct{}{}))
	var ret = String.Name(String.Via(gd.StringNameProxy{}, pointers.Pack(pointers.New[gd.StringName](r_ret))))
	return ret
}

//go:nosplit
func (self class) SetAutoplay(enable bool) { //gd:AudioStreamPlayer3D.set_autoplay
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.AudioStreamPlayer3D.Bind_set_autoplay, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

//go:nosplit
func (self class) IsAutoplayEnabled() bool { //gd:AudioStreamPlayer3D.is_autoplay_enabled
	var r_ret = gdunsafe.Call[bool](self.AsObject(), gd.Global.Methods.AudioStreamPlayer3D.Bind_is_autoplay_enabled, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetPlaying(enable bool) { //gd:AudioStreamPlayer3D.set_playing
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.AudioStreamPlayer3D.Bind_set_playing, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

//go:nosplit
func (self class) SetMaxDistance(meters float64) { //gd:AudioStreamPlayer3D.set_max_distance
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.AudioStreamPlayer3D.Bind_set_max_distance, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ meters float64 }{meters}))
}

//go:nosplit
func (self class) GetMaxDistance() float64 { //gd:AudioStreamPlayer3D.get_max_distance
	var r_ret = gdunsafe.Call[float64](self.AsObject(), gd.Global.Methods.AudioStreamPlayer3D.Bind_get_max_distance, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetAreaMask(mask int64) { //gd:AudioStreamPlayer3D.set_area_mask
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.AudioStreamPlayer3D.Bind_set_area_mask, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ mask int64 }{mask}))
}

//go:nosplit
func (self class) GetAreaMask() int64 { //gd:AudioStreamPlayer3D.get_area_mask
	var r_ret = gdunsafe.Call[int64](self.AsObject(), gd.Global.Methods.AudioStreamPlayer3D.Bind_get_area_mask, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetEmissionAngle(degrees float64) { //gd:AudioStreamPlayer3D.set_emission_angle
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.AudioStreamPlayer3D.Bind_set_emission_angle, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ degrees float64 }{degrees}))
}

//go:nosplit
func (self class) GetEmissionAngle() float64 { //gd:AudioStreamPlayer3D.get_emission_angle
	var r_ret = gdunsafe.Call[float64](self.AsObject(), gd.Global.Methods.AudioStreamPlayer3D.Bind_get_emission_angle, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetEmissionAngleEnabled(enabled bool) { //gd:AudioStreamPlayer3D.set_emission_angle_enabled
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.AudioStreamPlayer3D.Bind_set_emission_angle_enabled, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enabled bool }{enabled}))
}

//go:nosplit
func (self class) IsEmissionAngleEnabled() bool { //gd:AudioStreamPlayer3D.is_emission_angle_enabled
	var r_ret = gdunsafe.Call[bool](self.AsObject(), gd.Global.Methods.AudioStreamPlayer3D.Bind_is_emission_angle_enabled, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetEmissionAngleFilterAttenuationDb(db float64) { //gd:AudioStreamPlayer3D.set_emission_angle_filter_attenuation_db
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.AudioStreamPlayer3D.Bind_set_emission_angle_filter_attenuation_db, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ db float64 }{db}))
}

//go:nosplit
func (self class) GetEmissionAngleFilterAttenuationDb() float64 { //gd:AudioStreamPlayer3D.get_emission_angle_filter_attenuation_db
	var r_ret = gdunsafe.Call[float64](self.AsObject(), gd.Global.Methods.AudioStreamPlayer3D.Bind_get_emission_angle_filter_attenuation_db, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetAttenuationFilterCutoffHz(degrees float64) { //gd:AudioStreamPlayer3D.set_attenuation_filter_cutoff_hz
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.AudioStreamPlayer3D.Bind_set_attenuation_filter_cutoff_hz, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ degrees float64 }{degrees}))
}

//go:nosplit
func (self class) GetAttenuationFilterCutoffHz() float64 { //gd:AudioStreamPlayer3D.get_attenuation_filter_cutoff_hz
	var r_ret = gdunsafe.Call[float64](self.AsObject(), gd.Global.Methods.AudioStreamPlayer3D.Bind_get_attenuation_filter_cutoff_hz, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetAttenuationFilterDb(db float64) { //gd:AudioStreamPlayer3D.set_attenuation_filter_db
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.AudioStreamPlayer3D.Bind_set_attenuation_filter_db, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ db float64 }{db}))
}

//go:nosplit
func (self class) GetAttenuationFilterDb() float64 { //gd:AudioStreamPlayer3D.get_attenuation_filter_db
	var r_ret = gdunsafe.Call[float64](self.AsObject(), gd.Global.Methods.AudioStreamPlayer3D.Bind_get_attenuation_filter_db, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetAttenuationModel(model AttenuationModel) { //gd:AudioStreamPlayer3D.set_attenuation_model
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.AudioStreamPlayer3D.Bind_set_attenuation_model, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ model AttenuationModel }{model}))
}

//go:nosplit
func (self class) GetAttenuationModel() AttenuationModel { //gd:AudioStreamPlayer3D.get_attenuation_model
	var r_ret = gdunsafe.Call[AttenuationModel](self.AsObject(), gd.Global.Methods.AudioStreamPlayer3D.Bind_get_attenuation_model, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetDopplerTracking(mode DopplerTracking) { //gd:AudioStreamPlayer3D.set_doppler_tracking
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.AudioStreamPlayer3D.Bind_set_doppler_tracking, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ mode DopplerTracking }{mode}))
}

//go:nosplit
func (self class) GetDopplerTracking() DopplerTracking { //gd:AudioStreamPlayer3D.get_doppler_tracking
	var r_ret = gdunsafe.Call[DopplerTracking](self.AsObject(), gd.Global.Methods.AudioStreamPlayer3D.Bind_get_doppler_tracking, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetStreamPaused(pause bool) { //gd:AudioStreamPlayer3D.set_stream_paused
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.AudioStreamPlayer3D.Bind_set_stream_paused, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ pause bool }{pause}))
}

//go:nosplit
func (self class) GetStreamPaused() bool { //gd:AudioStreamPlayer3D.get_stream_paused
	var r_ret = gdunsafe.Call[bool](self.AsObject(), gd.Global.Methods.AudioStreamPlayer3D.Bind_get_stream_paused, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetMaxPolyphony(max_polyphony int64) { //gd:AudioStreamPlayer3D.set_max_polyphony
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.AudioStreamPlayer3D.Bind_set_max_polyphony, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ max_polyphony int64 }{max_polyphony}))
}

//go:nosplit
func (self class) GetMaxPolyphony() int64 { //gd:AudioStreamPlayer3D.get_max_polyphony
	var r_ret = gdunsafe.Call[int64](self.AsObject(), gd.Global.Methods.AudioStreamPlayer3D.Bind_get_max_polyphony, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetPanningStrength(panning_strength float64) { //gd:AudioStreamPlayer3D.set_panning_strength
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.AudioStreamPlayer3D.Bind_set_panning_strength, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ panning_strength float64 }{panning_strength}))
}

//go:nosplit
func (self class) GetPanningStrength() float64 { //gd:AudioStreamPlayer3D.get_panning_strength
	var r_ret = gdunsafe.Call[float64](self.AsObject(), gd.Global.Methods.AudioStreamPlayer3D.Bind_get_panning_strength, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns whether the [AudioStreamPlayer] can return the [AudioStreamPlayback] object or not.
*/
//go:nosplit
func (self class) HasStreamPlayback() bool { //gd:AudioStreamPlayer3D.has_stream_playback
	var r_ret = gdunsafe.Call[bool](self.AsObject(), gd.Global.Methods.AudioStreamPlayer3D.Bind_has_stream_playback, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the [AudioStreamPlayback] object associated with this [AudioStreamPlayer3D].
*/
//go:nosplit
func (self class) GetStreamPlayback() [1]gdclass.AudioStreamPlayback { //gd:AudioStreamPlayer3D.get_stream_playback
	var r_ret = gdunsafe.Call[gd.EnginePointer](self.AsObject(), gd.Global.Methods.AudioStreamPlayer3D.Bind_get_stream_playback, gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.AudioStreamPlayback{gd.PointerWithOwnershipTransferredToGo[gdclass.AudioStreamPlayback](r_ret)}
	return ret
}

//go:nosplit
func (self class) SetPlaybackType(playback_type AudioServer.PlaybackType) { //gd:AudioStreamPlayer3D.set_playback_type
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.AudioStreamPlayer3D.Bind_set_playback_type, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ playback_type AudioServer.PlaybackType }{playback_type}))
}

//go:nosplit
func (self class) GetPlaybackType() AudioServer.PlaybackType { //gd:AudioStreamPlayer3D.get_playback_type
	var r_ret = gdunsafe.Call[AudioServer.PlaybackType](self.AsObject(), gd.Global.Methods.AudioStreamPlayer3D.Bind_get_playback_type, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}
func (self Instance) OnFinished(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("finished"), gd.NewCallable(cb), 0)
}

func (self class) AsAudioStreamPlayer3D() Advanced    { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsAudioStreamPlayer3D() Instance { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsAudioStreamPlayer3D() Instance {
	return self.Super().AsAudioStreamPlayer3D()
}
func (self class) AsNode3D() Node3D.Advanced         { return *((*Node3D.Advanced)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsNode3D() Node3D.Instance { return self.Super().AsNode3D() }
func (self Instance) AsNode3D() Node3D.Instance      { return *((*Node3D.Instance)(unsafe.Pointer(&self))) }
func (self class) AsNode() Node.Advanced             { return *((*Node.Advanced)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsNode() Node.Instance     { return self.Super().AsNode() }
func (self Instance) AsNode() Node.Instance          { return *((*Node.Instance)(unsafe.Pointer(&self))) }

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Node3D.Advanced(self.AsNode3D()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Node3D.Instance(self.AsNode3D()), name)
	}
}
func init() {
	gdclass.Register("AudioStreamPlayer3D", func(ptr gd.Object) any {
		return [1]gdclass.AudioStreamPlayer3D{*(*gdclass.AudioStreamPlayer3D)(unsafe.Pointer(&ptr))}
	})
}

type AttenuationModel int //gd:AudioStreamPlayer3D.AttenuationModel

const (
	/*Attenuation of loudness according to linear distance.*/
	AttenuationInverseDistance AttenuationModel = 0
	/*Attenuation of loudness according to squared distance.*/
	AttenuationInverseSquareDistance AttenuationModel = 1
	/*Attenuation of loudness according to logarithmic distance.*/
	AttenuationLogarithmic AttenuationModel = 2
	/*No attenuation of loudness according to distance. The sound will still be heard positionally, unlike an [AudioStreamPlayer]. [constant ATTENUATION_DISABLED] can be combined with a [member max_distance] value greater than [code]0.0[/code] to achieve linear attenuation clamped to a sphere of a defined size.*/
	AttenuationDisabled AttenuationModel = 3
)

type DopplerTracking int //gd:AudioStreamPlayer3D.DopplerTracking

const (
	/*Disables doppler tracking.*/
	DopplerTrackingDisabled DopplerTracking = 0
	/*Executes doppler tracking during process frames (see [constant Node.NOTIFICATION_INTERNAL_PROCESS]).*/
	DopplerTrackingIdleStep DopplerTracking = 1
	/*Executes doppler tracking during physics frames (see [constant Node.NOTIFICATION_INTERNAL_PHYSICS_PROCESS]).*/
	DopplerTrackingPhysicsStep DopplerTracking = 2
)
