// Code generated by the generate package DO NOT EDIT

// Package CPUParticles2D provides methods for working with CPUParticles2D object instances.
package CPUParticles2D

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/CanvasItem"
import "graphics.gd/classdb/Curve"
import "graphics.gd/classdb/Gradient"
import "graphics.gd/classdb/Node"
import "graphics.gd/classdb/Node2D"
import "graphics.gd/classdb/Texture2D"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Color"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"
import "graphics.gd/variant/Vector2"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
CPU-based 2D particle node used to create a variety of particle systems and effects.
See also [GPUParticles2D], which provides the same functionality with hardware acceleration, but may not run on older devices.
*/
type Instance [1]gdclass.CPUParticles2D

func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

type Expanded [1]gdclass.CPUParticles2D

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsCPUParticles2D() Instance
}

/*
Requests the particles to process for extra process time during a single frame.
Useful for particle playback, if used in combination with [member use_fixed_seed] or by calling [method restart] with parameter [code]keep_seed[/code] set to [code]true[/code].
*/
func (self Instance) RequestParticlesProcess(process_time Float.X) { //gd:CPUParticles2D.request_particles_process
	Advanced(self).RequestParticlesProcess(float64(process_time))
}

/*
Restarts the particle emitter.
If [param keep_seed] is [code]true[/code], the current random seed will be preserved. Useful for seeking and playback.
*/
func (self Instance) Restart() { //gd:CPUParticles2D.restart
	Advanced(self).Restart(false)
}

/*
Restarts the particle emitter.
If [param keep_seed] is [code]true[/code], the current random seed will be preserved. Useful for seeking and playback.
*/
func (self Expanded) Restart(keep_seed bool) { //gd:CPUParticles2D.restart
	Advanced(self).Restart(keep_seed)
}

/*
Sets this node's properties to match a given [GPUParticles2D] node with an assigned [ParticleProcessMaterial].
*/
func (self Instance) ConvertFromParticles(particles Node.Instance) { //gd:CPUParticles2D.convert_from_particles
	Advanced(self).ConvertFromParticles(particles)
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.CPUParticles2D

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {
	object := gd.Global.ClassDB.ConstructObject(gd.NewStringName("CPUParticles2D"))
	casted := Instance{*(*gdclass.CPUParticles2D)(unsafe.Pointer(&object))}
	return casted
}

func (self Instance) Emitting() bool {
	return bool(class(self).IsEmitting())
}

func (self Instance) SetEmitting(value bool) {
	class(self).SetEmitting(value)
}

func (self Instance) Amount() int {
	return int(int(class(self).GetAmount()))
}

func (self Instance) SetAmount(value int) {
	class(self).SetAmount(int64(value))
}

func (self Instance) Texture() Texture2D.Instance {
	return Texture2D.Instance(class(self).GetTexture())
}

func (self Instance) SetTexture(value Texture2D.Instance) {
	class(self).SetTexture(value)
}

func (self Instance) Lifetime() Float.X {
	return Float.X(Float.X(class(self).GetLifetime()))
}

func (self Instance) SetLifetime(value Float.X) {
	class(self).SetLifetime(float64(value))
}

func (self Instance) OneShot() bool {
	return bool(class(self).GetOneShot())
}

func (self Instance) SetOneShot(value bool) {
	class(self).SetOneShot(value)
}

func (self Instance) Preprocess() Float.X {
	return Float.X(Float.X(class(self).GetPreProcessTime()))
}

func (self Instance) SetPreprocess(value Float.X) {
	class(self).SetPreProcessTime(float64(value))
}

func (self Instance) SpeedScale() Float.X {
	return Float.X(Float.X(class(self).GetSpeedScale()))
}

func (self Instance) SetSpeedScale(value Float.X) {
	class(self).SetSpeedScale(float64(value))
}

func (self Instance) Explosiveness() Float.X {
	return Float.X(Float.X(class(self).GetExplosivenessRatio()))
}

func (self Instance) SetExplosiveness(value Float.X) {
	class(self).SetExplosivenessRatio(float64(value))
}

func (self Instance) Randomness() Float.X {
	return Float.X(Float.X(class(self).GetRandomnessRatio()))
}

func (self Instance) SetRandomness(value Float.X) {
	class(self).SetRandomnessRatio(float64(value))
}

func (self Instance) UseFixedSeed() bool {
	return bool(class(self).GetUseFixedSeed())
}

func (self Instance) SetUseFixedSeed(value bool) {
	class(self).SetUseFixedSeed(value)
}

func (self Instance) Seed() int {
	return int(int(class(self).GetSeed()))
}

func (self Instance) SetSeed(value int) {
	class(self).SetSeed(int64(value))
}

func (self Instance) LifetimeRandomness() Float.X {
	return Float.X(Float.X(class(self).GetLifetimeRandomness()))
}

func (self Instance) SetLifetimeRandomness(value Float.X) {
	class(self).SetLifetimeRandomness(float64(value))
}

func (self Instance) FixedFps() int {
	return int(int(class(self).GetFixedFps()))
}

func (self Instance) SetFixedFps(value int) {
	class(self).SetFixedFps(int64(value))
}

func (self Instance) FractDelta() bool {
	return bool(class(self).GetFractionalDelta())
}

func (self Instance) SetFractDelta(value bool) {
	class(self).SetFractionalDelta(value)
}

func (self Instance) LocalCoords() bool {
	return bool(class(self).GetUseLocalCoordinates())
}

func (self Instance) SetLocalCoords(value bool) {
	class(self).SetUseLocalCoordinates(value)
}

func (self Instance) DrawOrder() DrawOrder {
	return DrawOrder(class(self).GetDrawOrder())
}

func (self Instance) SetDrawOrder(value DrawOrder) {
	class(self).SetDrawOrder(value)
}

func (self Instance) EmissionShape() EmissionShape {
	return EmissionShape(class(self).GetEmissionShape())
}

func (self Instance) SetEmissionShape(value EmissionShape) {
	class(self).SetEmissionShape(value)
}

func (self Instance) EmissionSphereRadius() Float.X {
	return Float.X(Float.X(class(self).GetEmissionSphereRadius()))
}

func (self Instance) SetEmissionSphereRadius(value Float.X) {
	class(self).SetEmissionSphereRadius(float64(value))
}

func (self Instance) EmissionRectExtents() Vector2.XY {
	return Vector2.XY(class(self).GetEmissionRectExtents())
}

func (self Instance) SetEmissionRectExtents(value Vector2.XY) {
	class(self).SetEmissionRectExtents(Vector2.XY(value))
}

func (self Instance) EmissionPoints() []Vector2.XY {
	return []Vector2.XY(slices.Collect(class(self).GetEmissionPoints().Values()))
}

func (self Instance) SetEmissionPoints(value []Vector2.XY) {
	class(self).SetEmissionPoints(Packed.New(value...))
}

func (self Instance) EmissionNormals() []Vector2.XY {
	return []Vector2.XY(slices.Collect(class(self).GetEmissionNormals().Values()))
}

func (self Instance) SetEmissionNormals(value []Vector2.XY) {
	class(self).SetEmissionNormals(Packed.New(value...))
}

func (self Instance) EmissionColors() []Color.RGBA {
	return []Color.RGBA(slices.Collect(class(self).GetEmissionColors().Values()))
}

func (self Instance) SetEmissionColors(value []Color.RGBA) {
	class(self).SetEmissionColors(Packed.New(value...))
}

func (self Instance) ParticleFlagAlignY() bool {
	return bool(class(self).GetParticleFlag(0))
}

func (self Instance) SetParticleFlagAlignY(value bool) {
	class(self).SetParticleFlag(0, value)
}

func (self Instance) Direction() Vector2.XY {
	return Vector2.XY(class(self).GetDirection())
}

func (self Instance) SetDirection(value Vector2.XY) {
	class(self).SetDirection(Vector2.XY(value))
}

func (self Instance) Spread() Float.X {
	return Float.X(Float.X(class(self).GetSpread()))
}

func (self Instance) SetSpread(value Float.X) {
	class(self).SetSpread(float64(value))
}

func (self Instance) Gravity() Vector2.XY {
	return Vector2.XY(class(self).GetGravity())
}

func (self Instance) SetGravity(value Vector2.XY) {
	class(self).SetGravity(Vector2.XY(value))
}

func (self Instance) InitialVelocityMin() Float.X {
	return Float.X(Float.X(class(self).GetParamMin(0)))
}

func (self Instance) SetInitialVelocityMin(value Float.X) {
	class(self).SetParamMin(0, float64(value))
}

func (self Instance) InitialVelocityMax() Float.X {
	return Float.X(Float.X(class(self).GetParamMax(0)))
}

func (self Instance) SetInitialVelocityMax(value Float.X) {
	class(self).SetParamMax(0, float64(value))
}

func (self Instance) AngularVelocityMin() Float.X {
	return Float.X(Float.X(class(self).GetParamMin(1)))
}

func (self Instance) SetAngularVelocityMin(value Float.X) {
	class(self).SetParamMin(1, float64(value))
}

func (self Instance) AngularVelocityMax() Float.X {
	return Float.X(Float.X(class(self).GetParamMax(1)))
}

func (self Instance) SetAngularVelocityMax(value Float.X) {
	class(self).SetParamMax(1, float64(value))
}

func (self Instance) AngularVelocityCurve() Curve.Instance {
	return Curve.Instance(class(self).GetParamCurve(1))
}

func (self Instance) SetAngularVelocityCurve(value Curve.Instance) {
	class(self).SetParamCurve(1, value)
}

func (self Instance) OrbitVelocityMin() Float.X {
	return Float.X(Float.X(class(self).GetParamMin(2)))
}

func (self Instance) SetOrbitVelocityMin(value Float.X) {
	class(self).SetParamMin(2, float64(value))
}

func (self Instance) OrbitVelocityMax() Float.X {
	return Float.X(Float.X(class(self).GetParamMax(2)))
}

func (self Instance) SetOrbitVelocityMax(value Float.X) {
	class(self).SetParamMax(2, float64(value))
}

func (self Instance) OrbitVelocityCurve() Curve.Instance {
	return Curve.Instance(class(self).GetParamCurve(2))
}

func (self Instance) SetOrbitVelocityCurve(value Curve.Instance) {
	class(self).SetParamCurve(2, value)
}

func (self Instance) LinearAccelMin() Float.X {
	return Float.X(Float.X(class(self).GetParamMin(3)))
}

func (self Instance) SetLinearAccelMin(value Float.X) {
	class(self).SetParamMin(3, float64(value))
}

func (self Instance) LinearAccelMax() Float.X {
	return Float.X(Float.X(class(self).GetParamMax(3)))
}

func (self Instance) SetLinearAccelMax(value Float.X) {
	class(self).SetParamMax(3, float64(value))
}

func (self Instance) LinearAccelCurve() Curve.Instance {
	return Curve.Instance(class(self).GetParamCurve(3))
}

func (self Instance) SetLinearAccelCurve(value Curve.Instance) {
	class(self).SetParamCurve(3, value)
}

func (self Instance) RadialAccelMin() Float.X {
	return Float.X(Float.X(class(self).GetParamMin(4)))
}

func (self Instance) SetRadialAccelMin(value Float.X) {
	class(self).SetParamMin(4, float64(value))
}

func (self Instance) RadialAccelMax() Float.X {
	return Float.X(Float.X(class(self).GetParamMax(4)))
}

func (self Instance) SetRadialAccelMax(value Float.X) {
	class(self).SetParamMax(4, float64(value))
}

func (self Instance) RadialAccelCurve() Curve.Instance {
	return Curve.Instance(class(self).GetParamCurve(4))
}

func (self Instance) SetRadialAccelCurve(value Curve.Instance) {
	class(self).SetParamCurve(4, value)
}

func (self Instance) TangentialAccelMin() Float.X {
	return Float.X(Float.X(class(self).GetParamMin(5)))
}

func (self Instance) SetTangentialAccelMin(value Float.X) {
	class(self).SetParamMin(5, float64(value))
}

func (self Instance) TangentialAccelMax() Float.X {
	return Float.X(Float.X(class(self).GetParamMax(5)))
}

func (self Instance) SetTangentialAccelMax(value Float.X) {
	class(self).SetParamMax(5, float64(value))
}

func (self Instance) TangentialAccelCurve() Curve.Instance {
	return Curve.Instance(class(self).GetParamCurve(5))
}

func (self Instance) SetTangentialAccelCurve(value Curve.Instance) {
	class(self).SetParamCurve(5, value)
}

func (self Instance) DampingMin() Float.X {
	return Float.X(Float.X(class(self).GetParamMin(6)))
}

func (self Instance) SetDampingMin(value Float.X) {
	class(self).SetParamMin(6, float64(value))
}

func (self Instance) DampingMax() Float.X {
	return Float.X(Float.X(class(self).GetParamMax(6)))
}

func (self Instance) SetDampingMax(value Float.X) {
	class(self).SetParamMax(6, float64(value))
}

func (self Instance) DampingCurve() Curve.Instance {
	return Curve.Instance(class(self).GetParamCurve(6))
}

func (self Instance) SetDampingCurve(value Curve.Instance) {
	class(self).SetParamCurve(6, value)
}

func (self Instance) AngleMin() Float.X {
	return Float.X(Float.X(class(self).GetParamMin(7)))
}

func (self Instance) SetAngleMin(value Float.X) {
	class(self).SetParamMin(7, float64(value))
}

func (self Instance) AngleMax() Float.X {
	return Float.X(Float.X(class(self).GetParamMax(7)))
}

func (self Instance) SetAngleMax(value Float.X) {
	class(self).SetParamMax(7, float64(value))
}

func (self Instance) AngleCurve() Curve.Instance {
	return Curve.Instance(class(self).GetParamCurve(7))
}

func (self Instance) SetAngleCurve(value Curve.Instance) {
	class(self).SetParamCurve(7, value)
}

func (self Instance) ScaleAmountMin() Float.X {
	return Float.X(Float.X(class(self).GetParamMin(8)))
}

func (self Instance) SetScaleAmountMin(value Float.X) {
	class(self).SetParamMin(8, float64(value))
}

func (self Instance) ScaleAmountMax() Float.X {
	return Float.X(Float.X(class(self).GetParamMax(8)))
}

func (self Instance) SetScaleAmountMax(value Float.X) {
	class(self).SetParamMax(8, float64(value))
}

func (self Instance) ScaleAmountCurve() Curve.Instance {
	return Curve.Instance(class(self).GetParamCurve(8))
}

func (self Instance) SetScaleAmountCurve(value Curve.Instance) {
	class(self).SetParamCurve(8, value)
}

func (self Instance) SplitScale() bool {
	return bool(class(self).GetSplitScale())
}

func (self Instance) SetSplitScale(value bool) {
	class(self).SetSplitScale(value)
}

func (self Instance) ScaleCurveX() Curve.Instance {
	return Curve.Instance(class(self).GetScaleCurveX())
}

func (self Instance) SetScaleCurveX(value Curve.Instance) {
	class(self).SetScaleCurveX(value)
}

func (self Instance) ScaleCurveY() Curve.Instance {
	return Curve.Instance(class(self).GetScaleCurveY())
}

func (self Instance) SetScaleCurveY(value Curve.Instance) {
	class(self).SetScaleCurveY(value)
}

func (self Instance) Color() Color.RGBA {
	return Color.RGBA(class(self).GetColor())
}

func (self Instance) SetColor(value Color.RGBA) {
	class(self).SetColor(Color.RGBA(value))
}

func (self Instance) ColorRamp() Gradient.Instance {
	return Gradient.Instance(class(self).GetColorRamp())
}

func (self Instance) SetColorRamp(value Gradient.Instance) {
	class(self).SetColorRamp(value)
}

func (self Instance) ColorInitialRamp() Gradient.Instance {
	return Gradient.Instance(class(self).GetColorInitialRamp())
}

func (self Instance) SetColorInitialRamp(value Gradient.Instance) {
	class(self).SetColorInitialRamp(value)
}

func (self Instance) HueVariationMin() Float.X {
	return Float.X(Float.X(class(self).GetParamMin(9)))
}

func (self Instance) SetHueVariationMin(value Float.X) {
	class(self).SetParamMin(9, float64(value))
}

func (self Instance) HueVariationMax() Float.X {
	return Float.X(Float.X(class(self).GetParamMax(9)))
}

func (self Instance) SetHueVariationMax(value Float.X) {
	class(self).SetParamMax(9, float64(value))
}

func (self Instance) HueVariationCurve() Curve.Instance {
	return Curve.Instance(class(self).GetParamCurve(9))
}

func (self Instance) SetHueVariationCurve(value Curve.Instance) {
	class(self).SetParamCurve(9, value)
}

func (self Instance) AnimSpeedMin() Float.X {
	return Float.X(Float.X(class(self).GetParamMin(10)))
}

func (self Instance) SetAnimSpeedMin(value Float.X) {
	class(self).SetParamMin(10, float64(value))
}

func (self Instance) AnimSpeedMax() Float.X {
	return Float.X(Float.X(class(self).GetParamMax(10)))
}

func (self Instance) SetAnimSpeedMax(value Float.X) {
	class(self).SetParamMax(10, float64(value))
}

func (self Instance) AnimSpeedCurve() Curve.Instance {
	return Curve.Instance(class(self).GetParamCurve(10))
}

func (self Instance) SetAnimSpeedCurve(value Curve.Instance) {
	class(self).SetParamCurve(10, value)
}

func (self Instance) AnimOffsetMin() Float.X {
	return Float.X(Float.X(class(self).GetParamMin(11)))
}

func (self Instance) SetAnimOffsetMin(value Float.X) {
	class(self).SetParamMin(11, float64(value))
}

func (self Instance) AnimOffsetMax() Float.X {
	return Float.X(Float.X(class(self).GetParamMax(11)))
}

func (self Instance) SetAnimOffsetMax(value Float.X) {
	class(self).SetParamMax(11, float64(value))
}

func (self Instance) AnimOffsetCurve() Curve.Instance {
	return Curve.Instance(class(self).GetParamCurve(11))
}

func (self Instance) SetAnimOffsetCurve(value Curve.Instance) {
	class(self).SetParamCurve(11, value)
}

//go:nosplit
func (self class) SetEmitting(emitting bool) { //gd:CPUParticles2D.set_emitting
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_set_emitting), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ emitting bool }{emitting}))
}

//go:nosplit
func (self class) SetAmount(amount int64) { //gd:CPUParticles2D.set_amount
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_set_amount), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ amount int64 }{amount}))
}

//go:nosplit
func (self class) SetLifetime(secs float64) { //gd:CPUParticles2D.set_lifetime
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_set_lifetime), 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ secs float64 }{secs}))
}

//go:nosplit
func (self class) SetOneShot(enable bool) { //gd:CPUParticles2D.set_one_shot
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_set_one_shot), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

//go:nosplit
func (self class) SetPreProcessTime(secs float64) { //gd:CPUParticles2D.set_pre_process_time
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_set_pre_process_time), 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ secs float64 }{secs}))
}

//go:nosplit
func (self class) SetExplosivenessRatio(ratio float64) { //gd:CPUParticles2D.set_explosiveness_ratio
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_set_explosiveness_ratio), 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ ratio float64 }{ratio}))
}

//go:nosplit
func (self class) SetRandomnessRatio(ratio float64) { //gd:CPUParticles2D.set_randomness_ratio
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_set_randomness_ratio), 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ ratio float64 }{ratio}))
}

//go:nosplit
func (self class) SetLifetimeRandomness(random float64) { //gd:CPUParticles2D.set_lifetime_randomness
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_set_lifetime_randomness), 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ random float64 }{random}))
}

//go:nosplit
func (self class) SetUseLocalCoordinates(enable bool) { //gd:CPUParticles2D.set_use_local_coordinates
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_set_use_local_coordinates), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

//go:nosplit
func (self class) SetFixedFps(fps int64) { //gd:CPUParticles2D.set_fixed_fps
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_set_fixed_fps), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ fps int64 }{fps}))
}

//go:nosplit
func (self class) SetFractionalDelta(enable bool) { //gd:CPUParticles2D.set_fractional_delta
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_set_fractional_delta), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

//go:nosplit
func (self class) SetSpeedScale(scale float64) { //gd:CPUParticles2D.set_speed_scale
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_set_speed_scale), 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ scale float64 }{scale}))
}

/*
Requests the particles to process for extra process time during a single frame.
Useful for particle playback, if used in combination with [member use_fixed_seed] or by calling [method restart] with parameter [code]keep_seed[/code] set to [code]true[/code].
*/
//go:nosplit
func (self class) RequestParticlesProcess(process_time float64) { //gd:CPUParticles2D.request_particles_process
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_request_particles_process), 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ process_time float64 }{process_time}))
}

//go:nosplit
func (self class) IsEmitting() bool { //gd:CPUParticles2D.is_emitting
	var r_ret = gdextension.Call[bool](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_is_emitting), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) GetAmount() int64 { //gd:CPUParticles2D.get_amount
	var r_ret = gdextension.Call[int64](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_get_amount), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) GetLifetime() float64 { //gd:CPUParticles2D.get_lifetime
	var r_ret = gdextension.Call[float64](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_get_lifetime), gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) GetOneShot() bool { //gd:CPUParticles2D.get_one_shot
	var r_ret = gdextension.Call[bool](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_get_one_shot), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) GetPreProcessTime() float64 { //gd:CPUParticles2D.get_pre_process_time
	var r_ret = gdextension.Call[float64](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_get_pre_process_time), gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) GetExplosivenessRatio() float64 { //gd:CPUParticles2D.get_explosiveness_ratio
	var r_ret = gdextension.Call[float64](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_get_explosiveness_ratio), gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) GetRandomnessRatio() float64 { //gd:CPUParticles2D.get_randomness_ratio
	var r_ret = gdextension.Call[float64](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_get_randomness_ratio), gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) GetLifetimeRandomness() float64 { //gd:CPUParticles2D.get_lifetime_randomness
	var r_ret = gdextension.Call[float64](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_get_lifetime_randomness), gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) GetUseLocalCoordinates() bool { //gd:CPUParticles2D.get_use_local_coordinates
	var r_ret = gdextension.Call[bool](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_get_use_local_coordinates), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) GetFixedFps() int64 { //gd:CPUParticles2D.get_fixed_fps
	var r_ret = gdextension.Call[int64](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_get_fixed_fps), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) GetFractionalDelta() bool { //gd:CPUParticles2D.get_fractional_delta
	var r_ret = gdextension.Call[bool](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_get_fractional_delta), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) GetSpeedScale() float64 { //gd:CPUParticles2D.get_speed_scale
	var r_ret = gdextension.Call[float64](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_get_speed_scale), gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetUseFixedSeed(use_fixed_seed bool) { //gd:CPUParticles2D.set_use_fixed_seed
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_set_use_fixed_seed), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ use_fixed_seed bool }{use_fixed_seed}))
}

//go:nosplit
func (self class) GetUseFixedSeed() bool { //gd:CPUParticles2D.get_use_fixed_seed
	var r_ret = gdextension.Call[bool](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_get_use_fixed_seed), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetSeed(seed int64) { //gd:CPUParticles2D.set_seed
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_set_seed), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ seed int64 }{seed}))
}

//go:nosplit
func (self class) GetSeed() int64 { //gd:CPUParticles2D.get_seed
	var r_ret = gdextension.Call[int64](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_get_seed), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetDrawOrder(order DrawOrder) { //gd:CPUParticles2D.set_draw_order
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_set_draw_order), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ order DrawOrder }{order}))
}

//go:nosplit
func (self class) GetDrawOrder() DrawOrder { //gd:CPUParticles2D.get_draw_order
	var r_ret = gdextension.Call[DrawOrder](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_get_draw_order), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetTexture(texture [1]gdclass.Texture2D) { //gd:CPUParticles2D.set_texture
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_set_texture), 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ texture gdextension.Object }{gdextension.Object(gd.ObjectChecked(texture[0].AsObject()))}))
}

//go:nosplit
func (self class) GetTexture() [1]gdclass.Texture2D { //gd:CPUParticles2D.get_texture
	var r_ret = gdextension.Call[gd.EnginePointer](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_get_texture), gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.Texture2D{gd.PointerWithOwnershipTransferredToGo[gdclass.Texture2D](r_ret)}
	return ret
}

/*
Restarts the particle emitter.
If [param keep_seed] is [code]true[/code], the current random seed will be preserved. Useful for seeking and playback.
*/
//go:nosplit
func (self class) Restart(keep_seed bool) { //gd:CPUParticles2D.restart
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_restart), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ keep_seed bool }{keep_seed}))
}

//go:nosplit
func (self class) SetDirection(direction Vector2.XY) { //gd:CPUParticles2D.set_direction
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_set_direction), 0|(gdextension.SizeVector2<<4), unsafe.Pointer(&struct{ direction Vector2.XY }{direction}))
}

//go:nosplit
func (self class) GetDirection() Vector2.XY { //gd:CPUParticles2D.get_direction
	var r_ret = gdextension.Call[Vector2.XY](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_get_direction), gdextension.SizeVector2, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetSpread(spread float64) { //gd:CPUParticles2D.set_spread
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_set_spread), 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ spread float64 }{spread}))
}

//go:nosplit
func (self class) GetSpread() float64 { //gd:CPUParticles2D.get_spread
	var r_ret = gdextension.Call[float64](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_get_spread), gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Sets the minimum value for the given parameter.
*/
//go:nosplit
func (self class) SetParamMin(param Parameter, value float64) { //gd:CPUParticles2D.set_param_min
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_set_param_min), 0|(gdextension.SizeInt<<4)|(gdextension.SizeFloat<<8), unsafe.Pointer(&struct {
		param Parameter
		value float64
	}{param, value}))
}

/*
Returns the minimum value range for the given parameter.
*/
//go:nosplit
func (self class) GetParamMin(param Parameter) float64 { //gd:CPUParticles2D.get_param_min
	var r_ret = gdextension.Call[float64](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_get_param_min), gdextension.SizeFloat|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ param Parameter }{param}))
	var ret = r_ret
	return ret
}

/*
Sets the maximum value for the given parameter.
*/
//go:nosplit
func (self class) SetParamMax(param Parameter, value float64) { //gd:CPUParticles2D.set_param_max
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_set_param_max), 0|(gdextension.SizeInt<<4)|(gdextension.SizeFloat<<8), unsafe.Pointer(&struct {
		param Parameter
		value float64
	}{param, value}))
}

/*
Returns the maximum value range for the given parameter.
*/
//go:nosplit
func (self class) GetParamMax(param Parameter) float64 { //gd:CPUParticles2D.get_param_max
	var r_ret = gdextension.Call[float64](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_get_param_max), gdextension.SizeFloat|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ param Parameter }{param}))
	var ret = r_ret
	return ret
}

/*
Sets the [Curve] of the parameter specified by [enum Parameter]. Should be a unit [Curve].
*/
//go:nosplit
func (self class) SetParamCurve(param Parameter, curve [1]gdclass.Curve) { //gd:CPUParticles2D.set_param_curve
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_set_param_curve), 0|(gdextension.SizeInt<<4)|(gdextension.SizeObject<<8), unsafe.Pointer(&struct {
		param Parameter
		curve gdextension.Object
	}{param, gdextension.Object(gd.ObjectChecked(curve[0].AsObject()))}))
}

/*
Returns the [Curve] of the parameter specified by [enum Parameter].
*/
//go:nosplit
func (self class) GetParamCurve(param Parameter) [1]gdclass.Curve { //gd:CPUParticles2D.get_param_curve
	var r_ret = gdextension.Call[gd.EnginePointer](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_get_param_curve), gdextension.SizeObject|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ param Parameter }{param}))
	var ret = [1]gdclass.Curve{gd.PointerWithOwnershipTransferredToGo[gdclass.Curve](r_ret)}
	return ret
}

//go:nosplit
func (self class) SetColor(color Color.RGBA) { //gd:CPUParticles2D.set_color
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_set_color), 0|(gdextension.SizeColor<<4), unsafe.Pointer(&struct{ color Color.RGBA }{color}))
}

//go:nosplit
func (self class) GetColor() Color.RGBA { //gd:CPUParticles2D.get_color
	var r_ret = gdextension.Call[Color.RGBA](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_get_color), gdextension.SizeColor, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetColorRamp(ramp [1]gdclass.Gradient) { //gd:CPUParticles2D.set_color_ramp
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_set_color_ramp), 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ ramp gdextension.Object }{gdextension.Object(gd.ObjectChecked(ramp[0].AsObject()))}))
}

//go:nosplit
func (self class) GetColorRamp() [1]gdclass.Gradient { //gd:CPUParticles2D.get_color_ramp
	var r_ret = gdextension.Call[gd.EnginePointer](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_get_color_ramp), gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.Gradient{gd.PointerWithOwnershipTransferredToGo[gdclass.Gradient](r_ret)}
	return ret
}

//go:nosplit
func (self class) SetColorInitialRamp(ramp [1]gdclass.Gradient) { //gd:CPUParticles2D.set_color_initial_ramp
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_set_color_initial_ramp), 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ ramp gdextension.Object }{gdextension.Object(gd.ObjectChecked(ramp[0].AsObject()))}))
}

//go:nosplit
func (self class) GetColorInitialRamp() [1]gdclass.Gradient { //gd:CPUParticles2D.get_color_initial_ramp
	var r_ret = gdextension.Call[gd.EnginePointer](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_get_color_initial_ramp), gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.Gradient{gd.PointerWithOwnershipTransferredToGo[gdclass.Gradient](r_ret)}
	return ret
}

/*
Enables or disables the given flag (see [enum ParticleFlags] for options).
*/
//go:nosplit
func (self class) SetParticleFlag(particle_flag ParticleFlags, enable bool) { //gd:CPUParticles2D.set_particle_flag
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_set_particle_flag), 0|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		particle_flag ParticleFlags
		enable        bool
	}{particle_flag, enable}))
}

/*
Returns the enabled state of the given particle flag (see [enum ParticleFlags] for options).
*/
//go:nosplit
func (self class) GetParticleFlag(particle_flag ParticleFlags) bool { //gd:CPUParticles2D.get_particle_flag
	var r_ret = gdextension.Call[bool](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_get_particle_flag), gdextension.SizeBool|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ particle_flag ParticleFlags }{particle_flag}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetEmissionShape(shape EmissionShape) { //gd:CPUParticles2D.set_emission_shape
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_set_emission_shape), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ shape EmissionShape }{shape}))
}

//go:nosplit
func (self class) GetEmissionShape() EmissionShape { //gd:CPUParticles2D.get_emission_shape
	var r_ret = gdextension.Call[EmissionShape](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_get_emission_shape), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetEmissionSphereRadius(radius float64) { //gd:CPUParticles2D.set_emission_sphere_radius
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_set_emission_sphere_radius), 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ radius float64 }{radius}))
}

//go:nosplit
func (self class) GetEmissionSphereRadius() float64 { //gd:CPUParticles2D.get_emission_sphere_radius
	var r_ret = gdextension.Call[float64](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_get_emission_sphere_radius), gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetEmissionRectExtents(extents Vector2.XY) { //gd:CPUParticles2D.set_emission_rect_extents
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_set_emission_rect_extents), 0|(gdextension.SizeVector2<<4), unsafe.Pointer(&struct{ extents Vector2.XY }{extents}))
}

//go:nosplit
func (self class) GetEmissionRectExtents() Vector2.XY { //gd:CPUParticles2D.get_emission_rect_extents
	var r_ret = gdextension.Call[Vector2.XY](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_get_emission_rect_extents), gdextension.SizeVector2, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetEmissionPoints(array Packed.Array[Vector2.XY]) { //gd:CPUParticles2D.set_emission_points
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_set_emission_points), 0|(gdextension.SizePackedArray<<4), unsafe.Pointer(&struct{ array gdextension.PackedArray }{gdextension.ToPackedArray(pointers.Get(gd.InternalPacked[gd.PackedVector2Array, Vector2.XY](array)))}))
}

//go:nosplit
func (self class) GetEmissionPoints() Packed.Array[Vector2.XY] { //gd:CPUParticles2D.get_emission_points
	var r_ret = gdextension.Call[gd.PackedPointers](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_get_emission_points), gdextension.SizePackedArray, unsafe.Pointer(&struct{}{}))
	var ret = Packed.Array[Vector2.XY](Array.Through(gd.PackedProxy[gd.PackedVector2Array, Vector2.XY]{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

//go:nosplit
func (self class) SetEmissionNormals(array Packed.Array[Vector2.XY]) { //gd:CPUParticles2D.set_emission_normals
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_set_emission_normals), 0|(gdextension.SizePackedArray<<4), unsafe.Pointer(&struct{ array gdextension.PackedArray }{gdextension.ToPackedArray(pointers.Get(gd.InternalPacked[gd.PackedVector2Array, Vector2.XY](array)))}))
}

//go:nosplit
func (self class) GetEmissionNormals() Packed.Array[Vector2.XY] { //gd:CPUParticles2D.get_emission_normals
	var r_ret = gdextension.Call[gd.PackedPointers](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_get_emission_normals), gdextension.SizePackedArray, unsafe.Pointer(&struct{}{}))
	var ret = Packed.Array[Vector2.XY](Array.Through(gd.PackedProxy[gd.PackedVector2Array, Vector2.XY]{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

//go:nosplit
func (self class) SetEmissionColors(array Packed.Array[Color.RGBA]) { //gd:CPUParticles2D.set_emission_colors
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_set_emission_colors), 0|(gdextension.SizePackedArray<<4), unsafe.Pointer(&struct{ array gdextension.PackedArray }{gdextension.ToPackedArray(pointers.Get(gd.InternalPacked[gd.PackedColorArray, Color.RGBA](array)))}))
}

//go:nosplit
func (self class) GetEmissionColors() Packed.Array[Color.RGBA] { //gd:CPUParticles2D.get_emission_colors
	var r_ret = gdextension.Call[gd.PackedPointers](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_get_emission_colors), gdextension.SizePackedArray, unsafe.Pointer(&struct{}{}))
	var ret = Packed.Array[Color.RGBA](Array.Through(gd.PackedProxy[gd.PackedColorArray, Color.RGBA]{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

//go:nosplit
func (self class) GetGravity() Vector2.XY { //gd:CPUParticles2D.get_gravity
	var r_ret = gdextension.Call[Vector2.XY](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_get_gravity), gdextension.SizeVector2, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetGravity(accel_vec Vector2.XY) { //gd:CPUParticles2D.set_gravity
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_set_gravity), 0|(gdextension.SizeVector2<<4), unsafe.Pointer(&struct{ accel_vec Vector2.XY }{accel_vec}))
}

//go:nosplit
func (self class) GetSplitScale() bool { //gd:CPUParticles2D.get_split_scale
	var r_ret = gdextension.Call[bool](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_get_split_scale), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetSplitScale(split_scale bool) { //gd:CPUParticles2D.set_split_scale
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_set_split_scale), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ split_scale bool }{split_scale}))
}

//go:nosplit
func (self class) GetScaleCurveX() [1]gdclass.Curve { //gd:CPUParticles2D.get_scale_curve_x
	var r_ret = gdextension.Call[gd.EnginePointer](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_get_scale_curve_x), gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.Curve{gd.PointerWithOwnershipTransferredToGo[gdclass.Curve](r_ret)}
	return ret
}

//go:nosplit
func (self class) SetScaleCurveX(scale_curve [1]gdclass.Curve) { //gd:CPUParticles2D.set_scale_curve_x
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_set_scale_curve_x), 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ scale_curve gdextension.Object }{gdextension.Object(gd.ObjectChecked(scale_curve[0].AsObject()))}))
}

//go:nosplit
func (self class) GetScaleCurveY() [1]gdclass.Curve { //gd:CPUParticles2D.get_scale_curve_y
	var r_ret = gdextension.Call[gd.EnginePointer](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_get_scale_curve_y), gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.Curve{gd.PointerWithOwnershipTransferredToGo[gdclass.Curve](r_ret)}
	return ret
}

//go:nosplit
func (self class) SetScaleCurveY(scale_curve [1]gdclass.Curve) { //gd:CPUParticles2D.set_scale_curve_y
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_set_scale_curve_y), 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ scale_curve gdextension.Object }{gdextension.Object(gd.ObjectChecked(scale_curve[0].AsObject()))}))
}

/*
Sets this node's properties to match a given [GPUParticles2D] node with an assigned [ParticleProcessMaterial].
*/
//go:nosplit
func (self class) ConvertFromParticles(particles [1]gdclass.Node) { //gd:CPUParticles2D.convert_from_particles
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.CPUParticles2D.Bind_convert_from_particles), 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ particles gdextension.Object }{gdextension.Object(gd.ObjectChecked(particles[0].AsObject()))}))
}
func (self Instance) OnFinished(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("finished"), gd.NewCallable(cb), 0)
}

func (self class) AsCPUParticles2D() Advanced         { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsCPUParticles2D() Instance      { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsCPUParticles2D() Instance { return self.Super().AsCPUParticles2D() }
func (self class) AsNode2D() Node2D.Advanced          { return *((*Node2D.Advanced)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsNode2D() Node2D.Instance  { return self.Super().AsNode2D() }
func (self Instance) AsNode2D() Node2D.Instance       { return *((*Node2D.Instance)(unsafe.Pointer(&self))) }
func (self class) AsCanvasItem() CanvasItem.Advanced {
	return *((*CanvasItem.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsCanvasItem() CanvasItem.Instance { return self.Super().AsCanvasItem() }
func (self Instance) AsCanvasItem() CanvasItem.Instance {
	return *((*CanvasItem.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsNode() Node.Advanced         { return *((*Node.Advanced)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsNode() Node.Instance { return self.Super().AsNode() }
func (self Instance) AsNode() Node.Instance      { return *((*Node.Instance)(unsafe.Pointer(&self))) }

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Node2D.Advanced(self.AsNode2D()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Node2D.Instance(self.AsNode2D()), name)
	}
}
func init() {
	gdclass.Register("CPUParticles2D", func(ptr gd.Object) any {
		return [1]gdclass.CPUParticles2D{*(*gdclass.CPUParticles2D)(unsafe.Pointer(&ptr))}
	})
}

type DrawOrder int //gd:CPUParticles2D.DrawOrder

const (
	/*Particles are drawn in the order emitted.*/
	DrawOrderIndex DrawOrder = 0
	/*Particles are drawn in order of remaining lifetime. In other words, the particle with the highest lifetime is drawn at the front.*/
	DrawOrderLifetime DrawOrder = 1
)

type Parameter int //gd:CPUParticles2D.Parameter

const (
	/*Use with [method set_param_min], [method set_param_max], and [method set_param_curve] to set initial velocity properties.*/
	ParamInitialLinearVelocity Parameter = 0
	/*Use with [method set_param_min], [method set_param_max], and [method set_param_curve] to set angular velocity properties.*/
	ParamAngularVelocity Parameter = 1
	/*Use with [method set_param_min], [method set_param_max], and [method set_param_curve] to set orbital velocity properties.*/
	ParamOrbitVelocity Parameter = 2
	/*Use with [method set_param_min], [method set_param_max], and [method set_param_curve] to set linear acceleration properties.*/
	ParamLinearAccel Parameter = 3
	/*Use with [method set_param_min], [method set_param_max], and [method set_param_curve] to set radial acceleration properties.*/
	ParamRadialAccel Parameter = 4
	/*Use with [method set_param_min], [method set_param_max], and [method set_param_curve] to set tangential acceleration properties.*/
	ParamTangentialAccel Parameter = 5
	/*Use with [method set_param_min], [method set_param_max], and [method set_param_curve] to set damping properties.*/
	ParamDamping Parameter = 6
	/*Use with [method set_param_min], [method set_param_max], and [method set_param_curve] to set angle properties.*/
	ParamAngle Parameter = 7
	/*Use with [method set_param_min], [method set_param_max], and [method set_param_curve] to set scale properties.*/
	ParamScale Parameter = 8
	/*Use with [method set_param_min], [method set_param_max], and [method set_param_curve] to set hue variation properties.*/
	ParamHueVariation Parameter = 9
	/*Use with [method set_param_min], [method set_param_max], and [method set_param_curve] to set animation speed properties.*/
	ParamAnimSpeed Parameter = 10
	/*Use with [method set_param_min], [method set_param_max], and [method set_param_curve] to set animation offset properties.*/
	ParamAnimOffset Parameter = 11
	/*Represents the size of the [enum Parameter] enum.*/
	ParamMax Parameter = 12
)

type ParticleFlags int //gd:CPUParticles2D.ParticleFlags

const (
	/*Use with [method set_particle_flag] to set [member particle_flag_align_y].*/
	ParticleFlagAlignYToVelocity ParticleFlags = 0
	/*Present for consistency with 3D particle nodes, not used in 2D.*/
	ParticleFlagRotateY ParticleFlags = 1
	/*Present for consistency with 3D particle nodes, not used in 2D.*/
	ParticleFlagDisableZ ParticleFlags = 2
	/*Represents the size of the [enum ParticleFlags] enum.*/
	ParticleFlagMax ParticleFlags = 3
)

type EmissionShape int //gd:CPUParticles2D.EmissionShape

const (
	/*All particles will be emitted from a single point.*/
	EmissionShapePoint EmissionShape = 0
	/*Particles will be emitted in the volume of a sphere flattened to two dimensions.*/
	EmissionShapeSphere EmissionShape = 1
	/*Particles will be emitted on the surface of a sphere flattened to two dimensions.*/
	EmissionShapeSphereSurface EmissionShape = 2
	/*Particles will be emitted in the area of a rectangle.*/
	EmissionShapeRectangle EmissionShape = 3
	/*Particles will be emitted at a position chosen randomly among [member emission_points]. Particle color will be modulated by [member emission_colors].*/
	EmissionShapePoints EmissionShape = 4
	/*Particles will be emitted at a position chosen randomly among [member emission_points]. Particle velocity and rotation will be set based on [member emission_normals]. Particle color will be modulated by [member emission_colors].*/
	EmissionShapeDirectedPoints EmissionShape = 5
	/*Represents the size of the [enum EmissionShape] enum.*/
	EmissionShapeMax EmissionShape = 6
)
