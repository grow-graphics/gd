// Code generated by the generate package DO NOT EDIT

// Package TextServerManager provides methods for working with TextServerManager object instances.
package TextServerManager

import "sync"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/variant/Signal"
import "graphics.gd/classdb/TextServer"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Signal.Any
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
[TextServerManager] is the API backend for loading, enumerating, and switching [TextServer]s.
[b]Note:[/b] Switching text server at runtime is possible, but will invalidate all fonts and text buffers. Make sure to unload all controls, fonts, and themes before doing so.
*/
type Instance [1]gdclass.TextServerManager

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	add_interface         gdextension.MethodForClass `hash:"1799689403"`
	get_interface_count   gdextension.MethodForClass `hash:"3905245786"`
	remove_interface      gdextension.MethodForClass `hash:"1799689403"`
	get_interface         gdextension.MethodForClass `hash:"1672475555"`
	get_interfaces        gdextension.MethodForClass `hash:"3995934104"`
	find_interface        gdextension.MethodForClass `hash:"2240905781"`
	set_primary_interface gdextension.MethodForClass `hash:"1799689403"`
	get_primary_interface gdextension.MethodForClass `hash:"905850878"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("TextServerManager")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		gdextension.Free(gdextension.TypeStringName, &sname)
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

var self [1]gdclass.TextServerManager
var once sync.Once

func singleton() {
	self[0] = pointers.Raw[gdclass.TextServerManager]([3]uint64{uint64(gdextension.Host.Objects.Global(sname))})
}

/*
Registers a [TextServer] interface.
*/
func AddInterface(intf TextServer.Instance) { //gd:TextServerManager.add_interface
	once.Do(singleton)
	Advanced().AddInterface(intf)
}

/*
Returns the number of interfaces currently registered.
*/
func GetInterfaceCount() int { //gd:TextServerManager.get_interface_count
	once.Do(singleton)
	return int(int(Advanced().GetInterfaceCount()))
}

/*
Removes an interface. All fonts and shaped text caches should be freed before removing an interface.
*/
func RemoveInterface(intf TextServer.Instance) { //gd:TextServerManager.remove_interface
	once.Do(singleton)
	Advanced().RemoveInterface(intf)
}

/*
Returns the interface registered at a given index.
*/
func GetInterface(idx int) TextServer.Instance { //gd:TextServerManager.get_interface
	once.Do(singleton)
	return TextServer.Instance(Advanced().GetInterface(int64(idx)))
}

/*
Returns a list of available interfaces, with the index and name of each interface.
*/
func GetInterfaces() []map[int]string { //gd:TextServerManager.get_interfaces
	once.Do(singleton)
	return []map[int]string(gd.ArrayAs[[]map[int]string](gd.InternalArray(Advanced().GetInterfaces())))
}

/*
Finds an interface by its [param name].
*/
func FindInterface(name string) TextServer.Instance { //gd:TextServerManager.find_interface
	once.Do(singleton)
	return TextServer.Instance(Advanced().FindInterface(String.New(name)))
}

/*
Sets the primary [TextServer] interface.
*/
func SetPrimaryInterface(index TextServer.Instance) { //gd:TextServerManager.set_primary_interface
	once.Do(singleton)
	Advanced().SetPrimaryInterface(index)
}

/*
Returns the primary [TextServer] interface currently in use.
*/
func GetPrimaryInterface() TextServer.Instance { //gd:TextServerManager.get_primary_interface
	once.Do(singleton)
	return TextServer.Instance(Advanced().GetPrimaryInterface())
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
func Advanced() class { once.Do(singleton); return self }

type class [1]gdclass.TextServerManager

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = pointers.AsA[gdclass.TextServerManager](obj[0])
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = pointers.AsA[gdclass.TextServerManager](obj[0])
		return true
	}
	return false
}
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }
func (self *Extension[T]) AsObject() [1]gd.Object { return self.Super().AsObject() }

/*
Registers a [TextServer] interface.
*/
//go:nosplit
func (self class) AddInterface(intf [1]gdclass.TextServer) { //gd:TextServerManager.add_interface
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_interface, 0|(gdextension.SizeObject<<4), &struct{ intf gdextension.Object }{gdextension.Object(gd.ObjectChecked(intf[0].AsObject()))})
}

/*
Returns the number of interfaces currently registered.
*/
//go:nosplit
func (self class) GetInterfaceCount() int64 { //gd:TextServerManager.get_interface_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_interface_count, gdextension.SizeInt, &struct{}{})
	var ret = r_ret
	return ret
}

/*
Removes an interface. All fonts and shaped text caches should be freed before removing an interface.
*/
//go:nosplit
func (self class) RemoveInterface(intf [1]gdclass.TextServer) { //gd:TextServerManager.remove_interface
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.remove_interface, 0|(gdextension.SizeObject<<4), &struct{ intf gdextension.Object }{gdextension.Object(gd.ObjectChecked(intf[0].AsObject()))})
}

/*
Returns the interface registered at a given index.
*/
//go:nosplit
func (self class) GetInterface(idx int64) [1]gdclass.TextServer { //gd:TextServerManager.get_interface
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_interface, gdextension.SizeObject|(gdextension.SizeInt<<4), &struct{ idx int64 }{idx})
	var ret = [1]gdclass.TextServer{gd.PointerWithOwnershipTransferredToGo[gdclass.TextServer](r_ret)}
	return ret
}

/*
Returns a list of available interfaces, with the index and name of each interface.
*/
//go:nosplit
func (self class) GetInterfaces() Array.Contains[Dictionary.Any] { //gd:TextServerManager.get_interfaces
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), methods.get_interfaces, gdextension.SizeArray, &struct{}{})
	var ret = Array.Through(gd.ArrayProxy[Dictionary.Any]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

/*
Finds an interface by its [param name].
*/
//go:nosplit
func (self class) FindInterface(name String.Readable) [1]gdclass.TextServer { //gd:TextServerManager.find_interface
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.find_interface, gdextension.SizeObject|(gdextension.SizeString<<4), &struct{ name gdextension.String }{pointers.Get(gd.InternalString(name))})
	var ret = [1]gdclass.TextServer{gd.PointerWithOwnershipTransferredToGo[gdclass.TextServer](r_ret)}
	return ret
}

/*
Sets the primary [TextServer] interface.
*/
//go:nosplit
func (self class) SetPrimaryInterface(index [1]gdclass.TextServer) { //gd:TextServerManager.set_primary_interface
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_primary_interface, 0|(gdextension.SizeObject<<4), &struct{ index gdextension.Object }{gdextension.Object(gd.ObjectChecked(index[0].AsObject()))})
}

/*
Returns the primary [TextServer] interface currently in use.
*/
//go:nosplit
func (self class) GetPrimaryInterface() [1]gdclass.TextServer { //gd:TextServerManager.get_primary_interface
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_primary_interface, gdextension.SizeObject, &struct{}{})
	var ret = [1]gdclass.TextServer{gd.PointerWithOwnershipTransferredToGo[gdclass.TextServer](r_ret)}
	return ret
}
func OnInterfaceAdded(cb func(interface_name string), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("interface_added"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) InterfaceAdded() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`InterfaceAdded`))))
}

func OnInterfaceRemoved(cb func(interface_name string), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("interface_removed"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) InterfaceRemoved() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`InterfaceRemoved`))))
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Object.Advanced(self.AsObject()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Object.Instance(self.AsObject()), name)
	}
}
func init() {
	gdclass.Register("TextServerManager", func(ptr gd.Object) any { return Instance{pointers.AsA[gdclass.TextServerManager](ptr)} })
}
