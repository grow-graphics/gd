// Code generated by the generate package DO NOT EDIT

// Package PhysicsBody3D provides methods for working with PhysicsBody3D object instances.
package PhysicsBody3D

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/CollisionObject3D"
import "graphics.gd/classdb/KinematicCollision3D"
import "graphics.gd/classdb/Node"
import "graphics.gd/classdb/Node3D"
import "graphics.gd/classdb/PhysicsServer3D"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"
import "graphics.gd/variant/Transform3D"
import "graphics.gd/variant/Vector3"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
[PhysicsBody3D] is an abstract base class for 3D game objects affected by physics. All 3D physics bodies inherit from it.
[b]Warning:[/b] With a non-uniform scale, this node will likely not behave as expected. It is advised to keep its scale the same on all axes and adjust its collision shape(s) instead.
*/
type Instance [1]gdclass.PhysicsBody3D

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	move_and_collide                gdextension.MethodForClass `hash:"3208792678"`
	test_move                       gdextension.MethodForClass `hash:"2481691619"`
	get_gravity                     gdextension.MethodForClass `hash:"3360562783"`
	set_axis_lock                   gdextension.MethodForClass `hash:"1787895195"`
	get_axis_lock                   gdextension.MethodForClass `hash:"2264617709"`
	get_collision_exceptions        gdextension.MethodForClass `hash:"2915620761"`
	add_collision_exception_with    gdextension.MethodForClass `hash:"1078189570"`
	remove_collision_exception_with gdextension.MethodForClass `hash:"1078189570"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("PhysicsBody3D")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		pointers.Raw[gd.StringName](sname).Free()
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

type Expanded [1]gdclass.PhysicsBody3D

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsPhysicsBody3D() Instance
}

/*
Moves the body along the vector [param motion]. In order to be frame rate independent in [method Node._physics_process] or [method Node._process], [param motion] should be computed using [code]delta[/code].
The body will stop if it collides. Returns a [KinematicCollision3D], which contains information about the collision when stopped, or when touching another body along the motion.
If [param test_only] is [code]true[/code], the body does not move but the would-be collision information is given.
[param safe_margin] is the extra margin used for collision recovery (see [member CharacterBody3D.safe_margin] for more details).
If [param recovery_as_collision] is [code]true[/code], any depenetration from the recovery phase is also reported as a collision; this is used e.g. by [CharacterBody3D] for improving floor detection during floor snapping.
[param max_collisions] allows to retrieve more than one collision result.
*/
func (self Instance) MoveAndCollide(motion Vector3.XYZ) KinematicCollision3D.Instance { //gd:PhysicsBody3D.move_and_collide
	return KinematicCollision3D.Instance(Advanced(self).MoveAndCollide(Vector3.XYZ(motion), false, float64(0.001), false, int64(1)))
}

/*
Moves the body along the vector [param motion]. In order to be frame rate independent in [method Node._physics_process] or [method Node._process], [param motion] should be computed using [code]delta[/code].
The body will stop if it collides. Returns a [KinematicCollision3D], which contains information about the collision when stopped, or when touching another body along the motion.
If [param test_only] is [code]true[/code], the body does not move but the would-be collision information is given.
[param safe_margin] is the extra margin used for collision recovery (see [member CharacterBody3D.safe_margin] for more details).
If [param recovery_as_collision] is [code]true[/code], any depenetration from the recovery phase is also reported as a collision; this is used e.g. by [CharacterBody3D] for improving floor detection during floor snapping.
[param max_collisions] allows to retrieve more than one collision result.
*/
func (self Expanded) MoveAndCollide(motion Vector3.XYZ, test_only bool, safe_margin Float.X, recovery_as_collision bool, max_collisions int) KinematicCollision3D.Instance { //gd:PhysicsBody3D.move_and_collide
	return KinematicCollision3D.Instance(Advanced(self).MoveAndCollide(Vector3.XYZ(motion), test_only, float64(safe_margin), recovery_as_collision, int64(max_collisions)))
}

/*
Checks for collisions without moving the body. In order to be frame rate independent in [method Node._physics_process] or [method Node._process], [param motion] should be computed using [code]delta[/code].
Virtually sets the node's position, scale and rotation to that of the given [Transform3D], then tries to move the body along the vector [param motion]. Returns [code]true[/code] if a collision would stop the body from moving along the whole path.
[param collision] is an optional object of type [KinematicCollision3D], which contains additional information about the collision when stopped, or when touching another body along the motion.
[param safe_margin] is the extra margin used for collision recovery (see [member CharacterBody3D.safe_margin] for more details).
If [param recovery_as_collision] is [code]true[/code], any depenetration from the recovery phase is also reported as a collision; this is useful for checking whether the body would [i]touch[/i] any other bodies.
[param max_collisions] allows to retrieve more than one collision result.
*/
func (self Instance) TestMove(from Transform3D.BasisOrigin, motion Vector3.XYZ) bool { //gd:PhysicsBody3D.test_move
	return bool(Advanced(self).TestMove(Transform3D.BasisOrigin(from), Vector3.XYZ(motion), [1]KinematicCollision3D.Instance{}[0], float64(0.001), false, int64(1)))
}

/*
Checks for collisions without moving the body. In order to be frame rate independent in [method Node._physics_process] or [method Node._process], [param motion] should be computed using [code]delta[/code].
Virtually sets the node's position, scale and rotation to that of the given [Transform3D], then tries to move the body along the vector [param motion]. Returns [code]true[/code] if a collision would stop the body from moving along the whole path.
[param collision] is an optional object of type [KinematicCollision3D], which contains additional information about the collision when stopped, or when touching another body along the motion.
[param safe_margin] is the extra margin used for collision recovery (see [member CharacterBody3D.safe_margin] for more details).
If [param recovery_as_collision] is [code]true[/code], any depenetration from the recovery phase is also reported as a collision; this is useful for checking whether the body would [i]touch[/i] any other bodies.
[param max_collisions] allows to retrieve more than one collision result.
*/
func (self Expanded) TestMove(from Transform3D.BasisOrigin, motion Vector3.XYZ, collision KinematicCollision3D.Instance, safe_margin Float.X, recovery_as_collision bool, max_collisions int) bool { //gd:PhysicsBody3D.test_move
	return bool(Advanced(self).TestMove(Transform3D.BasisOrigin(from), Vector3.XYZ(motion), collision, float64(safe_margin), recovery_as_collision, int64(max_collisions)))
}

/*
Returns the gravity vector computed from all sources that can affect the body, including all gravity overrides from [Area3D] nodes and the global world gravity.
*/
func (self Instance) GetGravity() Vector3.XYZ { //gd:PhysicsBody3D.get_gravity
	return Vector3.XYZ(Advanced(self).GetGravity())
}

/*
Returns an array of nodes that were added as collision exceptions for this body.
*/
func (self Instance) GetCollisionExceptions() []Instance { //gd:PhysicsBody3D.get_collision_exceptions
	return []Instance(gd.ArrayAs[[]Instance](gd.InternalArray(Advanced(self).GetCollisionExceptions())))
}

/*
Adds a body to the list of bodies that this body can't collide with.
*/
func (self Instance) AddCollisionExceptionWith(body Node.Instance) { //gd:PhysicsBody3D.add_collision_exception_with
	Advanced(self).AddCollisionExceptionWith(body)
}

/*
Removes a body from the list of bodies that this body can't collide with.
*/
func (self Instance) RemoveCollisionExceptionWith(body Node.Instance) { //gd:PhysicsBody3D.remove_collision_exception_with
	Advanced(self).RemoveCollisionExceptionWith(body)
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.PhysicsBody3D

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.PhysicsBody3D)(unsafe.Pointer(&obj))
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.PhysicsBody3D)(unsafe.Pointer(&obj))
		return true
	}
	return false
}

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {

	if !gd.Linked {
		var placeholder Instance
		*(*gd.Object)(unsafe.Pointer(&placeholder)) = pointers.Add[gd.Object]([3]uint64{})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(*(*gd.Object)(unsafe.Pointer(&placeholder)), raw)
				gd.RegisterCleanup(func() {
					gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
				})
			}
		})
		return placeholder
	}
	object := [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})}
	casted := Instance{*(*gdclass.PhysicsBody3D)(unsafe.Pointer(&object))}
	object[0].Notification(0, false)
	return casted
}

func (self Instance) AxisLockLinearX() bool {
	return bool(class(self).GetAxisLock(1))
}

func (self Instance) SetAxisLockLinearX(value bool) {
	class(self).SetAxisLock(1, value)
}

func (self Instance) AxisLockLinearY() bool {
	return bool(class(self).GetAxisLock(2))
}

func (self Instance) SetAxisLockLinearY(value bool) {
	class(self).SetAxisLock(2, value)
}

func (self Instance) AxisLockLinearZ() bool {
	return bool(class(self).GetAxisLock(4))
}

func (self Instance) SetAxisLockLinearZ(value bool) {
	class(self).SetAxisLock(4, value)
}

func (self Instance) AxisLockAngularX() bool {
	return bool(class(self).GetAxisLock(8))
}

func (self Instance) SetAxisLockAngularX(value bool) {
	class(self).SetAxisLock(8, value)
}

func (self Instance) AxisLockAngularY() bool {
	return bool(class(self).GetAxisLock(16))
}

func (self Instance) SetAxisLockAngularY(value bool) {
	class(self).SetAxisLock(16, value)
}

func (self Instance) AxisLockAngularZ() bool {
	return bool(class(self).GetAxisLock(32))
}

func (self Instance) SetAxisLockAngularZ(value bool) {
	class(self).SetAxisLock(32, value)
}

/*
Moves the body along the vector [param motion]. In order to be frame rate independent in [method Node._physics_process] or [method Node._process], [param motion] should be computed using [code]delta[/code].
The body will stop if it collides. Returns a [KinematicCollision3D], which contains information about the collision when stopped, or when touching another body along the motion.
If [param test_only] is [code]true[/code], the body does not move but the would-be collision information is given.
[param safe_margin] is the extra margin used for collision recovery (see [member CharacterBody3D.safe_margin] for more details).
If [param recovery_as_collision] is [code]true[/code], any depenetration from the recovery phase is also reported as a collision; this is used e.g. by [CharacterBody3D] for improving floor detection during floor snapping.
[param max_collisions] allows to retrieve more than one collision result.
*/
//go:nosplit
func (self class) MoveAndCollide(motion Vector3.XYZ, test_only bool, safe_margin float64, recovery_as_collision bool, max_collisions int64) [1]gdclass.KinematicCollision3D { //gd:PhysicsBody3D.move_and_collide
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.move_and_collide, gdextension.SizeObject|(gdextension.SizeVector3<<4)|(gdextension.SizeBool<<8)|(gdextension.SizeFloat<<12)|(gdextension.SizeBool<<16)|(gdextension.SizeInt<<20), unsafe.Pointer(&struct {
		motion                Vector3.XYZ
		test_only             bool
		safe_margin           float64
		recovery_as_collision bool
		max_collisions        int64
	}{motion, test_only, safe_margin, recovery_as_collision, max_collisions}))
	var ret = [1]gdclass.KinematicCollision3D{gd.PointerWithOwnershipTransferredToGo[gdclass.KinematicCollision3D](r_ret)}
	return ret
}

/*
Checks for collisions without moving the body. In order to be frame rate independent in [method Node._physics_process] or [method Node._process], [param motion] should be computed using [code]delta[/code].
Virtually sets the node's position, scale and rotation to that of the given [Transform3D], then tries to move the body along the vector [param motion]. Returns [code]true[/code] if a collision would stop the body from moving along the whole path.
[param collision] is an optional object of type [KinematicCollision3D], which contains additional information about the collision when stopped, or when touching another body along the motion.
[param safe_margin] is the extra margin used for collision recovery (see [member CharacterBody3D.safe_margin] for more details).
If [param recovery_as_collision] is [code]true[/code], any depenetration from the recovery phase is also reported as a collision; this is useful for checking whether the body would [i]touch[/i] any other bodies.
[param max_collisions] allows to retrieve more than one collision result.
*/
//go:nosplit
func (self class) TestMove(from Transform3D.BasisOrigin, motion Vector3.XYZ, collision [1]gdclass.KinematicCollision3D, safe_margin float64, recovery_as_collision bool, max_collisions int64) bool { //gd:PhysicsBody3D.test_move
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.test_move, gdextension.SizeBool|(gdextension.SizeTransform3D<<4)|(gdextension.SizeVector3<<8)|(gdextension.SizeObject<<12)|(gdextension.SizeFloat<<16)|(gdextension.SizeBool<<20)|(gdextension.SizeInt<<24), unsafe.Pointer(&struct {
		from                  Transform3D.BasisOrigin
		motion                Vector3.XYZ
		collision             gdextension.Object
		safe_margin           float64
		recovery_as_collision bool
		max_collisions        int64
	}{gd.Transposed(from), motion, gdextension.Object(gd.ObjectChecked(collision[0].AsObject())), safe_margin, recovery_as_collision, max_collisions}))
	var ret = r_ret
	return ret
}

/*
Returns the gravity vector computed from all sources that can affect the body, including all gravity overrides from [Area3D] nodes and the global world gravity.
*/
//go:nosplit
func (self class) GetGravity() Vector3.XYZ { //gd:PhysicsBody3D.get_gravity
	var r_ret = gdextension.Call[Vector3.XYZ](gd.ObjectChecked(self.AsObject()), methods.get_gravity, gdextension.SizeVector3, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Locks or unlocks the specified linear or rotational [param axis] depending on the value of [param lock].
*/
//go:nosplit
func (self class) SetAxisLock(axis PhysicsServer3D.BodyAxis, lock bool) { //gd:PhysicsBody3D.set_axis_lock
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_axis_lock, 0|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		axis PhysicsServer3D.BodyAxis
		lock bool
	}{axis, lock}))
}

/*
Returns [code]true[/code] if the specified linear or rotational [param axis] is locked.
*/
//go:nosplit
func (self class) GetAxisLock(axis PhysicsServer3D.BodyAxis) bool { //gd:PhysicsBody3D.get_axis_lock
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.get_axis_lock, gdextension.SizeBool|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ axis PhysicsServer3D.BodyAxis }{axis}))
	var ret = r_ret
	return ret
}

/*
Returns an array of nodes that were added as collision exceptions for this body.
*/
//go:nosplit
func (self class) GetCollisionExceptions() Array.Contains[[1]gdclass.PhysicsBody3D] { //gd:PhysicsBody3D.get_collision_exceptions
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), methods.get_collision_exceptions, gdextension.SizeArray, unsafe.Pointer(&struct{}{}))
	var ret = Array.Through(gd.ArrayProxy[[1]gdclass.PhysicsBody3D]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

/*
Adds a body to the list of bodies that this body can't collide with.
*/
//go:nosplit
func (self class) AddCollisionExceptionWith(body [1]gdclass.Node) { //gd:PhysicsBody3D.add_collision_exception_with
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_collision_exception_with, 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ body gdextension.Object }{gdextension.Object(gd.ObjectChecked(body[0].AsObject()))}))
}

/*
Removes a body from the list of bodies that this body can't collide with.
*/
//go:nosplit
func (self class) RemoveCollisionExceptionWith(body [1]gdclass.Node) { //gd:PhysicsBody3D.remove_collision_exception_with
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.remove_collision_exception_with, 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ body gdextension.Object }{gdextension.Object(gd.ObjectChecked(body[0].AsObject()))}))
}
func (self class) AsPhysicsBody3D() Advanced         { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsPhysicsBody3D() Instance      { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsPhysicsBody3D() Instance { return self.Super().AsPhysicsBody3D() }
func (self class) AsCollisionObject3D() CollisionObject3D.Advanced {
	return *((*CollisionObject3D.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsCollisionObject3D() CollisionObject3D.Instance {
	return self.Super().AsCollisionObject3D()
}
func (self Instance) AsCollisionObject3D() CollisionObject3D.Instance {
	return *((*CollisionObject3D.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsNode3D() Node3D.Advanced         { return *((*Node3D.Advanced)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsNode3D() Node3D.Instance { return self.Super().AsNode3D() }
func (self Instance) AsNode3D() Node3D.Instance      { return *((*Node3D.Instance)(unsafe.Pointer(&self))) }
func (self class) AsNode() Node.Advanced             { return *((*Node.Advanced)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsNode() Node.Instance     { return self.Super().AsNode() }
func (self Instance) AsNode() Node.Instance          { return *((*Node.Instance)(unsafe.Pointer(&self))) }

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(CollisionObject3D.Advanced(self.AsCollisionObject3D()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(CollisionObject3D.Instance(self.AsCollisionObject3D()), name)
	}
}
func init() {
	gdclass.Register("PhysicsBody3D", func(ptr gd.Object) any { return *(*Instance)(unsafe.Pointer(&ptr)) })
}
