// Code generated by the generate package DO NOT EDIT

// Package SkeletonIK3D provides methods for working with SkeletonIK3D object instances.
package SkeletonIK3D

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/Node"
import "graphics.gd/classdb/Node3D"
import "graphics.gd/classdb/Skeleton3D"
import "graphics.gd/classdb/SkeletonModifier3D"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"
import "graphics.gd/variant/Transform3D"
import "graphics.gd/variant/Vector3"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
SkeletonIK3D is used to rotate all bones of a [Skeleton3D] bone chain a way that places the end bone at a desired 3D position. A typical scenario for IK in games is to place a character's feet on the ground or a character's hands on a currently held object. SkeletonIK uses FabrikInverseKinematic internally to solve the bone chain and applies the results to the [Skeleton3D] [code]bones_global_pose_override[/code] property for all affected bones in the chain. If fully applied, this overwrites any bone transform from [Animation]s or bone custom poses set by users. The applied amount can be controlled with the [member SkeletonModifier3D.influence] property.
[codeblock]
# Apply IK effect automatically on every new frame (not the current)
skeleton_ik_node.start()

# Apply IK effect only on the current frame
skeleton_ik_node.start(true)

# Stop IK effect and reset bones_global_pose_override on Skeleton
skeleton_ik_node.stop()

# Apply full IK effect
skeleton_ik_node.set_influence(1.0)

# Apply half IK effect
skeleton_ik_node.set_influence(0.5)

# Apply zero IK effect (a value at or below 0.01 also removes bones_global_pose_override on Skeleton)
skeleton_ik_node.set_influence(0.0)
[/codeblock]
*/
type Instance [1]gdclass.SkeletonIK3D

func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

type Expanded [1]gdclass.SkeletonIK3D

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsSkeletonIK3D() Instance
}

/*
Returns the parent [Skeleton3D] node that was present when SkeletonIK entered the scene tree. Returns [code]null[/code] if the parent node was not a [Skeleton3D] node when SkeletonIK3D entered the scene tree.
*/
func (self Instance) GetParentSkeleton() Skeleton3D.Instance { //gd:SkeletonIK3D.get_parent_skeleton
	return Skeleton3D.Instance(Advanced(self).GetParentSkeleton())
}

/*
Returns [code]true[/code] if SkeletonIK is applying IK effects on continues frames to the [Skeleton3D] bones. Returns [code]false[/code] if SkeletonIK is stopped or [method start] was used with the [code]one_time[/code] parameter set to [code]true[/code].
*/
func (self Instance) IsRunning() bool { //gd:SkeletonIK3D.is_running
	return bool(Advanced(self).IsRunning())
}

/*
Starts applying IK effects on each frame to the [Skeleton3D] bones but will only take effect starting on the next frame. If [param one_time] is [code]true[/code], this will take effect immediately but also reset on the next frame.
*/
func (self Instance) Start() { //gd:SkeletonIK3D.start
	Advanced(self).Start(false)
}

/*
Starts applying IK effects on each frame to the [Skeleton3D] bones but will only take effect starting on the next frame. If [param one_time] is [code]true[/code], this will take effect immediately but also reset on the next frame.
*/
func (self Expanded) Start(one_time bool) { //gd:SkeletonIK3D.start
	Advanced(self).Start(one_time)
}

/*
Stops applying IK effects on each frame to the [Skeleton3D] bones and also calls [method Skeleton3D.clear_bones_global_pose_override] to remove existing overrides on all bones.
*/
func (self Instance) Stop() { //gd:SkeletonIK3D.stop
	Advanced(self).Stop()
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.SkeletonIK3D

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {
	object := gd.Global.ClassDB.ConstructObject(gd.NewStringName("SkeletonIK3D"))
	casted := Instance{*(*gdclass.SkeletonIK3D)(unsafe.Pointer(&object))}
	return casted
}

func (self Instance) RootBone() string {
	return string(class(self).GetRootBone().String())
}

func (self Instance) SetRootBone(value string) {
	class(self).SetRootBone(String.Name(String.New(value)))
}

func (self Instance) TipBone() string {
	return string(class(self).GetTipBone().String())
}

func (self Instance) SetTipBone(value string) {
	class(self).SetTipBone(String.Name(String.New(value)))
}

func (self Instance) Target() Transform3D.BasisOrigin {
	return Transform3D.BasisOrigin(class(self).GetTargetTransform())
}

func (self Instance) SetTarget(value Transform3D.BasisOrigin) {
	class(self).SetTargetTransform(Transform3D.BasisOrigin(value))
}

func (self Instance) OverrideTipBasis() bool {
	return bool(class(self).IsOverrideTipBasis())
}

func (self Instance) SetOverrideTipBasis(value bool) {
	class(self).SetOverrideTipBasis(value)
}

func (self Instance) UseMagnet() bool {
	return bool(class(self).IsUsingMagnet())
}

func (self Instance) SetUseMagnet(value bool) {
	class(self).SetUseMagnet(value)
}

func (self Instance) Magnet() Vector3.XYZ {
	return Vector3.XYZ(class(self).GetMagnetPosition())
}

func (self Instance) SetMagnet(value Vector3.XYZ) {
	class(self).SetMagnetPosition(Vector3.XYZ(value))
}

func (self Instance) TargetNode() string {
	return string(class(self).GetTargetNode().String())
}

func (self Instance) SetTargetNode(value string) {
	class(self).SetTargetNode(Path.ToNode(String.New(value)))
}

func (self Instance) MinDistance() Float.X {
	return Float.X(Float.X(class(self).GetMinDistance()))
}

func (self Instance) SetMinDistance(value Float.X) {
	class(self).SetMinDistance(float64(value))
}

func (self Instance) MaxIterations() int {
	return int(int(class(self).GetMaxIterations()))
}

func (self Instance) SetMaxIterations(value int) {
	class(self).SetMaxIterations(int64(value))
}

func (self Instance) Interpolation() Float.X {
	return Float.X(Float.X(class(self).GetInterpolation()))
}

func (self Instance) SetInterpolation(value Float.X) {
	class(self).SetInterpolation(float64(value))
}

//go:nosplit
func (self class) SetRootBone(root_bone String.Name) { //gd:SkeletonIK3D.set_root_bone
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.SkeletonIK3D.Bind_set_root_bone), 0|(gdextension.SizeStringName<<4), unsafe.Pointer(&struct{ root_bone gdextension.StringName }{gdextension.StringName(pointers.Get(gd.InternalStringName(root_bone))[0])}))
}

//go:nosplit
func (self class) GetRootBone() String.Name { //gd:SkeletonIK3D.get_root_bone
	var r_ret = gdextension.Call[[1]gd.EnginePointer](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.SkeletonIK3D.Bind_get_root_bone), gdextension.SizeStringName, unsafe.Pointer(&struct{}{}))
	var ret = String.Name(String.Via(gd.StringNameProxy{}, pointers.Pack(pointers.New[gd.StringName](r_ret))))
	return ret
}

//go:nosplit
func (self class) SetTipBone(tip_bone String.Name) { //gd:SkeletonIK3D.set_tip_bone
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.SkeletonIK3D.Bind_set_tip_bone), 0|(gdextension.SizeStringName<<4), unsafe.Pointer(&struct{ tip_bone gdextension.StringName }{gdextension.StringName(pointers.Get(gd.InternalStringName(tip_bone))[0])}))
}

//go:nosplit
func (self class) GetTipBone() String.Name { //gd:SkeletonIK3D.get_tip_bone
	var r_ret = gdextension.Call[[1]gd.EnginePointer](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.SkeletonIK3D.Bind_get_tip_bone), gdextension.SizeStringName, unsafe.Pointer(&struct{}{}))
	var ret = String.Name(String.Via(gd.StringNameProxy{}, pointers.Pack(pointers.New[gd.StringName](r_ret))))
	return ret
}

//go:nosplit
func (self class) SetTargetTransform(target Transform3D.BasisOrigin) { //gd:SkeletonIK3D.set_target_transform
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.SkeletonIK3D.Bind_set_target_transform), 0|(gdextension.SizeTransform3D<<4), unsafe.Pointer(&struct{ target Transform3D.BasisOrigin }{gd.Transposed(target)}))
}

//go:nosplit
func (self class) GetTargetTransform() Transform3D.BasisOrigin { //gd:SkeletonIK3D.get_target_transform
	var r_ret = gdextension.Call[Transform3D.BasisOrigin](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.SkeletonIK3D.Bind_get_target_transform), gdextension.SizeTransform3D, unsafe.Pointer(&struct{}{}))
	var ret = gd.Transposed(r_ret)
	return ret
}

//go:nosplit
func (self class) SetTargetNode(node Path.ToNode) { //gd:SkeletonIK3D.set_target_node
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.SkeletonIK3D.Bind_set_target_node), 0|(gdextension.SizeNodePath<<4), unsafe.Pointer(&struct{ node gdextension.NodePath }{gdextension.NodePath(pointers.Get(gd.InternalNodePath(node))[0])}))
}

//go:nosplit
func (self class) GetTargetNode() Path.ToNode { //gd:SkeletonIK3D.get_target_node
	var r_ret = gdextension.Call[[1]gd.EnginePointer](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.SkeletonIK3D.Bind_get_target_node), gdextension.SizeNodePath, unsafe.Pointer(&struct{}{}))
	var ret = Path.ToNode(String.Via(gd.NodePathProxy{}, pointers.Pack(pointers.New[gd.NodePath](r_ret))))
	return ret
}

//go:nosplit
func (self class) SetOverrideTipBasis(override bool) { //gd:SkeletonIK3D.set_override_tip_basis
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.SkeletonIK3D.Bind_set_override_tip_basis), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ override bool }{override}))
}

//go:nosplit
func (self class) IsOverrideTipBasis() bool { //gd:SkeletonIK3D.is_override_tip_basis
	var r_ret = gdextension.Call[bool](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.SkeletonIK3D.Bind_is_override_tip_basis), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetUseMagnet(use bool) { //gd:SkeletonIK3D.set_use_magnet
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.SkeletonIK3D.Bind_set_use_magnet), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ use bool }{use}))
}

//go:nosplit
func (self class) IsUsingMagnet() bool { //gd:SkeletonIK3D.is_using_magnet
	var r_ret = gdextension.Call[bool](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.SkeletonIK3D.Bind_is_using_magnet), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetMagnetPosition(local_position Vector3.XYZ) { //gd:SkeletonIK3D.set_magnet_position
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.SkeletonIK3D.Bind_set_magnet_position), 0|(gdextension.SizeVector3<<4), unsafe.Pointer(&struct{ local_position Vector3.XYZ }{local_position}))
}

//go:nosplit
func (self class) GetMagnetPosition() Vector3.XYZ { //gd:SkeletonIK3D.get_magnet_position
	var r_ret = gdextension.Call[Vector3.XYZ](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.SkeletonIK3D.Bind_get_magnet_position), gdextension.SizeVector3, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the parent [Skeleton3D] node that was present when SkeletonIK entered the scene tree. Returns [code]null[/code] if the parent node was not a [Skeleton3D] node when SkeletonIK3D entered the scene tree.
*/
//go:nosplit
func (self class) GetParentSkeleton() [1]gdclass.Skeleton3D { //gd:SkeletonIK3D.get_parent_skeleton
	var r_ret = gdextension.Call[gd.EnginePointer](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.SkeletonIK3D.Bind_get_parent_skeleton), gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.Skeleton3D{gd.PointerMustAssertInstanceID[gdclass.Skeleton3D](r_ret)}
	return ret
}

/*
Returns [code]true[/code] if SkeletonIK is applying IK effects on continues frames to the [Skeleton3D] bones. Returns [code]false[/code] if SkeletonIK is stopped or [method start] was used with the [code]one_time[/code] parameter set to [code]true[/code].
*/
//go:nosplit
func (self class) IsRunning() bool { //gd:SkeletonIK3D.is_running
	var r_ret = gdextension.Call[bool](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.SkeletonIK3D.Bind_is_running), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetMinDistance(min_distance float64) { //gd:SkeletonIK3D.set_min_distance
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.SkeletonIK3D.Bind_set_min_distance), 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ min_distance float64 }{min_distance}))
}

//go:nosplit
func (self class) GetMinDistance() float64 { //gd:SkeletonIK3D.get_min_distance
	var r_ret = gdextension.Call[float64](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.SkeletonIK3D.Bind_get_min_distance), gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetMaxIterations(iterations int64) { //gd:SkeletonIK3D.set_max_iterations
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.SkeletonIK3D.Bind_set_max_iterations), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ iterations int64 }{iterations}))
}

//go:nosplit
func (self class) GetMaxIterations() int64 { //gd:SkeletonIK3D.get_max_iterations
	var r_ret = gdextension.Call[int64](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.SkeletonIK3D.Bind_get_max_iterations), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Starts applying IK effects on each frame to the [Skeleton3D] bones but will only take effect starting on the next frame. If [param one_time] is [code]true[/code], this will take effect immediately but also reset on the next frame.
*/
//go:nosplit
func (self class) Start(one_time bool) { //gd:SkeletonIK3D.start
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.SkeletonIK3D.Bind_start), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ one_time bool }{one_time}))
}

/*
Stops applying IK effects on each frame to the [Skeleton3D] bones and also calls [method Skeleton3D.clear_bones_global_pose_override] to remove existing overrides on all bones.
*/
//go:nosplit
func (self class) Stop() { //gd:SkeletonIK3D.stop
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.SkeletonIK3D.Bind_stop), 0, unsafe.Pointer(&struct{}{}))
}

//go:nosplit
func (self class) SetInterpolation(interpolation float64) { //gd:SkeletonIK3D.set_interpolation
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.SkeletonIK3D.Bind_set_interpolation), 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ interpolation float64 }{interpolation}))
}

//go:nosplit
func (self class) GetInterpolation() float64 { //gd:SkeletonIK3D.get_interpolation
	var r_ret = gdextension.Call[float64](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.SkeletonIK3D.Bind_get_interpolation), gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}
func (self class) AsSkeletonIK3D() Advanced         { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsSkeletonIK3D() Instance      { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsSkeletonIK3D() Instance { return self.Super().AsSkeletonIK3D() }
func (self class) AsSkeletonModifier3D() SkeletonModifier3D.Advanced {
	return *((*SkeletonModifier3D.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsSkeletonModifier3D() SkeletonModifier3D.Instance {
	return self.Super().AsSkeletonModifier3D()
}
func (self Instance) AsSkeletonModifier3D() SkeletonModifier3D.Instance {
	return *((*SkeletonModifier3D.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsNode3D() Node3D.Advanced         { return *((*Node3D.Advanced)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsNode3D() Node3D.Instance { return self.Super().AsNode3D() }
func (self Instance) AsNode3D() Node3D.Instance      { return *((*Node3D.Instance)(unsafe.Pointer(&self))) }
func (self class) AsNode() Node.Advanced             { return *((*Node.Advanced)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsNode() Node.Instance     { return self.Super().AsNode() }
func (self Instance) AsNode() Node.Instance          { return *((*Node.Instance)(unsafe.Pointer(&self))) }

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(SkeletonModifier3D.Advanced(self.AsSkeletonModifier3D()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(SkeletonModifier3D.Instance(self.AsSkeletonModifier3D()), name)
	}
}
func init() {
	gdclass.Register("SkeletonIK3D", func(ptr gd.Object) any {
		return [1]gdclass.SkeletonIK3D{*(*gdclass.SkeletonIK3D)(unsafe.Pointer(&ptr))}
	})
}
