// Code generated by the generate package DO NOT EDIT

// Package EditorInspectorPlugin provides methods for working with EditorInspectorPlugin object instances.
package EditorInspectorPlugin

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/ClassDB"
import "graphics.gd/classdb/Control"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
[EditorInspectorPlugin] allows adding custom property editors to [EditorInspector].
When an object is edited, the [method _can_handle] function is called and must return [code]true[/code] if the object type is supported.
If supported, the function [method _parse_begin] will be called, allowing to place custom controls at the beginning of the class.
Subsequently, the [method _parse_category] and [method _parse_property] are called for every category and property. They offer the ability to add custom controls to the inspector too.
Finally, [method _parse_end] will be called.
On each of these calls, the "add" functions can be called.
To use [EditorInspectorPlugin], register it using the [method EditorPlugin.add_inspector_plugin] method first.

	See [Interface] for methods that can be overridden by a [Class] that extends it.
*/
type Instance [1]gdclass.EditorInspectorPlugin

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	add_custom_control                          gdextension.MethodForClass `hash:"1496901182"`
	add_property_editor                         gdextension.MethodForClass `hash:"2042698479"`
	add_property_editor_for_multiple_properties gdextension.MethodForClass `hash:"788598683"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("EditorInspectorPlugin")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, true)
	})
	gd.RegisterCleanup(func() {
		gdextension.Free(gdextension.TypeStringName, &sname)
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

type Expanded [1]gdclass.EditorInspectorPlugin

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsEditorInspectorPlugin() Instance
}
type Interface interface {
	//Returns [code]true[/code] if this object can be handled by this plugin.
	CanHandle(obj Object.Instance) bool
	//Called to allow adding controls at the beginning of the property list for [param object].
	ParseBegin(obj Object.Instance)
	//Called to allow adding controls at the beginning of a category in the property list for [param object].
	ParseCategory(obj Object.Instance, category string)
	//Called to allow adding controls at the beginning of a group or a sub-group in the property list for [param object].
	ParseGroup(obj Object.Instance, group string)
	//Called to allow adding property-specific editors to the property list for [param object]. The added editor control must extend [EditorProperty]. Returning [code]true[/code] removes the built-in editor for this property, otherwise allows to insert a custom editor before the built-in one.
	ParseProperty(obj Object.Instance, atype variant.Type, name string, hint_type ClassDB.PropertyHint, hint_string string, usage_flags ClassDB.PropertyUsageFlags, wide bool) bool
	//Called to allow adding controls at the end of the property list for [param object].
	ParseEnd(obj Object.Instance)
}

// Implementation implements [Interface] with empty methods.
type Implementation = implementation

type implementation struct{}

func (self implementation) CanHandle(obj Object.Instance) (_ bool)             { return }
func (self implementation) ParseBegin(obj Object.Instance)                     { return }
func (self implementation) ParseCategory(obj Object.Instance, category string) { return }
func (self implementation) ParseGroup(obj Object.Instance, group string)       { return }
func (self implementation) ParseProperty(obj Object.Instance, atype variant.Type, name string, hint_type ClassDB.PropertyHint, hint_string string, usage_flags ClassDB.PropertyUsageFlags, wide bool) (_ bool) {
	return
}
func (self implementation) ParseEnd(obj Object.Instance) { return }

/*
Returns [code]true[/code] if this object can be handled by this plugin.
*/
func (Instance) _can_handle(impl func(ptr unsafe.Pointer, obj Object.Instance) bool) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var obj = [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gd.UnsafeGet[gdextension.Object](p_args, 0))})}
		defer pointers.End(obj[0])
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self, obj)
		gd.UnsafeSet(p_back, ret)
	}
}

/*
Called to allow adding controls at the beginning of the property list for [param object].
*/
func (Instance) _parse_begin(impl func(ptr unsafe.Pointer, obj Object.Instance)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var obj = [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gd.UnsafeGet[gdextension.Object](p_args, 0))})}
		defer pointers.End(obj[0])
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, obj)
	}
}

/*
Called to allow adding controls at the beginning of a category in the property list for [param object].
*/
func (Instance) _parse_category(impl func(ptr unsafe.Pointer, obj Object.Instance, category string)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var obj = [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gd.UnsafeGet[gdextension.Object](p_args, 0))})}
		defer pointers.End(obj[0])
		var category = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](gd.UnsafeGet[gdextension.String](p_args, 1))))
		defer pointers.End(gd.InternalString(category))
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, obj, category.String())
	}
}

/*
Called to allow adding controls at the beginning of a group or a sub-group in the property list for [param object].
*/
func (Instance) _parse_group(impl func(ptr unsafe.Pointer, obj Object.Instance, group string)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var obj = [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gd.UnsafeGet[gdextension.Object](p_args, 0))})}
		defer pointers.End(obj[0])
		var group = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](gd.UnsafeGet[gdextension.String](p_args, 1))))
		defer pointers.End(gd.InternalString(group))
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, obj, group.String())
	}
}

/*
Called to allow adding property-specific editors to the property list for [param object]. The added editor control must extend [EditorProperty]. Returning [code]true[/code] removes the built-in editor for this property, otherwise allows to insert a custom editor before the built-in one.
*/
func (Instance) _parse_property(impl func(ptr unsafe.Pointer, obj Object.Instance, atype variant.Type, name string, hint_type ClassDB.PropertyHint, hint_string string, usage_flags ClassDB.PropertyUsageFlags, wide bool) bool) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var obj = [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gd.UnsafeGet[gdextension.Object](p_args, 0))})}
		defer pointers.End(obj[0])
		var atype = gd.UnsafeGet[variant.Type](p_args, 1)
		var name = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](gd.UnsafeGet[gdextension.String](p_args, 2))))
		defer pointers.End(gd.InternalString(name))
		var hint_type = gd.UnsafeGet[ClassDB.PropertyHint](p_args, 3)
		var hint_string = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](gd.UnsafeGet[gdextension.String](p_args, 4))))
		defer pointers.End(gd.InternalString(hint_string))
		var usage_flags = gd.UnsafeGet[ClassDB.PropertyUsageFlags](p_args, 5)
		var wide = gd.UnsafeGet[bool](p_args, 6)
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self, obj, atype, name.String(), hint_type, hint_string.String(), usage_flags, wide)
		gd.UnsafeSet(p_back, ret)
	}
}

/*
Called to allow adding controls at the end of the property list for [param object].
*/
func (Instance) _parse_end(impl func(ptr unsafe.Pointer, obj Object.Instance)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var obj = [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gd.UnsafeGet[gdextension.Object](p_args, 0))})}
		defer pointers.End(obj[0])
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, obj)
	}
}

/*
Adds a custom control, which is not necessarily a property editor.
*/
func (self Instance) AddCustomControl(control Control.Instance) { //gd:EditorInspectorPlugin.add_custom_control
	Advanced(self).AddCustomControl(control)
}

/*
Adds a property editor for an individual property. The [param editor] control must extend [EditorProperty].
There can be multiple property editors for a property. If [param add_to_end] is [code]true[/code], this newly added editor will be displayed after all the other editors of the property whose [param add_to_end] is [code]false[/code]. For example, the editor uses this parameter to add an "Edit Region" button for [member Sprite2D.region_rect] below the regular [Rect2] editor.
[param label] can be used to choose a custom label for the property editor in the inspector. If left empty, the label is computed from the name of the property instead.
*/
func (self Instance) AddPropertyEditor(property string, editor Control.Instance) { //gd:EditorInspectorPlugin.add_property_editor
	Advanced(self).AddPropertyEditor(String.New(property), editor, false, String.New(""))
}

/*
Adds a property editor for an individual property. The [param editor] control must extend [EditorProperty].
There can be multiple property editors for a property. If [param add_to_end] is [code]true[/code], this newly added editor will be displayed after all the other editors of the property whose [param add_to_end] is [code]false[/code]. For example, the editor uses this parameter to add an "Edit Region" button for [member Sprite2D.region_rect] below the regular [Rect2] editor.
[param label] can be used to choose a custom label for the property editor in the inspector. If left empty, the label is computed from the name of the property instead.
*/
func (self Expanded) AddPropertyEditor(property string, editor Control.Instance, add_to_end bool, label string) { //gd:EditorInspectorPlugin.add_property_editor
	Advanced(self).AddPropertyEditor(String.New(property), editor, add_to_end, String.New(label))
}

/*
Adds an editor that allows modifying multiple properties. The [param editor] control must extend [EditorProperty].
*/
func (self Instance) AddPropertyEditorForMultipleProperties(label string, properties []string, editor Control.Instance) { //gd:EditorInspectorPlugin.add_property_editor_for_multiple_properties
	Advanced(self).AddPropertyEditorForMultipleProperties(String.New(label), Packed.MakeStrings(properties...), editor)
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.EditorInspectorPlugin

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.EditorInspectorPlugin)(unsafe.Pointer(&obj))
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.EditorInspectorPlugin)(unsafe.Pointer(&obj))
		return true
	}
	return false
}

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {

	if !gd.Linked {
		var placeholder Instance
		*(*gd.Object)(unsafe.Pointer(&placeholder)) = pointers.Add[gd.Object]([3]uint64{})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(*(*gd.Object)(unsafe.Pointer(&placeholder)), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	object := [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})}
	casted := Instance{*(*gdclass.EditorInspectorPlugin)(unsafe.Pointer(&object))}
	casted.AsRefCounted()[0].InitRef()
	object[0].Notification(0, false)
	return casted
}

/*
Returns [code]true[/code] if this object can be handled by this plugin.
*/
func (class) _can_handle(impl func(ptr unsafe.Pointer, obj [1]gd.Object) bool) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var obj = [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gd.UnsafeGet[gdextension.Object](p_args, 0))})}
		defer pointers.End(obj[0])
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self, obj)
		gd.UnsafeSet(p_back, ret)
	}
}

/*
Called to allow adding controls at the beginning of the property list for [param object].
*/
func (class) _parse_begin(impl func(ptr unsafe.Pointer, obj [1]gd.Object)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var obj = [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gd.UnsafeGet[gdextension.Object](p_args, 0))})}
		defer pointers.End(obj[0])
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, obj)
	}
}

/*
Called to allow adding controls at the beginning of a category in the property list for [param object].
*/
func (class) _parse_category(impl func(ptr unsafe.Pointer, obj [1]gd.Object, category String.Readable)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var obj = [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gd.UnsafeGet[gdextension.Object](p_args, 0))})}
		defer pointers.End(obj[0])
		var category = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](gd.UnsafeGet[gdextension.String](p_args, 1))))
		defer pointers.End(gd.InternalString(category))
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, obj, category)
	}
}

/*
Called to allow adding controls at the beginning of a group or a sub-group in the property list for [param object].
*/
func (class) _parse_group(impl func(ptr unsafe.Pointer, obj [1]gd.Object, group String.Readable)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var obj = [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gd.UnsafeGet[gdextension.Object](p_args, 0))})}
		defer pointers.End(obj[0])
		var group = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](gd.UnsafeGet[gdextension.String](p_args, 1))))
		defer pointers.End(gd.InternalString(group))
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, obj, group)
	}
}

/*
Called to allow adding property-specific editors to the property list for [param object]. The added editor control must extend [EditorProperty]. Returning [code]true[/code] removes the built-in editor for this property, otherwise allows to insert a custom editor before the built-in one.
*/
func (class) _parse_property(impl func(ptr unsafe.Pointer, obj [1]gd.Object, atype variant.Type, name String.Readable, hint_type ClassDB.PropertyHint, hint_string String.Readable, usage_flags ClassDB.PropertyUsageFlags, wide bool) bool) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var obj = [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gd.UnsafeGet[gdextension.Object](p_args, 0))})}
		defer pointers.End(obj[0])
		var atype = gd.UnsafeGet[variant.Type](p_args, 1)
		var name = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](gd.UnsafeGet[gdextension.String](p_args, 2))))
		defer pointers.End(gd.InternalString(name))
		var hint_type = gd.UnsafeGet[ClassDB.PropertyHint](p_args, 3)
		var hint_string = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](gd.UnsafeGet[gdextension.String](p_args, 4))))
		defer pointers.End(gd.InternalString(hint_string))
		var usage_flags = gd.UnsafeGet[ClassDB.PropertyUsageFlags](p_args, 5)
		var wide = gd.UnsafeGet[bool](p_args, 6)
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self, obj, atype, name, hint_type, hint_string, usage_flags, wide)
		gd.UnsafeSet(p_back, ret)
	}
}

/*
Called to allow adding controls at the end of the property list for [param object].
*/
func (class) _parse_end(impl func(ptr unsafe.Pointer, obj [1]gd.Object)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var obj = [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gd.UnsafeGet[gdextension.Object](p_args, 0))})}
		defer pointers.End(obj[0])
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, obj)
	}
}

/*
Adds a custom control, which is not necessarily a property editor.
*/
//go:nosplit
func (self class) AddCustomControl(control [1]gdclass.Control) { //gd:EditorInspectorPlugin.add_custom_control
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_custom_control, 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ control gdextension.Object }{gdextension.Object(gd.PointerWithOwnershipTransferredToGodot(control[0].AsObject()[0]))}))
}

/*
Adds a property editor for an individual property. The [param editor] control must extend [EditorProperty].
There can be multiple property editors for a property. If [param add_to_end] is [code]true[/code], this newly added editor will be displayed after all the other editors of the property whose [param add_to_end] is [code]false[/code]. For example, the editor uses this parameter to add an "Edit Region" button for [member Sprite2D.region_rect] below the regular [Rect2] editor.
[param label] can be used to choose a custom label for the property editor in the inspector. If left empty, the label is computed from the name of the property instead.
*/
//go:nosplit
func (self class) AddPropertyEditor(property String.Readable, editor [1]gdclass.Control, add_to_end bool, label String.Readable) { //gd:EditorInspectorPlugin.add_property_editor
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_property_editor, 0|(gdextension.SizeString<<4)|(gdextension.SizeObject<<8)|(gdextension.SizeBool<<12)|(gdextension.SizeString<<16), unsafe.Pointer(&struct {
		property   gdextension.String
		editor     gdextension.Object
		add_to_end bool
		label      gdextension.String
	}{pointers.Get(gd.InternalString(property)), gdextension.Object(gd.PointerWithOwnershipTransferredToGodot(editor[0].AsObject()[0])), add_to_end, pointers.Get(gd.InternalString(label))}))
}

/*
Adds an editor that allows modifying multiple properties. The [param editor] control must extend [EditorProperty].
*/
//go:nosplit
func (self class) AddPropertyEditorForMultipleProperties(label String.Readable, properties Packed.Strings, editor [1]gdclass.Control) { //gd:EditorInspectorPlugin.add_property_editor_for_multiple_properties
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_property_editor_for_multiple_properties, 0|(gdextension.SizeString<<4)|(gdextension.SizePackedArray<<8)|(gdextension.SizeObject<<12), unsafe.Pointer(&struct {
		label      gdextension.String
		properties gdextension.PackedArray[gdextension.String]
		editor     gdextension.Object
	}{pointers.Get(gd.InternalString(label)), pointers.Get(gd.InternalPackedStrings(properties)), gdextension.Object(gd.PointerWithOwnershipTransferredToGodot(editor[0].AsObject()[0]))}))
}
func (self class) AsEditorInspectorPlugin() Advanced    { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsEditorInspectorPlugin() Instance { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsEditorInspectorPlugin() Instance {
	return self.Super().AsEditorInspectorPlugin()
}
func (self class) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsRefCounted() [1]gd.RefCounted { return self.Super().AsRefCounted() }
func (self Instance) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	case "_can_handle":
		return reflect.ValueOf(self._can_handle)
	case "_parse_begin":
		return reflect.ValueOf(self._parse_begin)
	case "_parse_category":
		return reflect.ValueOf(self._parse_category)
	case "_parse_group":
		return reflect.ValueOf(self._parse_group)
	case "_parse_property":
		return reflect.ValueOf(self._parse_property)
	case "_parse_end":
		return reflect.ValueOf(self._parse_end)
	default:
		return gd.VirtualByName(RefCounted.Advanced(self.AsRefCounted()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	case "_can_handle":
		return reflect.ValueOf(self._can_handle)
	case "_parse_begin":
		return reflect.ValueOf(self._parse_begin)
	case "_parse_category":
		return reflect.ValueOf(self._parse_category)
	case "_parse_group":
		return reflect.ValueOf(self._parse_group)
	case "_parse_property":
		return reflect.ValueOf(self._parse_property)
	case "_parse_end":
		return reflect.ValueOf(self._parse_end)
	default:
		return gd.VirtualByName(RefCounted.Instance(self.AsRefCounted()), name)
	}
}
func init() {
	gdclass.Register("EditorInspectorPlugin", func(ptr gd.Object) any { return *(*Instance)(unsafe.Pointer(&ptr)) })
}
