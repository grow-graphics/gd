// Code generated by the generate package DO NOT EDIT

// Package Area3D provides methods for working with Area3D object instances.
package Area3D

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/variant/Signal"
import "graphics.gd/classdb/CollisionObject3D"
import "graphics.gd/classdb/Node"
import "graphics.gd/classdb/Node3D"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"
import "graphics.gd/variant/Vector3"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Signal.Any
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
[Area3D] is a region of 3D space defined by one or multiple [CollisionShape3D] or [CollisionPolygon3D] child nodes. It detects when other [CollisionObject3D]s enter or exit it, and it also keeps track of which collision objects haven't exited it yet (i.e. which one are overlapping it).
This node can also locally alter or override physics parameters (gravity, damping) and route audio to custom audio buses.
[b]Note:[/b] Areas and bodies created with [PhysicsServer3D] might not interact as expected with [Area3D]s, and might not emit signals or track objects correctly.
[b]Warning:[/b] Using a [ConcavePolygonShape3D] inside a [CollisionShape3D] child of this node (created e.g. by using the [b]Create Trimesh Collision Sibling[/b] option in the [b]Mesh[/b] menu that appears when selecting a [MeshInstance3D] node) may give unexpected results, since this collision shape is hollow. If this is not desired, it has to be split into multiple [ConvexPolygonShape3D]s or primitive shapes like [BoxShape3D], or in some cases it may be replaceable by a [CollisionPolygon3D].
*/
type Instance [1]gdclass.Area3D

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	set_gravity_space_override_mode      gdextension.MethodForClass `hash:"2311433571"`
	get_gravity_space_override_mode      gdextension.MethodForClass `hash:"958191869"`
	set_gravity_is_point                 gdextension.MethodForClass `hash:"2586408642"`
	is_gravity_a_point                   gdextension.MethodForClass `hash:"36873697"`
	set_gravity_point_unit_distance      gdextension.MethodForClass `hash:"373806689"`
	get_gravity_point_unit_distance      gdextension.MethodForClass `hash:"1740695150"`
	set_gravity_point_center             gdextension.MethodForClass `hash:"3460891852"`
	get_gravity_point_center             gdextension.MethodForClass `hash:"3360562783"`
	set_gravity_direction                gdextension.MethodForClass `hash:"3460891852"`
	get_gravity_direction                gdextension.MethodForClass `hash:"3360562783"`
	set_gravity                          gdextension.MethodForClass `hash:"373806689"`
	get_gravity                          gdextension.MethodForClass `hash:"1740695150"`
	set_linear_damp_space_override_mode  gdextension.MethodForClass `hash:"2311433571"`
	get_linear_damp_space_override_mode  gdextension.MethodForClass `hash:"958191869"`
	set_angular_damp_space_override_mode gdextension.MethodForClass `hash:"2311433571"`
	get_angular_damp_space_override_mode gdextension.MethodForClass `hash:"958191869"`
	set_angular_damp                     gdextension.MethodForClass `hash:"373806689"`
	get_angular_damp                     gdextension.MethodForClass `hash:"1740695150"`
	set_linear_damp                      gdextension.MethodForClass `hash:"373806689"`
	get_linear_damp                      gdextension.MethodForClass `hash:"1740695150"`
	set_priority                         gdextension.MethodForClass `hash:"1286410249"`
	get_priority                         gdextension.MethodForClass `hash:"3905245786"`
	set_wind_force_magnitude             gdextension.MethodForClass `hash:"373806689"`
	get_wind_force_magnitude             gdextension.MethodForClass `hash:"1740695150"`
	set_wind_attenuation_factor          gdextension.MethodForClass `hash:"373806689"`
	get_wind_attenuation_factor          gdextension.MethodForClass `hash:"1740695150"`
	set_wind_source_path                 gdextension.MethodForClass `hash:"1348162250"`
	get_wind_source_path                 gdextension.MethodForClass `hash:"4075236667"`
	set_monitorable                      gdextension.MethodForClass `hash:"2586408642"`
	is_monitorable                       gdextension.MethodForClass `hash:"36873697"`
	set_monitoring                       gdextension.MethodForClass `hash:"2586408642"`
	is_monitoring                        gdextension.MethodForClass `hash:"36873697"`
	get_overlapping_bodies               gdextension.MethodForClass `hash:"3995934104"`
	get_overlapping_areas                gdextension.MethodForClass `hash:"3995934104"`
	has_overlapping_bodies               gdextension.MethodForClass `hash:"36873697"`
	has_overlapping_areas                gdextension.MethodForClass `hash:"36873697"`
	overlaps_body                        gdextension.MethodForClass `hash:"3093956946"`
	overlaps_area                        gdextension.MethodForClass `hash:"3093956946"`
	set_audio_bus_override               gdextension.MethodForClass `hash:"2586408642"`
	is_overriding_audio_bus              gdextension.MethodForClass `hash:"36873697"`
	set_audio_bus_name                   gdextension.MethodForClass `hash:"3304788590"`
	get_audio_bus_name                   gdextension.MethodForClass `hash:"2002593661"`
	set_use_reverb_bus                   gdextension.MethodForClass `hash:"2586408642"`
	is_using_reverb_bus                  gdextension.MethodForClass `hash:"36873697"`
	set_reverb_bus_name                  gdextension.MethodForClass `hash:"3304788590"`
	get_reverb_bus_name                  gdextension.MethodForClass `hash:"2002593661"`
	set_reverb_amount                    gdextension.MethodForClass `hash:"373806689"`
	get_reverb_amount                    gdextension.MethodForClass `hash:"1740695150"`
	set_reverb_uniformity                gdextension.MethodForClass `hash:"373806689"`
	get_reverb_uniformity                gdextension.MethodForClass `hash:"1740695150"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("Area3D")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		gdextension.Free(gdextension.TypeStringName, &sname)
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsArea3D() Instance
}

/*
Returns a list of intersecting [PhysicsBody3D]s and [GridMap]s. The overlapping body's [member CollisionObject3D.collision_layer] must be part of this area's [member CollisionObject3D.collision_mask] in order to be detected.
For performance reasons (collisions are all processed at the same time) this list is modified once during the physics step, not immediately after objects are moved. Consider using signals instead.
*/
func (self Instance) GetOverlappingBodies() []Node3D.Instance { //gd:Area3D.get_overlapping_bodies
	return []Node3D.Instance(gd.ArrayAs[[]Node3D.Instance](gd.InternalArray(Advanced(self).GetOverlappingBodies())))
}

/*
Returns a list of intersecting [Area3D]s. The overlapping area's [member CollisionObject3D.collision_layer] must be part of this area's [member CollisionObject3D.collision_mask] in order to be detected.
For performance reasons (collisions are all processed at the same time) this list is modified once during the physics step, not immediately after objects are moved. Consider using signals instead.
*/
func (self Instance) GetOverlappingAreas() []Instance { //gd:Area3D.get_overlapping_areas
	return []Instance(gd.ArrayAs[[]Instance](gd.InternalArray(Advanced(self).GetOverlappingAreas())))
}

/*
Returns [code]true[/code] if intersecting any [PhysicsBody3D]s or [GridMap]s, otherwise returns [code]false[/code]. The overlapping body's [member CollisionObject3D.collision_layer] must be part of this area's [member CollisionObject3D.collision_mask] in order to be detected.
For performance reasons (collisions are all processed at the same time) the list of overlapping bodies is modified once during the physics step, not immediately after objects are moved. Consider using signals instead.
*/
func (self Instance) HasOverlappingBodies() bool { //gd:Area3D.has_overlapping_bodies
	return bool(Advanced(self).HasOverlappingBodies())
}

/*
Returns [code]true[/code] if intersecting any [Area3D]s, otherwise returns [code]false[/code]. The overlapping area's [member CollisionObject3D.collision_layer] must be part of this area's [member CollisionObject3D.collision_mask] in order to be detected.
For performance reasons (collisions are all processed at the same time) the list of overlapping areas is modified once during the physics step, not immediately after objects are moved. Consider using signals instead.
*/
func (self Instance) HasOverlappingAreas() bool { //gd:Area3D.has_overlapping_areas
	return bool(Advanced(self).HasOverlappingAreas())
}

/*
Returns [code]true[/code] if the given physics body intersects or overlaps this [Area3D], [code]false[/code] otherwise.
[b]Note:[/b] The result of this test is not immediate after moving objects. For performance, list of overlaps is updated once per frame and before the physics step. Consider using signals instead.
The [param body] argument can either be a [PhysicsBody3D] or a [GridMap] instance. While GridMaps are not physics body themselves, they register their tiles with collision shapes as a virtual physics body.
*/
func (self Instance) OverlapsBody(body Node.Instance) bool { //gd:Area3D.overlaps_body
	return bool(Advanced(self).OverlapsBody(body))
}

/*
Returns [code]true[/code] if the given [Area3D] intersects or overlaps this [Area3D], [code]false[/code] otherwise.
[b]Note:[/b] The result of this test is not immediate after moving objects. For performance, list of overlaps is updated once per frame and before the physics step. Consider using signals instead.
*/
func (self Instance) OverlapsArea(area Node.Instance) bool { //gd:Area3D.overlaps_area
	return bool(Advanced(self).OverlapsArea(area))
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.Area3D

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.Area3D)(unsafe.Pointer(&obj))
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.Area3D)(unsafe.Pointer(&obj))
		return true
	}
	return false
}

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {

	if !gd.Linked {
		var placeholder Instance
		*(*gd.Object)(unsafe.Pointer(&placeholder)) = pointers.Add[gd.Object]([3]uint64{})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(*(*gd.Object)(unsafe.Pointer(&placeholder)), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	object := [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})}
	casted := Instance{*(*gdclass.Area3D)(unsafe.Pointer(&object))}
	object[0].Notification(0, false)
	return casted
}

func (self Instance) Monitoring() bool {
	return bool(class(self).IsMonitoring())
}

func (self Instance) SetMonitoring(value bool) {
	class(self).SetMonitoring(value)
}

func (self Instance) Monitorable() bool {
	return bool(class(self).IsMonitorable())
}

func (self Instance) SetMonitorable(value bool) {
	class(self).SetMonitorable(value)
}

func (self Instance) Priority() int {
	return int(int(class(self).GetPriority()))
}

func (self Instance) SetPriority(value int) {
	class(self).SetPriority(int64(value))
}

func (self Instance) GravitySpaceOverride() SpaceOverride {
	return SpaceOverride(class(self).GetGravitySpaceOverrideMode())
}

func (self Instance) SetGravitySpaceOverride(value SpaceOverride) {
	class(self).SetGravitySpaceOverrideMode(value)
}

func (self Instance) GravityPoint() bool {
	return bool(class(self).IsGravityAPoint())
}

func (self Instance) SetGravityPoint(value bool) {
	class(self).SetGravityIsPoint(value)
}

func (self Instance) GravityPointUnitDistance() Float.X {
	return Float.X(Float.X(class(self).GetGravityPointUnitDistance()))
}

func (self Instance) SetGravityPointUnitDistance(value Float.X) {
	class(self).SetGravityPointUnitDistance(float64(value))
}

func (self Instance) GravityPointCenter() Vector3.XYZ {
	return Vector3.XYZ(class(self).GetGravityPointCenter())
}

func (self Instance) SetGravityPointCenter(value Vector3.XYZ) {
	class(self).SetGravityPointCenter(Vector3.XYZ(value))
}

func (self Instance) GravityDirection() Vector3.XYZ {
	return Vector3.XYZ(class(self).GetGravityDirection())
}

func (self Instance) SetGravityDirection(value Vector3.XYZ) {
	class(self).SetGravityDirection(Vector3.XYZ(value))
}

func (self Instance) Gravity() Float.X {
	return Float.X(Float.X(class(self).GetGravity()))
}

func (self Instance) SetGravity(value Float.X) {
	class(self).SetGravity(float64(value))
}

func (self Instance) LinearDampSpaceOverride() SpaceOverride {
	return SpaceOverride(class(self).GetLinearDampSpaceOverrideMode())
}

func (self Instance) SetLinearDampSpaceOverride(value SpaceOverride) {
	class(self).SetLinearDampSpaceOverrideMode(value)
}

func (self Instance) LinearDamp() Float.X {
	return Float.X(Float.X(class(self).GetLinearDamp()))
}

func (self Instance) SetLinearDamp(value Float.X) {
	class(self).SetLinearDamp(float64(value))
}

func (self Instance) AngularDampSpaceOverride() SpaceOverride {
	return SpaceOverride(class(self).GetAngularDampSpaceOverrideMode())
}

func (self Instance) SetAngularDampSpaceOverride(value SpaceOverride) {
	class(self).SetAngularDampSpaceOverrideMode(value)
}

func (self Instance) AngularDamp() Float.X {
	return Float.X(Float.X(class(self).GetAngularDamp()))
}

func (self Instance) SetAngularDamp(value Float.X) {
	class(self).SetAngularDamp(float64(value))
}

func (self Instance) WindForceMagnitude() Float.X {
	return Float.X(Float.X(class(self).GetWindForceMagnitude()))
}

func (self Instance) SetWindForceMagnitude(value Float.X) {
	class(self).SetWindForceMagnitude(float64(value))
}

func (self Instance) WindAttenuationFactor() Float.X {
	return Float.X(Float.X(class(self).GetWindAttenuationFactor()))
}

func (self Instance) SetWindAttenuationFactor(value Float.X) {
	class(self).SetWindAttenuationFactor(float64(value))
}

func (self Instance) WindSourcePath() string {
	return string(class(self).GetWindSourcePath().String())
}

func (self Instance) SetWindSourcePath(value string) {
	class(self).SetWindSourcePath(Path.ToNode(String.New(value)))
}

func (self Instance) AudioBusOverride() bool {
	return bool(class(self).IsOverridingAudioBus())
}

func (self Instance) SetAudioBusOverride(value bool) {
	class(self).SetAudioBusOverride(value)
}

func (self Instance) AudioBusName() string {
	return string(class(self).GetAudioBusName().String())
}

func (self Instance) SetAudioBusName(value string) {
	class(self).SetAudioBusName(String.Name(String.New(value)))
}

func (self Instance) ReverbBusEnabled() bool {
	return bool(class(self).IsUsingReverbBus())
}

func (self Instance) SetReverbBusEnabled(value bool) {
	class(self).SetUseReverbBus(value)
}

func (self Instance) ReverbBusName() string {
	return string(class(self).GetReverbBusName().String())
}

func (self Instance) SetReverbBusName(value string) {
	class(self).SetReverbBusName(String.Name(String.New(value)))
}

func (self Instance) ReverbBusAmount() Float.X {
	return Float.X(Float.X(class(self).GetReverbAmount()))
}

func (self Instance) SetReverbBusAmount(value Float.X) {
	class(self).SetReverbAmount(float64(value))
}

func (self Instance) ReverbBusUniformity() Float.X {
	return Float.X(Float.X(class(self).GetReverbUniformity()))
}

func (self Instance) SetReverbBusUniformity(value Float.X) {
	class(self).SetReverbUniformity(float64(value))
}

//go:nosplit
func (self class) SetGravitySpaceOverrideMode(space_override_mode SpaceOverride) { //gd:Area3D.set_gravity_space_override_mode
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_gravity_space_override_mode, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ space_override_mode SpaceOverride }{space_override_mode}))
}

//go:nosplit
func (self class) GetGravitySpaceOverrideMode() SpaceOverride { //gd:Area3D.get_gravity_space_override_mode
	var r_ret = gdextension.Call[SpaceOverride](gd.ObjectChecked(self.AsObject()), methods.get_gravity_space_override_mode, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetGravityIsPoint(enable bool) { //gd:Area3D.set_gravity_is_point
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_gravity_is_point, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

//go:nosplit
func (self class) IsGravityAPoint() bool { //gd:Area3D.is_gravity_a_point
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_gravity_a_point, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetGravityPointUnitDistance(distance_scale float64) { //gd:Area3D.set_gravity_point_unit_distance
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_gravity_point_unit_distance, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ distance_scale float64 }{distance_scale}))
}

//go:nosplit
func (self class) GetGravityPointUnitDistance() float64 { //gd:Area3D.get_gravity_point_unit_distance
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_gravity_point_unit_distance, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetGravityPointCenter(center Vector3.XYZ) { //gd:Area3D.set_gravity_point_center
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_gravity_point_center, 0|(gdextension.SizeVector3<<4), unsafe.Pointer(&struct{ center Vector3.XYZ }{center}))
}

//go:nosplit
func (self class) GetGravityPointCenter() Vector3.XYZ { //gd:Area3D.get_gravity_point_center
	var r_ret = gdextension.Call[Vector3.XYZ](gd.ObjectChecked(self.AsObject()), methods.get_gravity_point_center, gdextension.SizeVector3, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetGravityDirection(direction Vector3.XYZ) { //gd:Area3D.set_gravity_direction
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_gravity_direction, 0|(gdextension.SizeVector3<<4), unsafe.Pointer(&struct{ direction Vector3.XYZ }{direction}))
}

//go:nosplit
func (self class) GetGravityDirection() Vector3.XYZ { //gd:Area3D.get_gravity_direction
	var r_ret = gdextension.Call[Vector3.XYZ](gd.ObjectChecked(self.AsObject()), methods.get_gravity_direction, gdextension.SizeVector3, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetGravity(gravity float64) { //gd:Area3D.set_gravity
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_gravity, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ gravity float64 }{gravity}))
}

//go:nosplit
func (self class) GetGravity() float64 { //gd:Area3D.get_gravity
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_gravity, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetLinearDampSpaceOverrideMode(space_override_mode SpaceOverride) { //gd:Area3D.set_linear_damp_space_override_mode
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_linear_damp_space_override_mode, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ space_override_mode SpaceOverride }{space_override_mode}))
}

//go:nosplit
func (self class) GetLinearDampSpaceOverrideMode() SpaceOverride { //gd:Area3D.get_linear_damp_space_override_mode
	var r_ret = gdextension.Call[SpaceOverride](gd.ObjectChecked(self.AsObject()), methods.get_linear_damp_space_override_mode, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetAngularDampSpaceOverrideMode(space_override_mode SpaceOverride) { //gd:Area3D.set_angular_damp_space_override_mode
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_angular_damp_space_override_mode, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ space_override_mode SpaceOverride }{space_override_mode}))
}

//go:nosplit
func (self class) GetAngularDampSpaceOverrideMode() SpaceOverride { //gd:Area3D.get_angular_damp_space_override_mode
	var r_ret = gdextension.Call[SpaceOverride](gd.ObjectChecked(self.AsObject()), methods.get_angular_damp_space_override_mode, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetAngularDamp(angular_damp float64) { //gd:Area3D.set_angular_damp
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_angular_damp, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ angular_damp float64 }{angular_damp}))
}

//go:nosplit
func (self class) GetAngularDamp() float64 { //gd:Area3D.get_angular_damp
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_angular_damp, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetLinearDamp(linear_damp float64) { //gd:Area3D.set_linear_damp
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_linear_damp, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ linear_damp float64 }{linear_damp}))
}

//go:nosplit
func (self class) GetLinearDamp() float64 { //gd:Area3D.get_linear_damp
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_linear_damp, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetPriority(priority int64) { //gd:Area3D.set_priority
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_priority, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ priority int64 }{priority}))
}

//go:nosplit
func (self class) GetPriority() int64 { //gd:Area3D.get_priority
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_priority, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetWindForceMagnitude(wind_force_magnitude float64) { //gd:Area3D.set_wind_force_magnitude
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_wind_force_magnitude, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ wind_force_magnitude float64 }{wind_force_magnitude}))
}

//go:nosplit
func (self class) GetWindForceMagnitude() float64 { //gd:Area3D.get_wind_force_magnitude
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_wind_force_magnitude, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetWindAttenuationFactor(wind_attenuation_factor float64) { //gd:Area3D.set_wind_attenuation_factor
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_wind_attenuation_factor, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ wind_attenuation_factor float64 }{wind_attenuation_factor}))
}

//go:nosplit
func (self class) GetWindAttenuationFactor() float64 { //gd:Area3D.get_wind_attenuation_factor
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_wind_attenuation_factor, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetWindSourcePath(wind_source_path Path.ToNode) { //gd:Area3D.set_wind_source_path
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_wind_source_path, 0|(gdextension.SizeNodePath<<4), unsafe.Pointer(&struct{ wind_source_path gdextension.NodePath }{pointers.Get(gd.InternalNodePath(wind_source_path))}))
}

//go:nosplit
func (self class) GetWindSourcePath() Path.ToNode { //gd:Area3D.get_wind_source_path
	var r_ret = gdextension.Call[gdextension.NodePath](gd.ObjectChecked(self.AsObject()), methods.get_wind_source_path, gdextension.SizeNodePath, unsafe.Pointer(&struct{}{}))
	var ret = Path.ToNode(String.Via(gd.NodePathProxy{}, pointers.Pack(pointers.New[gd.NodePath](r_ret))))
	return ret
}

//go:nosplit
func (self class) SetMonitorable(enable bool) { //gd:Area3D.set_monitorable
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_monitorable, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

//go:nosplit
func (self class) IsMonitorable() bool { //gd:Area3D.is_monitorable
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_monitorable, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetMonitoring(enable bool) { //gd:Area3D.set_monitoring
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_monitoring, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

//go:nosplit
func (self class) IsMonitoring() bool { //gd:Area3D.is_monitoring
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_monitoring, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns a list of intersecting [PhysicsBody3D]s and [GridMap]s. The overlapping body's [member CollisionObject3D.collision_layer] must be part of this area's [member CollisionObject3D.collision_mask] in order to be detected.
For performance reasons (collisions are all processed at the same time) this list is modified once during the physics step, not immediately after objects are moved. Consider using signals instead.
*/
//go:nosplit
func (self class) GetOverlappingBodies() Array.Contains[[1]gdclass.Node3D] { //gd:Area3D.get_overlapping_bodies
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), methods.get_overlapping_bodies, gdextension.SizeArray, unsafe.Pointer(&struct{}{}))
	var ret = Array.Through(gd.ArrayProxy[[1]gdclass.Node3D]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

/*
Returns a list of intersecting [Area3D]s. The overlapping area's [member CollisionObject3D.collision_layer] must be part of this area's [member CollisionObject3D.collision_mask] in order to be detected.
For performance reasons (collisions are all processed at the same time) this list is modified once during the physics step, not immediately after objects are moved. Consider using signals instead.
*/
//go:nosplit
func (self class) GetOverlappingAreas() Array.Contains[[1]gdclass.Area3D] { //gd:Area3D.get_overlapping_areas
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), methods.get_overlapping_areas, gdextension.SizeArray, unsafe.Pointer(&struct{}{}))
	var ret = Array.Through(gd.ArrayProxy[[1]gdclass.Area3D]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

/*
Returns [code]true[/code] if intersecting any [PhysicsBody3D]s or [GridMap]s, otherwise returns [code]false[/code]. The overlapping body's [member CollisionObject3D.collision_layer] must be part of this area's [member CollisionObject3D.collision_mask] in order to be detected.
For performance reasons (collisions are all processed at the same time) the list of overlapping bodies is modified once during the physics step, not immediately after objects are moved. Consider using signals instead.
*/
//go:nosplit
func (self class) HasOverlappingBodies() bool { //gd:Area3D.has_overlapping_bodies
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.has_overlapping_bodies, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if intersecting any [Area3D]s, otherwise returns [code]false[/code]. The overlapping area's [member CollisionObject3D.collision_layer] must be part of this area's [member CollisionObject3D.collision_mask] in order to be detected.
For performance reasons (collisions are all processed at the same time) the list of overlapping areas is modified once during the physics step, not immediately after objects are moved. Consider using signals instead.
*/
//go:nosplit
func (self class) HasOverlappingAreas() bool { //gd:Area3D.has_overlapping_areas
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.has_overlapping_areas, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if the given physics body intersects or overlaps this [Area3D], [code]false[/code] otherwise.
[b]Note:[/b] The result of this test is not immediate after moving objects. For performance, list of overlaps is updated once per frame and before the physics step. Consider using signals instead.
The [param body] argument can either be a [PhysicsBody3D] or a [GridMap] instance. While GridMaps are not physics body themselves, they register their tiles with collision shapes as a virtual physics body.
*/
//go:nosplit
func (self class) OverlapsBody(body [1]gdclass.Node) bool { //gd:Area3D.overlaps_body
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.overlaps_body, gdextension.SizeBool|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ body gdextension.Object }{gdextension.Object(gd.ObjectChecked(body[0].AsObject()))}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if the given [Area3D] intersects or overlaps this [Area3D], [code]false[/code] otherwise.
[b]Note:[/b] The result of this test is not immediate after moving objects. For performance, list of overlaps is updated once per frame and before the physics step. Consider using signals instead.
*/
//go:nosplit
func (self class) OverlapsArea(area [1]gdclass.Node) bool { //gd:Area3D.overlaps_area
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.overlaps_area, gdextension.SizeBool|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ area gdextension.Object }{gdextension.Object(gd.ObjectChecked(area[0].AsObject()))}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetAudioBusOverride(enable bool) { //gd:Area3D.set_audio_bus_override
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_audio_bus_override, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

//go:nosplit
func (self class) IsOverridingAudioBus() bool { //gd:Area3D.is_overriding_audio_bus
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_overriding_audio_bus, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetAudioBusName(name String.Name) { //gd:Area3D.set_audio_bus_name
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_audio_bus_name, 0|(gdextension.SizeStringName<<4), unsafe.Pointer(&struct{ name gdextension.StringName }{pointers.Get(gd.InternalStringName(name))}))
}

//go:nosplit
func (self class) GetAudioBusName() String.Name { //gd:Area3D.get_audio_bus_name
	var r_ret = gdextension.Call[gdextension.StringName](gd.ObjectChecked(self.AsObject()), methods.get_audio_bus_name, gdextension.SizeStringName, unsafe.Pointer(&struct{}{}))
	var ret = String.Name(String.Via(gd.StringNameProxy{}, pointers.Pack(pointers.New[gd.StringName](r_ret))))
	return ret
}

//go:nosplit
func (self class) SetUseReverbBus(enable bool) { //gd:Area3D.set_use_reverb_bus
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_use_reverb_bus, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

//go:nosplit
func (self class) IsUsingReverbBus() bool { //gd:Area3D.is_using_reverb_bus
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_using_reverb_bus, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetReverbBusName(name String.Name) { //gd:Area3D.set_reverb_bus_name
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_reverb_bus_name, 0|(gdextension.SizeStringName<<4), unsafe.Pointer(&struct{ name gdextension.StringName }{pointers.Get(gd.InternalStringName(name))}))
}

//go:nosplit
func (self class) GetReverbBusName() String.Name { //gd:Area3D.get_reverb_bus_name
	var r_ret = gdextension.Call[gdextension.StringName](gd.ObjectChecked(self.AsObject()), methods.get_reverb_bus_name, gdextension.SizeStringName, unsafe.Pointer(&struct{}{}))
	var ret = String.Name(String.Via(gd.StringNameProxy{}, pointers.Pack(pointers.New[gd.StringName](r_ret))))
	return ret
}

//go:nosplit
func (self class) SetReverbAmount(amount float64) { //gd:Area3D.set_reverb_amount
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_reverb_amount, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ amount float64 }{amount}))
}

//go:nosplit
func (self class) GetReverbAmount() float64 { //gd:Area3D.get_reverb_amount
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_reverb_amount, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetReverbUniformity(amount float64) { //gd:Area3D.set_reverb_uniformity
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_reverb_uniformity, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ amount float64 }{amount}))
}

//go:nosplit
func (self class) GetReverbUniformity() float64 { //gd:Area3D.get_reverb_uniformity
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_reverb_uniformity, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}
func (self Instance) OnBodyShapeEntered(cb func(body_rid RID.Any, body Node3D.Instance, body_shape_index int, local_shape_index int), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("body_shape_entered"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) BodyShapeEntered() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`BodyShapeEntered`))))
}

func (self Instance) OnBodyShapeExited(cb func(body_rid RID.Any, body Node3D.Instance, body_shape_index int, local_shape_index int), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("body_shape_exited"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) BodyShapeExited() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`BodyShapeExited`))))
}

func (self Instance) OnBodyEntered(cb func(body Node3D.Instance), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("body_entered"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) BodyEntered() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`BodyEntered`))))
}

func (self Instance) OnBodyExited(cb func(body Node3D.Instance), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("body_exited"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) BodyExited() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`BodyExited`))))
}

func (self Instance) OnAreaShapeEntered(cb func(area_rid RID.Any, area Instance, area_shape_index int, local_shape_index int), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("area_shape_entered"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) AreaShapeEntered() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`AreaShapeEntered`))))
}

func (self Instance) OnAreaShapeExited(cb func(area_rid RID.Any, area Instance, area_shape_index int, local_shape_index int), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("area_shape_exited"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) AreaShapeExited() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`AreaShapeExited`))))
}

func (self Instance) OnAreaEntered(cb func(area Instance), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("area_entered"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) AreaEntered() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`AreaEntered`))))
}

func (self Instance) OnAreaExited(cb func(area Instance), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("area_exited"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) AreaExited() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`AreaExited`))))
}

func (self class) AsArea3D() Advanced         { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsArea3D() Instance      { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsArea3D() Instance { return self.Super().AsArea3D() }
func (self class) AsCollisionObject3D() CollisionObject3D.Advanced {
	return *((*CollisionObject3D.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsCollisionObject3D() CollisionObject3D.Instance {
	return self.Super().AsCollisionObject3D()
}
func (self Instance) AsCollisionObject3D() CollisionObject3D.Instance {
	return *((*CollisionObject3D.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsNode3D() Node3D.Advanced         { return *((*Node3D.Advanced)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsNode3D() Node3D.Instance { return self.Super().AsNode3D() }
func (self Instance) AsNode3D() Node3D.Instance      { return *((*Node3D.Instance)(unsafe.Pointer(&self))) }
func (self class) AsNode() Node.Advanced             { return *((*Node.Advanced)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsNode() Node.Instance     { return self.Super().AsNode() }
func (self Instance) AsNode() Node.Instance          { return *((*Node.Instance)(unsafe.Pointer(&self))) }

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(CollisionObject3D.Advanced(self.AsCollisionObject3D()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(CollisionObject3D.Instance(self.AsCollisionObject3D()), name)
	}
}
func init() {
	gdclass.Register("Area3D", func(ptr gd.Object) any { return *(*Instance)(unsafe.Pointer(&ptr)) })
}

type SpaceOverride int //gd:Area3D.SpaceOverride

const (
	/*This area does not affect gravity/damping.*/
	SpaceOverrideDisabled SpaceOverride = 0
	/*This area adds its gravity/damping values to whatever has been calculated so far (in [member priority] order).*/
	SpaceOverrideCombine SpaceOverride = 1
	/*This area adds its gravity/damping values to whatever has been calculated so far (in [member priority] order), ignoring any lower priority areas.*/
	SpaceOverrideCombineReplace SpaceOverride = 2
	/*This area replaces any gravity/damping, even the defaults, ignoring any lower priority areas.*/
	SpaceOverrideReplace SpaceOverride = 3
	/*This area replaces any gravity/damping calculated so far (in [member priority] order), but keeps calculating the rest of the areas.*/
	SpaceOverrideReplaceCombine SpaceOverride = 4
)
