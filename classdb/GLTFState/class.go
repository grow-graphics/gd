// Code generated by the generate package DO NOT EDIT

// Package GLTFState provides methods for working with GLTFState object instances.
package GLTFState

import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/variant/Signal"
import "graphics.gd/classdb/AnimationPlayer"
import "graphics.gd/classdb/GLTFAccessor"
import "graphics.gd/classdb/GLTFAnimation"
import "graphics.gd/classdb/GLTFBufferView"
import "graphics.gd/classdb/GLTFCamera"
import "graphics.gd/classdb/GLTFLight"
import "graphics.gd/classdb/GLTFMesh"
import "graphics.gd/classdb/GLTFNode"
import "graphics.gd/classdb/GLTFSkeleton"
import "graphics.gd/classdb/GLTFSkin"
import "graphics.gd/classdb/GLTFTexture"
import "graphics.gd/classdb/GLTFTextureSampler"
import "graphics.gd/classdb/Material"
import "graphics.gd/classdb/Node"
import "graphics.gd/classdb/Resource"
import "graphics.gd/classdb/Texture2D"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Signal.Any
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
Contains all nodes and resources of a glTF file. This is used by [GLTFDocument] as data storage, which allows [GLTFDocument] and all [GLTFDocumentExtension] classes to remain stateless.
GLTFState can be populated by [GLTFDocument] reading a file or by converting a Godot scene. Then the data can either be used to create a Godot scene or save to a glTF file. The code that converts to/from a Godot scene can be intercepted at arbitrary points by [GLTFDocumentExtension] classes. This allows for custom data to be stored in the glTF file or for custom data to be converted to/from Godot nodes.
*/
type Instance [1]gdclass.GLTFState

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	add_used_extension           gdextension.MethodForClass `hash:"2678287736"`
	append_data_to_buffers       gdextension.MethodForClass `hash:"1460416665"`
	append_gltf_node             gdextension.MethodForClass `hash:"3562288551"`
	get_json                     gdextension.MethodForClass `hash:"2382534195"`
	set_json                     gdextension.MethodForClass `hash:"4155329257"`
	get_major_version            gdextension.MethodForClass `hash:"2455072627"`
	set_major_version            gdextension.MethodForClass `hash:"1286410249"`
	get_minor_version            gdextension.MethodForClass `hash:"2455072627"`
	set_minor_version            gdextension.MethodForClass `hash:"1286410249"`
	get_copyright                gdextension.MethodForClass `hash:"201670096"`
	set_copyright                gdextension.MethodForClass `hash:"83702148"`
	get_glb_data                 gdextension.MethodForClass `hash:"2115431945"`
	set_glb_data                 gdextension.MethodForClass `hash:"2971499966"`
	get_use_named_skin_binds     gdextension.MethodForClass `hash:"2240911060"`
	set_use_named_skin_binds     gdextension.MethodForClass `hash:"2586408642"`
	get_nodes                    gdextension.MethodForClass `hash:"2915620761"`
	set_nodes                    gdextension.MethodForClass `hash:"381264803"`
	get_buffers                  gdextension.MethodForClass `hash:"2915620761"`
	set_buffers                  gdextension.MethodForClass `hash:"381264803"`
	get_buffer_views             gdextension.MethodForClass `hash:"2915620761"`
	set_buffer_views             gdextension.MethodForClass `hash:"381264803"`
	get_accessors                gdextension.MethodForClass `hash:"2915620761"`
	set_accessors                gdextension.MethodForClass `hash:"381264803"`
	get_meshes                   gdextension.MethodForClass `hash:"2915620761"`
	set_meshes                   gdextension.MethodForClass `hash:"381264803"`
	get_animation_players_count  gdextension.MethodForClass `hash:"3744713108"`
	get_animation_player         gdextension.MethodForClass `hash:"925043400"`
	get_materials                gdextension.MethodForClass `hash:"2915620761"`
	set_materials                gdextension.MethodForClass `hash:"381264803"`
	get_scene_name               gdextension.MethodForClass `hash:"2841200299"`
	set_scene_name               gdextension.MethodForClass `hash:"83702148"`
	get_base_path                gdextension.MethodForClass `hash:"2841200299"`
	set_base_path                gdextension.MethodForClass `hash:"83702148"`
	get_filename                 gdextension.MethodForClass `hash:"201670096"`
	set_filename                 gdextension.MethodForClass `hash:"83702148"`
	get_root_nodes               gdextension.MethodForClass `hash:"969006518"`
	set_root_nodes               gdextension.MethodForClass `hash:"3614634198"`
	get_textures                 gdextension.MethodForClass `hash:"2915620761"`
	set_textures                 gdextension.MethodForClass `hash:"381264803"`
	get_texture_samplers         gdextension.MethodForClass `hash:"2915620761"`
	set_texture_samplers         gdextension.MethodForClass `hash:"381264803"`
	get_images                   gdextension.MethodForClass `hash:"2915620761"`
	set_images                   gdextension.MethodForClass `hash:"381264803"`
	get_skins                    gdextension.MethodForClass `hash:"2915620761"`
	set_skins                    gdextension.MethodForClass `hash:"381264803"`
	get_cameras                  gdextension.MethodForClass `hash:"2915620761"`
	set_cameras                  gdextension.MethodForClass `hash:"381264803"`
	get_lights                   gdextension.MethodForClass `hash:"2915620761"`
	set_lights                   gdextension.MethodForClass `hash:"381264803"`
	get_unique_names             gdextension.MethodForClass `hash:"2915620761"`
	set_unique_names             gdextension.MethodForClass `hash:"381264803"`
	get_unique_animation_names   gdextension.MethodForClass `hash:"2915620761"`
	set_unique_animation_names   gdextension.MethodForClass `hash:"381264803"`
	get_skeletons                gdextension.MethodForClass `hash:"2915620761"`
	set_skeletons                gdextension.MethodForClass `hash:"381264803"`
	get_create_animations        gdextension.MethodForClass `hash:"2240911060"`
	set_create_animations        gdextension.MethodForClass `hash:"2586408642"`
	get_import_as_skeleton_bones gdextension.MethodForClass `hash:"2240911060"`
	set_import_as_skeleton_bones gdextension.MethodForClass `hash:"2586408642"`
	get_animations               gdextension.MethodForClass `hash:"2915620761"`
	set_animations               gdextension.MethodForClass `hash:"381264803"`
	get_scene_node               gdextension.MethodForClass `hash:"4253421667"`
	get_node_index               gdextension.MethodForClass `hash:"1205807060"`
	get_additional_data          gdextension.MethodForClass `hash:"2138907829"`
	set_additional_data          gdextension.MethodForClass `hash:"3776071444"`
	get_handle_binary_image      gdextension.MethodForClass `hash:"2455072627"`
	set_handle_binary_image      gdextension.MethodForClass `hash:"1286410249"`
	set_bake_fps                 gdextension.MethodForClass `hash:"373806689"`
	get_bake_fps                 gdextension.MethodForClass `hash:"1740695150"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("GLTFState")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		gdextension.Free(gdextension.TypeStringName, &sname)
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

type Expanded [1]gdclass.GLTFState

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsGLTFState() Instance
}

/*
Appends an extension to the list of extensions used by this glTF file during serialization. If [param required] is [code]true[/code], the extension will also be added to the list of required extensions. Do not run this in [method GLTFDocumentExtension._export_post], as that stage is too late to add extensions. The final list is sorted alphabetically.
*/
func (self Instance) AddUsedExtension(extension_name string, required bool) { //gd:GLTFState.add_used_extension
	Advanced(self).AddUsedExtension(String.New(extension_name), required)
}

/*
Appends the given byte array data to the buffers and creates a [GLTFBufferView] for it. The index of the destination [GLTFBufferView] is returned. If [param deduplication] is [code]true[/code], the buffers will first be searched for duplicate data, otherwise new bytes will always be appended.
*/
func (self Instance) AppendDataToBuffers(data []byte, deduplication bool) int { //gd:GLTFState.append_data_to_buffers
	return int(int(Advanced(self).AppendDataToBuffers(Packed.Bytes(Packed.New(data...)), deduplication)))
}

/*
Append the given [GLTFNode] to the state, and return its new index. This can be used to export one Godot node as multiple glTF nodes, or inject new glTF nodes at import time. On import, this must be called before [method GLTFDocumentExtension._generate_scene_node] finishes for the parent node. On export, this must be called before [method GLTFDocumentExtension._export_node] runs for the parent node.
The [param godot_scene_node] parameter is the Godot scene node that corresponds to this glTF node. This is highly recommended to be set to a valid node, but may be [code]null[/code] if there is no corresponding Godot scene node. One Godot scene node may be used for multiple glTF nodes, so if exporting multiple glTF nodes for one Godot scene node, use the same Godot scene node for each.
The [param parent_node_index] parameter is the index of the parent [GLTFNode] in the state. If [code]-1[/code], the node will be a root node, otherwise the new node will be added to the parent's list of children. The index will also be written to the [member GLTFNode.parent] property of the new node.
*/
func (self Instance) AppendGltfNode(gltf_node GLTFNode.Instance, godot_scene_node Node.Instance, parent_node_index int) int { //gd:GLTFState.append_gltf_node
	return int(int(Advanced(self).AppendGltfNode(gltf_node, godot_scene_node, int64(parent_node_index))))
}

/*
Returns the number of [AnimationPlayer] nodes in this [GLTFState]. These nodes are only used during the export process when converting Godot [AnimationPlayer] nodes to glTF animations.
*/
func (self Instance) GetAnimationPlayersCount(idx int) int { //gd:GLTFState.get_animation_players_count
	return int(int(Advanced(self).GetAnimationPlayersCount(int64(idx))))
}

/*
Returns the [AnimationPlayer] node with the given index. These nodes are only used during the export process when converting Godot [AnimationPlayer] nodes to glTF animations.
*/
func (self Instance) GetAnimationPlayer(idx int) AnimationPlayer.Instance { //gd:GLTFState.get_animation_player
	return AnimationPlayer.Instance(Advanced(self).GetAnimationPlayer(int64(idx)))
}

/*
Returns the Godot scene node that corresponds to the same index as the [GLTFNode] it was generated from. This is the inverse of [method get_node_index]. Useful during the import process.
[b]Note:[/b] Not every [GLTFNode] will have a scene node generated, and not every generated scene node will have a corresponding [GLTFNode]. If there is no scene node for this [GLTFNode] index, [code]null[/code] is returned.
*/
func (self Instance) GetSceneNode(idx int) Node.Instance { //gd:GLTFState.get_scene_node
	return Node.Instance(Advanced(self).GetSceneNode(int64(idx)))
}

/*
Returns the index of the [GLTFNode] corresponding to this Godot scene node. This is the inverse of [method get_scene_node]. Useful during the export process.
[b]Note:[/b] Not every Godot scene node will have a corresponding [GLTFNode], and not every [GLTFNode] will have a scene node generated. If there is no [GLTFNode] index for this scene node, [code]-1[/code] is returned.
*/
func (self Instance) GetNodeIndex(scene_node Node.Instance) int { //gd:GLTFState.get_node_index
	return int(int(Advanced(self).GetNodeIndex(scene_node)))
}

/*
Gets additional arbitrary data in this [GLTFState] instance. This can be used to keep per-file state data in [GLTFDocumentExtension] classes, which is important because they are stateless.
The argument should be the [GLTFDocumentExtension] name (does not have to match the extension name in the glTF file), and the return value can be anything you set. If nothing was set, the return value is [code]null[/code].
*/
func (self Instance) GetAdditionalData(extension_name string) any { //gd:GLTFState.get_additional_data
	return any(Advanced(self).GetAdditionalData(String.Name(String.New(extension_name))).Interface())
}

/*
Sets additional arbitrary data in this [GLTFState] instance. This can be used to keep per-file state data in [GLTFDocumentExtension] classes, which is important because they are stateless.
The first argument should be the [GLTFDocumentExtension] name (does not have to match the extension name in the glTF file), and the second argument can be anything you want.
*/
func (self Instance) SetAdditionalData(extension_name string, additional_data any) { //gd:GLTFState.set_additional_data
	Advanced(self).SetAdditionalData(String.Name(String.New(extension_name)), variant.New(additional_data))
}

/*
Returns the [NodePath] that this GLTF node will have in the Godot scene tree after being imported. This is useful when importing glTF object model pointers with [GLTFObjectModelProperty], for handling extensions such as [code]KHR_animation_pointer[/code] or [code]KHR_interactivity[/code].
If [param handle_skeletons] is [code]true[/code], paths to skeleton bone glTF nodes will be resolved properly. For example, a path that would be [code]^"A/B/C/Bone1/Bone2/Bone3"[/code] if [code]false[/code] will become [code]^"A/B/C/Skeleton3D:Bone3"[/code].
*/
func (self Instance) GetSceneNodePath(peer GLTFNode.Instance) string { //gd:GLTFNode.get_scene_node_path
	return string(GLTFNode.Advanced(peer).GetSceneNodePath(self, true).String())
}

/*
Returns the [NodePath] that this GLTF node will have in the Godot scene tree after being imported. This is useful when importing glTF object model pointers with [GLTFObjectModelProperty], for handling extensions such as [code]KHR_animation_pointer[/code] or [code]KHR_interactivity[/code].
If [param handle_skeletons] is [code]true[/code], paths to skeleton bone glTF nodes will be resolved properly. For example, a path that would be [code]^"A/B/C/Bone1/Bone2/Bone3"[/code] if [code]false[/code] will become [code]^"A/B/C/Skeleton3D:Bone3"[/code].
*/
func (self Expanded) GetSceneNodePath(peer GLTFNode.Instance, handle_skeletons bool) string { //gd:GLTFNode.get_scene_node_path
	return string(GLTFNode.Advanced(peer).GetSceneNodePath(self, handle_skeletons).String())
}

/*
Loads the buffer view data from the buffer referenced by this buffer view in the given [GLTFState]. Interleaved data with a byte stride is not yet supported by this method. The data is returned as a [PackedByteArray].
*/
func (self Instance) LoadBufferViewData(peer GLTFBufferView.Instance) []byte { //gd:GLTFBufferView.load_buffer_view_data
	return []byte(GLTFBufferView.Advanced(peer).LoadBufferViewData(self).Bytes())
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.GLTFState

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = pointers.AsA[gdclass.GLTFState](obj[0])
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = pointers.AsA[gdclass.GLTFState](obj[0])
		return true
	}
	return false
}
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }
func (self *Extension[T]) AsObject() [1]gd.Object { return self.Super().AsObject() }
func New() Instance {
	if !gd.Linked {
		var placeholder = Instance([1]gdclass.GLTFState{pointers.Add[gdclass.GLTFState]([3]uint64{})})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(pointers.AsA[gd.Object](placeholder[0]), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	casted := Instance([1]gdclass.GLTFState{pointers.New[gdclass.GLTFState]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})})
	casted.AsRefCounted()[0].InitRef()
	casted.AsObject()[0].Notification(0, false)
	return casted
}

func (self Instance) Json() map[any]any {
	return map[any]any(gd.DictionaryAs[map[any]any](class(self).GetJson()))
}

func (self Instance) SetJson(value map[any]any) {
	class(self).SetJson(gd.DictionaryFromMap(value))
}

func (self Instance) MajorVersion() int {
	return int(int(class(self).GetMajorVersion()))
}

func (self Instance) SetMajorVersion(value int) {
	class(self).SetMajorVersion(int64(value))
}

func (self Instance) MinorVersion() int {
	return int(int(class(self).GetMinorVersion()))
}

func (self Instance) SetMinorVersion(value int) {
	class(self).SetMinorVersion(int64(value))
}

func (self Instance) Copyright() string {
	return string(class(self).GetCopyright().String())
}

func (self Instance) SetCopyright(value string) {
	class(self).SetCopyright(String.New(value))
}

func (self Instance) GlbData() []byte {
	return []byte(class(self).GetGlbData().Bytes())
}

func (self Instance) SetGlbData(value []byte) {
	class(self).SetGlbData(Packed.Bytes(Packed.New(value...)))
}

func (self Instance) UseNamedSkinBinds() bool {
	return bool(class(self).GetUseNamedSkinBinds())
}

func (self Instance) SetUseNamedSkinBinds(value bool) {
	class(self).SetUseNamedSkinBinds(value)
}

func (self Instance) Nodes() []GLTFNode.Instance {
	return []GLTFNode.Instance(gd.ArrayAs[[]GLTFNode.Instance](gd.InternalArray(class(self).GetNodes())))
}

func (self Instance) SetNodes(value []GLTFNode.Instance) {
	class(self).SetNodes(gd.ArrayFromSlice[Array.Contains[[1]gdclass.GLTFNode]](value))
}

func (self Instance) Buffers() [][]byte {
	return [][]byte(gd.ArrayAs[[][]byte](gd.InternalArray(class(self).GetBuffers())))
}

func (self Instance) SetBuffers(value [][]byte) {
	class(self).SetBuffers(gd.ArrayFromSlice[Array.Contains[Packed.Bytes]](value))
}

func (self Instance) BufferViews() []GLTFBufferView.Instance {
	return []GLTFBufferView.Instance(gd.ArrayAs[[]GLTFBufferView.Instance](gd.InternalArray(class(self).GetBufferViews())))
}

func (self Instance) SetBufferViews(value []GLTFBufferView.Instance) {
	class(self).SetBufferViews(gd.ArrayFromSlice[Array.Contains[[1]gdclass.GLTFBufferView]](value))
}

func (self Instance) Accessors() []GLTFAccessor.Instance {
	return []GLTFAccessor.Instance(gd.ArrayAs[[]GLTFAccessor.Instance](gd.InternalArray(class(self).GetAccessors())))
}

func (self Instance) SetAccessors(value []GLTFAccessor.Instance) {
	class(self).SetAccessors(gd.ArrayFromSlice[Array.Contains[[1]gdclass.GLTFAccessor]](value))
}

func (self Instance) Meshes() []GLTFMesh.Instance {
	return []GLTFMesh.Instance(gd.ArrayAs[[]GLTFMesh.Instance](gd.InternalArray(class(self).GetMeshes())))
}

func (self Instance) SetMeshes(value []GLTFMesh.Instance) {
	class(self).SetMeshes(gd.ArrayFromSlice[Array.Contains[[1]gdclass.GLTFMesh]](value))
}

func (self Instance) Materials() []Material.Instance {
	return []Material.Instance(gd.ArrayAs[[]Material.Instance](gd.InternalArray(class(self).GetMaterials())))
}

func (self Instance) SetMaterials(value []Material.Instance) {
	class(self).SetMaterials(gd.ArrayFromSlice[Array.Contains[[1]gdclass.Material]](value))
}

func (self Instance) SceneName() string {
	return string(class(self).GetSceneName().String())
}

func (self Instance) SetSceneName(value string) {
	class(self).SetSceneName(String.New(value))
}

func (self Instance) BasePath() string {
	return string(class(self).GetBasePath().String())
}

func (self Instance) SetBasePath(value string) {
	class(self).SetBasePath(String.New(value))
}

func (self Instance) Filename() string {
	return string(class(self).GetFilename().String())
}

func (self Instance) SetFilename(value string) {
	class(self).SetFilename(String.New(value))
}

func (self Instance) RootNodes() []int32 {
	return []int32(slices.Collect(class(self).GetRootNodes().Values()))
}

func (self Instance) SetRootNodes(value []int32) {
	class(self).SetRootNodes(Packed.New(value...))
}

func (self Instance) Textures() []GLTFTexture.Instance {
	return []GLTFTexture.Instance(gd.ArrayAs[[]GLTFTexture.Instance](gd.InternalArray(class(self).GetTextures())))
}

func (self Instance) SetTextures(value []GLTFTexture.Instance) {
	class(self).SetTextures(gd.ArrayFromSlice[Array.Contains[[1]gdclass.GLTFTexture]](value))
}

func (self Instance) TextureSamplers() []GLTFTextureSampler.Instance {
	return []GLTFTextureSampler.Instance(gd.ArrayAs[[]GLTFTextureSampler.Instance](gd.InternalArray(class(self).GetTextureSamplers())))
}

func (self Instance) SetTextureSamplers(value []GLTFTextureSampler.Instance) {
	class(self).SetTextureSamplers(gd.ArrayFromSlice[Array.Contains[[1]gdclass.GLTFTextureSampler]](value))
}

func (self Instance) Images() []Texture2D.Instance {
	return []Texture2D.Instance(gd.ArrayAs[[]Texture2D.Instance](gd.InternalArray(class(self).GetImages())))
}

func (self Instance) SetImages(value []Texture2D.Instance) {
	class(self).SetImages(gd.ArrayFromSlice[Array.Contains[[1]gdclass.Texture2D]](value))
}

func (self Instance) Skins() []GLTFSkin.Instance {
	return []GLTFSkin.Instance(gd.ArrayAs[[]GLTFSkin.Instance](gd.InternalArray(class(self).GetSkins())))
}

func (self Instance) SetSkins(value []GLTFSkin.Instance) {
	class(self).SetSkins(gd.ArrayFromSlice[Array.Contains[[1]gdclass.GLTFSkin]](value))
}

func (self Instance) Cameras() []GLTFCamera.Instance {
	return []GLTFCamera.Instance(gd.ArrayAs[[]GLTFCamera.Instance](gd.InternalArray(class(self).GetCameras())))
}

func (self Instance) SetCameras(value []GLTFCamera.Instance) {
	class(self).SetCameras(gd.ArrayFromSlice[Array.Contains[[1]gdclass.GLTFCamera]](value))
}

func (self Instance) Lights() []GLTFLight.Instance {
	return []GLTFLight.Instance(gd.ArrayAs[[]GLTFLight.Instance](gd.InternalArray(class(self).GetLights())))
}

func (self Instance) SetLights(value []GLTFLight.Instance) {
	class(self).SetLights(gd.ArrayFromSlice[Array.Contains[[1]gdclass.GLTFLight]](value))
}

func (self Instance) UniqueNames() []string {
	return []string(gd.ArrayAs[[]string](gd.InternalArray(class(self).GetUniqueNames())))
}

func (self Instance) SetUniqueNames(value []string) {
	class(self).SetUniqueNames(gd.ArrayFromSlice[Array.Contains[String.Readable]](value))
}

func (self Instance) UniqueAnimationNames() []string {
	return []string(gd.ArrayAs[[]string](gd.InternalArray(class(self).GetUniqueAnimationNames())))
}

func (self Instance) SetUniqueAnimationNames(value []string) {
	class(self).SetUniqueAnimationNames(gd.ArrayFromSlice[Array.Contains[String.Readable]](value))
}

func (self Instance) Skeletons() []GLTFSkeleton.Instance {
	return []GLTFSkeleton.Instance(gd.ArrayAs[[]GLTFSkeleton.Instance](gd.InternalArray(class(self).GetSkeletons())))
}

func (self Instance) SetSkeletons(value []GLTFSkeleton.Instance) {
	class(self).SetSkeletons(gd.ArrayFromSlice[Array.Contains[[1]gdclass.GLTFSkeleton]](value))
}

func (self Instance) CreateAnimations() bool {
	return bool(class(self).GetCreateAnimations())
}

func (self Instance) SetCreateAnimations(value bool) {
	class(self).SetCreateAnimations(value)
}

func (self Instance) ImportAsSkeletonBones() bool {
	return bool(class(self).GetImportAsSkeletonBones())
}

func (self Instance) SetImportAsSkeletonBones(value bool) {
	class(self).SetImportAsSkeletonBones(value)
}

func (self Instance) Animations() []GLTFAnimation.Instance {
	return []GLTFAnimation.Instance(gd.ArrayAs[[]GLTFAnimation.Instance](gd.InternalArray(class(self).GetAnimations())))
}

func (self Instance) SetAnimations(value []GLTFAnimation.Instance) {
	class(self).SetAnimations(gd.ArrayFromSlice[Array.Contains[[1]gdclass.GLTFAnimation]](value))
}

func (self Instance) HandleBinaryImage() BinaryHandler {
	return BinaryHandler(int(class(self).GetHandleBinaryImage()))
}

func (self Instance) SetHandleBinaryImage(value BinaryHandler) {
	class(self).SetHandleBinaryImage(int64(value))
}

func (self Instance) BakeFps() Float.X {
	return Float.X(Float.X(class(self).GetBakeFps()))
}

func (self Instance) SetBakeFps(value Float.X) {
	class(self).SetBakeFps(float64(value))
}

/*
Appends an extension to the list of extensions used by this glTF file during serialization. If [param required] is [code]true[/code], the extension will also be added to the list of required extensions. Do not run this in [method GLTFDocumentExtension._export_post], as that stage is too late to add extensions. The final list is sorted alphabetically.
*/
//go:nosplit
func (self class) AddUsedExtension(extension_name String.Readable, required bool) { //gd:GLTFState.add_used_extension
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_used_extension, 0|(gdextension.SizeString<<4)|(gdextension.SizeBool<<8), &struct {
		extension_name gdextension.String
		required       bool
	}{pointers.Get(gd.InternalString(extension_name)), required})
}

/*
Appends the given byte array data to the buffers and creates a [GLTFBufferView] for it. The index of the destination [GLTFBufferView] is returned. If [param deduplication] is [code]true[/code], the buffers will first be searched for duplicate data, otherwise new bytes will always be appended.
*/
//go:nosplit
func (self class) AppendDataToBuffers(data Packed.Bytes, deduplication bool) int64 { //gd:GLTFState.append_data_to_buffers
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.append_data_to_buffers, gdextension.SizeInt|(gdextension.SizePackedArray<<4)|(gdextension.SizeBool<<8), &struct {
		data          gdextension.PackedArray[byte]
		deduplication bool
	}{pointers.Get(gd.InternalPacked[gd.PackedByteArray, byte](Packed.Array[byte](data))), deduplication})
	var ret = r_ret
	return ret
}

/*
Append the given [GLTFNode] to the state, and return its new index. This can be used to export one Godot node as multiple glTF nodes, or inject new glTF nodes at import time. On import, this must be called before [method GLTFDocumentExtension._generate_scene_node] finishes for the parent node. On export, this must be called before [method GLTFDocumentExtension._export_node] runs for the parent node.
The [param godot_scene_node] parameter is the Godot scene node that corresponds to this glTF node. This is highly recommended to be set to a valid node, but may be [code]null[/code] if there is no corresponding Godot scene node. One Godot scene node may be used for multiple glTF nodes, so if exporting multiple glTF nodes for one Godot scene node, use the same Godot scene node for each.
The [param parent_node_index] parameter is the index of the parent [GLTFNode] in the state. If [code]-1[/code], the node will be a root node, otherwise the new node will be added to the parent's list of children. The index will also be written to the [member GLTFNode.parent] property of the new node.
*/
//go:nosplit
func (self class) AppendGltfNode(gltf_node [1]gdclass.GLTFNode, godot_scene_node [1]gdclass.Node, parent_node_index int64) int64 { //gd:GLTFState.append_gltf_node
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.append_gltf_node, gdextension.SizeInt|(gdextension.SizeObject<<4)|(gdextension.SizeObject<<8)|(gdextension.SizeInt<<12), &struct {
		gltf_node         gdextension.Object
		godot_scene_node  gdextension.Object
		parent_node_index int64
	}{gdextension.Object(gd.ObjectChecked(gltf_node[0].AsObject())), gdextension.Object(gd.ObjectChecked(godot_scene_node[0].AsObject())), parent_node_index})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) GetJson() Dictionary.Any { //gd:GLTFState.get_json
	var r_ret = gdextension.Call[gdextension.Dictionary](gd.ObjectChecked(self.AsObject()), methods.get_json, gdextension.SizeDictionary, &struct{}{})
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret)))
	return ret
}

//go:nosplit
func (self class) SetJson(json Dictionary.Any) { //gd:GLTFState.set_json
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_json, 0|(gdextension.SizeDictionary<<4), &struct{ json gdextension.Dictionary }{pointers.Get(gd.InternalDictionary(json))})
}

//go:nosplit
func (self class) GetMajorVersion() int64 { //gd:GLTFState.get_major_version
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_major_version, gdextension.SizeInt, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetMajorVersion(major_version int64) { //gd:GLTFState.set_major_version
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_major_version, 0|(gdextension.SizeInt<<4), &struct{ major_version int64 }{major_version})
}

//go:nosplit
func (self class) GetMinorVersion() int64 { //gd:GLTFState.get_minor_version
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_minor_version, gdextension.SizeInt, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetMinorVersion(minor_version int64) { //gd:GLTFState.set_minor_version
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_minor_version, 0|(gdextension.SizeInt<<4), &struct{ minor_version int64 }{minor_version})
}

//go:nosplit
func (self class) GetCopyright() String.Readable { //gd:GLTFState.get_copyright
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_copyright, gdextension.SizeString, &struct{}{})
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

//go:nosplit
func (self class) SetCopyright(copyright String.Readable) { //gd:GLTFState.set_copyright
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_copyright, 0|(gdextension.SizeString<<4), &struct{ copyright gdextension.String }{pointers.Get(gd.InternalString(copyright))})
}

//go:nosplit
func (self class) GetGlbData() Packed.Bytes { //gd:GLTFState.get_glb_data
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.get_glb_data, gdextension.SizePackedArray, &struct{}{})
	var ret = Packed.Bytes(Array.Through(gd.PackedProxy[gd.PackedByteArray, byte]{}, pointers.Pack(pointers.Let[gd.PackedByteArray](r_ret))))
	return ret
}

//go:nosplit
func (self class) SetGlbData(glb_data Packed.Bytes) { //gd:GLTFState.set_glb_data
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_glb_data, 0|(gdextension.SizePackedArray<<4), &struct{ glb_data gdextension.PackedArray[byte] }{pointers.Get(gd.InternalPacked[gd.PackedByteArray, byte](Packed.Array[byte](glb_data)))})
}

//go:nosplit
func (self class) GetUseNamedSkinBinds() bool { //gd:GLTFState.get_use_named_skin_binds
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.get_use_named_skin_binds, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetUseNamedSkinBinds(use_named_skin_binds bool) { //gd:GLTFState.set_use_named_skin_binds
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_use_named_skin_binds, 0|(gdextension.SizeBool<<4), &struct{ use_named_skin_binds bool }{use_named_skin_binds})
}

/*
Returns an array of all [GLTFNode]s in the glTF file. These are the nodes that [member GLTFNode.children] and [member root_nodes] refer to. This includes nodes that may not be generated in the Godot scene, or nodes that may generate multiple Godot scene nodes.
*/
//go:nosplit
func (self class) GetNodes() Array.Contains[[1]gdclass.GLTFNode] { //gd:GLTFState.get_nodes
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), methods.get_nodes, gdextension.SizeArray, &struct{}{})
	var ret = Array.Through(gd.ArrayProxy[[1]gdclass.GLTFNode]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

/*
Sets the [GLTFNode]s in the state. These are the nodes that [member GLTFNode.children] and [member root_nodes] refer to. Some of the nodes set here may not be generated in the Godot scene, or may generate multiple Godot scene nodes.
*/
//go:nosplit
func (self class) SetNodes(nodes Array.Contains[[1]gdclass.GLTFNode]) { //gd:GLTFState.set_nodes
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_nodes, 0|(gdextension.SizeArray<<4), &struct{ nodes gdextension.Array }{pointers.Get(gd.InternalArray(nodes))})
}

//go:nosplit
func (self class) GetBuffers() Array.Contains[Packed.Bytes] { //gd:GLTFState.get_buffers
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), methods.get_buffers, gdextension.SizeArray, &struct{}{})
	var ret = Array.Through(gd.ArrayProxy[Packed.Bytes]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

//go:nosplit
func (self class) SetBuffers(buffers Array.Contains[Packed.Bytes]) { //gd:GLTFState.set_buffers
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_buffers, 0|(gdextension.SizeArray<<4), &struct{ buffers gdextension.Array }{pointers.Get(gd.InternalArray(buffers))})
}

//go:nosplit
func (self class) GetBufferViews() Array.Contains[[1]gdclass.GLTFBufferView] { //gd:GLTFState.get_buffer_views
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), methods.get_buffer_views, gdextension.SizeArray, &struct{}{})
	var ret = Array.Through(gd.ArrayProxy[[1]gdclass.GLTFBufferView]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

//go:nosplit
func (self class) SetBufferViews(buffer_views Array.Contains[[1]gdclass.GLTFBufferView]) { //gd:GLTFState.set_buffer_views
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_buffer_views, 0|(gdextension.SizeArray<<4), &struct{ buffer_views gdextension.Array }{pointers.Get(gd.InternalArray(buffer_views))})
}

//go:nosplit
func (self class) GetAccessors() Array.Contains[[1]gdclass.GLTFAccessor] { //gd:GLTFState.get_accessors
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), methods.get_accessors, gdextension.SizeArray, &struct{}{})
	var ret = Array.Through(gd.ArrayProxy[[1]gdclass.GLTFAccessor]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

//go:nosplit
func (self class) SetAccessors(accessors Array.Contains[[1]gdclass.GLTFAccessor]) { //gd:GLTFState.set_accessors
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_accessors, 0|(gdextension.SizeArray<<4), &struct{ accessors gdextension.Array }{pointers.Get(gd.InternalArray(accessors))})
}

/*
Returns an array of all [GLTFMesh]es in the glTF file. These are the meshes that the [member GLTFNode.mesh] index refers to.
*/
//go:nosplit
func (self class) GetMeshes() Array.Contains[[1]gdclass.GLTFMesh] { //gd:GLTFState.get_meshes
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), methods.get_meshes, gdextension.SizeArray, &struct{}{})
	var ret = Array.Through(gd.ArrayProxy[[1]gdclass.GLTFMesh]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

/*
Sets the [GLTFMesh]es in the state. These are the meshes that the [member GLTFNode.mesh] index refers to.
*/
//go:nosplit
func (self class) SetMeshes(meshes Array.Contains[[1]gdclass.GLTFMesh]) { //gd:GLTFState.set_meshes
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_meshes, 0|(gdextension.SizeArray<<4), &struct{ meshes gdextension.Array }{pointers.Get(gd.InternalArray(meshes))})
}

/*
Returns the number of [AnimationPlayer] nodes in this [GLTFState]. These nodes are only used during the export process when converting Godot [AnimationPlayer] nodes to glTF animations.
*/
//go:nosplit
func (self class) GetAnimationPlayersCount(idx int64) int64 { //gd:GLTFState.get_animation_players_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_animation_players_count, gdextension.SizeInt|(gdextension.SizeInt<<4), &struct{ idx int64 }{idx})
	var ret = r_ret
	return ret
}

/*
Returns the [AnimationPlayer] node with the given index. These nodes are only used during the export process when converting Godot [AnimationPlayer] nodes to glTF animations.
*/
//go:nosplit
func (self class) GetAnimationPlayer(idx int64) [1]gdclass.AnimationPlayer { //gd:GLTFState.get_animation_player
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_animation_player, gdextension.SizeObject|(gdextension.SizeInt<<4), &struct{ idx int64 }{idx})
	var ret = [1]gdclass.AnimationPlayer{gd.PointerMustAssertInstanceID[gdclass.AnimationPlayer](r_ret)}
	return ret
}

//go:nosplit
func (self class) GetMaterials() Array.Contains[[1]gdclass.Material] { //gd:GLTFState.get_materials
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), methods.get_materials, gdextension.SizeArray, &struct{}{})
	var ret = Array.Through(gd.ArrayProxy[[1]gdclass.Material]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

//go:nosplit
func (self class) SetMaterials(materials Array.Contains[[1]gdclass.Material]) { //gd:GLTFState.set_materials
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_materials, 0|(gdextension.SizeArray<<4), &struct{ materials gdextension.Array }{pointers.Get(gd.InternalArray(materials))})
}

//go:nosplit
func (self class) GetSceneName() String.Readable { //gd:GLTFState.get_scene_name
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_scene_name, gdextension.SizeString, &struct{}{})
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

//go:nosplit
func (self class) SetSceneName(scene_name String.Readable) { //gd:GLTFState.set_scene_name
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_scene_name, 0|(gdextension.SizeString<<4), &struct{ scene_name gdextension.String }{pointers.Get(gd.InternalString(scene_name))})
}

//go:nosplit
func (self class) GetBasePath() String.Readable { //gd:GLTFState.get_base_path
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_base_path, gdextension.SizeString, &struct{}{})
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

//go:nosplit
func (self class) SetBasePath(base_path String.Readable) { //gd:GLTFState.set_base_path
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_base_path, 0|(gdextension.SizeString<<4), &struct{ base_path gdextension.String }{pointers.Get(gd.InternalString(base_path))})
}

//go:nosplit
func (self class) GetFilename() String.Readable { //gd:GLTFState.get_filename
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_filename, gdextension.SizeString, &struct{}{})
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

//go:nosplit
func (self class) SetFilename(filename String.Readable) { //gd:GLTFState.set_filename
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_filename, 0|(gdextension.SizeString<<4), &struct{ filename gdextension.String }{pointers.Get(gd.InternalString(filename))})
}

//go:nosplit
func (self class) GetRootNodes() Packed.Array[int32] { //gd:GLTFState.get_root_nodes
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.get_root_nodes, gdextension.SizePackedArray, &struct{}{})
	var ret = Packed.Array[int32](Array.Through(gd.PackedProxy[gd.PackedInt32Array, int32]{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

//go:nosplit
func (self class) SetRootNodes(root_nodes Packed.Array[int32]) { //gd:GLTFState.set_root_nodes
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_root_nodes, 0|(gdextension.SizePackedArray<<4), &struct {
		root_nodes gdextension.PackedArray[int32]
	}{pointers.Get(gd.InternalPacked[gd.PackedInt32Array, int32](root_nodes))})
}

//go:nosplit
func (self class) GetTextures() Array.Contains[[1]gdclass.GLTFTexture] { //gd:GLTFState.get_textures
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), methods.get_textures, gdextension.SizeArray, &struct{}{})
	var ret = Array.Through(gd.ArrayProxy[[1]gdclass.GLTFTexture]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

//go:nosplit
func (self class) SetTextures(textures Array.Contains[[1]gdclass.GLTFTexture]) { //gd:GLTFState.set_textures
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_textures, 0|(gdextension.SizeArray<<4), &struct{ textures gdextension.Array }{pointers.Get(gd.InternalArray(textures))})
}

/*
Retrieves the array of texture samplers that are used by the textures contained in the glTF.
*/
//go:nosplit
func (self class) GetTextureSamplers() Array.Contains[[1]gdclass.GLTFTextureSampler] { //gd:GLTFState.get_texture_samplers
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), methods.get_texture_samplers, gdextension.SizeArray, &struct{}{})
	var ret = Array.Through(gd.ArrayProxy[[1]gdclass.GLTFTextureSampler]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

/*
Sets the array of texture samplers that are used by the textures contained in the glTF.
*/
//go:nosplit
func (self class) SetTextureSamplers(texture_samplers Array.Contains[[1]gdclass.GLTFTextureSampler]) { //gd:GLTFState.set_texture_samplers
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_texture_samplers, 0|(gdextension.SizeArray<<4), &struct{ texture_samplers gdextension.Array }{pointers.Get(gd.InternalArray(texture_samplers))})
}

/*
Gets the images of the glTF file as an array of [Texture2D]s. These are the images that the [member GLTFTexture.src_image] index refers to.
*/
//go:nosplit
func (self class) GetImages() Array.Contains[[1]gdclass.Texture2D] { //gd:GLTFState.get_images
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), methods.get_images, gdextension.SizeArray, &struct{}{})
	var ret = Array.Through(gd.ArrayProxy[[1]gdclass.Texture2D]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

/*
Sets the images in the state stored as an array of [Texture2D]s. This can be used during export. These are the images that the [member GLTFTexture.src_image] index refers to.
*/
//go:nosplit
func (self class) SetImages(images Array.Contains[[1]gdclass.Texture2D]) { //gd:GLTFState.set_images
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_images, 0|(gdextension.SizeArray<<4), &struct{ images gdextension.Array }{pointers.Get(gd.InternalArray(images))})
}

/*
Returns an array of all [GLTFSkin]s in the glTF file. These are the skins that the [member GLTFNode.skin] index refers to.
*/
//go:nosplit
func (self class) GetSkins() Array.Contains[[1]gdclass.GLTFSkin] { //gd:GLTFState.get_skins
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), methods.get_skins, gdextension.SizeArray, &struct{}{})
	var ret = Array.Through(gd.ArrayProxy[[1]gdclass.GLTFSkin]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

/*
Sets the [GLTFSkin]s in the state. These are the skins that the [member GLTFNode.skin] index refers to.
*/
//go:nosplit
func (self class) SetSkins(skins Array.Contains[[1]gdclass.GLTFSkin]) { //gd:GLTFState.set_skins
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_skins, 0|(gdextension.SizeArray<<4), &struct{ skins gdextension.Array }{pointers.Get(gd.InternalArray(skins))})
}

/*
Returns an array of all [GLTFCamera]s in the glTF file. These are the cameras that the [member GLTFNode.camera] index refers to.
*/
//go:nosplit
func (self class) GetCameras() Array.Contains[[1]gdclass.GLTFCamera] { //gd:GLTFState.get_cameras
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), methods.get_cameras, gdextension.SizeArray, &struct{}{})
	var ret = Array.Through(gd.ArrayProxy[[1]gdclass.GLTFCamera]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

/*
Sets the [GLTFCamera]s in the state. These are the cameras that the [member GLTFNode.camera] index refers to.
*/
//go:nosplit
func (self class) SetCameras(cameras Array.Contains[[1]gdclass.GLTFCamera]) { //gd:GLTFState.set_cameras
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_cameras, 0|(gdextension.SizeArray<<4), &struct{ cameras gdextension.Array }{pointers.Get(gd.InternalArray(cameras))})
}

/*
Returns an array of all [GLTFLight]s in the glTF file. These are the lights that the [member GLTFNode.light] index refers to.
*/
//go:nosplit
func (self class) GetLights() Array.Contains[[1]gdclass.GLTFLight] { //gd:GLTFState.get_lights
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), methods.get_lights, gdextension.SizeArray, &struct{}{})
	var ret = Array.Through(gd.ArrayProxy[[1]gdclass.GLTFLight]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

/*
Sets the [GLTFLight]s in the state. These are the lights that the [member GLTFNode.light] index refers to.
*/
//go:nosplit
func (self class) SetLights(lights Array.Contains[[1]gdclass.GLTFLight]) { //gd:GLTFState.set_lights
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_lights, 0|(gdextension.SizeArray<<4), &struct{ lights gdextension.Array }{pointers.Get(gd.InternalArray(lights))})
}

/*
Returns an array of unique node names. This is used in both the import process and export process.
*/
//go:nosplit
func (self class) GetUniqueNames() Array.Contains[String.Readable] { //gd:GLTFState.get_unique_names
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), methods.get_unique_names, gdextension.SizeArray, &struct{}{})
	var ret = Array.Through(gd.ArrayProxy[String.Readable]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

/*
Sets the unique node names in the state. This is used in both the import process and export process.
*/
//go:nosplit
func (self class) SetUniqueNames(unique_names Array.Contains[String.Readable]) { //gd:GLTFState.set_unique_names
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_unique_names, 0|(gdextension.SizeArray<<4), &struct{ unique_names gdextension.Array }{pointers.Get(gd.InternalArray(unique_names))})
}

/*
Returns an array of unique animation names. This is only used during the import process.
*/
//go:nosplit
func (self class) GetUniqueAnimationNames() Array.Contains[String.Readable] { //gd:GLTFState.get_unique_animation_names
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), methods.get_unique_animation_names, gdextension.SizeArray, &struct{}{})
	var ret = Array.Through(gd.ArrayProxy[String.Readable]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

/*
Sets the unique animation names in the state. This is only used during the import process.
*/
//go:nosplit
func (self class) SetUniqueAnimationNames(unique_animation_names Array.Contains[String.Readable]) { //gd:GLTFState.set_unique_animation_names
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_unique_animation_names, 0|(gdextension.SizeArray<<4), &struct{ unique_animation_names gdextension.Array }{pointers.Get(gd.InternalArray(unique_animation_names))})
}

/*
Returns an array of all [GLTFSkeleton]s in the glTF file. These are the skeletons that the [member GLTFNode.skeleton] index refers to.
*/
//go:nosplit
func (self class) GetSkeletons() Array.Contains[[1]gdclass.GLTFSkeleton] { //gd:GLTFState.get_skeletons
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), methods.get_skeletons, gdextension.SizeArray, &struct{}{})
	var ret = Array.Through(gd.ArrayProxy[[1]gdclass.GLTFSkeleton]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

/*
Sets the [GLTFSkeleton]s in the state. These are the skeletons that the [member GLTFNode.skeleton] index refers to.
*/
//go:nosplit
func (self class) SetSkeletons(skeletons Array.Contains[[1]gdclass.GLTFSkeleton]) { //gd:GLTFState.set_skeletons
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_skeletons, 0|(gdextension.SizeArray<<4), &struct{ skeletons gdextension.Array }{pointers.Get(gd.InternalArray(skeletons))})
}

//go:nosplit
func (self class) GetCreateAnimations() bool { //gd:GLTFState.get_create_animations
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.get_create_animations, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetCreateAnimations(create_animations bool) { //gd:GLTFState.set_create_animations
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_create_animations, 0|(gdextension.SizeBool<<4), &struct{ create_animations bool }{create_animations})
}

//go:nosplit
func (self class) GetImportAsSkeletonBones() bool { //gd:GLTFState.get_import_as_skeleton_bones
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.get_import_as_skeleton_bones, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetImportAsSkeletonBones(import_as_skeleton_bones bool) { //gd:GLTFState.set_import_as_skeleton_bones
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_import_as_skeleton_bones, 0|(gdextension.SizeBool<<4), &struct{ import_as_skeleton_bones bool }{import_as_skeleton_bones})
}

/*
Returns an array of all [GLTFAnimation]s in the glTF file. When importing, these will be generated as animations in an [AnimationPlayer] node. When exporting, these will be generated from Godot [AnimationPlayer] nodes.
*/
//go:nosplit
func (self class) GetAnimations() Array.Contains[[1]gdclass.GLTFAnimation] { //gd:GLTFState.get_animations
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), methods.get_animations, gdextension.SizeArray, &struct{}{})
	var ret = Array.Through(gd.ArrayProxy[[1]gdclass.GLTFAnimation]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

/*
Sets the [GLTFAnimation]s in the state. When importing, these will be generated as animations in an [AnimationPlayer] node. When exporting, these will be generated from Godot [AnimationPlayer] nodes.
*/
//go:nosplit
func (self class) SetAnimations(animations Array.Contains[[1]gdclass.GLTFAnimation]) { //gd:GLTFState.set_animations
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_animations, 0|(gdextension.SizeArray<<4), &struct{ animations gdextension.Array }{pointers.Get(gd.InternalArray(animations))})
}

/*
Returns the Godot scene node that corresponds to the same index as the [GLTFNode] it was generated from. This is the inverse of [method get_node_index]. Useful during the import process.
[b]Note:[/b] Not every [GLTFNode] will have a scene node generated, and not every generated scene node will have a corresponding [GLTFNode]. If there is no scene node for this [GLTFNode] index, [code]null[/code] is returned.
*/
//go:nosplit
func (self class) GetSceneNode(idx int64) [1]gdclass.Node { //gd:GLTFState.get_scene_node
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_scene_node, gdextension.SizeObject|(gdextension.SizeInt<<4), &struct{ idx int64 }{idx})
	var ret = [1]gdclass.Node{gd.PointerMustAssertInstanceID[gdclass.Node](r_ret)}
	return ret
}

/*
Returns the index of the [GLTFNode] corresponding to this Godot scene node. This is the inverse of [method get_scene_node]. Useful during the export process.
[b]Note:[/b] Not every Godot scene node will have a corresponding [GLTFNode], and not every [GLTFNode] will have a scene node generated. If there is no [GLTFNode] index for this scene node, [code]-1[/code] is returned.
*/
//go:nosplit
func (self class) GetNodeIndex(scene_node [1]gdclass.Node) int64 { //gd:GLTFState.get_node_index
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_node_index, gdextension.SizeInt|(gdextension.SizeObject<<4), &struct{ scene_node gdextension.Object }{gdextension.Object(gd.ObjectChecked(scene_node[0].AsObject()))})
	var ret = r_ret
	return ret
}

/*
Gets additional arbitrary data in this [GLTFState] instance. This can be used to keep per-file state data in [GLTFDocumentExtension] classes, which is important because they are stateless.
The argument should be the [GLTFDocumentExtension] name (does not have to match the extension name in the glTF file), and the return value can be anything you set. If nothing was set, the return value is [code]null[/code].
*/
//go:nosplit
func (self class) GetAdditionalData(extension_name String.Name) variant.Any { //gd:GLTFState.get_additional_data
	var r_ret = gdextension.Call[gdextension.Variant](gd.ObjectChecked(self.AsObject()), methods.get_additional_data, gdextension.SizeVariant|(gdextension.SizeStringName<<4), &struct{ extension_name gdextension.StringName }{pointers.Get(gd.InternalStringName(extension_name))})
	var ret = variant.Implementation(gd.VariantProxy{}, pointers.Pack(pointers.New[gd.Variant](r_ret)))
	return ret
}

/*
Sets additional arbitrary data in this [GLTFState] instance. This can be used to keep per-file state data in [GLTFDocumentExtension] classes, which is important because they are stateless.
The first argument should be the [GLTFDocumentExtension] name (does not have to match the extension name in the glTF file), and the second argument can be anything you want.
*/
//go:nosplit
func (self class) SetAdditionalData(extension_name String.Name, additional_data variant.Any) { //gd:GLTFState.set_additional_data
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_additional_data, 0|(gdextension.SizeStringName<<4)|(gdextension.SizeVariant<<8), &struct {
		extension_name  gdextension.StringName
		additional_data gdextension.Variant
	}{pointers.Get(gd.InternalStringName(extension_name)), gdextension.Variant(pointers.Get(gd.InternalVariant(additional_data)))})
}

//go:nosplit
func (self class) GetHandleBinaryImage() int64 { //gd:GLTFState.get_handle_binary_image
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_handle_binary_image, gdextension.SizeInt, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetHandleBinaryImage(method int64) { //gd:GLTFState.set_handle_binary_image
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_handle_binary_image, 0|(gdextension.SizeInt<<4), &struct{ method int64 }{method})
}

//go:nosplit
func (self class) SetBakeFps(value float64) { //gd:GLTFState.set_bake_fps
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_bake_fps, 0|(gdextension.SizeFloat<<4), &struct{ value float64 }{value})
}

//go:nosplit
func (self class) GetBakeFps() float64 { //gd:GLTFState.get_bake_fps
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_bake_fps, gdextension.SizeFloat, &struct{}{})
	var ret = r_ret
	return ret
}
func (self class) AsGLTFState() Advanced { return Advanced{pointers.AsA[gdclass.GLTFState](self[0])} }
func (self Instance) AsGLTFState() Instance {
	return Instance{pointers.AsA[gdclass.GLTFState](self[0])}
}
func (self *Extension[T]) AsGLTFState() Instance { return self.Super().AsGLTFState() }
func (self class) AsResource() Resource.Advanced {
	return Resource.Advanced{pointers.AsA[gdclass.Resource](self[0])}
}
func (self *Extension[T]) AsResource() Resource.Instance { return self.Super().AsResource() }
func (self Instance) AsResource() Resource.Instance {
	return Resource.Instance{pointers.AsA[gdclass.Resource](self[0])}
}
func (self class) AsRefCounted() [1]gd.RefCounted {
	return [1]gd.RefCounted{gd.RefCounted(pointers.AsA[gd.Object](self[0]))}
}
func (self *Extension[T]) AsRefCounted() [1]gd.RefCounted { return self.Super().AsRefCounted() }
func (self Instance) AsRefCounted() [1]gd.RefCounted {
	return [1]gd.RefCounted{gd.RefCounted(pointers.AsA[gd.Object](self[0]))}
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Resource.Advanced(self.AsResource()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Resource.Instance(self.AsResource()), name)
	}
}
func init() {
	gdclass.Register("GLTFState", func(ptr gd.Object) any { return Instance{pointers.AsA[gdclass.GLTFState](ptr)} })
}

type BinaryHandler int

const HandleBinaryDiscardTextures BinaryHandler = 0     //gd:GLTFState.HANDLE_BINARY_DISCARD_TEXTURES
const HandleBinaryExtractTextures BinaryHandler = 1     //gd:GLTFState.HANDLE_BINARY_EXTRACT_TEXTURES
const HandleBinaryEmbedAsBasisu BinaryHandler = 2       //gd:GLTFState.HANDLE_BINARY_EMBED_AS_BASISU
const HandleBinaryEmbedAsUncompressed BinaryHandler = 3 //gd:GLTFState.HANDLE_BINARY_EMBED_AS_UNCOMPRESSED
