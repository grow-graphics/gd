// Code generated by the generate package DO NOT EDIT

// Package LobbyClient provides methods for working with LobbyClient object instances.
package LobbyClient

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/BlaziumClient"
import "graphics.gd/classdb/LobbyInfo"
import "graphics.gd/classdb/LobbyPeer"
import "graphics.gd/classdb/LobbyResponse"
import "graphics.gd/classdb/Node"
import "graphics.gd/classdb/ViewLobbyResponse"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
The [LobbyClient] node provides an interface for connecting to the Blazium Lobby service. There is a free instance hosted on the [url=https://blazium.app]blazium.app[/url] domain that is used by default.
The normal flow is as follows:
1. Listen to all the signals you are interested in.
2. Connect to the server using [method connect_to_server] method.
3. Call any other methods to create, view or join lobbies, as well as add data to them.
4. Close the session using [method disconnect_from_server] method at the end of the game.
[b]Note:[/b] Some methods are non blocking and can be awaited in order to get the result.
There are also members on this class that are automatically updated as the lobby gets updated, such as:
- [member peer]: The current peer. Reflects changes to the self peer.
- [member peers]: The lobby peers. Reflects changes to all peers.
- [member lobby]: The lobby. Reflects changes to the lobby.
- [member host_data]: The current lobby private data. Only works if you are host.
- [member peer_data]: The current peer private data.
[codeblocks]
[gdscript]
func _ready():

	disconnected_from_server.connect(_disconnected_from_server)
	var res : LobbyResult = await connect_to_server().finished
	if res.has_error():
	    print(res.error)
	var res_view: ViewLobbyResult =await create_lobby("Test lobby", false).finished
	if res_view.has_error():
	    print(res_view.error)
	else:
	    print(res_view.lobby.lobby_name)

func _disconnected_from_server(reason: String):

	print("Disconnected from server: " + reason)

[/gdscript]
[/codeblocks]
*/
type Instance [1]gdclass.LobbyClient

func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

type Expanded [1]gdclass.LobbyClient

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsLobbyClient() Instance
}

/*
Returns true if you are the host of the current lobby.
*/
func (self Instance) IsHost() bool { //gd:LobbyClient.is_host
	return bool(Advanced(self).IsHost())
}
func (self Instance) SetOverrideDiscordPath(override_discord_path string) { //gd:LobbyClient.set_override_discord_path
	Advanced(self).SetOverrideDiscordPath(String.New(override_discord_path))
}
func (self Instance) GetOverrideDiscordPath() string { //gd:LobbyClient.get_override_discord_path
	return string(Advanced(self).GetOverrideDiscordPath().String())
}

/*
Connect to a Blazium Lobby Server using the [member game_id] and [member server_url].
Generates [signal connected_to_server] signal if successful.
*/
func (self Instance) ConnectToServer() LobbyResponse.Instance { //gd:LobbyClient.connect_to_server
	return LobbyResponse.Instance(Advanced(self).ConnectToServer())
}

/*
Disconnect from the lobby server.
Needs [method connect_to_server] to be called first.
Generates [signal disconnected_from_server] signal.
*/
func (self Instance) DisconnectFromServer() LobbyResponse.Instance { //gd:LobbyClient.disconnect_from_server
	return LobbyResponse.Instance(Advanced(self).DisconnectFromServer())
}

/*
Quick join a lobby or create one if none exist. If you are already in a lobby, you cannot join another one. You need to leave first.
Needs [method connect_to_server] to be called first.
Returns a [ViewLobbyResponse] object that has a [signal ViewLobbyResponse.finished] signal that is emitted when finished.
Generates either [signal lobby_joined] or [signal lobby_created].
*/
func (self Instance) QuickJoin(title string) ViewLobbyResponse.Instance { //gd:LobbyClient.quick_join
	return ViewLobbyResponse.Instance(Advanced(self).QuickJoin(String.New(title), Dictionary.Nil, int64(4)))
}

/*
Quick join a lobby or create one if none exist. If you are already in a lobby, you cannot join another one. You need to leave first.
Needs [method connect_to_server] to be called first.
Returns a [ViewLobbyResponse] object that has a [signal ViewLobbyResponse.finished] signal that is emitted when finished.
Generates either [signal lobby_joined] or [signal lobby_created].
*/
func (self Expanded) QuickJoin(title string, tags map[any]any, max_players int) ViewLobbyResponse.Instance { //gd:LobbyClient.quick_join
	return ViewLobbyResponse.Instance(Advanced(self).QuickJoin(String.New(title), gd.DictionaryFromMap(tags), int64(max_players)))
}

/*
Create a lobby and become host. If you are already in a lobby, you cannot create one. You need to leave first.
The new lobby can have a title, tags, max players and password. 0 max players means unlimited.
Needs [method connect_to_server] to be called first.
Returns a [ViewLobbyResponse] object that has a [signal ViewLobbyResponse.finished] signal that is emitted when finished.
Generates [signal lobby_created] signal.
*/
func (self Instance) CreateLobby(title string, sealed bool) ViewLobbyResponse.Instance { //gd:LobbyClient.create_lobby
	return ViewLobbyResponse.Instance(Advanced(self).CreateLobby(String.New(title), sealed, Dictionary.Nil, int64(4), String.New("")))
}

/*
Create a lobby and become host. If you are already in a lobby, you cannot create one. You need to leave first.
The new lobby can have a title, tags, max players and password. 0 max players means unlimited.
Needs [method connect_to_server] to be called first.
Returns a [ViewLobbyResponse] object that has a [signal ViewLobbyResponse.finished] signal that is emitted when finished.
Generates [signal lobby_created] signal.
*/
func (self Expanded) CreateLobby(title string, sealed bool, tags map[any]any, max_players int, password string) ViewLobbyResponse.Instance { //gd:LobbyClient.create_lobby
	return ViewLobbyResponse.Instance(Advanced(self).CreateLobby(String.New(title), sealed, gd.DictionaryFromMap(tags), int64(max_players), String.New(password)))
}

/*
Join a lobby. If you are already in a lobby, you cannot join another one. You need to leave first.
If the lobby you want to join is password protected, you need to provide the password.
Needs [method connect_to_server] to be called first.
Returns a [ViewLobbyResponse] object that has a [signal ViewLobbyResponse.finished] signal that is emitted when finished.
Generates [signal lobby_joined].
*/
func (self Instance) JoinLobby(lobby_id string) ViewLobbyResponse.Instance { //gd:LobbyClient.join_lobby
	return ViewLobbyResponse.Instance(Advanced(self).JoinLobby(String.New(lobby_id), String.New("")))
}

/*
Join a lobby. If you are already in a lobby, you cannot join another one. You need to leave first.
If the lobby you want to join is password protected, you need to provide the password.
Needs [method connect_to_server] to be called first.
Returns a [ViewLobbyResponse] object that has a [signal ViewLobbyResponse.finished] signal that is emitted when finished.
Generates [signal lobby_joined].
*/
func (self Expanded) JoinLobby(lobby_id string, password string) ViewLobbyResponse.Instance { //gd:LobbyClient.join_lobby
	return ViewLobbyResponse.Instance(Advanced(self).JoinLobby(String.New(lobby_id), String.New(password)))
}

/*
Leave a lobby. You need to be in a lobby to leave one.
Needs [method connect_to_server] to be called first.
Returns a [LobbyResponse] object that has a [signal LobbyResponse.finished] signal that is emitted when finished.
Generates [signal lobby_left].
*/
func (self Instance) LeaveLobby() LobbyResponse.Instance { //gd:LobbyClient.leave_lobby
	return LobbyResponse.Instance(Advanced(self).LeaveLobby())
}

/*
Lists all lobbies. Lobbies that are sealed won't show in the list, except if you disconnected and trying to reconnect to a lobby.
Needs [method connect_to_server] to be called first.
Returns a [LobbyResponse] object that has a [signal LobbyResponse.finished] signal that is emitted when finished.
Generates [signal lobbies_listed].
*/
func (self Instance) ListLobbies() LobbyResponse.Instance { //gd:LobbyClient.list_lobbies
	return LobbyResponse.Instance(Advanced(self).ListLobbies())
}

/*
Kick a peer. You need to be host to do so.
Needs [method connect_to_server] to be called first.
Returns a [LobbyResponse] object that has a [signal LobbyResponse.finished] signal that is emitted when finished.
Generates [signal peer_left] signal with kicked set to true.
*/
func (self Instance) KickPeer(peer_id string) LobbyResponse.Instance { //gd:LobbyClient.kick_peer
	return LobbyResponse.Instance(Advanced(self).KickPeer(String.New(peer_id)))
}

/*
Send a chat message. Only works if you are in a lobby.
Needs [method connect_to_server] to be called first.
Returns a [LobbyResponse] object that has a [signal LobbyResponse.finished] signal that is emitted when finished.
Generates [signal peer_messaged].
*/
func (self Instance) SendChatMessage(chat_message string) LobbyResponse.Instance { //gd:LobbyClient.send_chat_message
	return LobbyResponse.Instance(Advanced(self).SendChatMessage(String.New(chat_message)))
}

/*
Ready up in the lobby. You need to be in a lobby and unready to run this.
Needs [method connect_to_server] to be called first.
Returns a [LobbyResponse] object that has a [signal LobbyResponse.finished] signal that is emitted when finished.
Generates [signal peer_ready].
*/
func (self Instance) SetLobbyReady(ready bool) LobbyResponse.Instance { //gd:LobbyClient.set_lobby_ready
	return LobbyResponse.Instance(Advanced(self).SetLobbyReady(ready))
}

/*
Add tags to the lobby. Only works if you are host.
Needs [method connect_to_server] to be called first.
Returns a [LobbyResponse] object that has a [signal LobbyResponse.finished] signal that is emitted when finished.
Generates [signal lobby_tagged].
*/
func (self Instance) AddLobbyTags(tags map[any]any) LobbyResponse.Instance { //gd:LobbyClient.add_lobby_tags
	return LobbyResponse.Instance(Advanced(self).AddLobbyTags(gd.DictionaryFromMap(tags)))
}

/*
Delete one or more keys from the lobby tags. Only works if you are host.
Needs [method connect_to_server] to be called first.
Returns a [LobbyResponse] object that has a [signal LobbyResponse.finished] signal that is emitted when finished.
Generates [signal lobby_tagged].
*/
func (self Instance) DelLobbyTags(keys []string) LobbyResponse.Instance { //gd:LobbyClient.del_lobby_tags
	return LobbyResponse.Instance(Advanced(self).DelLobbyTags(gd.ArrayFromSlice[Array.Contains[String.Readable]](keys)))
}

/*
Seals the lobby. You need to be the host to do this and the lobby needs to be unsealed.
Needs [method connect_to_server] to be called first.
Returns a [LobbyResponse] object that has a [signal LobbyResponse.finished] signal that is emitted when finished.
Generates [signal lobby_sealed].
*/
func (self Instance) SetLobbySealed(seal bool) LobbyResponse.Instance { //gd:LobbyClient.set_lobby_sealed
	return LobbyResponse.Instance(Advanced(self).SetLobbySealed(seal))
}

/*
Send a notification either to the host, or if you are host send data to all peers.
Needs [method connect_to_server] to be called first.
Returns a [LobbyResponse] object that has a [signal LobbyResponse.finished] signal that is emitted when finished.
Generates [signal lobby_notified] signal.
*/
func (self Instance) NotifyLobby(data any) LobbyResponse.Instance { //gd:LobbyClient.notify_lobby
	return LobbyResponse.Instance(Advanced(self).NotifyLobby(variant.New(data)))
}

/*
Send a notification to a peer, works only if you are host.
Needs [method connect_to_server] to be called first.
Returns a [LobbyResponse] object that has a [signal LobbyResponse.finished] signal that is emitted when finished.
Generates [signal lobby_notified] signal.
*/
func (self Instance) NotifyPeer(data any, target_peer string) LobbyResponse.Instance { //gd:LobbyClient.notify_peer
	return LobbyResponse.Instance(Advanced(self).NotifyPeer(variant.New(data), String.New(target_peer)))
}

/*
Add user data to your own peer.
Needs [method connect_to_server] to be called first.
Returns a [LobbyResponse] object that has a [signal LobbyResponse.finished] signal that is emitted when finished.
Generates [signal received_peer_user_data].
*/
func (self Instance) AddPeerUserData(data map[any]any) LobbyResponse.Instance { //gd:LobbyClient.add_peer_user_data
	return LobbyResponse.Instance(Advanced(self).AddPeerUserData(gd.DictionaryFromMap(data)))
}

/*
Delete one or more keys from the peers user data.
Needs [method connect_to_server] to be called first.
Returns a [LobbyResponse] object that has a [signal LobbyResponse.finished] signal that is emitted when finished.
Generates [signal received_peer_user_data].
*/
func (self Instance) DelPeerUserData(keys []string) LobbyResponse.Instance { //gd:LobbyClient.del_peer_user_data
	return LobbyResponse.Instance(Advanced(self).DelPeerUserData(gd.ArrayFromSlice[Array.Contains[String.Readable]](keys)))
}

/*
Add data to the lobby. Only works if you are host.
Needs [method connect_to_server] to be called first.
Returns a [LobbyResponse] object that has a [signal LobbyResponse.finished] signal that is emitted when finished.
Generates [signal received_lobby_data].
*/
func (self Instance) AddLobbyData(data map[any]any) LobbyResponse.Instance { //gd:LobbyClient.add_lobby_data
	return LobbyResponse.Instance(Advanced(self).AddLobbyData(gd.DictionaryFromMap(data), false))
}

/*
Add data to the lobby. Only works if you are host.
Needs [method connect_to_server] to be called first.
Returns a [LobbyResponse] object that has a [signal LobbyResponse.finished] signal that is emitted when finished.
Generates [signal received_lobby_data].
*/
func (self Expanded) AddLobbyData(data map[any]any, is_private bool) LobbyResponse.Instance { //gd:LobbyClient.add_lobby_data
	return LobbyResponse.Instance(Advanced(self).AddLobbyData(gd.DictionaryFromMap(data), is_private))
}

/*
Delete one or more keys from the lobby data. Only works if you are host.
Needs [method connect_to_server] to be called first.
Returns a [LobbyResponse] object that has a [signal LobbyResponse.finished] signal that is emitted when finished.
Generates [signal received_lobby_data].
*/
func (self Instance) DelLobbyData(keys []string) LobbyResponse.Instance { //gd:LobbyClient.del_lobby_data
	return LobbyResponse.Instance(Advanced(self).DelLobbyData(gd.ArrayFromSlice[Array.Contains[String.Readable]](keys), false))
}

/*
Delete one or more keys from the lobby data. Only works if you are host.
Needs [method connect_to_server] to be called first.
Returns a [LobbyResponse] object that has a [signal LobbyResponse.finished] signal that is emitted when finished.
Generates [signal received_lobby_data].
*/
func (self Expanded) DelLobbyData(keys []string, is_private bool) LobbyResponse.Instance { //gd:LobbyClient.del_lobby_data
	return LobbyResponse.Instance(Advanced(self).DelLobbyData(gd.ArrayFromSlice[Array.Contains[String.Readable]](keys), is_private))
}

/*
Add data to a peer. Only works if you are host.
Needs [method connect_to_server] to be called first.
Returns a [LobbyResponse] object that has a [signal LobbyResponse.finished] signal that is emitted when finished.
Generates [signal received_peer_data].
*/
func (self Instance) AddPeerData(data map[any]any, target_peer string) LobbyResponse.Instance { //gd:LobbyClient.add_peer_data
	return LobbyResponse.Instance(Advanced(self).AddPeerData(gd.DictionaryFromMap(data), String.New(target_peer), false))
}

/*
Add data to a peer. Only works if you are host.
Needs [method connect_to_server] to be called first.
Returns a [LobbyResponse] object that has a [signal LobbyResponse.finished] signal that is emitted when finished.
Generates [signal received_peer_data].
*/
func (self Expanded) AddPeerData(data map[any]any, target_peer string, is_private bool) LobbyResponse.Instance { //gd:LobbyClient.add_peer_data
	return LobbyResponse.Instance(Advanced(self).AddPeerData(gd.DictionaryFromMap(data), String.New(target_peer), is_private))
}

/*
Delete one or more keys from the peer data. Only works if you are host.
Needs [method connect_to_server] to be called first.
Returns a [LobbyResponse] object that has a [signal LobbyResponse.finished] signal that is emitted when finished.
Generates [signal received_peer_data].
*/
func (self Instance) DelPeerData(keys []string, target_peer string) LobbyResponse.Instance { //gd:LobbyClient.del_peer_data
	return LobbyResponse.Instance(Advanced(self).DelPeerData(gd.ArrayFromSlice[Array.Contains[String.Readable]](keys), String.New(target_peer), false))
}

/*
Delete one or more keys from the peer data. Only works if you are host.
Needs [method connect_to_server] to be called first.
Returns a [LobbyResponse] object that has a [signal LobbyResponse.finished] signal that is emitted when finished.
Generates [signal received_peer_data].
*/
func (self Expanded) DelPeerData(keys []string, target_peer string, is_private bool) LobbyResponse.Instance { //gd:LobbyClient.del_peer_data
	return LobbyResponse.Instance(Advanced(self).DelPeerData(gd.ArrayFromSlice[Array.Contains[String.Readable]](keys), String.New(target_peer), is_private))
}

/*
Add data to all peers. Only works if you are host.
Needs [method connect_to_server] to be called first.
Returns a [LobbyResponse] object that has a [signal LobbyResponse.finished] signal that is emitted when finished.
Generates [signal received_peer_data].
*/
func (self Instance) AddPeersData(data map[any]any) LobbyResponse.Instance { //gd:LobbyClient.add_peers_data
	return LobbyResponse.Instance(Advanced(self).AddPeersData(gd.DictionaryFromMap(data), false))
}

/*
Add data to all peers. Only works if you are host.
Needs [method connect_to_server] to be called first.
Returns a [LobbyResponse] object that has a [signal LobbyResponse.finished] signal that is emitted when finished.
Generates [signal received_peer_data].
*/
func (self Expanded) AddPeersData(data map[any]any, is_private bool) LobbyResponse.Instance { //gd:LobbyClient.add_peers_data
	return LobbyResponse.Instance(Advanced(self).AddPeersData(gd.DictionaryFromMap(data), is_private))
}

/*
Delete one or more keys from the peers data. Only works if you are host.
Needs [method connect_to_server] to be called first.
Returns a [LobbyResponse] object that has a [signal LobbyResponse.finished] signal that is emitted when finished.
Generates [signal received_peer_data].
*/
func (self Instance) DelPeersData(keys []string) LobbyResponse.Instance { //gd:LobbyClient.del_peers_data
	return LobbyResponse.Instance(Advanced(self).DelPeersData(gd.ArrayFromSlice[Array.Contains[String.Readable]](keys), false))
}

/*
Delete one or more keys from the peers data. Only works if you are host.
Needs [method connect_to_server] to be called first.
Returns a [LobbyResponse] object that has a [signal LobbyResponse.finished] signal that is emitted when finished.
Generates [signal received_peer_data].
*/
func (self Expanded) DelPeersData(keys []string, is_private bool) LobbyResponse.Instance { //gd:LobbyClient.del_peers_data
	return LobbyResponse.Instance(Advanced(self).DelPeersData(gd.ArrayFromSlice[Array.Contains[String.Readable]](keys), is_private))
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.LobbyClient

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {
	object := gd.Global.ClassDB.ConstructObject(gd.NewStringName("LobbyClient"))
	casted := Instance{*(*gdclass.LobbyClient)(unsafe.Pointer(&object))}
	return casted
}

func (self Instance) ServerUrl() string {
	return string(class(self).GetServerUrl().String())
}

func (self Instance) SetServerUrl(value string) {
	class(self).SetServerUrl(String.New(value))
}

func (self Instance) ReconnectionToken() string {
	return string(class(self).GetReconnectionToken().String())
}

func (self Instance) SetReconnectionToken(value string) {
	class(self).SetReconnectionToken(String.New(value))
}

func (self Instance) GameId() string {
	return string(class(self).GetGameId().String())
}

func (self Instance) SetGameId(value string) {
	class(self).SetGameId(String.New(value))
}

func (self Instance) Connected() bool {
	return bool(class(self).GetConnected())
}

func (self Instance) Lobby() LobbyInfo.Instance {
	return LobbyInfo.Instance(class(self).GetLobby())
}

func (self Instance) Peer() LobbyPeer.Instance {
	return LobbyPeer.Instance(class(self).GetPeer())
}

func (self Instance) Peers() []LobbyPeer.Instance {
	return []LobbyPeer.Instance(gd.ArrayAs[[]LobbyPeer.Instance](gd.InternalArray(class(self).GetPeers())))
}

func (self Instance) HostData() map[any]any {
	return map[any]any(gd.DictionaryAs[map[any]any](class(self).GetHostData()))
}

func (self Instance) PeerData() map[any]any {
	return map[any]any(gd.DictionaryAs[map[any]any](class(self).GetPeerData()))
}

//go:nosplit
func (self class) SetServerUrl(server_url String.Readable) { //gd:LobbyClient.set_server_url
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(server_url)))
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.LobbyClient.Bind_set_server_url, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) GetServerUrl() String.Readable { //gd:LobbyClient.get_server_url
	var frame = callframe.New()
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.LobbyClient.Bind_get_server_url, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

//go:nosplit
func (self class) SetReconnectionToken(reconnection_token String.Readable) { //gd:LobbyClient.set_reconnection_token
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(reconnection_token)))
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.LobbyClient.Bind_set_reconnection_token, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) GetReconnectionToken() String.Readable { //gd:LobbyClient.get_reconnection_token
	var frame = callframe.New()
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.LobbyClient.Bind_get_reconnection_token, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

//go:nosplit
func (self class) SetGameId(game_id String.Readable) { //gd:LobbyClient.set_game_id
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(game_id)))
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.LobbyClient.Bind_set_game_id, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) GetGameId() String.Readable { //gd:LobbyClient.get_game_id
	var frame = callframe.New()
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.LobbyClient.Bind_get_game_id, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Returns true if you are the host of the current lobby.
*/
//go:nosplit
func (self class) IsHost() bool { //gd:LobbyClient.is_host
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.LobbyClient.Bind_is_host, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

//go:nosplit
func (self class) GetConnected() bool { //gd:LobbyClient.get_connected
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.LobbyClient.Bind_get_connected, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

//go:nosplit
func (self class) GetLobby() [1]gdclass.LobbyInfo { //gd:LobbyClient.get_lobby
	var frame = callframe.New()
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.LobbyClient.Bind_get_lobby, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.LobbyInfo{gd.PointerWithOwnershipTransferredToGo[gdclass.LobbyInfo](r_ret.Get())}
	frame.Free()
	return ret
}

//go:nosplit
func (self class) GetPeer() [1]gdclass.LobbyPeer { //gd:LobbyClient.get_peer
	var frame = callframe.New()
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.LobbyClient.Bind_get_peer, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.LobbyPeer{gd.PointerWithOwnershipTransferredToGo[gdclass.LobbyPeer](r_ret.Get())}
	frame.Free()
	return ret
}

//go:nosplit
func (self class) GetPeers() Array.Contains[[1]gdclass.LobbyPeer] { //gd:LobbyClient.get_peers
	var frame = callframe.New()
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.LobbyClient.Bind_get_peers, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Array.Through(gd.ArrayProxy[[1]gdclass.LobbyPeer]{}, pointers.Pack(pointers.New[gd.Array](r_ret.Get())))
	frame.Free()
	return ret
}

//go:nosplit
func (self class) GetHostData() Dictionary.Any { //gd:LobbyClient.get_host_data
	var frame = callframe.New()
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.LobbyClient.Bind_get_host_data, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

//go:nosplit
func (self class) GetPeerData() Dictionary.Any { //gd:LobbyClient.get_peer_data
	var frame = callframe.New()
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.LobbyClient.Bind_get_peer_data, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

//go:nosplit
func (self class) SetOverrideDiscordPath(override_discord_path String.Readable) { //gd:LobbyClient.set_override_discord_path
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(override_discord_path)))
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.LobbyClient.Bind_set_override_discord_path, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) GetOverrideDiscordPath() String.Readable { //gd:LobbyClient.get_override_discord_path
	var frame = callframe.New()
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.LobbyClient.Bind_get_override_discord_path, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Connect to a Blazium Lobby Server using the [member game_id] and [member server_url].
Generates [signal connected_to_server] signal if successful.
*/
//go:nosplit
func (self class) ConnectToServer() [1]gdclass.LobbyResponse { //gd:LobbyClient.connect_to_server
	var frame = callframe.New()
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.LobbyClient.Bind_connect_to_server, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.LobbyResponse{gd.PointerWithOwnershipTransferredToGo[gdclass.LobbyResponse](r_ret.Get())}
	frame.Free()
	return ret
}

/*
Disconnect from the lobby server.
Needs [method connect_to_server] to be called first.
Generates [signal disconnected_from_server] signal.
*/
//go:nosplit
func (self class) DisconnectFromServer() [1]gdclass.LobbyResponse { //gd:LobbyClient.disconnect_from_server
	var frame = callframe.New()
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.LobbyClient.Bind_disconnect_from_server, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.LobbyResponse{gd.PointerWithOwnershipTransferredToGo[gdclass.LobbyResponse](r_ret.Get())}
	frame.Free()
	return ret
}

/*
Quick join a lobby or create one if none exist. If you are already in a lobby, you cannot join another one. You need to leave first.
Needs [method connect_to_server] to be called first.
Returns a [ViewLobbyResponse] object that has a [signal ViewLobbyResponse.finished] signal that is emitted when finished.
Generates either [signal lobby_joined] or [signal lobby_created].
*/
//go:nosplit
func (self class) QuickJoin(title String.Readable, tags Dictionary.Any, max_players int64) [1]gdclass.ViewLobbyResponse { //gd:LobbyClient.quick_join
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(title)))
	callframe.Arg(frame, pointers.Get(gd.InternalDictionary(tags)))
	callframe.Arg(frame, max_players)
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.LobbyClient.Bind_quick_join, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.ViewLobbyResponse{gd.PointerWithOwnershipTransferredToGo[gdclass.ViewLobbyResponse](r_ret.Get())}
	frame.Free()
	return ret
}

/*
Create a lobby and become host. If you are already in a lobby, you cannot create one. You need to leave first.
The new lobby can have a title, tags, max players and password. 0 max players means unlimited.
Needs [method connect_to_server] to be called first.
Returns a [ViewLobbyResponse] object that has a [signal ViewLobbyResponse.finished] signal that is emitted when finished.
Generates [signal lobby_created] signal.
*/
//go:nosplit
func (self class) CreateLobby(title String.Readable, sealed bool, tags Dictionary.Any, max_players int64, password String.Readable) [1]gdclass.ViewLobbyResponse { //gd:LobbyClient.create_lobby
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(title)))
	callframe.Arg(frame, sealed)
	callframe.Arg(frame, pointers.Get(gd.InternalDictionary(tags)))
	callframe.Arg(frame, max_players)
	callframe.Arg(frame, pointers.Get(gd.InternalString(password)))
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.LobbyClient.Bind_create_lobby, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.ViewLobbyResponse{gd.PointerWithOwnershipTransferredToGo[gdclass.ViewLobbyResponse](r_ret.Get())}
	frame.Free()
	return ret
}

/*
Join a lobby. If you are already in a lobby, you cannot join another one. You need to leave first.
If the lobby you want to join is password protected, you need to provide the password.
Needs [method connect_to_server] to be called first.
Returns a [ViewLobbyResponse] object that has a [signal ViewLobbyResponse.finished] signal that is emitted when finished.
Generates [signal lobby_joined].
*/
//go:nosplit
func (self class) JoinLobby(lobby_id String.Readable, password String.Readable) [1]gdclass.ViewLobbyResponse { //gd:LobbyClient.join_lobby
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(lobby_id)))
	callframe.Arg(frame, pointers.Get(gd.InternalString(password)))
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.LobbyClient.Bind_join_lobby, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.ViewLobbyResponse{gd.PointerWithOwnershipTransferredToGo[gdclass.ViewLobbyResponse](r_ret.Get())}
	frame.Free()
	return ret
}

/*
Leave a lobby. You need to be in a lobby to leave one.
Needs [method connect_to_server] to be called first.
Returns a [LobbyResponse] object that has a [signal LobbyResponse.finished] signal that is emitted when finished.
Generates [signal lobby_left].
*/
//go:nosplit
func (self class) LeaveLobby() [1]gdclass.LobbyResponse { //gd:LobbyClient.leave_lobby
	var frame = callframe.New()
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.LobbyClient.Bind_leave_lobby, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.LobbyResponse{gd.PointerWithOwnershipTransferredToGo[gdclass.LobbyResponse](r_ret.Get())}
	frame.Free()
	return ret
}

/*
Lists all lobbies. Lobbies that are sealed won't show in the list, except if you disconnected and trying to reconnect to a lobby.
Needs [method connect_to_server] to be called first.
Returns a [LobbyResponse] object that has a [signal LobbyResponse.finished] signal that is emitted when finished.
Generates [signal lobbies_listed].
*/
//go:nosplit
func (self class) ListLobbies() [1]gdclass.LobbyResponse { //gd:LobbyClient.list_lobbies
	var frame = callframe.New()
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.LobbyClient.Bind_list_lobbies, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.LobbyResponse{gd.PointerWithOwnershipTransferredToGo[gdclass.LobbyResponse](r_ret.Get())}
	frame.Free()
	return ret
}

/*
Kick a peer. You need to be host to do so.
Needs [method connect_to_server] to be called first.
Returns a [LobbyResponse] object that has a [signal LobbyResponse.finished] signal that is emitted when finished.
Generates [signal peer_left] signal with kicked set to true.
*/
//go:nosplit
func (self class) KickPeer(peer_id String.Readable) [1]gdclass.LobbyResponse { //gd:LobbyClient.kick_peer
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(peer_id)))
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.LobbyClient.Bind_kick_peer, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.LobbyResponse{gd.PointerWithOwnershipTransferredToGo[gdclass.LobbyResponse](r_ret.Get())}
	frame.Free()
	return ret
}

/*
Send a chat message. Only works if you are in a lobby.
Needs [method connect_to_server] to be called first.
Returns a [LobbyResponse] object that has a [signal LobbyResponse.finished] signal that is emitted when finished.
Generates [signal peer_messaged].
*/
//go:nosplit
func (self class) SendChatMessage(chat_message String.Readable) [1]gdclass.LobbyResponse { //gd:LobbyClient.send_chat_message
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(chat_message)))
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.LobbyClient.Bind_send_chat_message, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.LobbyResponse{gd.PointerWithOwnershipTransferredToGo[gdclass.LobbyResponse](r_ret.Get())}
	frame.Free()
	return ret
}

/*
Ready up in the lobby. You need to be in a lobby and unready to run this.
Needs [method connect_to_server] to be called first.
Returns a [LobbyResponse] object that has a [signal LobbyResponse.finished] signal that is emitted when finished.
Generates [signal peer_ready].
*/
//go:nosplit
func (self class) SetLobbyReady(ready bool) [1]gdclass.LobbyResponse { //gd:LobbyClient.set_lobby_ready
	var frame = callframe.New()
	callframe.Arg(frame, ready)
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.LobbyClient.Bind_set_lobby_ready, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.LobbyResponse{gd.PointerWithOwnershipTransferredToGo[gdclass.LobbyResponse](r_ret.Get())}
	frame.Free()
	return ret
}

/*
Add tags to the lobby. Only works if you are host.
Needs [method connect_to_server] to be called first.
Returns a [LobbyResponse] object that has a [signal LobbyResponse.finished] signal that is emitted when finished.
Generates [signal lobby_tagged].
*/
//go:nosplit
func (self class) AddLobbyTags(tags Dictionary.Any) [1]gdclass.LobbyResponse { //gd:LobbyClient.add_lobby_tags
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalDictionary(tags)))
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.LobbyClient.Bind_add_lobby_tags, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.LobbyResponse{gd.PointerWithOwnershipTransferredToGo[gdclass.LobbyResponse](r_ret.Get())}
	frame.Free()
	return ret
}

/*
Delete one or more keys from the lobby tags. Only works if you are host.
Needs [method connect_to_server] to be called first.
Returns a [LobbyResponse] object that has a [signal LobbyResponse.finished] signal that is emitted when finished.
Generates [signal lobby_tagged].
*/
//go:nosplit
func (self class) DelLobbyTags(keys Array.Contains[String.Readable]) [1]gdclass.LobbyResponse { //gd:LobbyClient.del_lobby_tags
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalArray(keys)))
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.LobbyClient.Bind_del_lobby_tags, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.LobbyResponse{gd.PointerWithOwnershipTransferredToGo[gdclass.LobbyResponse](r_ret.Get())}
	frame.Free()
	return ret
}

/*
Seals the lobby. You need to be the host to do this and the lobby needs to be unsealed.
Needs [method connect_to_server] to be called first.
Returns a [LobbyResponse] object that has a [signal LobbyResponse.finished] signal that is emitted when finished.
Generates [signal lobby_sealed].
*/
//go:nosplit
func (self class) SetLobbySealed(seal bool) [1]gdclass.LobbyResponse { //gd:LobbyClient.set_lobby_sealed
	var frame = callframe.New()
	callframe.Arg(frame, seal)
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.LobbyClient.Bind_set_lobby_sealed, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.LobbyResponse{gd.PointerWithOwnershipTransferredToGo[gdclass.LobbyResponse](r_ret.Get())}
	frame.Free()
	return ret
}

/*
Send a notification either to the host, or if you are host send data to all peers.
Needs [method connect_to_server] to be called first.
Returns a [LobbyResponse] object that has a [signal LobbyResponse.finished] signal that is emitted when finished.
Generates [signal lobby_notified] signal.
*/
//go:nosplit
func (self class) NotifyLobby(data variant.Any) [1]gdclass.LobbyResponse { //gd:LobbyClient.notify_lobby
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalVariant(data)))
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.LobbyClient.Bind_notify_lobby, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.LobbyResponse{gd.PointerWithOwnershipTransferredToGo[gdclass.LobbyResponse](r_ret.Get())}
	frame.Free()
	return ret
}

/*
Send a notification to a peer, works only if you are host.
Needs [method connect_to_server] to be called first.
Returns a [LobbyResponse] object that has a [signal LobbyResponse.finished] signal that is emitted when finished.
Generates [signal lobby_notified] signal.
*/
//go:nosplit
func (self class) NotifyPeer(data variant.Any, target_peer String.Readable) [1]gdclass.LobbyResponse { //gd:LobbyClient.notify_peer
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalVariant(data)))
	callframe.Arg(frame, pointers.Get(gd.InternalString(target_peer)))
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.LobbyClient.Bind_notify_peer, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.LobbyResponse{gd.PointerWithOwnershipTransferredToGo[gdclass.LobbyResponse](r_ret.Get())}
	frame.Free()
	return ret
}

/*
Add user data to your own peer.
Needs [method connect_to_server] to be called first.
Returns a [LobbyResponse] object that has a [signal LobbyResponse.finished] signal that is emitted when finished.
Generates [signal received_peer_user_data].
*/
//go:nosplit
func (self class) AddPeerUserData(data Dictionary.Any) [1]gdclass.LobbyResponse { //gd:LobbyClient.add_peer_user_data
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalDictionary(data)))
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.LobbyClient.Bind_add_peer_user_data, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.LobbyResponse{gd.PointerWithOwnershipTransferredToGo[gdclass.LobbyResponse](r_ret.Get())}
	frame.Free()
	return ret
}

/*
Delete one or more keys from the peers user data.
Needs [method connect_to_server] to be called first.
Returns a [LobbyResponse] object that has a [signal LobbyResponse.finished] signal that is emitted when finished.
Generates [signal received_peer_user_data].
*/
//go:nosplit
func (self class) DelPeerUserData(keys Array.Contains[String.Readable]) [1]gdclass.LobbyResponse { //gd:LobbyClient.del_peer_user_data
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalArray(keys)))
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.LobbyClient.Bind_del_peer_user_data, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.LobbyResponse{gd.PointerWithOwnershipTransferredToGo[gdclass.LobbyResponse](r_ret.Get())}
	frame.Free()
	return ret
}

/*
Add data to the lobby. Only works if you are host.
Needs [method connect_to_server] to be called first.
Returns a [LobbyResponse] object that has a [signal LobbyResponse.finished] signal that is emitted when finished.
Generates [signal received_lobby_data].
*/
//go:nosplit
func (self class) AddLobbyData(data Dictionary.Any, is_private bool) [1]gdclass.LobbyResponse { //gd:LobbyClient.add_lobby_data
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalDictionary(data)))
	callframe.Arg(frame, is_private)
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.LobbyClient.Bind_add_lobby_data, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.LobbyResponse{gd.PointerWithOwnershipTransferredToGo[gdclass.LobbyResponse](r_ret.Get())}
	frame.Free()
	return ret
}

/*
Delete one or more keys from the lobby data. Only works if you are host.
Needs [method connect_to_server] to be called first.
Returns a [LobbyResponse] object that has a [signal LobbyResponse.finished] signal that is emitted when finished.
Generates [signal received_lobby_data].
*/
//go:nosplit
func (self class) DelLobbyData(keys Array.Contains[String.Readable], is_private bool) [1]gdclass.LobbyResponse { //gd:LobbyClient.del_lobby_data
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalArray(keys)))
	callframe.Arg(frame, is_private)
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.LobbyClient.Bind_del_lobby_data, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.LobbyResponse{gd.PointerWithOwnershipTransferredToGo[gdclass.LobbyResponse](r_ret.Get())}
	frame.Free()
	return ret
}

/*
Add data to a peer. Only works if you are host.
Needs [method connect_to_server] to be called first.
Returns a [LobbyResponse] object that has a [signal LobbyResponse.finished] signal that is emitted when finished.
Generates [signal received_peer_data].
*/
//go:nosplit
func (self class) AddPeerData(data Dictionary.Any, target_peer String.Readable, is_private bool) [1]gdclass.LobbyResponse { //gd:LobbyClient.add_peer_data
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalDictionary(data)))
	callframe.Arg(frame, pointers.Get(gd.InternalString(target_peer)))
	callframe.Arg(frame, is_private)
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.LobbyClient.Bind_add_peer_data, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.LobbyResponse{gd.PointerWithOwnershipTransferredToGo[gdclass.LobbyResponse](r_ret.Get())}
	frame.Free()
	return ret
}

/*
Delete one or more keys from the peer data. Only works if you are host.
Needs [method connect_to_server] to be called first.
Returns a [LobbyResponse] object that has a [signal LobbyResponse.finished] signal that is emitted when finished.
Generates [signal received_peer_data].
*/
//go:nosplit
func (self class) DelPeerData(keys Array.Contains[String.Readable], target_peer String.Readable, is_private bool) [1]gdclass.LobbyResponse { //gd:LobbyClient.del_peer_data
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalArray(keys)))
	callframe.Arg(frame, pointers.Get(gd.InternalString(target_peer)))
	callframe.Arg(frame, is_private)
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.LobbyClient.Bind_del_peer_data, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.LobbyResponse{gd.PointerWithOwnershipTransferredToGo[gdclass.LobbyResponse](r_ret.Get())}
	frame.Free()
	return ret
}

/*
Add data to all peers. Only works if you are host.
Needs [method connect_to_server] to be called first.
Returns a [LobbyResponse] object that has a [signal LobbyResponse.finished] signal that is emitted when finished.
Generates [signal received_peer_data].
*/
//go:nosplit
func (self class) AddPeersData(data Dictionary.Any, is_private bool) [1]gdclass.LobbyResponse { //gd:LobbyClient.add_peers_data
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalDictionary(data)))
	callframe.Arg(frame, is_private)
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.LobbyClient.Bind_add_peers_data, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.LobbyResponse{gd.PointerWithOwnershipTransferredToGo[gdclass.LobbyResponse](r_ret.Get())}
	frame.Free()
	return ret
}

/*
Delete one or more keys from the peers data. Only works if you are host.
Needs [method connect_to_server] to be called first.
Returns a [LobbyResponse] object that has a [signal LobbyResponse.finished] signal that is emitted when finished.
Generates [signal received_peer_data].
*/
//go:nosplit
func (self class) DelPeersData(keys Array.Contains[String.Readable], is_private bool) [1]gdclass.LobbyResponse { //gd:LobbyClient.del_peers_data
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalArray(keys)))
	callframe.Arg(frame, is_private)
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.LobbyClient.Bind_del_peers_data, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.LobbyResponse{gd.PointerWithOwnershipTransferredToGo[gdclass.LobbyResponse](r_ret.Get())}
	frame.Free()
	return ret
}
func (self Instance) OnConnectedToServer(cb func(peer LobbyPeer.Instance, reconnection_token string)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("connected_to_server"), gd.NewCallable(cb), 0)
}

func (self Instance) OnDisconnectedFromServer(cb func(reason string)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("disconnected_from_server"), gd.NewCallable(cb), 0)
}

func (self Instance) OnReceivedPeerUserData(cb func(peer LobbyPeer.Instance, data Object.Instance)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("received_peer_user_data"), gd.NewCallable(cb), 0)
}

func (self Instance) OnLobbyNotified(cb func(data Object.Instance, from_peer LobbyPeer.Instance)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("lobby_notified"), gd.NewCallable(cb), 0)
}

func (self Instance) OnReceivedPeerData(cb func(data Object.Instance, to_peer LobbyPeer.Instance, is_private bool)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("received_peer_data"), gd.NewCallable(cb), 0)
}

func (self Instance) OnReceivedLobbyData(cb func(data Object.Instance, is_private bool)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("received_lobby_data"), gd.NewCallable(cb), 0)
}

func (self Instance) OnLobbyCreated(cb func(lobby LobbyInfo.Instance, peers []LobbyPeer.Instance)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("lobby_created"), gd.NewCallable(cb), 0)
}

func (self Instance) OnLobbyJoined(cb func(lobby LobbyInfo.Instance, peers []LobbyPeer.Instance)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("lobby_joined"), gd.NewCallable(cb), 0)
}

func (self Instance) OnLobbyLeft(cb func(kicked bool)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("lobby_left"), gd.NewCallable(cb), 0)
}

func (self Instance) OnLobbySealed(cb func(sealed bool)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("lobby_sealed"), gd.NewCallable(cb), 0)
}

func (self Instance) OnLobbyTagged(cb func(tags map[any]any)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("lobby_tagged"), gd.NewCallable(cb), 0)
}

func (self Instance) OnLobbiesListed(cb func(lobbies []LobbyInfo.Instance)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("lobbies_listed"), gd.NewCallable(cb), 0)
}

func (self Instance) OnPeerJoined(cb func(peer LobbyPeer.Instance)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("peer_joined"), gd.NewCallable(cb), 0)
}

func (self Instance) OnPeerReconnected(cb func(peer LobbyPeer.Instance)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("peer_reconnected"), gd.NewCallable(cb), 0)
}

func (self Instance) OnPeerLeft(cb func(peer LobbyPeer.Instance, kicked bool)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("peer_left"), gd.NewCallable(cb), 0)
}

func (self Instance) OnPeerDisconnected(cb func(peer LobbyPeer.Instance)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("peer_disconnected"), gd.NewCallable(cb), 0)
}

func (self Instance) OnPeerMessaged(cb func(peer LobbyPeer.Instance, chat_message string)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("peer_messaged"), gd.NewCallable(cb), 0)
}

func (self Instance) OnPeerReady(cb func(peer LobbyPeer.Instance, is_ready bool)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("peer_ready"), gd.NewCallable(cb), 0)
}

func (self Instance) OnLogUpdated(cb func(command string, logs string)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("log_updated"), gd.NewCallable(cb), 0)
}

func (self class) AsLobbyClient() Advanced         { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsLobbyClient() Instance      { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsLobbyClient() Instance { return self.Super().AsLobbyClient() }
func (self class) AsBlaziumClient() BlaziumClient.Advanced {
	return *((*BlaziumClient.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsBlaziumClient() BlaziumClient.Instance {
	return self.Super().AsBlaziumClient()
}
func (self Instance) AsBlaziumClient() BlaziumClient.Instance {
	return *((*BlaziumClient.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsNode() Node.Advanced         { return *((*Node.Advanced)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsNode() Node.Instance { return self.Super().AsNode() }
func (self Instance) AsNode() Node.Instance      { return *((*Node.Instance)(unsafe.Pointer(&self))) }

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(BlaziumClient.Advanced(self.AsBlaziumClient()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(BlaziumClient.Instance(self.AsBlaziumClient()), name)
	}
}
func init() {
	gdclass.Register("LobbyClient", func(ptr gd.Object) any { return [1]gdclass.LobbyClient{*(*gdclass.LobbyClient)(unsafe.Pointer(&ptr))} })
}
