// Code generated by the generate package DO NOT EDIT

// Package EngineDebugger provides methods for working with EngineDebugger object instances.
package EngineDebugger

import "unsafe"
import "sync"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/variant/Signal"
import "graphics.gd/classdb/EngineProfiler"
import "graphics.gd/classdb/ScriptLanguage"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Signal.Any
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
[EngineDebugger] handles the communication between the editor and the running game. It is active in the running game. Messages can be sent/received through it. It also manages the profilers.
*/
type Instance [1]gdclass.EngineDebugger

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	is_active                  gdextension.MethodForClass `hash:"2240911060"`
	register_profiler          gdextension.MethodForClass `hash:"3651669560"`
	unregister_profiler        gdextension.MethodForClass `hash:"3304788590"`
	is_profiling               gdextension.MethodForClass `hash:"2041966384"`
	has_profiler               gdextension.MethodForClass `hash:"2041966384"`
	profiler_add_frame_data    gdextension.MethodForClass `hash:"1895267858"`
	profiler_enable            gdextension.MethodForClass `hash:"3192561009"`
	register_message_capture   gdextension.MethodForClass `hash:"1874754934"`
	unregister_message_capture gdextension.MethodForClass `hash:"3304788590"`
	has_capture                gdextension.MethodForClass `hash:"2041966384"`
	line_poll                  gdextension.MethodForClass `hash:"3218959716"`
	send_message               gdextension.MethodForClass `hash:"1209351045"`
	debug                      gdextension.MethodForClass `hash:"2751962654"`
	script_debug               gdextension.MethodForClass `hash:"2442343672"`
	set_lines_left             gdextension.MethodForClass `hash:"1286410249"`
	get_lines_left             gdextension.MethodForClass `hash:"3905245786"`
	set_depth                  gdextension.MethodForClass `hash:"1286410249"`
	get_depth                  gdextension.MethodForClass `hash:"3905245786"`
	is_breakpoint              gdextension.MethodForClass `hash:"921227809"`
	is_skipping_breakpoints    gdextension.MethodForClass `hash:"36873697"`
	insert_breakpoint          gdextension.MethodForClass `hash:"3780747571"`
	remove_breakpoint          gdextension.MethodForClass `hash:"3780747571"`
	clear_breakpoints          gdextension.MethodForClass `hash:"3218959716"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("EngineDebugger")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		gdextension.Free(gdextension.TypeStringName, &sname)
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

var self [1]gdclass.EngineDebugger
var once sync.Once

func singleton() {
	self[0] = pointers.Raw[gdclass.EngineDebugger]([3]uint64{uint64(gdextension.Host.Objects.Global(sname))})
}

/*
Returns [code]true[/code] if the debugger is active otherwise [code]false[/code].
*/
func IsActive() bool { //gd:EngineDebugger.is_active
	once.Do(singleton)
	return bool(Advanced().IsActive())
}

/*
Registers a profiler with the given [param name]. See [EngineProfiler] for more information.
*/
func RegisterProfiler(name string, profiler EngineProfiler.Instance) { //gd:EngineDebugger.register_profiler
	once.Do(singleton)
	Advanced().RegisterProfiler(String.Name(String.New(name)), profiler)
}

/*
Unregisters a profiler with given [param name].
*/
func UnregisterProfiler(name string) { //gd:EngineDebugger.unregister_profiler
	once.Do(singleton)
	Advanced().UnregisterProfiler(String.Name(String.New(name)))
}

/*
Returns [code]true[/code] if a profiler with the given name is present and active otherwise [code]false[/code].
*/
func IsProfiling(name string) bool { //gd:EngineDebugger.is_profiling
	once.Do(singleton)
	return bool(Advanced().IsProfiling(String.Name(String.New(name))))
}

/*
Returns [code]true[/code] if a profiler with the given name is present otherwise [code]false[/code].
*/
func HasProfiler(name string) bool { //gd:EngineDebugger.has_profiler
	once.Do(singleton)
	return bool(Advanced().HasProfiler(String.Name(String.New(name))))
}

/*
Calls the [code]add[/code] callable of the profiler with given [param name] and [param data].
*/
func ProfilerAddFrameData(name string, data []any) { //gd:EngineDebugger.profiler_add_frame_data
	once.Do(singleton)
	Advanced().ProfilerAddFrameData(String.Name(String.New(name)), gd.EngineArrayFromSlice(data))
}

/*
Calls the [code]toggle[/code] callable of the profiler with given [param name] and [param arguments]. Enables/Disables the same profiler depending on [param enable] argument.
*/
func ProfilerEnable(name string, enable bool, arguments []any) { //gd:EngineDebugger.profiler_enable
	once.Do(singleton)
	Advanced().ProfilerEnable(String.Name(String.New(name)), enable, gd.EngineArrayFromSlice(arguments))
}

/*
Calls the [code]toggle[/code] callable of the profiler with given [param name] and [param arguments]. Enables/Disables the same profiler depending on [param enable] argument.
*/
func ProfilerEnableOptions(name string, enable bool, arguments []any) { //gd:EngineDebugger.profiler_enable
	once.Do(singleton)
	Advanced().ProfilerEnable(String.Name(String.New(name)), enable, gd.EngineArrayFromSlice(arguments))
}

/*
Registers a message capture with given [param name]. If [param name] is "my_message" then messages starting with "my_message:" will be called with the given callable.
The callable must accept a message string and a data array as argument. The callable should return [code]true[/code] if the message is recognized.
[b]Note:[/b] The callable will receive the message with the prefix stripped, unlike [method EditorDebuggerPlugin._capture]. See the [EditorDebuggerPlugin] description for an example.
*/
func RegisterMessageCapture(name string, callable func(message string, data []any)) { //gd:EngineDebugger.register_message_capture
	once.Do(singleton)
	Advanced().RegisterMessageCapture(String.Name(String.New(name)), Callable.New(callable))
}

/*
Unregisters the message capture with given [param name].
*/
func UnregisterMessageCapture(name string) { //gd:EngineDebugger.unregister_message_capture
	once.Do(singleton)
	Advanced().UnregisterMessageCapture(String.Name(String.New(name)))
}

/*
Returns [code]true[/code] if a capture with the given name is present otherwise [code]false[/code].
*/
func HasCapture(name string) bool { //gd:EngineDebugger.has_capture
	once.Do(singleton)
	return bool(Advanced().HasCapture(String.Name(String.New(name))))
}

/*
Forces a processing loop of debugger events. The purpose of this method is just processing events every now and then when the script might get too busy, so that bugs like infinite loops can be caught.
*/
func LinePoll() { //gd:EngineDebugger.line_poll
	once.Do(singleton)
	Advanced().LinePoll()
}

/*
Sends a message with given [param message] and [param data] array.
*/
func SendMessage(message string, data []any) { //gd:EngineDebugger.send_message
	once.Do(singleton)
	Advanced().SendMessage(String.New(message), gd.EngineArrayFromSlice(data))
}

/*
Starts a debug break in script execution, optionally specifying whether the program can continue based on [param can_continue] and whether the break was due to a breakpoint.
*/
func Debug(is_error_breakpoint bool) { //gd:EngineDebugger.debug
	once.Do(singleton)
	Advanced().Debug(true, is_error_breakpoint)
}

/*
Starts a debug break in script execution, optionally specifying whether the program can continue based on [param can_continue] and whether the break was due to a breakpoint.
*/
func DebugOptions(can_continue bool, is_error_breakpoint bool) { //gd:EngineDebugger.debug
	once.Do(singleton)
	Advanced().Debug(can_continue, is_error_breakpoint)
}

/*
Starts a debug break in script execution, optionally specifying whether the program can continue based on [param can_continue] and whether the break was due to a breakpoint.
*/
func ScriptDebug(language ScriptLanguage.Instance, is_error_breakpoint bool) { //gd:EngineDebugger.script_debug
	once.Do(singleton)
	Advanced().ScriptDebug(language, true, is_error_breakpoint)
}

/*
Starts a debug break in script execution, optionally specifying whether the program can continue based on [param can_continue] and whether the break was due to a breakpoint.
*/
func ScriptDebugOptions(language ScriptLanguage.Instance, can_continue bool, is_error_breakpoint bool) { //gd:EngineDebugger.script_debug
	once.Do(singleton)
	Advanced().ScriptDebug(language, can_continue, is_error_breakpoint)
}

/*
Sets the current debugging lines that remain.
*/
func SetLinesLeft(lines int) { //gd:EngineDebugger.set_lines_left
	once.Do(singleton)
	Advanced().SetLinesLeft(int64(lines))
}

/*
Returns the number of lines that remain.
*/
func GetLinesLeft() int { //gd:EngineDebugger.get_lines_left
	once.Do(singleton)
	return int(int(Advanced().GetLinesLeft()))
}

/*
Sets the current debugging depth.
*/
func SetDepth(depth int) { //gd:EngineDebugger.set_depth
	once.Do(singleton)
	Advanced().SetDepth(int64(depth))
}

/*
Returns the current debug depth.
*/
func GetDepth() int { //gd:EngineDebugger.get_depth
	once.Do(singleton)
	return int(int(Advanced().GetDepth()))
}

/*
Returns [code]true[/code] if the given [param source] and [param line] represent an existing breakpoint.
*/
func IsBreakpoint(line int, source string) bool { //gd:EngineDebugger.is_breakpoint
	once.Do(singleton)
	return bool(Advanced().IsBreakpoint(int64(line), String.Name(String.New(source))))
}

/*
Returns [code]true[/code] if the debugger is skipping breakpoints otherwise [code]false[/code].
*/
func IsSkippingBreakpoints() bool { //gd:EngineDebugger.is_skipping_breakpoints
	once.Do(singleton)
	return bool(Advanced().IsSkippingBreakpoints())
}

/*
Inserts a new breakpoint with the given [param source] and [param line].
*/
func InsertBreakpoint(line int, source string) { //gd:EngineDebugger.insert_breakpoint
	once.Do(singleton)
	Advanced().InsertBreakpoint(int64(line), String.Name(String.New(source)))
}

/*
Removes a breakpoint with the given [param source] and [param line].
*/
func RemoveBreakpoint(line int, source string) { //gd:EngineDebugger.remove_breakpoint
	once.Do(singleton)
	Advanced().RemoveBreakpoint(int64(line), String.Name(String.New(source)))
}

/*
Clears all breakpoints.
*/
func ClearBreakpoints() { //gd:EngineDebugger.clear_breakpoints
	once.Do(singleton)
	Advanced().ClearBreakpoints()
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
func Advanced() class { once.Do(singleton); return self }

type class [1]gdclass.EngineDebugger

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.EngineDebugger)(unsafe.Pointer(&obj))
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.EngineDebugger)(unsafe.Pointer(&obj))
		return true
	}
	return false
}

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }

/*
Returns [code]true[/code] if the debugger is active otherwise [code]false[/code].
*/
//go:nosplit
func (self class) IsActive() bool { //gd:EngineDebugger.is_active
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_active, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Registers a profiler with the given [param name]. See [EngineProfiler] for more information.
*/
//go:nosplit
func (self class) RegisterProfiler(name String.Name, profiler [1]gdclass.EngineProfiler) { //gd:EngineDebugger.register_profiler
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.register_profiler, 0|(gdextension.SizeStringName<<4)|(gdextension.SizeObject<<8), unsafe.Pointer(&struct {
		name     gdextension.StringName
		profiler gdextension.Object
	}{pointers.Get(gd.InternalStringName(name)), gdextension.Object(gd.ObjectChecked(profiler[0].AsObject()))}))
}

/*
Unregisters a profiler with given [param name].
*/
//go:nosplit
func (self class) UnregisterProfiler(name String.Name) { //gd:EngineDebugger.unregister_profiler
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.unregister_profiler, 0|(gdextension.SizeStringName<<4), unsafe.Pointer(&struct{ name gdextension.StringName }{pointers.Get(gd.InternalStringName(name))}))
}

/*
Returns [code]true[/code] if a profiler with the given name is present and active otherwise [code]false[/code].
*/
//go:nosplit
func (self class) IsProfiling(name String.Name) bool { //gd:EngineDebugger.is_profiling
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_profiling, gdextension.SizeBool|(gdextension.SizeStringName<<4), unsafe.Pointer(&struct{ name gdextension.StringName }{pointers.Get(gd.InternalStringName(name))}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if a profiler with the given name is present otherwise [code]false[/code].
*/
//go:nosplit
func (self class) HasProfiler(name String.Name) bool { //gd:EngineDebugger.has_profiler
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.has_profiler, gdextension.SizeBool|(gdextension.SizeStringName<<4), unsafe.Pointer(&struct{ name gdextension.StringName }{pointers.Get(gd.InternalStringName(name))}))
	var ret = r_ret
	return ret
}

/*
Calls the [code]add[/code] callable of the profiler with given [param name] and [param data].
*/
//go:nosplit
func (self class) ProfilerAddFrameData(name String.Name, data Array.Any) { //gd:EngineDebugger.profiler_add_frame_data
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.profiler_add_frame_data, 0|(gdextension.SizeStringName<<4)|(gdextension.SizeArray<<8), unsafe.Pointer(&struct {
		name gdextension.StringName
		data gdextension.Array
	}{pointers.Get(gd.InternalStringName(name)), pointers.Get(gd.InternalArray(data))}))
}

/*
Calls the [code]toggle[/code] callable of the profiler with given [param name] and [param arguments]. Enables/Disables the same profiler depending on [param enable] argument.
*/
//go:nosplit
func (self class) ProfilerEnable(name String.Name, enable bool, arguments Array.Any) { //gd:EngineDebugger.profiler_enable
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.profiler_enable, 0|(gdextension.SizeStringName<<4)|(gdextension.SizeBool<<8)|(gdextension.SizeArray<<12), unsafe.Pointer(&struct {
		name      gdextension.StringName
		enable    bool
		arguments gdextension.Array
	}{pointers.Get(gd.InternalStringName(name)), enable, pointers.Get(gd.InternalArray(arguments))}))
}

/*
Registers a message capture with given [param name]. If [param name] is "my_message" then messages starting with "my_message:" will be called with the given callable.
The callable must accept a message string and a data array as argument. The callable should return [code]true[/code] if the message is recognized.
[b]Note:[/b] The callable will receive the message with the prefix stripped, unlike [method EditorDebuggerPlugin._capture]. See the [EditorDebuggerPlugin] description for an example.
*/
//go:nosplit
func (self class) RegisterMessageCapture(name String.Name, callable Callable.Function) { //gd:EngineDebugger.register_message_capture
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.register_message_capture, 0|(gdextension.SizeStringName<<4)|(gdextension.SizeCallable<<8), unsafe.Pointer(&struct {
		name     gdextension.StringName
		callable gdextension.Callable
	}{pointers.Get(gd.InternalStringName(name)), pointers.Get(gd.InternalCallable(callable))}))
}

/*
Unregisters the message capture with given [param name].
*/
//go:nosplit
func (self class) UnregisterMessageCapture(name String.Name) { //gd:EngineDebugger.unregister_message_capture
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.unregister_message_capture, 0|(gdextension.SizeStringName<<4), unsafe.Pointer(&struct{ name gdextension.StringName }{pointers.Get(gd.InternalStringName(name))}))
}

/*
Returns [code]true[/code] if a capture with the given name is present otherwise [code]false[/code].
*/
//go:nosplit
func (self class) HasCapture(name String.Name) bool { //gd:EngineDebugger.has_capture
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.has_capture, gdextension.SizeBool|(gdextension.SizeStringName<<4), unsafe.Pointer(&struct{ name gdextension.StringName }{pointers.Get(gd.InternalStringName(name))}))
	var ret = r_ret
	return ret
}

/*
Forces a processing loop of debugger events. The purpose of this method is just processing events every now and then when the script might get too busy, so that bugs like infinite loops can be caught.
*/
//go:nosplit
func (self class) LinePoll() { //gd:EngineDebugger.line_poll
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.line_poll, 0, unsafe.Pointer(&struct{}{}))
}

/*
Sends a message with given [param message] and [param data] array.
*/
//go:nosplit
func (self class) SendMessage(message String.Readable, data Array.Any) { //gd:EngineDebugger.send_message
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.send_message, 0|(gdextension.SizeString<<4)|(gdextension.SizeArray<<8), unsafe.Pointer(&struct {
		message gdextension.String
		data    gdextension.Array
	}{pointers.Get(gd.InternalString(message)), pointers.Get(gd.InternalArray(data))}))
}

/*
Starts a debug break in script execution, optionally specifying whether the program can continue based on [param can_continue] and whether the break was due to a breakpoint.
*/
//go:nosplit
func (self class) Debug(can_continue bool, is_error_breakpoint bool) { //gd:EngineDebugger.debug
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.debug, 0|(gdextension.SizeBool<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		can_continue        bool
		is_error_breakpoint bool
	}{can_continue, is_error_breakpoint}))
}

/*
Starts a debug break in script execution, optionally specifying whether the program can continue based on [param can_continue] and whether the break was due to a breakpoint.
*/
//go:nosplit
func (self class) ScriptDebug(language [1]gdclass.ScriptLanguage, can_continue bool, is_error_breakpoint bool) { //gd:EngineDebugger.script_debug
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.script_debug, 0|(gdextension.SizeObject<<4)|(gdextension.SizeBool<<8)|(gdextension.SizeBool<<12), unsafe.Pointer(&struct {
		language            gdextension.Object
		can_continue        bool
		is_error_breakpoint bool
	}{gdextension.Object(gd.ObjectChecked(language[0].AsObject())), can_continue, is_error_breakpoint}))
}

/*
Sets the current debugging lines that remain.
*/
//go:nosplit
func (self class) SetLinesLeft(lines int64) { //gd:EngineDebugger.set_lines_left
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_lines_left, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ lines int64 }{lines}))
}

/*
Returns the number of lines that remain.
*/
//go:nosplit
func (self class) GetLinesLeft() int64 { //gd:EngineDebugger.get_lines_left
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_lines_left, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Sets the current debugging depth.
*/
//go:nosplit
func (self class) SetDepth(depth int64) { //gd:EngineDebugger.set_depth
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_depth, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ depth int64 }{depth}))
}

/*
Returns the current debug depth.
*/
//go:nosplit
func (self class) GetDepth() int64 { //gd:EngineDebugger.get_depth
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_depth, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if the given [param source] and [param line] represent an existing breakpoint.
*/
//go:nosplit
func (self class) IsBreakpoint(line int64, source String.Name) bool { //gd:EngineDebugger.is_breakpoint
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_breakpoint, gdextension.SizeBool|(gdextension.SizeInt<<4)|(gdextension.SizeStringName<<8), unsafe.Pointer(&struct {
		line   int64
		source gdextension.StringName
	}{line, pointers.Get(gd.InternalStringName(source))}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if the debugger is skipping breakpoints otherwise [code]false[/code].
*/
//go:nosplit
func (self class) IsSkippingBreakpoints() bool { //gd:EngineDebugger.is_skipping_breakpoints
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_skipping_breakpoints, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Inserts a new breakpoint with the given [param source] and [param line].
*/
//go:nosplit
func (self class) InsertBreakpoint(line int64, source String.Name) { //gd:EngineDebugger.insert_breakpoint
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.insert_breakpoint, 0|(gdextension.SizeInt<<4)|(gdextension.SizeStringName<<8), unsafe.Pointer(&struct {
		line   int64
		source gdextension.StringName
	}{line, pointers.Get(gd.InternalStringName(source))}))
}

/*
Removes a breakpoint with the given [param source] and [param line].
*/
//go:nosplit
func (self class) RemoveBreakpoint(line int64, source String.Name) { //gd:EngineDebugger.remove_breakpoint
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.remove_breakpoint, 0|(gdextension.SizeInt<<4)|(gdextension.SizeStringName<<8), unsafe.Pointer(&struct {
		line   int64
		source gdextension.StringName
	}{line, pointers.Get(gd.InternalStringName(source))}))
}

/*
Clears all breakpoints.
*/
//go:nosplit
func (self class) ClearBreakpoints() { //gd:EngineDebugger.clear_breakpoints
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.clear_breakpoints, 0, unsafe.Pointer(&struct{}{}))
}
func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Object.Advanced(self.AsObject()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Object.Instance(self.AsObject()), name)
	}
}
func init() {
	gdclass.Register("EngineDebugger", func(ptr gd.Object) any { return *(*Instance)(unsafe.Pointer(&ptr)) })
}
