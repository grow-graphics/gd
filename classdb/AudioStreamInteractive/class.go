// Code generated by the generate package DO NOT EDIT

// Package AudioStreamInteractive provides methods for working with AudioStreamInteractive object instances.
package AudioStreamInteractive

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/variant/Signal"
import "graphics.gd/classdb/AudioStream"
import "graphics.gd/classdb/Resource"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Signal.Any
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
This is an audio stream that can playback music interactively, combining clips and a transition table. Clips must be added first, and then the transition rules via the [method add_transition]. Additionally, this stream exports a property parameter to control the playback via [AudioStreamPlayer], [AudioStreamPlayer2D], or [AudioStreamPlayer3D].
The way this is used is by filling a number of clips, then configuring the transition table. From there, clips are selected for playback and the music will smoothly go from the current to the new one while using the corresponding transition rule defined in the transition table.
*/
type Instance [1]gdclass.AudioStreamInteractive

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	set_clip_count                  gdextension.MethodForClass `hash:"1286410249"`
	get_clip_count                  gdextension.MethodForClass `hash:"3905245786"`
	set_initial_clip                gdextension.MethodForClass `hash:"1286410249"`
	get_initial_clip                gdextension.MethodForClass `hash:"3905245786"`
	set_clip_name                   gdextension.MethodForClass `hash:"3780747571"`
	get_clip_name                   gdextension.MethodForClass `hash:"659327637"`
	set_clip_stream                 gdextension.MethodForClass `hash:"111075094"`
	get_clip_stream                 gdextension.MethodForClass `hash:"2739380747"`
	set_clip_auto_advance           gdextension.MethodForClass `hash:"57217598"`
	get_clip_auto_advance           gdextension.MethodForClass `hash:"1778634807"`
	set_clip_auto_advance_next_clip gdextension.MethodForClass `hash:"3937882851"`
	get_clip_auto_advance_next_clip gdextension.MethodForClass `hash:"923996154"`
	add_transition                  gdextension.MethodForClass `hash:"1630280552"`
	has_transition                  gdextension.MethodForClass `hash:"2522259332"`
	erase_transition                gdextension.MethodForClass `hash:"3937882851"`
	get_transition_list             gdextension.MethodForClass `hash:"1930428628"`
	get_transition_from_time        gdextension.MethodForClass `hash:"3453338158"`
	get_transition_to_time          gdextension.MethodForClass `hash:"1369651373"`
	get_transition_fade_mode        gdextension.MethodForClass `hash:"4065396087"`
	get_transition_fade_beats       gdextension.MethodForClass `hash:"3085491603"`
	is_transition_using_filler_clip gdextension.MethodForClass `hash:"2522259332"`
	get_transition_filler_clip      gdextension.MethodForClass `hash:"3175239445"`
	is_transition_holding_previous  gdextension.MethodForClass `hash:"2522259332"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("AudioStreamInteractive")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		gdextension.Free(gdextension.TypeStringName, &sname)
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

type Expanded [1]gdclass.AudioStreamInteractive

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsAudioStreamInteractive() Instance
}

/*
Set the name of the current clip (for easier identification).
*/
func (self Instance) SetClipName(clip_index Clip, name string) { //gd:AudioStreamInteractive.set_clip_name
	Advanced(self).SetClipName(int64(clip_index), String.Name(String.New(name)))
}

/*
Return the name of a clip.
*/
func (self Instance) GetClipName(clip_index Clip) string { //gd:AudioStreamInteractive.get_clip_name
	return string(Advanced(self).GetClipName(int64(clip_index)).String())
}

/*
Set the [AudioStream] associated with the current clip.
*/
func (self Instance) SetClipStream(clip_index Clip, stream AudioStream.Instance) { //gd:AudioStreamInteractive.set_clip_stream
	Advanced(self).SetClipStream(int64(clip_index), stream)
}

/*
Return the [AudioStream] associated with a clip.
*/
func (self Instance) GetClipStream(clip_index Clip) AudioStream.Instance { //gd:AudioStreamInteractive.get_clip_stream
	return AudioStream.Instance(Advanced(self).GetClipStream(int64(clip_index)))
}

/*
Set whether a clip will auto-advance by changing the auto-advance mode.
*/
func (self Instance) SetClipAutoAdvance(clip_index Clip, mode AutoAdvanceMode) { //gd:AudioStreamInteractive.set_clip_auto_advance
	Advanced(self).SetClipAutoAdvance(int64(clip_index), mode)
}

/*
Return whether a clip has auto-advance enabled. See [method set_clip_auto_advance].
*/
func (self Instance) GetClipAutoAdvance(clip_index Clip) AutoAdvanceMode { //gd:AudioStreamInteractive.get_clip_auto_advance
	return AutoAdvanceMode(Advanced(self).GetClipAutoAdvance(int64(clip_index)))
}

/*
Set the index of the next clip towards which this clip will auto advance to when finished. If the clip being played loops, then auto-advance will be ignored.
*/
func (self Instance) SetClipAutoAdvanceNextClip(clip_index Clip, auto_advance_next_clip Clip) { //gd:AudioStreamInteractive.set_clip_auto_advance_next_clip
	Advanced(self).SetClipAutoAdvanceNextClip(int64(clip_index), int64(auto_advance_next_clip))
}

/*
Return the clip towards which the clip referenced by [param clip_index] will auto-advance to.
*/
func (self Instance) GetClipAutoAdvanceNextClip(clip_index Clip) int { //gd:AudioStreamInteractive.get_clip_auto_advance_next_clip
	return int(int(Advanced(self).GetClipAutoAdvanceNextClip(int64(clip_index))))
}

/*
Add a transition between two clips. Provide the indices of the source and destination clips, or use the [constant CLIP_ANY] constant to indicate that transition happens to/from any clip to this one.
* [param from_time] indicates the moment in the current clip the transition will begin after triggered.
* [param to_time] indicates the time in the next clip that the playback will start from.
* [param fade_mode] indicates how the fade will happen between clips. If unsure, just use [constant FADE_AUTOMATIC] which uses the most common type of fade for each situation.
* [param fade_beats] indicates how many beats the fade will take. Using decimals is allowed.
* [param use_filler_clip] indicates that there will be a filler clip used between the source and destination clips.
* [param filler_clip] the index of the filler clip.
* If [param hold_previous] is used, then this clip will be remembered. This can be used together with [constant AUTO_ADVANCE_RETURN_TO_HOLD] to return to this clip after another is done playing.
*/
func (self Instance) AddTransition(from_clip Clip, to_clip Clip, from_time TransitionFromTime, to_time TransitionToTime, fade_mode FadeMode, fade_beats Float.X) { //gd:AudioStreamInteractive.add_transition
	Advanced(self).AddTransition(int64(from_clip), int64(to_clip), from_time, to_time, fade_mode, float64(fade_beats), false, int64(-1), false)
}

/*
Add a transition between two clips. Provide the indices of the source and destination clips, or use the [constant CLIP_ANY] constant to indicate that transition happens to/from any clip to this one.
* [param from_time] indicates the moment in the current clip the transition will begin after triggered.
* [param to_time] indicates the time in the next clip that the playback will start from.
* [param fade_mode] indicates how the fade will happen between clips. If unsure, just use [constant FADE_AUTOMATIC] which uses the most common type of fade for each situation.
* [param fade_beats] indicates how many beats the fade will take. Using decimals is allowed.
* [param use_filler_clip] indicates that there will be a filler clip used between the source and destination clips.
* [param filler_clip] the index of the filler clip.
* If [param hold_previous] is used, then this clip will be remembered. This can be used together with [constant AUTO_ADVANCE_RETURN_TO_HOLD] to return to this clip after another is done playing.
*/
func (self Expanded) AddTransition(from_clip Clip, to_clip Clip, from_time TransitionFromTime, to_time TransitionToTime, fade_mode FadeMode, fade_beats Float.X, use_filler_clip bool, filler_clip Clip, hold_previous bool) { //gd:AudioStreamInteractive.add_transition
	Advanced(self).AddTransition(int64(from_clip), int64(to_clip), from_time, to_time, fade_mode, float64(fade_beats), use_filler_clip, int64(filler_clip), hold_previous)
}

/*
Returns [code]true[/code] if a given transition exists (was added via [method add_transition]).
*/
func (self Instance) HasTransition(from_clip Clip, to_clip Clip) bool { //gd:AudioStreamInteractive.has_transition
	return bool(Advanced(self).HasTransition(int64(from_clip), int64(to_clip)))
}

/*
Erase a transition by providing [param from_clip] and [param to_clip] clip indices. [constant CLIP_ANY] can be used for either argument or both.
*/
func (self Instance) EraseTransition(from_clip Clip, to_clip Clip) { //gd:AudioStreamInteractive.erase_transition
	Advanced(self).EraseTransition(int64(from_clip), int64(to_clip))
}

/*
Return the list of transitions (from, to interleaved).
*/
func (self Instance) GetTransitionList() []int32 { //gd:AudioStreamInteractive.get_transition_list
	return []int32(slices.Collect(Advanced(self).GetTransitionList().Values()))
}

/*
Return the source time position for a transition (see [method add_transition]).
*/
func (self Instance) GetTransitionFromTime(from_clip Clip, to_clip Clip) TransitionFromTime { //gd:AudioStreamInteractive.get_transition_from_time
	return TransitionFromTime(Advanced(self).GetTransitionFromTime(int64(from_clip), int64(to_clip)))
}

/*
Return the destination time position for a transition (see [method add_transition]).
*/
func (self Instance) GetTransitionToTime(from_clip Clip, to_clip Clip) TransitionToTime { //gd:AudioStreamInteractive.get_transition_to_time
	return TransitionToTime(Advanced(self).GetTransitionToTime(int64(from_clip), int64(to_clip)))
}

/*
Return the mode for a transition (see [method add_transition]).
*/
func (self Instance) GetTransitionFadeMode(from_clip Clip, to_clip Clip) FadeMode { //gd:AudioStreamInteractive.get_transition_fade_mode
	return FadeMode(Advanced(self).GetTransitionFadeMode(int64(from_clip), int64(to_clip)))
}

/*
Return the time (in beats) for a transition (see [method add_transition]).
*/
func (self Instance) GetTransitionFadeBeats(from_clip Clip, to_clip Clip) Float.X { //gd:AudioStreamInteractive.get_transition_fade_beats
	return Float.X(Float.X(Advanced(self).GetTransitionFadeBeats(int64(from_clip), int64(to_clip))))
}

/*
Return whether a transition uses the [i]filler clip[/i] functionality (see [method add_transition]).
*/
func (self Instance) IsTransitionUsingFillerClip(from_clip Clip, to_clip Clip) bool { //gd:AudioStreamInteractive.is_transition_using_filler_clip
	return bool(Advanced(self).IsTransitionUsingFillerClip(int64(from_clip), int64(to_clip)))
}

/*
Return the filler clip for a transition (see [method add_transition]).
*/
func (self Instance) GetTransitionFillerClip(from_clip Clip, to_clip Clip) int { //gd:AudioStreamInteractive.get_transition_filler_clip
	return int(int(Advanced(self).GetTransitionFillerClip(int64(from_clip), int64(to_clip))))
}

/*
Return whether a transition uses the [i]hold previous[/i] functionality (see [method add_transition]).
*/
func (self Instance) IsTransitionHoldingPrevious(from_clip Clip, to_clip Clip) bool { //gd:AudioStreamInteractive.is_transition_holding_previous
	return bool(Advanced(self).IsTransitionHoldingPrevious(int64(from_clip), int64(to_clip)))
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.AudioStreamInteractive

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = pointers.AsA[gdclass.AudioStreamInteractive](obj[0])
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = pointers.AsA[gdclass.AudioStreamInteractive](obj[0])
		return true
	}
	return false
}
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }
func (self *Extension[T]) AsObject() [1]gd.Object { return self.Super().AsObject() }
func New() Instance {
	if !gd.Linked {
		var placeholder = Instance([1]gdclass.AudioStreamInteractive{pointers.Add[gdclass.AudioStreamInteractive]([3]uint64{})})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(pointers.AsA[gd.Object](placeholder[0]), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	casted := Instance([1]gdclass.AudioStreamInteractive{pointers.New[gdclass.AudioStreamInteractive]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})})
	casted.AsRefCounted()[0].InitRef()
	casted.AsObject()[0].Notification(0, false)
	return casted
}

func (self Instance) ClipCount() int {
	return int(int(class(self).GetClipCount()))
}

func (self Instance) SetClipCount(value int) {
	class(self).SetClipCount(int64(value))
}

func (self Instance) InitialClip() int {
	return int(int(class(self).GetInitialClip()))
}

func (self Instance) SetInitialClip(value int) {
	class(self).SetInitialClip(int64(value))
}

//go:nosplit
func (self class) SetClipCount(clip_count int64) { //gd:AudioStreamInteractive.set_clip_count
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_clip_count, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ clip_count int64 }{clip_count}))
}

//go:nosplit
func (self class) GetClipCount() int64 { //gd:AudioStreamInteractive.get_clip_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_clip_count, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetInitialClip(clip_index int64) { //gd:AudioStreamInteractive.set_initial_clip
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_initial_clip, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ clip_index int64 }{clip_index}))
}

//go:nosplit
func (self class) GetInitialClip() int64 { //gd:AudioStreamInteractive.get_initial_clip
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_initial_clip, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Set the name of the current clip (for easier identification).
*/
//go:nosplit
func (self class) SetClipName(clip_index int64, name String.Name) { //gd:AudioStreamInteractive.set_clip_name
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_clip_name, 0|(gdextension.SizeInt<<4)|(gdextension.SizeStringName<<8), unsafe.Pointer(&struct {
		clip_index int64
		name       gdextension.StringName
	}{clip_index, pointers.Get(gd.InternalStringName(name))}))
}

/*
Return the name of a clip.
*/
//go:nosplit
func (self class) GetClipName(clip_index int64) String.Name { //gd:AudioStreamInteractive.get_clip_name
	var r_ret = gdextension.Call[gdextension.StringName](gd.ObjectChecked(self.AsObject()), methods.get_clip_name, gdextension.SizeStringName|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ clip_index int64 }{clip_index}))
	var ret = String.Name(String.Via(gd.StringNameProxy{}, pointers.Pack(pointers.New[gd.StringName](r_ret))))
	return ret
}

/*
Set the [AudioStream] associated with the current clip.
*/
//go:nosplit
func (self class) SetClipStream(clip_index int64, stream [1]gdclass.AudioStream) { //gd:AudioStreamInteractive.set_clip_stream
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_clip_stream, 0|(gdextension.SizeInt<<4)|(gdextension.SizeObject<<8), unsafe.Pointer(&struct {
		clip_index int64
		stream     gdextension.Object
	}{clip_index, gdextension.Object(gd.ObjectChecked(stream[0].AsObject()))}))
}

/*
Return the [AudioStream] associated with a clip.
*/
//go:nosplit
func (self class) GetClipStream(clip_index int64) [1]gdclass.AudioStream { //gd:AudioStreamInteractive.get_clip_stream
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_clip_stream, gdextension.SizeObject|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ clip_index int64 }{clip_index}))
	var ret = [1]gdclass.AudioStream{gd.PointerWithOwnershipTransferredToGo[gdclass.AudioStream](r_ret)}
	return ret
}

/*
Set whether a clip will auto-advance by changing the auto-advance mode.
*/
//go:nosplit
func (self class) SetClipAutoAdvance(clip_index int64, mode AutoAdvanceMode) { //gd:AudioStreamInteractive.set_clip_auto_advance
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_clip_auto_advance, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		clip_index int64
		mode       AutoAdvanceMode
	}{clip_index, mode}))
}

/*
Return whether a clip has auto-advance enabled. See [method set_clip_auto_advance].
*/
//go:nosplit
func (self class) GetClipAutoAdvance(clip_index int64) AutoAdvanceMode { //gd:AudioStreamInteractive.get_clip_auto_advance
	var r_ret = gdextension.Call[AutoAdvanceMode](gd.ObjectChecked(self.AsObject()), methods.get_clip_auto_advance, gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ clip_index int64 }{clip_index}))
	var ret = r_ret
	return ret
}

/*
Set the index of the next clip towards which this clip will auto advance to when finished. If the clip being played loops, then auto-advance will be ignored.
*/
//go:nosplit
func (self class) SetClipAutoAdvanceNextClip(clip_index int64, auto_advance_next_clip int64) { //gd:AudioStreamInteractive.set_clip_auto_advance_next_clip
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_clip_auto_advance_next_clip, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		clip_index             int64
		auto_advance_next_clip int64
	}{clip_index, auto_advance_next_clip}))
}

/*
Return the clip towards which the clip referenced by [param clip_index] will auto-advance to.
*/
//go:nosplit
func (self class) GetClipAutoAdvanceNextClip(clip_index int64) int64 { //gd:AudioStreamInteractive.get_clip_auto_advance_next_clip
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_clip_auto_advance_next_clip, gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ clip_index int64 }{clip_index}))
	var ret = r_ret
	return ret
}

/*
Add a transition between two clips. Provide the indices of the source and destination clips, or use the [constant CLIP_ANY] constant to indicate that transition happens to/from any clip to this one.
* [param from_time] indicates the moment in the current clip the transition will begin after triggered.
* [param to_time] indicates the time in the next clip that the playback will start from.
* [param fade_mode] indicates how the fade will happen between clips. If unsure, just use [constant FADE_AUTOMATIC] which uses the most common type of fade for each situation.
* [param fade_beats] indicates how many beats the fade will take. Using decimals is allowed.
* [param use_filler_clip] indicates that there will be a filler clip used between the source and destination clips.
* [param filler_clip] the index of the filler clip.
* If [param hold_previous] is used, then this clip will be remembered. This can be used together with [constant AUTO_ADVANCE_RETURN_TO_HOLD] to return to this clip after another is done playing.
*/
//go:nosplit
func (self class) AddTransition(from_clip int64, to_clip int64, from_time TransitionFromTime, to_time TransitionToTime, fade_mode FadeMode, fade_beats float64, use_filler_clip bool, filler_clip int64, hold_previous bool) { //gd:AudioStreamInteractive.add_transition
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_transition, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeInt<<16)|(gdextension.SizeInt<<20)|(gdextension.SizeFloat<<24)|(gdextension.SizeBool<<28)|(gdextension.SizeInt<<32)|(gdextension.SizeBool<<36), unsafe.Pointer(&struct {
		from_clip       int64
		to_clip         int64
		from_time       TransitionFromTime
		to_time         TransitionToTime
		fade_mode       FadeMode
		fade_beats      float64
		use_filler_clip bool
		filler_clip     int64
		hold_previous   bool
	}{from_clip, to_clip, from_time, to_time, fade_mode, fade_beats, use_filler_clip, filler_clip, hold_previous}))
}

/*
Returns [code]true[/code] if a given transition exists (was added via [method add_transition]).
*/
//go:nosplit
func (self class) HasTransition(from_clip int64, to_clip int64) bool { //gd:AudioStreamInteractive.has_transition
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.has_transition, gdextension.SizeBool|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		from_clip int64
		to_clip   int64
	}{from_clip, to_clip}))
	var ret = r_ret
	return ret
}

/*
Erase a transition by providing [param from_clip] and [param to_clip] clip indices. [constant CLIP_ANY] can be used for either argument or both.
*/
//go:nosplit
func (self class) EraseTransition(from_clip int64, to_clip int64) { //gd:AudioStreamInteractive.erase_transition
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.erase_transition, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		from_clip int64
		to_clip   int64
	}{from_clip, to_clip}))
}

/*
Return the list of transitions (from, to interleaved).
*/
//go:nosplit
func (self class) GetTransitionList() Packed.Array[int32] { //gd:AudioStreamInteractive.get_transition_list
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.get_transition_list, gdextension.SizePackedArray, unsafe.Pointer(&struct{}{}))
	var ret = Packed.Array[int32](Array.Through(gd.PackedProxy[gd.PackedInt32Array, int32]{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

/*
Return the source time position for a transition (see [method add_transition]).
*/
//go:nosplit
func (self class) GetTransitionFromTime(from_clip int64, to_clip int64) TransitionFromTime { //gd:AudioStreamInteractive.get_transition_from_time
	var r_ret = gdextension.Call[TransitionFromTime](gd.ObjectChecked(self.AsObject()), methods.get_transition_from_time, gdextension.SizeInt|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		from_clip int64
		to_clip   int64
	}{from_clip, to_clip}))
	var ret = r_ret
	return ret
}

/*
Return the destination time position for a transition (see [method add_transition]).
*/
//go:nosplit
func (self class) GetTransitionToTime(from_clip int64, to_clip int64) TransitionToTime { //gd:AudioStreamInteractive.get_transition_to_time
	var r_ret = gdextension.Call[TransitionToTime](gd.ObjectChecked(self.AsObject()), methods.get_transition_to_time, gdextension.SizeInt|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		from_clip int64
		to_clip   int64
	}{from_clip, to_clip}))
	var ret = r_ret
	return ret
}

/*
Return the mode for a transition (see [method add_transition]).
*/
//go:nosplit
func (self class) GetTransitionFadeMode(from_clip int64, to_clip int64) FadeMode { //gd:AudioStreamInteractive.get_transition_fade_mode
	var r_ret = gdextension.Call[FadeMode](gd.ObjectChecked(self.AsObject()), methods.get_transition_fade_mode, gdextension.SizeInt|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		from_clip int64
		to_clip   int64
	}{from_clip, to_clip}))
	var ret = r_ret
	return ret
}

/*
Return the time (in beats) for a transition (see [method add_transition]).
*/
//go:nosplit
func (self class) GetTransitionFadeBeats(from_clip int64, to_clip int64) float64 { //gd:AudioStreamInteractive.get_transition_fade_beats
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_transition_fade_beats, gdextension.SizeFloat|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		from_clip int64
		to_clip   int64
	}{from_clip, to_clip}))
	var ret = r_ret
	return ret
}

/*
Return whether a transition uses the [i]filler clip[/i] functionality (see [method add_transition]).
*/
//go:nosplit
func (self class) IsTransitionUsingFillerClip(from_clip int64, to_clip int64) bool { //gd:AudioStreamInteractive.is_transition_using_filler_clip
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_transition_using_filler_clip, gdextension.SizeBool|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		from_clip int64
		to_clip   int64
	}{from_clip, to_clip}))
	var ret = r_ret
	return ret
}

/*
Return the filler clip for a transition (see [method add_transition]).
*/
//go:nosplit
func (self class) GetTransitionFillerClip(from_clip int64, to_clip int64) int64 { //gd:AudioStreamInteractive.get_transition_filler_clip
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_transition_filler_clip, gdextension.SizeInt|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		from_clip int64
		to_clip   int64
	}{from_clip, to_clip}))
	var ret = r_ret
	return ret
}

/*
Return whether a transition uses the [i]hold previous[/i] functionality (see [method add_transition]).
*/
//go:nosplit
func (self class) IsTransitionHoldingPrevious(from_clip int64, to_clip int64) bool { //gd:AudioStreamInteractive.is_transition_holding_previous
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_transition_holding_previous, gdextension.SizeBool|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		from_clip int64
		to_clip   int64
	}{from_clip, to_clip}))
	var ret = r_ret
	return ret
}
func (self class) AsAudioStreamInteractive() Advanced {
	return Advanced{pointers.AsA[gdclass.AudioStreamInteractive](self[0])}
}
func (self Instance) AsAudioStreamInteractive() Instance {
	return Instance{pointers.AsA[gdclass.AudioStreamInteractive](self[0])}
}
func (self *Extension[T]) AsAudioStreamInteractive() Instance {
	return self.Super().AsAudioStreamInteractive()
}
func (self class) AsAudioStream() AudioStream.Advanced {
	return AudioStream.Advanced{pointers.AsA[gdclass.AudioStream](self[0])}
}
func (self *Extension[T]) AsAudioStream() AudioStream.Instance { return self.Super().AsAudioStream() }
func (self Instance) AsAudioStream() AudioStream.Instance {
	return AudioStream.Instance{pointers.AsA[gdclass.AudioStream](self[0])}
}
func (self class) AsResource() Resource.Advanced {
	return Resource.Advanced{pointers.AsA[gdclass.Resource](self[0])}
}
func (self *Extension[T]) AsResource() Resource.Instance { return self.Super().AsResource() }
func (self Instance) AsResource() Resource.Instance {
	return Resource.Instance{pointers.AsA[gdclass.Resource](self[0])}
}
func (self class) AsRefCounted() [1]gd.RefCounted {
	return [1]gd.RefCounted{gd.RefCounted(pointers.AsA[gd.Object](self[0]))}
}
func (self *Extension[T]) AsRefCounted() [1]gd.RefCounted { return self.Super().AsRefCounted() }
func (self Instance) AsRefCounted() [1]gd.RefCounted {
	return [1]gd.RefCounted{gd.RefCounted(pointers.AsA[gd.Object](self[0]))}
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(AudioStream.Advanced(self.AsAudioStream()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(AudioStream.Instance(self.AsAudioStream()), name)
	}
}
func init() {
	gdclass.Register("AudioStreamInteractive", func(ptr gd.Object) any { return Instance{pointers.AsA[gdclass.AudioStreamInteractive](ptr)} })
}

type TransitionFromTime int //gd:AudioStreamInteractive.TransitionFromTime

const (
	/*Start transition as soon as possible, don't wait for any specific time position.*/
	TransitionFromTimeImmediate TransitionFromTime = 0
	/*Transition when the clip playback position reaches the next beat.*/
	TransitionFromTimeNextBeat TransitionFromTime = 1
	/*Transition when the clip playback position reaches the next bar.*/
	TransitionFromTimeNextBar TransitionFromTime = 2
	/*Transition when the current clip finished playing.*/
	TransitionFromTimeEnd TransitionFromTime = 3
)

type TransitionToTime int //gd:AudioStreamInteractive.TransitionToTime

const (
	/*Transition to the same position in the destination clip. This is useful when both clips have exactly the same length and the music should fade between them.*/
	TransitionToTimeSamePosition TransitionToTime = 0
	/*Transition to the start of the destination clip.*/
	TransitionToTimeStart TransitionToTime = 1
)

type FadeMode int //gd:AudioStreamInteractive.FadeMode

const (
	/*Do not use fade for the transition. This is useful when transitioning from a clip-end to clip-beginning, and each clip has their begin/end.*/
	FadeDisabled FadeMode = 0
	/*Use a fade-in in the next clip, let the current clip finish.*/
	FadeIn FadeMode = 1
	/*Use a fade-out in the current clip, the next clip will start by itself.*/
	FadeOut FadeMode = 2
	/*Use a cross-fade between clips.*/
	FadeCross FadeMode = 3
	/*Use automatic fade logic depending on the transition from/to. It is recommended to use this by default.*/
	FadeAutomatic FadeMode = 4
)

type AutoAdvanceMode int //gd:AudioStreamInteractive.AutoAdvanceMode

const (
	/*Disable auto-advance (default).*/
	AutoAdvanceDisabled AutoAdvanceMode = 0
	/*Enable auto-advance, a clip must be specified.*/
	AutoAdvanceEnabled AutoAdvanceMode = 1
	/*Enable auto-advance, but instead of specifying a clip, the playback will return to hold (see [method add_transition]).*/
	AutoAdvanceReturnToHold AutoAdvanceMode = 2
)

type Clip int

const ClipAny Clip = -1 //gd:AudioStreamInteractive.CLIP_ANY
