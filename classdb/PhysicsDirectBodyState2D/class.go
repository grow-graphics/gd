// Code generated by the generate package DO NOT EDIT

// Package PhysicsDirectBodyState2D provides methods for working with PhysicsDirectBodyState2D object instances.
package PhysicsDirectBodyState2D

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/variant/Signal"
import "graphics.gd/classdb/PhysicsDirectSpaceState2D"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"
import "graphics.gd/variant/Transform2D"
import "graphics.gd/variant/Vector2"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Signal.Any
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
Provides direct access to a physics body in the [PhysicsServer2D], allowing safe changes to physics properties. This object is passed via the direct state callback of [RigidBody2D], and is intended for changing the direct state of that body. See [method RigidBody2D._integrate_forces].
*/
type Instance [1]gdclass.PhysicsDirectBodyState2D

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	get_total_gravity                         gdextension.MethodForClass `hash:"3341600327"`
	get_total_linear_damp                     gdextension.MethodForClass `hash:"1740695150"`
	get_total_angular_damp                    gdextension.MethodForClass `hash:"1740695150"`
	get_center_of_mass                        gdextension.MethodForClass `hash:"3341600327"`
	get_center_of_mass_local                  gdextension.MethodForClass `hash:"3341600327"`
	get_inverse_mass                          gdextension.MethodForClass `hash:"1740695150"`
	get_inverse_inertia                       gdextension.MethodForClass `hash:"1740695150"`
	set_linear_velocity                       gdextension.MethodForClass `hash:"743155724"`
	get_linear_velocity                       gdextension.MethodForClass `hash:"3341600327"`
	set_angular_velocity                      gdextension.MethodForClass `hash:"373806689"`
	get_angular_velocity                      gdextension.MethodForClass `hash:"1740695150"`
	set_transform                             gdextension.MethodForClass `hash:"2761652528"`
	get_transform                             gdextension.MethodForClass `hash:"3814499831"`
	get_velocity_at_local_position            gdextension.MethodForClass `hash:"2656412154"`
	apply_central_impulse                     gdextension.MethodForClass `hash:"743155724"`
	apply_torque_impulse                      gdextension.MethodForClass `hash:"373806689"`
	apply_impulse                             gdextension.MethodForClass `hash:"4288681949"`
	apply_central_force                       gdextension.MethodForClass `hash:"3862383994"`
	apply_force                               gdextension.MethodForClass `hash:"4288681949"`
	apply_torque                              gdextension.MethodForClass `hash:"373806689"`
	add_constant_central_force                gdextension.MethodForClass `hash:"3862383994"`
	add_constant_force                        gdextension.MethodForClass `hash:"4288681949"`
	add_constant_torque                       gdextension.MethodForClass `hash:"373806689"`
	set_constant_force                        gdextension.MethodForClass `hash:"743155724"`
	get_constant_force                        gdextension.MethodForClass `hash:"3341600327"`
	set_constant_torque                       gdextension.MethodForClass `hash:"373806689"`
	get_constant_torque                       gdextension.MethodForClass `hash:"1740695150"`
	set_sleep_state                           gdextension.MethodForClass `hash:"2586408642"`
	is_sleeping                               gdextension.MethodForClass `hash:"36873697"`
	get_contact_count                         gdextension.MethodForClass `hash:"3905245786"`
	get_contact_local_position                gdextension.MethodForClass `hash:"2299179447"`
	get_contact_local_normal                  gdextension.MethodForClass `hash:"2299179447"`
	get_contact_local_shape                   gdextension.MethodForClass `hash:"923996154"`
	get_contact_local_velocity_at_position    gdextension.MethodForClass `hash:"2299179447"`
	get_contact_collider                      gdextension.MethodForClass `hash:"495598643"`
	get_contact_collider_position             gdextension.MethodForClass `hash:"2299179447"`
	get_contact_collider_id                   gdextension.MethodForClass `hash:"923996154"`
	get_contact_collider_object               gdextension.MethodForClass `hash:"3332903315"`
	get_contact_collider_shape                gdextension.MethodForClass `hash:"923996154"`
	get_contact_collider_velocity_at_position gdextension.MethodForClass `hash:"2299179447"`
	get_contact_impulse                       gdextension.MethodForClass `hash:"2299179447"`
	get_step                                  gdextension.MethodForClass `hash:"1740695150"`
	integrate_forces                          gdextension.MethodForClass `hash:"3218959716"`
	get_space_state                           gdextension.MethodForClass `hash:"2506717822"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("PhysicsDirectBodyState2D")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		gdextension.Free(gdextension.TypeStringName, &sname)
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

type Expanded [1]gdclass.PhysicsDirectBodyState2D

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsPhysicsDirectBodyState2D() Instance
}

/*
Returns the body's velocity at the given relative position, including both translation and rotation.
*/
func (self Instance) GetVelocityAtLocalPosition(local_position Vector2.XY) Vector2.XY { //gd:PhysicsDirectBodyState2D.get_velocity_at_local_position
	return Vector2.XY(Advanced(self).GetVelocityAtLocalPosition(Vector2.XY(local_position)))
}

/*
Applies a directional impulse without affecting rotation.
An impulse is time-independent! Applying an impulse every frame would result in a framerate-dependent force. For this reason, it should only be used when simulating one-time impacts (use the "_force" functions otherwise).
This is equivalent to using [method apply_impulse] at the body's center of mass.
*/
func (self Instance) ApplyCentralImpulse(impulse Vector2.XY) { //gd:PhysicsDirectBodyState2D.apply_central_impulse
	Advanced(self).ApplyCentralImpulse(Vector2.XY(impulse))
}

/*
Applies a rotational impulse to the body without affecting the position.
An impulse is time-independent! Applying an impulse every frame would result in a framerate-dependent force. For this reason, it should only be used when simulating one-time impacts (use the "_force" functions otherwise).
[b]Note:[/b] [member inverse_inertia] is required for this to work. To have [member inverse_inertia], an active [CollisionShape2D] must be a child of the node, or you can manually set [member inverse_inertia].
*/
func (self Instance) ApplyTorqueImpulse(impulse Float.X) { //gd:PhysicsDirectBodyState2D.apply_torque_impulse
	Advanced(self).ApplyTorqueImpulse(float64(impulse))
}

/*
Applies a positioned impulse to the body.
An impulse is time-independent! Applying an impulse every frame would result in a framerate-dependent force. For this reason, it should only be used when simulating one-time impacts (use the "_force" functions otherwise).
[param position] is the offset from the body origin in global coordinates.
*/
func (self Instance) ApplyImpulse(impulse Vector2.XY) { //gd:PhysicsDirectBodyState2D.apply_impulse
	Advanced(self).ApplyImpulse(Vector2.XY(impulse), Vector2.XY(gd.Vector2{0, 0}))
}

/*
Applies a positioned impulse to the body.
An impulse is time-independent! Applying an impulse every frame would result in a framerate-dependent force. For this reason, it should only be used when simulating one-time impacts (use the "_force" functions otherwise).
[param position] is the offset from the body origin in global coordinates.
*/
func (self Expanded) ApplyImpulse(impulse Vector2.XY, position Vector2.XY) { //gd:PhysicsDirectBodyState2D.apply_impulse
	Advanced(self).ApplyImpulse(Vector2.XY(impulse), Vector2.XY(position))
}

/*
Applies a directional force without affecting rotation. A force is time dependent and meant to be applied every physics update.
This is equivalent to using [method apply_force] at the body's center of mass.
*/
func (self Instance) ApplyCentralForce() { //gd:PhysicsDirectBodyState2D.apply_central_force
	Advanced(self).ApplyCentralForce(Vector2.XY(gd.Vector2{0, 0}))
}

/*
Applies a directional force without affecting rotation. A force is time dependent and meant to be applied every physics update.
This is equivalent to using [method apply_force] at the body's center of mass.
*/
func (self Expanded) ApplyCentralForce(force Vector2.XY) { //gd:PhysicsDirectBodyState2D.apply_central_force
	Advanced(self).ApplyCentralForce(Vector2.XY(force))
}

/*
Applies a positioned force to the body. A force is time dependent and meant to be applied every physics update.
[param position] is the offset from the body origin in global coordinates.
*/
func (self Instance) ApplyForce(force Vector2.XY) { //gd:PhysicsDirectBodyState2D.apply_force
	Advanced(self).ApplyForce(Vector2.XY(force), Vector2.XY(gd.Vector2{0, 0}))
}

/*
Applies a positioned force to the body. A force is time dependent and meant to be applied every physics update.
[param position] is the offset from the body origin in global coordinates.
*/
func (self Expanded) ApplyForce(force Vector2.XY, position Vector2.XY) { //gd:PhysicsDirectBodyState2D.apply_force
	Advanced(self).ApplyForce(Vector2.XY(force), Vector2.XY(position))
}

/*
Applies a rotational force without affecting position. A force is time dependent and meant to be applied every physics update.
[b]Note:[/b] [member inverse_inertia] is required for this to work. To have [member inverse_inertia], an active [CollisionShape2D] must be a child of the node, or you can manually set [member inverse_inertia].
*/
func (self Instance) ApplyTorque(torque Float.X) { //gd:PhysicsDirectBodyState2D.apply_torque
	Advanced(self).ApplyTorque(float64(torque))
}

/*
Adds a constant directional force without affecting rotation that keeps being applied over time until cleared with [code]constant_force = Vector2(0, 0)[/code].
This is equivalent to using [method add_constant_force] at the body's center of mass.
*/
func (self Instance) AddConstantCentralForce() { //gd:PhysicsDirectBodyState2D.add_constant_central_force
	Advanced(self).AddConstantCentralForce(Vector2.XY(gd.Vector2{0, 0}))
}

/*
Adds a constant directional force without affecting rotation that keeps being applied over time until cleared with [code]constant_force = Vector2(0, 0)[/code].
This is equivalent to using [method add_constant_force] at the body's center of mass.
*/
func (self Expanded) AddConstantCentralForce(force Vector2.XY) { //gd:PhysicsDirectBodyState2D.add_constant_central_force
	Advanced(self).AddConstantCentralForce(Vector2.XY(force))
}

/*
Adds a constant positioned force to the body that keeps being applied over time until cleared with [code]constant_force = Vector2(0, 0)[/code].
[param position] is the offset from the body origin in global coordinates.
*/
func (self Instance) AddConstantForce(force Vector2.XY) { //gd:PhysicsDirectBodyState2D.add_constant_force
	Advanced(self).AddConstantForce(Vector2.XY(force), Vector2.XY(gd.Vector2{0, 0}))
}

/*
Adds a constant positioned force to the body that keeps being applied over time until cleared with [code]constant_force = Vector2(0, 0)[/code].
[param position] is the offset from the body origin in global coordinates.
*/
func (self Expanded) AddConstantForce(force Vector2.XY, position Vector2.XY) { //gd:PhysicsDirectBodyState2D.add_constant_force
	Advanced(self).AddConstantForce(Vector2.XY(force), Vector2.XY(position))
}

/*
Adds a constant rotational force without affecting position that keeps being applied over time until cleared with [code]constant_torque = 0[/code].
*/
func (self Instance) AddConstantTorque(torque Float.X) { //gd:PhysicsDirectBodyState2D.add_constant_torque
	Advanced(self).AddConstantTorque(float64(torque))
}

/*
Sets the body's total constant positional forces applied during each physics update.
See [method add_constant_force] and [method add_constant_central_force].
*/
func (self Instance) SetConstantForce(force Vector2.XY) { //gd:PhysicsDirectBodyState2D.set_constant_force
	Advanced(self).SetConstantForce(Vector2.XY(force))
}

/*
Returns the body's total constant positional forces applied during each physics update.
See [method add_constant_force] and [method add_constant_central_force].
*/
func (self Instance) GetConstantForce() Vector2.XY { //gd:PhysicsDirectBodyState2D.get_constant_force
	return Vector2.XY(Advanced(self).GetConstantForce())
}

/*
Sets the body's total constant rotational forces applied during each physics update.
See [method add_constant_torque].
*/
func (self Instance) SetConstantTorque(torque Float.X) { //gd:PhysicsDirectBodyState2D.set_constant_torque
	Advanced(self).SetConstantTorque(float64(torque))
}

/*
Returns the body's total constant rotational forces applied during each physics update.
See [method add_constant_torque].
*/
func (self Instance) GetConstantTorque() Float.X { //gd:PhysicsDirectBodyState2D.get_constant_torque
	return Float.X(Float.X(Advanced(self).GetConstantTorque()))
}

/*
Returns the number of contacts this body has with other bodies.
[b]Note:[/b] By default, this returns 0 unless bodies are configured to monitor contacts. See [member RigidBody2D.contact_monitor].
*/
func (self Instance) GetContactCount() int { //gd:PhysicsDirectBodyState2D.get_contact_count
	return int(int(Advanced(self).GetContactCount()))
}

/*
Returns the position of the contact point on the body in the global coordinate system.
*/
func (self Instance) GetContactLocalPosition(contact_idx int) Vector2.XY { //gd:PhysicsDirectBodyState2D.get_contact_local_position
	return Vector2.XY(Advanced(self).GetContactLocalPosition(int64(contact_idx)))
}

/*
Returns the local normal at the contact point.
*/
func (self Instance) GetContactLocalNormal(contact_idx int) Vector2.XY { //gd:PhysicsDirectBodyState2D.get_contact_local_normal
	return Vector2.XY(Advanced(self).GetContactLocalNormal(int64(contact_idx)))
}

/*
Returns the local shape index of the collision.
*/
func (self Instance) GetContactLocalShape(contact_idx int) int { //gd:PhysicsDirectBodyState2D.get_contact_local_shape
	return int(int(Advanced(self).GetContactLocalShape(int64(contact_idx))))
}

/*
Returns the velocity vector at the body's contact point.
*/
func (self Instance) GetContactLocalVelocityAtPosition(contact_idx int) Vector2.XY { //gd:PhysicsDirectBodyState2D.get_contact_local_velocity_at_position
	return Vector2.XY(Advanced(self).GetContactLocalVelocityAtPosition(int64(contact_idx)))
}

/*
Returns the collider's [RID].
*/
func (self Instance) GetContactCollider(contact_idx int) RID.Body2D { //gd:PhysicsDirectBodyState2D.get_contact_collider
	return RID.Body2D(Advanced(self).GetContactCollider(int64(contact_idx)))
}

/*
Returns the position of the contact point on the collider in the global coordinate system.
*/
func (self Instance) GetContactColliderPosition(contact_idx int) Vector2.XY { //gd:PhysicsDirectBodyState2D.get_contact_collider_position
	return Vector2.XY(Advanced(self).GetContactColliderPosition(int64(contact_idx)))
}

/*
Returns the collider's object id.
*/
func (self Instance) GetContactColliderId(contact_idx int) int { //gd:PhysicsDirectBodyState2D.get_contact_collider_id
	return int(int(Advanced(self).GetContactColliderId(int64(contact_idx))))
}

/*
Returns the collider object. This depends on how it was created (will return a scene node if such was used to create it).
*/
func (self Instance) GetContactColliderObject(contact_idx int) Object.Instance { //gd:PhysicsDirectBodyState2D.get_contact_collider_object
	return Object.Instance(Advanced(self).GetContactColliderObject(int64(contact_idx)))
}

/*
Returns the collider's shape index.
*/
func (self Instance) GetContactColliderShape(contact_idx int) int { //gd:PhysicsDirectBodyState2D.get_contact_collider_shape
	return int(int(Advanced(self).GetContactColliderShape(int64(contact_idx))))
}

/*
Returns the velocity vector at the collider's contact point.
*/
func (self Instance) GetContactColliderVelocityAtPosition(contact_idx int) Vector2.XY { //gd:PhysicsDirectBodyState2D.get_contact_collider_velocity_at_position
	return Vector2.XY(Advanced(self).GetContactColliderVelocityAtPosition(int64(contact_idx)))
}

/*
Returns the impulse created by the contact.
*/
func (self Instance) GetContactImpulse(contact_idx int) Vector2.XY { //gd:PhysicsDirectBodyState2D.get_contact_impulse
	return Vector2.XY(Advanced(self).GetContactImpulse(int64(contact_idx)))
}

/*
Updates the body's linear and angular velocity by applying gravity and damping for the equivalent of one physics tick.
*/
func (self Instance) IntegrateForces() { //gd:PhysicsDirectBodyState2D.integrate_forces
	Advanced(self).IntegrateForces()
}

/*
Returns the current state of the space, useful for queries.
*/
func (self Instance) GetSpaceState() PhysicsDirectSpaceState2D.Instance { //gd:PhysicsDirectBodyState2D.get_space_state
	return PhysicsDirectSpaceState2D.Instance(Advanced(self).GetSpaceState())
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.PhysicsDirectBodyState2D

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = pointers.AsA[gdclass.PhysicsDirectBodyState2D](obj[0])
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = pointers.AsA[gdclass.PhysicsDirectBodyState2D](obj[0])
		return true
	}
	return false
}
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }
func (self *Extension[T]) AsObject() [1]gd.Object { return self.Super().AsObject() }
func New() Instance {
	if !gd.Linked {
		var placeholder = Instance([1]gdclass.PhysicsDirectBodyState2D{pointers.Add[gdclass.PhysicsDirectBodyState2D]([3]uint64{})})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(pointers.AsA[gd.Object](placeholder[0]), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	casted := Instance([1]gdclass.PhysicsDirectBodyState2D{pointers.New[gdclass.PhysicsDirectBodyState2D]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})})
	casted.AsObject()[0].Notification(0, false)
	return casted
}

func (self Instance) Step() Float.X {
	return Float.X(Float.X(class(self).GetStep()))
}

func (self Instance) InverseMass() Float.X {
	return Float.X(Float.X(class(self).GetInverseMass()))
}

func (self Instance) InverseInertia() Float.X {
	return Float.X(Float.X(class(self).GetInverseInertia()))
}

func (self Instance) TotalAngularDamp() Float.X {
	return Float.X(Float.X(class(self).GetTotalAngularDamp()))
}

func (self Instance) TotalLinearDamp() Float.X {
	return Float.X(Float.X(class(self).GetTotalLinearDamp()))
}

func (self Instance) TotalGravity() Vector2.XY {
	return Vector2.XY(class(self).GetTotalGravity())
}

func (self Instance) CenterOfMass() Vector2.XY {
	return Vector2.XY(class(self).GetCenterOfMass())
}

func (self Instance) CenterOfMassLocal() Vector2.XY {
	return Vector2.XY(class(self).GetCenterOfMassLocal())
}

func (self Instance) AngularVelocity() Float.X {
	return Float.X(Float.X(class(self).GetAngularVelocity()))
}

func (self Instance) SetAngularVelocity(value Float.X) {
	class(self).SetAngularVelocity(float64(value))
}

func (self Instance) LinearVelocity() Vector2.XY {
	return Vector2.XY(class(self).GetLinearVelocity())
}

func (self Instance) SetLinearVelocity(value Vector2.XY) {
	class(self).SetLinearVelocity(Vector2.XY(value))
}

func (self Instance) Sleeping() bool {
	return bool(class(self).IsSleeping())
}

func (self Instance) SetSleeping(value bool) {
	class(self).SetSleepState(value)
}

func (self Instance) Transform() Transform2D.OriginXY {
	return Transform2D.OriginXY(class(self).GetTransform())
}

func (self Instance) SetTransform(value Transform2D.OriginXY) {
	class(self).SetTransform(Transform2D.OriginXY(value))
}

//go:nosplit
func (self class) GetTotalGravity() Vector2.XY { //gd:PhysicsDirectBodyState2D.get_total_gravity
	var r_ret = gdextension.Call[Vector2.XY](gd.ObjectChecked(self.AsObject()), methods.get_total_gravity, gdextension.SizeVector2, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) GetTotalLinearDamp() float64 { //gd:PhysicsDirectBodyState2D.get_total_linear_damp
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_total_linear_damp, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) GetTotalAngularDamp() float64 { //gd:PhysicsDirectBodyState2D.get_total_angular_damp
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_total_angular_damp, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) GetCenterOfMass() Vector2.XY { //gd:PhysicsDirectBodyState2D.get_center_of_mass
	var r_ret = gdextension.Call[Vector2.XY](gd.ObjectChecked(self.AsObject()), methods.get_center_of_mass, gdextension.SizeVector2, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) GetCenterOfMassLocal() Vector2.XY { //gd:PhysicsDirectBodyState2D.get_center_of_mass_local
	var r_ret = gdextension.Call[Vector2.XY](gd.ObjectChecked(self.AsObject()), methods.get_center_of_mass_local, gdextension.SizeVector2, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) GetInverseMass() float64 { //gd:PhysicsDirectBodyState2D.get_inverse_mass
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_inverse_mass, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) GetInverseInertia() float64 { //gd:PhysicsDirectBodyState2D.get_inverse_inertia
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_inverse_inertia, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetLinearVelocity(velocity Vector2.XY) { //gd:PhysicsDirectBodyState2D.set_linear_velocity
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_linear_velocity, 0|(gdextension.SizeVector2<<4), unsafe.Pointer(&struct{ velocity Vector2.XY }{velocity}))
}

//go:nosplit
func (self class) GetLinearVelocity() Vector2.XY { //gd:PhysicsDirectBodyState2D.get_linear_velocity
	var r_ret = gdextension.Call[Vector2.XY](gd.ObjectChecked(self.AsObject()), methods.get_linear_velocity, gdextension.SizeVector2, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetAngularVelocity(velocity float64) { //gd:PhysicsDirectBodyState2D.set_angular_velocity
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_angular_velocity, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ velocity float64 }{velocity}))
}

//go:nosplit
func (self class) GetAngularVelocity() float64 { //gd:PhysicsDirectBodyState2D.get_angular_velocity
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_angular_velocity, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetTransform(transform Transform2D.OriginXY) { //gd:PhysicsDirectBodyState2D.set_transform
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_transform, 0|(gdextension.SizeTransform2D<<4), unsafe.Pointer(&struct{ transform Transform2D.OriginXY }{transform}))
}

//go:nosplit
func (self class) GetTransform() Transform2D.OriginXY { //gd:PhysicsDirectBodyState2D.get_transform
	var r_ret = gdextension.Call[Transform2D.OriginXY](gd.ObjectChecked(self.AsObject()), methods.get_transform, gdextension.SizeTransform2D, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the body's velocity at the given relative position, including both translation and rotation.
*/
//go:nosplit
func (self class) GetVelocityAtLocalPosition(local_position Vector2.XY) Vector2.XY { //gd:PhysicsDirectBodyState2D.get_velocity_at_local_position
	var r_ret = gdextension.Call[Vector2.XY](gd.ObjectChecked(self.AsObject()), methods.get_velocity_at_local_position, gdextension.SizeVector2|(gdextension.SizeVector2<<4), unsafe.Pointer(&struct{ local_position Vector2.XY }{local_position}))
	var ret = r_ret
	return ret
}

/*
Applies a directional impulse without affecting rotation.
An impulse is time-independent! Applying an impulse every frame would result in a framerate-dependent force. For this reason, it should only be used when simulating one-time impacts (use the "_force" functions otherwise).
This is equivalent to using [method apply_impulse] at the body's center of mass.
*/
//go:nosplit
func (self class) ApplyCentralImpulse(impulse Vector2.XY) { //gd:PhysicsDirectBodyState2D.apply_central_impulse
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.apply_central_impulse, 0|(gdextension.SizeVector2<<4), unsafe.Pointer(&struct{ impulse Vector2.XY }{impulse}))
}

/*
Applies a rotational impulse to the body without affecting the position.
An impulse is time-independent! Applying an impulse every frame would result in a framerate-dependent force. For this reason, it should only be used when simulating one-time impacts (use the "_force" functions otherwise).
[b]Note:[/b] [member inverse_inertia] is required for this to work. To have [member inverse_inertia], an active [CollisionShape2D] must be a child of the node, or you can manually set [member inverse_inertia].
*/
//go:nosplit
func (self class) ApplyTorqueImpulse(impulse float64) { //gd:PhysicsDirectBodyState2D.apply_torque_impulse
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.apply_torque_impulse, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ impulse float64 }{impulse}))
}

/*
Applies a positioned impulse to the body.
An impulse is time-independent! Applying an impulse every frame would result in a framerate-dependent force. For this reason, it should only be used when simulating one-time impacts (use the "_force" functions otherwise).
[param position] is the offset from the body origin in global coordinates.
*/
//go:nosplit
func (self class) ApplyImpulse(impulse Vector2.XY, position Vector2.XY) { //gd:PhysicsDirectBodyState2D.apply_impulse
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.apply_impulse, 0|(gdextension.SizeVector2<<4)|(gdextension.SizeVector2<<8), unsafe.Pointer(&struct {
		impulse  Vector2.XY
		position Vector2.XY
	}{impulse, position}))
}

/*
Applies a directional force without affecting rotation. A force is time dependent and meant to be applied every physics update.
This is equivalent to using [method apply_force] at the body's center of mass.
*/
//go:nosplit
func (self class) ApplyCentralForce(force Vector2.XY) { //gd:PhysicsDirectBodyState2D.apply_central_force
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.apply_central_force, 0|(gdextension.SizeVector2<<4), unsafe.Pointer(&struct{ force Vector2.XY }{force}))
}

/*
Applies a positioned force to the body. A force is time dependent and meant to be applied every physics update.
[param position] is the offset from the body origin in global coordinates.
*/
//go:nosplit
func (self class) ApplyForce(force Vector2.XY, position Vector2.XY) { //gd:PhysicsDirectBodyState2D.apply_force
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.apply_force, 0|(gdextension.SizeVector2<<4)|(gdextension.SizeVector2<<8), unsafe.Pointer(&struct {
		force    Vector2.XY
		position Vector2.XY
	}{force, position}))
}

/*
Applies a rotational force without affecting position. A force is time dependent and meant to be applied every physics update.
[b]Note:[/b] [member inverse_inertia] is required for this to work. To have [member inverse_inertia], an active [CollisionShape2D] must be a child of the node, or you can manually set [member inverse_inertia].
*/
//go:nosplit
func (self class) ApplyTorque(torque float64) { //gd:PhysicsDirectBodyState2D.apply_torque
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.apply_torque, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ torque float64 }{torque}))
}

/*
Adds a constant directional force without affecting rotation that keeps being applied over time until cleared with [code]constant_force = Vector2(0, 0)[/code].
This is equivalent to using [method add_constant_force] at the body's center of mass.
*/
//go:nosplit
func (self class) AddConstantCentralForce(force Vector2.XY) { //gd:PhysicsDirectBodyState2D.add_constant_central_force
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_constant_central_force, 0|(gdextension.SizeVector2<<4), unsafe.Pointer(&struct{ force Vector2.XY }{force}))
}

/*
Adds a constant positioned force to the body that keeps being applied over time until cleared with [code]constant_force = Vector2(0, 0)[/code].
[param position] is the offset from the body origin in global coordinates.
*/
//go:nosplit
func (self class) AddConstantForce(force Vector2.XY, position Vector2.XY) { //gd:PhysicsDirectBodyState2D.add_constant_force
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_constant_force, 0|(gdextension.SizeVector2<<4)|(gdextension.SizeVector2<<8), unsafe.Pointer(&struct {
		force    Vector2.XY
		position Vector2.XY
	}{force, position}))
}

/*
Adds a constant rotational force without affecting position that keeps being applied over time until cleared with [code]constant_torque = 0[/code].
*/
//go:nosplit
func (self class) AddConstantTorque(torque float64) { //gd:PhysicsDirectBodyState2D.add_constant_torque
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_constant_torque, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ torque float64 }{torque}))
}

/*
Sets the body's total constant positional forces applied during each physics update.
See [method add_constant_force] and [method add_constant_central_force].
*/
//go:nosplit
func (self class) SetConstantForce(force Vector2.XY) { //gd:PhysicsDirectBodyState2D.set_constant_force
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_constant_force, 0|(gdextension.SizeVector2<<4), unsafe.Pointer(&struct{ force Vector2.XY }{force}))
}

/*
Returns the body's total constant positional forces applied during each physics update.
See [method add_constant_force] and [method add_constant_central_force].
*/
//go:nosplit
func (self class) GetConstantForce() Vector2.XY { //gd:PhysicsDirectBodyState2D.get_constant_force
	var r_ret = gdextension.Call[Vector2.XY](gd.ObjectChecked(self.AsObject()), methods.get_constant_force, gdextension.SizeVector2, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Sets the body's total constant rotational forces applied during each physics update.
See [method add_constant_torque].
*/
//go:nosplit
func (self class) SetConstantTorque(torque float64) { //gd:PhysicsDirectBodyState2D.set_constant_torque
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_constant_torque, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ torque float64 }{torque}))
}

/*
Returns the body's total constant rotational forces applied during each physics update.
See [method add_constant_torque].
*/
//go:nosplit
func (self class) GetConstantTorque() float64 { //gd:PhysicsDirectBodyState2D.get_constant_torque
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_constant_torque, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetSleepState(enabled bool) { //gd:PhysicsDirectBodyState2D.set_sleep_state
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_sleep_state, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enabled bool }{enabled}))
}

//go:nosplit
func (self class) IsSleeping() bool { //gd:PhysicsDirectBodyState2D.is_sleeping
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_sleeping, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the number of contacts this body has with other bodies.
[b]Note:[/b] By default, this returns 0 unless bodies are configured to monitor contacts. See [member RigidBody2D.contact_monitor].
*/
//go:nosplit
func (self class) GetContactCount() int64 { //gd:PhysicsDirectBodyState2D.get_contact_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_contact_count, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the position of the contact point on the body in the global coordinate system.
*/
//go:nosplit
func (self class) GetContactLocalPosition(contact_idx int64) Vector2.XY { //gd:PhysicsDirectBodyState2D.get_contact_local_position
	var r_ret = gdextension.Call[Vector2.XY](gd.ObjectChecked(self.AsObject()), methods.get_contact_local_position, gdextension.SizeVector2|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ contact_idx int64 }{contact_idx}))
	var ret = r_ret
	return ret
}

/*
Returns the local normal at the contact point.
*/
//go:nosplit
func (self class) GetContactLocalNormal(contact_idx int64) Vector2.XY { //gd:PhysicsDirectBodyState2D.get_contact_local_normal
	var r_ret = gdextension.Call[Vector2.XY](gd.ObjectChecked(self.AsObject()), methods.get_contact_local_normal, gdextension.SizeVector2|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ contact_idx int64 }{contact_idx}))
	var ret = r_ret
	return ret
}

/*
Returns the local shape index of the collision.
*/
//go:nosplit
func (self class) GetContactLocalShape(contact_idx int64) int64 { //gd:PhysicsDirectBodyState2D.get_contact_local_shape
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_contact_local_shape, gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ contact_idx int64 }{contact_idx}))
	var ret = r_ret
	return ret
}

/*
Returns the velocity vector at the body's contact point.
*/
//go:nosplit
func (self class) GetContactLocalVelocityAtPosition(contact_idx int64) Vector2.XY { //gd:PhysicsDirectBodyState2D.get_contact_local_velocity_at_position
	var r_ret = gdextension.Call[Vector2.XY](gd.ObjectChecked(self.AsObject()), methods.get_contact_local_velocity_at_position, gdextension.SizeVector2|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ contact_idx int64 }{contact_idx}))
	var ret = r_ret
	return ret
}

/*
Returns the collider's [RID].
*/
//go:nosplit
func (self class) GetContactCollider(contact_idx int64) RID.Any { //gd:PhysicsDirectBodyState2D.get_contact_collider
	var r_ret = gdextension.Call[RID.Any](gd.ObjectChecked(self.AsObject()), methods.get_contact_collider, gdextension.SizeRID|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ contact_idx int64 }{contact_idx}))
	var ret = r_ret
	return ret
}

/*
Returns the position of the contact point on the collider in the global coordinate system.
*/
//go:nosplit
func (self class) GetContactColliderPosition(contact_idx int64) Vector2.XY { //gd:PhysicsDirectBodyState2D.get_contact_collider_position
	var r_ret = gdextension.Call[Vector2.XY](gd.ObjectChecked(self.AsObject()), methods.get_contact_collider_position, gdextension.SizeVector2|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ contact_idx int64 }{contact_idx}))
	var ret = r_ret
	return ret
}

/*
Returns the collider's object id.
*/
//go:nosplit
func (self class) GetContactColliderId(contact_idx int64) int64 { //gd:PhysicsDirectBodyState2D.get_contact_collider_id
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_contact_collider_id, gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ contact_idx int64 }{contact_idx}))
	var ret = r_ret
	return ret
}

/*
Returns the collider object. This depends on how it was created (will return a scene node if such was used to create it).
*/
//go:nosplit
func (self class) GetContactColliderObject(contact_idx int64) [1]gd.Object { //gd:PhysicsDirectBodyState2D.get_contact_collider_object
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_contact_collider_object, gdextension.SizeObject|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ contact_idx int64 }{contact_idx}))
	var ret = [1]gd.Object{gd.PointerMustAssertInstanceID[gd.Object](r_ret)}
	return ret
}

/*
Returns the collider's shape index.
*/
//go:nosplit
func (self class) GetContactColliderShape(contact_idx int64) int64 { //gd:PhysicsDirectBodyState2D.get_contact_collider_shape
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_contact_collider_shape, gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ contact_idx int64 }{contact_idx}))
	var ret = r_ret
	return ret
}

/*
Returns the velocity vector at the collider's contact point.
*/
//go:nosplit
func (self class) GetContactColliderVelocityAtPosition(contact_idx int64) Vector2.XY { //gd:PhysicsDirectBodyState2D.get_contact_collider_velocity_at_position
	var r_ret = gdextension.Call[Vector2.XY](gd.ObjectChecked(self.AsObject()), methods.get_contact_collider_velocity_at_position, gdextension.SizeVector2|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ contact_idx int64 }{contact_idx}))
	var ret = r_ret
	return ret
}

/*
Returns the impulse created by the contact.
*/
//go:nosplit
func (self class) GetContactImpulse(contact_idx int64) Vector2.XY { //gd:PhysicsDirectBodyState2D.get_contact_impulse
	var r_ret = gdextension.Call[Vector2.XY](gd.ObjectChecked(self.AsObject()), methods.get_contact_impulse, gdextension.SizeVector2|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ contact_idx int64 }{contact_idx}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) GetStep() float64 { //gd:PhysicsDirectBodyState2D.get_step
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_step, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Updates the body's linear and angular velocity by applying gravity and damping for the equivalent of one physics tick.
*/
//go:nosplit
func (self class) IntegrateForces() { //gd:PhysicsDirectBodyState2D.integrate_forces
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.integrate_forces, 0, unsafe.Pointer(&struct{}{}))
}

/*
Returns the current state of the space, useful for queries.
*/
//go:nosplit
func (self class) GetSpaceState() [1]gdclass.PhysicsDirectSpaceState2D { //gd:PhysicsDirectBodyState2D.get_space_state
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_space_state, gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.PhysicsDirectSpaceState2D{gd.PointerMustAssertInstanceID[gdclass.PhysicsDirectSpaceState2D](r_ret)}
	return ret
}
func (self class) AsPhysicsDirectBodyState2D() Advanced {
	return Advanced{pointers.AsA[gdclass.PhysicsDirectBodyState2D](self[0])}
}
func (self Instance) AsPhysicsDirectBodyState2D() Instance {
	return Instance{pointers.AsA[gdclass.PhysicsDirectBodyState2D](self[0])}
}
func (self *Extension[T]) AsPhysicsDirectBodyState2D() Instance {
	return self.Super().AsPhysicsDirectBodyState2D()
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Object.Advanced(self.AsObject()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Object.Instance(self.AsObject()), name)
	}
}
func init() {
	gdclass.Register("PhysicsDirectBodyState2D", func(ptr gd.Object) any { return Instance{pointers.AsA[gdclass.PhysicsDirectBodyState2D](ptr)} })
}
