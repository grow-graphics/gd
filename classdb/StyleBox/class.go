// Code generated by the generate package DO NOT EDIT

// Package StyleBox provides methods for working with StyleBox object instances.
package StyleBox

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/CanvasItem"
import "graphics.gd/classdb/Resource"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/Rect2"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"
import "graphics.gd/variant/Vector2"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
[StyleBox] is an abstract base class for drawing stylized boxes for UI elements. It is used for panels, buttons, [LineEdit] backgrounds, [Tree] backgrounds, etc. and also for testing a transparency mask for pointer signals. If mask test fails on a [StyleBox] assigned as mask to a control, clicks and motion signals will go through it to the one below.
[b]Note:[/b] For control nodes that have [i]Theme Properties[/i], the [code]focus[/code] [StyleBox] is displayed over the [code]normal[/code], [code]hover[/code] or [code]pressed[/code] [StyleBox]. This makes the [code]focus[/code] [StyleBox] more reusable across different nodes.

	See [Interface] for methods that can be overridden by a [Class] that extends it.
*/
type Instance [1]gdclass.StyleBox

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	get_minimum_size       gdextension.MethodForClass `hash:"3341600327"`
	set_content_margin     gdextension.MethodForClass `hash:"4290182280"`
	set_content_margin_all gdextension.MethodForClass `hash:"373806689"`
	get_content_margin     gdextension.MethodForClass `hash:"2869120046"`
	get_margin             gdextension.MethodForClass `hash:"2869120046"`
	get_offset             gdextension.MethodForClass `hash:"3341600327"`
	draw                   gdextension.MethodForClass `hash:"2275962004"`
	get_current_item_drawn gdextension.MethodForClass `hash:"3213695180"`
	test_mask              gdextension.MethodForClass `hash:"3735564539"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("StyleBox")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		pointers.Raw[gd.StringName](sname).Free()
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsStyleBox() Instance
}
type Interface interface {
	Draw(to_canvas_item RID.Any, rect Rect2.PositionSize)
	GetDrawRect(rect Rect2.PositionSize) Rect2.PositionSize
	//Virtual method to be implemented by the user. Returns a custom minimum size that the stylebox must respect when drawing. By default [method get_minimum_size] only takes content margins into account. This method can be overridden to add another size restriction. A combination of the default behavior and the output of this method will be used, to account for both sizes.
	GetMinimumSize() Vector2.XY
	TestMask(point Vector2.XY, rect Rect2.PositionSize) bool
}

// Implementation implements [Interface] with empty methods.
type Implementation = implementation

type implementation struct{}

func (self implementation) Draw(to_canvas_item RID.Any, rect Rect2.PositionSize)        { return }
func (self implementation) GetDrawRect(rect Rect2.PositionSize) (_ Rect2.PositionSize)  { return }
func (self implementation) GetMinimumSize() (_ Vector2.XY)                              { return }
func (self implementation) TestMask(point Vector2.XY, rect Rect2.PositionSize) (_ bool) { return }
func (Instance) _draw(impl func(ptr unsafe.Pointer, to_canvas_item RID.Any, rect Rect2.PositionSize)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var to_canvas_item = gd.UnsafeGet[RID.Any](p_args, 0)
		var rect = gd.UnsafeGet[Rect2.PositionSize](p_args, 1)
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, to_canvas_item, rect)
	}
}
func (Instance) _get_draw_rect(impl func(ptr unsafe.Pointer, rect Rect2.PositionSize) Rect2.PositionSize) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var rect = gd.UnsafeGet[Rect2.PositionSize](p_args, 0)
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self, rect)
		gd.UnsafeSet(p_back, Rect2.PositionSize(ret))
	}
}

/*
Virtual method to be implemented by the user. Returns a custom minimum size that the stylebox must respect when drawing. By default [method get_minimum_size] only takes content margins into account. This method can be overridden to add another size restriction. A combination of the default behavior and the output of this method will be used, to account for both sizes.
*/
func (Instance) _get_minimum_size(impl func(ptr unsafe.Pointer) Vector2.XY) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		gd.UnsafeSet(p_back, Vector2.XY(ret))
	}
}
func (Instance) _test_mask(impl func(ptr unsafe.Pointer, point Vector2.XY, rect Rect2.PositionSize) bool) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var point = gd.UnsafeGet[Vector2.XY](p_args, 0)
		var rect = gd.UnsafeGet[Rect2.PositionSize](p_args, 1)
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self, point, rect)
		gd.UnsafeSet(p_back, ret)
	}
}

/*
Returns the minimum size that this stylebox can be shrunk to.
*/
func (self Instance) GetMinimumSize() Vector2.XY { //gd:StyleBox.get_minimum_size
	return Vector2.XY(Advanced(self).GetMinimumSize())
}

/*
Sets the default margin to [param offset] pixels for all sides.
*/
func (self Instance) SetContentMarginAll(offset Float.X) { //gd:StyleBox.set_content_margin_all
	Advanced(self).SetContentMarginAll(float64(offset))
}

/*
Returns the content margin offset for the specified [enum Side].
Positive values reduce size inwards, unlike [Control]'s margin values.
*/
func (self Instance) GetMargin(margin Rect2.Side) Float.X { //gd:StyleBox.get_margin
	return Float.X(Float.X(Advanced(self).GetMargin(margin)))
}

/*
Returns the "offset" of a stylebox. This helper function returns a value equivalent to [code]Vector2(style.get_margin(MARGIN_LEFT), style.get_margin(MARGIN_TOP))[/code].
*/
func (self Instance) GetOffset() Vector2.XY { //gd:StyleBox.get_offset
	return Vector2.XY(Advanced(self).GetOffset())
}

/*
Returns the [CanvasItem] that handles its [constant CanvasItem.NOTIFICATION_DRAW] or [method CanvasItem._draw] callback at this moment.
*/
func (self Instance) GetCurrentItemDrawn() CanvasItem.Instance { //gd:StyleBox.get_current_item_drawn
	return CanvasItem.Instance(Advanced(self).GetCurrentItemDrawn())
}

/*
Test a position in a rectangle, return whether it passes the mask test.
*/
func (self Instance) TestMask(point Vector2.XY, rect Rect2.PositionSize) bool { //gd:StyleBox.test_mask
	return bool(Advanced(self).TestMask(Vector2.XY(point), Rect2.PositionSize(rect)))
}

/*
Draws a styled rectangle.
*/
func (self Instance) Draw(peer CanvasItem.Instance, rect Rect2.PositionSize) { //gd:CanvasItem.draw_style_box
	CanvasItem.Advanced(peer).DrawStyleBox(self, Rect2.PositionSize(rect))
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.StyleBox

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.StyleBox)(unsafe.Pointer(&obj))
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.StyleBox)(unsafe.Pointer(&obj))
		return true
	}
	return false
}

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {
	object := [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})}
	casted := Instance{*(*gdclass.StyleBox)(unsafe.Pointer(&object))}
	casted.AsRefCounted()[0].Reference()
	object[0].Notification(0, false)
	return casted
}

func (self Instance) ContentMarginLeft() Float.X {
	return Float.X(Float.X(class(self).GetContentMargin(0)))
}

func (self Instance) SetContentMarginLeft(value Float.X) {
	class(self).SetContentMargin(0, float64(value))
}

func (self Instance) ContentMarginTop() Float.X {
	return Float.X(Float.X(class(self).GetContentMargin(1)))
}

func (self Instance) SetContentMarginTop(value Float.X) {
	class(self).SetContentMargin(1, float64(value))
}

func (self Instance) ContentMarginRight() Float.X {
	return Float.X(Float.X(class(self).GetContentMargin(2)))
}

func (self Instance) SetContentMarginRight(value Float.X) {
	class(self).SetContentMargin(2, float64(value))
}

func (self Instance) ContentMarginBottom() Float.X {
	return Float.X(Float.X(class(self).GetContentMargin(3)))
}

func (self Instance) SetContentMarginBottom(value Float.X) {
	class(self).SetContentMargin(3, float64(value))
}

func (class) _draw(impl func(ptr unsafe.Pointer, to_canvas_item RID.Any, rect Rect2.PositionSize)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var to_canvas_item = gd.UnsafeGet[RID.Any](p_args, 0)
		var rect = gd.UnsafeGet[Rect2.PositionSize](p_args, 1)
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, to_canvas_item, rect)
	}
}

func (class) _get_draw_rect(impl func(ptr unsafe.Pointer, rect Rect2.PositionSize) Rect2.PositionSize) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var rect = gd.UnsafeGet[Rect2.PositionSize](p_args, 0)
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self, rect)
		gd.UnsafeSet(p_back, ret)
	}
}

/*
Virtual method to be implemented by the user. Returns a custom minimum size that the stylebox must respect when drawing. By default [method get_minimum_size] only takes content margins into account. This method can be overridden to add another size restriction. A combination of the default behavior and the output of this method will be used, to account for both sizes.
*/
func (class) _get_minimum_size(impl func(ptr unsafe.Pointer) Vector2.XY) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		gd.UnsafeSet(p_back, ret)
	}
}

func (class) _test_mask(impl func(ptr unsafe.Pointer, point Vector2.XY, rect Rect2.PositionSize) bool) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var point = gd.UnsafeGet[Vector2.XY](p_args, 0)
		var rect = gd.UnsafeGet[Rect2.PositionSize](p_args, 1)
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self, point, rect)
		gd.UnsafeSet(p_back, ret)
	}
}

/*
Returns the minimum size that this stylebox can be shrunk to.
*/
//go:nosplit
func (self class) GetMinimumSize() Vector2.XY { //gd:StyleBox.get_minimum_size
	var r_ret = gdextension.Call[Vector2.XY](gd.ObjectChecked(self.AsObject()), methods.get_minimum_size, gdextension.SizeVector2, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Sets the default value of the specified [enum Side] to [param offset] pixels.
*/
//go:nosplit
func (self class) SetContentMargin(margin Rect2.Side, offset float64) { //gd:StyleBox.set_content_margin
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_content_margin, 0|(gdextension.SizeInt<<4)|(gdextension.SizeFloat<<8), unsafe.Pointer(&struct {
		margin Rect2.Side
		offset float64
	}{margin, offset}))
}

/*
Sets the default margin to [param offset] pixels for all sides.
*/
//go:nosplit
func (self class) SetContentMarginAll(offset float64) { //gd:StyleBox.set_content_margin_all
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_content_margin_all, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ offset float64 }{offset}))
}

/*
Returns the default margin of the specified [enum Side].
*/
//go:nosplit
func (self class) GetContentMargin(margin Rect2.Side) float64 { //gd:StyleBox.get_content_margin
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_content_margin, gdextension.SizeFloat|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ margin Rect2.Side }{margin}))
	var ret = r_ret
	return ret
}

/*
Returns the content margin offset for the specified [enum Side].
Positive values reduce size inwards, unlike [Control]'s margin values.
*/
//go:nosplit
func (self class) GetMargin(margin Rect2.Side) float64 { //gd:StyleBox.get_margin
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_margin, gdextension.SizeFloat|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ margin Rect2.Side }{margin}))
	var ret = r_ret
	return ret
}

/*
Returns the "offset" of a stylebox. This helper function returns a value equivalent to [code]Vector2(style.get_margin(MARGIN_LEFT), style.get_margin(MARGIN_TOP))[/code].
*/
//go:nosplit
func (self class) GetOffset() Vector2.XY { //gd:StyleBox.get_offset
	var r_ret = gdextension.Call[Vector2.XY](gd.ObjectChecked(self.AsObject()), methods.get_offset, gdextension.SizeVector2, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Draws this stylebox using a canvas item identified by the given [RID].
The [RID] value can either be the result of [method CanvasItem.get_canvas_item] called on an existing [CanvasItem]-derived node, or directly from creating a canvas item in the [RenderingServer] with [method RenderingServer.canvas_item_create].
*/
//go:nosplit
func (self class) Draw(canvas_item RID.Any, rect Rect2.PositionSize) { //gd:StyleBox.draw
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.draw, 0|(gdextension.SizeRID<<4)|(gdextension.SizeRect2<<8), unsafe.Pointer(&struct {
		canvas_item RID.Any
		rect        Rect2.PositionSize
	}{canvas_item, rect}))
}

/*
Returns the [CanvasItem] that handles its [constant CanvasItem.NOTIFICATION_DRAW] or [method CanvasItem._draw] callback at this moment.
*/
//go:nosplit
func (self class) GetCurrentItemDrawn() [1]gdclass.CanvasItem { //gd:StyleBox.get_current_item_drawn
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_current_item_drawn, gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.CanvasItem{gd.PointerMustAssertInstanceID[gdclass.CanvasItem](r_ret)}
	return ret
}

/*
Test a position in a rectangle, return whether it passes the mask test.
*/
//go:nosplit
func (self class) TestMask(point Vector2.XY, rect Rect2.PositionSize) bool { //gd:StyleBox.test_mask
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.test_mask, gdextension.SizeBool|(gdextension.SizeVector2<<4)|(gdextension.SizeRect2<<8), unsafe.Pointer(&struct {
		point Vector2.XY
		rect  Rect2.PositionSize
	}{point, rect}))
	var ret = r_ret
	return ret
}
func (self class) AsStyleBox() Advanced         { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsStyleBox() Instance      { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsStyleBox() Instance { return self.Super().AsStyleBox() }
func (self class) AsResource() Resource.Advanced {
	return *((*Resource.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsResource() Resource.Instance { return self.Super().AsResource() }
func (self Instance) AsResource() Resource.Instance {
	return *((*Resource.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsRefCounted() [1]gd.RefCounted { return self.Super().AsRefCounted() }
func (self Instance) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	case "_draw":
		return reflect.ValueOf(self._draw)
	case "_get_draw_rect":
		return reflect.ValueOf(self._get_draw_rect)
	case "_get_minimum_size":
		return reflect.ValueOf(self._get_minimum_size)
	case "_test_mask":
		return reflect.ValueOf(self._test_mask)
	default:
		return gd.VirtualByName(Resource.Advanced(self.AsResource()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	case "_draw":
		return reflect.ValueOf(self._draw)
	case "_get_draw_rect":
		return reflect.ValueOf(self._get_draw_rect)
	case "_get_minimum_size":
		return reflect.ValueOf(self._get_minimum_size)
	case "_test_mask":
		return reflect.ValueOf(self._test_mask)
	default:
		return gd.VirtualByName(Resource.Instance(self.AsResource()), name)
	}
}
func init() {
	gdclass.Register("StyleBox", func(ptr gd.Object) any { return *(*Instance)(unsafe.Pointer(&ptr)) })
}
