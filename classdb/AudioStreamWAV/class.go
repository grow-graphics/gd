// Code generated by the generate package DO NOT EDIT

// Package AudioStreamWAV provides methods for working with AudioStreamWAV object instances.
package AudioStreamWAV

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/variant/Signal"
import "graphics.gd/classdb/AudioStream"
import "graphics.gd/classdb/Resource"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Signal.Any
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
AudioStreamWAV stores sound samples loaded from WAV files. To play the stored sound, use an [AudioStreamPlayer] (for non-positional audio) or [AudioStreamPlayer2D]/[AudioStreamPlayer3D] (for positional audio). The sound can be looped.
This class can also be used to store dynamically-generated PCM audio data. See also [AudioStreamGenerator] for procedural audio generation.
*/
type Instance [1]gdclass.AudioStreamWAV

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	load_from_buffer gdextension.MethodForClass `hash:"4266838938"`
	load_from_file   gdextension.MethodForClass `hash:"4015802384"`
	set_data         gdextension.MethodForClass `hash:"2971499966"`
	get_data         gdextension.MethodForClass `hash:"2362200018"`
	set_format       gdextension.MethodForClass `hash:"60648488"`
	get_format       gdextension.MethodForClass `hash:"3151724922"`
	set_loop_mode    gdextension.MethodForClass `hash:"2444882972"`
	get_loop_mode    gdextension.MethodForClass `hash:"393560655"`
	set_loop_begin   gdextension.MethodForClass `hash:"1286410249"`
	get_loop_begin   gdextension.MethodForClass `hash:"3905245786"`
	set_loop_end     gdextension.MethodForClass `hash:"1286410249"`
	get_loop_end     gdextension.MethodForClass `hash:"3905245786"`
	set_mix_rate     gdextension.MethodForClass `hash:"1286410249"`
	get_mix_rate     gdextension.MethodForClass `hash:"3905245786"`
	set_stereo       gdextension.MethodForClass `hash:"2586408642"`
	is_stereo        gdextension.MethodForClass `hash:"36873697"`
	save_to_wav      gdextension.MethodForClass `hash:"166001499"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("AudioStreamWAV")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		gdextension.Free(gdextension.TypeStringName, &sname)
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsAudioStreamWAV() Instance
}

/*
Creates a new [AudioStreamWAV] instance from the given buffer. The buffer must contain WAV data.
The keys and values of [param options] match the properties of [ResourceImporterWAV]. The usage of [param options] is identical to [method AudioStreamWAV.load_from_file].
*/
func LoadFromBuffer(stream_data []byte, options Options) Instance { //gd:AudioStreamWAV.load_from_buffer
	self := Instance{}
	return Instance(Advanced(self).LoadFromBuffer(Packed.Bytes(Packed.New(stream_data...)), gd.DictionaryFromMap(options)))
}

/*
Creates a new [AudioStreamWAV] instance from the given buffer. The buffer must contain WAV data.
The keys and values of [param options] match the properties of [ResourceImporterWAV]. The usage of [param options] is identical to [method AudioStreamWAV.load_from_file].
*/
func LoadFromBufferOptions(stream_data []byte, options Options) Instance { //gd:AudioStreamWAV.load_from_buffer
	self := Instance{}
	return Instance(Advanced(self).LoadFromBuffer(Packed.Bytes(Packed.New(stream_data...)), gd.DictionaryFromMap(options)))
}

/*
Creates a new [AudioStreamWAV] instance from the given file path. The file must be in WAV format.
The keys and values of [param options] match the properties of [ResourceImporterWAV].
[b]Example:[/b] Load the first file dropped as a WAV and play it:
[codeblock]
@onready var audio_player = $AudioStreamPlayer

func _ready():

	get_window().files_dropped.connect(_on_files_dropped)

func _on_files_dropped(files):

	if files[0].get_extension() == "wav":
	    audio_player.stream = AudioStreamWAV.load_from_file(files[0], {
	            "force/max_rate": true,
	            "force/max_rate_hz": 11025
	        })
	    audio_player.play()

[/codeblock]
*/
func LoadFromFile(path string, options Options) Instance { //gd:AudioStreamWAV.load_from_file
	self := Instance{}
	return Instance(Advanced(self).LoadFromFile(String.New(path), gd.DictionaryFromMap(options)))
}

/*
Creates a new [AudioStreamWAV] instance from the given file path. The file must be in WAV format.
The keys and values of [param options] match the properties of [ResourceImporterWAV].
[b]Example:[/b] Load the first file dropped as a WAV and play it:
[codeblock]
@onready var audio_player = $AudioStreamPlayer

func _ready():

	get_window().files_dropped.connect(_on_files_dropped)

func _on_files_dropped(files):

	if files[0].get_extension() == "wav":
	    audio_player.stream = AudioStreamWAV.load_from_file(files[0], {
	            "force/max_rate": true,
	            "force/max_rate_hz": 11025
	        })
	    audio_player.play()

[/codeblock]
*/
func LoadFromFileOptions(path string, options Options) Instance { //gd:AudioStreamWAV.load_from_file
	self := Instance{}
	return Instance(Advanced(self).LoadFromFile(String.New(path), gd.DictionaryFromMap(options)))
}

/*
Saves the AudioStreamWAV as a WAV file to [param path]. Samples with IMA ADPCM or Quite OK Audio formats can't be saved.
[b]Note:[/b] A [code].wav[/code] extension is automatically appended to [param path] if it is missing.
*/
func (self Instance) SaveToWav(path string) error { //gd:AudioStreamWAV.save_to_wav
	return error(gd.ToError(Advanced(self).SaveToWav(String.New(path))))
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.AudioStreamWAV

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.AudioStreamWAV)(unsafe.Pointer(&obj))
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.AudioStreamWAV)(unsafe.Pointer(&obj))
		return true
	}
	return false
}

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {

	if !gd.Linked {
		var placeholder Instance
		*(*gd.Object)(unsafe.Pointer(&placeholder)) = pointers.Add[gd.Object]([3]uint64{})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(*(*gd.Object)(unsafe.Pointer(&placeholder)), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	object := [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})}
	casted := Instance{*(*gdclass.AudioStreamWAV)(unsafe.Pointer(&object))}
	casted.AsRefCounted()[0].InitRef()
	object[0].Notification(0, false)
	return casted
}

func (self Instance) Data() []byte {
	return []byte(class(self).GetData().Bytes())
}

func (self Instance) SetData(value []byte) {
	class(self).SetData(Packed.Bytes(Packed.New(value...)))
}

func (self Instance) Format() Format {
	return Format(class(self).GetFormat())
}

func (self Instance) SetFormat(value Format) {
	class(self).SetFormat(value)
}

func (self Instance) LoopMode() LoopMode {
	return LoopMode(class(self).GetLoopMode())
}

func (self Instance) SetLoopMode(value LoopMode) {
	class(self).SetLoopMode(value)
}

func (self Instance) LoopBegin() int {
	return int(int(class(self).GetLoopBegin()))
}

func (self Instance) SetLoopBegin(value int) {
	class(self).SetLoopBegin(int64(value))
}

func (self Instance) LoopEnd() int {
	return int(int(class(self).GetLoopEnd()))
}

func (self Instance) SetLoopEnd(value int) {
	class(self).SetLoopEnd(int64(value))
}

func (self Instance) MixRate() int {
	return int(int(class(self).GetMixRate()))
}

func (self Instance) SetMixRate(value int) {
	class(self).SetMixRate(int64(value))
}

func (self Instance) Stereo() bool {
	return bool(class(self).IsStereo())
}

func (self Instance) SetStereo(value bool) {
	class(self).SetStereo(value)
}

/*
Creates a new [AudioStreamWAV] instance from the given buffer. The buffer must contain WAV data.
The keys and values of [param options] match the properties of [ResourceImporterWAV]. The usage of [param options] is identical to [method AudioStreamWAV.load_from_file].
*/
//go:nosplit
func (self class) LoadFromBuffer(stream_data Packed.Bytes, options Dictionary.Any) [1]gdclass.AudioStreamWAV { //gd:AudioStreamWAV.load_from_buffer
	var r_ret = gdextension.CallStatic[gdextension.Object](methods.load_from_buffer, gdextension.SizeObject|(gdextension.SizePackedArray<<4)|(gdextension.SizeDictionary<<8), unsafe.Pointer(&struct {
		stream_data gdextension.PackedArray[byte]
		options     gdextension.Dictionary
	}{pointers.Get(gd.InternalPacked[gd.PackedByteArray, byte](Packed.Array[byte](stream_data))), pointers.Get(gd.InternalDictionary(options))}))
	var ret = [1]gdclass.AudioStreamWAV{gd.PointerWithOwnershipTransferredToGo[gdclass.AudioStreamWAV](r_ret)}
	return ret
}

/*
Creates a new [AudioStreamWAV] instance from the given file path. The file must be in WAV format.
The keys and values of [param options] match the properties of [ResourceImporterWAV].
[b]Example:[/b] Load the first file dropped as a WAV and play it:
[codeblock]
@onready var audio_player = $AudioStreamPlayer

func _ready():
    get_window().files_dropped.connect(_on_files_dropped)

func _on_files_dropped(files):
    if files[0].get_extension() == "wav":
        audio_player.stream = AudioStreamWAV.load_from_file(files[0], {
                "force/max_rate": true,
                "force/max_rate_hz": 11025
            })
        audio_player.play()
[/codeblock]
*/
//go:nosplit
func (self class) LoadFromFile(path String.Readable, options Dictionary.Any) [1]gdclass.AudioStreamWAV { //gd:AudioStreamWAV.load_from_file
	var r_ret = gdextension.CallStatic[gdextension.Object](methods.load_from_file, gdextension.SizeObject|(gdextension.SizeString<<4)|(gdextension.SizeDictionary<<8), unsafe.Pointer(&struct {
		path    gdextension.String
		options gdextension.Dictionary
	}{pointers.Get(gd.InternalString(path)), pointers.Get(gd.InternalDictionary(options))}))
	var ret = [1]gdclass.AudioStreamWAV{gd.PointerWithOwnershipTransferredToGo[gdclass.AudioStreamWAV](r_ret)}
	return ret
}

//go:nosplit
func (self class) SetData(data Packed.Bytes) { //gd:AudioStreamWAV.set_data
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_data, 0|(gdextension.SizePackedArray<<4), unsafe.Pointer(&struct{ data gdextension.PackedArray[byte] }{pointers.Get(gd.InternalPacked[gd.PackedByteArray, byte](Packed.Array[byte](data)))}))
}

//go:nosplit
func (self class) GetData() Packed.Bytes { //gd:AudioStreamWAV.get_data
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.get_data, gdextension.SizePackedArray, unsafe.Pointer(&struct{}{}))
	var ret = Packed.Bytes(Array.Through(gd.PackedProxy[gd.PackedByteArray, byte]{}, pointers.Pack(pointers.Let[gd.PackedByteArray](r_ret))))
	return ret
}

//go:nosplit
func (self class) SetFormat(format Format) { //gd:AudioStreamWAV.set_format
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_format, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ format Format }{format}))
}

//go:nosplit
func (self class) GetFormat() Format { //gd:AudioStreamWAV.get_format
	var r_ret = gdextension.Call[Format](gd.ObjectChecked(self.AsObject()), methods.get_format, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetLoopMode(loop_mode LoopMode) { //gd:AudioStreamWAV.set_loop_mode
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_loop_mode, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ loop_mode LoopMode }{loop_mode}))
}

//go:nosplit
func (self class) GetLoopMode() LoopMode { //gd:AudioStreamWAV.get_loop_mode
	var r_ret = gdextension.Call[LoopMode](gd.ObjectChecked(self.AsObject()), methods.get_loop_mode, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetLoopBegin(loop_begin int64) { //gd:AudioStreamWAV.set_loop_begin
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_loop_begin, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ loop_begin int64 }{loop_begin}))
}

//go:nosplit
func (self class) GetLoopBegin() int64 { //gd:AudioStreamWAV.get_loop_begin
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_loop_begin, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetLoopEnd(loop_end int64) { //gd:AudioStreamWAV.set_loop_end
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_loop_end, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ loop_end int64 }{loop_end}))
}

//go:nosplit
func (self class) GetLoopEnd() int64 { //gd:AudioStreamWAV.get_loop_end
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_loop_end, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetMixRate(mix_rate int64) { //gd:AudioStreamWAV.set_mix_rate
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_mix_rate, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ mix_rate int64 }{mix_rate}))
}

//go:nosplit
func (self class) GetMixRate() int64 { //gd:AudioStreamWAV.get_mix_rate
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_mix_rate, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetStereo(stereo bool) { //gd:AudioStreamWAV.set_stereo
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_stereo, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ stereo bool }{stereo}))
}

//go:nosplit
func (self class) IsStereo() bool { //gd:AudioStreamWAV.is_stereo
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_stereo, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Saves the AudioStreamWAV as a WAV file to [param path]. Samples with IMA ADPCM or Quite OK Audio formats can't be saved.
[b]Note:[/b] A [code].wav[/code] extension is automatically appended to [param path] if it is missing.
*/
//go:nosplit
func (self class) SaveToWav(path String.Readable) Error.Code { //gd:AudioStreamWAV.save_to_wav
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.save_to_wav, gdextension.SizeInt|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ path gdextension.String }{pointers.Get(gd.InternalString(path))}))
	var ret = Error.Code(r_ret)
	return ret
}
func (self class) AsAudioStreamWAV() Advanced         { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsAudioStreamWAV() Instance      { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsAudioStreamWAV() Instance { return self.Super().AsAudioStreamWAV() }
func (self class) AsAudioStream() AudioStream.Advanced {
	return *((*AudioStream.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsAudioStream() AudioStream.Instance { return self.Super().AsAudioStream() }
func (self Instance) AsAudioStream() AudioStream.Instance {
	return *((*AudioStream.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsResource() Resource.Advanced {
	return *((*Resource.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsResource() Resource.Instance { return self.Super().AsResource() }
func (self Instance) AsResource() Resource.Instance {
	return *((*Resource.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsRefCounted() [1]gd.RefCounted { return self.Super().AsRefCounted() }
func (self Instance) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(AudioStream.Advanced(self.AsAudioStream()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(AudioStream.Instance(self.AsAudioStream()), name)
	}
}
func init() {
	gdclass.Register("AudioStreamWAV", func(ptr gd.Object) any { return *(*Instance)(unsafe.Pointer(&ptr)) })
}

type Format int //gd:AudioStreamWAV.Format

const (
	/*8-bit PCM audio codec.*/
	Format8Bits Format = 0
	/*16-bit PCM audio codec.*/
	Format16Bits Format = 1
	/*Audio is lossily compressed as IMA ADPCM.*/
	FormatImaAdpcm Format = 2
	/*Audio is lossily compressed as [url=https://qoaformat.org/]Quite OK Audio[/url].*/
	FormatQoa Format = 3
)

type LoopMode int //gd:AudioStreamWAV.LoopMode

const (
	/*Audio does not loop.*/
	LoopDisabled LoopMode = 0
	/*Audio loops the data between [member loop_begin] and [member loop_end], playing forward only.*/
	LoopForward LoopMode = 1
	/*Audio loops the data between [member loop_begin] and [member loop_end], playing back and forth.*/
	LoopPingpong LoopMode = 2
	/*Audio loops the data between [member loop_begin] and [member loop_end], playing backward only.*/
	LoopBackward LoopMode = 3
)

type Options struct {
	CompressionMode int     `gd:"compress/mode"`
	LoopBegin       int     `gd:"edit/loop_begin"`
	LoopEnd         int     `gd:"edit/loop_end"`
	LoopMode        int     `gd:"edit/loop_mode"`
	Normalize       int     `gd:"edit/normalize"`
	Trim            bool    `gd:"edit/trim"`
	ForceMinRate    bool    `gd:"force/8_bit"`
	ForceMaxRate    bool    `gd:"force/max_rate"`
	ForceMaxRateHz  float32 `gd:"force/max_rate_hz"`
	ForceMono       bool    `gd:"force/mono"`
}
