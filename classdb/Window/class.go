// Code generated by the generate package DO NOT EDIT

// Package Window provides methods for working with Window object instances.
package Window

import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/variant/Signal"
import "graphics.gd/classdb/DisplayServer"
import "graphics.gd/classdb/Font"
import "graphics.gd/classdb/InputEvent"
import "graphics.gd/classdb/Node"
import "graphics.gd/classdb/StyleBox"
import "graphics.gd/classdb/Texture2D"
import "graphics.gd/classdb/Theme"
import "graphics.gd/classdb/Viewport"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Color"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/Rect2i"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"
import "graphics.gd/variant/Vector2"
import "graphics.gd/variant/Vector2i"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Signal.Any
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
A node that creates a window. The window can either be a native system window or embedded inside another [Window] (see [member Viewport.gui_embed_subwindows]).
At runtime, [Window]s will not close automatically when requested. You need to handle it manually using the [signal close_requested] signal (this applies both to pressing the close button and clicking outside of a popup).

	See [Interface] for methods that can be overridden by a [Class] that extends it.
*/
type Instance [1]gdclass.Window

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	set_title                        gdextension.MethodForClass `hash:"83702148"`
	get_title                        gdextension.MethodForClass `hash:"201670096"`
	get_window_id                    gdextension.MethodForClass `hash:"3905245786"`
	set_initial_position             gdextension.MethodForClass `hash:"4084468099"`
	get_initial_position             gdextension.MethodForClass `hash:"4294066647"`
	set_current_screen               gdextension.MethodForClass `hash:"1286410249"`
	get_current_screen               gdextension.MethodForClass `hash:"3905245786"`
	set_position                     gdextension.MethodForClass `hash:"1130785943"`
	get_position                     gdextension.MethodForClass `hash:"3690982128"`
	move_to_center                   gdextension.MethodForClass `hash:"3218959716"`
	set_size                         gdextension.MethodForClass `hash:"1130785943"`
	get_size                         gdextension.MethodForClass `hash:"3690982128"`
	reset_size                       gdextension.MethodForClass `hash:"3218959716"`
	get_position_with_decorations    gdextension.MethodForClass `hash:"3690982128"`
	get_size_with_decorations        gdextension.MethodForClass `hash:"3690982128"`
	set_max_size                     gdextension.MethodForClass `hash:"1130785943"`
	get_max_size                     gdextension.MethodForClass `hash:"3690982128"`
	set_min_size                     gdextension.MethodForClass `hash:"1130785943"`
	get_min_size                     gdextension.MethodForClass `hash:"3690982128"`
	set_mode                         gdextension.MethodForClass `hash:"3095236531"`
	get_mode                         gdextension.MethodForClass `hash:"2566346114"`
	set_flag                         gdextension.MethodForClass `hash:"3426449779"`
	get_flag                         gdextension.MethodForClass `hash:"3062752289"`
	is_maximize_allowed              gdextension.MethodForClass `hash:"36873697"`
	request_attention                gdextension.MethodForClass `hash:"3218959716"`
	move_to_foreground               gdextension.MethodForClass `hash:"3218959716"`
	set_visible                      gdextension.MethodForClass `hash:"2586408642"`
	is_visible                       gdextension.MethodForClass `hash:"36873697"`
	hide                             gdextension.MethodForClass `hash:"3218959716"`
	show                             gdextension.MethodForClass `hash:"3218959716"`
	set_transient                    gdextension.MethodForClass `hash:"2586408642"`
	is_transient                     gdextension.MethodForClass `hash:"36873697"`
	set_transient_to_focused         gdextension.MethodForClass `hash:"2586408642"`
	is_transient_to_focused          gdextension.MethodForClass `hash:"36873697"`
	set_exclusive                    gdextension.MethodForClass `hash:"2586408642"`
	is_exclusive                     gdextension.MethodForClass `hash:"36873697"`
	set_unparent_when_invisible      gdextension.MethodForClass `hash:"2586408642"`
	can_draw                         gdextension.MethodForClass `hash:"36873697"`
	has_focus                        gdextension.MethodForClass `hash:"36873697"`
	grab_focus                       gdextension.MethodForClass `hash:"3218959716"`
	start_drag                       gdextension.MethodForClass `hash:"3218959716"`
	start_resize                     gdextension.MethodForClass `hash:"122288853"`
	set_ime_active                   gdextension.MethodForClass `hash:"2586408642"`
	set_ime_position                 gdextension.MethodForClass `hash:"1130785943"`
	is_embedded                      gdextension.MethodForClass `hash:"36873697"`
	get_contents_minimum_size        gdextension.MethodForClass `hash:"3341600327"`
	set_force_native                 gdextension.MethodForClass `hash:"2586408642"`
	get_force_native                 gdextension.MethodForClass `hash:"36873697"`
	set_content_scale_size           gdextension.MethodForClass `hash:"1130785943"`
	get_content_scale_size           gdextension.MethodForClass `hash:"3690982128"`
	set_content_scale_mode           gdextension.MethodForClass `hash:"2937716473"`
	get_content_scale_mode           gdextension.MethodForClass `hash:"161585230"`
	set_content_scale_aspect         gdextension.MethodForClass `hash:"2370399418"`
	get_content_scale_aspect         gdextension.MethodForClass `hash:"4158790715"`
	set_content_scale_stretch        gdextension.MethodForClass `hash:"349355940"`
	get_content_scale_stretch        gdextension.MethodForClass `hash:"536857316"`
	set_keep_title_visible           gdextension.MethodForClass `hash:"2586408642"`
	get_keep_title_visible           gdextension.MethodForClass `hash:"36873697"`
	set_content_scale_factor         gdextension.MethodForClass `hash:"373806689"`
	get_content_scale_factor         gdextension.MethodForClass `hash:"1740695150"`
	set_use_font_oversampling        gdextension.MethodForClass `hash:"2586408642"`
	is_using_font_oversampling       gdextension.MethodForClass `hash:"36873697"`
	set_mouse_passthrough_polygon    gdextension.MethodForClass `hash:"1509147220"`
	get_mouse_passthrough_polygon    gdextension.MethodForClass `hash:"2961356807"`
	set_wrap_controls                gdextension.MethodForClass `hash:"2586408642"`
	is_wrapping_controls             gdextension.MethodForClass `hash:"36873697"`
	child_controls_changed           gdextension.MethodForClass `hash:"3218959716"`
	set_theme                        gdextension.MethodForClass `hash:"2326690814"`
	get_theme                        gdextension.MethodForClass `hash:"3846893731"`
	set_theme_type_variation         gdextension.MethodForClass `hash:"3304788590"`
	get_theme_type_variation         gdextension.MethodForClass `hash:"2002593661"`
	begin_bulk_theme_override        gdextension.MethodForClass `hash:"3218959716"`
	end_bulk_theme_override          gdextension.MethodForClass `hash:"3218959716"`
	add_theme_icon_override          gdextension.MethodForClass `hash:"1373065600"`
	add_theme_stylebox_override      gdextension.MethodForClass `hash:"4188838905"`
	add_theme_font_override          gdextension.MethodForClass `hash:"3518018674"`
	add_theme_font_size_override     gdextension.MethodForClass `hash:"2415702435"`
	add_theme_color_override         gdextension.MethodForClass `hash:"4260178595"`
	add_theme_constant_override      gdextension.MethodForClass `hash:"2415702435"`
	remove_theme_icon_override       gdextension.MethodForClass `hash:"3304788590"`
	remove_theme_stylebox_override   gdextension.MethodForClass `hash:"3304788590"`
	remove_theme_font_override       gdextension.MethodForClass `hash:"3304788590"`
	remove_theme_font_size_override  gdextension.MethodForClass `hash:"3304788590"`
	remove_theme_color_override      gdextension.MethodForClass `hash:"3304788590"`
	remove_theme_constant_override   gdextension.MethodForClass `hash:"3304788590"`
	get_theme_icon                   gdextension.MethodForClass `hash:"3163973443"`
	get_theme_stylebox               gdextension.MethodForClass `hash:"604739069"`
	get_theme_font                   gdextension.MethodForClass `hash:"2826986490"`
	get_theme_font_size              gdextension.MethodForClass `hash:"1327056374"`
	get_theme_color                  gdextension.MethodForClass `hash:"2798751242"`
	get_theme_constant               gdextension.MethodForClass `hash:"1327056374"`
	has_theme_icon_override          gdextension.MethodForClass `hash:"2619796661"`
	has_theme_stylebox_override      gdextension.MethodForClass `hash:"2619796661"`
	has_theme_font_override          gdextension.MethodForClass `hash:"2619796661"`
	has_theme_font_size_override     gdextension.MethodForClass `hash:"2619796661"`
	has_theme_color_override         gdextension.MethodForClass `hash:"2619796661"`
	has_theme_constant_override      gdextension.MethodForClass `hash:"2619796661"`
	has_theme_icon                   gdextension.MethodForClass `hash:"866386512"`
	has_theme_stylebox               gdextension.MethodForClass `hash:"866386512"`
	has_theme_font                   gdextension.MethodForClass `hash:"866386512"`
	has_theme_font_size              gdextension.MethodForClass `hash:"866386512"`
	has_theme_color                  gdextension.MethodForClass `hash:"866386512"`
	has_theme_constant               gdextension.MethodForClass `hash:"866386512"`
	get_theme_default_base_scale     gdextension.MethodForClass `hash:"1740695150"`
	get_theme_default_font           gdextension.MethodForClass `hash:"3229501585"`
	get_theme_default_font_size      gdextension.MethodForClass `hash:"3905245786"`
	set_layout_direction             gdextension.MethodForClass `hash:"3094704184"`
	get_layout_direction             gdextension.MethodForClass `hash:"3909617982"`
	is_layout_rtl                    gdextension.MethodForClass `hash:"36873697"`
	set_auto_translate               gdextension.MethodForClass `hash:"2586408642"`
	is_auto_translating              gdextension.MethodForClass `hash:"36873697"`
	popup                            gdextension.MethodForClass `hash:"1680304321"`
	popup_on_parent                  gdextension.MethodForClass `hash:"1763793166"`
	popup_centered                   gdextension.MethodForClass `hash:"3447975422"`
	popup_centered_ratio             gdextension.MethodForClass `hash:"1014814997"`
	popup_centered_clamped           gdextension.MethodForClass `hash:"2613752477"`
	popup_exclusive                  gdextension.MethodForClass `hash:"2134721627"`
	popup_exclusive_on_parent        gdextension.MethodForClass `hash:"2344671043"`
	popup_exclusive_centered         gdextension.MethodForClass `hash:"3357594017"`
	popup_exclusive_centered_ratio   gdextension.MethodForClass `hash:"2284776287"`
	popup_exclusive_centered_clamped gdextension.MethodForClass `hash:"2612708785"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("Window")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		gdextension.Free(gdextension.TypeStringName, &sname)
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

type Expanded [1]gdclass.Window

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsWindow() Instance
}
type Interface interface {
	//Virtual method to be implemented by the user. Overrides the value returned by [method get_contents_minimum_size].
	GetContentsMinimumSize() Vector2.XY
}

// Implementation implements [Interface] with empty methods.
type Implementation = implementation

type implementation struct{}

func (self implementation) GetContentsMinimumSize() (_ Vector2.XY) { return }

/*
Virtual method to be implemented by the user. Overrides the value returned by [method get_contents_minimum_size].
*/
func (Instance) _get_contents_minimum_size(impl func(ptr gdclass.Receiver) Vector2.XY) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args, p_back gdextension.Pointer) {
		self := gdclass.Receiver(reflect.ValueOf(class).UnsafePointer())
		ret := impl(self)
		gd.UnsafeSet(p_back, Vector2.XY(ret))
	}
}

/*
Returns the ID of the window.
*/
func (self Instance) GetWindowId() int { //gd:Window.get_window_id
	return int(int(Advanced(self).GetWindowId()))
}

/*
Centers a native window on the current screen and an embedded window on its embedder [Viewport].
*/
func (self Instance) MoveToCenter() { //gd:Window.move_to_center
	Advanced(self).MoveToCenter()
}

/*
Resets the size to the minimum size, which is the max of [member min_size] and (if [member wrap_controls] is enabled) [method get_contents_minimum_size]. This is equivalent to calling [code]set_size(Vector2i())[/code] (or any size below the minimum).
*/
func (self Instance) ResetSize() { //gd:Window.reset_size
	Advanced(self).ResetSize()
}

/*
Returns the window's position including its border.
[b]Note:[/b] If [member visible] is [code]false[/code], this method returns the same value as [member position].
*/
func (self Instance) GetPositionWithDecorations() Vector2i.XY { //gd:Window.get_position_with_decorations
	return Vector2i.XY(Advanced(self).GetPositionWithDecorations())
}

/*
Returns the window's size including its border.
[b]Note:[/b] If [member visible] is [code]false[/code], this method returns the same value as [member size].
*/
func (self Instance) GetSizeWithDecorations() Vector2i.XY { //gd:Window.get_size_with_decorations
	return Vector2i.XY(Advanced(self).GetSizeWithDecorations())
}

/*
Returns [code]true[/code] if the window can be maximized (the maximize button is enabled).
*/
func (self Instance) IsMaximizeAllowed() bool { //gd:Window.is_maximize_allowed
	return bool(Advanced(self).IsMaximizeAllowed())
}

/*
Tells the OS that the [Window] needs an attention. This makes the window stand out in some way depending on the system, e.g. it might blink on the task bar.
*/
func (self Instance) RequestAttention() { //gd:Window.request_attention
	Advanced(self).RequestAttention()
}

/*
Causes the window to grab focus, allowing it to receive user input.
*/
func (self Instance) MoveToForeground() { //gd:Window.move_to_foreground
	Advanced(self).MoveToForeground()
}

/*
Hides the window. This is not the same as minimized state. Hidden window can't be interacted with and needs to be made visible with [method show].
*/
func (self Instance) Hide() { //gd:Window.hide
	Advanced(self).Hide()
}

/*
Makes the [Window] appear. This enables interactions with the [Window] and doesn't change any of its property other than visibility (unlike e.g. [method popup]).
*/
func (self Instance) Show() { //gd:Window.show
	Advanced(self).Show()
}

/*
If [param unparent] is [code]true[/code], the window is automatically unparented when going invisible.
[b]Note:[/b] Make sure to keep a reference to the node, otherwise it will be orphaned. You also need to manually call [method Node.queue_free] to free the window if it's not parented.
*/
func (self Instance) SetUnparentWhenInvisible(unparent bool) { //gd:Window.set_unparent_when_invisible
	Advanced(self).SetUnparentWhenInvisible(unparent)
}

/*
Returns whether the window is being drawn to the screen.
*/
func (self Instance) CanDraw() bool { //gd:Window.can_draw
	return bool(Advanced(self).CanDraw())
}

/*
Returns [code]true[/code] if the window is focused.
*/
func (self Instance) HasFocus() bool { //gd:Window.has_focus
	return bool(Advanced(self).HasFocus())
}

/*
Causes the window to grab focus, allowing it to receive user input.
*/
func (self Instance) GrabFocus() { //gd:Window.grab_focus
	Advanced(self).GrabFocus()
}

/*
Starts an interactive drag operation on the window, using the current mouse position. Call this method when handling a mouse button being pressed to simulate a pressed event on the window's title bar. Using this method allows the window to participate in space switching, tiling, and other system features.
*/
func (self Instance) StartDrag() { //gd:Window.start_drag
	Advanced(self).StartDrag()
}

/*
Starts an interactive resize operation on the window, using the current mouse position. Call this method when handling a mouse button being pressed to simulate a pressed event on the window's edge.
*/
func (self Instance) StartResize(edge DisplayServer.WindowResizeEdge) { //gd:Window.start_resize
	Advanced(self).StartResize(edge)
}

/*
If [param active] is [code]true[/code], enables system's native IME (Input Method Editor).
*/
func (self Instance) SetImeActive(active bool) { //gd:Window.set_ime_active
	Advanced(self).SetImeActive(active)
}

/*
Moves IME to the given position.
*/
func (self Instance) SetImePosition(position Vector2i.XY) { //gd:Window.set_ime_position
	Advanced(self).SetImePosition(Vector2i.XY(position))
}

/*
Returns [code]true[/code] if the window is currently embedded in another window.
*/
func (self Instance) IsEmbedded() bool { //gd:Window.is_embedded
	return bool(Advanced(self).IsEmbedded())
}

/*
Returns the combined minimum size from the child [Control] nodes of the window. Use [method child_controls_changed] to update it when child nodes have changed.
The value returned by this method can be overridden with [method _get_contents_minimum_size].
*/
func (self Instance) GetContentsMinimumSize() Vector2.XY { //gd:Window.get_contents_minimum_size
	return Vector2.XY(Advanced(self).GetContentsMinimumSize())
}

/*
Enables font oversampling. This makes fonts look better when they are scaled up.
*/
func (self Instance) SetUseFontOversampling(enable bool) { //gd:Window.set_use_font_oversampling
	Advanced(self).SetUseFontOversampling(enable)
}

/*
Returns [code]true[/code] if font oversampling is enabled. See [method set_use_font_oversampling].
*/
func (self Instance) IsUsingFontOversampling() bool { //gd:Window.is_using_font_oversampling
	return bool(Advanced(self).IsUsingFontOversampling())
}

/*
Requests an update of the [Window] size to fit underlying [Control] nodes.
*/
func (self Instance) ChildControlsChanged() { //gd:Window.child_controls_changed
	Advanced(self).ChildControlsChanged()
}

/*
Prevents [code]*_theme_*_override[/code] methods from emitting [constant NOTIFICATION_THEME_CHANGED] until [method end_bulk_theme_override] is called.
*/
func (self Instance) BeginBulkThemeOverride() { //gd:Window.begin_bulk_theme_override
	Advanced(self).BeginBulkThemeOverride()
}

/*
Ends a bulk theme override update. See [method begin_bulk_theme_override].
*/
func (self Instance) EndBulkThemeOverride() { //gd:Window.end_bulk_theme_override
	Advanced(self).EndBulkThemeOverride()
}

/*
Creates a local override for a theme icon with the specified [param name]. Local overrides always take precedence when fetching theme items for the control. An override can be removed with [method remove_theme_icon_override].
See also [method get_theme_icon].
*/
func (self Instance) AddThemeIconOverride(name string, texture Texture2D.Instance) { //gd:Window.add_theme_icon_override
	Advanced(self).AddThemeIconOverride(String.Name(String.New(name)), texture)
}

/*
Creates a local override for a theme [StyleBox] with the specified [param name]. Local overrides always take precedence when fetching theme items for the control. An override can be removed with [method remove_theme_stylebox_override].
See also [method get_theme_stylebox] and [method Control.add_theme_stylebox_override] for more details.
*/
func (self Instance) AddThemeStyleboxOverride(name string, stylebox StyleBox.Instance) { //gd:Window.add_theme_stylebox_override
	Advanced(self).AddThemeStyleboxOverride(String.Name(String.New(name)), stylebox)
}

/*
Creates a local override for a theme [Font] with the specified [param name]. Local overrides always take precedence when fetching theme items for the control. An override can be removed with [method remove_theme_font_override].
See also [method get_theme_font].
*/
func (self Instance) AddThemeFontOverride(name string, font Font.Instance) { //gd:Window.add_theme_font_override
	Advanced(self).AddThemeFontOverride(String.Name(String.New(name)), font)
}

/*
Creates a local override for a theme font size with the specified [param name]. Local overrides always take precedence when fetching theme items for the control. An override can be removed with [method remove_theme_font_size_override].
See also [method get_theme_font_size].
*/
func (self Instance) AddThemeFontSizeOverride(name string, font_size int) { //gd:Window.add_theme_font_size_override
	Advanced(self).AddThemeFontSizeOverride(String.Name(String.New(name)), int64(font_size))
}

/*
Creates a local override for a theme [Color] with the specified [param name]. Local overrides always take precedence when fetching theme items for the control. An override can be removed with [method remove_theme_color_override].
See also [method get_theme_color] and [method Control.add_theme_color_override] for more details.
*/
func (self Instance) AddThemeColorOverride(name string, color Color.RGBA) { //gd:Window.add_theme_color_override
	Advanced(self).AddThemeColorOverride(String.Name(String.New(name)), Color.RGBA(color))
}

/*
Creates a local override for a theme constant with the specified [param name]. Local overrides always take precedence when fetching theme items for the control. An override can be removed with [method remove_theme_constant_override].
See also [method get_theme_constant].
*/
func (self Instance) AddThemeConstantOverride(name string, constant int) { //gd:Window.add_theme_constant_override
	Advanced(self).AddThemeConstantOverride(String.Name(String.New(name)), int64(constant))
}

/*
Removes a local override for a theme icon with the specified [param name] previously added by [method add_theme_icon_override] or via the Inspector dock.
*/
func (self Instance) RemoveThemeIconOverride(name string) { //gd:Window.remove_theme_icon_override
	Advanced(self).RemoveThemeIconOverride(String.Name(String.New(name)))
}

/*
Removes a local override for a theme [StyleBox] with the specified [param name] previously added by [method add_theme_stylebox_override] or via the Inspector dock.
*/
func (self Instance) RemoveThemeStyleboxOverride(name string) { //gd:Window.remove_theme_stylebox_override
	Advanced(self).RemoveThemeStyleboxOverride(String.Name(String.New(name)))
}

/*
Removes a local override for a theme [Font] with the specified [param name] previously added by [method add_theme_font_override] or via the Inspector dock.
*/
func (self Instance) RemoveThemeFontOverride(name string) { //gd:Window.remove_theme_font_override
	Advanced(self).RemoveThemeFontOverride(String.Name(String.New(name)))
}

/*
Removes a local override for a theme font size with the specified [param name] previously added by [method add_theme_font_size_override] or via the Inspector dock.
*/
func (self Instance) RemoveThemeFontSizeOverride(name string) { //gd:Window.remove_theme_font_size_override
	Advanced(self).RemoveThemeFontSizeOverride(String.Name(String.New(name)))
}

/*
Removes a local override for a theme [Color] with the specified [param name] previously added by [method add_theme_color_override] or via the Inspector dock.
*/
func (self Instance) RemoveThemeColorOverride(name string) { //gd:Window.remove_theme_color_override
	Advanced(self).RemoveThemeColorOverride(String.Name(String.New(name)))
}

/*
Removes a local override for a theme constant with the specified [param name] previously added by [method add_theme_constant_override] or via the Inspector dock.
*/
func (self Instance) RemoveThemeConstantOverride(name string) { //gd:Window.remove_theme_constant_override
	Advanced(self).RemoveThemeConstantOverride(String.Name(String.New(name)))
}

/*
Returns an icon from the first matching [Theme] in the tree if that [Theme] has an icon item with the specified [param name] and [param theme_type].
See [method Control.get_theme_color] for details.
*/
func (self Instance) GetThemeIcon(name string) Texture2D.Instance { //gd:Window.get_theme_icon
	return Texture2D.Instance(Advanced(self).GetThemeIcon(String.Name(String.New(name)), String.Name(String.New(""))))
}

/*
Returns an icon from the first matching [Theme] in the tree if that [Theme] has an icon item with the specified [param name] and [param theme_type].
See [method Control.get_theme_color] for details.
*/
func (self Expanded) GetThemeIcon(name string, theme_type string) Texture2D.Instance { //gd:Window.get_theme_icon
	return Texture2D.Instance(Advanced(self).GetThemeIcon(String.Name(String.New(name)), String.Name(String.New(theme_type))))
}

/*
Returns a [StyleBox] from the first matching [Theme] in the tree if that [Theme] has a stylebox item with the specified [param name] and [param theme_type].
See [method Control.get_theme_color] for details.
*/
func (self Instance) GetThemeStylebox(name string) StyleBox.Instance { //gd:Window.get_theme_stylebox
	return StyleBox.Instance(Advanced(self).GetThemeStylebox(String.Name(String.New(name)), String.Name(String.New(""))))
}

/*
Returns a [StyleBox] from the first matching [Theme] in the tree if that [Theme] has a stylebox item with the specified [param name] and [param theme_type].
See [method Control.get_theme_color] for details.
*/
func (self Expanded) GetThemeStylebox(name string, theme_type string) StyleBox.Instance { //gd:Window.get_theme_stylebox
	return StyleBox.Instance(Advanced(self).GetThemeStylebox(String.Name(String.New(name)), String.Name(String.New(theme_type))))
}

/*
Returns a [Font] from the first matching [Theme] in the tree if that [Theme] has a font item with the specified [param name] and [param theme_type].
See [method Control.get_theme_color] for details.
*/
func (self Instance) GetThemeFont(name string) Font.Instance { //gd:Window.get_theme_font
	return Font.Instance(Advanced(self).GetThemeFont(String.Name(String.New(name)), String.Name(String.New(""))))
}

/*
Returns a [Font] from the first matching [Theme] in the tree if that [Theme] has a font item with the specified [param name] and [param theme_type].
See [method Control.get_theme_color] for details.
*/
func (self Expanded) GetThemeFont(name string, theme_type string) Font.Instance { //gd:Window.get_theme_font
	return Font.Instance(Advanced(self).GetThemeFont(String.Name(String.New(name)), String.Name(String.New(theme_type))))
}

/*
Returns a font size from the first matching [Theme] in the tree if that [Theme] has a font size item with the specified [param name] and [param theme_type].
See [method Control.get_theme_color] for details.
*/
func (self Instance) GetThemeFontSize(name string) int { //gd:Window.get_theme_font_size
	return int(int(Advanced(self).GetThemeFontSize(String.Name(String.New(name)), String.Name(String.New("")))))
}

/*
Returns a font size from the first matching [Theme] in the tree if that [Theme] has a font size item with the specified [param name] and [param theme_type].
See [method Control.get_theme_color] for details.
*/
func (self Expanded) GetThemeFontSize(name string, theme_type string) int { //gd:Window.get_theme_font_size
	return int(int(Advanced(self).GetThemeFontSize(String.Name(String.New(name)), String.Name(String.New(theme_type)))))
}

/*
Returns a [Color] from the first matching [Theme] in the tree if that [Theme] has a color item with the specified [param name] and [param theme_type].
See [method Control.get_theme_color] for more details.
*/
func (self Instance) GetThemeColor(name string) Color.RGBA { //gd:Window.get_theme_color
	return Color.RGBA(Advanced(self).GetThemeColor(String.Name(String.New(name)), String.Name(String.New(""))))
}

/*
Returns a [Color] from the first matching [Theme] in the tree if that [Theme] has a color item with the specified [param name] and [param theme_type].
See [method Control.get_theme_color] for more details.
*/
func (self Expanded) GetThemeColor(name string, theme_type string) Color.RGBA { //gd:Window.get_theme_color
	return Color.RGBA(Advanced(self).GetThemeColor(String.Name(String.New(name)), String.Name(String.New(theme_type))))
}

/*
Returns a constant from the first matching [Theme] in the tree if that [Theme] has a constant item with the specified [param name] and [param theme_type].
See [method Control.get_theme_color] for more details.
*/
func (self Instance) GetThemeConstant(name string) int { //gd:Window.get_theme_constant
	return int(int(Advanced(self).GetThemeConstant(String.Name(String.New(name)), String.Name(String.New("")))))
}

/*
Returns a constant from the first matching [Theme] in the tree if that [Theme] has a constant item with the specified [param name] and [param theme_type].
See [method Control.get_theme_color] for more details.
*/
func (self Expanded) GetThemeConstant(name string, theme_type string) int { //gd:Window.get_theme_constant
	return int(int(Advanced(self).GetThemeConstant(String.Name(String.New(name)), String.Name(String.New(theme_type)))))
}

/*
Returns [code]true[/code] if there is a local override for a theme icon with the specified [param name] in this [Control] node.
See [method add_theme_icon_override].
*/
func (self Instance) HasThemeIconOverride(name string) bool { //gd:Window.has_theme_icon_override
	return bool(Advanced(self).HasThemeIconOverride(String.Name(String.New(name))))
}

/*
Returns [code]true[/code] if there is a local override for a theme [StyleBox] with the specified [param name] in this [Control] node.
See [method add_theme_stylebox_override].
*/
func (self Instance) HasThemeStyleboxOverride(name string) bool { //gd:Window.has_theme_stylebox_override
	return bool(Advanced(self).HasThemeStyleboxOverride(String.Name(String.New(name))))
}

/*
Returns [code]true[/code] if there is a local override for a theme [Font] with the specified [param name] in this [Control] node.
See [method add_theme_font_override].
*/
func (self Instance) HasThemeFontOverride(name string) bool { //gd:Window.has_theme_font_override
	return bool(Advanced(self).HasThemeFontOverride(String.Name(String.New(name))))
}

/*
Returns [code]true[/code] if there is a local override for a theme font size with the specified [param name] in this [Control] node.
See [method add_theme_font_size_override].
*/
func (self Instance) HasThemeFontSizeOverride(name string) bool { //gd:Window.has_theme_font_size_override
	return bool(Advanced(self).HasThemeFontSizeOverride(String.Name(String.New(name))))
}

/*
Returns [code]true[/code] if there is a local override for a theme [Color] with the specified [param name] in this [Control] node.
See [method add_theme_color_override].
*/
func (self Instance) HasThemeColorOverride(name string) bool { //gd:Window.has_theme_color_override
	return bool(Advanced(self).HasThemeColorOverride(String.Name(String.New(name))))
}

/*
Returns [code]true[/code] if there is a local override for a theme constant with the specified [param name] in this [Control] node.
See [method add_theme_constant_override].
*/
func (self Instance) HasThemeConstantOverride(name string) bool { //gd:Window.has_theme_constant_override
	return bool(Advanced(self).HasThemeConstantOverride(String.Name(String.New(name))))
}

/*
Returns [code]true[/code] if there is a matching [Theme] in the tree that has an icon item with the specified [param name] and [param theme_type].
See [method Control.get_theme_color] for details.
*/
func (self Instance) HasThemeIcon(name string) bool { //gd:Window.has_theme_icon
	return bool(Advanced(self).HasThemeIcon(String.Name(String.New(name)), String.Name(String.New(""))))
}

/*
Returns [code]true[/code] if there is a matching [Theme] in the tree that has an icon item with the specified [param name] and [param theme_type].
See [method Control.get_theme_color] for details.
*/
func (self Expanded) HasThemeIcon(name string, theme_type string) bool { //gd:Window.has_theme_icon
	return bool(Advanced(self).HasThemeIcon(String.Name(String.New(name)), String.Name(String.New(theme_type))))
}

/*
Returns [code]true[/code] if there is a matching [Theme] in the tree that has a stylebox item with the specified [param name] and [param theme_type].
See [method Control.get_theme_color] for details.
*/
func (self Instance) HasThemeStylebox(name string) bool { //gd:Window.has_theme_stylebox
	return bool(Advanced(self).HasThemeStylebox(String.Name(String.New(name)), String.Name(String.New(""))))
}

/*
Returns [code]true[/code] if there is a matching [Theme] in the tree that has a stylebox item with the specified [param name] and [param theme_type].
See [method Control.get_theme_color] for details.
*/
func (self Expanded) HasThemeStylebox(name string, theme_type string) bool { //gd:Window.has_theme_stylebox
	return bool(Advanced(self).HasThemeStylebox(String.Name(String.New(name)), String.Name(String.New(theme_type))))
}

/*
Returns [code]true[/code] if there is a matching [Theme] in the tree that has a font item with the specified [param name] and [param theme_type].
See [method Control.get_theme_color] for details.
*/
func (self Instance) HasThemeFont(name string) bool { //gd:Window.has_theme_font
	return bool(Advanced(self).HasThemeFont(String.Name(String.New(name)), String.Name(String.New(""))))
}

/*
Returns [code]true[/code] if there is a matching [Theme] in the tree that has a font item with the specified [param name] and [param theme_type].
See [method Control.get_theme_color] for details.
*/
func (self Expanded) HasThemeFont(name string, theme_type string) bool { //gd:Window.has_theme_font
	return bool(Advanced(self).HasThemeFont(String.Name(String.New(name)), String.Name(String.New(theme_type))))
}

/*
Returns [code]true[/code] if there is a matching [Theme] in the tree that has a font size item with the specified [param name] and [param theme_type].
See [method Control.get_theme_color] for details.
*/
func (self Instance) HasThemeFontSize(name string) bool { //gd:Window.has_theme_font_size
	return bool(Advanced(self).HasThemeFontSize(String.Name(String.New(name)), String.Name(String.New(""))))
}

/*
Returns [code]true[/code] if there is a matching [Theme] in the tree that has a font size item with the specified [param name] and [param theme_type].
See [method Control.get_theme_color] for details.
*/
func (self Expanded) HasThemeFontSize(name string, theme_type string) bool { //gd:Window.has_theme_font_size
	return bool(Advanced(self).HasThemeFontSize(String.Name(String.New(name)), String.Name(String.New(theme_type))))
}

/*
Returns [code]true[/code] if there is a matching [Theme] in the tree that has a color item with the specified [param name] and [param theme_type].
See [method Control.get_theme_color] for details.
*/
func (self Instance) HasThemeColor(name string) bool { //gd:Window.has_theme_color
	return bool(Advanced(self).HasThemeColor(String.Name(String.New(name)), String.Name(String.New(""))))
}

/*
Returns [code]true[/code] if there is a matching [Theme] in the tree that has a color item with the specified [param name] and [param theme_type].
See [method Control.get_theme_color] for details.
*/
func (self Expanded) HasThemeColor(name string, theme_type string) bool { //gd:Window.has_theme_color
	return bool(Advanced(self).HasThemeColor(String.Name(String.New(name)), String.Name(String.New(theme_type))))
}

/*
Returns [code]true[/code] if there is a matching [Theme] in the tree that has a constant item with the specified [param name] and [param theme_type].
See [method Control.get_theme_color] for details.
*/
func (self Instance) HasThemeConstant(name string) bool { //gd:Window.has_theme_constant
	return bool(Advanced(self).HasThemeConstant(String.Name(String.New(name)), String.Name(String.New(""))))
}

/*
Returns [code]true[/code] if there is a matching [Theme] in the tree that has a constant item with the specified [param name] and [param theme_type].
See [method Control.get_theme_color] for details.
*/
func (self Expanded) HasThemeConstant(name string, theme_type string) bool { //gd:Window.has_theme_constant
	return bool(Advanced(self).HasThemeConstant(String.Name(String.New(name)), String.Name(String.New(theme_type))))
}

/*
Returns the default base scale value from the first matching [Theme] in the tree if that [Theme] has a valid [member Theme.default_base_scale] value.
See [method Control.get_theme_color] for details.
*/
func (self Instance) GetThemeDefaultBaseScale() Float.X { //gd:Window.get_theme_default_base_scale
	return Float.X(Float.X(Advanced(self).GetThemeDefaultBaseScale()))
}

/*
Returns the default font from the first matching [Theme] in the tree if that [Theme] has a valid [member Theme.default_font] value.
See [method Control.get_theme_color] for details.
*/
func (self Instance) GetThemeDefaultFont() Font.Instance { //gd:Window.get_theme_default_font
	return Font.Instance(Advanced(self).GetThemeDefaultFont())
}

/*
Returns the default font size value from the first matching [Theme] in the tree if that [Theme] has a valid [member Theme.default_font_size] value.
See [method Control.get_theme_color] for details.
*/
func (self Instance) GetThemeDefaultFontSize() int { //gd:Window.get_theme_default_font_size
	return int(int(Advanced(self).GetThemeDefaultFontSize()))
}

/*
Sets layout direction and text writing direction. Right-to-left layouts are necessary for certain languages (e.g. Arabic and Hebrew).
*/
func (self Instance) SetLayoutDirection(direction LayoutDirection) { //gd:Window.set_layout_direction
	Advanced(self).SetLayoutDirection(direction)
}

/*
Returns layout direction and text writing direction.
*/
func (self Instance) GetLayoutDirection() LayoutDirection { //gd:Window.get_layout_direction
	return LayoutDirection(Advanced(self).GetLayoutDirection())
}

/*
Returns [code]true[/code] if layout is right-to-left.
*/
func (self Instance) IsLayoutRtl() bool { //gd:Window.is_layout_rtl
	return bool(Advanced(self).IsLayoutRtl())
}

/*
Shows the [Window] and makes it transient (see [member transient]). If [param rect] is provided, it will be set as the [Window]'s size. Fails if called on the main window.
If [member ProjectSettings.display/window/subwindows/embed_subwindows] is [code]true[/code] (single-window mode), [param rect]'s coordinates are global and relative to the main window's top-left corner (excluding window decorations). If [param rect]'s position coordinates are negative, the window will be located outside the main window and may not be visible as a result.
If [member ProjectSettings.display/window/subwindows/embed_subwindows] is [code]false[/code] (multi-window mode), [param rect]'s coordinates are global and relative to the top-left corner of the leftmost screen. If [param rect]'s position coordinates are negative, the window will be placed at the top-left corner of the screen.
[b]Note:[/b] [param rect] must be in global coordinates if specified.
*/
func (self Instance) Popup() { //gd:Window.popup
	Advanced(self).Popup(Rect2i.PositionSize(gd.NewRect2i(0, 0, 0, 0)))
}

/*
Shows the [Window] and makes it transient (see [member transient]). If [param rect] is provided, it will be set as the [Window]'s size. Fails if called on the main window.
If [member ProjectSettings.display/window/subwindows/embed_subwindows] is [code]true[/code] (single-window mode), [param rect]'s coordinates are global and relative to the main window's top-left corner (excluding window decorations). If [param rect]'s position coordinates are negative, the window will be located outside the main window and may not be visible as a result.
If [member ProjectSettings.display/window/subwindows/embed_subwindows] is [code]false[/code] (multi-window mode), [param rect]'s coordinates are global and relative to the top-left corner of the leftmost screen. If [param rect]'s position coordinates are negative, the window will be placed at the top-left corner of the screen.
[b]Note:[/b] [param rect] must be in global coordinates if specified.
*/
func (self Expanded) Popup(rect Rect2i.PositionSize) { //gd:Window.popup
	Advanced(self).Popup(Rect2i.PositionSize(rect))
}

/*
Popups the [Window] with a position shifted by parent [Window]'s position. If the [Window] is embedded, has the same effect as [method popup].
*/
func (self Instance) PopupOnParent(parent_rect Rect2i.PositionSize) { //gd:Window.popup_on_parent
	Advanced(self).PopupOnParent(Rect2i.PositionSize(parent_rect))
}

/*
Popups the [Window] at the center of the current screen, with optionally given minimum size. If the [Window] is embedded, it will be centered in the parent [Viewport] instead.
[b]Note:[/b] Calling it with the default value of [param minsize] is equivalent to calling it with [member size].
*/
func (self Instance) PopupCentered() { //gd:Window.popup_centered
	Advanced(self).PopupCentered(Vector2i.XY(gd.Vector2i{0, 0}))
}

/*
Popups the [Window] at the center of the current screen, with optionally given minimum size. If the [Window] is embedded, it will be centered in the parent [Viewport] instead.
[b]Note:[/b] Calling it with the default value of [param minsize] is equivalent to calling it with [member size].
*/
func (self Expanded) PopupCentered(minsize Vector2i.XY) { //gd:Window.popup_centered
	Advanced(self).PopupCentered(Vector2i.XY(minsize))
}

/*
If [Window] is embedded, popups the [Window] centered inside its embedder and sets its size as a [param ratio] of embedder's size.
If [Window] is a native window, popups the [Window] centered inside the screen of its parent [Window] and sets its size as a [param ratio] of the screen size.
*/
func (self Instance) PopupCenteredRatio() { //gd:Window.popup_centered_ratio
	Advanced(self).PopupCenteredRatio(float64(0.8))
}

/*
If [Window] is embedded, popups the [Window] centered inside its embedder and sets its size as a [param ratio] of embedder's size.
If [Window] is a native window, popups the [Window] centered inside the screen of its parent [Window] and sets its size as a [param ratio] of the screen size.
*/
func (self Expanded) PopupCenteredRatio(ratio Float.X) { //gd:Window.popup_centered_ratio
	Advanced(self).PopupCenteredRatio(float64(ratio))
}

/*
Popups the [Window] centered inside its parent [Window]. [param fallback_ratio] determines the maximum size of the [Window], in relation to its parent.
[b]Note:[/b] Calling it with the default value of [param minsize] is equivalent to calling it with [member size].
*/
func (self Instance) PopupCenteredClamped() { //gd:Window.popup_centered_clamped
	Advanced(self).PopupCenteredClamped(Vector2i.XY(gd.Vector2i{0, 0}), float64(0.75))
}

/*
Popups the [Window] centered inside its parent [Window]. [param fallback_ratio] determines the maximum size of the [Window], in relation to its parent.
[b]Note:[/b] Calling it with the default value of [param minsize] is equivalent to calling it with [member size].
*/
func (self Expanded) PopupCenteredClamped(minsize Vector2i.XY, fallback_ratio Float.X) { //gd:Window.popup_centered_clamped
	Advanced(self).PopupCenteredClamped(Vector2i.XY(minsize), float64(fallback_ratio))
}

/*
Attempts to parent this dialog to the last exclusive window relative to [param from_node], and then calls [method Window.popup] on it. The dialog must have no current parent, otherwise the method fails.
See also [method set_unparent_when_invisible] and [method Node.get_last_exclusive_window].
*/
func (self Instance) PopupExclusive(from_node Node.Instance) { //gd:Window.popup_exclusive
	Advanced(self).PopupExclusive(from_node, Rect2i.PositionSize(gd.NewRect2i(0, 0, 0, 0)))
}

/*
Attempts to parent this dialog to the last exclusive window relative to [param from_node], and then calls [method Window.popup] on it. The dialog must have no current parent, otherwise the method fails.
See also [method set_unparent_when_invisible] and [method Node.get_last_exclusive_window].
*/
func (self Expanded) PopupExclusive(from_node Node.Instance, rect Rect2i.PositionSize) { //gd:Window.popup_exclusive
	Advanced(self).PopupExclusive(from_node, Rect2i.PositionSize(rect))
}

/*
Attempts to parent this dialog to the last exclusive window relative to [param from_node], and then calls [method Window.popup_on_parent] on it. The dialog must have no current parent, otherwise the method fails.
See also [method set_unparent_when_invisible] and [method Node.get_last_exclusive_window].
*/
func (self Instance) PopupExclusiveOnParent(from_node Node.Instance, parent_rect Rect2i.PositionSize) { //gd:Window.popup_exclusive_on_parent
	Advanced(self).PopupExclusiveOnParent(from_node, Rect2i.PositionSize(parent_rect))
}

/*
Attempts to parent this dialog to the last exclusive window relative to [param from_node], and then calls [method Window.popup_centered] on it. The dialog must have no current parent, otherwise the method fails.
See also [method set_unparent_when_invisible] and [method Node.get_last_exclusive_window].
*/
func (self Instance) PopupExclusiveCentered(from_node Node.Instance) { //gd:Window.popup_exclusive_centered
	Advanced(self).PopupExclusiveCentered(from_node, Vector2i.XY(gd.Vector2i{0, 0}))
}

/*
Attempts to parent this dialog to the last exclusive window relative to [param from_node], and then calls [method Window.popup_centered] on it. The dialog must have no current parent, otherwise the method fails.
See also [method set_unparent_when_invisible] and [method Node.get_last_exclusive_window].
*/
func (self Expanded) PopupExclusiveCentered(from_node Node.Instance, minsize Vector2i.XY) { //gd:Window.popup_exclusive_centered
	Advanced(self).PopupExclusiveCentered(from_node, Vector2i.XY(minsize))
}

/*
Attempts to parent this dialog to the last exclusive window relative to [param from_node], and then calls [method Window.popup_centered_ratio] on it. The dialog must have no current parent, otherwise the method fails.
See also [method set_unparent_when_invisible] and [method Node.get_last_exclusive_window].
*/
func (self Instance) PopupExclusiveCenteredRatio(from_node Node.Instance) { //gd:Window.popup_exclusive_centered_ratio
	Advanced(self).PopupExclusiveCenteredRatio(from_node, float64(0.8))
}

/*
Attempts to parent this dialog to the last exclusive window relative to [param from_node], and then calls [method Window.popup_centered_ratio] on it. The dialog must have no current parent, otherwise the method fails.
See also [method set_unparent_when_invisible] and [method Node.get_last_exclusive_window].
*/
func (self Expanded) PopupExclusiveCenteredRatio(from_node Node.Instance, ratio Float.X) { //gd:Window.popup_exclusive_centered_ratio
	Advanced(self).PopupExclusiveCenteredRatio(from_node, float64(ratio))
}

/*
Attempts to parent this dialog to the last exclusive window relative to [param from_node], and then calls [method Window.popup_centered_clamped] on it. The dialog must have no current parent, otherwise the method fails.
See also [method set_unparent_when_invisible] and [method Node.get_last_exclusive_window].
*/
func (self Instance) PopupExclusiveCenteredClamped(from_node Node.Instance) { //gd:Window.popup_exclusive_centered_clamped
	Advanced(self).PopupExclusiveCenteredClamped(from_node, Vector2i.XY(gd.Vector2i{0, 0}), float64(0.75))
}

/*
Attempts to parent this dialog to the last exclusive window relative to [param from_node], and then calls [method Window.popup_centered_clamped] on it. The dialog must have no current parent, otherwise the method fails.
See also [method set_unparent_when_invisible] and [method Node.get_last_exclusive_window].
*/
func (self Expanded) PopupExclusiveCenteredClamped(from_node Node.Instance, minsize Vector2i.XY, fallback_ratio Float.X) { //gd:Window.popup_exclusive_centered_clamped
	Advanced(self).PopupExclusiveCenteredClamped(from_node, Vector2i.XY(minsize), float64(fallback_ratio))
}

/*
Returns the [Window] that contains this node. If the node is in the main window, this is equivalent to getting the root node ([code]get_tree().get_root()[/code]).
*/
func Get(peer Node.Instance) Instance { //gd:Node.get_window
	return Instance(Node.Advanced(peer).GetWindow())
}

/*
Returns a list of the visible embedded [Window]s inside the viewport.
[b]Note:[/b] [Window]s inside other viewports will not be listed.
*/
func (self Instance) GetEmbeddedInView(peer Viewport.Instance) []Instance { //gd:Viewport.get_embedded_subwindows
	return []Instance(gd.ArrayAs[[]Instance](gd.InternalArray(Viewport.Advanced(peer).GetEmbeddedSubwindows())))
}

/*
Returns the [Window] that contains this node, or the last exclusive child in a chain of windows starting with the one that contains this node.
*/
func GetLastExclusive(peer Node.Instance) Instance { //gd:Node.get_last_exclusive_window
	return Instance(Node.Advanced(peer).GetLastExclusiveWindow())
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.Window

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = pointers.AsA[gdclass.Window](obj[0])
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = pointers.AsA[gdclass.Window](obj[0])
		return true
	}
	return false
}
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }
func (self *Extension[T]) AsObject() [1]gd.Object { return self.Super().AsObject() }
func New() Instance {
	if !gd.Linked {
		var placeholder = Instance([1]gdclass.Window{pointers.Add[gdclass.Window]([3]uint64{})})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(pointers.AsA[gd.Object](placeholder[0]), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	casted := Instance([1]gdclass.Window{pointers.New[gdclass.Window]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})})
	casted.AsObject()[0].Notification(0, false)
	return casted
}

func (self Instance) Mode() Mode {
	return Mode(class(self).GetMode())
}

func (self Instance) SetMode(value Mode) {
	class(self).SetMode(value)
}

func (self Instance) Title() string {
	return string(class(self).GetTitle().String())
}

func (self Instance) SetTitle(value string) {
	class(self).SetTitle(String.New(value))
}

func (self Instance) InitialPosition() WindowInitialPosition {
	return WindowInitialPosition(class(self).GetInitialPosition())
}

func (self Instance) SetInitialPosition(value WindowInitialPosition) {
	class(self).SetInitialPosition(value)
}

func (self Instance) Position() Vector2i.XY {
	return Vector2i.XY(class(self).GetPosition())
}

func (self Instance) SetPosition(value Vector2i.XY) {
	class(self).SetPosition(Vector2i.XY(value))
}

func (self Instance) Size() Vector2i.XY {
	return Vector2i.XY(class(self).GetSize())
}

func (self Instance) SetSize(value Vector2i.XY) {
	class(self).SetSize(Vector2i.XY(value))
}

func (self Instance) CurrentScreen() int {
	return int(int(class(self).GetCurrentScreen()))
}

func (self Instance) SetCurrentScreen(value int) {
	class(self).SetCurrentScreen(int64(value))
}

func (self Instance) MousePassthroughPolygon() []Vector2.XY {
	return []Vector2.XY(slices.Collect(class(self).GetMousePassthroughPolygon().Values()))
}

func (self Instance) SetMousePassthroughPolygon(value []Vector2.XY) {
	class(self).SetMousePassthroughPolygon(Packed.New(value...))
}

func (self Instance) Visible() bool {
	return bool(class(self).IsVisible())
}

func (self Instance) SetVisible(value bool) {
	class(self).SetVisible(value)
}

func (self Instance) WrapControls() bool {
	return bool(class(self).IsWrappingControls())
}

func (self Instance) SetWrapControls(value bool) {
	class(self).SetWrapControls(value)
}

func (self Instance) Transient() bool {
	return bool(class(self).IsTransient())
}

func (self Instance) SetTransient(value bool) {
	class(self).SetTransient(value)
}

func (self Instance) TransientToFocused() bool {
	return bool(class(self).IsTransientToFocused())
}

func (self Instance) SetTransientToFocused(value bool) {
	class(self).SetTransientToFocused(value)
}

func (self Instance) Exclusive() bool {
	return bool(class(self).IsExclusive())
}

func (self Instance) SetExclusive(value bool) {
	class(self).SetExclusive(value)
}

func (self Instance) Unresizable() bool {
	return bool(class(self).GetFlag(0))
}

func (self Instance) SetUnresizable(value bool) {
	class(self).SetFlag(0, value)
}

func (self Instance) Borderless() bool {
	return bool(class(self).GetFlag(1))
}

func (self Instance) SetBorderless(value bool) {
	class(self).SetFlag(1, value)
}

func (self Instance) AlwaysOnTop() bool {
	return bool(class(self).GetFlag(2))
}

func (self Instance) SetAlwaysOnTop(value bool) {
	class(self).SetFlag(2, value)
}

func (self Instance) Transparent() bool {
	return bool(class(self).GetFlag(3))
}

func (self Instance) SetTransparent(value bool) {
	class(self).SetFlag(3, value)
}

func (self Instance) Unfocusable() bool {
	return bool(class(self).GetFlag(4))
}

func (self Instance) SetUnfocusable(value bool) {
	class(self).SetFlag(4, value)
}

func (self Instance) PopupWindow() bool {
	return bool(class(self).GetFlag(5))
}

func (self Instance) SetPopupWindow(value bool) {
	class(self).SetFlag(5, value)
}

func (self Instance) ExtendToTitle() bool {
	return bool(class(self).GetFlag(6))
}

func (self Instance) SetExtendToTitle(value bool) {
	class(self).SetFlag(6, value)
}

func (self Instance) MousePassthrough() bool {
	return bool(class(self).GetFlag(7))
}

func (self Instance) SetMousePassthrough(value bool) {
	class(self).SetFlag(7, value)
}

func (self Instance) SharpCorners() bool {
	return bool(class(self).GetFlag(8))
}

func (self Instance) SetSharpCorners(value bool) {
	class(self).SetFlag(8, value)
}

func (self Instance) ExcludeFromCapture() bool {
	return bool(class(self).GetFlag(9))
}

func (self Instance) SetExcludeFromCapture(value bool) {
	class(self).SetFlag(9, value)
}

func (self Instance) ForceNative() bool {
	return bool(class(self).GetForceNative())
}

func (self Instance) SetForceNative(value bool) {
	class(self).SetForceNative(value)
}

func (self Instance) MinSize() Vector2i.XY {
	return Vector2i.XY(class(self).GetMinSize())
}

func (self Instance) SetMinSize(value Vector2i.XY) {
	class(self).SetMinSize(Vector2i.XY(value))
}

func (self Instance) MaxSize() Vector2i.XY {
	return Vector2i.XY(class(self).GetMaxSize())
}

func (self Instance) SetMaxSize(value Vector2i.XY) {
	class(self).SetMaxSize(Vector2i.XY(value))
}

func (self Instance) KeepTitleVisible() bool {
	return bool(class(self).GetKeepTitleVisible())
}

func (self Instance) SetKeepTitleVisible(value bool) {
	class(self).SetKeepTitleVisible(value)
}

func (self Instance) ContentScaleSize() Vector2i.XY {
	return Vector2i.XY(class(self).GetContentScaleSize())
}

func (self Instance) SetContentScaleSize(value Vector2i.XY) {
	class(self).SetContentScaleSize(Vector2i.XY(value))
}

func (self Instance) ContentScaleMode() ContentScaleMode {
	return ContentScaleMode(class(self).GetContentScaleMode())
}

func (self Instance) SetContentScaleMode(value ContentScaleMode) {
	class(self).SetContentScaleMode(value)
}

func (self Instance) ContentScaleAspect() ContentScaleAspect {
	return ContentScaleAspect(class(self).GetContentScaleAspect())
}

func (self Instance) SetContentScaleAspect(value ContentScaleAspect) {
	class(self).SetContentScaleAspect(value)
}

func (self Instance) ContentScaleStretch() ContentScaleStretch {
	return ContentScaleStretch(class(self).GetContentScaleStretch())
}

func (self Instance) SetContentScaleStretch(value ContentScaleStretch) {
	class(self).SetContentScaleStretch(value)
}

func (self Instance) ContentScaleFactor() Float.X {
	return Float.X(Float.X(class(self).GetContentScaleFactor()))
}

func (self Instance) SetContentScaleFactor(value Float.X) {
	class(self).SetContentScaleFactor(float64(value))
}

func (self Instance) AutoTranslate() bool {
	return bool(class(self).IsAutoTranslating())
}

func (self Instance) SetAutoTranslate(value bool) {
	class(self).SetAutoTranslate(value)
}

func (self Instance) Theme() Theme.Instance {
	return Theme.Instance(class(self).GetTheme())
}

func (self Instance) SetTheme(value Theme.Instance) {
	class(self).SetTheme(value)
}

func (self Instance) ThemeTypeVariation() string {
	return string(class(self).GetThemeTypeVariation().String())
}

func (self Instance) SetThemeTypeVariation(value string) {
	class(self).SetThemeTypeVariation(String.Name(String.New(value)))
}

/*
Virtual method to be implemented by the user. Overrides the value returned by [method get_contents_minimum_size].
*/
func (class) _get_contents_minimum_size(impl func(ptr gdclass.Receiver) Vector2.XY) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args, p_back gdextension.Pointer) {
		self := gdclass.Receiver(reflect.ValueOf(class).UnsafePointer())
		ret := impl(self)
		gd.UnsafeSet(p_back, ret)
	}
}

//go:nosplit
func (self class) SetTitle(title String.Readable) { //gd:Window.set_title
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_title, 0|(gdextension.SizeString<<4), &struct{ title gdextension.String }{pointers.Get(gd.InternalString(title))})
}

//go:nosplit
func (self class) GetTitle() String.Readable { //gd:Window.get_title
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_title, gdextension.SizeString, &struct{}{})
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Returns the ID of the window.
*/
//go:nosplit
func (self class) GetWindowId() int64 { //gd:Window.get_window_id
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_window_id, gdextension.SizeInt, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetInitialPosition(initial_position WindowInitialPosition) { //gd:Window.set_initial_position
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_initial_position, 0|(gdextension.SizeInt<<4), &struct{ initial_position WindowInitialPosition }{initial_position})
}

//go:nosplit
func (self class) GetInitialPosition() WindowInitialPosition { //gd:Window.get_initial_position
	var r_ret = gdextension.Call[WindowInitialPosition](gd.ObjectChecked(self.AsObject()), methods.get_initial_position, gdextension.SizeInt, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetCurrentScreen(index int64) { //gd:Window.set_current_screen
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_current_screen, 0|(gdextension.SizeInt<<4), &struct{ index int64 }{index})
}

//go:nosplit
func (self class) GetCurrentScreen() int64 { //gd:Window.get_current_screen
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_current_screen, gdextension.SizeInt, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetPosition(position Vector2i.XY) { //gd:Window.set_position
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_position, 0|(gdextension.SizeVector2i<<4), &struct{ position Vector2i.XY }{position})
}

//go:nosplit
func (self class) GetPosition() Vector2i.XY { //gd:Window.get_position
	var r_ret = gdextension.Call[Vector2i.XY](gd.ObjectChecked(self.AsObject()), methods.get_position, gdextension.SizeVector2i, &struct{}{})
	var ret = r_ret
	return ret
}

/*
Centers a native window on the current screen and an embedded window on its embedder [Viewport].
*/
//go:nosplit
func (self class) MoveToCenter() { //gd:Window.move_to_center
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.move_to_center, 0, &struct{}{})
}

//go:nosplit
func (self class) SetSize(size Vector2i.XY) { //gd:Window.set_size
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_size, 0|(gdextension.SizeVector2i<<4), &struct{ size Vector2i.XY }{size})
}

//go:nosplit
func (self class) GetSize() Vector2i.XY { //gd:Window.get_size
	var r_ret = gdextension.Call[Vector2i.XY](gd.ObjectChecked(self.AsObject()), methods.get_size, gdextension.SizeVector2i, &struct{}{})
	var ret = r_ret
	return ret
}

/*
Resets the size to the minimum size, which is the max of [member min_size] and (if [member wrap_controls] is enabled) [method get_contents_minimum_size]. This is equivalent to calling [code]set_size(Vector2i())[/code] (or any size below the minimum).
*/
//go:nosplit
func (self class) ResetSize() { //gd:Window.reset_size
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.reset_size, 0, &struct{}{})
}

/*
Returns the window's position including its border.
[b]Note:[/b] If [member visible] is [code]false[/code], this method returns the same value as [member position].
*/
//go:nosplit
func (self class) GetPositionWithDecorations() Vector2i.XY { //gd:Window.get_position_with_decorations
	var r_ret = gdextension.Call[Vector2i.XY](gd.ObjectChecked(self.AsObject()), methods.get_position_with_decorations, gdextension.SizeVector2i, &struct{}{})
	var ret = r_ret
	return ret
}

/*
Returns the window's size including its border.
[b]Note:[/b] If [member visible] is [code]false[/code], this method returns the same value as [member size].
*/
//go:nosplit
func (self class) GetSizeWithDecorations() Vector2i.XY { //gd:Window.get_size_with_decorations
	var r_ret = gdextension.Call[Vector2i.XY](gd.ObjectChecked(self.AsObject()), methods.get_size_with_decorations, gdextension.SizeVector2i, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetMaxSize(max_size Vector2i.XY) { //gd:Window.set_max_size
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_max_size, 0|(gdextension.SizeVector2i<<4), &struct{ max_size Vector2i.XY }{max_size})
}

//go:nosplit
func (self class) GetMaxSize() Vector2i.XY { //gd:Window.get_max_size
	var r_ret = gdextension.Call[Vector2i.XY](gd.ObjectChecked(self.AsObject()), methods.get_max_size, gdextension.SizeVector2i, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetMinSize(min_size Vector2i.XY) { //gd:Window.set_min_size
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_min_size, 0|(gdextension.SizeVector2i<<4), &struct{ min_size Vector2i.XY }{min_size})
}

//go:nosplit
func (self class) GetMinSize() Vector2i.XY { //gd:Window.get_min_size
	var r_ret = gdextension.Call[Vector2i.XY](gd.ObjectChecked(self.AsObject()), methods.get_min_size, gdextension.SizeVector2i, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetMode(mode Mode) { //gd:Window.set_mode
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_mode, 0|(gdextension.SizeInt<<4), &struct{ mode Mode }{mode})
}

//go:nosplit
func (self class) GetMode() Mode { //gd:Window.get_mode
	var r_ret = gdextension.Call[Mode](gd.ObjectChecked(self.AsObject()), methods.get_mode, gdextension.SizeInt, &struct{}{})
	var ret = r_ret
	return ret
}

/*
Sets a specified window flag.
*/
//go:nosplit
func (self class) SetFlag(flag Flags, enabled bool) { //gd:Window.set_flag
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_flag, 0|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8), &struct {
		flag    Flags
		enabled bool
	}{flag, enabled})
}

/*
Returns [code]true[/code] if the [param flag] is set.
*/
//go:nosplit
func (self class) GetFlag(flag Flags) bool { //gd:Window.get_flag
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.get_flag, gdextension.SizeBool|(gdextension.SizeInt<<4), &struct{ flag Flags }{flag})
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if the window can be maximized (the maximize button is enabled).
*/
//go:nosplit
func (self class) IsMaximizeAllowed() bool { //gd:Window.is_maximize_allowed
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_maximize_allowed, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

/*
Tells the OS that the [Window] needs an attention. This makes the window stand out in some way depending on the system, e.g. it might blink on the task bar.
*/
//go:nosplit
func (self class) RequestAttention() { //gd:Window.request_attention
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.request_attention, 0, &struct{}{})
}

/*
Causes the window to grab focus, allowing it to receive user input.
*/
//go:nosplit
func (self class) MoveToForeground() { //gd:Window.move_to_foreground
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.move_to_foreground, 0, &struct{}{})
}

//go:nosplit
func (self class) SetVisible(visible bool) { //gd:Window.set_visible
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_visible, 0|(gdextension.SizeBool<<4), &struct{ visible bool }{visible})
}

//go:nosplit
func (self class) IsVisible() bool { //gd:Window.is_visible
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_visible, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

/*
Hides the window. This is not the same as minimized state. Hidden window can't be interacted with and needs to be made visible with [method show].
*/
//go:nosplit
func (self class) Hide() { //gd:Window.hide
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.hide, 0, &struct{}{})
}

/*
Makes the [Window] appear. This enables interactions with the [Window] and doesn't change any of its property other than visibility (unlike e.g. [method popup]).
*/
//go:nosplit
func (self class) Show() { //gd:Window.show
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.show, 0, &struct{}{})
}

//go:nosplit
func (self class) SetTransient(transient bool) { //gd:Window.set_transient
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_transient, 0|(gdextension.SizeBool<<4), &struct{ transient bool }{transient})
}

//go:nosplit
func (self class) IsTransient() bool { //gd:Window.is_transient
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_transient, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetTransientToFocused(enable bool) { //gd:Window.set_transient_to_focused
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_transient_to_focused, 0|(gdextension.SizeBool<<4), &struct{ enable bool }{enable})
}

//go:nosplit
func (self class) IsTransientToFocused() bool { //gd:Window.is_transient_to_focused
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_transient_to_focused, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetExclusive(exclusive bool) { //gd:Window.set_exclusive
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_exclusive, 0|(gdextension.SizeBool<<4), &struct{ exclusive bool }{exclusive})
}

//go:nosplit
func (self class) IsExclusive() bool { //gd:Window.is_exclusive
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_exclusive, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

/*
If [param unparent] is [code]true[/code], the window is automatically unparented when going invisible.
[b]Note:[/b] Make sure to keep a reference to the node, otherwise it will be orphaned. You also need to manually call [method Node.queue_free] to free the window if it's not parented.
*/
//go:nosplit
func (self class) SetUnparentWhenInvisible(unparent bool) { //gd:Window.set_unparent_when_invisible
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_unparent_when_invisible, 0|(gdextension.SizeBool<<4), &struct{ unparent bool }{unparent})
}

/*
Returns whether the window is being drawn to the screen.
*/
//go:nosplit
func (self class) CanDraw() bool { //gd:Window.can_draw
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.can_draw, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if the window is focused.
*/
//go:nosplit
func (self class) HasFocus() bool { //gd:Window.has_focus
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.has_focus, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

/*
Causes the window to grab focus, allowing it to receive user input.
*/
//go:nosplit
func (self class) GrabFocus() { //gd:Window.grab_focus
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.grab_focus, 0, &struct{}{})
}

/*
Starts an interactive drag operation on the window, using the current mouse position. Call this method when handling a mouse button being pressed to simulate a pressed event on the window's title bar. Using this method allows the window to participate in space switching, tiling, and other system features.
*/
//go:nosplit
func (self class) StartDrag() { //gd:Window.start_drag
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.start_drag, 0, &struct{}{})
}

/*
Starts an interactive resize operation on the window, using the current mouse position. Call this method when handling a mouse button being pressed to simulate a pressed event on the window's edge.
*/
//go:nosplit
func (self class) StartResize(edge DisplayServer.WindowResizeEdge) { //gd:Window.start_resize
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.start_resize, 0|(gdextension.SizeInt<<4), &struct {
		edge DisplayServer.WindowResizeEdge
	}{edge})
}

/*
If [param active] is [code]true[/code], enables system's native IME (Input Method Editor).
*/
//go:nosplit
func (self class) SetImeActive(active bool) { //gd:Window.set_ime_active
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_ime_active, 0|(gdextension.SizeBool<<4), &struct{ active bool }{active})
}

/*
Moves IME to the given position.
*/
//go:nosplit
func (self class) SetImePosition(position Vector2i.XY) { //gd:Window.set_ime_position
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_ime_position, 0|(gdextension.SizeVector2i<<4), &struct{ position Vector2i.XY }{position})
}

/*
Returns [code]true[/code] if the window is currently embedded in another window.
*/
//go:nosplit
func (self class) IsEmbedded() bool { //gd:Window.is_embedded
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_embedded, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

/*
Returns the combined minimum size from the child [Control] nodes of the window. Use [method child_controls_changed] to update it when child nodes have changed.
The value returned by this method can be overridden with [method _get_contents_minimum_size].
*/
//go:nosplit
func (self class) GetContentsMinimumSize() Vector2.XY { //gd:Window.get_contents_minimum_size
	var r_ret = gdextension.Call[Vector2.XY](gd.ObjectChecked(self.AsObject()), methods.get_contents_minimum_size, gdextension.SizeVector2, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetForceNative(force_native bool) { //gd:Window.set_force_native
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_force_native, 0|(gdextension.SizeBool<<4), &struct{ force_native bool }{force_native})
}

//go:nosplit
func (self class) GetForceNative() bool { //gd:Window.get_force_native
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.get_force_native, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetContentScaleSize(size Vector2i.XY) { //gd:Window.set_content_scale_size
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_content_scale_size, 0|(gdextension.SizeVector2i<<4), &struct{ size Vector2i.XY }{size})
}

//go:nosplit
func (self class) GetContentScaleSize() Vector2i.XY { //gd:Window.get_content_scale_size
	var r_ret = gdextension.Call[Vector2i.XY](gd.ObjectChecked(self.AsObject()), methods.get_content_scale_size, gdextension.SizeVector2i, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetContentScaleMode(mode ContentScaleMode) { //gd:Window.set_content_scale_mode
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_content_scale_mode, 0|(gdextension.SizeInt<<4), &struct{ mode ContentScaleMode }{mode})
}

//go:nosplit
func (self class) GetContentScaleMode() ContentScaleMode { //gd:Window.get_content_scale_mode
	var r_ret = gdextension.Call[ContentScaleMode](gd.ObjectChecked(self.AsObject()), methods.get_content_scale_mode, gdextension.SizeInt, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetContentScaleAspect(aspect ContentScaleAspect) { //gd:Window.set_content_scale_aspect
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_content_scale_aspect, 0|(gdextension.SizeInt<<4), &struct{ aspect ContentScaleAspect }{aspect})
}

//go:nosplit
func (self class) GetContentScaleAspect() ContentScaleAspect { //gd:Window.get_content_scale_aspect
	var r_ret = gdextension.Call[ContentScaleAspect](gd.ObjectChecked(self.AsObject()), methods.get_content_scale_aspect, gdextension.SizeInt, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetContentScaleStretch(stretch ContentScaleStretch) { //gd:Window.set_content_scale_stretch
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_content_scale_stretch, 0|(gdextension.SizeInt<<4), &struct{ stretch ContentScaleStretch }{stretch})
}

//go:nosplit
func (self class) GetContentScaleStretch() ContentScaleStretch { //gd:Window.get_content_scale_stretch
	var r_ret = gdextension.Call[ContentScaleStretch](gd.ObjectChecked(self.AsObject()), methods.get_content_scale_stretch, gdextension.SizeInt, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetKeepTitleVisible(title_visible bool) { //gd:Window.set_keep_title_visible
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_keep_title_visible, 0|(gdextension.SizeBool<<4), &struct{ title_visible bool }{title_visible})
}

//go:nosplit
func (self class) GetKeepTitleVisible() bool { //gd:Window.get_keep_title_visible
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.get_keep_title_visible, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetContentScaleFactor(factor float64) { //gd:Window.set_content_scale_factor
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_content_scale_factor, 0|(gdextension.SizeFloat<<4), &struct{ factor float64 }{factor})
}

//go:nosplit
func (self class) GetContentScaleFactor() float64 { //gd:Window.get_content_scale_factor
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_content_scale_factor, gdextension.SizeFloat, &struct{}{})
	var ret = r_ret
	return ret
}

/*
Enables font oversampling. This makes fonts look better when they are scaled up.
*/
//go:nosplit
func (self class) SetUseFontOversampling(enable bool) { //gd:Window.set_use_font_oversampling
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_use_font_oversampling, 0|(gdextension.SizeBool<<4), &struct{ enable bool }{enable})
}

/*
Returns [code]true[/code] if font oversampling is enabled. See [method set_use_font_oversampling].
*/
//go:nosplit
func (self class) IsUsingFontOversampling() bool { //gd:Window.is_using_font_oversampling
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_using_font_oversampling, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetMousePassthroughPolygon(polygon Packed.Array[Vector2.XY]) { //gd:Window.set_mouse_passthrough_polygon
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_mouse_passthrough_polygon, 0|(gdextension.SizePackedArray<<4), &struct {
		polygon gdextension.PackedArray[Vector2.XY]
	}{pointers.Get(gd.InternalPacked[gd.PackedVector2Array, Vector2.XY](polygon))})
}

//go:nosplit
func (self class) GetMousePassthroughPolygon() Packed.Array[Vector2.XY] { //gd:Window.get_mouse_passthrough_polygon
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.get_mouse_passthrough_polygon, gdextension.SizePackedArray, &struct{}{})
	var ret = Packed.Array[Vector2.XY](Array.Through(gd.PackedProxy[gd.PackedVector2Array, Vector2.XY]{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

//go:nosplit
func (self class) SetWrapControls(enable bool) { //gd:Window.set_wrap_controls
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_wrap_controls, 0|(gdextension.SizeBool<<4), &struct{ enable bool }{enable})
}

//go:nosplit
func (self class) IsWrappingControls() bool { //gd:Window.is_wrapping_controls
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_wrapping_controls, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

/*
Requests an update of the [Window] size to fit underlying [Control] nodes.
*/
//go:nosplit
func (self class) ChildControlsChanged() { //gd:Window.child_controls_changed
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.child_controls_changed, 0, &struct{}{})
}

//go:nosplit
func (self class) SetTheme(theme [1]gdclass.Theme) { //gd:Window.set_theme
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_theme, 0|(gdextension.SizeObject<<4), &struct{ theme gdextension.Object }{gdextension.Object(gd.ObjectChecked(theme[0].AsObject()))})
}

//go:nosplit
func (self class) GetTheme() [1]gdclass.Theme { //gd:Window.get_theme
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_theme, gdextension.SizeObject, &struct{}{})
	var ret = [1]gdclass.Theme{gd.PointerWithOwnershipTransferredToGo[gdclass.Theme](r_ret)}
	return ret
}

//go:nosplit
func (self class) SetThemeTypeVariation(theme_type String.Name) { //gd:Window.set_theme_type_variation
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_theme_type_variation, 0|(gdextension.SizeStringName<<4), &struct{ theme_type gdextension.StringName }{pointers.Get(gd.InternalStringName(theme_type))})
}

//go:nosplit
func (self class) GetThemeTypeVariation() String.Name { //gd:Window.get_theme_type_variation
	var r_ret = gdextension.Call[gdextension.StringName](gd.ObjectChecked(self.AsObject()), methods.get_theme_type_variation, gdextension.SizeStringName, &struct{}{})
	var ret = String.Name(String.Via(gd.StringNameProxy{}, pointers.Pack(pointers.New[gd.StringName](r_ret))))
	return ret
}

/*
Prevents [code]*_theme_*_override[/code] methods from emitting [constant NOTIFICATION_THEME_CHANGED] until [method end_bulk_theme_override] is called.
*/
//go:nosplit
func (self class) BeginBulkThemeOverride() { //gd:Window.begin_bulk_theme_override
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.begin_bulk_theme_override, 0, &struct{}{})
}

/*
Ends a bulk theme override update. See [method begin_bulk_theme_override].
*/
//go:nosplit
func (self class) EndBulkThemeOverride() { //gd:Window.end_bulk_theme_override
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.end_bulk_theme_override, 0, &struct{}{})
}

/*
Creates a local override for a theme icon with the specified [param name]. Local overrides always take precedence when fetching theme items for the control. An override can be removed with [method remove_theme_icon_override].
See also [method get_theme_icon].
*/
//go:nosplit
func (self class) AddThemeIconOverride(name String.Name, texture [1]gdclass.Texture2D) { //gd:Window.add_theme_icon_override
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_theme_icon_override, 0|(gdextension.SizeStringName<<4)|(gdextension.SizeObject<<8), &struct {
		name    gdextension.StringName
		texture gdextension.Object
	}{pointers.Get(gd.InternalStringName(name)), gdextension.Object(gd.ObjectChecked(texture[0].AsObject()))})
}

/*
Creates a local override for a theme [StyleBox] with the specified [param name]. Local overrides always take precedence when fetching theme items for the control. An override can be removed with [method remove_theme_stylebox_override].
See also [method get_theme_stylebox] and [method Control.add_theme_stylebox_override] for more details.
*/
//go:nosplit
func (self class) AddThemeStyleboxOverride(name String.Name, stylebox [1]gdclass.StyleBox) { //gd:Window.add_theme_stylebox_override
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_theme_stylebox_override, 0|(gdextension.SizeStringName<<4)|(gdextension.SizeObject<<8), &struct {
		name     gdextension.StringName
		stylebox gdextension.Object
	}{pointers.Get(gd.InternalStringName(name)), gdextension.Object(gd.ObjectChecked(stylebox[0].AsObject()))})
}

/*
Creates a local override for a theme [Font] with the specified [param name]. Local overrides always take precedence when fetching theme items for the control. An override can be removed with [method remove_theme_font_override].
See also [method get_theme_font].
*/
//go:nosplit
func (self class) AddThemeFontOverride(name String.Name, font [1]gdclass.Font) { //gd:Window.add_theme_font_override
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_theme_font_override, 0|(gdextension.SizeStringName<<4)|(gdextension.SizeObject<<8), &struct {
		name gdextension.StringName
		font gdextension.Object
	}{pointers.Get(gd.InternalStringName(name)), gdextension.Object(gd.ObjectChecked(font[0].AsObject()))})
}

/*
Creates a local override for a theme font size with the specified [param name]. Local overrides always take precedence when fetching theme items for the control. An override can be removed with [method remove_theme_font_size_override].
See also [method get_theme_font_size].
*/
//go:nosplit
func (self class) AddThemeFontSizeOverride(name String.Name, font_size int64) { //gd:Window.add_theme_font_size_override
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_theme_font_size_override, 0|(gdextension.SizeStringName<<4)|(gdextension.SizeInt<<8), &struct {
		name      gdextension.StringName
		font_size int64
	}{pointers.Get(gd.InternalStringName(name)), font_size})
}

/*
Creates a local override for a theme [Color] with the specified [param name]. Local overrides always take precedence when fetching theme items for the control. An override can be removed with [method remove_theme_color_override].
See also [method get_theme_color] and [method Control.add_theme_color_override] for more details.
*/
//go:nosplit
func (self class) AddThemeColorOverride(name String.Name, color Color.RGBA) { //gd:Window.add_theme_color_override
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_theme_color_override, 0|(gdextension.SizeStringName<<4)|(gdextension.SizeColor<<8), &struct {
		name  gdextension.StringName
		color Color.RGBA
	}{pointers.Get(gd.InternalStringName(name)), color})
}

/*
Creates a local override for a theme constant with the specified [param name]. Local overrides always take precedence when fetching theme items for the control. An override can be removed with [method remove_theme_constant_override].
See also [method get_theme_constant].
*/
//go:nosplit
func (self class) AddThemeConstantOverride(name String.Name, constant int64) { //gd:Window.add_theme_constant_override
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_theme_constant_override, 0|(gdextension.SizeStringName<<4)|(gdextension.SizeInt<<8), &struct {
		name     gdextension.StringName
		constant int64
	}{pointers.Get(gd.InternalStringName(name)), constant})
}

/*
Removes a local override for a theme icon with the specified [param name] previously added by [method add_theme_icon_override] or via the Inspector dock.
*/
//go:nosplit
func (self class) RemoveThemeIconOverride(name String.Name) { //gd:Window.remove_theme_icon_override
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.remove_theme_icon_override, 0|(gdextension.SizeStringName<<4), &struct{ name gdextension.StringName }{pointers.Get(gd.InternalStringName(name))})
}

/*
Removes a local override for a theme [StyleBox] with the specified [param name] previously added by [method add_theme_stylebox_override] or via the Inspector dock.
*/
//go:nosplit
func (self class) RemoveThemeStyleboxOverride(name String.Name) { //gd:Window.remove_theme_stylebox_override
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.remove_theme_stylebox_override, 0|(gdextension.SizeStringName<<4), &struct{ name gdextension.StringName }{pointers.Get(gd.InternalStringName(name))})
}

/*
Removes a local override for a theme [Font] with the specified [param name] previously added by [method add_theme_font_override] or via the Inspector dock.
*/
//go:nosplit
func (self class) RemoveThemeFontOverride(name String.Name) { //gd:Window.remove_theme_font_override
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.remove_theme_font_override, 0|(gdextension.SizeStringName<<4), &struct{ name gdextension.StringName }{pointers.Get(gd.InternalStringName(name))})
}

/*
Removes a local override for a theme font size with the specified [param name] previously added by [method add_theme_font_size_override] or via the Inspector dock.
*/
//go:nosplit
func (self class) RemoveThemeFontSizeOverride(name String.Name) { //gd:Window.remove_theme_font_size_override
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.remove_theme_font_size_override, 0|(gdextension.SizeStringName<<4), &struct{ name gdextension.StringName }{pointers.Get(gd.InternalStringName(name))})
}

/*
Removes a local override for a theme [Color] with the specified [param name] previously added by [method add_theme_color_override] or via the Inspector dock.
*/
//go:nosplit
func (self class) RemoveThemeColorOverride(name String.Name) { //gd:Window.remove_theme_color_override
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.remove_theme_color_override, 0|(gdextension.SizeStringName<<4), &struct{ name gdextension.StringName }{pointers.Get(gd.InternalStringName(name))})
}

/*
Removes a local override for a theme constant with the specified [param name] previously added by [method add_theme_constant_override] or via the Inspector dock.
*/
//go:nosplit
func (self class) RemoveThemeConstantOverride(name String.Name) { //gd:Window.remove_theme_constant_override
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.remove_theme_constant_override, 0|(gdextension.SizeStringName<<4), &struct{ name gdextension.StringName }{pointers.Get(gd.InternalStringName(name))})
}

/*
Returns an icon from the first matching [Theme] in the tree if that [Theme] has an icon item with the specified [param name] and [param theme_type].
See [method Control.get_theme_color] for details.
*/
//go:nosplit
func (self class) GetThemeIcon(name String.Name, theme_type String.Name) [1]gdclass.Texture2D { //gd:Window.get_theme_icon
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_theme_icon, gdextension.SizeObject|(gdextension.SizeStringName<<4)|(gdextension.SizeStringName<<8), &struct {
		name       gdextension.StringName
		theme_type gdextension.StringName
	}{pointers.Get(gd.InternalStringName(name)), pointers.Get(gd.InternalStringName(theme_type))})
	var ret = [1]gdclass.Texture2D{gd.PointerWithOwnershipTransferredToGo[gdclass.Texture2D](r_ret)}
	return ret
}

/*
Returns a [StyleBox] from the first matching [Theme] in the tree if that [Theme] has a stylebox item with the specified [param name] and [param theme_type].
See [method Control.get_theme_color] for details.
*/
//go:nosplit
func (self class) GetThemeStylebox(name String.Name, theme_type String.Name) [1]gdclass.StyleBox { //gd:Window.get_theme_stylebox
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_theme_stylebox, gdextension.SizeObject|(gdextension.SizeStringName<<4)|(gdextension.SizeStringName<<8), &struct {
		name       gdextension.StringName
		theme_type gdextension.StringName
	}{pointers.Get(gd.InternalStringName(name)), pointers.Get(gd.InternalStringName(theme_type))})
	var ret = [1]gdclass.StyleBox{gd.PointerWithOwnershipTransferredToGo[gdclass.StyleBox](r_ret)}
	return ret
}

/*
Returns a [Font] from the first matching [Theme] in the tree if that [Theme] has a font item with the specified [param name] and [param theme_type].
See [method Control.get_theme_color] for details.
*/
//go:nosplit
func (self class) GetThemeFont(name String.Name, theme_type String.Name) [1]gdclass.Font { //gd:Window.get_theme_font
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_theme_font, gdextension.SizeObject|(gdextension.SizeStringName<<4)|(gdextension.SizeStringName<<8), &struct {
		name       gdextension.StringName
		theme_type gdextension.StringName
	}{pointers.Get(gd.InternalStringName(name)), pointers.Get(gd.InternalStringName(theme_type))})
	var ret = [1]gdclass.Font{gd.PointerWithOwnershipTransferredToGo[gdclass.Font](r_ret)}
	return ret
}

/*
Returns a font size from the first matching [Theme] in the tree if that [Theme] has a font size item with the specified [param name] and [param theme_type].
See [method Control.get_theme_color] for details.
*/
//go:nosplit
func (self class) GetThemeFontSize(name String.Name, theme_type String.Name) int64 { //gd:Window.get_theme_font_size
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_theme_font_size, gdextension.SizeInt|(gdextension.SizeStringName<<4)|(gdextension.SizeStringName<<8), &struct {
		name       gdextension.StringName
		theme_type gdextension.StringName
	}{pointers.Get(gd.InternalStringName(name)), pointers.Get(gd.InternalStringName(theme_type))})
	var ret = r_ret
	return ret
}

/*
Returns a [Color] from the first matching [Theme] in the tree if that [Theme] has a color item with the specified [param name] and [param theme_type].
See [method Control.get_theme_color] for more details.
*/
//go:nosplit
func (self class) GetThemeColor(name String.Name, theme_type String.Name) Color.RGBA { //gd:Window.get_theme_color
	var r_ret = gdextension.Call[Color.RGBA](gd.ObjectChecked(self.AsObject()), methods.get_theme_color, gdextension.SizeColor|(gdextension.SizeStringName<<4)|(gdextension.SizeStringName<<8), &struct {
		name       gdextension.StringName
		theme_type gdextension.StringName
	}{pointers.Get(gd.InternalStringName(name)), pointers.Get(gd.InternalStringName(theme_type))})
	var ret = r_ret
	return ret
}

/*
Returns a constant from the first matching [Theme] in the tree if that [Theme] has a constant item with the specified [param name] and [param theme_type].
See [method Control.get_theme_color] for more details.
*/
//go:nosplit
func (self class) GetThemeConstant(name String.Name, theme_type String.Name) int64 { //gd:Window.get_theme_constant
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_theme_constant, gdextension.SizeInt|(gdextension.SizeStringName<<4)|(gdextension.SizeStringName<<8), &struct {
		name       gdextension.StringName
		theme_type gdextension.StringName
	}{pointers.Get(gd.InternalStringName(name)), pointers.Get(gd.InternalStringName(theme_type))})
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if there is a local override for a theme icon with the specified [param name] in this [Control] node.
See [method add_theme_icon_override].
*/
//go:nosplit
func (self class) HasThemeIconOverride(name String.Name) bool { //gd:Window.has_theme_icon_override
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.has_theme_icon_override, gdextension.SizeBool|(gdextension.SizeStringName<<4), &struct{ name gdextension.StringName }{pointers.Get(gd.InternalStringName(name))})
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if there is a local override for a theme [StyleBox] with the specified [param name] in this [Control] node.
See [method add_theme_stylebox_override].
*/
//go:nosplit
func (self class) HasThemeStyleboxOverride(name String.Name) bool { //gd:Window.has_theme_stylebox_override
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.has_theme_stylebox_override, gdextension.SizeBool|(gdextension.SizeStringName<<4), &struct{ name gdextension.StringName }{pointers.Get(gd.InternalStringName(name))})
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if there is a local override for a theme [Font] with the specified [param name] in this [Control] node.
See [method add_theme_font_override].
*/
//go:nosplit
func (self class) HasThemeFontOverride(name String.Name) bool { //gd:Window.has_theme_font_override
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.has_theme_font_override, gdextension.SizeBool|(gdextension.SizeStringName<<4), &struct{ name gdextension.StringName }{pointers.Get(gd.InternalStringName(name))})
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if there is a local override for a theme font size with the specified [param name] in this [Control] node.
See [method add_theme_font_size_override].
*/
//go:nosplit
func (self class) HasThemeFontSizeOverride(name String.Name) bool { //gd:Window.has_theme_font_size_override
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.has_theme_font_size_override, gdextension.SizeBool|(gdextension.SizeStringName<<4), &struct{ name gdextension.StringName }{pointers.Get(gd.InternalStringName(name))})
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if there is a local override for a theme [Color] with the specified [param name] in this [Control] node.
See [method add_theme_color_override].
*/
//go:nosplit
func (self class) HasThemeColorOverride(name String.Name) bool { //gd:Window.has_theme_color_override
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.has_theme_color_override, gdextension.SizeBool|(gdextension.SizeStringName<<4), &struct{ name gdextension.StringName }{pointers.Get(gd.InternalStringName(name))})
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if there is a local override for a theme constant with the specified [param name] in this [Control] node.
See [method add_theme_constant_override].
*/
//go:nosplit
func (self class) HasThemeConstantOverride(name String.Name) bool { //gd:Window.has_theme_constant_override
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.has_theme_constant_override, gdextension.SizeBool|(gdextension.SizeStringName<<4), &struct{ name gdextension.StringName }{pointers.Get(gd.InternalStringName(name))})
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if there is a matching [Theme] in the tree that has an icon item with the specified [param name] and [param theme_type].
See [method Control.get_theme_color] for details.
*/
//go:nosplit
func (self class) HasThemeIcon(name String.Name, theme_type String.Name) bool { //gd:Window.has_theme_icon
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.has_theme_icon, gdextension.SizeBool|(gdextension.SizeStringName<<4)|(gdextension.SizeStringName<<8), &struct {
		name       gdextension.StringName
		theme_type gdextension.StringName
	}{pointers.Get(gd.InternalStringName(name)), pointers.Get(gd.InternalStringName(theme_type))})
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if there is a matching [Theme] in the tree that has a stylebox item with the specified [param name] and [param theme_type].
See [method Control.get_theme_color] for details.
*/
//go:nosplit
func (self class) HasThemeStylebox(name String.Name, theme_type String.Name) bool { //gd:Window.has_theme_stylebox
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.has_theme_stylebox, gdextension.SizeBool|(gdextension.SizeStringName<<4)|(gdextension.SizeStringName<<8), &struct {
		name       gdextension.StringName
		theme_type gdextension.StringName
	}{pointers.Get(gd.InternalStringName(name)), pointers.Get(gd.InternalStringName(theme_type))})
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if there is a matching [Theme] in the tree that has a font item with the specified [param name] and [param theme_type].
See [method Control.get_theme_color] for details.
*/
//go:nosplit
func (self class) HasThemeFont(name String.Name, theme_type String.Name) bool { //gd:Window.has_theme_font
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.has_theme_font, gdextension.SizeBool|(gdextension.SizeStringName<<4)|(gdextension.SizeStringName<<8), &struct {
		name       gdextension.StringName
		theme_type gdextension.StringName
	}{pointers.Get(gd.InternalStringName(name)), pointers.Get(gd.InternalStringName(theme_type))})
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if there is a matching [Theme] in the tree that has a font size item with the specified [param name] and [param theme_type].
See [method Control.get_theme_color] for details.
*/
//go:nosplit
func (self class) HasThemeFontSize(name String.Name, theme_type String.Name) bool { //gd:Window.has_theme_font_size
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.has_theme_font_size, gdextension.SizeBool|(gdextension.SizeStringName<<4)|(gdextension.SizeStringName<<8), &struct {
		name       gdextension.StringName
		theme_type gdextension.StringName
	}{pointers.Get(gd.InternalStringName(name)), pointers.Get(gd.InternalStringName(theme_type))})
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if there is a matching [Theme] in the tree that has a color item with the specified [param name] and [param theme_type].
See [method Control.get_theme_color] for details.
*/
//go:nosplit
func (self class) HasThemeColor(name String.Name, theme_type String.Name) bool { //gd:Window.has_theme_color
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.has_theme_color, gdextension.SizeBool|(gdextension.SizeStringName<<4)|(gdextension.SizeStringName<<8), &struct {
		name       gdextension.StringName
		theme_type gdextension.StringName
	}{pointers.Get(gd.InternalStringName(name)), pointers.Get(gd.InternalStringName(theme_type))})
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if there is a matching [Theme] in the tree that has a constant item with the specified [param name] and [param theme_type].
See [method Control.get_theme_color] for details.
*/
//go:nosplit
func (self class) HasThemeConstant(name String.Name, theme_type String.Name) bool { //gd:Window.has_theme_constant
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.has_theme_constant, gdextension.SizeBool|(gdextension.SizeStringName<<4)|(gdextension.SizeStringName<<8), &struct {
		name       gdextension.StringName
		theme_type gdextension.StringName
	}{pointers.Get(gd.InternalStringName(name)), pointers.Get(gd.InternalStringName(theme_type))})
	var ret = r_ret
	return ret
}

/*
Returns the default base scale value from the first matching [Theme] in the tree if that [Theme] has a valid [member Theme.default_base_scale] value.
See [method Control.get_theme_color] for details.
*/
//go:nosplit
func (self class) GetThemeDefaultBaseScale() float64 { //gd:Window.get_theme_default_base_scale
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_theme_default_base_scale, gdextension.SizeFloat, &struct{}{})
	var ret = r_ret
	return ret
}

/*
Returns the default font from the first matching [Theme] in the tree if that [Theme] has a valid [member Theme.default_font] value.
See [method Control.get_theme_color] for details.
*/
//go:nosplit
func (self class) GetThemeDefaultFont() [1]gdclass.Font { //gd:Window.get_theme_default_font
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_theme_default_font, gdextension.SizeObject, &struct{}{})
	var ret = [1]gdclass.Font{gd.PointerWithOwnershipTransferredToGo[gdclass.Font](r_ret)}
	return ret
}

/*
Returns the default font size value from the first matching [Theme] in the tree if that [Theme] has a valid [member Theme.default_font_size] value.
See [method Control.get_theme_color] for details.
*/
//go:nosplit
func (self class) GetThemeDefaultFontSize() int64 { //gd:Window.get_theme_default_font_size
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_theme_default_font_size, gdextension.SizeInt, &struct{}{})
	var ret = r_ret
	return ret
}

/*
Sets layout direction and text writing direction. Right-to-left layouts are necessary for certain languages (e.g. Arabic and Hebrew).
*/
//go:nosplit
func (self class) SetLayoutDirection(direction LayoutDirection) { //gd:Window.set_layout_direction
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_layout_direction, 0|(gdextension.SizeInt<<4), &struct{ direction LayoutDirection }{direction})
}

/*
Returns layout direction and text writing direction.
*/
//go:nosplit
func (self class) GetLayoutDirection() LayoutDirection { //gd:Window.get_layout_direction
	var r_ret = gdextension.Call[LayoutDirection](gd.ObjectChecked(self.AsObject()), methods.get_layout_direction, gdextension.SizeInt, &struct{}{})
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if layout is right-to-left.
*/
//go:nosplit
func (self class) IsLayoutRtl() bool { //gd:Window.is_layout_rtl
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_layout_rtl, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetAutoTranslate(enable bool) { //gd:Window.set_auto_translate
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_auto_translate, 0|(gdextension.SizeBool<<4), &struct{ enable bool }{enable})
}

//go:nosplit
func (self class) IsAutoTranslating() bool { //gd:Window.is_auto_translating
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_auto_translating, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

/*
Shows the [Window] and makes it transient (see [member transient]). If [param rect] is provided, it will be set as the [Window]'s size. Fails if called on the main window.
If [member ProjectSettings.display/window/subwindows/embed_subwindows] is [code]true[/code] (single-window mode), [param rect]'s coordinates are global and relative to the main window's top-left corner (excluding window decorations). If [param rect]'s position coordinates are negative, the window will be located outside the main window and may not be visible as a result.
If [member ProjectSettings.display/window/subwindows/embed_subwindows] is [code]false[/code] (multi-window mode), [param rect]'s coordinates are global and relative to the top-left corner of the leftmost screen. If [param rect]'s position coordinates are negative, the window will be placed at the top-left corner of the screen.
[b]Note:[/b] [param rect] must be in global coordinates if specified.
*/
//go:nosplit
func (self class) Popup(rect Rect2i.PositionSize) { //gd:Window.popup
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.popup, 0|(gdextension.SizeRect2i<<4), &struct{ rect Rect2i.PositionSize }{rect})
}

/*
Popups the [Window] with a position shifted by parent [Window]'s position. If the [Window] is embedded, has the same effect as [method popup].
*/
//go:nosplit
func (self class) PopupOnParent(parent_rect Rect2i.PositionSize) { //gd:Window.popup_on_parent
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.popup_on_parent, 0|(gdextension.SizeRect2i<<4), &struct{ parent_rect Rect2i.PositionSize }{parent_rect})
}

/*
Popups the [Window] at the center of the current screen, with optionally given minimum size. If the [Window] is embedded, it will be centered in the parent [Viewport] instead.
[b]Note:[/b] Calling it with the default value of [param minsize] is equivalent to calling it with [member size].
*/
//go:nosplit
func (self class) PopupCentered(minsize Vector2i.XY) { //gd:Window.popup_centered
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.popup_centered, 0|(gdextension.SizeVector2i<<4), &struct{ minsize Vector2i.XY }{minsize})
}

/*
If [Window] is embedded, popups the [Window] centered inside its embedder and sets its size as a [param ratio] of embedder's size.
If [Window] is a native window, popups the [Window] centered inside the screen of its parent [Window] and sets its size as a [param ratio] of the screen size.
*/
//go:nosplit
func (self class) PopupCenteredRatio(ratio float64) { //gd:Window.popup_centered_ratio
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.popup_centered_ratio, 0|(gdextension.SizeFloat<<4), &struct{ ratio float64 }{ratio})
}

/*
Popups the [Window] centered inside its parent [Window]. [param fallback_ratio] determines the maximum size of the [Window], in relation to its parent.
[b]Note:[/b] Calling it with the default value of [param minsize] is equivalent to calling it with [member size].
*/
//go:nosplit
func (self class) PopupCenteredClamped(minsize Vector2i.XY, fallback_ratio float64) { //gd:Window.popup_centered_clamped
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.popup_centered_clamped, 0|(gdextension.SizeVector2i<<4)|(gdextension.SizeFloat<<8), &struct {
		minsize        Vector2i.XY
		fallback_ratio float64
	}{minsize, fallback_ratio})
}

/*
Attempts to parent this dialog to the last exclusive window relative to [param from_node], and then calls [method Window.popup] on it. The dialog must have no current parent, otherwise the method fails.
See also [method set_unparent_when_invisible] and [method Node.get_last_exclusive_window].
*/
//go:nosplit
func (self class) PopupExclusive(from_node [1]gdclass.Node, rect Rect2i.PositionSize) { //gd:Window.popup_exclusive
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.popup_exclusive, 0|(gdextension.SizeObject<<4)|(gdextension.SizeRect2i<<8), &struct {
		from_node gdextension.Object
		rect      Rect2i.PositionSize
	}{gdextension.Object(gd.ObjectChecked(from_node[0].AsObject())), rect})
}

/*
Attempts to parent this dialog to the last exclusive window relative to [param from_node], and then calls [method Window.popup_on_parent] on it. The dialog must have no current parent, otherwise the method fails.
See also [method set_unparent_when_invisible] and [method Node.get_last_exclusive_window].
*/
//go:nosplit
func (self class) PopupExclusiveOnParent(from_node [1]gdclass.Node, parent_rect Rect2i.PositionSize) { //gd:Window.popup_exclusive_on_parent
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.popup_exclusive_on_parent, 0|(gdextension.SizeObject<<4)|(gdextension.SizeRect2i<<8), &struct {
		from_node   gdextension.Object
		parent_rect Rect2i.PositionSize
	}{gdextension.Object(gd.ObjectChecked(from_node[0].AsObject())), parent_rect})
}

/*
Attempts to parent this dialog to the last exclusive window relative to [param from_node], and then calls [method Window.popup_centered] on it. The dialog must have no current parent, otherwise the method fails.
See also [method set_unparent_when_invisible] and [method Node.get_last_exclusive_window].
*/
//go:nosplit
func (self class) PopupExclusiveCentered(from_node [1]gdclass.Node, minsize Vector2i.XY) { //gd:Window.popup_exclusive_centered
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.popup_exclusive_centered, 0|(gdextension.SizeObject<<4)|(gdextension.SizeVector2i<<8), &struct {
		from_node gdextension.Object
		minsize   Vector2i.XY
	}{gdextension.Object(gd.ObjectChecked(from_node[0].AsObject())), minsize})
}

/*
Attempts to parent this dialog to the last exclusive window relative to [param from_node], and then calls [method Window.popup_centered_ratio] on it. The dialog must have no current parent, otherwise the method fails.
See also [method set_unparent_when_invisible] and [method Node.get_last_exclusive_window].
*/
//go:nosplit
func (self class) PopupExclusiveCenteredRatio(from_node [1]gdclass.Node, ratio float64) { //gd:Window.popup_exclusive_centered_ratio
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.popup_exclusive_centered_ratio, 0|(gdextension.SizeObject<<4)|(gdextension.SizeFloat<<8), &struct {
		from_node gdextension.Object
		ratio     float64
	}{gdextension.Object(gd.ObjectChecked(from_node[0].AsObject())), ratio})
}

/*
Attempts to parent this dialog to the last exclusive window relative to [param from_node], and then calls [method Window.popup_centered_clamped] on it. The dialog must have no current parent, otherwise the method fails.
See also [method set_unparent_when_invisible] and [method Node.get_last_exclusive_window].
*/
//go:nosplit
func (self class) PopupExclusiveCenteredClamped(from_node [1]gdclass.Node, minsize Vector2i.XY, fallback_ratio float64) { //gd:Window.popup_exclusive_centered_clamped
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.popup_exclusive_centered_clamped, 0|(gdextension.SizeObject<<4)|(gdextension.SizeVector2i<<8)|(gdextension.SizeFloat<<12), &struct {
		from_node      gdextension.Object
		minsize        Vector2i.XY
		fallback_ratio float64
	}{gdextension.Object(gd.ObjectChecked(from_node[0].AsObject())), minsize, fallback_ratio})
}
func (self Instance) OnWindowInput(cb func(event InputEvent.Instance), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("window_input"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) WindowInput() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`WindowInput`))))
}

func (self Instance) OnFilesDropped(cb func(files []string), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("files_dropped"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) FilesDropped() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`FilesDropped`))))
}

func (self Instance) OnMouseEntered(cb func(), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("mouse_entered"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) MouseEntered() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`MouseEntered`))))
}

func (self Instance) OnMouseExited(cb func(), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("mouse_exited"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) MouseExited() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`MouseExited`))))
}

func (self Instance) OnFocusEntered(cb func(), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("focus_entered"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) FocusEntered() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`FocusEntered`))))
}

func (self Instance) OnFocusExited(cb func(), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("focus_exited"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) FocusExited() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`FocusExited`))))
}

func (self Instance) OnCloseRequested(cb func(), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("close_requested"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) CloseRequested() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`CloseRequested`))))
}

func (self Instance) OnGoBackRequested(cb func(), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("go_back_requested"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) GoBackRequested() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`GoBackRequested`))))
}

func (self Instance) OnVisibilityChanged(cb func(), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("visibility_changed"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) VisibilityChanged() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`VisibilityChanged`))))
}

func (self Instance) OnAboutToPopup(cb func(), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("about_to_popup"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) AboutToPopup() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`AboutToPopup`))))
}

func (self Instance) OnThemeChanged(cb func(), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("theme_changed"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) ThemeChanged() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`ThemeChanged`))))
}

func (self Instance) OnDpiChanged(cb func(), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("dpi_changed"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) DpiChanged() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`DpiChanged`))))
}

func (self Instance) OnTitlebarChanged(cb func(), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("titlebar_changed"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) TitlebarChanged() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`TitlebarChanged`))))
}

func (self Instance) OnTitleChanged(cb func(), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("title_changed"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) TitleChanged() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`TitleChanged`))))
}

func (self class) AsWindow() Advanced         { return Advanced{pointers.AsA[gdclass.Window](self[0])} }
func (self Instance) AsWindow() Instance      { return Instance{pointers.AsA[gdclass.Window](self[0])} }
func (self *Extension[T]) AsWindow() Instance { return self.Super().AsWindow() }
func (self class) AsViewport() Viewport.Advanced {
	return Viewport.Advanced{pointers.AsA[gdclass.Viewport](self[0])}
}
func (self *Extension[T]) AsViewport() Viewport.Instance { return self.Super().AsViewport() }
func (self Instance) AsViewport() Viewport.Instance {
	return Viewport.Instance{pointers.AsA[gdclass.Viewport](self[0])}
}
func (self class) AsNode() Node.Advanced         { return Node.Advanced{pointers.AsA[gdclass.Node](self[0])} }
func (self *Extension[T]) AsNode() Node.Instance { return self.Super().AsNode() }
func (self Instance) AsNode() Node.Instance {
	return Node.Instance{pointers.AsA[gdclass.Node](self[0])}
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	case "_get_contents_minimum_size":
		return reflect.ValueOf(self._get_contents_minimum_size)
	default:
		return gd.VirtualByName(Viewport.Advanced(self.AsViewport()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	case "_get_contents_minimum_size":
		return reflect.ValueOf(self._get_contents_minimum_size)
	default:
		return gd.VirtualByName(Viewport.Instance(self.AsViewport()), name)
	}
}
func init() {
	gdclass.Register("Window", func(ptr gd.Object) any { return Instance{pointers.AsA[gdclass.Window](ptr)} })
}

type Mode int //gd:Window.Mode

const (
	/*Windowed mode, i.e. [Window] doesn't occupy the whole screen (unless set to the size of the screen).*/
	ModeWindowed Mode = 0
	/*Minimized window mode, i.e. [Window] is not visible and available on window manager's window list. Normally happens when the minimize button is pressed.*/
	ModeMinimized Mode = 1
	/*Maximized window mode, i.e. [Window] will occupy whole screen area except task bar and still display its borders. Normally happens when the maximize button is pressed.*/
	ModeMaximized Mode = 2
	/*Full screen mode with full multi-window support.
	  Full screen window covers the entire display area of a screen and has no decorations. The display's video mode is not changed.
	  [b]On Android:[/b] This enables immersive mode.
	  [b]On Windows:[/b] Multi-window full-screen mode has a 1px border of the [member ProjectSettings.rendering/environment/defaults/default_clear_color] color.
	  [b]On macOS:[/b] A new desktop is used to display the running project.
	  [b]Note:[/b] Regardless of the platform, enabling full screen will change the window size to match the monitor's size. Therefore, make sure your project supports [url=$DOCS_URL/tutorials/rendering/multiple_resolutions.html]multiple resolutions[/url] when enabling full screen mode.*/
	ModeFullscreen Mode = 3
	/*A single window full screen mode. This mode has less overhead, but only one window can be open on a given screen at a time (opening a child window or application switching will trigger a full screen transition).
	  Full screen window covers the entire display area of a screen and has no border or decorations. The display's video mode is not changed.
	  [b]On Android:[/b] This enables immersive mode.
	  [b]On Windows:[/b] Depending on video driver, full screen transition might cause screens to go black for a moment.
	  [b]On macOS:[/b] A new desktop is used to display the running project. Exclusive full screen mode prevents Dock and Menu from showing up when the mouse pointer is hovering the edge of the screen.
	  [b]On Linux (X11):[/b] Exclusive full screen mode bypasses compositor.
	  [b]Note:[/b] Regardless of the platform, enabling full screen will change the window size to match the monitor's size. Therefore, make sure your project supports [url=$DOCS_URL/tutorials/rendering/multiple_resolutions.html]multiple resolutions[/url] when enabling full screen mode.*/
	ModeExclusiveFullscreen Mode = 4
)

type Flags int //gd:Window.Flags

const (
	/*The window can't be resized by dragging its resize grip. It's still possible to resize the window using [member size]. This flag is ignored for full screen windows. Set with [member unresizable].*/
	FlagResizeDisabled Flags = 0
	/*The window do not have native title bar and other decorations. This flag is ignored for full-screen windows. Set with [member borderless].*/
	FlagBorderless Flags = 1
	/*The window is floating on top of all other windows. This flag is ignored for full-screen windows. Set with [member always_on_top].*/
	FlagAlwaysOnTop Flags = 2
	/*The window background can be transparent. Set with [member transparent].
	  [b]Note:[/b] This flag has no effect if either [member ProjectSettings.display/window/per_pixel_transparency/allowed], or the window's [member Viewport.transparent_bg] is set to [code]false[/code].*/
	FlagTransparent Flags = 3
	/*The window can't be focused. No-focus window will ignore all input, except mouse clicks. Set with [member unfocusable].*/
	FlagNoFocus Flags = 4
	/*Window is part of menu or [OptionButton] dropdown. This flag can't be changed when the window is visible. An active popup window will exclusively receive all input, without stealing focus from its parent. Popup windows are automatically closed when uses click outside it, or when an application is switched. Popup window must have transient parent set (see [member transient]).
	  [b]Note:[/b] This flag has no effect in embedded windows (unless said window is a [Popup]).*/
	FlagPopup Flags = 5
	/*Window content is expanded to the full size of the window. Unlike borderless window, the frame is left intact and can be used to resize the window, title bar is transparent, but have minimize/maximize/close buttons. Set with [member extend_to_title].
	  [b]Note:[/b] This flag is implemented only on macOS.
	  [b]Note:[/b] This flag has no effect in embedded windows.*/
	FlagExtendToTitle Flags = 6
	/*All mouse events are passed to the underlying window of the same application.
	  [b]Note:[/b] This flag has no effect in embedded windows.*/
	FlagMousePassthrough Flags = 7
	/*Window style is overridden, forcing sharp corners.
	  [b]Note:[/b] This flag has no effect in embedded windows.
	  [b]Note:[/b] This flag is implemented only on Windows (11).*/
	FlagSharpCorners Flags = 8
	/*Windows is excluded from screenshots taken by [method DisplayServer.screen_get_image], [method DisplayServer.screen_get_image_rect], and [method DisplayServer.screen_get_pixel].
	  [b]Note:[/b] This flag is implemented on macOS and Windows.
	  [b]Note:[/b] Setting this flag will [b]NOT[/b] prevent other apps from capturing an image, it should not be used as a security measure.*/
	FlagExcludeFromCapture Flags = 9
	/*Max value of the [enum Flags].*/
	FlagMax Flags = 10
)

type ContentScaleMode int //gd:Window.ContentScaleMode

const (
	/*The content will not be scaled to match the [Window]'s size.*/
	ContentScaleModeDisabled ContentScaleMode = 0
	/*The content will be rendered at the target size. This is more performance-expensive than [constant CONTENT_SCALE_MODE_VIEWPORT], but provides better results.*/
	ContentScaleModeCanvasItems ContentScaleMode = 1
	/*The content will be rendered at the base size and then scaled to the target size. More performant than [constant CONTENT_SCALE_MODE_CANVAS_ITEMS], but results in pixelated image.*/
	ContentScaleModeViewport ContentScaleMode = 2
)

type ContentScaleAspect int //gd:Window.ContentScaleAspect

const (
	/*The aspect will be ignored. Scaling will simply stretch the content to fit the target size.*/
	ContentScaleAspectIgnore ContentScaleAspect = 0
	/*The content's aspect will be preserved. If the target size has different aspect from the base one, the image will be centered and black bars will appear on left and right sides.*/
	ContentScaleAspectKeep ContentScaleAspect = 1
	/*The content can be expanded vertically. Scaling horizontally will result in keeping the width ratio and then black bars on left and right sides.*/
	ContentScaleAspectKeepWidth ContentScaleAspect = 2
	/*The content can be expanded horizontally. Scaling vertically will result in keeping the height ratio and then black bars on top and bottom sides.*/
	ContentScaleAspectKeepHeight ContentScaleAspect = 3
	/*The content's aspect will be preserved. If the target size has different aspect from the base one, the content will stay in the top-left corner and add an extra visible area in the stretched space.*/
	ContentScaleAspectExpand ContentScaleAspect = 4
)

type ContentScaleStretch int //gd:Window.ContentScaleStretch

const (
	/*The content will be stretched according to a fractional factor. This fills all the space available in the window, but allows "pixel wobble" to occur due to uneven pixel scaling.*/
	ContentScaleStretchFractional ContentScaleStretch = 0
	/*The content will be stretched only according to an integer factor, preserving sharp pixels. This may leave a black background visible on the window's edges depending on the window size.*/
	ContentScaleStretchInteger ContentScaleStretch = 1
)

type LayoutDirection int //gd:Window.LayoutDirection

const (
	/*Automatic layout direction, determined from the parent window layout direction.*/
	LayoutDirectionInherited LayoutDirection = 0
	/*Automatic layout direction, determined from the current locale.*/
	LayoutDirectionApplicationLocale LayoutDirection = 1
	/*Left-to-right layout direction.*/
	LayoutDirectionLtr LayoutDirection = 2
	/*Right-to-left layout direction.*/
	LayoutDirectionRtl LayoutDirection = 3
	/*Automatic layout direction, determined from the system locale.*/
	LayoutDirectionSystemLocale LayoutDirection = 4
	/*Represents the size of the [enum LayoutDirection] enum.*/
	LayoutDirectionMax    LayoutDirection = 5
	LayoutDirectionLocale LayoutDirection = 1
)

type WindowInitialPosition int //gd:Window.WindowInitialPosition

const (
	/*Initial window position is determined by [member position].*/
	WindowInitialPositionAbsolute WindowInitialPosition = 0
	/*Initial window position is the center of the primary screen.*/
	WindowInitialPositionCenterPrimaryScreen WindowInitialPosition = 1
	/*Initial window position is the center of the main window screen.*/
	WindowInitialPositionCenterMainWindowScreen WindowInitialPosition = 2
	/*Initial window position is the center of [member current_screen] screen.*/
	WindowInitialPositionCenterOtherScreen WindowInitialPosition = 3
	/*Initial window position is the center of the screen containing the mouse pointer.*/
	WindowInitialPositionCenterScreenWithMouseFocus WindowInitialPosition = 4
	/*Initial window position is the center of the screen containing the window with the keyboard focus.*/
	WindowInitialPositionCenterScreenWithKeyboardFocus WindowInitialPosition = 5
)
const NotificationVisibilityChanged Object.Notification = 30 //gd:Window.NOTIFICATION_VISIBILITY_CHANGED
const NotificationThemeChanged Object.Notification = 32      //gd:Window.NOTIFICATION_THEME_CHANGED
