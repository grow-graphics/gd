// Code generated by the generate package DO NOT EDIT

// Package StreamPeerTCP provides methods for working with StreamPeerTCP object instances.
package StreamPeerTCP

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/StreamPeer"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
A stream peer that handles TCP connections. This object can be used to connect to TCP servers, or also is returned by a TCP server.
[b]Note:[/b] When exporting to Android, make sure to enable the [code]INTERNET[/code] permission in the Android export preset before exporting the project or using one-click deploy. Otherwise, network communication of any kind will be blocked by Android.
*/
type Instance [1]gdclass.StreamPeerTCP

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	bind                 gdextension.MethodForClass `hash:"3167955072"`
	connect_to_host      gdextension.MethodForClass `hash:"993915709"`
	poll                 gdextension.MethodForClass `hash:"166280745"`
	get_status           gdextension.MethodForClass `hash:"859471121"`
	get_connected_host   gdextension.MethodForClass `hash:"201670096"`
	get_connected_port   gdextension.MethodForClass `hash:"3905245786"`
	get_local_port       gdextension.MethodForClass `hash:"3905245786"`
	disconnect_from_host gdextension.MethodForClass `hash:"3218959716"`
	set_no_delay         gdextension.MethodForClass `hash:"2586408642"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("StreamPeerTCP")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		gdextension.Free(gdextension.TypeStringName, &sname)
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

type Expanded [1]gdclass.StreamPeerTCP

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsStreamPeerTCP() Instance
}

/*
Opens the TCP socket, and binds it to the specified local address.
This method is generally not needed, and only used to force the subsequent call to [method connect_to_host] to use the specified [param host] and [param port] as source address. This can be desired in some NAT punchthrough techniques, or when forcing the source network interface.
*/
func (self Instance) Bind(port int) error { //gd:StreamPeerTCP.bind
	return error(gd.ToError(Advanced(self).Bind(int64(port), String.New("*"))))
}

/*
Opens the TCP socket, and binds it to the specified local address.
This method is generally not needed, and only used to force the subsequent call to [method connect_to_host] to use the specified [param host] and [param port] as source address. This can be desired in some NAT punchthrough techniques, or when forcing the source network interface.
*/
func (self Expanded) Bind(port int, host string) error { //gd:StreamPeerTCP.bind
	return error(gd.ToError(Advanced(self).Bind(int64(port), String.New(host))))
}

/*
Connects to the specified [code]host:port[/code] pair. A hostname will be resolved if valid. Returns [constant OK] on success.
*/
func (self Instance) ConnectToHost(host string, port int) error { //gd:StreamPeerTCP.connect_to_host
	return error(gd.ToError(Advanced(self).ConnectToHost(String.New(host), int64(port))))
}

/*
Poll the socket, updating its state. See [method get_status].
*/
func (self Instance) Poll() error { //gd:StreamPeerTCP.poll
	return error(gd.ToError(Advanced(self).Poll()))
}

/*
Returns the status of the connection, see [enum Status].
*/
func (self Instance) GetStatus() Status { //gd:StreamPeerTCP.get_status
	return Status(Advanced(self).GetStatus())
}

/*
Returns the IP of this peer.
*/
func (self Instance) GetConnectedHost() string { //gd:StreamPeerTCP.get_connected_host
	return string(Advanced(self).GetConnectedHost().String())
}

/*
Returns the port of this peer.
*/
func (self Instance) GetConnectedPort() int { //gd:StreamPeerTCP.get_connected_port
	return int(int(Advanced(self).GetConnectedPort()))
}

/*
Returns the local port to which this peer is bound.
*/
func (self Instance) GetLocalPort() int { //gd:StreamPeerTCP.get_local_port
	return int(int(Advanced(self).GetLocalPort()))
}

/*
Disconnects from host.
*/
func (self Instance) DisconnectFromHost() { //gd:StreamPeerTCP.disconnect_from_host
	Advanced(self).DisconnectFromHost()
}

/*
If [param enabled] is [code]true[/code], packets will be sent immediately. If [param enabled] is [code]false[/code] (the default), packet transfers will be delayed and combined using [url=https://en.wikipedia.org/wiki/Nagle%27s_algorithm]Nagle's algorithm[/url].
[b]Note:[/b] It's recommended to leave this disabled for applications that send large packets or need to transfer a lot of data, as enabling this can decrease the total available bandwidth.
*/
func (self Instance) SetNoDelay(enabled bool) { //gd:StreamPeerTCP.set_no_delay
	Advanced(self).SetNoDelay(enabled)
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.StreamPeerTCP

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.StreamPeerTCP)(unsafe.Pointer(&obj))
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.StreamPeerTCP)(unsafe.Pointer(&obj))
		return true
	}
	return false
}

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {

	if !gd.Linked {
		var placeholder Instance
		*(*gd.Object)(unsafe.Pointer(&placeholder)) = pointers.Add[gd.Object]([3]uint64{})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(*(*gd.Object)(unsafe.Pointer(&placeholder)), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	object := [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})}
	casted := Instance{*(*gdclass.StreamPeerTCP)(unsafe.Pointer(&object))}
	object[0].Notification(0, false)
	return casted
}

/*
Opens the TCP socket, and binds it to the specified local address.
This method is generally not needed, and only used to force the subsequent call to [method connect_to_host] to use the specified [param host] and [param port] as source address. This can be desired in some NAT punchthrough techniques, or when forcing the source network interface.
*/
//go:nosplit
func (self class) Bind(port int64, host String.Readable) Error.Code { //gd:StreamPeerTCP.bind
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.bind, gdextension.SizeInt|(gdextension.SizeInt<<4)|(gdextension.SizeString<<8), unsafe.Pointer(&struct {
		port int64
		host gdextension.String
	}{port, pointers.Get(gd.InternalString(host))}))
	var ret = Error.Code(r_ret)
	return ret
}

/*
Connects to the specified [code]host:port[/code] pair. A hostname will be resolved if valid. Returns [constant OK] on success.
*/
//go:nosplit
func (self class) ConnectToHost(host String.Readable, port int64) Error.Code { //gd:StreamPeerTCP.connect_to_host
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.connect_to_host, gdextension.SizeInt|(gdextension.SizeString<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		host gdextension.String
		port int64
	}{pointers.Get(gd.InternalString(host)), port}))
	var ret = Error.Code(r_ret)
	return ret
}

/*
Poll the socket, updating its state. See [method get_status].
*/
//go:nosplit
func (self class) Poll() Error.Code { //gd:StreamPeerTCP.poll
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.poll, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = Error.Code(r_ret)
	return ret
}

/*
Returns the status of the connection, see [enum Status].
*/
//go:nosplit
func (self class) GetStatus() Status { //gd:StreamPeerTCP.get_status
	var r_ret = gdextension.Call[Status](gd.ObjectChecked(self.AsObject()), methods.get_status, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the IP of this peer.
*/
//go:nosplit
func (self class) GetConnectedHost() String.Readable { //gd:StreamPeerTCP.get_connected_host
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_connected_host, gdextension.SizeString, unsafe.Pointer(&struct{}{}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Returns the port of this peer.
*/
//go:nosplit
func (self class) GetConnectedPort() int64 { //gd:StreamPeerTCP.get_connected_port
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_connected_port, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the local port to which this peer is bound.
*/
//go:nosplit
func (self class) GetLocalPort() int64 { //gd:StreamPeerTCP.get_local_port
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_local_port, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Disconnects from host.
*/
//go:nosplit
func (self class) DisconnectFromHost() { //gd:StreamPeerTCP.disconnect_from_host
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.disconnect_from_host, 0, unsafe.Pointer(&struct{}{}))
}

/*
If [param enabled] is [code]true[/code], packets will be sent immediately. If [param enabled] is [code]false[/code] (the default), packet transfers will be delayed and combined using [url=https://en.wikipedia.org/wiki/Nagle%27s_algorithm]Nagle's algorithm[/url].
[b]Note:[/b] It's recommended to leave this disabled for applications that send large packets or need to transfer a lot of data, as enabling this can decrease the total available bandwidth.
*/
//go:nosplit
func (self class) SetNoDelay(enabled bool) { //gd:StreamPeerTCP.set_no_delay
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_no_delay, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enabled bool }{enabled}))
}
func (self class) AsStreamPeerTCP() Advanced         { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsStreamPeerTCP() Instance      { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsStreamPeerTCP() Instance { return self.Super().AsStreamPeerTCP() }
func (self class) AsStreamPeer() StreamPeer.Advanced {
	return *((*StreamPeer.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsStreamPeer() StreamPeer.Instance { return self.Super().AsStreamPeer() }
func (self Instance) AsStreamPeer() StreamPeer.Instance {
	return *((*StreamPeer.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsRefCounted() [1]gd.RefCounted { return self.Super().AsRefCounted() }
func (self Instance) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(StreamPeer.Advanced(self.AsStreamPeer()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(StreamPeer.Instance(self.AsStreamPeer()), name)
	}
}
func init() {
	gdclass.Register("StreamPeerTCP", func(ptr gd.Object) any { return *(*Instance)(unsafe.Pointer(&ptr)) })
}

type Status int //gd:StreamPeerTCP.Status

const (
	/*The initial status of the [StreamPeerTCP]. This is also the status after disconnecting.*/
	StatusNone Status = 0
	/*A status representing a [StreamPeerTCP] that is connecting to a host.*/
	StatusConnecting Status = 1
	/*A status representing a [StreamPeerTCP] that is connected to a host.*/
	StatusConnected Status = 2
	/*A status representing a [StreamPeerTCP] in error state.*/
	StatusError Status = 3
)
