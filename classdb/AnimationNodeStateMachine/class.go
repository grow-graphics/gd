// Code generated by the generate package DO NOT EDIT

// Package AnimationNodeStateMachine provides methods for working with AnimationNodeStateMachine object instances.
package AnimationNodeStateMachine

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/classdb/AnimationNode"
import "graphics.gd/classdb/AnimationNodeStateMachineTransition"
import "graphics.gd/classdb/AnimationRootNode"
import "graphics.gd/classdb/Resource"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"
import "graphics.gd/variant/Vector2"

var _ Object.ID
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ = slices.Delete[[]struct{}, struct{}]

/*
Contains multiple [AnimationRootNode]s representing animation states, connected in a graph. State transitions can be configured to happen automatically or via code, using a shortest-path algorithm. Retrieve the [AnimationNodeStateMachinePlayback] object from the [AnimationTree] node to control it programmatically.
[codeblocks]
[gdscript]
var state_machine = $AnimationTree.get("parameters/playback")
state_machine.travel("some_state")
[/gdscript]
[csharp]
var stateMachine = GetNode<AnimationTree>("AnimationTree").Get("parameters/playback") as AnimationNodeStateMachinePlayback;
stateMachine.Travel("some_state");
[/csharp]
[/codeblocks]
*/
type Instance [1]gdclass.AnimationNodeStateMachine
type Expanded [1]gdclass.AnimationNodeStateMachine

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsAnimationNodeStateMachine() Instance
}

/*
Adds a new animation node to the graph. The [param position] is used for display in the editor.
*/
func (self Instance) AddNode(name string, node AnimationNode.Instance) { //gd:AnimationNodeStateMachine.add_node
	Advanced(self).AddNode(String.Name(String.New(name)), node, Vector2.XY(gd.Vector2{0, 0}))
}

/*
Adds a new animation node to the graph. The [param position] is used for display in the editor.
*/
func (self Expanded) AddNode(name string, node AnimationNode.Instance, position Vector2.XY) { //gd:AnimationNodeStateMachine.add_node
	Advanced(self).AddNode(String.Name(String.New(name)), node, Vector2.XY(position))
}

/*
Replaces the given animation node with a new animation node.
*/
func (self Instance) ReplaceNode(name string, node AnimationNode.Instance) { //gd:AnimationNodeStateMachine.replace_node
	Advanced(self).ReplaceNode(String.Name(String.New(name)), node)
}

/*
Returns the animation node with the given name.
*/
func (self Instance) GetNode(name string) AnimationNode.Instance { //gd:AnimationNodeStateMachine.get_node
	return AnimationNode.Instance(Advanced(self).GetNode(String.Name(String.New(name))))
}

/*
Deletes the given animation node from the graph.
*/
func (self Instance) RemoveNode(name string) { //gd:AnimationNodeStateMachine.remove_node
	Advanced(self).RemoveNode(String.Name(String.New(name)))
}

/*
Renames the given animation node.
*/
func (self Instance) RenameNode(name string, new_name string) { //gd:AnimationNodeStateMachine.rename_node
	Advanced(self).RenameNode(String.Name(String.New(name)), String.Name(String.New(new_name)))
}

/*
Returns [code]true[/code] if the graph contains the given animation node.
*/
func (self Instance) HasNode(name string) bool { //gd:AnimationNodeStateMachine.has_node
	return bool(Advanced(self).HasNode(String.Name(String.New(name))))
}

/*
Returns the given animation node's name.
*/
func (self Instance) GetNodeName(node AnimationNode.Instance) string { //gd:AnimationNodeStateMachine.get_node_name
	return string(Advanced(self).GetNodeName(node).String())
}

/*
Sets the animation node's coordinates. Used for display in the editor.
*/
func (self Instance) SetNodePosition(name string, position Vector2.XY) { //gd:AnimationNodeStateMachine.set_node_position
	Advanced(self).SetNodePosition(String.Name(String.New(name)), Vector2.XY(position))
}

/*
Returns the given animation node's coordinates. Used for display in the editor.
*/
func (self Instance) GetNodePosition(name string) Vector2.XY { //gd:AnimationNodeStateMachine.get_node_position
	return Vector2.XY(Advanced(self).GetNodePosition(String.Name(String.New(name))))
}

/*
Returns [code]true[/code] if there is a transition between the given animation nodes.
*/
func (self Instance) HasTransition(from string, to string) bool { //gd:AnimationNodeStateMachine.has_transition
	return bool(Advanced(self).HasTransition(String.Name(String.New(from)), String.Name(String.New(to))))
}

/*
Adds a transition between the given animation nodes.
*/
func (self Instance) AddTransition(from string, to string, transition AnimationNodeStateMachineTransition.Instance) { //gd:AnimationNodeStateMachine.add_transition
	Advanced(self).AddTransition(String.Name(String.New(from)), String.Name(String.New(to)), transition)
}

/*
Returns the given transition.
*/
func (self Instance) GetTransition(idx int) AnimationNodeStateMachineTransition.Instance { //gd:AnimationNodeStateMachine.get_transition
	return AnimationNodeStateMachineTransition.Instance(Advanced(self).GetTransition(int64(idx)))
}

/*
Returns the given transition's start node.
*/
func (self Instance) GetTransitionFrom(idx int) string { //gd:AnimationNodeStateMachine.get_transition_from
	return string(Advanced(self).GetTransitionFrom(int64(idx)).String())
}

/*
Returns the given transition's end node.
*/
func (self Instance) GetTransitionTo(idx int) string { //gd:AnimationNodeStateMachine.get_transition_to
	return string(Advanced(self).GetTransitionTo(int64(idx)).String())
}

/*
Returns the number of connections in the graph.
*/
func (self Instance) GetTransitionCount() int { //gd:AnimationNodeStateMachine.get_transition_count
	return int(int(Advanced(self).GetTransitionCount()))
}

/*
Deletes the given transition by index.
*/
func (self Instance) RemoveTransitionByIndex(idx int) { //gd:AnimationNodeStateMachine.remove_transition_by_index
	Advanced(self).RemoveTransitionByIndex(int64(idx))
}

/*
Deletes the transition between the two specified animation nodes.
*/
func (self Instance) RemoveTransition(from string, to string) { //gd:AnimationNodeStateMachine.remove_transition
	Advanced(self).RemoveTransition(String.Name(String.New(from)), String.Name(String.New(to)))
}

/*
Sets the draw offset of the graph. Used for display in the editor.
*/
func (self Instance) SetGraphOffset(offset Vector2.XY) { //gd:AnimationNodeStateMachine.set_graph_offset
	Advanced(self).SetGraphOffset(Vector2.XY(offset))
}

/*
Returns the draw offset of the graph. Used for display in the editor.
*/
func (self Instance) GetGraphOffset() Vector2.XY { //gd:AnimationNodeStateMachine.get_graph_offset
	return Vector2.XY(Advanced(self).GetGraphOffset())
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.AnimationNodeStateMachine

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func New() Instance {
	object := gd.Global.ClassDB.ConstructObject(gd.NewStringName("AnimationNodeStateMachine"))
	casted := Instance{*(*gdclass.AnimationNodeStateMachine)(unsafe.Pointer(&object))}
	casted.AsRefCounted()[0].Reference()
	return casted
}

func (self Instance) StateMachineType() gdclass.AnimationNodeStateMachineStateMachineType {
	return gdclass.AnimationNodeStateMachineStateMachineType(class(self).GetStateMachineType())
}

func (self Instance) SetStateMachineType(value gdclass.AnimationNodeStateMachineStateMachineType) {
	class(self).SetStateMachineType(value)
}

func (self Instance) AllowTransitionToSelf() bool {
	return bool(class(self).IsAllowTransitionToSelf())
}

func (self Instance) SetAllowTransitionToSelf(value bool) {
	class(self).SetAllowTransitionToSelf(value)
}

func (self Instance) ResetEnds() bool {
	return bool(class(self).AreEndsReset())
}

func (self Instance) SetResetEnds(value bool) {
	class(self).SetResetEnds(value)
}

/*
Adds a new animation node to the graph. The [param position] is used for display in the editor.
*/
//go:nosplit
func (self class) AddNode(name String.Name, node [1]gdclass.AnimationNode, position Vector2.XY) { //gd:AnimationNodeStateMachine.add_node
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalStringName(name)))
	callframe.Arg(frame, pointers.Get(node[0])[0])
	callframe.Arg(frame, position)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.AnimationNodeStateMachine.Bind_add_node, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Replaces the given animation node with a new animation node.
*/
//go:nosplit
func (self class) ReplaceNode(name String.Name, node [1]gdclass.AnimationNode) { //gd:AnimationNodeStateMachine.replace_node
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalStringName(name)))
	callframe.Arg(frame, pointers.Get(node[0])[0])
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.AnimationNodeStateMachine.Bind_replace_node, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Returns the animation node with the given name.
*/
//go:nosplit
func (self class) GetNode(name String.Name) [1]gdclass.AnimationNode { //gd:AnimationNodeStateMachine.get_node
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalStringName(name)))
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.AnimationNodeStateMachine.Bind_get_node, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.AnimationNode{gd.PointerWithOwnershipTransferredToGo[gdclass.AnimationNode](r_ret.Get())}
	frame.Free()
	return ret
}

/*
Deletes the given animation node from the graph.
*/
//go:nosplit
func (self class) RemoveNode(name String.Name) { //gd:AnimationNodeStateMachine.remove_node
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalStringName(name)))
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.AnimationNodeStateMachine.Bind_remove_node, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Renames the given animation node.
*/
//go:nosplit
func (self class) RenameNode(name String.Name, new_name String.Name) { //gd:AnimationNodeStateMachine.rename_node
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalStringName(name)))
	callframe.Arg(frame, pointers.Get(gd.InternalStringName(new_name)))
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.AnimationNodeStateMachine.Bind_rename_node, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Returns [code]true[/code] if the graph contains the given animation node.
*/
//go:nosplit
func (self class) HasNode(name String.Name) bool { //gd:AnimationNodeStateMachine.has_node
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalStringName(name)))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.AnimationNodeStateMachine.Bind_has_node, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns the given animation node's name.
*/
//go:nosplit
func (self class) GetNodeName(node [1]gdclass.AnimationNode) String.Name { //gd:AnimationNodeStateMachine.get_node_name
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(node[0])[0])
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.AnimationNodeStateMachine.Bind_get_node_name, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Name(String.Via(gd.StringNameProxy{}, pointers.Pack(pointers.New[gd.StringName](r_ret.Get()))))
	frame.Free()
	return ret
}

/*
Sets the animation node's coordinates. Used for display in the editor.
*/
//go:nosplit
func (self class) SetNodePosition(name String.Name, position Vector2.XY) { //gd:AnimationNodeStateMachine.set_node_position
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalStringName(name)))
	callframe.Arg(frame, position)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.AnimationNodeStateMachine.Bind_set_node_position, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Returns the given animation node's coordinates. Used for display in the editor.
*/
//go:nosplit
func (self class) GetNodePosition(name String.Name) Vector2.XY { //gd:AnimationNodeStateMachine.get_node_position
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalStringName(name)))
	var r_ret = callframe.Ret[Vector2.XY](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.AnimationNodeStateMachine.Bind_get_node_position, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if there is a transition between the given animation nodes.
*/
//go:nosplit
func (self class) HasTransition(from String.Name, to String.Name) bool { //gd:AnimationNodeStateMachine.has_transition
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalStringName(from)))
	callframe.Arg(frame, pointers.Get(gd.InternalStringName(to)))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.AnimationNodeStateMachine.Bind_has_transition, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Adds a transition between the given animation nodes.
*/
//go:nosplit
func (self class) AddTransition(from String.Name, to String.Name, transition [1]gdclass.AnimationNodeStateMachineTransition) { //gd:AnimationNodeStateMachine.add_transition
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalStringName(from)))
	callframe.Arg(frame, pointers.Get(gd.InternalStringName(to)))
	callframe.Arg(frame, pointers.Get(transition[0])[0])
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.AnimationNodeStateMachine.Bind_add_transition, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Returns the given transition.
*/
//go:nosplit
func (self class) GetTransition(idx int64) [1]gdclass.AnimationNodeStateMachineTransition { //gd:AnimationNodeStateMachine.get_transition
	var frame = callframe.New()
	callframe.Arg(frame, idx)
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.AnimationNodeStateMachine.Bind_get_transition, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.AnimationNodeStateMachineTransition{gd.PointerWithOwnershipTransferredToGo[gdclass.AnimationNodeStateMachineTransition](r_ret.Get())}
	frame.Free()
	return ret
}

/*
Returns the given transition's start node.
*/
//go:nosplit
func (self class) GetTransitionFrom(idx int64) String.Name { //gd:AnimationNodeStateMachine.get_transition_from
	var frame = callframe.New()
	callframe.Arg(frame, idx)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.AnimationNodeStateMachine.Bind_get_transition_from, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Name(String.Via(gd.StringNameProxy{}, pointers.Pack(pointers.New[gd.StringName](r_ret.Get()))))
	frame.Free()
	return ret
}

/*
Returns the given transition's end node.
*/
//go:nosplit
func (self class) GetTransitionTo(idx int64) String.Name { //gd:AnimationNodeStateMachine.get_transition_to
	var frame = callframe.New()
	callframe.Arg(frame, idx)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.AnimationNodeStateMachine.Bind_get_transition_to, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Name(String.Via(gd.StringNameProxy{}, pointers.Pack(pointers.New[gd.StringName](r_ret.Get()))))
	frame.Free()
	return ret
}

/*
Returns the number of connections in the graph.
*/
//go:nosplit
func (self class) GetTransitionCount() int64 { //gd:AnimationNodeStateMachine.get_transition_count
	var frame = callframe.New()
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.AnimationNodeStateMachine.Bind_get_transition_count, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Deletes the given transition by index.
*/
//go:nosplit
func (self class) RemoveTransitionByIndex(idx int64) { //gd:AnimationNodeStateMachine.remove_transition_by_index
	var frame = callframe.New()
	callframe.Arg(frame, idx)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.AnimationNodeStateMachine.Bind_remove_transition_by_index, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Deletes the transition between the two specified animation nodes.
*/
//go:nosplit
func (self class) RemoveTransition(from String.Name, to String.Name) { //gd:AnimationNodeStateMachine.remove_transition
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalStringName(from)))
	callframe.Arg(frame, pointers.Get(gd.InternalStringName(to)))
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.AnimationNodeStateMachine.Bind_remove_transition, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Sets the draw offset of the graph. Used for display in the editor.
*/
//go:nosplit
func (self class) SetGraphOffset(offset Vector2.XY) { //gd:AnimationNodeStateMachine.set_graph_offset
	var frame = callframe.New()
	callframe.Arg(frame, offset)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.AnimationNodeStateMachine.Bind_set_graph_offset, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Returns the draw offset of the graph. Used for display in the editor.
*/
//go:nosplit
func (self class) GetGraphOffset() Vector2.XY { //gd:AnimationNodeStateMachine.get_graph_offset
	var frame = callframe.New()
	var r_ret = callframe.Ret[Vector2.XY](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.AnimationNodeStateMachine.Bind_get_graph_offset, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

//go:nosplit
func (self class) SetStateMachineType(state_machine_type gdclass.AnimationNodeStateMachineStateMachineType) { //gd:AnimationNodeStateMachine.set_state_machine_type
	var frame = callframe.New()
	callframe.Arg(frame, state_machine_type)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.AnimationNodeStateMachine.Bind_set_state_machine_type, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) GetStateMachineType() gdclass.AnimationNodeStateMachineStateMachineType { //gd:AnimationNodeStateMachine.get_state_machine_type
	var frame = callframe.New()
	var r_ret = callframe.Ret[gdclass.AnimationNodeStateMachineStateMachineType](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.AnimationNodeStateMachine.Bind_get_state_machine_type, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

//go:nosplit
func (self class) SetAllowTransitionToSelf(enable bool) { //gd:AnimationNodeStateMachine.set_allow_transition_to_self
	var frame = callframe.New()
	callframe.Arg(frame, enable)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.AnimationNodeStateMachine.Bind_set_allow_transition_to_self, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) IsAllowTransitionToSelf() bool { //gd:AnimationNodeStateMachine.is_allow_transition_to_self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.AnimationNodeStateMachine.Bind_is_allow_transition_to_self, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

//go:nosplit
func (self class) SetResetEnds(enable bool) { //gd:AnimationNodeStateMachine.set_reset_ends
	var frame = callframe.New()
	callframe.Arg(frame, enable)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.AnimationNodeStateMachine.Bind_set_reset_ends, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) AreEndsReset() bool { //gd:AnimationNodeStateMachine.are_ends_reset
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.AnimationNodeStateMachine.Bind_are_ends_reset, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
func (self class) AsAnimationNodeStateMachine() Advanced {
	return *((*Advanced)(unsafe.Pointer(&self)))
}
func (self Instance) AsAnimationNodeStateMachine() Instance {
	return *((*Instance)(unsafe.Pointer(&self)))
}
func (self class) AsAnimationRootNode() AnimationRootNode.Advanced {
	return *((*AnimationRootNode.Advanced)(unsafe.Pointer(&self)))
}
func (self Instance) AsAnimationRootNode() AnimationRootNode.Instance {
	return *((*AnimationRootNode.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsAnimationNode() AnimationNode.Advanced {
	return *((*AnimationNode.Advanced)(unsafe.Pointer(&self)))
}
func (self Instance) AsAnimationNode() AnimationNode.Instance {
	return *((*AnimationNode.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsResource() Resource.Advanced {
	return *((*Resource.Advanced)(unsafe.Pointer(&self)))
}
func (self Instance) AsResource() Resource.Instance {
	return *((*Resource.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}
func (self Instance) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(AnimationRootNode.Advanced(self.AsAnimationRootNode()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(AnimationRootNode.Instance(self.AsAnimationRootNode()), name)
	}
}
func init() {
	gdclass.Register("AnimationNodeStateMachine", func(ptr gd.Object) any {
		return [1]gdclass.AnimationNodeStateMachine{*(*gdclass.AnimationNodeStateMachine)(unsafe.Pointer(&ptr))}
	})
}

type StateMachineType = gdclass.AnimationNodeStateMachineStateMachineType //gd:AnimationNodeStateMachine.StateMachineType

const (
	/*Seeking to the beginning is treated as playing from the start state. Transition to the end state is treated as exiting the state machine.*/
	StateMachineTypeRoot StateMachineType = 0
	/*Seeking to the beginning is treated as seeking to the beginning of the animation in the current state. Transition to the end state, or the absence of transitions in each state, is treated as exiting the state machine.*/
	StateMachineTypeNested StateMachineType = 1
	/*This is a grouped state machine that can be controlled from a parent state machine. It does not work independently. There must be a state machine with [member state_machine_type] of [constant STATE_MACHINE_TYPE_ROOT] or [constant STATE_MACHINE_TYPE_NESTED] in the parent or ancestor.*/
	StateMachineTypeGrouped StateMachineType = 2
)
