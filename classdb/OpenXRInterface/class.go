// Code generated by the generate package DO NOT EDIT

// Package OpenXRInterface provides methods for working with OpenXRInterface object instances.
package OpenXRInterface

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/XRInterface"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/Quaternion"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"
import "graphics.gd/variant/Vector3"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
The OpenXR interface allows Godot to interact with OpenXR runtimes and make it possible to create XR experiences and games.
Due to the needs of OpenXR this interface works slightly different than other plugin based XR interfaces. It needs to be initialized when Godot starts. You need to enable OpenXR, settings for this can be found in your games project settings under the XR heading. You do need to mark a viewport for use with XR in order for Godot to know which render result should be output to the headset.
*/
type Instance [1]gdclass.OpenXRInterface

func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsOpenXRInterface() Instance
}

/*
Returns [code]true[/code] if OpenXR's foveation extension is supported, the interface must be initialized before this returns a valid value.
[b]Note:[/b] This feature is only available on the compatibility renderer and currently only available on some stand alone headsets. For Vulkan set [member Viewport.vrs_mode] to [code]VRS_XR[/code] on desktop.
*/
func (self Instance) IsFoveationSupported() bool { //gd:OpenXRInterface.is_foveation_supported
	return bool(Advanced(self).IsFoveationSupported())
}

/*
Returns [code]true[/code] if the given action set is active.
*/
func (self Instance) IsActionSetActive(name string) bool { //gd:OpenXRInterface.is_action_set_active
	return bool(Advanced(self).IsActionSetActive(String.New(name)))
}

/*
Sets the given action set as active or inactive.
*/
func (self Instance) SetActionSetActive(name string, active bool) { //gd:OpenXRInterface.set_action_set_active
	Advanced(self).SetActionSetActive(String.New(name), active)
}

/*
Returns a list of action sets registered with Godot (loaded from the action map at runtime).
*/
func (self Instance) GetActionSets() []any { //gd:OpenXRInterface.get_action_sets
	return []any(gd.ArrayAs[[]any](gd.InternalArray(Advanced(self).GetActionSets())))
}

/*
Returns display refresh rates supported by the current HMD. Only returned if this feature is supported by the OpenXR runtime and after the interface has been initialized.
*/
func (self Instance) GetAvailableDisplayRefreshRates() []any { //gd:OpenXRInterface.get_available_display_refresh_rates
	return []any(gd.ArrayAs[[]any](gd.InternalArray(Advanced(self).GetAvailableDisplayRefreshRates())))
}

/*
If handtracking is enabled and motion range is supported, sets the currently configured motion range for [param hand] to [param motion_range].
*/
func (self Instance) SetMotionRange(hand Hand, motion_range HandMotionRange) { //gd:OpenXRInterface.set_motion_range
	Advanced(self).SetMotionRange(hand, motion_range)
}

/*
If handtracking is enabled and motion range is supported, gets the currently configured motion range for [param hand].
*/
func (self Instance) GetMotionRange(hand Hand) HandMotionRange { //gd:OpenXRInterface.get_motion_range
	return HandMotionRange(Advanced(self).GetMotionRange(hand))
}

/*
If handtracking is enabled and hand tracking source is supported, gets the source of the hand tracking data for [param hand].
*/
func (self Instance) GetHandTrackingSource(hand Hand) HandTrackedSource { //gd:OpenXRInterface.get_hand_tracking_source
	return HandTrackedSource(Advanced(self).GetHandTrackingSource(hand))
}

/*
If handtracking is enabled, returns flags that inform us of the validity of the tracking data.
*/
func (self Instance) GetHandJointFlags(hand Hand, joint HandJoints) HandJointFlags { //gd:OpenXRInterface.get_hand_joint_flags
	return HandJointFlags(Advanced(self).GetHandJointFlags(hand, joint))
}

/*
If handtracking is enabled, returns the rotation of a joint ([param joint]) of a hand ([param hand]) as provided by OpenXR.
*/
func (self Instance) GetHandJointRotation(hand Hand, joint HandJoints) Quaternion.IJKX { //gd:OpenXRInterface.get_hand_joint_rotation
	return Quaternion.IJKX(Advanced(self).GetHandJointRotation(hand, joint))
}

/*
If handtracking is enabled, returns the position of a joint ([param joint]) of a hand ([param hand]) as provided by OpenXR. This is relative to [XROrigin3D] without worldscale applied!
*/
func (self Instance) GetHandJointPosition(hand Hand, joint HandJoints) Vector3.XYZ { //gd:OpenXRInterface.get_hand_joint_position
	return Vector3.XYZ(Advanced(self).GetHandJointPosition(hand, joint))
}

/*
If handtracking is enabled, returns the radius of a joint ([param joint]) of a hand ([param hand]) as provided by OpenXR. This is without worldscale applied!
*/
func (self Instance) GetHandJointRadius(hand Hand, joint HandJoints) Float.X { //gd:OpenXRInterface.get_hand_joint_radius
	return Float.X(Float.X(Advanced(self).GetHandJointRadius(hand, joint)))
}

/*
If handtracking is enabled, returns the linear velocity of a joint ([param joint]) of a hand ([param hand]) as provided by OpenXR. This is relative to [XROrigin3D] without worldscale applied!
*/
func (self Instance) GetHandJointLinearVelocity(hand Hand, joint HandJoints) Vector3.XYZ { //gd:OpenXRInterface.get_hand_joint_linear_velocity
	return Vector3.XYZ(Advanced(self).GetHandJointLinearVelocity(hand, joint))
}

/*
If handtracking is enabled, returns the angular velocity of a joint ([param joint]) of a hand ([param hand]) as provided by OpenXR. This is relative to [XROrigin3D]!
*/
func (self Instance) GetHandJointAngularVelocity(hand Hand, joint HandJoints) Vector3.XYZ { //gd:OpenXRInterface.get_hand_joint_angular_velocity
	return Vector3.XYZ(Advanced(self).GetHandJointAngularVelocity(hand, joint))
}

/*
Returns [code]true[/code] if OpenXR's hand tracking is supported and enabled.
[b]Note:[/b] This only returns a valid value after OpenXR has been initialized.
*/
func (self Instance) IsHandTrackingSupported() bool { //gd:OpenXRInterface.is_hand_tracking_supported
	return bool(Advanced(self).IsHandTrackingSupported())
}

/*
Returns [code]true[/code] if OpenXR's hand interaction profile is supported and enabled.
[b]Note:[/b] This only returns a valid value after OpenXR has been initialized.
*/
func (self Instance) IsHandInteractionSupported() bool { //gd:OpenXRInterface.is_hand_interaction_supported
	return bool(Advanced(self).IsHandInteractionSupported())
}

/*
Returns the capabilities of the eye gaze interaction extension.
[b]Note:[/b] This only returns a valid value after OpenXR has been initialized.
*/
func (self Instance) IsEyeGazeInteractionSupported() bool { //gd:OpenXRInterface.is_eye_gaze_interaction_supported
	return bool(Advanced(self).IsEyeGazeInteractionSupported())
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.OpenXRInterface

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {
	object := [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gdextension.Host.Objects.Make(pointers.Get(gd.NewStringName("OpenXRInterface"))))})}
	casted := Instance{*(*gdclass.OpenXRInterface)(unsafe.Pointer(&object))}
	casted.AsRefCounted()[0].Reference()
	object[0].Notification(0, false)
	return casted
}

func (self Instance) DisplayRefreshRate() Float.X {
	return Float.X(Float.X(class(self).GetDisplayRefreshRate()))
}

func (self Instance) SetDisplayRefreshRate(value Float.X) {
	class(self).SetDisplayRefreshRate(float64(value))
}

func (self Instance) RenderTargetSizeMultiplier() Float.X {
	return Float.X(Float.X(class(self).GetRenderTargetSizeMultiplier()))
}

func (self Instance) SetRenderTargetSizeMultiplier(value Float.X) {
	class(self).SetRenderTargetSizeMultiplier(float64(value))
}

func (self Instance) FoveationLevel() int {
	return int(int(class(self).GetFoveationLevel()))
}

func (self Instance) SetFoveationLevel(value int) {
	class(self).SetFoveationLevel(int64(value))
}

func (self Instance) FoveationDynamic() bool {
	return bool(class(self).GetFoveationDynamic())
}

func (self Instance) SetFoveationDynamic(value bool) {
	class(self).SetFoveationDynamic(value)
}

func (self Instance) VrsMinRadius() Float.X {
	return Float.X(Float.X(class(self).GetVrsMinRadius()))
}

func (self Instance) SetVrsMinRadius(value Float.X) {
	class(self).SetVrsMinRadius(float64(value))
}

func (self Instance) VrsStrength() Float.X {
	return Float.X(Float.X(class(self).GetVrsStrength()))
}

func (self Instance) SetVrsStrength(value Float.X) {
	class(self).SetVrsStrength(float64(value))
}

//go:nosplit
func (self class) GetDisplayRefreshRate() float64 { //gd:OpenXRInterface.get_display_refresh_rate
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRInterface.Bind_get_display_refresh_rate), gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetDisplayRefreshRate(refresh_rate float64) { //gd:OpenXRInterface.set_display_refresh_rate
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRInterface.Bind_set_display_refresh_rate), 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ refresh_rate float64 }{refresh_rate}))
}

//go:nosplit
func (self class) GetRenderTargetSizeMultiplier() float64 { //gd:OpenXRInterface.get_render_target_size_multiplier
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRInterface.Bind_get_render_target_size_multiplier), gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetRenderTargetSizeMultiplier(multiplier float64) { //gd:OpenXRInterface.set_render_target_size_multiplier
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRInterface.Bind_set_render_target_size_multiplier), 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ multiplier float64 }{multiplier}))
}

/*
Returns [code]true[/code] if OpenXR's foveation extension is supported, the interface must be initialized before this returns a valid value.
[b]Note:[/b] This feature is only available on the compatibility renderer and currently only available on some stand alone headsets. For Vulkan set [member Viewport.vrs_mode] to [code]VRS_XR[/code] on desktop.
*/
//go:nosplit
func (self class) IsFoveationSupported() bool { //gd:OpenXRInterface.is_foveation_supported
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRInterface.Bind_is_foveation_supported), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) GetFoveationLevel() int64 { //gd:OpenXRInterface.get_foveation_level
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRInterface.Bind_get_foveation_level), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetFoveationLevel(foveation_level int64) { //gd:OpenXRInterface.set_foveation_level
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRInterface.Bind_set_foveation_level), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ foveation_level int64 }{foveation_level}))
}

//go:nosplit
func (self class) GetFoveationDynamic() bool { //gd:OpenXRInterface.get_foveation_dynamic
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRInterface.Bind_get_foveation_dynamic), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetFoveationDynamic(foveation_dynamic bool) { //gd:OpenXRInterface.set_foveation_dynamic
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRInterface.Bind_set_foveation_dynamic), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ foveation_dynamic bool }{foveation_dynamic}))
}

/*
Returns [code]true[/code] if the given action set is active.
*/
//go:nosplit
func (self class) IsActionSetActive(name String.Readable) bool { //gd:OpenXRInterface.is_action_set_active
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRInterface.Bind_is_action_set_active), gdextension.SizeBool|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ name gdextension.String }{pointers.Get(gd.InternalString(name))}))
	var ret = r_ret
	return ret
}

/*
Sets the given action set as active or inactive.
*/
//go:nosplit
func (self class) SetActionSetActive(name String.Readable, active bool) { //gd:OpenXRInterface.set_action_set_active
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRInterface.Bind_set_action_set_active), 0|(gdextension.SizeString<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		name   gdextension.String
		active bool
	}{pointers.Get(gd.InternalString(name)), active}))
}

/*
Returns a list of action sets registered with Godot (loaded from the action map at runtime).
*/
//go:nosplit
func (self class) GetActionSets() Array.Any { //gd:OpenXRInterface.get_action_sets
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRInterface.Bind_get_action_sets), gdextension.SizeArray, unsafe.Pointer(&struct{}{}))
	var ret = Array.Through(gd.ArrayProxy[variant.Any]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

/*
Returns display refresh rates supported by the current HMD. Only returned if this feature is supported by the OpenXR runtime and after the interface has been initialized.
*/
//go:nosplit
func (self class) GetAvailableDisplayRefreshRates() Array.Any { //gd:OpenXRInterface.get_available_display_refresh_rates
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRInterface.Bind_get_available_display_refresh_rates), gdextension.SizeArray, unsafe.Pointer(&struct{}{}))
	var ret = Array.Through(gd.ArrayProxy[variant.Any]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

/*
If handtracking is enabled and motion range is supported, sets the currently configured motion range for [param hand] to [param motion_range].
*/
//go:nosplit
func (self class) SetMotionRange(hand Hand, motion_range HandMotionRange) { //gd:OpenXRInterface.set_motion_range
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRInterface.Bind_set_motion_range), 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		hand         Hand
		motion_range HandMotionRange
	}{hand, motion_range}))
}

/*
If handtracking is enabled and motion range is supported, gets the currently configured motion range for [param hand].
*/
//go:nosplit
func (self class) GetMotionRange(hand Hand) HandMotionRange { //gd:OpenXRInterface.get_motion_range
	var r_ret = gdextension.Call[HandMotionRange](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRInterface.Bind_get_motion_range), gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ hand Hand }{hand}))
	var ret = r_ret
	return ret
}

/*
If handtracking is enabled and hand tracking source is supported, gets the source of the hand tracking data for [param hand].
*/
//go:nosplit
func (self class) GetHandTrackingSource(hand Hand) HandTrackedSource { //gd:OpenXRInterface.get_hand_tracking_source
	var r_ret = gdextension.Call[HandTrackedSource](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRInterface.Bind_get_hand_tracking_source), gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ hand Hand }{hand}))
	var ret = r_ret
	return ret
}

/*
If handtracking is enabled, returns flags that inform us of the validity of the tracking data.
*/
//go:nosplit
func (self class) GetHandJointFlags(hand Hand, joint HandJoints) HandJointFlags { //gd:OpenXRInterface.get_hand_joint_flags
	var r_ret = gdextension.Call[HandJointFlags](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRInterface.Bind_get_hand_joint_flags), gdextension.SizeInt|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		hand  Hand
		joint HandJoints
	}{hand, joint}))
	var ret = r_ret
	return ret
}

/*
If handtracking is enabled, returns the rotation of a joint ([param joint]) of a hand ([param hand]) as provided by OpenXR.
*/
//go:nosplit
func (self class) GetHandJointRotation(hand Hand, joint HandJoints) Quaternion.IJKX { //gd:OpenXRInterface.get_hand_joint_rotation
	var r_ret = gdextension.Call[Quaternion.IJKX](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRInterface.Bind_get_hand_joint_rotation), gdextension.SizeQuaternion|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		hand  Hand
		joint HandJoints
	}{hand, joint}))
	var ret = r_ret
	return ret
}

/*
If handtracking is enabled, returns the position of a joint ([param joint]) of a hand ([param hand]) as provided by OpenXR. This is relative to [XROrigin3D] without worldscale applied!
*/
//go:nosplit
func (self class) GetHandJointPosition(hand Hand, joint HandJoints) Vector3.XYZ { //gd:OpenXRInterface.get_hand_joint_position
	var r_ret = gdextension.Call[Vector3.XYZ](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRInterface.Bind_get_hand_joint_position), gdextension.SizeVector3|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		hand  Hand
		joint HandJoints
	}{hand, joint}))
	var ret = r_ret
	return ret
}

/*
If handtracking is enabled, returns the radius of a joint ([param joint]) of a hand ([param hand]) as provided by OpenXR. This is without worldscale applied!
*/
//go:nosplit
func (self class) GetHandJointRadius(hand Hand, joint HandJoints) float64 { //gd:OpenXRInterface.get_hand_joint_radius
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRInterface.Bind_get_hand_joint_radius), gdextension.SizeFloat|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		hand  Hand
		joint HandJoints
	}{hand, joint}))
	var ret = r_ret
	return ret
}

/*
If handtracking is enabled, returns the linear velocity of a joint ([param joint]) of a hand ([param hand]) as provided by OpenXR. This is relative to [XROrigin3D] without worldscale applied!
*/
//go:nosplit
func (self class) GetHandJointLinearVelocity(hand Hand, joint HandJoints) Vector3.XYZ { //gd:OpenXRInterface.get_hand_joint_linear_velocity
	var r_ret = gdextension.Call[Vector3.XYZ](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRInterface.Bind_get_hand_joint_linear_velocity), gdextension.SizeVector3|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		hand  Hand
		joint HandJoints
	}{hand, joint}))
	var ret = r_ret
	return ret
}

/*
If handtracking is enabled, returns the angular velocity of a joint ([param joint]) of a hand ([param hand]) as provided by OpenXR. This is relative to [XROrigin3D]!
*/
//go:nosplit
func (self class) GetHandJointAngularVelocity(hand Hand, joint HandJoints) Vector3.XYZ { //gd:OpenXRInterface.get_hand_joint_angular_velocity
	var r_ret = gdextension.Call[Vector3.XYZ](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRInterface.Bind_get_hand_joint_angular_velocity), gdextension.SizeVector3|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		hand  Hand
		joint HandJoints
	}{hand, joint}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if OpenXR's hand tracking is supported and enabled.
[b]Note:[/b] This only returns a valid value after OpenXR has been initialized.
*/
//go:nosplit
func (self class) IsHandTrackingSupported() bool { //gd:OpenXRInterface.is_hand_tracking_supported
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRInterface.Bind_is_hand_tracking_supported), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if OpenXR's hand interaction profile is supported and enabled.
[b]Note:[/b] This only returns a valid value after OpenXR has been initialized.
*/
//go:nosplit
func (self class) IsHandInteractionSupported() bool { //gd:OpenXRInterface.is_hand_interaction_supported
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRInterface.Bind_is_hand_interaction_supported), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the capabilities of the eye gaze interaction extension.
[b]Note:[/b] This only returns a valid value after OpenXR has been initialized.
*/
//go:nosplit
func (self class) IsEyeGazeInteractionSupported() bool { //gd:OpenXRInterface.is_eye_gaze_interaction_supported
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRInterface.Bind_is_eye_gaze_interaction_supported), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) GetVrsMinRadius() float64 { //gd:OpenXRInterface.get_vrs_min_radius
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRInterface.Bind_get_vrs_min_radius), gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetVrsMinRadius(radius float64) { //gd:OpenXRInterface.set_vrs_min_radius
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRInterface.Bind_set_vrs_min_radius), 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ radius float64 }{radius}))
}

//go:nosplit
func (self class) GetVrsStrength() float64 { //gd:OpenXRInterface.get_vrs_strength
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRInterface.Bind_get_vrs_strength), gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetVrsStrength(strength float64) { //gd:OpenXRInterface.set_vrs_strength
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRInterface.Bind_set_vrs_strength), 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ strength float64 }{strength}))
}
func (self Instance) OnSessionBegun(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("session_begun"), gd.NewCallable(cb), 0)
}

func (self Instance) OnSessionStopping(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("session_stopping"), gd.NewCallable(cb), 0)
}

func (self Instance) OnSessionFocussed(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("session_focussed"), gd.NewCallable(cb), 0)
}

func (self Instance) OnSessionVisible(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("session_visible"), gd.NewCallable(cb), 0)
}

func (self Instance) OnSessionLossPending(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("session_loss_pending"), gd.NewCallable(cb), 0)
}

func (self Instance) OnInstanceExiting(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("instance_exiting"), gd.NewCallable(cb), 0)
}

func (self Instance) OnPoseRecentered(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("pose_recentered"), gd.NewCallable(cb), 0)
}

func (self Instance) OnRefreshRateChanged(cb func(refresh_rate Float.X)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("refresh_rate_changed"), gd.NewCallable(cb), 0)
}

func (self class) AsOpenXRInterface() Advanced         { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsOpenXRInterface() Instance      { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsOpenXRInterface() Instance { return self.Super().AsOpenXRInterface() }
func (self class) AsXRInterface() XRInterface.Advanced {
	return *((*XRInterface.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsXRInterface() XRInterface.Instance { return self.Super().AsXRInterface() }
func (self Instance) AsXRInterface() XRInterface.Instance {
	return *((*XRInterface.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsRefCounted() [1]gd.RefCounted { return self.Super().AsRefCounted() }
func (self Instance) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(XRInterface.Advanced(self.AsXRInterface()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(XRInterface.Instance(self.AsXRInterface()), name)
	}
}
func init() {
	gdclass.Register("OpenXRInterface", func(ptr gd.Object) any {
		return [1]gdclass.OpenXRInterface{*(*gdclass.OpenXRInterface)(unsafe.Pointer(&ptr))}
	})
}

type Hand int //gd:OpenXRInterface.Hand

const (
	/*Left hand.*/
	HandLeft Hand = 0
	/*Right hand.*/
	HandRight Hand = 1
	/*Maximum value for the hand enum.*/
	HandMax Hand = 2
)

type HandMotionRange int //gd:OpenXRInterface.HandMotionRange

const (
	/*Full hand range, if user closes their hands, we make a full fist.*/
	HandMotionRangeUnobstructed HandMotionRange = 0
	/*Conform to controller, if user closes their hands, the tracked data conforms to the shape of the controller.*/
	HandMotionRangeConformToController HandMotionRange = 1
	/*Maximum value for the motion range enum.*/
	HandMotionRangeMax HandMotionRange = 2
)

type HandTrackedSource int //gd:OpenXRInterface.HandTrackedSource

const (
	/*The source of hand tracking data is unknown (the extension is likely unsupported).*/
	HandTrackedSourceUnknown HandTrackedSource = 0
	/*The source of hand tracking is unobstructed, this means that an accurate method of hand tracking is used, e.g. optical hand tracking, data gloves, etc.*/
	HandTrackedSourceUnobstructed HandTrackedSource = 1
	/*The source of hand tracking is a controller, bone positions are inferred from controller inputs.*/
	HandTrackedSourceController HandTrackedSource = 2
	/*Maximum value for the hand tracked source enum.*/
	HandTrackedSourceMax HandTrackedSource = 3
)

type HandJoints int //gd:OpenXRInterface.HandJoints

const (
	/*Palm joint.*/
	HandJointPalm HandJoints = 0
	/*Wrist joint.*/
	HandJointWrist HandJoints = 1
	/*Thumb metacarpal joint.*/
	HandJointThumbMetacarpal HandJoints = 2
	/*Thumb proximal joint.*/
	HandJointThumbProximal HandJoints = 3
	/*Thumb distal joint.*/
	HandJointThumbDistal HandJoints = 4
	/*Thumb tip joint.*/
	HandJointThumbTip HandJoints = 5
	/*Index metacarpal joint.*/
	HandJointIndexMetacarpal HandJoints = 6
	/*Index proximal joint.*/
	HandJointIndexProximal HandJoints = 7
	/*Index intermediate joint.*/
	HandJointIndexIntermediate HandJoints = 8
	/*Index distal joint.*/
	HandJointIndexDistal HandJoints = 9
	/*Index tip joint.*/
	HandJointIndexTip HandJoints = 10
	/*Middle metacarpal joint.*/
	HandJointMiddleMetacarpal HandJoints = 11
	/*Middle proximal joint.*/
	HandJointMiddleProximal HandJoints = 12
	/*Middle intermediate joint.*/
	HandJointMiddleIntermediate HandJoints = 13
	/*Middle distal joint.*/
	HandJointMiddleDistal HandJoints = 14
	/*Middle tip joint.*/
	HandJointMiddleTip HandJoints = 15
	/*Ring metacarpal joint.*/
	HandJointRingMetacarpal HandJoints = 16
	/*Ring proximal joint.*/
	HandJointRingProximal HandJoints = 17
	/*Ring intermediate joint.*/
	HandJointRingIntermediate HandJoints = 18
	/*Ring distal joint.*/
	HandJointRingDistal HandJoints = 19
	/*Ring tip joint.*/
	HandJointRingTip HandJoints = 20
	/*Little metacarpal joint.*/
	HandJointLittleMetacarpal HandJoints = 21
	/*Little proximal joint.*/
	HandJointLittleProximal HandJoints = 22
	/*Little intermediate joint.*/
	HandJointLittleIntermediate HandJoints = 23
	/*Little distal joint.*/
	HandJointLittleDistal HandJoints = 24
	/*Little tip joint.*/
	HandJointLittleTip HandJoints = 25
	/*Maximum value for the hand joint enum.*/
	HandJointMax HandJoints = 26
)

type HandJointFlags int //gd:OpenXRInterface.HandJointFlags

const (
	/*No flags are set.*/
	HandJointNone HandJointFlags = 0
	/*If set, the orientation data is valid, otherwise, the orientation data is unreliable and should not be used.*/
	HandJointOrientationValid HandJointFlags = 1
	/*If set, the orientation data comes from tracking data, otherwise, the orientation data contains predicted data.*/
	HandJointOrientationTracked HandJointFlags = 2
	/*If set, the positional data is valid, otherwise, the positional data is unreliable and should not be used.*/
	HandJointPositionValid HandJointFlags = 4
	/*If set, the positional data comes from tracking data, otherwise, the positional data contains predicted data.*/
	HandJointPositionTracked HandJointFlags = 8
	/*If set, our linear velocity data is valid, otherwise, the linear velocity data is unreliable and should not be used.*/
	HandJointLinearVelocityValid HandJointFlags = 16
	/*If set, our angular velocity data is valid, otherwise, the angular velocity data is unreliable and should not be used.*/
	HandJointAngularVelocityValid HandJointFlags = 32
)
