// Code generated by the generate package DO NOT EDIT

// Package SceneTree provides methods for working with SceneTree object instances.
package SceneTree

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/MainLoop"
import "graphics.gd/classdb/MultiplayerAPI"
import "graphics.gd/classdb/Node"
import "graphics.gd/classdb/PackedScene"
import "graphics.gd/classdb/SceneTreeTimer"
import "graphics.gd/classdb/Tween"
import "graphics.gd/classdb/Window"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
As one of the most important classes, the [SceneTree] manages the hierarchy of nodes in a scene, as well as scenes themselves. Nodes can be added, fetched and removed. The whole scene tree (and thus the current scene) can be paused. Scenes can be loaded, switched and reloaded.
You can also use the [SceneTree] to organize your nodes into [b]groups[/b]: every node can be added to as many groups as you want to create, e.g. an "enemy" group. You can then iterate these groups or even call methods and set properties on all the nodes belonging to any given group.
[SceneTree] is the default [MainLoop] implementation used by the engine, and is thus in charge of the game loop.
*/
type Instance [1]gdclass.SceneTree

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	get_root                          gdextension.MethodForClass `hash:"1757182445"`
	has_group                         gdextension.MethodForClass `hash:"2619796661"`
	is_auto_accept_quit               gdextension.MethodForClass `hash:"36873697"`
	set_auto_accept_quit              gdextension.MethodForClass `hash:"2586408642"`
	is_quit_on_go_back                gdextension.MethodForClass `hash:"36873697"`
	set_quit_on_go_back               gdextension.MethodForClass `hash:"2586408642"`
	set_debug_collisions_hint         gdextension.MethodForClass `hash:"2586408642"`
	is_debugging_collisions_hint      gdextension.MethodForClass `hash:"36873697"`
	set_debug_paths_hint              gdextension.MethodForClass `hash:"2586408642"`
	is_debugging_paths_hint           gdextension.MethodForClass `hash:"36873697"`
	set_debug_navigation_hint         gdextension.MethodForClass `hash:"2586408642"`
	is_debugging_navigation_hint      gdextension.MethodForClass `hash:"36873697"`
	set_edited_scene_root             gdextension.MethodForClass `hash:"1078189570"`
	get_edited_scene_root             gdextension.MethodForClass `hash:"3160264692"`
	set_pause                         gdextension.MethodForClass `hash:"2586408642"`
	is_paused                         gdextension.MethodForClass `hash:"36873697"`
	create_timer                      gdextension.MethodForClass `hash:"2709170273"`
	create_tween                      gdextension.MethodForClass `hash:"3426978995"`
	get_processed_tweens              gdextension.MethodForClass `hash:"2915620761"`
	get_node_count                    gdextension.MethodForClass `hash:"3905245786"`
	get_frame                         gdextension.MethodForClass `hash:"3905245786"`
	quit                              gdextension.MethodForClass `hash:"1995695955"`
	set_physics_interpolation_enabled gdextension.MethodForClass `hash:"2586408642"`
	is_physics_interpolation_enabled  gdextension.MethodForClass `hash:"36873697"`
	queue_delete                      gdextension.MethodForClass `hash:"3975164845"`
	call_group_flags                  gdextension.MethodForClass `hash:"1527739229"`
	notify_group_flags                gdextension.MethodForClass `hash:"1245489420"`
	set_group_flags                   gdextension.MethodForClass `hash:"3497599527"`
	call_group                        gdextension.MethodForClass `hash:"1257962832"`
	notify_group                      gdextension.MethodForClass `hash:"2415702435"`
	set_group                         gdextension.MethodForClass `hash:"1279312029"`
	get_nodes_in_group                gdextension.MethodForClass `hash:"689397652"`
	get_first_node_in_group           gdextension.MethodForClass `hash:"4071044623"`
	get_node_count_in_group           gdextension.MethodForClass `hash:"2458036349"`
	set_current_scene                 gdextension.MethodForClass `hash:"1078189570"`
	get_current_scene                 gdextension.MethodForClass `hash:"3160264692"`
	change_scene_to_file              gdextension.MethodForClass `hash:"166001499"`
	change_scene_to_packed            gdextension.MethodForClass `hash:"107349098"`
	reload_current_scene              gdextension.MethodForClass `hash:"166280745"`
	unload_current_scene              gdextension.MethodForClass `hash:"3218959716"`
	set_multiplayer                   gdextension.MethodForClass `hash:"2385607013"`
	get_multiplayer                   gdextension.MethodForClass `hash:"3453401404"`
	set_multiplayer_poll_enabled      gdextension.MethodForClass `hash:"2586408642"`
	is_multiplayer_poll_enabled       gdextension.MethodForClass `hash:"36873697"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("SceneTree")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		pointers.Raw[gd.StringName](sname).Free()
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

type Expanded [1]gdclass.SceneTree

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsSceneTree() Instance
}

/*
Returns [code]true[/code] if a node added to the given group [param name] exists in the tree.
*/
func (self Instance) HasGroup(name string) bool { //gd:SceneTree.has_group
	return bool(Advanced(self).HasGroup(String.Name(String.New(name))))
}

/*
Returns a new [SceneTreeTimer]. After [param time_sec] in seconds have passed, the timer will emit [signal SceneTreeTimer.timeout] and will be automatically freed.
If [param process_always] is [code]false[/code], the timer will be paused when setting [member SceneTree.paused] to [code]true[/code].
If [param process_in_physics] is [code]true[/code], the timer will update at the end of the physics frame, instead of the process frame.
If [param ignore_time_scale] is [code]true[/code], the timer will ignore [member Engine.time_scale] and update with the real, elapsed time.
This method is commonly used to create a one-shot delay timer, as in the following example:
[codeblocks]
[gdscript]
func some_function():

	print("start")
	await get_tree().create_timer(1.0).timeout
	print("end")

[/gdscript]
[csharp]
public async Task SomeFunction()

	{
	    GD.Print("start");
	    await ToSignal(GetTree().CreateTimer(1.0f), SceneTreeTimer.SignalName.Timeout);
	    GD.Print("end");
	}

[/csharp]
[/codeblocks]
[b]Note:[/b] The timer is always updated [i]after[/i] all of the nodes in the tree. A node's [method Node._process] method would be called before the timer updates (or [method Node._physics_process] if [param process_in_physics] is set to [code]true[/code]).
*/
func (self Instance) CreateTimer(time_sec Float.X) SceneTreeTimer.Instance { //gd:SceneTree.create_timer
	return SceneTreeTimer.Instance(Advanced(self).CreateTimer(float64(time_sec), true, false, false))
}

/*
Returns a new [SceneTreeTimer]. After [param time_sec] in seconds have passed, the timer will emit [signal SceneTreeTimer.timeout] and will be automatically freed.
If [param process_always] is [code]false[/code], the timer will be paused when setting [member SceneTree.paused] to [code]true[/code].
If [param process_in_physics] is [code]true[/code], the timer will update at the end of the physics frame, instead of the process frame.
If [param ignore_time_scale] is [code]true[/code], the timer will ignore [member Engine.time_scale] and update with the real, elapsed time.
This method is commonly used to create a one-shot delay timer, as in the following example:
[codeblocks]
[gdscript]
func some_function():

	print("start")
	await get_tree().create_timer(1.0).timeout
	print("end")

[/gdscript]
[csharp]
public async Task SomeFunction()

	{
	    GD.Print("start");
	    await ToSignal(GetTree().CreateTimer(1.0f), SceneTreeTimer.SignalName.Timeout);
	    GD.Print("end");
	}

[/csharp]
[/codeblocks]
[b]Note:[/b] The timer is always updated [i]after[/i] all of the nodes in the tree. A node's [method Node._process] method would be called before the timer updates (or [method Node._physics_process] if [param process_in_physics] is set to [code]true[/code]).
*/
func (self Expanded) CreateTimer(time_sec Float.X, process_always bool, process_in_physics bool, ignore_time_scale bool) SceneTreeTimer.Instance { //gd:SceneTree.create_timer
	return SceneTreeTimer.Instance(Advanced(self).CreateTimer(float64(time_sec), process_always, process_in_physics, ignore_time_scale))
}

/*
Creates and returns a new [Tween] processed in this tree. The Tween will start automatically on the next process frame or physics frame (depending on its [enum Tween.TweenProcessMode]).
[b]Note:[/b] A [Tween] created using this method is not bound to any [Node]. It may keep working until there is nothing left to animate. If you want the [Tween] to be automatically killed when the [Node] is freed, use [method Node.create_tween] or [method Tween.bind_node].
*/
func (self Instance) CreateTween() Tween.Instance { //gd:SceneTree.create_tween
	return Tween.Instance(Advanced(self).CreateTween())
}

/*
Returns an [Array] of currently existing [Tween]s in the tree, including paused tweens.
*/
func (self Instance) GetProcessedTweens() []Tween.Instance { //gd:SceneTree.get_processed_tweens
	return []Tween.Instance(gd.ArrayAs[[]Tween.Instance](gd.InternalArray(Advanced(self).GetProcessedTweens())))
}

/*
Returns the number of nodes inside this tree.
*/
func (self Instance) GetNodeCount() int { //gd:SceneTree.get_node_count
	return int(int(Advanced(self).GetNodeCount()))
}

/*
Returns how many frames have been processed, since the application started. This is [i]not[/i] a measurement of elapsed time.
*/
func (self Instance) GetFrame() int { //gd:SceneTree.get_frame
	return int(int(Advanced(self).GetFrame()))
}

/*
Quits the application at the end of the current iteration, with the given [param exit_code].
By convention, an exit code of [code]0[/code] indicates success, whereas any other exit code indicates an error. For portability reasons, it should be between [code]0[/code] and [code]125[/code] (inclusive).
[b]Note:[/b] On iOS this method doesn't work. Instead, as recommended by the [url=https://developer.apple.com/library/archive/qa/qa1561/_index.html]iOS Human Interface Guidelines[/url], the user is expected to close apps via the Home button.
*/
func (self Instance) Quit() { //gd:SceneTree.quit
	Advanced(self).Quit(int64(0))
}

/*
Quits the application at the end of the current iteration, with the given [param exit_code].
By convention, an exit code of [code]0[/code] indicates success, whereas any other exit code indicates an error. For portability reasons, it should be between [code]0[/code] and [code]125[/code] (inclusive).
[b]Note:[/b] On iOS this method doesn't work. Instead, as recommended by the [url=https://developer.apple.com/library/archive/qa/qa1561/_index.html]iOS Human Interface Guidelines[/url], the user is expected to close apps via the Home button.
*/
func (self Expanded) Quit(exit_code int) { //gd:SceneTree.quit
	Advanced(self).Quit(int64(exit_code))
}

/*
Queues the given [param obj] to be deleted, calling its [method Object.free] at the end of the current frame. This method is similar to [method Node.queue_free].
*/
func (self Instance) QueueDelete(obj Object.Instance) { //gd:SceneTree.queue_delete
	Advanced(self).QueueDelete(obj)
}

/*
Calls the given [param method] on each node inside this tree added to the given [param group]. Use [param flags] to customize this method's behavior (see [enum GroupCallFlags]). Additional arguments for [param method] can be passed at the end of this method. Nodes that cannot call [param method] (either because the method doesn't exist or the arguments do not match) are ignored.
[codeblock]
# Calls "hide" to all nodes of the "enemies" group, at the end of the frame and in reverse tree order.
get_tree().call_group_flags(

	SceneTree.GROUP_CALL_DEFERRED | SceneTree.GROUP_CALL_REVERSE,
	"enemies", "hide")

[/codeblock]
[b]Note:[/b] In C#, [param method] must be in snake_case when referring to built-in Godot methods. Prefer using the names exposed in the [code]MethodName[/code] class to avoid allocating a new [StringName] on each call.
*/
func (self Instance) CallGroupFlags(flags int, group string, method string, args ...any) { //gd:SceneTree.call_group_flags
	var converted_variants = make([]gd.Variant, len(args))
	for i, arg := range args {
		converted_variants[i] = gd.NewVariant(arg)
	}
	Advanced(self).CallGroupFlags(int64(flags), String.Name(String.New(group)), String.Name(String.New(method)), converted_variants...)
}

/*
Calls [method Object.notification] with the given [param notification] to all nodes inside this tree added to the [param group]. Use [param call_flags] to customize this method's behavior (see [enum GroupCallFlags]).
*/
func (self Instance) NotifyGroupFlags(call_flags int, group string, notification int) { //gd:SceneTree.notify_group_flags
	Advanced(self).NotifyGroupFlags(int64(call_flags), String.Name(String.New(group)), int64(notification))
}

/*
Sets the given [param property] to [param value] on all nodes inside this tree added to the given [param group]. Nodes that do not have the [param property] are ignored. Use [param call_flags] to customize this method's behavior (see [enum GroupCallFlags]).
[b]Note:[/b] In C#, [param property] must be in snake_case when referring to built-in Godot properties. Prefer using the names exposed in the [code]PropertyName[/code] class to avoid allocating a new [StringName] on each call.
*/
func (self Instance) SetGroupFlags(call_flags int, group string, property string, value any) { //gd:SceneTree.set_group_flags
	Advanced(self).SetGroupFlags(int64(call_flags), String.Name(String.New(group)), String.New(property), variant.New(value))
}

/*
Calls [param method] on each node inside this tree added to the given [param group]. You can pass arguments to [param method] by specifying them at the end of this method call. Nodes that cannot call [param method] (either because the method doesn't exist or the arguments do not match) are ignored. See also [method set_group] and [method notify_group].
[b]Note:[/b] This method acts immediately on all selected nodes at once, which may cause stuttering in some performance-intensive situations.
[b]Note:[/b] In C#, [param method] must be in snake_case when referring to built-in Godot methods. Prefer using the names exposed in the [code]MethodName[/code] class to avoid allocating a new [StringName] on each call.
*/
func (self Instance) CallGroup(group string, method string, args ...any) { //gd:SceneTree.call_group
	var converted_variants = make([]gd.Variant, len(args))
	for i, arg := range args {
		converted_variants[i] = gd.NewVariant(arg)
	}
	Advanced(self).CallGroup(String.Name(String.New(group)), String.Name(String.New(method)), converted_variants...)
}

/*
Calls [method Object.notification] with the given [param notification] to all nodes inside this tree added to the [param group]. See also [url=$DOCS_URL/tutorials/best_practices/godot_notifications.html]Godot notifications[/url] and [method call_group] and [method set_group].
[b]Note:[/b] This method acts immediately on all selected nodes at once, which may cause stuttering in some performance-intensive situations.
*/
func (self Instance) NotifyGroup(group string, notification int) { //gd:SceneTree.notify_group
	Advanced(self).NotifyGroup(String.Name(String.New(group)), int64(notification))
}

/*
Sets the given [param property] to [param value] on all nodes inside this tree added to the given [param group]. Nodes that do not have the [param property] are ignored. See also [method call_group] and [method notify_group].
[b]Note:[/b] This method acts immediately on all selected nodes at once, which may cause stuttering in some performance-intensive situations.
[b]Note:[/b] In C#, [param property] must be in snake_case when referring to built-in Godot properties. Prefer using the names exposed in the [code]PropertyName[/code] class to avoid allocating a new [StringName] on each call.
*/
func (self Instance) SetGroup(group string, property string, value any) { //gd:SceneTree.set_group
	Advanced(self).SetGroup(String.Name(String.New(group)), String.New(property), variant.New(value))
}

/*
Returns an [Array] containing all nodes inside this tree, that have been added to the given [param group], in scene hierarchy order.
*/
func (self Instance) GetNodesInGroup(group string) []Node.Instance { //gd:SceneTree.get_nodes_in_group
	return []Node.Instance(gd.ArrayAs[[]Node.Instance](gd.InternalArray(Advanced(self).GetNodesInGroup(String.Name(String.New(group))))))
}

/*
Returns the first [Node] found inside the tree, that has been added to the given [param group], in scene hierarchy order. Returns [code]null[/code] if no match is found. See also [method get_nodes_in_group].
*/
func (self Instance) GetFirstNodeInGroup(group string) Node.Instance { //gd:SceneTree.get_first_node_in_group
	return Node.Instance(Advanced(self).GetFirstNodeInGroup(String.Name(String.New(group))))
}

/*
Returns the number of nodes assigned to the given group.
*/
func (self Instance) GetNodeCountInGroup(group string) int { //gd:SceneTree.get_node_count_in_group
	return int(int(Advanced(self).GetNodeCountInGroup(String.Name(String.New(group)))))
}

/*
Changes the running scene to the one at the given [param path], after loading it into a [PackedScene] and creating a new instance.
Returns [constant OK] on success, [constant ERR_CANT_OPEN] if the [param path] cannot be loaded into a [PackedScene], or [constant ERR_CANT_CREATE] if that scene cannot be instantiated.
[b]Note:[/b] See [method change_scene_to_packed] for details on the order of operations.
*/
func (self Instance) ChangeSceneToFile(path string) error { //gd:SceneTree.change_scene_to_file
	return error(gd.ToError(Advanced(self).ChangeSceneToFile(String.New(path))))
}

/*
Changes the running scene to a new instance of the given [PackedScene] (which must be valid).
Returns [constant OK] on success, [constant ERR_CANT_CREATE] if the scene cannot be instantiated, or [constant ERR_INVALID_PARAMETER] if the scene is invalid.
[b]Note:[/b] Operations happen in the following order when [method change_scene_to_packed] is called:
1. The current scene node is immediately removed from the tree. From that point, [method Node.get_tree] called on the current (outgoing) scene will return [code]null[/code]. [member current_scene] will be [code]null[/code], too, because the new scene is not available yet.
2. At the end of the frame, the formerly current scene, already removed from the tree, will be deleted (freed from memory) and then the new scene will be instantiated and added to the tree. [method Node.get_tree] and [member current_scene] will be back to working as usual.
This ensures that both scenes aren't running at the same time, while still freeing the previous scene in a safe way similar to [method Node.queue_free].
*/
func (self Instance) ChangeSceneToPacked(packed_scene PackedScene.Instance) error { //gd:SceneTree.change_scene_to_packed
	return error(gd.ToError(Advanced(self).ChangeSceneToPacked(packed_scene)))
}

/*
Reloads the currently active scene, replacing [member current_scene] with a new instance of its original [PackedScene].
Returns [constant OK] on success, [constant ERR_UNCONFIGURED] if no [member current_scene] is defined, [constant ERR_CANT_OPEN] if [member current_scene] cannot be loaded into a [PackedScene], or [constant ERR_CANT_CREATE] if the scene cannot be instantiated.
*/
func (self Instance) ReloadCurrentScene() error { //gd:SceneTree.reload_current_scene
	return error(gd.ToError(Advanced(self).ReloadCurrentScene()))
}

/*
If a current scene is loaded, calling this method will unload it.
*/
func (self Instance) UnloadCurrentScene() { //gd:SceneTree.unload_current_scene
	Advanced(self).UnloadCurrentScene()
}

/*
Sets a custom [MultiplayerAPI] with the given [param root_path] (controlling also the relative subpaths), or override the default one if [param root_path] is empty.
[b]Note:[/b] No [MultiplayerAPI] must be configured for the subpath containing [param root_path], nested custom multiplayers are not allowed. I.e. if one is configured for [code]"/root/Foo"[/code] setting one for [code]"/root/Foo/Bar"[/code] will cause an error.
*/
func (self Instance) SetMultiplayer(multiplayer MultiplayerAPI.Instance) { //gd:SceneTree.set_multiplayer
	Advanced(self).SetMultiplayer(multiplayer, Path.ToNode(String.New("")))
}

/*
Sets a custom [MultiplayerAPI] with the given [param root_path] (controlling also the relative subpaths), or override the default one if [param root_path] is empty.
[b]Note:[/b] No [MultiplayerAPI] must be configured for the subpath containing [param root_path], nested custom multiplayers are not allowed. I.e. if one is configured for [code]"/root/Foo"[/code] setting one for [code]"/root/Foo/Bar"[/code] will cause an error.
*/
func (self Expanded) SetMultiplayer(multiplayer MultiplayerAPI.Instance, root_path string) { //gd:SceneTree.set_multiplayer
	Advanced(self).SetMultiplayer(multiplayer, Path.ToNode(String.New(root_path)))
}

/*
Searches for the [MultiplayerAPI] configured for the given path, if one does not exist it searches the parent paths until one is found. If the path is empty, or none is found, the default one is returned. See [method set_multiplayer].
*/
func (self Instance) GetMultiplayer() MultiplayerAPI.Instance { //gd:SceneTree.get_multiplayer
	return MultiplayerAPI.Instance(Advanced(self).GetMultiplayer(Path.ToNode(String.New(""))))
}

/*
Searches for the [MultiplayerAPI] configured for the given path, if one does not exist it searches the parent paths until one is found. If the path is empty, or none is found, the default one is returned. See [method set_multiplayer].
*/
func (self Expanded) GetMultiplayer(for_path string) MultiplayerAPI.Instance { //gd:SceneTree.get_multiplayer
	return MultiplayerAPI.Instance(Advanced(self).GetMultiplayer(Path.ToNode(String.New(for_path))))
}

/*
Returns the [SceneTree] that contains this node. If this node is not inside the tree, generates an error and returns [code]null[/code]. See also [method is_inside_tree].
*/
func Get(peer Node.Instance) Instance { //gd:Node.get_tree
	return Instance(Node.Advanced(peer).GetTree())
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.SceneTree

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.SceneTree)(unsafe.Pointer(&obj))
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.SceneTree)(unsafe.Pointer(&obj))
		return true
	}
	return false
}

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {

	if !gd.Linked {
		var placeholder Instance
		*(*gd.Object)(unsafe.Pointer(&placeholder)) = pointers.Add[gd.Object]([3]uint64{})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(*(*gd.Object)(unsafe.Pointer(&placeholder)), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	object := [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})}
	casted := Instance{*(*gdclass.SceneTree)(unsafe.Pointer(&object))}
	object[0].Notification(0, false)
	return casted
}

func (self Instance) AutoAcceptQuit() bool {
	return bool(class(self).IsAutoAcceptQuit())
}

func (self Instance) SetAutoAcceptQuit(value bool) {
	class(self).SetAutoAcceptQuit(value)
}

func (self Instance) QuitOnGoBack() bool {
	return bool(class(self).IsQuitOnGoBack())
}

func (self Instance) SetQuitOnGoBack(value bool) {
	class(self).SetQuitOnGoBack(value)
}

func (self Instance) DebugCollisionsHint() bool {
	return bool(class(self).IsDebuggingCollisionsHint())
}

func (self Instance) SetDebugCollisionsHint(value bool) {
	class(self).SetDebugCollisionsHint(value)
}

func (self Instance) DebugPathsHint() bool {
	return bool(class(self).IsDebuggingPathsHint())
}

func (self Instance) SetDebugPathsHint(value bool) {
	class(self).SetDebugPathsHint(value)
}

func (self Instance) DebugNavigationHint() bool {
	return bool(class(self).IsDebuggingNavigationHint())
}

func (self Instance) SetDebugNavigationHint(value bool) {
	class(self).SetDebugNavigationHint(value)
}

func (self Instance) Paused() bool {
	return bool(class(self).IsPaused())
}

func (self Instance) SetPaused(value bool) {
	class(self).SetPause(value)
}

func (self Instance) EditedSceneRoot() Node.Instance {
	return Node.Instance(class(self).GetEditedSceneRoot())
}

func (self Instance) SetEditedSceneRoot(value Node.Instance) {
	class(self).SetEditedSceneRoot(value)
}

func (self Instance) CurrentScene() Node.Instance {
	return Node.Instance(class(self).GetCurrentScene())
}

func (self Instance) SetCurrentScene(value Node.Instance) {
	class(self).SetCurrentScene(value)
}

func (self Instance) Root() Window.Instance {
	return Window.Instance(class(self).GetRoot())
}

func (self Instance) MultiplayerPoll() bool {
	return bool(class(self).IsMultiplayerPollEnabled())
}

func (self Instance) SetMultiplayerPoll(value bool) {
	class(self).SetMultiplayerPollEnabled(value)
}

func (self Instance) PhysicsInterpolation() bool {
	return bool(class(self).IsPhysicsInterpolationEnabled())
}

func (self Instance) SetPhysicsInterpolation(value bool) {
	class(self).SetPhysicsInterpolationEnabled(value)
}

//go:nosplit
func (self class) GetRoot() [1]gdclass.Window { //gd:SceneTree.get_root
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_root, gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.Window{gd.PointerMustAssertInstanceID[gdclass.Window](r_ret)}
	return ret
}

/*
Returns [code]true[/code] if a node added to the given group [param name] exists in the tree.
*/
//go:nosplit
func (self class) HasGroup(name String.Name) bool { //gd:SceneTree.has_group
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.has_group, gdextension.SizeBool|(gdextension.SizeStringName<<4), unsafe.Pointer(&struct{ name gdextension.StringName }{pointers.Get(gd.InternalStringName(name))}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) IsAutoAcceptQuit() bool { //gd:SceneTree.is_auto_accept_quit
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_auto_accept_quit, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetAutoAcceptQuit(enabled bool) { //gd:SceneTree.set_auto_accept_quit
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_auto_accept_quit, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enabled bool }{enabled}))
}

//go:nosplit
func (self class) IsQuitOnGoBack() bool { //gd:SceneTree.is_quit_on_go_back
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_quit_on_go_back, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetQuitOnGoBack(enabled bool) { //gd:SceneTree.set_quit_on_go_back
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_quit_on_go_back, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enabled bool }{enabled}))
}

//go:nosplit
func (self class) SetDebugCollisionsHint(enable bool) { //gd:SceneTree.set_debug_collisions_hint
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_debug_collisions_hint, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

//go:nosplit
func (self class) IsDebuggingCollisionsHint() bool { //gd:SceneTree.is_debugging_collisions_hint
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_debugging_collisions_hint, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetDebugPathsHint(enable bool) { //gd:SceneTree.set_debug_paths_hint
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_debug_paths_hint, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

//go:nosplit
func (self class) IsDebuggingPathsHint() bool { //gd:SceneTree.is_debugging_paths_hint
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_debugging_paths_hint, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetDebugNavigationHint(enable bool) { //gd:SceneTree.set_debug_navigation_hint
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_debug_navigation_hint, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

//go:nosplit
func (self class) IsDebuggingNavigationHint() bool { //gd:SceneTree.is_debugging_navigation_hint
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_debugging_navigation_hint, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetEditedSceneRoot(scene [1]gdclass.Node) { //gd:SceneTree.set_edited_scene_root
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_edited_scene_root, 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ scene gdextension.Object }{gdextension.Object(gd.PointerWithOwnershipTransferredToGodot(scene[0].AsObject()[0]))}))
}

//go:nosplit
func (self class) GetEditedSceneRoot() [1]gdclass.Node { //gd:SceneTree.get_edited_scene_root
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_edited_scene_root, gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.Node{gd.PointerMustAssertInstanceID[gdclass.Node](r_ret)}
	return ret
}

//go:nosplit
func (self class) SetPause(enable bool) { //gd:SceneTree.set_pause
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_pause, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

//go:nosplit
func (self class) IsPaused() bool { //gd:SceneTree.is_paused
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_paused, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns a new [SceneTreeTimer]. After [param time_sec] in seconds have passed, the timer will emit [signal SceneTreeTimer.timeout] and will be automatically freed.
If [param process_always] is [code]false[/code], the timer will be paused when setting [member SceneTree.paused] to [code]true[/code].
If [param process_in_physics] is [code]true[/code], the timer will update at the end of the physics frame, instead of the process frame.
If [param ignore_time_scale] is [code]true[/code], the timer will ignore [member Engine.time_scale] and update with the real, elapsed time.
This method is commonly used to create a one-shot delay timer, as in the following example:
[codeblocks]
[gdscript]
func some_function():
    print("start")
    await get_tree().create_timer(1.0).timeout
    print("end")
[/gdscript]
[csharp]
public async Task SomeFunction()
{
    GD.Print("start");
    await ToSignal(GetTree().CreateTimer(1.0f), SceneTreeTimer.SignalName.Timeout);
    GD.Print("end");
}
[/csharp]
[/codeblocks]
[b]Note:[/b] The timer is always updated [i]after[/i] all of the nodes in the tree. A node's [method Node._process] method would be called before the timer updates (or [method Node._physics_process] if [param process_in_physics] is set to [code]true[/code]).
*/
//go:nosplit
func (self class) CreateTimer(time_sec float64, process_always bool, process_in_physics bool, ignore_time_scale bool) [1]gdclass.SceneTreeTimer { //gd:SceneTree.create_timer
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.create_timer, gdextension.SizeObject|(gdextension.SizeFloat<<4)|(gdextension.SizeBool<<8)|(gdextension.SizeBool<<12)|(gdextension.SizeBool<<16), unsafe.Pointer(&struct {
		time_sec           float64
		process_always     bool
		process_in_physics bool
		ignore_time_scale  bool
	}{time_sec, process_always, process_in_physics, ignore_time_scale}))
	var ret = [1]gdclass.SceneTreeTimer{gd.PointerWithOwnershipTransferredToGo[gdclass.SceneTreeTimer](r_ret)}
	return ret
}

/*
Creates and returns a new [Tween] processed in this tree. The Tween will start automatically on the next process frame or physics frame (depending on its [enum Tween.TweenProcessMode]).
[b]Note:[/b] A [Tween] created using this method is not bound to any [Node]. It may keep working until there is nothing left to animate. If you want the [Tween] to be automatically killed when the [Node] is freed, use [method Node.create_tween] or [method Tween.bind_node].
*/
//go:nosplit
func (self class) CreateTween() [1]gdclass.Tween { //gd:SceneTree.create_tween
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.create_tween, gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.Tween{gd.PointerWithOwnershipTransferredToGo[gdclass.Tween](r_ret)}
	return ret
}

/*
Returns an [Array] of currently existing [Tween]s in the tree, including paused tweens.
*/
//go:nosplit
func (self class) GetProcessedTweens() Array.Contains[[1]gdclass.Tween] { //gd:SceneTree.get_processed_tweens
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), methods.get_processed_tweens, gdextension.SizeArray, unsafe.Pointer(&struct{}{}))
	var ret = Array.Through(gd.ArrayProxy[[1]gdclass.Tween]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

/*
Returns the number of nodes inside this tree.
*/
//go:nosplit
func (self class) GetNodeCount() int64 { //gd:SceneTree.get_node_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_node_count, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns how many frames have been processed, since the application started. This is [i]not[/i] a measurement of elapsed time.
*/
//go:nosplit
func (self class) GetFrame() int64 { //gd:SceneTree.get_frame
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_frame, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Quits the application at the end of the current iteration, with the given [param exit_code].
By convention, an exit code of [code]0[/code] indicates success, whereas any other exit code indicates an error. For portability reasons, it should be between [code]0[/code] and [code]125[/code] (inclusive).
[b]Note:[/b] On iOS this method doesn't work. Instead, as recommended by the [url=https://developer.apple.com/library/archive/qa/qa1561/_index.html]iOS Human Interface Guidelines[/url], the user is expected to close apps via the Home button.
*/
//go:nosplit
func (self class) Quit(exit_code int64) { //gd:SceneTree.quit
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.quit, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ exit_code int64 }{exit_code}))
}

//go:nosplit
func (self class) SetPhysicsInterpolationEnabled(enabled bool) { //gd:SceneTree.set_physics_interpolation_enabled
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_physics_interpolation_enabled, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enabled bool }{enabled}))
}

//go:nosplit
func (self class) IsPhysicsInterpolationEnabled() bool { //gd:SceneTree.is_physics_interpolation_enabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_physics_interpolation_enabled, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Queues the given [param obj] to be deleted, calling its [method Object.free] at the end of the current frame. This method is similar to [method Node.queue_free].
*/
//go:nosplit
func (self class) QueueDelete(obj [1]gd.Object) { //gd:SceneTree.queue_delete
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.queue_delete, 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ obj gdextension.Object }{gdextension.Object(gd.PointerWithOwnershipTransferredToGodot(obj[0].AsObject()[0]))}))
}

/*
Calls the given [param method] on each node inside this tree added to the given [param group]. Use [param flags] to customize this method's behavior (see [enum GroupCallFlags]). Additional arguments for [param method] can be passed at the end of this method. Nodes that cannot call [param method] (either because the method doesn't exist or the arguments do not match) are ignored.
[codeblock]
# Calls "hide" to all nodes of the "enemies" group, at the end of the frame and in reverse tree order.
get_tree().call_group_flags(
        SceneTree.GROUP_CALL_DEFERRED | SceneTree.GROUP_CALL_REVERSE,
        "enemies", "hide")
[/codeblock]
[b]Note:[/b] In C#, [param method] must be in snake_case when referring to built-in Godot methods. Prefer using the names exposed in the [code]MethodName[/code] class to avoid allocating a new [StringName] on each call.
*/
//go:nosplit
func (self class) CallGroupFlags(flags int64, group String.Name, method String.Name, args ...gd.Variant) { //gd:SceneTree.call_group_flags
	var fixed = [...]gdextension.Variant{gdextension.Variant(pointers.Get(gd.NewVariant(flags))), gdextension.Variant(pointers.Get(gd.NewVariant(group))), gdextension.Variant(pointers.Get(gd.NewVariant(method)))}
	ret, err := methods.call_group_flags.Call(gd.ObjectChecked(self.AsObject()), fixed[:]...)
	if err != nil {
		panic(err)
	}
	_ = ret
}

/*
Calls [method Object.notification] with the given [param notification] to all nodes inside this tree added to the [param group]. Use [param call_flags] to customize this method's behavior (see [enum GroupCallFlags]).
*/
//go:nosplit
func (self class) NotifyGroupFlags(call_flags int64, group String.Name, notification int64) { //gd:SceneTree.notify_group_flags
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.notify_group_flags, 0|(gdextension.SizeInt<<4)|(gdextension.SizeStringName<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		call_flags   int64
		group        gdextension.StringName
		notification int64
	}{call_flags, pointers.Get(gd.InternalStringName(group)), notification}))
}

/*
Sets the given [param property] to [param value] on all nodes inside this tree added to the given [param group]. Nodes that do not have the [param property] are ignored. Use [param call_flags] to customize this method's behavior (see [enum GroupCallFlags]).
[b]Note:[/b] In C#, [param property] must be in snake_case when referring to built-in Godot properties. Prefer using the names exposed in the [code]PropertyName[/code] class to avoid allocating a new [StringName] on each call.
*/
//go:nosplit
func (self class) SetGroupFlags(call_flags int64, group String.Name, property String.Readable, value variant.Any) { //gd:SceneTree.set_group_flags
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_group_flags, 0|(gdextension.SizeInt<<4)|(gdextension.SizeStringName<<8)|(gdextension.SizeString<<12)|(gdextension.SizeVariant<<16), unsafe.Pointer(&struct {
		call_flags int64
		group      gdextension.StringName
		property   gdextension.String
		value      gdextension.Variant
	}{call_flags, pointers.Get(gd.InternalStringName(group)), pointers.Get(gd.InternalString(property)), gdextension.Variant(pointers.Get(gd.InternalVariant(value)))}))
}

/*
Calls [param method] on each node inside this tree added to the given [param group]. You can pass arguments to [param method] by specifying them at the end of this method call. Nodes that cannot call [param method] (either because the method doesn't exist or the arguments do not match) are ignored. See also [method set_group] and [method notify_group].
[b]Note:[/b] This method acts immediately on all selected nodes at once, which may cause stuttering in some performance-intensive situations.
[b]Note:[/b] In C#, [param method] must be in snake_case when referring to built-in Godot methods. Prefer using the names exposed in the [code]MethodName[/code] class to avoid allocating a new [StringName] on each call.
*/
//go:nosplit
func (self class) CallGroup(group String.Name, method String.Name, args ...gd.Variant) { //gd:SceneTree.call_group
	var fixed = [...]gdextension.Variant{gdextension.Variant(pointers.Get(gd.NewVariant(group))), gdextension.Variant(pointers.Get(gd.NewVariant(method)))}
	ret, err := methods.call_group.Call(gd.ObjectChecked(self.AsObject()), fixed[:]...)
	if err != nil {
		panic(err)
	}
	_ = ret
}

/*
Calls [method Object.notification] with the given [param notification] to all nodes inside this tree added to the [param group]. See also [url=$DOCS_URL/tutorials/best_practices/godot_notifications.html]Godot notifications[/url] and [method call_group] and [method set_group].
[b]Note:[/b] This method acts immediately on all selected nodes at once, which may cause stuttering in some performance-intensive situations.
*/
//go:nosplit
func (self class) NotifyGroup(group String.Name, notification int64) { //gd:SceneTree.notify_group
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.notify_group, 0|(gdextension.SizeStringName<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		group        gdextension.StringName
		notification int64
	}{pointers.Get(gd.InternalStringName(group)), notification}))
}

/*
Sets the given [param property] to [param value] on all nodes inside this tree added to the given [param group]. Nodes that do not have the [param property] are ignored. See also [method call_group] and [method notify_group].
[b]Note:[/b] This method acts immediately on all selected nodes at once, which may cause stuttering in some performance-intensive situations.
[b]Note:[/b] In C#, [param property] must be in snake_case when referring to built-in Godot properties. Prefer using the names exposed in the [code]PropertyName[/code] class to avoid allocating a new [StringName] on each call.
*/
//go:nosplit
func (self class) SetGroup(group String.Name, property String.Readable, value variant.Any) { //gd:SceneTree.set_group
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_group, 0|(gdextension.SizeStringName<<4)|(gdextension.SizeString<<8)|(gdextension.SizeVariant<<12), unsafe.Pointer(&struct {
		group    gdextension.StringName
		property gdextension.String
		value    gdextension.Variant
	}{pointers.Get(gd.InternalStringName(group)), pointers.Get(gd.InternalString(property)), gdextension.Variant(pointers.Get(gd.InternalVariant(value)))}))
}

/*
Returns an [Array] containing all nodes inside this tree, that have been added to the given [param group], in scene hierarchy order.
*/
//go:nosplit
func (self class) GetNodesInGroup(group String.Name) Array.Contains[[1]gdclass.Node] { //gd:SceneTree.get_nodes_in_group
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), methods.get_nodes_in_group, gdextension.SizeArray|(gdextension.SizeStringName<<4), unsafe.Pointer(&struct{ group gdextension.StringName }{pointers.Get(gd.InternalStringName(group))}))
	var ret = Array.Through(gd.ArrayProxy[[1]gdclass.Node]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

/*
Returns the first [Node] found inside the tree, that has been added to the given [param group], in scene hierarchy order. Returns [code]null[/code] if no match is found. See also [method get_nodes_in_group].
*/
//go:nosplit
func (self class) GetFirstNodeInGroup(group String.Name) [1]gdclass.Node { //gd:SceneTree.get_first_node_in_group
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_first_node_in_group, gdextension.SizeObject|(gdextension.SizeStringName<<4), unsafe.Pointer(&struct{ group gdextension.StringName }{pointers.Get(gd.InternalStringName(group))}))
	var ret = [1]gdclass.Node{gd.PointerMustAssertInstanceID[gdclass.Node](r_ret)}
	return ret
}

/*
Returns the number of nodes assigned to the given group.
*/
//go:nosplit
func (self class) GetNodeCountInGroup(group String.Name) int64 { //gd:SceneTree.get_node_count_in_group
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_node_count_in_group, gdextension.SizeInt|(gdextension.SizeStringName<<4), unsafe.Pointer(&struct{ group gdextension.StringName }{pointers.Get(gd.InternalStringName(group))}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetCurrentScene(child_node [1]gdclass.Node) { //gd:SceneTree.set_current_scene
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_current_scene, 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ child_node gdextension.Object }{gdextension.Object(gd.PointerWithOwnershipTransferredToGodot(child_node[0].AsObject()[0]))}))
}

//go:nosplit
func (self class) GetCurrentScene() [1]gdclass.Node { //gd:SceneTree.get_current_scene
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_current_scene, gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.Node{gd.PointerMustAssertInstanceID[gdclass.Node](r_ret)}
	return ret
}

/*
Changes the running scene to the one at the given [param path], after loading it into a [PackedScene] and creating a new instance.
Returns [constant OK] on success, [constant ERR_CANT_OPEN] if the [param path] cannot be loaded into a [PackedScene], or [constant ERR_CANT_CREATE] if that scene cannot be instantiated.
[b]Note:[/b] See [method change_scene_to_packed] for details on the order of operations.
*/
//go:nosplit
func (self class) ChangeSceneToFile(path String.Readable) Error.Code { //gd:SceneTree.change_scene_to_file
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.change_scene_to_file, gdextension.SizeInt|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ path gdextension.String }{pointers.Get(gd.InternalString(path))}))
	var ret = Error.Code(r_ret)
	return ret
}

/*
Changes the running scene to a new instance of the given [PackedScene] (which must be valid).
Returns [constant OK] on success, [constant ERR_CANT_CREATE] if the scene cannot be instantiated, or [constant ERR_INVALID_PARAMETER] if the scene is invalid.
[b]Note:[/b] Operations happen in the following order when [method change_scene_to_packed] is called:
1. The current scene node is immediately removed from the tree. From that point, [method Node.get_tree] called on the current (outgoing) scene will return [code]null[/code]. [member current_scene] will be [code]null[/code], too, because the new scene is not available yet.
2. At the end of the frame, the formerly current scene, already removed from the tree, will be deleted (freed from memory) and then the new scene will be instantiated and added to the tree. [method Node.get_tree] and [member current_scene] will be back to working as usual.
This ensures that both scenes aren't running at the same time, while still freeing the previous scene in a safe way similar to [method Node.queue_free].
*/
//go:nosplit
func (self class) ChangeSceneToPacked(packed_scene [1]gdclass.PackedScene) Error.Code { //gd:SceneTree.change_scene_to_packed
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.change_scene_to_packed, gdextension.SizeInt|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ packed_scene gdextension.Object }{gdextension.Object(gd.ObjectChecked(packed_scene[0].AsObject()))}))
	var ret = Error.Code(r_ret)
	return ret
}

/*
Reloads the currently active scene, replacing [member current_scene] with a new instance of its original [PackedScene].
Returns [constant OK] on success, [constant ERR_UNCONFIGURED] if no [member current_scene] is defined, [constant ERR_CANT_OPEN] if [member current_scene] cannot be loaded into a [PackedScene], or [constant ERR_CANT_CREATE] if the scene cannot be instantiated.
*/
//go:nosplit
func (self class) ReloadCurrentScene() Error.Code { //gd:SceneTree.reload_current_scene
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.reload_current_scene, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = Error.Code(r_ret)
	return ret
}

/*
If a current scene is loaded, calling this method will unload it.
*/
//go:nosplit
func (self class) UnloadCurrentScene() { //gd:SceneTree.unload_current_scene
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.unload_current_scene, 0, unsafe.Pointer(&struct{}{}))
}

/*
Sets a custom [MultiplayerAPI] with the given [param root_path] (controlling also the relative subpaths), or override the default one if [param root_path] is empty.
[b]Note:[/b] No [MultiplayerAPI] must be configured for the subpath containing [param root_path], nested custom multiplayers are not allowed. I.e. if one is configured for [code]"/root/Foo"[/code] setting one for [code]"/root/Foo/Bar"[/code] will cause an error.
*/
//go:nosplit
func (self class) SetMultiplayer(multiplayer [1]gdclass.MultiplayerAPI, root_path Path.ToNode) { //gd:SceneTree.set_multiplayer
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_multiplayer, 0|(gdextension.SizeObject<<4)|(gdextension.SizeNodePath<<8), unsafe.Pointer(&struct {
		multiplayer gdextension.Object
		root_path   gdextension.NodePath
	}{gdextension.Object(gd.ObjectChecked(multiplayer[0].AsObject())), pointers.Get(gd.InternalNodePath(root_path))}))
}

/*
Searches for the [MultiplayerAPI] configured for the given path, if one does not exist it searches the parent paths until one is found. If the path is empty, or none is found, the default one is returned. See [method set_multiplayer].
*/
//go:nosplit
func (self class) GetMultiplayer(for_path Path.ToNode) [1]gdclass.MultiplayerAPI { //gd:SceneTree.get_multiplayer
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_multiplayer, gdextension.SizeObject|(gdextension.SizeNodePath<<4), unsafe.Pointer(&struct{ for_path gdextension.NodePath }{pointers.Get(gd.InternalNodePath(for_path))}))
	var ret = [1]gdclass.MultiplayerAPI{gd.PointerWithOwnershipTransferredToGo[gdclass.MultiplayerAPI](r_ret)}
	return ret
}

//go:nosplit
func (self class) SetMultiplayerPollEnabled(enabled bool) { //gd:SceneTree.set_multiplayer_poll_enabled
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_multiplayer_poll_enabled, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enabled bool }{enabled}))
}

//go:nosplit
func (self class) IsMultiplayerPollEnabled() bool { //gd:SceneTree.is_multiplayer_poll_enabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_multiplayer_poll_enabled, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}
func (self Instance) OnTreeChanged(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("tree_changed"), gd.NewCallable(cb), 0)
}

func (self Instance) OnTreeProcessModeChanged(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("tree_process_mode_changed"), gd.NewCallable(cb), 0)
}

func (self Instance) OnNodeAdded(cb func(node Node.Instance)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("node_added"), gd.NewCallable(cb), 0)
}

func (self Instance) OnNodeRemoved(cb func(node Node.Instance)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("node_removed"), gd.NewCallable(cb), 0)
}

func (self Instance) OnNodeRenamed(cb func(node Node.Instance)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("node_renamed"), gd.NewCallable(cb), 0)
}

func (self Instance) OnNodeConfigurationWarningChanged(cb func(node Node.Instance)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("node_configuration_warning_changed"), gd.NewCallable(cb), 0)
}

func (self Instance) OnProcessFrame(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("process_frame"), gd.NewCallable(cb), 0)
}

func (self Instance) OnPhysicsFrame(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("physics_frame"), gd.NewCallable(cb), 0)
}

func (self class) AsSceneTree() Advanced         { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsSceneTree() Instance      { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsSceneTree() Instance { return self.Super().AsSceneTree() }
func (self class) AsMainLoop() MainLoop.Advanced {
	return *((*MainLoop.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsMainLoop() MainLoop.Instance { return self.Super().AsMainLoop() }
func (self Instance) AsMainLoop() MainLoop.Instance {
	return *((*MainLoop.Instance)(unsafe.Pointer(&self)))
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(MainLoop.Advanced(self.AsMainLoop()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(MainLoop.Instance(self.AsMainLoop()), name)
	}
}
func init() {
	gdclass.Register("SceneTree", func(ptr gd.Object) any { return *(*Instance)(unsafe.Pointer(&ptr)) })
}

type GroupCallFlags int //gd:SceneTree.GroupCallFlags

const (
	/*Call nodes within a group with no special behavior (default).*/
	GroupCallDefault GroupCallFlags = 0
	/*Call nodes within a group in reverse tree hierarchy order (all nested children are called before their respective parent nodes).*/
	GroupCallReverse GroupCallFlags = 1
	/*Call nodes within a group at the end of the current frame (can be either process or physics frame), similar to [method Object.call_deferred].*/
	GroupCallDeferred GroupCallFlags = 2
	/*Call nodes within a group only once, even if the call is executed many times in the same frame. Must be combined with [constant GROUP_CALL_DEFERRED] to work.
	  [b]Note:[/b] Different arguments are not taken into account. Therefore, when the same call is executed with different arguments, only the first call will be performed.*/
	GroupCallUnique GroupCallFlags = 4
)
