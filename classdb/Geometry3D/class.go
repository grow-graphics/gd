// Code generated by the generate package DO NOT EDIT

// Package Geometry3D provides methods for working with Geometry3D object instances.
package Geometry3D

import "unsafe"
import "sync"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/Plane"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"
import "graphics.gd/variant/Vector3"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
Provides a set of helper functions to create geometric shapes, compute intersections between shapes, and process various other geometric operations in 3D.
*/
type Instance [1]gdclass.Geometry3D

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	compute_convex_mesh_points            gdextension.MethodForClass `hash:"1936902142"`
	build_box_planes                      gdextension.MethodForClass `hash:"3622277145"`
	build_cylinder_planes                 gdextension.MethodForClass `hash:"449920067"`
	build_capsule_planes                  gdextension.MethodForClass `hash:"2113592876"`
	get_closest_points_between_segments   gdextension.MethodForClass `hash:"1056373962"`
	get_closest_point_to_segment          gdextension.MethodForClass `hash:"2168193209"`
	get_closest_point_to_segment_uncapped gdextension.MethodForClass `hash:"2168193209"`
	get_triangle_barycentric_coords       gdextension.MethodForClass `hash:"1362048029"`
	ray_intersects_triangle               gdextension.MethodForClass `hash:"1718655448"`
	segment_intersects_triangle           gdextension.MethodForClass `hash:"1718655448"`
	segment_intersects_sphere             gdextension.MethodForClass `hash:"4080141172"`
	segment_intersects_cylinder           gdextension.MethodForClass `hash:"2361316491"`
	segment_intersects_convex             gdextension.MethodForClass `hash:"537425332"`
	clip_polygon                          gdextension.MethodForClass `hash:"2603188319"`
	tetrahedralize_delaunay               gdextension.MethodForClass `hash:"1230191221"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("Geometry3D")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		pointers.Raw[gd.StringName](sname).Free()
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

var self [1]gdclass.Geometry3D
var once sync.Once

func singleton() {
	self[0] = pointers.Raw[gdclass.Geometry3D]([3]uint64{uint64(gdextension.Host.Objects.Global(sname))})
}

/*
Calculates and returns all the vertex points of a convex shape defined by an array of [param planes].
*/
func ComputeConvexMeshPoints(planes []Plane.NormalD) []Vector3.XYZ { //gd:Geometry3D.compute_convex_mesh_points
	once.Do(singleton)
	return []Vector3.XYZ(slices.Collect(Advanced().ComputeConvexMeshPoints(gd.ArrayFromSlice[Array.Contains[Plane.NormalD]](planes)).Values()))
}

/*
Returns an array with 6 [Plane]s that describe the sides of a box centered at the origin. The box size is defined by [param extents], which represents one (positive) corner of the box (i.e. half its actual size).
*/
func BuildBoxPlanes(extents Vector3.XYZ) []Plane.NormalD { //gd:Geometry3D.build_box_planes
	once.Do(singleton)
	return []Plane.NormalD(gd.ArrayAs[[]Plane.NormalD](gd.InternalArray(Advanced().BuildBoxPlanes(Vector3.XYZ(extents)))))
}

/*
Returns an array of [Plane]s closely bounding a faceted cylinder centered at the origin with radius [param radius] and height [param height]. The parameter [param sides] defines how many planes will be generated for the round part of the cylinder. The parameter [param axis] describes the axis along which the cylinder is oriented (0 for X, 1 for Y, 2 for Z).
*/
func BuildCylinderPlanes(radius Float.X, height Float.X, sides int) []Plane.NormalD { //gd:Geometry3D.build_cylinder_planes
	once.Do(singleton)
	return []Plane.NormalD(gd.ArrayAs[[]Plane.NormalD](gd.InternalArray(Advanced().BuildCylinderPlanes(float64(radius), float64(height), int64(sides), 2))))
}

/*
Returns an array of [Plane]s closely bounding a faceted cylinder centered at the origin with radius [param radius] and height [param height]. The parameter [param sides] defines how many planes will be generated for the round part of the cylinder. The parameter [param axis] describes the axis along which the cylinder is oriented (0 for X, 1 for Y, 2 for Z).
*/
func BuildCylinderPlanesOptions(radius Float.X, height Float.X, sides int, axis Vector3.Axis) []Plane.NormalD { //gd:Geometry3D.build_cylinder_planes
	once.Do(singleton)
	return []Plane.NormalD(gd.ArrayAs[[]Plane.NormalD](gd.InternalArray(Advanced().BuildCylinderPlanes(float64(radius), float64(height), int64(sides), axis))))
}

/*
Returns an array of [Plane]s closely bounding a faceted capsule centered at the origin with radius [param radius] and height [param height]. The parameter [param sides] defines how many planes will be generated for the side part of the capsule, whereas [param lats] gives the number of latitudinal steps at the bottom and top of the capsule. The parameter [param axis] describes the axis along which the capsule is oriented (0 for X, 1 for Y, 2 for Z).
*/
func BuildCapsulePlanes(radius Float.X, height Float.X, sides int, lats int) []Plane.NormalD { //gd:Geometry3D.build_capsule_planes
	once.Do(singleton)
	return []Plane.NormalD(gd.ArrayAs[[]Plane.NormalD](gd.InternalArray(Advanced().BuildCapsulePlanes(float64(radius), float64(height), int64(sides), int64(lats), 2))))
}

/*
Returns an array of [Plane]s closely bounding a faceted capsule centered at the origin with radius [param radius] and height [param height]. The parameter [param sides] defines how many planes will be generated for the side part of the capsule, whereas [param lats] gives the number of latitudinal steps at the bottom and top of the capsule. The parameter [param axis] describes the axis along which the capsule is oriented (0 for X, 1 for Y, 2 for Z).
*/
func BuildCapsulePlanesOptions(radius Float.X, height Float.X, sides int, lats int, axis Vector3.Axis) []Plane.NormalD { //gd:Geometry3D.build_capsule_planes
	once.Do(singleton)
	return []Plane.NormalD(gd.ArrayAs[[]Plane.NormalD](gd.InternalArray(Advanced().BuildCapsulePlanes(float64(radius), float64(height), int64(sides), int64(lats), axis))))
}

/*
Given the two 3D segments ([param p1], [param p2]) and ([param q1], [param q2]), finds those two points on the two segments that are closest to each other. Returns a [PackedVector3Array] that contains this point on ([param p1], [param p2]) as well the accompanying point on ([param q1], [param q2]).
*/
func GetClosestPointsBetweenSegments(p1 Vector3.XYZ, p2 Vector3.XYZ, q1 Vector3.XYZ, q2 Vector3.XYZ) []Vector3.XYZ { //gd:Geometry3D.get_closest_points_between_segments
	once.Do(singleton)
	return []Vector3.XYZ(slices.Collect(Advanced().GetClosestPointsBetweenSegments(Vector3.XYZ(p1), Vector3.XYZ(p2), Vector3.XYZ(q1), Vector3.XYZ(q2)).Values()))
}

/*
Returns the 3D point on the 3D segment ([param s1], [param s2]) that is closest to [param point]. The returned point will always be inside the specified segment.
*/
func GetClosestPointToSegment(point Vector3.XYZ, s1 Vector3.XYZ, s2 Vector3.XYZ) Vector3.XYZ { //gd:Geometry3D.get_closest_point_to_segment
	once.Do(singleton)
	return Vector3.XYZ(Advanced().GetClosestPointToSegment(Vector3.XYZ(point), Vector3.XYZ(s1), Vector3.XYZ(s2)))
}

/*
Returns the 3D point on the 3D line defined by ([param s1], [param s2]) that is closest to [param point]. The returned point can be inside the segment ([param s1], [param s2]) or outside of it, i.e. somewhere on the line extending from the segment.
*/
func GetClosestPointToSegmentUncapped(point Vector3.XYZ, s1 Vector3.XYZ, s2 Vector3.XYZ) Vector3.XYZ { //gd:Geometry3D.get_closest_point_to_segment_uncapped
	once.Do(singleton)
	return Vector3.XYZ(Advanced().GetClosestPointToSegmentUncapped(Vector3.XYZ(point), Vector3.XYZ(s1), Vector3.XYZ(s2)))
}

/*
Returns a [Vector3] containing weights based on how close a 3D position ([param point]) is to a triangle's different vertices ([param a], [param b] and [param c]). This is useful for interpolating between the data of different vertices in a triangle. One example use case is using this to smoothly rotate over a mesh instead of relying solely on face normals.
[url=https://en.wikipedia.org/wiki/Barycentric_coordinate_system]Here is a more detailed explanation of barycentric coordinates.[/url]
*/
func GetTriangleBarycentricCoords(point Vector3.XYZ, a Vector3.XYZ, b Vector3.XYZ, c Vector3.XYZ) Vector3.XYZ { //gd:Geometry3D.get_triangle_barycentric_coords
	once.Do(singleton)
	return Vector3.XYZ(Advanced().GetTriangleBarycentricCoords(Vector3.XYZ(point), Vector3.XYZ(a), Vector3.XYZ(b), Vector3.XYZ(c)))
}

/*
Tests if the 3D ray starting at [param from] with the direction of [param dir] intersects the triangle specified by [param a], [param b] and [param c]. If yes, returns the point of intersection as [Vector3]. If no intersection takes place, returns [code]null[/code].
*/
func RayIntersectsTriangle(from Vector3.XYZ, dir Vector3.XYZ, a Vector3.XYZ, b Vector3.XYZ, c Vector3.XYZ) any { //gd:Geometry3D.ray_intersects_triangle
	once.Do(singleton)
	return any(Advanced().RayIntersectsTriangle(Vector3.XYZ(from), Vector3.XYZ(dir), Vector3.XYZ(a), Vector3.XYZ(b), Vector3.XYZ(c)).Interface())
}

/*
Tests if the segment ([param from], [param to]) intersects the triangle [param a], [param b], [param c]. If yes, returns the point of intersection as [Vector3]. If no intersection takes place, returns [code]null[/code].
*/
func SegmentIntersectsTriangle(from Vector3.XYZ, to Vector3.XYZ, a Vector3.XYZ, b Vector3.XYZ, c Vector3.XYZ) any { //gd:Geometry3D.segment_intersects_triangle
	once.Do(singleton)
	return any(Advanced().SegmentIntersectsTriangle(Vector3.XYZ(from), Vector3.XYZ(to), Vector3.XYZ(a), Vector3.XYZ(b), Vector3.XYZ(c)).Interface())
}

/*
Checks if the segment ([param from], [param to]) intersects the sphere that is located at [param sphere_position] and has radius [param sphere_radius]. If no, returns an empty [PackedVector3Array]. If yes, returns a [PackedVector3Array] containing the point of intersection and the sphere's normal at the point of intersection.
*/
func SegmentIntersectsSphere(from Vector3.XYZ, to Vector3.XYZ, sphere_position Vector3.XYZ, sphere_radius Float.X) []Vector3.XYZ { //gd:Geometry3D.segment_intersects_sphere
	once.Do(singleton)
	return []Vector3.XYZ(slices.Collect(Advanced().SegmentIntersectsSphere(Vector3.XYZ(from), Vector3.XYZ(to), Vector3.XYZ(sphere_position), float64(sphere_radius)).Values()))
}

/*
Checks if the segment ([param from], [param to]) intersects the cylinder with height [param height] that is centered at the origin and has radius [param radius]. If no, returns an empty [PackedVector3Array]. If an intersection takes place, the returned array contains the point of intersection and the cylinder's normal at the point of intersection.
*/
func SegmentIntersectsCylinder(from Vector3.XYZ, to Vector3.XYZ, height Float.X, radius Float.X) []Vector3.XYZ { //gd:Geometry3D.segment_intersects_cylinder
	once.Do(singleton)
	return []Vector3.XYZ(slices.Collect(Advanced().SegmentIntersectsCylinder(Vector3.XYZ(from), Vector3.XYZ(to), float64(height), float64(radius)).Values()))
}

/*
Given a convex hull defined though the [Plane]s in the array [param planes], tests if the segment ([param from], [param to]) intersects with that hull. If an intersection is found, returns a [PackedVector3Array] containing the point the intersection and the hull's normal. Otherwise, returns an empty array.
*/
func SegmentIntersectsConvex(from Vector3.XYZ, to Vector3.XYZ, planes []Plane.NormalD) []Vector3.XYZ { //gd:Geometry3D.segment_intersects_convex
	once.Do(singleton)
	return []Vector3.XYZ(slices.Collect(Advanced().SegmentIntersectsConvex(Vector3.XYZ(from), Vector3.XYZ(to), gd.ArrayFromSlice[Array.Contains[Plane.NormalD]](planes)).Values()))
}

/*
Clips the polygon defined by the points in [param points] against the [param plane] and returns the points of the clipped polygon.
*/
func ClipPolygon(points []Vector3.XYZ, plane Plane.NormalD) []Vector3.XYZ { //gd:Geometry3D.clip_polygon
	once.Do(singleton)
	return []Vector3.XYZ(slices.Collect(Advanced().ClipPolygon(Packed.New(points...), Plane.NormalD(plane)).Values()))
}

/*
Tetrahedralizes the volume specified by a discrete set of [param points] in 3D space, ensuring that no point lies within the circumsphere of any resulting tetrahedron. The method returns a [PackedInt32Array] where each tetrahedron consists of four consecutive point indices into the [param points] array (resulting in an array with [code]n * 4[/code] elements, where [code]n[/code] is the number of tetrahedra found). If the tetrahedralization is unsuccessful, an empty [PackedInt32Array] is returned.
*/
func TetrahedralizeDelaunay(points []Vector3.XYZ) []int32 { //gd:Geometry3D.tetrahedralize_delaunay
	once.Do(singleton)
	return []int32(slices.Collect(Advanced().TetrahedralizeDelaunay(Packed.New(points...)).Values()))
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
func Advanced() class { once.Do(singleton); return self }

type class [1]gdclass.Geometry3D

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.Geometry3D)(unsafe.Pointer(&obj))
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.Geometry3D)(unsafe.Pointer(&obj))
		return true
	}
	return false
}

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }

/*
Calculates and returns all the vertex points of a convex shape defined by an array of [param planes].
*/
//go:nosplit
func (self class) ComputeConvexMeshPoints(planes Array.Contains[Plane.NormalD]) Packed.Array[Vector3.XYZ] { //gd:Geometry3D.compute_convex_mesh_points
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.compute_convex_mesh_points, gdextension.SizePackedArray|(gdextension.SizeArray<<4), unsafe.Pointer(&struct{ planes gdextension.Array }{pointers.Get(gd.InternalArray(planes))}))
	var ret = Packed.Array[Vector3.XYZ](Array.Through(gd.PackedProxy[gd.PackedVector3Array, Vector3.XYZ]{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

/*
Returns an array with 6 [Plane]s that describe the sides of a box centered at the origin. The box size is defined by [param extents], which represents one (positive) corner of the box (i.e. half its actual size).
*/
//go:nosplit
func (self class) BuildBoxPlanes(extents Vector3.XYZ) Array.Contains[Plane.NormalD] { //gd:Geometry3D.build_box_planes
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), methods.build_box_planes, gdextension.SizeArray|(gdextension.SizeVector3<<4), unsafe.Pointer(&struct{ extents Vector3.XYZ }{extents}))
	var ret = Array.Through(gd.ArrayProxy[Plane.NormalD]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

/*
Returns an array of [Plane]s closely bounding a faceted cylinder centered at the origin with radius [param radius] and height [param height]. The parameter [param sides] defines how many planes will be generated for the round part of the cylinder. The parameter [param axis] describes the axis along which the cylinder is oriented (0 for X, 1 for Y, 2 for Z).
*/
//go:nosplit
func (self class) BuildCylinderPlanes(radius float64, height float64, sides int64, axis Vector3.Axis) Array.Contains[Plane.NormalD] { //gd:Geometry3D.build_cylinder_planes
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), methods.build_cylinder_planes, gdextension.SizeArray|(gdextension.SizeFloat<<4)|(gdextension.SizeFloat<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeInt<<16), unsafe.Pointer(&struct {
		radius float64
		height float64
		sides  int64
		axis   Vector3.Axis
	}{radius, height, sides, axis}))
	var ret = Array.Through(gd.ArrayProxy[Plane.NormalD]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

/*
Returns an array of [Plane]s closely bounding a faceted capsule centered at the origin with radius [param radius] and height [param height]. The parameter [param sides] defines how many planes will be generated for the side part of the capsule, whereas [param lats] gives the number of latitudinal steps at the bottom and top of the capsule. The parameter [param axis] describes the axis along which the capsule is oriented (0 for X, 1 for Y, 2 for Z).
*/
//go:nosplit
func (self class) BuildCapsulePlanes(radius float64, height float64, sides int64, lats int64, axis Vector3.Axis) Array.Contains[Plane.NormalD] { //gd:Geometry3D.build_capsule_planes
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), methods.build_capsule_planes, gdextension.SizeArray|(gdextension.SizeFloat<<4)|(gdextension.SizeFloat<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeInt<<16)|(gdextension.SizeInt<<20), unsafe.Pointer(&struct {
		radius float64
		height float64
		sides  int64
		lats   int64
		axis   Vector3.Axis
	}{radius, height, sides, lats, axis}))
	var ret = Array.Through(gd.ArrayProxy[Plane.NormalD]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

/*
Given the two 3D segments ([param p1], [param p2]) and ([param q1], [param q2]), finds those two points on the two segments that are closest to each other. Returns a [PackedVector3Array] that contains this point on ([param p1], [param p2]) as well the accompanying point on ([param q1], [param q2]).
*/
//go:nosplit
func (self class) GetClosestPointsBetweenSegments(p1 Vector3.XYZ, p2 Vector3.XYZ, q1 Vector3.XYZ, q2 Vector3.XYZ) Packed.Array[Vector3.XYZ] { //gd:Geometry3D.get_closest_points_between_segments
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.get_closest_points_between_segments, gdextension.SizePackedArray|(gdextension.SizeVector3<<4)|(gdextension.SizeVector3<<8)|(gdextension.SizeVector3<<12)|(gdextension.SizeVector3<<16), unsafe.Pointer(&struct {
		p1 Vector3.XYZ
		p2 Vector3.XYZ
		q1 Vector3.XYZ
		q2 Vector3.XYZ
	}{p1, p2, q1, q2}))
	var ret = Packed.Array[Vector3.XYZ](Array.Through(gd.PackedProxy[gd.PackedVector3Array, Vector3.XYZ]{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

/*
Returns the 3D point on the 3D segment ([param s1], [param s2]) that is closest to [param point]. The returned point will always be inside the specified segment.
*/
//go:nosplit
func (self class) GetClosestPointToSegment(point Vector3.XYZ, s1 Vector3.XYZ, s2 Vector3.XYZ) Vector3.XYZ { //gd:Geometry3D.get_closest_point_to_segment
	var r_ret = gdextension.Call[Vector3.XYZ](gd.ObjectChecked(self.AsObject()), methods.get_closest_point_to_segment, gdextension.SizeVector3|(gdextension.SizeVector3<<4)|(gdextension.SizeVector3<<8)|(gdextension.SizeVector3<<12), unsafe.Pointer(&struct {
		point Vector3.XYZ
		s1    Vector3.XYZ
		s2    Vector3.XYZ
	}{point, s1, s2}))
	var ret = r_ret
	return ret
}

/*
Returns the 3D point on the 3D line defined by ([param s1], [param s2]) that is closest to [param point]. The returned point can be inside the segment ([param s1], [param s2]) or outside of it, i.e. somewhere on the line extending from the segment.
*/
//go:nosplit
func (self class) GetClosestPointToSegmentUncapped(point Vector3.XYZ, s1 Vector3.XYZ, s2 Vector3.XYZ) Vector3.XYZ { //gd:Geometry3D.get_closest_point_to_segment_uncapped
	var r_ret = gdextension.Call[Vector3.XYZ](gd.ObjectChecked(self.AsObject()), methods.get_closest_point_to_segment_uncapped, gdextension.SizeVector3|(gdextension.SizeVector3<<4)|(gdextension.SizeVector3<<8)|(gdextension.SizeVector3<<12), unsafe.Pointer(&struct {
		point Vector3.XYZ
		s1    Vector3.XYZ
		s2    Vector3.XYZ
	}{point, s1, s2}))
	var ret = r_ret
	return ret
}

/*
Returns a [Vector3] containing weights based on how close a 3D position ([param point]) is to a triangle's different vertices ([param a], [param b] and [param c]). This is useful for interpolating between the data of different vertices in a triangle. One example use case is using this to smoothly rotate over a mesh instead of relying solely on face normals.
[url=https://en.wikipedia.org/wiki/Barycentric_coordinate_system]Here is a more detailed explanation of barycentric coordinates.[/url]
*/
//go:nosplit
func (self class) GetTriangleBarycentricCoords(point Vector3.XYZ, a Vector3.XYZ, b Vector3.XYZ, c Vector3.XYZ) Vector3.XYZ { //gd:Geometry3D.get_triangle_barycentric_coords
	var r_ret = gdextension.Call[Vector3.XYZ](gd.ObjectChecked(self.AsObject()), methods.get_triangle_barycentric_coords, gdextension.SizeVector3|(gdextension.SizeVector3<<4)|(gdextension.SizeVector3<<8)|(gdextension.SizeVector3<<12)|(gdextension.SizeVector3<<16), unsafe.Pointer(&struct {
		point Vector3.XYZ
		a     Vector3.XYZ
		b     Vector3.XYZ
		c     Vector3.XYZ
	}{point, a, b, c}))
	var ret = r_ret
	return ret
}

/*
Tests if the 3D ray starting at [param from] with the direction of [param dir] intersects the triangle specified by [param a], [param b] and [param c]. If yes, returns the point of intersection as [Vector3]. If no intersection takes place, returns [code]null[/code].
*/
//go:nosplit
func (self class) RayIntersectsTriangle(from Vector3.XYZ, dir Vector3.XYZ, a Vector3.XYZ, b Vector3.XYZ, c Vector3.XYZ) variant.Any { //gd:Geometry3D.ray_intersects_triangle
	var r_ret = gdextension.Call[gdextension.Variant](gd.ObjectChecked(self.AsObject()), methods.ray_intersects_triangle, gdextension.SizeVariant|(gdextension.SizeVector3<<4)|(gdextension.SizeVector3<<8)|(gdextension.SizeVector3<<12)|(gdextension.SizeVector3<<16)|(gdextension.SizeVector3<<20), unsafe.Pointer(&struct {
		from Vector3.XYZ
		dir  Vector3.XYZ
		a    Vector3.XYZ
		b    Vector3.XYZ
		c    Vector3.XYZ
	}{from, dir, a, b, c}))
	var ret = variant.Implementation(gd.VariantProxy{}, pointers.Pack(pointers.New[gd.Variant](r_ret)))
	return ret
}

/*
Tests if the segment ([param from], [param to]) intersects the triangle [param a], [param b], [param c]. If yes, returns the point of intersection as [Vector3]. If no intersection takes place, returns [code]null[/code].
*/
//go:nosplit
func (self class) SegmentIntersectsTriangle(from Vector3.XYZ, to Vector3.XYZ, a Vector3.XYZ, b Vector3.XYZ, c Vector3.XYZ) variant.Any { //gd:Geometry3D.segment_intersects_triangle
	var r_ret = gdextension.Call[gdextension.Variant](gd.ObjectChecked(self.AsObject()), methods.segment_intersects_triangle, gdextension.SizeVariant|(gdextension.SizeVector3<<4)|(gdextension.SizeVector3<<8)|(gdextension.SizeVector3<<12)|(gdextension.SizeVector3<<16)|(gdextension.SizeVector3<<20), unsafe.Pointer(&struct {
		from Vector3.XYZ
		to   Vector3.XYZ
		a    Vector3.XYZ
		b    Vector3.XYZ
		c    Vector3.XYZ
	}{from, to, a, b, c}))
	var ret = variant.Implementation(gd.VariantProxy{}, pointers.Pack(pointers.New[gd.Variant](r_ret)))
	return ret
}

/*
Checks if the segment ([param from], [param to]) intersects the sphere that is located at [param sphere_position] and has radius [param sphere_radius]. If no, returns an empty [PackedVector3Array]. If yes, returns a [PackedVector3Array] containing the point of intersection and the sphere's normal at the point of intersection.
*/
//go:nosplit
func (self class) SegmentIntersectsSphere(from Vector3.XYZ, to Vector3.XYZ, sphere_position Vector3.XYZ, sphere_radius float64) Packed.Array[Vector3.XYZ] { //gd:Geometry3D.segment_intersects_sphere
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.segment_intersects_sphere, gdextension.SizePackedArray|(gdextension.SizeVector3<<4)|(gdextension.SizeVector3<<8)|(gdextension.SizeVector3<<12)|(gdextension.SizeFloat<<16), unsafe.Pointer(&struct {
		from            Vector3.XYZ
		to              Vector3.XYZ
		sphere_position Vector3.XYZ
		sphere_radius   float64
	}{from, to, sphere_position, sphere_radius}))
	var ret = Packed.Array[Vector3.XYZ](Array.Through(gd.PackedProxy[gd.PackedVector3Array, Vector3.XYZ]{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

/*
Checks if the segment ([param from], [param to]) intersects the cylinder with height [param height] that is centered at the origin and has radius [param radius]. If no, returns an empty [PackedVector3Array]. If an intersection takes place, the returned array contains the point of intersection and the cylinder's normal at the point of intersection.
*/
//go:nosplit
func (self class) SegmentIntersectsCylinder(from Vector3.XYZ, to Vector3.XYZ, height float64, radius float64) Packed.Array[Vector3.XYZ] { //gd:Geometry3D.segment_intersects_cylinder
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.segment_intersects_cylinder, gdextension.SizePackedArray|(gdextension.SizeVector3<<4)|(gdextension.SizeVector3<<8)|(gdextension.SizeFloat<<12)|(gdextension.SizeFloat<<16), unsafe.Pointer(&struct {
		from   Vector3.XYZ
		to     Vector3.XYZ
		height float64
		radius float64
	}{from, to, height, radius}))
	var ret = Packed.Array[Vector3.XYZ](Array.Through(gd.PackedProxy[gd.PackedVector3Array, Vector3.XYZ]{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

/*
Given a convex hull defined though the [Plane]s in the array [param planes], tests if the segment ([param from], [param to]) intersects with that hull. If an intersection is found, returns a [PackedVector3Array] containing the point the intersection and the hull's normal. Otherwise, returns an empty array.
*/
//go:nosplit
func (self class) SegmentIntersectsConvex(from Vector3.XYZ, to Vector3.XYZ, planes Array.Contains[Plane.NormalD]) Packed.Array[Vector3.XYZ] { //gd:Geometry3D.segment_intersects_convex
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.segment_intersects_convex, gdextension.SizePackedArray|(gdextension.SizeVector3<<4)|(gdextension.SizeVector3<<8)|(gdextension.SizeArray<<12), unsafe.Pointer(&struct {
		from   Vector3.XYZ
		to     Vector3.XYZ
		planes gdextension.Array
	}{from, to, pointers.Get(gd.InternalArray(planes))}))
	var ret = Packed.Array[Vector3.XYZ](Array.Through(gd.PackedProxy[gd.PackedVector3Array, Vector3.XYZ]{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

/*
Clips the polygon defined by the points in [param points] against the [param plane] and returns the points of the clipped polygon.
*/
//go:nosplit
func (self class) ClipPolygon(points Packed.Array[Vector3.XYZ], plane Plane.NormalD) Packed.Array[Vector3.XYZ] { //gd:Geometry3D.clip_polygon
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.clip_polygon, gdextension.SizePackedArray|(gdextension.SizePackedArray<<4)|(gdextension.SizePlane<<8), unsafe.Pointer(&struct {
		points gdextension.PackedArray[Vector3.XYZ]
		plane  Plane.NormalD
	}{pointers.Get(gd.InternalPacked[gd.PackedVector3Array, Vector3.XYZ](points)), plane}))
	var ret = Packed.Array[Vector3.XYZ](Array.Through(gd.PackedProxy[gd.PackedVector3Array, Vector3.XYZ]{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

/*
Tetrahedralizes the volume specified by a discrete set of [param points] in 3D space, ensuring that no point lies within the circumsphere of any resulting tetrahedron. The method returns a [PackedInt32Array] where each tetrahedron consists of four consecutive point indices into the [param points] array (resulting in an array with [code]n * 4[/code] elements, where [code]n[/code] is the number of tetrahedra found). If the tetrahedralization is unsuccessful, an empty [PackedInt32Array] is returned.
*/
//go:nosplit
func (self class) TetrahedralizeDelaunay(points Packed.Array[Vector3.XYZ]) Packed.Array[int32] { //gd:Geometry3D.tetrahedralize_delaunay
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.tetrahedralize_delaunay, gdextension.SizePackedArray|(gdextension.SizePackedArray<<4), unsafe.Pointer(&struct {
		points gdextension.PackedArray[Vector3.XYZ]
	}{pointers.Get(gd.InternalPacked[gd.PackedVector3Array, Vector3.XYZ](points))}))
	var ret = Packed.Array[int32](Array.Through(gd.PackedProxy[gd.PackedInt32Array, int32]{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}
func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Object.Advanced(self.AsObject()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Object.Instance(self.AsObject()), name)
	}
}
func init() {
	gdclass.Register("Geometry3D", func(ptr gd.Object) any { return *(*Instance)(unsafe.Pointer(&ptr)) })
}
