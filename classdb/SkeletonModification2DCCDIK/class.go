// Code generated by the generate package DO NOT EDIT

// Package SkeletonModification2DCCDIK provides methods for working with SkeletonModification2DCCDIK object instances.
package SkeletonModification2DCCDIK

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/variant/Signal"
import "graphics.gd/classdb/Resource"
import "graphics.gd/classdb/SkeletonModification2D"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Signal.Any
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
This [SkeletonModification2D] uses an algorithm called Cyclic Coordinate Descent Inverse Kinematics, or CCDIK, to manipulate a chain of bones in a [Skeleton2D] so it reaches a defined target.
CCDIK works by rotating a set of bones, typically called a "bone chain", on a single axis. Each bone is rotated to face the target from the tip (by default), which over a chain of bones allow it to rotate properly to reach the target. Because the bones only rotate on a single axis, CCDIK [i]can[/i] look more robotic than other IK solvers.
[b]Note:[/b] The CCDIK modifier has [code]ccdik_joints[/code], which are the data objects that hold the data for each joint in the CCDIK chain. This is different from a bone! CCDIK joints hold the data needed for each bone in the bone chain used by CCDIK.
CCDIK also fully supports angle constraints, allowing for more control over how a solution is met.
*/
type Instance [1]gdclass.SkeletonModification2DCCDIK

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	set_target_node                         gdextension.MethodForClass `hash:"1348162250"`
	get_target_node                         gdextension.MethodForClass `hash:"4075236667"`
	set_tip_node                            gdextension.MethodForClass `hash:"1348162250"`
	get_tip_node                            gdextension.MethodForClass `hash:"4075236667"`
	set_ccdik_data_chain_length             gdextension.MethodForClass `hash:"1286410249"`
	get_ccdik_data_chain_length             gdextension.MethodForClass `hash:"2455072627"`
	set_ccdik_joint_bone2d_node             gdextension.MethodForClass `hash:"2761262315"`
	get_ccdik_joint_bone2d_node             gdextension.MethodForClass `hash:"408788394"`
	set_ccdik_joint_bone_index              gdextension.MethodForClass `hash:"3937882851"`
	get_ccdik_joint_bone_index              gdextension.MethodForClass `hash:"923996154"`
	set_ccdik_joint_rotate_from_joint       gdextension.MethodForClass `hash:"300928843"`
	get_ccdik_joint_rotate_from_joint       gdextension.MethodForClass `hash:"1116898809"`
	set_ccdik_joint_enable_constraint       gdextension.MethodForClass `hash:"300928843"`
	get_ccdik_joint_enable_constraint       gdextension.MethodForClass `hash:"1116898809"`
	set_ccdik_joint_constraint_angle_min    gdextension.MethodForClass `hash:"1602489585"`
	get_ccdik_joint_constraint_angle_min    gdextension.MethodForClass `hash:"2339986948"`
	set_ccdik_joint_constraint_angle_max    gdextension.MethodForClass `hash:"1602489585"`
	get_ccdik_joint_constraint_angle_max    gdextension.MethodForClass `hash:"2339986948"`
	set_ccdik_joint_constraint_angle_invert gdextension.MethodForClass `hash:"300928843"`
	get_ccdik_joint_constraint_angle_invert gdextension.MethodForClass `hash:"1116898809"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("SkeletonModification2DCCDIK")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		gdextension.Free(gdextension.TypeStringName, &sname)
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsSkeletonModification2DCCDIK() Instance
}

/*
Sets the [Bone2D] node assigned to the CCDIK joint at [param joint_idx].
*/
func (self Instance) SetCcdikJointBone2dNode(joint_idx int, bone2d_nodepath string) { //gd:SkeletonModification2DCCDIK.set_ccdik_joint_bone2d_node
	Advanced(self).SetCcdikJointBone2dNode(int64(joint_idx), Path.ToNode(String.New(bone2d_nodepath)))
}

/*
Returns the [Bone2D] node assigned to the CCDIK joint at [param joint_idx].
*/
func (self Instance) GetCcdikJointBone2dNode(joint_idx int) string { //gd:SkeletonModification2DCCDIK.get_ccdik_joint_bone2d_node
	return string(Advanced(self).GetCcdikJointBone2dNode(int64(joint_idx)).String())
}

/*
Sets the bone index, [param bone_idx], of the CCDIK joint at [param joint_idx]. When possible, this will also update the [code]bone2d_node[/code] of the CCDIK joint based on data provided by the linked skeleton.
*/
func (self Instance) SetCcdikJointBoneIndex(joint_idx int, bone_idx int) { //gd:SkeletonModification2DCCDIK.set_ccdik_joint_bone_index
	Advanced(self).SetCcdikJointBoneIndex(int64(joint_idx), int64(bone_idx))
}

/*
Returns the index of the [Bone2D] node assigned to the CCDIK joint at [param joint_idx].
*/
func (self Instance) GetCcdikJointBoneIndex(joint_idx int) int { //gd:SkeletonModification2DCCDIK.get_ccdik_joint_bone_index
	return int(int(Advanced(self).GetCcdikJointBoneIndex(int64(joint_idx))))
}

/*
Sets whether the joint at [param joint_idx] is set to rotate from the joint, [code]true[/code], or to rotate from the tip, [code]false[/code].
*/
func (self Instance) SetCcdikJointRotateFromJoint(joint_idx int, rotate_from_joint bool) { //gd:SkeletonModification2DCCDIK.set_ccdik_joint_rotate_from_joint
	Advanced(self).SetCcdikJointRotateFromJoint(int64(joint_idx), rotate_from_joint)
}

/*
Returns whether the joint at [param joint_idx] is set to rotate from the joint, [code]true[/code], or to rotate from the tip, [code]false[/code]. The default is to rotate from the tip.
*/
func (self Instance) GetCcdikJointRotateFromJoint(joint_idx int) bool { //gd:SkeletonModification2DCCDIK.get_ccdik_joint_rotate_from_joint
	return bool(Advanced(self).GetCcdikJointRotateFromJoint(int64(joint_idx)))
}

/*
Determines whether angle constraints on the CCDIK joint at [param joint_idx] are enabled. When [code]true[/code], constraints will be enabled and taken into account when solving.
*/
func (self Instance) SetCcdikJointEnableConstraint(joint_idx int, enable_constraint bool) { //gd:SkeletonModification2DCCDIK.set_ccdik_joint_enable_constraint
	Advanced(self).SetCcdikJointEnableConstraint(int64(joint_idx), enable_constraint)
}

/*
Returns whether angle constraints on the CCDIK joint at [param joint_idx] are enabled.
*/
func (self Instance) GetCcdikJointEnableConstraint(joint_idx int) bool { //gd:SkeletonModification2DCCDIK.get_ccdik_joint_enable_constraint
	return bool(Advanced(self).GetCcdikJointEnableConstraint(int64(joint_idx)))
}

/*
Sets the minimum angle constraint for the joint at [param joint_idx].
*/
func (self Instance) SetCcdikJointConstraintAngleMin(joint_idx int, angle_min Angle.Radians) { //gd:SkeletonModification2DCCDIK.set_ccdik_joint_constraint_angle_min
	Advanced(self).SetCcdikJointConstraintAngleMin(int64(joint_idx), float64(angle_min))
}

/*
Returns the minimum angle constraint for the joint at [param joint_idx].
*/
func (self Instance) GetCcdikJointConstraintAngleMin(joint_idx int) Angle.Radians { //gd:SkeletonModification2DCCDIK.get_ccdik_joint_constraint_angle_min
	return Angle.Radians(Float.X(Advanced(self).GetCcdikJointConstraintAngleMin(int64(joint_idx))))
}

/*
Sets the maximum angle constraint for the joint at [param joint_idx].
*/
func (self Instance) SetCcdikJointConstraintAngleMax(joint_idx int, angle_max Angle.Radians) { //gd:SkeletonModification2DCCDIK.set_ccdik_joint_constraint_angle_max
	Advanced(self).SetCcdikJointConstraintAngleMax(int64(joint_idx), float64(angle_max))
}

/*
Returns the maximum angle constraint for the joint at [param joint_idx].
*/
func (self Instance) GetCcdikJointConstraintAngleMax(joint_idx int) Angle.Radians { //gd:SkeletonModification2DCCDIK.get_ccdik_joint_constraint_angle_max
	return Angle.Radians(Float.X(Advanced(self).GetCcdikJointConstraintAngleMax(int64(joint_idx))))
}

/*
Sets whether the CCDIK joint at [param joint_idx] uses an inverted joint constraint.
An inverted joint constraint only constraints the CCDIK joint to the angles [i]outside of[/i] the inputted minimum and maximum angles. For this reason, it is referred to as an inverted joint constraint, as it constraints the joint to the outside of the inputted values.
*/
func (self Instance) SetCcdikJointConstraintAngleInvert(joint_idx int, invert bool) { //gd:SkeletonModification2DCCDIK.set_ccdik_joint_constraint_angle_invert
	Advanced(self).SetCcdikJointConstraintAngleInvert(int64(joint_idx), invert)
}

/*
Returns whether the CCDIK joint at [param joint_idx] uses an inverted joint constraint. See [method set_ccdik_joint_constraint_angle_invert] for details.
*/
func (self Instance) GetCcdikJointConstraintAngleInvert(joint_idx int) bool { //gd:SkeletonModification2DCCDIK.get_ccdik_joint_constraint_angle_invert
	return bool(Advanced(self).GetCcdikJointConstraintAngleInvert(int64(joint_idx)))
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.SkeletonModification2DCCDIK

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = pointers.AsA[gdclass.SkeletonModification2DCCDIK](obj[0])
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = pointers.AsA[gdclass.SkeletonModification2DCCDIK](obj[0])
		return true
	}
	return false
}
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }
func (self *Extension[T]) AsObject() [1]gd.Object { return self.Super().AsObject() }
func New() Instance {
	if !gd.Linked {
		var placeholder = Instance([1]gdclass.SkeletonModification2DCCDIK{pointers.Add[gdclass.SkeletonModification2DCCDIK]([3]uint64{})})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(pointers.AsA[gd.Object](placeholder[0]), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	casted := Instance([1]gdclass.SkeletonModification2DCCDIK{pointers.New[gdclass.SkeletonModification2DCCDIK]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})})
	casted.AsRefCounted()[0].InitRef()
	casted.AsObject()[0].Notification(0, false)
	return casted
}

func (self Instance) TargetNodepath() string {
	return string(class(self).GetTargetNode().String())
}

func (self Instance) SetTargetNodepath(value string) {
	class(self).SetTargetNode(Path.ToNode(String.New(value)))
}

func (self Instance) TipNodepath() string {
	return string(class(self).GetTipNode().String())
}

func (self Instance) SetTipNodepath(value string) {
	class(self).SetTipNode(Path.ToNode(String.New(value)))
}

func (self Instance) CcdikDataChainLength() int {
	return int(int(class(self).GetCcdikDataChainLength()))
}

func (self Instance) SetCcdikDataChainLength(value int) {
	class(self).SetCcdikDataChainLength(int64(value))
}

//go:nosplit
func (self class) SetTargetNode(target_nodepath Path.ToNode) { //gd:SkeletonModification2DCCDIK.set_target_node
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_target_node, 0|(gdextension.SizeNodePath<<4), unsafe.Pointer(&struct{ target_nodepath gdextension.NodePath }{pointers.Get(gd.InternalNodePath(target_nodepath))}))
}

//go:nosplit
func (self class) GetTargetNode() Path.ToNode { //gd:SkeletonModification2DCCDIK.get_target_node
	var r_ret = gdextension.Call[gdextension.NodePath](gd.ObjectChecked(self.AsObject()), methods.get_target_node, gdextension.SizeNodePath, unsafe.Pointer(&struct{}{}))
	var ret = Path.ToNode(String.Via(gd.NodePathProxy{}, pointers.Pack(pointers.New[gd.NodePath](r_ret))))
	return ret
}

//go:nosplit
func (self class) SetTipNode(tip_nodepath Path.ToNode) { //gd:SkeletonModification2DCCDIK.set_tip_node
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_tip_node, 0|(gdextension.SizeNodePath<<4), unsafe.Pointer(&struct{ tip_nodepath gdextension.NodePath }{pointers.Get(gd.InternalNodePath(tip_nodepath))}))
}

//go:nosplit
func (self class) GetTipNode() Path.ToNode { //gd:SkeletonModification2DCCDIK.get_tip_node
	var r_ret = gdextension.Call[gdextension.NodePath](gd.ObjectChecked(self.AsObject()), methods.get_tip_node, gdextension.SizeNodePath, unsafe.Pointer(&struct{}{}))
	var ret = Path.ToNode(String.Via(gd.NodePathProxy{}, pointers.Pack(pointers.New[gd.NodePath](r_ret))))
	return ret
}

//go:nosplit
func (self class) SetCcdikDataChainLength(length int64) { //gd:SkeletonModification2DCCDIK.set_ccdik_data_chain_length
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_ccdik_data_chain_length, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ length int64 }{length}))
}

//go:nosplit
func (self class) GetCcdikDataChainLength() int64 { //gd:SkeletonModification2DCCDIK.get_ccdik_data_chain_length
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_ccdik_data_chain_length, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Sets the [Bone2D] node assigned to the CCDIK joint at [param joint_idx].
*/
//go:nosplit
func (self class) SetCcdikJointBone2dNode(joint_idx int64, bone2d_nodepath Path.ToNode) { //gd:SkeletonModification2DCCDIK.set_ccdik_joint_bone2d_node
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_ccdik_joint_bone2d_node, 0|(gdextension.SizeInt<<4)|(gdextension.SizeNodePath<<8), unsafe.Pointer(&struct {
		joint_idx       int64
		bone2d_nodepath gdextension.NodePath
	}{joint_idx, pointers.Get(gd.InternalNodePath(bone2d_nodepath))}))
}

/*
Returns the [Bone2D] node assigned to the CCDIK joint at [param joint_idx].
*/
//go:nosplit
func (self class) GetCcdikJointBone2dNode(joint_idx int64) Path.ToNode { //gd:SkeletonModification2DCCDIK.get_ccdik_joint_bone2d_node
	var r_ret = gdextension.Call[gdextension.NodePath](gd.ObjectChecked(self.AsObject()), methods.get_ccdik_joint_bone2d_node, gdextension.SizeNodePath|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ joint_idx int64 }{joint_idx}))
	var ret = Path.ToNode(String.Via(gd.NodePathProxy{}, pointers.Pack(pointers.New[gd.NodePath](r_ret))))
	return ret
}

/*
Sets the bone index, [param bone_idx], of the CCDIK joint at [param joint_idx]. When possible, this will also update the [code]bone2d_node[/code] of the CCDIK joint based on data provided by the linked skeleton.
*/
//go:nosplit
func (self class) SetCcdikJointBoneIndex(joint_idx int64, bone_idx int64) { //gd:SkeletonModification2DCCDIK.set_ccdik_joint_bone_index
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_ccdik_joint_bone_index, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		joint_idx int64
		bone_idx  int64
	}{joint_idx, bone_idx}))
}

/*
Returns the index of the [Bone2D] node assigned to the CCDIK joint at [param joint_idx].
*/
//go:nosplit
func (self class) GetCcdikJointBoneIndex(joint_idx int64) int64 { //gd:SkeletonModification2DCCDIK.get_ccdik_joint_bone_index
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_ccdik_joint_bone_index, gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ joint_idx int64 }{joint_idx}))
	var ret = r_ret
	return ret
}

/*
Sets whether the joint at [param joint_idx] is set to rotate from the joint, [code]true[/code], or to rotate from the tip, [code]false[/code].
*/
//go:nosplit
func (self class) SetCcdikJointRotateFromJoint(joint_idx int64, rotate_from_joint bool) { //gd:SkeletonModification2DCCDIK.set_ccdik_joint_rotate_from_joint
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_ccdik_joint_rotate_from_joint, 0|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		joint_idx         int64
		rotate_from_joint bool
	}{joint_idx, rotate_from_joint}))
}

/*
Returns whether the joint at [param joint_idx] is set to rotate from the joint, [code]true[/code], or to rotate from the tip, [code]false[/code]. The default is to rotate from the tip.
*/
//go:nosplit
func (self class) GetCcdikJointRotateFromJoint(joint_idx int64) bool { //gd:SkeletonModification2DCCDIK.get_ccdik_joint_rotate_from_joint
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.get_ccdik_joint_rotate_from_joint, gdextension.SizeBool|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ joint_idx int64 }{joint_idx}))
	var ret = r_ret
	return ret
}

/*
Determines whether angle constraints on the CCDIK joint at [param joint_idx] are enabled. When [code]true[/code], constraints will be enabled and taken into account when solving.
*/
//go:nosplit
func (self class) SetCcdikJointEnableConstraint(joint_idx int64, enable_constraint bool) { //gd:SkeletonModification2DCCDIK.set_ccdik_joint_enable_constraint
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_ccdik_joint_enable_constraint, 0|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		joint_idx         int64
		enable_constraint bool
	}{joint_idx, enable_constraint}))
}

/*
Returns whether angle constraints on the CCDIK joint at [param joint_idx] are enabled.
*/
//go:nosplit
func (self class) GetCcdikJointEnableConstraint(joint_idx int64) bool { //gd:SkeletonModification2DCCDIK.get_ccdik_joint_enable_constraint
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.get_ccdik_joint_enable_constraint, gdextension.SizeBool|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ joint_idx int64 }{joint_idx}))
	var ret = r_ret
	return ret
}

/*
Sets the minimum angle constraint for the joint at [param joint_idx].
*/
//go:nosplit
func (self class) SetCcdikJointConstraintAngleMin(joint_idx int64, angle_min float64) { //gd:SkeletonModification2DCCDIK.set_ccdik_joint_constraint_angle_min
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_ccdik_joint_constraint_angle_min, 0|(gdextension.SizeInt<<4)|(gdextension.SizeFloat<<8), unsafe.Pointer(&struct {
		joint_idx int64
		angle_min float64
	}{joint_idx, angle_min}))
}

/*
Returns the minimum angle constraint for the joint at [param joint_idx].
*/
//go:nosplit
func (self class) GetCcdikJointConstraintAngleMin(joint_idx int64) float64 { //gd:SkeletonModification2DCCDIK.get_ccdik_joint_constraint_angle_min
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_ccdik_joint_constraint_angle_min, gdextension.SizeFloat|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ joint_idx int64 }{joint_idx}))
	var ret = r_ret
	return ret
}

/*
Sets the maximum angle constraint for the joint at [param joint_idx].
*/
//go:nosplit
func (self class) SetCcdikJointConstraintAngleMax(joint_idx int64, angle_max float64) { //gd:SkeletonModification2DCCDIK.set_ccdik_joint_constraint_angle_max
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_ccdik_joint_constraint_angle_max, 0|(gdextension.SizeInt<<4)|(gdextension.SizeFloat<<8), unsafe.Pointer(&struct {
		joint_idx int64
		angle_max float64
	}{joint_idx, angle_max}))
}

/*
Returns the maximum angle constraint for the joint at [param joint_idx].
*/
//go:nosplit
func (self class) GetCcdikJointConstraintAngleMax(joint_idx int64) float64 { //gd:SkeletonModification2DCCDIK.get_ccdik_joint_constraint_angle_max
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_ccdik_joint_constraint_angle_max, gdextension.SizeFloat|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ joint_idx int64 }{joint_idx}))
	var ret = r_ret
	return ret
}

/*
Sets whether the CCDIK joint at [param joint_idx] uses an inverted joint constraint.
An inverted joint constraint only constraints the CCDIK joint to the angles [i]outside of[/i] the inputted minimum and maximum angles. For this reason, it is referred to as an inverted joint constraint, as it constraints the joint to the outside of the inputted values.
*/
//go:nosplit
func (self class) SetCcdikJointConstraintAngleInvert(joint_idx int64, invert bool) { //gd:SkeletonModification2DCCDIK.set_ccdik_joint_constraint_angle_invert
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_ccdik_joint_constraint_angle_invert, 0|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		joint_idx int64
		invert    bool
	}{joint_idx, invert}))
}

/*
Returns whether the CCDIK joint at [param joint_idx] uses an inverted joint constraint. See [method set_ccdik_joint_constraint_angle_invert] for details.
*/
//go:nosplit
func (self class) GetCcdikJointConstraintAngleInvert(joint_idx int64) bool { //gd:SkeletonModification2DCCDIK.get_ccdik_joint_constraint_angle_invert
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.get_ccdik_joint_constraint_angle_invert, gdextension.SizeBool|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ joint_idx int64 }{joint_idx}))
	var ret = r_ret
	return ret
}
func (self class) AsSkeletonModification2DCCDIK() Advanced {
	return Advanced{pointers.AsA[gdclass.SkeletonModification2DCCDIK](self[0])}
}
func (self Instance) AsSkeletonModification2DCCDIK() Instance {
	return Instance{pointers.AsA[gdclass.SkeletonModification2DCCDIK](self[0])}
}
func (self *Extension[T]) AsSkeletonModification2DCCDIK() Instance {
	return self.Super().AsSkeletonModification2DCCDIK()
}
func (self class) AsSkeletonModification2D() SkeletonModification2D.Advanced {
	return SkeletonModification2D.Advanced{pointers.AsA[gdclass.SkeletonModification2D](self[0])}
}
func (self *Extension[T]) AsSkeletonModification2D() SkeletonModification2D.Instance {
	return self.Super().AsSkeletonModification2D()
}
func (self Instance) AsSkeletonModification2D() SkeletonModification2D.Instance {
	return SkeletonModification2D.Instance{pointers.AsA[gdclass.SkeletonModification2D](self[0])}
}
func (self class) AsResource() Resource.Advanced {
	return Resource.Advanced{pointers.AsA[gdclass.Resource](self[0])}
}
func (self *Extension[T]) AsResource() Resource.Instance { return self.Super().AsResource() }
func (self Instance) AsResource() Resource.Instance {
	return Resource.Instance{pointers.AsA[gdclass.Resource](self[0])}
}
func (self class) AsRefCounted() [1]gd.RefCounted {
	return [1]gd.RefCounted{gd.RefCounted(pointers.AsA[gd.Object](self[0]))}
}
func (self *Extension[T]) AsRefCounted() [1]gd.RefCounted { return self.Super().AsRefCounted() }
func (self Instance) AsRefCounted() [1]gd.RefCounted {
	return [1]gd.RefCounted{gd.RefCounted(pointers.AsA[gd.Object](self[0]))}
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(SkeletonModification2D.Advanced(self.AsSkeletonModification2D()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(SkeletonModification2D.Instance(self.AsSkeletonModification2D()), name)
	}
}
func init() {
	gdclass.Register("SkeletonModification2DCCDIK", func(ptr gd.Object) any { return Instance{pointers.AsA[gdclass.SkeletonModification2DCCDIK](ptr)} })
}
