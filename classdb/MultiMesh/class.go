// Code generated by the generate package DO NOT EDIT

// Package MultiMesh provides methods for working with MultiMesh object instances.
package MultiMesh

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/Mesh"
import "graphics.gd/classdb/Resource"
import "graphics.gd/variant/AABB"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Color"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"
import "graphics.gd/variant/Transform2D"
import "graphics.gd/variant/Transform3D"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
MultiMesh provides low-level mesh instancing. Drawing thousands of [MeshInstance3D] nodes can be slow, since each object is submitted to the GPU then drawn individually.
MultiMesh is much faster as it can draw thousands of instances with a single draw call, resulting in less API overhead.
As a drawback, if the instances are too far away from each other, performance may be reduced as every single instance will always render (they are spatially indexed as one, for the whole object).
Since instances may have any behavior, the AABB used for visibility must be provided by the user.
[b]Note:[/b] A MultiMesh is a single object, therefore the same maximum lights per object restriction applies. This means, that once the maximum lights are consumed by one or more instances, the rest of the MultiMesh instances will [b]not[/b] receive any lighting.
[b]Note:[/b] Blend Shapes will be ignored if used in a MultiMesh.
*/
type Instance [1]gdclass.MultiMesh

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	set_mesh                             gdextension.MethodForClass `hash:"194775623"`
	get_mesh                             gdextension.MethodForClass `hash:"1808005922"`
	set_use_colors                       gdextension.MethodForClass `hash:"2586408642"`
	is_using_colors                      gdextension.MethodForClass `hash:"36873697"`
	set_use_custom_data                  gdextension.MethodForClass `hash:"2586408642"`
	is_using_custom_data                 gdextension.MethodForClass `hash:"36873697"`
	set_transform_format                 gdextension.MethodForClass `hash:"2404750322"`
	get_transform_format                 gdextension.MethodForClass `hash:"2444156481"`
	set_instance_count                   gdextension.MethodForClass `hash:"1286410249"`
	get_instance_count                   gdextension.MethodForClass `hash:"3905245786"`
	set_visible_instance_count           gdextension.MethodForClass `hash:"1286410249"`
	get_visible_instance_count           gdextension.MethodForClass `hash:"3905245786"`
	set_physics_interpolation_quality    gdextension.MethodForClass `hash:"1819488408"`
	get_physics_interpolation_quality    gdextension.MethodForClass `hash:"1465701882"`
	set_instance_transform               gdextension.MethodForClass `hash:"3616898986"`
	set_instance_transform_2d            gdextension.MethodForClass `hash:"30160968"`
	get_instance_transform               gdextension.MethodForClass `hash:"1965739696"`
	get_instance_transform_2d            gdextension.MethodForClass `hash:"3836996910"`
	set_instance_color                   gdextension.MethodForClass `hash:"2878471219"`
	get_instance_color                   gdextension.MethodForClass `hash:"3457211756"`
	set_instance_custom_data             gdextension.MethodForClass `hash:"2878471219"`
	get_instance_custom_data             gdextension.MethodForClass `hash:"3457211756"`
	reset_instance_physics_interpolation gdextension.MethodForClass `hash:"1286410249"`
	set_custom_aabb                      gdextension.MethodForClass `hash:"259215842"`
	get_custom_aabb                      gdextension.MethodForClass `hash:"1068685055"`
	get_aabb                             gdextension.MethodForClass `hash:"1068685055"`
	get_buffer                           gdextension.MethodForClass `hash:"675695659"`
	set_buffer                           gdextension.MethodForClass `hash:"2899603908"`
	set_buffer_interpolated              gdextension.MethodForClass `hash:"3514430332"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("MultiMesh")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		pointers.Raw[gd.StringName](sname).Free()
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsMultiMesh() Instance
}

/*
Sets the [Transform3D] for a specific instance.
*/
func (self Instance) SetInstanceTransform(instance int, transform Transform3D.BasisOrigin) { //gd:MultiMesh.set_instance_transform
	Advanced(self).SetInstanceTransform(int64(instance), Transform3D.BasisOrigin(transform))
}

/*
Sets the [Transform2D] for a specific instance.
*/
func (self Instance) SetInstanceTransform2d(instance int, transform Transform2D.OriginXY) { //gd:MultiMesh.set_instance_transform_2d
	Advanced(self).SetInstanceTransform2d(int64(instance), Transform2D.OriginXY(transform))
}

/*
Returns the [Transform3D] of a specific instance.
*/
func (self Instance) GetInstanceTransform(instance int) Transform3D.BasisOrigin { //gd:MultiMesh.get_instance_transform
	return Transform3D.BasisOrigin(Advanced(self).GetInstanceTransform(int64(instance)))
}

/*
Returns the [Transform2D] of a specific instance.
*/
func (self Instance) GetInstanceTransform2d(instance int) Transform2D.OriginXY { //gd:MultiMesh.get_instance_transform_2d
	return Transform2D.OriginXY(Advanced(self).GetInstanceTransform2d(int64(instance)))
}

/*
Sets the color of a specific instance by [i]multiplying[/i] the mesh's existing vertex colors. This allows for different color tinting per instance.
[b]Note:[/b] Each component is stored in 32 bits in the Forward+ and Mobile rendering methods, but is packed into 16 bits in the Compatibility rendering method.
For the color to take effect, ensure that [member use_colors] is [code]true[/code] on the [MultiMesh] and [member BaseMaterial3D.vertex_color_use_as_albedo] is [code]true[/code] on the material. If you intend to set an absolute color instead of tinting, make sure the material's albedo color is set to pure white ([code]Color(1, 1, 1)[/code]).
*/
func (self Instance) SetInstanceColor(instance int, color Color.RGBA) { //gd:MultiMesh.set_instance_color
	Advanced(self).SetInstanceColor(int64(instance), Color.RGBA(color))
}

/*
Gets a specific instance's color multiplier.
*/
func (self Instance) GetInstanceColor(instance int) Color.RGBA { //gd:MultiMesh.get_instance_color
	return Color.RGBA(Advanced(self).GetInstanceColor(int64(instance)))
}

/*
Sets custom data for a specific instance. [param custom_data] is a [Color] type only to contain 4 floating-point numbers.
[b]Note:[/b] Each number is stored in 32 bits in the Forward+ and Mobile rendering methods, but is packed into 16 bits in the Compatibility rendering method.
For the custom data to be used, ensure that [member use_custom_data] is [code]true[/code].
This custom instance data has to be manually accessed in your custom shader using [code]INSTANCE_CUSTOM[/code].
*/
func (self Instance) SetInstanceCustomData(instance int, custom_data Color.RGBA) { //gd:MultiMesh.set_instance_custom_data
	Advanced(self).SetInstanceCustomData(int64(instance), Color.RGBA(custom_data))
}

/*
Returns the custom data that has been set for a specific instance.
*/
func (self Instance) GetInstanceCustomData(instance int) Color.RGBA { //gd:MultiMesh.get_instance_custom_data
	return Color.RGBA(Advanced(self).GetInstanceCustomData(int64(instance)))
}

/*
When using [i]physics interpolation[/i], this function allows you to prevent interpolation on an instance in the current physics tick.
This allows you to move instances instantaneously, and should usually be used when initially placing an instance such as a bullet to prevent graphical glitches.
*/
func (self Instance) ResetInstancePhysicsInterpolation(instance int) { //gd:MultiMesh.reset_instance_physics_interpolation
	Advanced(self).ResetInstancePhysicsInterpolation(int64(instance))
}

/*
Returns the visibility axis-aligned bounding box in local space.
*/
func (self Instance) GetAabb() AABB.PositionSize { //gd:MultiMesh.get_aabb
	return AABB.PositionSize(Advanced(self).GetAabb())
}

/*
An alternative to setting the [member buffer] property, which can be used with [i]physics interpolation[/i]. This method takes two arrays, and can set the data for the current and previous tick in one go. The renderer will automatically interpolate the data at each frame.
This is useful for situations where the order of instances may change from physics tick to tick, such as particle systems.
When the order of instances is coherent, the simpler alternative of setting [member buffer] can still be used with interpolation.
*/
func (self Instance) SetBufferInterpolated(buffer_curr []float32, buffer_prev []float32) { //gd:MultiMesh.set_buffer_interpolated
	Advanced(self).SetBufferInterpolated(Packed.New(buffer_curr...), Packed.New(buffer_prev...))
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.MultiMesh

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.MultiMesh)(unsafe.Pointer(&obj))
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.MultiMesh)(unsafe.Pointer(&obj))
		return true
	}
	return false
}

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {

	if !gd.Linked {
		var placeholder Instance
		*(*gd.Object)(unsafe.Pointer(&placeholder)) = pointers.Add[gd.Object]([3]uint64{})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(*(*gd.Object)(unsafe.Pointer(&placeholder)), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	object := [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})}
	casted := Instance{*(*gdclass.MultiMesh)(unsafe.Pointer(&object))}
	casted.AsRefCounted()[0].Reference()
	object[0].Notification(0, false)
	return casted
}

func (self Instance) TransformFormat() TransformFormat {
	return TransformFormat(class(self).GetTransformFormat())
}

func (self Instance) SetTransformFormat(value TransformFormat) {
	class(self).SetTransformFormat(value)
}

func (self Instance) UseColors() bool {
	return bool(class(self).IsUsingColors())
}

func (self Instance) SetUseColors(value bool) {
	class(self).SetUseColors(value)
}

func (self Instance) UseCustomData() bool {
	return bool(class(self).IsUsingCustomData())
}

func (self Instance) SetUseCustomData(value bool) {
	class(self).SetUseCustomData(value)
}

func (self Instance) CustomAabb() AABB.PositionSize {
	return AABB.PositionSize(class(self).GetCustomAabb())
}

func (self Instance) SetCustomAabb(value AABB.PositionSize) {
	class(self).SetCustomAabb(AABB.PositionSize(value))
}

func (self Instance) InstanceCount() int {
	return int(int(class(self).GetInstanceCount()))
}

func (self Instance) SetInstanceCount(value int) {
	class(self).SetInstanceCount(int64(value))
}

func (self Instance) VisibleInstanceCount() int {
	return int(int(class(self).GetVisibleInstanceCount()))
}

func (self Instance) SetVisibleInstanceCount(value int) {
	class(self).SetVisibleInstanceCount(int64(value))
}

func (self Instance) Mesh() Mesh.Instance {
	return Mesh.Instance(class(self).GetMesh())
}

func (self Instance) SetMesh(value Mesh.Instance) {
	class(self).SetMesh(value)
}

func (self Instance) Buffer() []float32 {
	return []float32(slices.Collect(class(self).GetBuffer().Values()))
}

func (self Instance) SetBuffer(value []float32) {
	class(self).SetBuffer(Packed.New(value...))
}

func (self Instance) PhysicsInterpolationQuality() PhysicsInterpolationQuality {
	return PhysicsInterpolationQuality(class(self).GetPhysicsInterpolationQuality())
}

func (self Instance) SetPhysicsInterpolationQuality(value PhysicsInterpolationQuality) {
	class(self).SetPhysicsInterpolationQuality(value)
}

//go:nosplit
func (self class) SetMesh(mesh [1]gdclass.Mesh) { //gd:MultiMesh.set_mesh
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_mesh, 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ mesh gdextension.Object }{gdextension.Object(gd.ObjectChecked(mesh[0].AsObject()))}))
}

//go:nosplit
func (self class) GetMesh() [1]gdclass.Mesh { //gd:MultiMesh.get_mesh
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_mesh, gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.Mesh{gd.PointerWithOwnershipTransferredToGo[gdclass.Mesh](r_ret)}
	return ret
}

//go:nosplit
func (self class) SetUseColors(enable bool) { //gd:MultiMesh.set_use_colors
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_use_colors, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

//go:nosplit
func (self class) IsUsingColors() bool { //gd:MultiMesh.is_using_colors
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_using_colors, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetUseCustomData(enable bool) { //gd:MultiMesh.set_use_custom_data
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_use_custom_data, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

//go:nosplit
func (self class) IsUsingCustomData() bool { //gd:MultiMesh.is_using_custom_data
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_using_custom_data, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetTransformFormat(format TransformFormat) { //gd:MultiMesh.set_transform_format
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_transform_format, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ format TransformFormat }{format}))
}

//go:nosplit
func (self class) GetTransformFormat() TransformFormat { //gd:MultiMesh.get_transform_format
	var r_ret = gdextension.Call[TransformFormat](gd.ObjectChecked(self.AsObject()), methods.get_transform_format, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetInstanceCount(count int64) { //gd:MultiMesh.set_instance_count
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_instance_count, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ count int64 }{count}))
}

//go:nosplit
func (self class) GetInstanceCount() int64 { //gd:MultiMesh.get_instance_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_instance_count, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetVisibleInstanceCount(count int64) { //gd:MultiMesh.set_visible_instance_count
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_visible_instance_count, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ count int64 }{count}))
}

//go:nosplit
func (self class) GetVisibleInstanceCount() int64 { //gd:MultiMesh.get_visible_instance_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_visible_instance_count, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetPhysicsInterpolationQuality(quality PhysicsInterpolationQuality) { //gd:MultiMesh.set_physics_interpolation_quality
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_physics_interpolation_quality, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ quality PhysicsInterpolationQuality }{quality}))
}

//go:nosplit
func (self class) GetPhysicsInterpolationQuality() PhysicsInterpolationQuality { //gd:MultiMesh.get_physics_interpolation_quality
	var r_ret = gdextension.Call[PhysicsInterpolationQuality](gd.ObjectChecked(self.AsObject()), methods.get_physics_interpolation_quality, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Sets the [Transform3D] for a specific instance.
*/
//go:nosplit
func (self class) SetInstanceTransform(instance int64, transform Transform3D.BasisOrigin) { //gd:MultiMesh.set_instance_transform
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_instance_transform, 0|(gdextension.SizeInt<<4)|(gdextension.SizeTransform3D<<8), unsafe.Pointer(&struct {
		instance  int64
		transform Transform3D.BasisOrigin
	}{instance, gd.Transposed(transform)}))
}

/*
Sets the [Transform2D] for a specific instance.
*/
//go:nosplit
func (self class) SetInstanceTransform2d(instance int64, transform Transform2D.OriginXY) { //gd:MultiMesh.set_instance_transform_2d
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_instance_transform_2d, 0|(gdextension.SizeInt<<4)|(gdextension.SizeTransform2D<<8), unsafe.Pointer(&struct {
		instance  int64
		transform Transform2D.OriginXY
	}{instance, transform}))
}

/*
Returns the [Transform3D] of a specific instance.
*/
//go:nosplit
func (self class) GetInstanceTransform(instance int64) Transform3D.BasisOrigin { //gd:MultiMesh.get_instance_transform
	var r_ret = gdextension.Call[Transform3D.BasisOrigin](gd.ObjectChecked(self.AsObject()), methods.get_instance_transform, gdextension.SizeTransform3D|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ instance int64 }{instance}))
	var ret = gd.Transposed(r_ret)
	return ret
}

/*
Returns the [Transform2D] of a specific instance.
*/
//go:nosplit
func (self class) GetInstanceTransform2d(instance int64) Transform2D.OriginXY { //gd:MultiMesh.get_instance_transform_2d
	var r_ret = gdextension.Call[Transform2D.OriginXY](gd.ObjectChecked(self.AsObject()), methods.get_instance_transform_2d, gdextension.SizeTransform2D|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ instance int64 }{instance}))
	var ret = r_ret
	return ret
}

/*
Sets the color of a specific instance by [i]multiplying[/i] the mesh's existing vertex colors. This allows for different color tinting per instance.
[b]Note:[/b] Each component is stored in 32 bits in the Forward+ and Mobile rendering methods, but is packed into 16 bits in the Compatibility rendering method.
For the color to take effect, ensure that [member use_colors] is [code]true[/code] on the [MultiMesh] and [member BaseMaterial3D.vertex_color_use_as_albedo] is [code]true[/code] on the material. If you intend to set an absolute color instead of tinting, make sure the material's albedo color is set to pure white ([code]Color(1, 1, 1)[/code]).
*/
//go:nosplit
func (self class) SetInstanceColor(instance int64, color Color.RGBA) { //gd:MultiMesh.set_instance_color
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_instance_color, 0|(gdextension.SizeInt<<4)|(gdextension.SizeColor<<8), unsafe.Pointer(&struct {
		instance int64
		color    Color.RGBA
	}{instance, color}))
}

/*
Gets a specific instance's color multiplier.
*/
//go:nosplit
func (self class) GetInstanceColor(instance int64) Color.RGBA { //gd:MultiMesh.get_instance_color
	var r_ret = gdextension.Call[Color.RGBA](gd.ObjectChecked(self.AsObject()), methods.get_instance_color, gdextension.SizeColor|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ instance int64 }{instance}))
	var ret = r_ret
	return ret
}

/*
Sets custom data for a specific instance. [param custom_data] is a [Color] type only to contain 4 floating-point numbers.
[b]Note:[/b] Each number is stored in 32 bits in the Forward+ and Mobile rendering methods, but is packed into 16 bits in the Compatibility rendering method.
For the custom data to be used, ensure that [member use_custom_data] is [code]true[/code].
This custom instance data has to be manually accessed in your custom shader using [code]INSTANCE_CUSTOM[/code].
*/
//go:nosplit
func (self class) SetInstanceCustomData(instance int64, custom_data Color.RGBA) { //gd:MultiMesh.set_instance_custom_data
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_instance_custom_data, 0|(gdextension.SizeInt<<4)|(gdextension.SizeColor<<8), unsafe.Pointer(&struct {
		instance    int64
		custom_data Color.RGBA
	}{instance, custom_data}))
}

/*
Returns the custom data that has been set for a specific instance.
*/
//go:nosplit
func (self class) GetInstanceCustomData(instance int64) Color.RGBA { //gd:MultiMesh.get_instance_custom_data
	var r_ret = gdextension.Call[Color.RGBA](gd.ObjectChecked(self.AsObject()), methods.get_instance_custom_data, gdextension.SizeColor|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ instance int64 }{instance}))
	var ret = r_ret
	return ret
}

/*
When using [i]physics interpolation[/i], this function allows you to prevent interpolation on an instance in the current physics tick.
This allows you to move instances instantaneously, and should usually be used when initially placing an instance such as a bullet to prevent graphical glitches.
*/
//go:nosplit
func (self class) ResetInstancePhysicsInterpolation(instance int64) { //gd:MultiMesh.reset_instance_physics_interpolation
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.reset_instance_physics_interpolation, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ instance int64 }{instance}))
}

//go:nosplit
func (self class) SetCustomAabb(aabb AABB.PositionSize) { //gd:MultiMesh.set_custom_aabb
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_custom_aabb, 0|(gdextension.SizeAABB<<4), unsafe.Pointer(&struct{ aabb AABB.PositionSize }{aabb}))
}

//go:nosplit
func (self class) GetCustomAabb() AABB.PositionSize { //gd:MultiMesh.get_custom_aabb
	var r_ret = gdextension.Call[AABB.PositionSize](gd.ObjectChecked(self.AsObject()), methods.get_custom_aabb, gdextension.SizeAABB, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the visibility axis-aligned bounding box in local space.
*/
//go:nosplit
func (self class) GetAabb() AABB.PositionSize { //gd:MultiMesh.get_aabb
	var r_ret = gdextension.Call[AABB.PositionSize](gd.ObjectChecked(self.AsObject()), methods.get_aabb, gdextension.SizeAABB, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) GetBuffer() Packed.Array[float32] { //gd:MultiMesh.get_buffer
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.get_buffer, gdextension.SizePackedArray, unsafe.Pointer(&struct{}{}))
	var ret = Packed.Array[float32](Array.Through(gd.PackedProxy[gd.PackedFloat32Array, float32]{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

//go:nosplit
func (self class) SetBuffer(buffer Packed.Array[float32]) { //gd:MultiMesh.set_buffer
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_buffer, 0|(gdextension.SizePackedArray<<4), unsafe.Pointer(&struct {
		buffer gdextension.PackedArray[float32]
	}{pointers.Get(gd.InternalPacked[gd.PackedFloat32Array, float32](buffer))}))
}

/*
An alternative to setting the [member buffer] property, which can be used with [i]physics interpolation[/i]. This method takes two arrays, and can set the data for the current and previous tick in one go. The renderer will automatically interpolate the data at each frame.
This is useful for situations where the order of instances may change from physics tick to tick, such as particle systems.
When the order of instances is coherent, the simpler alternative of setting [member buffer] can still be used with interpolation.
*/
//go:nosplit
func (self class) SetBufferInterpolated(buffer_curr Packed.Array[float32], buffer_prev Packed.Array[float32]) { //gd:MultiMesh.set_buffer_interpolated
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_buffer_interpolated, 0|(gdextension.SizePackedArray<<4)|(gdextension.SizePackedArray<<8), unsafe.Pointer(&struct {
		buffer_curr gdextension.PackedArray[float32]
		buffer_prev gdextension.PackedArray[float32]
	}{pointers.Get(gd.InternalPacked[gd.PackedFloat32Array, float32](buffer_curr)), pointers.Get(gd.InternalPacked[gd.PackedFloat32Array, float32](buffer_prev))}))
}
func (self class) AsMultiMesh() Advanced         { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsMultiMesh() Instance      { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsMultiMesh() Instance { return self.Super().AsMultiMesh() }
func (self class) AsResource() Resource.Advanced {
	return *((*Resource.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsResource() Resource.Instance { return self.Super().AsResource() }
func (self Instance) AsResource() Resource.Instance {
	return *((*Resource.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsRefCounted() [1]gd.RefCounted { return self.Super().AsRefCounted() }
func (self Instance) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Resource.Advanced(self.AsResource()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Resource.Instance(self.AsResource()), name)
	}
}
func init() {
	gdclass.Register("MultiMesh", func(ptr gd.Object) any { return *(*Instance)(unsafe.Pointer(&ptr)) })
}

type TransformFormat int //gd:MultiMesh.TransformFormat

const (
	/*Use this when using 2D transforms.*/
	Transform2d TransformFormat = 0
	/*Use this when using 3D transforms.*/
	Transform3d TransformFormat = 1
)

type PhysicsInterpolationQuality int //gd:MultiMesh.PhysicsInterpolationQuality

const (
	/*Always interpolate using Basis lerping, which can produce warping artifacts in some situations.*/
	InterpQualityFast PhysicsInterpolationQuality = 0
	/*Attempt to interpolate using Basis slerping (spherical linear interpolation) where possible, otherwise fall back to lerping.*/
	InterpQualityHigh PhysicsInterpolationQuality = 1
)
