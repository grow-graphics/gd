// Code generated by the generate package DO NOT EDIT

// Package ZIPPacker provides methods for working with ZIPPacker object instances.
package ZIPPacker

import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/variant/Signal"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Signal.Any
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
This class implements a writer that allows storing the multiple blobs in a ZIP archive. See also [ZIPReader] and [PCKPacker].
[codeblock]
# Create a ZIP archive with a single file at its root.
func write_zip_file():

	var writer = ZIPPacker.new()
	var err = writer.open("user://archive.zip")
	if err != OK:
	    return err
	writer.start_file("hello.txt")
	writer.write_file("Hello World".to_utf8_buffer())
	writer.close_file()

	writer.close()
	return OK

[/codeblock]
*/
type Instance [1]gdclass.ZIPPacker

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	open       gdextension.MethodForClass `hash:"1936816515"`
	start_file gdextension.MethodForClass `hash:"166001499"`
	write_file gdextension.MethodForClass `hash:"680677267"`
	close_file gdextension.MethodForClass `hash:"166280745"`
	close      gdextension.MethodForClass `hash:"166280745"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("ZIPPacker")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		gdextension.Free(gdextension.TypeStringName, &sname)
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

type Expanded [1]gdclass.ZIPPacker

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsZIPPacker() Instance
}

/*
Opens a zip file for writing at the given path using the specified write mode.
This must be called before everything else.
*/
func (self Instance) Open(path string) error { //gd:ZIPPacker.open
	return error(gd.ToError(Advanced(self).Open(String.New(path), 0)))
}

/*
Opens a zip file for writing at the given path using the specified write mode.
This must be called before everything else.
*/
func (self Expanded) Open(path string, append ZipAppend) error { //gd:ZIPPacker.open
	return error(gd.ToError(Advanced(self).Open(String.New(path), append)))
}

/*
Starts writing to a file within the archive. Only one file can be written at the same time.
Must be called after [method open].
*/
func (self Instance) StartFile(path string) error { //gd:ZIPPacker.start_file
	return error(gd.ToError(Advanced(self).StartFile(String.New(path))))
}

/*
Write the given [param data] to the file.
Needs to be called after [method start_file].
*/
func (self Instance) WriteFile(data []byte) error { //gd:ZIPPacker.write_file
	return error(gd.ToError(Advanced(self).WriteFile(Packed.Bytes(Packed.New(data...)))))
}

/*
Stops writing to a file within the archive.
It will fail if there is no open file.
*/
func (self Instance) CloseFile() error { //gd:ZIPPacker.close_file
	return error(gd.ToError(Advanced(self).CloseFile()))
}

/*
Closes the underlying resources used by this instance.
*/
func (self Instance) Close() error { //gd:ZIPPacker.close
	return error(gd.ToError(Advanced(self).Close()))
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.ZIPPacker

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = pointers.AsA[gdclass.ZIPPacker](obj[0])
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = pointers.AsA[gdclass.ZIPPacker](obj[0])
		return true
	}
	return false
}
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }
func (self *Extension[T]) AsObject() [1]gd.Object { return self.Super().AsObject() }
func New() Instance {
	if !gd.Linked {
		var placeholder = Instance([1]gdclass.ZIPPacker{pointers.Add[gdclass.ZIPPacker]([3]uint64{})})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(pointers.AsA[gd.Object](placeholder[0]), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	casted := Instance([1]gdclass.ZIPPacker{pointers.New[gdclass.ZIPPacker]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})})
	casted.AsRefCounted()[0].InitRef()
	casted.AsObject()[0].Notification(0, false)
	return casted
}

/*
Opens a zip file for writing at the given path using the specified write mode.
This must be called before everything else.
*/
//go:nosplit
func (self class) Open(path String.Readable, append ZipAppend) Error.Code { //gd:ZIPPacker.open
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.open, gdextension.SizeInt|(gdextension.SizeString<<4)|(gdextension.SizeInt<<8), &struct {
		path   gdextension.String
		append ZipAppend
	}{pointers.Get(gd.InternalString(path)), append})
	var ret = Error.Code(r_ret)
	return ret
}

/*
Starts writing to a file within the archive. Only one file can be written at the same time.
Must be called after [method open].
*/
//go:nosplit
func (self class) StartFile(path String.Readable) Error.Code { //gd:ZIPPacker.start_file
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.start_file, gdextension.SizeInt|(gdextension.SizeString<<4), &struct{ path gdextension.String }{pointers.Get(gd.InternalString(path))})
	var ret = Error.Code(r_ret)
	return ret
}

/*
Write the given [param data] to the file.
Needs to be called after [method start_file].
*/
//go:nosplit
func (self class) WriteFile(data Packed.Bytes) Error.Code { //gd:ZIPPacker.write_file
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.write_file, gdextension.SizeInt|(gdextension.SizePackedArray<<4), &struct{ data gdextension.PackedArray[byte] }{pointers.Get(gd.InternalPacked[gd.PackedByteArray, byte](Packed.Array[byte](data)))})
	var ret = Error.Code(r_ret)
	return ret
}

/*
Stops writing to a file within the archive.
It will fail if there is no open file.
*/
//go:nosplit
func (self class) CloseFile() Error.Code { //gd:ZIPPacker.close_file
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.close_file, gdextension.SizeInt, &struct{}{})
	var ret = Error.Code(r_ret)
	return ret
}

/*
Closes the underlying resources used by this instance.
*/
//go:nosplit
func (self class) Close() Error.Code { //gd:ZIPPacker.close
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.close, gdextension.SizeInt, &struct{}{})
	var ret = Error.Code(r_ret)
	return ret
}
func (self class) AsZIPPacker() Advanced { return Advanced{pointers.AsA[gdclass.ZIPPacker](self[0])} }
func (self Instance) AsZIPPacker() Instance {
	return Instance{pointers.AsA[gdclass.ZIPPacker](self[0])}
}
func (self *Extension[T]) AsZIPPacker() Instance { return self.Super().AsZIPPacker() }
func (self class) AsRefCounted() [1]gd.RefCounted {
	return [1]gd.RefCounted{gd.RefCounted(pointers.AsA[gd.Object](self[0]))}
}
func (self *Extension[T]) AsRefCounted() [1]gd.RefCounted { return self.Super().AsRefCounted() }
func (self Instance) AsRefCounted() [1]gd.RefCounted {
	return [1]gd.RefCounted{gd.RefCounted(pointers.AsA[gd.Object](self[0]))}
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(RefCounted.Advanced(self.AsRefCounted()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(RefCounted.Instance(self.AsRefCounted()), name)
	}
}
func init() {
	gdclass.Register("ZIPPacker", func(ptr gd.Object) any { return Instance{pointers.AsA[gdclass.ZIPPacker](ptr)} })
}

type ZipAppend int //gd:ZIPPacker.ZipAppend

const (
	/*Create a new zip archive at the given path.*/
	AppendCreate ZipAppend = 0
	/*Append a new zip archive to the end of the already existing file at the given path.*/
	AppendCreateafter ZipAppend = 1
	/*Add new files to the existing zip archive at the given path.*/
	AppendAddinzip ZipAppend = 2
)
