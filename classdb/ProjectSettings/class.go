// Code generated by the generate package DO NOT EDIT

// Package ProjectSettings provides methods for working with ProjectSettings object instances.
package ProjectSettings

import "unsafe"
import "sync"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
Stores variables that can be accessed from everywhere. Use [method get_setting], [method set_setting] or [method has_setting] to access them. Variables stored in [code]project.godot[/code] are also loaded into [ProjectSettings], making this object very useful for reading custom game configuration options.
When naming a Project Settings property, use the full path to the setting including the category. For example, [code]"application/config/name"[/code] for the project name. Category and property names can be viewed in the Project Settings dialog.
[b]Feature tags:[/b] Project settings can be overridden for specific platforms and configurations (debug, release, ...) using [url=$DOCS_URL/tutorials/export/feature_tags.html]feature tags[/url].
[b]Overriding:[/b] Any project setting can be overridden by creating a file named [code]override.cfg[/code] in the project's root directory. This can also be used in exported projects by placing this file in the same directory as the project binary. Overriding will still take the base project settings' [url=$DOCS_URL/tutorials/export/feature_tags.html]feature tags[/url] in account. Therefore, make sure to [i]also[/i] override the setting with the desired feature tags if you want them to override base project settings on all platforms and configurations.
*/
type Instance [1]gdclass.ProjectSettings

func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

var self [1]gdclass.ProjectSettings
var once sync.Once

func singleton() {
	obj := gd.Global.Object.GetSingleton(gd.Global.Singletons.ProjectSettings)
	self = *(*[1]gdclass.ProjectSettings)(unsafe.Pointer(&obj))
}

/*
Returns [code]true[/code] if a configuration value is present.
*/
func HasSetting(name string) bool { //gd:ProjectSettings.has_setting
	once.Do(singleton)
	return bool(Advanced().HasSetting(String.New(name)))
}

/*
Sets the value of a setting.
[codeblocks]
[gdscript]
ProjectSettings.set_setting("application/config/name", "Example")
[/gdscript]
[csharp]
ProjectSettings.SetSetting("application/config/name", "Example");
[/csharp]
[/codeblocks]
This can also be used to erase custom project settings. To do this change the setting value to [code]null[/code].
*/
func SetSetting(name string, value any) { //gd:ProjectSettings.set_setting
	once.Do(singleton)
	Advanced().SetSetting(String.New(name), variant.New(value))
}

/*
Returns the value of the setting identified by [param name]. If the setting doesn't exist and [param default_value] is specified, the value of [param default_value] is returned. Otherwise, [code]null[/code] is returned.
[codeblocks]
[gdscript]
print(ProjectSettings.get_setting("application/config/name"))
print(ProjectSettings.get_setting("application/config/custom_description", "No description specified."))
[/gdscript]
[csharp]
GD.Print(ProjectSettings.GetSetting("application/config/name"));
GD.Print(ProjectSettings.GetSetting("application/config/custom_description", "No description specified."));
[/csharp]
[/codeblocks]
[b]Note:[/b] This method doesn't take potential feature overrides into account automatically. Use [method get_setting_with_override] to handle seamlessly.
*/
func GetSetting(name string, default_value any) any { //gd:ProjectSettings.get_setting
	once.Do(singleton)
	return any(Advanced().GetSetting(String.New(name), variant.New(default_value)).Interface())
}

/*
Returns the value of the setting identified by [param name]. If the setting doesn't exist and [param default_value] is specified, the value of [param default_value] is returned. Otherwise, [code]null[/code] is returned.
[codeblocks]
[gdscript]
print(ProjectSettings.get_setting("application/config/name"))
print(ProjectSettings.get_setting("application/config/custom_description", "No description specified."))
[/gdscript]
[csharp]
GD.Print(ProjectSettings.GetSetting("application/config/name"));
GD.Print(ProjectSettings.GetSetting("application/config/custom_description", "No description specified."));
[/csharp]
[/codeblocks]
[b]Note:[/b] This method doesn't take potential feature overrides into account automatically. Use [method get_setting_with_override] to handle seamlessly.
*/
func GetSettingOptions(name string, default_value any) any { //gd:ProjectSettings.get_setting
	once.Do(singleton)
	return any(Advanced().GetSetting(String.New(name), variant.New(default_value)).Interface())
}

/*
Similar to [method get_setting], but applies feature tag overrides if any exists and is valid.
[b]Example:[/b] If the setting override [code]"application/config/name.windows"[/code] exists, and the following code is executed on a [i]Windows[/i] operating system, the overridden setting is printed instead:
[codeblocks]
[gdscript]
print(ProjectSettings.get_setting_with_override("application/config/name"))
[/gdscript]
[csharp]
GD.Print(ProjectSettings.GetSettingWithOverride("application/config/name"));
[/csharp]
[/codeblocks]
*/
func GetSettingWithOverride(name string) any { //gd:ProjectSettings.get_setting_with_override
	once.Do(singleton)
	return any(Advanced().GetSettingWithOverride(String.Name(String.New(name))).Interface())
}

/*
Returns an [Array] of registered global classes. Each global class is represented as a [Dictionary] that contains the following entries:
- [code]base[/code] is a name of the base class;
- [code]class[/code] is a name of the registered global class;
- [code]icon[/code] is a path to a custom icon of the global class, if it has any;
- [code]language[/code] is a name of a programming language in which the global class is written;
- [code]path[/code] is a path to a file containing the global class.
[b]Note:[/b] Both the script and the icon paths are local to the project filesystem, i.e. they start with [code]res://[/code].
*/
func GetGlobalClassList() []GlobalClass { //gd:ProjectSettings.get_global_class_list
	once.Do(singleton)
	return []GlobalClass(gd.ArrayAs[[]GlobalClass](gd.InternalArray(Advanced().GetGlobalClassList())))
}

/*
Sets the order of a configuration value (influences when saved to the config file).
*/
func SetOrder(name string, position int) { //gd:ProjectSettings.set_order
	once.Do(singleton)
	Advanced().SetOrder(String.New(name), int64(position))
}

/*
Returns the order of a configuration value (influences when saved to the config file).
*/
func GetOrder(name string) int { //gd:ProjectSettings.get_order
	once.Do(singleton)
	return int(int(Advanced().GetOrder(String.New(name))))
}

/*
Sets the specified setting's initial value. This is the value the setting reverts to.
*/
func SetInitialValue(name string, value any) { //gd:ProjectSettings.set_initial_value
	once.Do(singleton)
	Advanced().SetInitialValue(String.New(name), variant.New(value))
}

/*
Defines if the specified setting is considered basic or advanced. Basic settings will always be shown in the project settings. Advanced settings will only be shown if the user enables the "Advanced Settings" option.
*/
func SetAsBasic(name string, basic bool) { //gd:ProjectSettings.set_as_basic
	once.Do(singleton)
	Advanced().SetAsBasic(String.New(name), basic)
}

/*
Defines if the specified setting is considered internal. An internal setting won't show up in the Project Settings dialog. This is mostly useful for addons that need to store their own internal settings without exposing them directly to the user.
*/
func SetAsInternal(name string, internal_ bool) { //gd:ProjectSettings.set_as_internal
	once.Do(singleton)
	Advanced().SetAsInternal(String.New(name), internal_)
}

/*
Adds a custom property info to a property. The dictionary must contain:
- [code]"name"[/code]: [String] (the property's name)
- [code]"type"[/code]: [int] (see [enum Variant.Type])
- optionally [code]"hint"[/code]: [int] (see [enum PropertyHint]) and [code]"hint_string"[/code]: [String]
[codeblocks]
[gdscript]
ProjectSettings.set("category/property_name", 0)

	var property_info = {
	    "name": "category/property_name",
	    "type": TYPE_INT,
	    "hint": PROPERTY_HINT_ENUM,
	    "hint_string": "one,two,three"
	}

ProjectSettings.add_property_info(property_info)
[/gdscript]
[csharp]
ProjectSettings.Singleton.Set("category/property_name", 0);

var propertyInfo = new Godot.Collections.Dictionary

	{
	    {"name", "category/propertyName"},
	    {"type", (int)Variant.Type.Int},
	    {"hint", (int)PropertyHint.Enum},
	    {"hint_string", "one,two,three"},
	};

ProjectSettings.AddPropertyInfo(propertyInfo);
[/csharp]
[/codeblocks]
*/
func AddPropertyInfo(hint PropertyInfo) { //gd:ProjectSettings.add_property_info
	once.Do(singleton)
	Advanced().AddPropertyInfo(gd.DictionaryFromMap(hint))
}

/*
Sets whether a setting requires restarting the editor to properly take effect.
[b]Note:[/b] This is just a hint to display to the user that the editor must be restarted for changes to take effect. Enabling [method set_restart_if_changed] does [i]not[/i] delay the setting being set when changed.
*/
func SetRestartIfChanged(name string, restart bool) { //gd:ProjectSettings.set_restart_if_changed
	once.Do(singleton)
	Advanced().SetRestartIfChanged(String.New(name), restart)
}

/*
Clears the whole configuration (not recommended, may break things).
*/
func Clear(name string) { //gd:ProjectSettings.clear
	once.Do(singleton)
	Advanced().Clear(String.New(name))
}

/*
Returns the localized path (starting with [code]res://[/code]) corresponding to the absolute, native OS [param path]. See also [method globalize_path].
*/
func LocalizePath(path string) string { //gd:ProjectSettings.localize_path
	once.Do(singleton)
	return string(Advanced().LocalizePath(String.New(path)).String())
}

/*
Returns the absolute, native OS path corresponding to the localized [param path] (starting with [code]res://[/code] or [code]user://[/code]). The returned path will vary depending on the operating system and user preferences. See [url=$DOCS_URL/tutorials/io/data_paths.html]File paths in Godot projects[/url] to see what those paths convert to. See also [method localize_path].
[b]Note:[/b] [method globalize_path] with [code]res://[/code] will not work in an exported project. Instead, prepend the executable's base directory to the path when running from an exported project:
[codeblock]
var path = ""
if OS.has_feature("editor"):

	# Running from an editor binary.
	# `path` will contain the absolute path to `hello.txt` located in the project root.
	path = ProjectSettings.globalize_path("res://hello.txt")

else:

	# Running from an exported project.
	# `path` will contain the absolute path to `hello.txt` next to the executable.
	# This is *not* identical to using `ProjectSettings.globalize_path()` with a `res://` path,
	# but is close enough in spirit.
	path = OS.get_executable_path().get_base_dir().path_join("hello.txt")

[/codeblock]
*/
func GlobalizePath(path string) string { //gd:ProjectSettings.globalize_path
	once.Do(singleton)
	return string(Advanced().GlobalizePath(String.New(path)).String())
}

/*
Saves the configuration to the [code]project.godot[/code] file.
[b]Note:[/b] This method is intended to be used by editor plugins, as modified [ProjectSettings] can't be loaded back in the running app. If you want to change project settings in exported projects, use [method save_custom] to save [code]override.cfg[/code] file.
*/
func Save() error { //gd:ProjectSettings.save
	once.Do(singleton)
	return error(gd.ToError(Advanced().Save()))
}

/*
Loads the contents of the .pck or .zip file specified by [param pack] into the resource filesystem ([code]res://[/code]). Returns [code]true[/code] on success.
[b]Note:[/b] If a file from [param pack] shares the same path as a file already in the resource filesystem, any attempts to load that file will use the file from [param pack] unless [param replace_files] is set to [code]false[/code].
[b]Note:[/b] The optional [param offset] parameter can be used to specify the offset in bytes to the start of the resource pack. This is only supported for .pck files.
[b]Note:[/b] [DirAccess] will not show changes made to the contents of [code]res://[/code] after calling this function.
*/
func LoadResourcePack(pack string, offset int) bool { //gd:ProjectSettings.load_resource_pack
	once.Do(singleton)
	return bool(Advanced().LoadResourcePack(String.New(pack), true, int64(offset)))
}

/*
Loads the contents of the .pck or .zip file specified by [param pack] into the resource filesystem ([code]res://[/code]). Returns [code]true[/code] on success.
[b]Note:[/b] If a file from [param pack] shares the same path as a file already in the resource filesystem, any attempts to load that file will use the file from [param pack] unless [param replace_files] is set to [code]false[/code].
[b]Note:[/b] The optional [param offset] parameter can be used to specify the offset in bytes to the start of the resource pack. This is only supported for .pck files.
[b]Note:[/b] [DirAccess] will not show changes made to the contents of [code]res://[/code] after calling this function.
*/
func LoadResourcePackOptions(pack string, replace_files bool, offset int) bool { //gd:ProjectSettings.load_resource_pack
	once.Do(singleton)
	return bool(Advanced().LoadResourcePack(String.New(pack), replace_files, int64(offset)))
}

/*
Saves the configuration to a custom file. The file extension must be [code].godot[/code] (to save in text-based [ConfigFile] format) or [code].binary[/code] (to save in binary format). You can also save [code]override.cfg[/code] file, which is also text, but can be used in exported projects unlike other formats.
*/
func SaveCustom(file string) error { //gd:ProjectSettings.save_custom
	once.Do(singleton)
	return error(gd.ToError(Advanced().SaveCustom(String.New(file))))
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
func Advanced() class { once.Do(singleton); return self }

type class [1]gdclass.ProjectSettings

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }

/*
Returns [code]true[/code] if a configuration value is present.
*/
//go:nosplit
func (self class) HasSetting(name String.Readable) bool { //gd:ProjectSettings.has_setting
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(name)))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.ProjectSettings.Bind_has_setting, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Sets the value of a setting.
[codeblocks]
[gdscript]
ProjectSettings.set_setting("application/config/name", "Example")
[/gdscript]
[csharp]
ProjectSettings.SetSetting("application/config/name", "Example");
[/csharp]
[/codeblocks]
This can also be used to erase custom project settings. To do this change the setting value to [code]null[/code].
*/
//go:nosplit
func (self class) SetSetting(name String.Readable, value variant.Any) { //gd:ProjectSettings.set_setting
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(name)))
	callframe.Arg(frame, pointers.Get(gd.InternalVariant(value)))
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.ProjectSettings.Bind_set_setting, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Returns the value of the setting identified by [param name]. If the setting doesn't exist and [param default_value] is specified, the value of [param default_value] is returned. Otherwise, [code]null[/code] is returned.
[codeblocks]
[gdscript]
print(ProjectSettings.get_setting("application/config/name"))
print(ProjectSettings.get_setting("application/config/custom_description", "No description specified."))
[/gdscript]
[csharp]
GD.Print(ProjectSettings.GetSetting("application/config/name"));
GD.Print(ProjectSettings.GetSetting("application/config/custom_description", "No description specified."));
[/csharp]
[/codeblocks]
[b]Note:[/b] This method doesn't take potential feature overrides into account automatically. Use [method get_setting_with_override] to handle seamlessly.
*/
//go:nosplit
func (self class) GetSetting(name String.Readable, default_value variant.Any) variant.Any { //gd:ProjectSettings.get_setting
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(name)))
	callframe.Arg(frame, pointers.Get(gd.InternalVariant(default_value)))
	var r_ret = callframe.Ret[[3]uint64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.ProjectSettings.Bind_get_setting, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = variant.Implementation(gd.VariantProxy{}, pointers.Pack(pointers.New[gd.Variant](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Similar to [method get_setting], but applies feature tag overrides if any exists and is valid.
[b]Example:[/b] If the setting override [code]"application/config/name.windows"[/code] exists, and the following code is executed on a [i]Windows[/i] operating system, the overridden setting is printed instead:
[codeblocks]
[gdscript]
print(ProjectSettings.get_setting_with_override("application/config/name"))
[/gdscript]
[csharp]
GD.Print(ProjectSettings.GetSettingWithOverride("application/config/name"));
[/csharp]
[/codeblocks]
*/
//go:nosplit
func (self class) GetSettingWithOverride(name String.Name) variant.Any { //gd:ProjectSettings.get_setting_with_override
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalStringName(name)))
	var r_ret = callframe.Ret[[3]uint64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.ProjectSettings.Bind_get_setting_with_override, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = variant.Implementation(gd.VariantProxy{}, pointers.Pack(pointers.New[gd.Variant](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Returns an [Array] of registered global classes. Each global class is represented as a [Dictionary] that contains the following entries:
- [code]base[/code] is a name of the base class;
- [code]class[/code] is a name of the registered global class;
- [code]icon[/code] is a path to a custom icon of the global class, if it has any;
- [code]language[/code] is a name of a programming language in which the global class is written;
- [code]path[/code] is a path to a file containing the global class.
[b]Note:[/b] Both the script and the icon paths are local to the project filesystem, i.e. they start with [code]res://[/code].
*/
//go:nosplit
func (self class) GetGlobalClassList() Array.Contains[Dictionary.Any] { //gd:ProjectSettings.get_global_class_list
	var frame = callframe.New()
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.ProjectSettings.Bind_get_global_class_list, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Array.Through(gd.ArrayProxy[Dictionary.Any]{}, pointers.Pack(pointers.New[gd.Array](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Sets the order of a configuration value (influences when saved to the config file).
*/
//go:nosplit
func (self class) SetOrder(name String.Readable, position int64) { //gd:ProjectSettings.set_order
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(name)))
	callframe.Arg(frame, position)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.ProjectSettings.Bind_set_order, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Returns the order of a configuration value (influences when saved to the config file).
*/
//go:nosplit
func (self class) GetOrder(name String.Readable) int64 { //gd:ProjectSettings.get_order
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(name)))
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.ProjectSettings.Bind_get_order, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Sets the specified setting's initial value. This is the value the setting reverts to.
*/
//go:nosplit
func (self class) SetInitialValue(name String.Readable, value variant.Any) { //gd:ProjectSettings.set_initial_value
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(name)))
	callframe.Arg(frame, pointers.Get(gd.InternalVariant(value)))
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.ProjectSettings.Bind_set_initial_value, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Defines if the specified setting is considered basic or advanced. Basic settings will always be shown in the project settings. Advanced settings will only be shown if the user enables the "Advanced Settings" option.
*/
//go:nosplit
func (self class) SetAsBasic(name String.Readable, basic bool) { //gd:ProjectSettings.set_as_basic
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(name)))
	callframe.Arg(frame, basic)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.ProjectSettings.Bind_set_as_basic, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Defines if the specified setting is considered internal. An internal setting won't show up in the Project Settings dialog. This is mostly useful for addons that need to store their own internal settings without exposing them directly to the user.
*/
//go:nosplit
func (self class) SetAsInternal(name String.Readable, internal_ bool) { //gd:ProjectSettings.set_as_internal
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(name)))
	callframe.Arg(frame, internal_)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.ProjectSettings.Bind_set_as_internal, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Adds a custom property info to a property. The dictionary must contain:
- [code]"name"[/code]: [String] (the property's name)
- [code]"type"[/code]: [int] (see [enum Variant.Type])
- optionally [code]"hint"[/code]: [int] (see [enum PropertyHint]) and [code]"hint_string"[/code]: [String]
[codeblocks]
[gdscript]
ProjectSettings.set("category/property_name", 0)

var property_info = {
    "name": "category/property_name",
    "type": TYPE_INT,
    "hint": PROPERTY_HINT_ENUM,
    "hint_string": "one,two,three"
}

ProjectSettings.add_property_info(property_info)
[/gdscript]
[csharp]
ProjectSettings.Singleton.Set("category/property_name", 0);

var propertyInfo = new Godot.Collections.Dictionary
{
    {"name", "category/propertyName"},
    {"type", (int)Variant.Type.Int},
    {"hint", (int)PropertyHint.Enum},
    {"hint_string", "one,two,three"},
};

ProjectSettings.AddPropertyInfo(propertyInfo);
[/csharp]
[/codeblocks]
*/
//go:nosplit
func (self class) AddPropertyInfo(hint Dictionary.Any) { //gd:ProjectSettings.add_property_info
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalDictionary(hint)))
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.ProjectSettings.Bind_add_property_info, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Sets whether a setting requires restarting the editor to properly take effect.
[b]Note:[/b] This is just a hint to display to the user that the editor must be restarted for changes to take effect. Enabling [method set_restart_if_changed] does [i]not[/i] delay the setting being set when changed.
*/
//go:nosplit
func (self class) SetRestartIfChanged(name String.Readable, restart bool) { //gd:ProjectSettings.set_restart_if_changed
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(name)))
	callframe.Arg(frame, restart)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.ProjectSettings.Bind_set_restart_if_changed, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Clears the whole configuration (not recommended, may break things).
*/
//go:nosplit
func (self class) Clear(name String.Readable) { //gd:ProjectSettings.clear
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(name)))
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.ProjectSettings.Bind_clear, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Returns the localized path (starting with [code]res://[/code]) corresponding to the absolute, native OS [param path]. See also [method globalize_path].
*/
//go:nosplit
func (self class) LocalizePath(path String.Readable) String.Readable { //gd:ProjectSettings.localize_path
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(path)))
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.ProjectSettings.Bind_localize_path, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Returns the absolute, native OS path corresponding to the localized [param path] (starting with [code]res://[/code] or [code]user://[/code]). The returned path will vary depending on the operating system and user preferences. See [url=$DOCS_URL/tutorials/io/data_paths.html]File paths in Godot projects[/url] to see what those paths convert to. See also [method localize_path].
[b]Note:[/b] [method globalize_path] with [code]res://[/code] will not work in an exported project. Instead, prepend the executable's base directory to the path when running from an exported project:
[codeblock]
var path = ""
if OS.has_feature("editor"):
    # Running from an editor binary.
    # `path` will contain the absolute path to `hello.txt` located in the project root.
    path = ProjectSettings.globalize_path("res://hello.txt")
else:
    # Running from an exported project.
    # `path` will contain the absolute path to `hello.txt` next to the executable.
    # This is *not* identical to using `ProjectSettings.globalize_path()` with a `res://` path,
    # but is close enough in spirit.
    path = OS.get_executable_path().get_base_dir().path_join("hello.txt")
[/codeblock]
*/
//go:nosplit
func (self class) GlobalizePath(path String.Readable) String.Readable { //gd:ProjectSettings.globalize_path
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(path)))
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.ProjectSettings.Bind_globalize_path, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Saves the configuration to the [code]project.godot[/code] file.
[b]Note:[/b] This method is intended to be used by editor plugins, as modified [ProjectSettings] can't be loaded back in the running app. If you want to change project settings in exported projects, use [method save_custom] to save [code]override.cfg[/code] file.
*/
//go:nosplit
func (self class) Save() Error.Code { //gd:ProjectSettings.save
	var frame = callframe.New()
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.ProjectSettings.Bind_save, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Error.Code(r_ret.Get())
	frame.Free()
	return ret
}

/*
Loads the contents of the .pck or .zip file specified by [param pack] into the resource filesystem ([code]res://[/code]). Returns [code]true[/code] on success.
[b]Note:[/b] If a file from [param pack] shares the same path as a file already in the resource filesystem, any attempts to load that file will use the file from [param pack] unless [param replace_files] is set to [code]false[/code].
[b]Note:[/b] The optional [param offset] parameter can be used to specify the offset in bytes to the start of the resource pack. This is only supported for .pck files.
[b]Note:[/b] [DirAccess] will not show changes made to the contents of [code]res://[/code] after calling this function.
*/
//go:nosplit
func (self class) LoadResourcePack(pack String.Readable, replace_files bool, offset int64) bool { //gd:ProjectSettings.load_resource_pack
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(pack)))
	callframe.Arg(frame, replace_files)
	callframe.Arg(frame, offset)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.ProjectSettings.Bind_load_resource_pack, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Saves the configuration to a custom file. The file extension must be [code].godot[/code] (to save in text-based [ConfigFile] format) or [code].binary[/code] (to save in binary format). You can also save [code]override.cfg[/code] file, which is also text, but can be used in exported projects unlike other formats.
*/
//go:nosplit
func (self class) SaveCustom(file String.Readable) Error.Code { //gd:ProjectSettings.save_custom
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(file)))
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.ProjectSettings.Bind_save_custom, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Error.Code(r_ret.Get())
	frame.Free()
	return ret
}
func OnSettingsChanged(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("settings_changed"), gd.NewCallable(cb), 0)
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Object.Advanced(self.AsObject()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Object.Instance(self.AsObject()), name)
	}
}
func init() {
	gdclass.Register("ProjectSettings", func(ptr gd.Object) any {
		return [1]gdclass.ProjectSettings{*(*gdclass.ProjectSettings)(unsafe.Pointer(&ptr))}
	})
}

type GlobalClass struct {
	Base     string `gd:"base"`
	Class    string `gd:"class"`
	Icon     string `gd:"icon"`
	Language string `gd:"language"`
	Path     string `gd:"path"`
}
type PropertyInfo struct {
	ClassName  string       `gd:"class_name"`
	Name       string       `gd:"name"`
	Hint       int          `gd:"hint"`
	HintString string       `gd:"hint_string"`
	Type       reflect.Type `gd:"type"`
	Usage      int          `gd:"usage"`
}
