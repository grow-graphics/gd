// Code generated by the generate package DO NOT EDIT

// Package ShapeCast3D provides methods for working with ShapeCast3D object instances.
package ShapeCast3D

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/variant/Signal"
import "graphics.gd/classdb/CollisionObject3D"
import "graphics.gd/classdb/Node"
import "graphics.gd/classdb/Node3D"
import "graphics.gd/classdb/Resource"
import "graphics.gd/classdb/Shape3D"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Color"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"
import "graphics.gd/variant/Vector3"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Signal.Any
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
Shape casting allows to detect collision objects by sweeping its [member shape] along the cast direction determined by [member target_position]. This is similar to [RayCast3D], but it allows for sweeping a region of space, rather than just a straight line. [ShapeCast3D] can detect multiple collision objects. It is useful for things like wide laser beams or snapping a simple shape to a floor.
Immediate collision overlaps can be done with the [member target_position] set to [code]Vector3(0, 0, 0)[/code] and by calling [method force_shapecast_update] within the same physics frame. This helps to overcome some limitations of [Area3D] when used as an instantaneous detection area, as collision information isn't immediately available to it.
[b]Note:[/b] Shape casting is more computationally expensive than ray casting.
*/
type Instance [1]gdclass.ShapeCast3D

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	resource_changed                      gdextension.MethodForClass `hash:"968641751"`
	set_enabled                           gdextension.MethodForClass `hash:"2586408642"`
	is_enabled                            gdextension.MethodForClass `hash:"36873697"`
	set_shape                             gdextension.MethodForClass `hash:"1549710052"`
	get_shape                             gdextension.MethodForClass `hash:"3214262478"`
	set_target_position                   gdextension.MethodForClass `hash:"3460891852"`
	get_target_position                   gdextension.MethodForClass `hash:"3360562783"`
	set_margin                            gdextension.MethodForClass `hash:"373806689"`
	get_margin                            gdextension.MethodForClass `hash:"1740695150"`
	set_max_results                       gdextension.MethodForClass `hash:"1286410249"`
	get_max_results                       gdextension.MethodForClass `hash:"3905245786"`
	is_colliding                          gdextension.MethodForClass `hash:"36873697"`
	get_collision_count                   gdextension.MethodForClass `hash:"3905245786"`
	force_shapecast_update                gdextension.MethodForClass `hash:"3218959716"`
	get_collider                          gdextension.MethodForClass `hash:"3332903315"`
	get_collider_rid                      gdextension.MethodForClass `hash:"495598643"`
	get_collider_shape                    gdextension.MethodForClass `hash:"923996154"`
	get_collision_point                   gdextension.MethodForClass `hash:"711720468"`
	get_collision_normal                  gdextension.MethodForClass `hash:"711720468"`
	get_closest_collision_safe_fraction   gdextension.MethodForClass `hash:"1740695150"`
	get_closest_collision_unsafe_fraction gdextension.MethodForClass `hash:"1740695150"`
	add_exception_rid                     gdextension.MethodForClass `hash:"2722037293"`
	add_exception                         gdextension.MethodForClass `hash:"1976431078"`
	remove_exception_rid                  gdextension.MethodForClass `hash:"2722037293"`
	remove_exception                      gdextension.MethodForClass `hash:"1976431078"`
	clear_exceptions                      gdextension.MethodForClass `hash:"3218959716"`
	set_collision_mask                    gdextension.MethodForClass `hash:"1286410249"`
	get_collision_mask                    gdextension.MethodForClass `hash:"3905245786"`
	set_collision_mask_value              gdextension.MethodForClass `hash:"300928843"`
	get_collision_mask_value              gdextension.MethodForClass `hash:"1116898809"`
	set_exclude_parent_body               gdextension.MethodForClass `hash:"2586408642"`
	get_exclude_parent_body               gdextension.MethodForClass `hash:"36873697"`
	set_collide_with_areas                gdextension.MethodForClass `hash:"2586408642"`
	is_collide_with_areas_enabled         gdextension.MethodForClass `hash:"36873697"`
	set_collide_with_bodies               gdextension.MethodForClass `hash:"2586408642"`
	is_collide_with_bodies_enabled        gdextension.MethodForClass `hash:"36873697"`
	get_collision_result                  gdextension.MethodForClass `hash:"3995934104"`
	set_debug_shape_custom_color          gdextension.MethodForClass `hash:"2920490490"`
	get_debug_shape_custom_color          gdextension.MethodForClass `hash:"3444240500"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("ShapeCast3D")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		gdextension.Free(gdextension.TypeStringName, &sname)
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsShapeCast3D() Instance
}

/*
This method does nothing.
*/
func (self Instance) ResourceChanged(resource Resource.Instance) { //gd:ShapeCast3D.resource_changed
	Advanced(self).ResourceChanged(resource)
}

/*
Returns whether any object is intersecting with the shape's vector (considering the vector length).
*/
func (self Instance) IsColliding() bool { //gd:ShapeCast3D.is_colliding
	return bool(Advanced(self).IsColliding())
}

/*
The number of collisions detected at the point of impact. Use this to iterate over multiple collisions as provided by [method get_collider], [method get_collider_shape], [method get_collision_point], and [method get_collision_normal] methods.
*/
func (self Instance) GetCollisionCount() int { //gd:ShapeCast3D.get_collision_count
	return int(int(Advanced(self).GetCollisionCount()))
}

/*
Updates the collision information for the shape immediately, without waiting for the next [code]_physics_process[/code] call. Use this method, for example, when the shape or its parent has changed state.
[b]Note:[/b] Setting [member enabled] to [code]true[/code] is not required for this to work.
*/
func (self Instance) ForceShapecastUpdate() { //gd:ShapeCast3D.force_shapecast_update
	Advanced(self).ForceShapecastUpdate()
}

/*
Returns the collided [Object] of one of the multiple collisions at [param index], or [code]null[/code] if no object is intersecting the shape (i.e. [method is_colliding] returns [code]false[/code]).
*/
func (self Instance) GetCollider(index int) Object.Instance { //gd:ShapeCast3D.get_collider
	return Object.Instance(Advanced(self).GetCollider(int64(index)))
}

/*
Returns the [RID] of the collided object of one of the multiple collisions at [param index].
*/
func (self Instance) GetColliderRid(index int) RID.Body3D { //gd:ShapeCast3D.get_collider_rid
	return RID.Body3D(Advanced(self).GetColliderRid(int64(index)))
}

/*
Returns the shape ID of the colliding shape of one of the multiple collisions at [param index], or [code]0[/code] if no object is intersecting the shape (i.e. [method is_colliding] returns [code]false[/code]).
*/
func (self Instance) GetColliderShape(index int) int { //gd:ShapeCast3D.get_collider_shape
	return int(int(Advanced(self).GetColliderShape(int64(index))))
}

/*
Returns the collision point of one of the multiple collisions at [param index] where the shape intersects the colliding object.
[b]Note:[/b] This point is in the [b]global[/b] coordinate system.
*/
func (self Instance) GetCollisionPoint(index int) Vector3.XYZ { //gd:ShapeCast3D.get_collision_point
	return Vector3.XYZ(Advanced(self).GetCollisionPoint(int64(index)))
}

/*
Returns the normal of one of the multiple collisions at [param index] of the intersecting object.
*/
func (self Instance) GetCollisionNormal(index int) Vector3.XYZ { //gd:ShapeCast3D.get_collision_normal
	return Vector3.XYZ(Advanced(self).GetCollisionNormal(int64(index)))
}

/*
Returns the fraction from this cast's origin to its [member target_position] of how far the shape can move without triggering a collision, as a value between [code]0.0[/code] and [code]1.0[/code].
*/
func (self Instance) GetClosestCollisionSafeFraction() Float.X { //gd:ShapeCast3D.get_closest_collision_safe_fraction
	return Float.X(Float.X(Advanced(self).GetClosestCollisionSafeFraction()))
}

/*
Returns the fraction from this cast's origin to its [member target_position] of how far the shape must move to trigger a collision, as a value between [code]0.0[/code] and [code]1.0[/code].
In ideal conditions this would be the same as [method get_closest_collision_safe_fraction], however shape casting is calculated in discrete steps, so the precise point of collision can occur between two calculated positions.
*/
func (self Instance) GetClosestCollisionUnsafeFraction() Float.X { //gd:ShapeCast3D.get_closest_collision_unsafe_fraction
	return Float.X(Float.X(Advanced(self).GetClosestCollisionUnsafeFraction()))
}

/*
Adds a collision exception so the shape does not report collisions with the specified [RID].
*/
func (self Instance) AddExceptionRid(rid RID.Body3D) { //gd:ShapeCast3D.add_exception_rid
	Advanced(self).AddExceptionRid(RID.Any(rid))
}

/*
Adds a collision exception so the shape does not report collisions with the specified node.
*/
func (self Instance) AddException(node CollisionObject3D.Instance) { //gd:ShapeCast3D.add_exception
	Advanced(self).AddException(node)
}

/*
Removes a collision exception so the shape does report collisions with the specified [RID].
*/
func (self Instance) RemoveExceptionRid(rid RID.Body3D) { //gd:ShapeCast3D.remove_exception_rid
	Advanced(self).RemoveExceptionRid(RID.Any(rid))
}

/*
Removes a collision exception so the shape does report collisions with the specified node.
*/
func (self Instance) RemoveException(node CollisionObject3D.Instance) { //gd:ShapeCast3D.remove_exception
	Advanced(self).RemoveException(node)
}

/*
Removes all collision exceptions for this shape.
*/
func (self Instance) ClearExceptions() { //gd:ShapeCast3D.clear_exceptions
	Advanced(self).ClearExceptions()
}

/*
Based on [param value], enables or disables the specified layer in the [member collision_mask], given a [param layer_number] between 1 and 32.
*/
func (self Instance) SetCollisionMaskValue(layer_number int, value bool) { //gd:ShapeCast3D.set_collision_mask_value
	Advanced(self).SetCollisionMaskValue(int64(layer_number), value)
}

/*
Returns whether or not the specified layer of the [member collision_mask] is enabled, given a [param layer_number] between 1 and 32.
*/
func (self Instance) GetCollisionMaskValue(layer_number int) bool { //gd:ShapeCast3D.get_collision_mask_value
	return bool(Advanced(self).GetCollisionMaskValue(int64(layer_number)))
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.ShapeCast3D

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.ShapeCast3D)(unsafe.Pointer(&obj))
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.ShapeCast3D)(unsafe.Pointer(&obj))
		return true
	}
	return false
}

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {

	if !gd.Linked {
		var placeholder Instance
		*(*gd.Object)(unsafe.Pointer(&placeholder)) = pointers.Add[gd.Object]([3]uint64{})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(*(*gd.Object)(unsafe.Pointer(&placeholder)), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	object := [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})}
	casted := Instance{*(*gdclass.ShapeCast3D)(unsafe.Pointer(&object))}
	object[0].Notification(0, false)
	return casted
}

func (self Instance) Enabled() bool {
	return bool(class(self).IsEnabled())
}

func (self Instance) SetEnabled(value bool) {
	class(self).SetEnabled(value)
}

func (self Instance) Shape() Shape3D.Instance {
	return Shape3D.Instance(class(self).GetShape())
}

func (self Instance) SetShape(value Shape3D.Instance) {
	class(self).SetShape(value)
}

func (self Instance) ExcludeParent() bool {
	return bool(class(self).GetExcludeParentBody())
}

func (self Instance) SetExcludeParent(value bool) {
	class(self).SetExcludeParentBody(value)
}

func (self Instance) TargetPosition() Vector3.XYZ {
	return Vector3.XYZ(class(self).GetTargetPosition())
}

func (self Instance) SetTargetPosition(value Vector3.XYZ) {
	class(self).SetTargetPosition(Vector3.XYZ(value))
}

func (self Instance) Margin() Float.X {
	return Float.X(Float.X(class(self).GetMargin()))
}

func (self Instance) SetMargin(value Float.X) {
	class(self).SetMargin(float64(value))
}

func (self Instance) MaxResults() int {
	return int(int(class(self).GetMaxResults()))
}

func (self Instance) SetMaxResults(value int) {
	class(self).SetMaxResults(int64(value))
}

func (self Instance) CollisionMask() int {
	return int(int(class(self).GetCollisionMask()))
}

func (self Instance) SetCollisionMask(value int) {
	class(self).SetCollisionMask(int64(value))
}

func (self Instance) CollisionResult() []PhysicsDirectSpaceState3D_RestInfo {
	return []PhysicsDirectSpaceState3D_RestInfo(gd.ArrayAs[[]PhysicsDirectSpaceState3D_RestInfo](gd.InternalArray(class(self).GetCollisionResult())))
}

func (self Instance) CollideWithAreas() bool {
	return bool(class(self).IsCollideWithAreasEnabled())
}

func (self Instance) SetCollideWithAreas(value bool) {
	class(self).SetCollideWithAreas(value)
}

func (self Instance) CollideWithBodies() bool {
	return bool(class(self).IsCollideWithBodiesEnabled())
}

func (self Instance) SetCollideWithBodies(value bool) {
	class(self).SetCollideWithBodies(value)
}

func (self Instance) DebugShapeCustomColor() Color.RGBA {
	return Color.RGBA(class(self).GetDebugShapeCustomColor())
}

func (self Instance) SetDebugShapeCustomColor(value Color.RGBA) {
	class(self).SetDebugShapeCustomColor(Color.RGBA(value))
}

/*
This method does nothing.
*/
//go:nosplit
func (self class) ResourceChanged(resource [1]gdclass.Resource) { //gd:ShapeCast3D.resource_changed
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.resource_changed, 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ resource gdextension.Object }{gdextension.Object(gd.ObjectChecked(resource[0].AsObject()))}))
}

//go:nosplit
func (self class) SetEnabled(enabled bool) { //gd:ShapeCast3D.set_enabled
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_enabled, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enabled bool }{enabled}))
}

//go:nosplit
func (self class) IsEnabled() bool { //gd:ShapeCast3D.is_enabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_enabled, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetShape(shape [1]gdclass.Shape3D) { //gd:ShapeCast3D.set_shape
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_shape, 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ shape gdextension.Object }{gdextension.Object(gd.ObjectChecked(shape[0].AsObject()))}))
}

//go:nosplit
func (self class) GetShape() [1]gdclass.Shape3D { //gd:ShapeCast3D.get_shape
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_shape, gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.Shape3D{gd.PointerWithOwnershipTransferredToGo[gdclass.Shape3D](r_ret)}
	return ret
}

//go:nosplit
func (self class) SetTargetPosition(local_point Vector3.XYZ) { //gd:ShapeCast3D.set_target_position
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_target_position, 0|(gdextension.SizeVector3<<4), unsafe.Pointer(&struct{ local_point Vector3.XYZ }{local_point}))
}

//go:nosplit
func (self class) GetTargetPosition() Vector3.XYZ { //gd:ShapeCast3D.get_target_position
	var r_ret = gdextension.Call[Vector3.XYZ](gd.ObjectChecked(self.AsObject()), methods.get_target_position, gdextension.SizeVector3, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetMargin(margin float64) { //gd:ShapeCast3D.set_margin
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_margin, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ margin float64 }{margin}))
}

//go:nosplit
func (self class) GetMargin() float64 { //gd:ShapeCast3D.get_margin
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_margin, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetMaxResults(max_results int64) { //gd:ShapeCast3D.set_max_results
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_max_results, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ max_results int64 }{max_results}))
}

//go:nosplit
func (self class) GetMaxResults() int64 { //gd:ShapeCast3D.get_max_results
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_max_results, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns whether any object is intersecting with the shape's vector (considering the vector length).
*/
//go:nosplit
func (self class) IsColliding() bool { //gd:ShapeCast3D.is_colliding
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_colliding, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
The number of collisions detected at the point of impact. Use this to iterate over multiple collisions as provided by [method get_collider], [method get_collider_shape], [method get_collision_point], and [method get_collision_normal] methods.
*/
//go:nosplit
func (self class) GetCollisionCount() int64 { //gd:ShapeCast3D.get_collision_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_collision_count, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Updates the collision information for the shape immediately, without waiting for the next [code]_physics_process[/code] call. Use this method, for example, when the shape or its parent has changed state.
[b]Note:[/b] Setting [member enabled] to [code]true[/code] is not required for this to work.
*/
//go:nosplit
func (self class) ForceShapecastUpdate() { //gd:ShapeCast3D.force_shapecast_update
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.force_shapecast_update, 0, unsafe.Pointer(&struct{}{}))
}

/*
Returns the collided [Object] of one of the multiple collisions at [param index], or [code]null[/code] if no object is intersecting the shape (i.e. [method is_colliding] returns [code]false[/code]).
*/
//go:nosplit
func (self class) GetCollider(index int64) [1]gd.Object { //gd:ShapeCast3D.get_collider
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_collider, gdextension.SizeObject|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ index int64 }{index}))
	var ret = [1]gd.Object{gd.PointerMustAssertInstanceID[gd.Object](r_ret)}
	return ret
}

/*
Returns the [RID] of the collided object of one of the multiple collisions at [param index].
*/
//go:nosplit
func (self class) GetColliderRid(index int64) RID.Any { //gd:ShapeCast3D.get_collider_rid
	var r_ret = gdextension.Call[RID.Any](gd.ObjectChecked(self.AsObject()), methods.get_collider_rid, gdextension.SizeRID|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ index int64 }{index}))
	var ret = r_ret
	return ret
}

/*
Returns the shape ID of the colliding shape of one of the multiple collisions at [param index], or [code]0[/code] if no object is intersecting the shape (i.e. [method is_colliding] returns [code]false[/code]).
*/
//go:nosplit
func (self class) GetColliderShape(index int64) int64 { //gd:ShapeCast3D.get_collider_shape
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_collider_shape, gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ index int64 }{index}))
	var ret = r_ret
	return ret
}

/*
Returns the collision point of one of the multiple collisions at [param index] where the shape intersects the colliding object.
[b]Note:[/b] This point is in the [b]global[/b] coordinate system.
*/
//go:nosplit
func (self class) GetCollisionPoint(index int64) Vector3.XYZ { //gd:ShapeCast3D.get_collision_point
	var r_ret = gdextension.Call[Vector3.XYZ](gd.ObjectChecked(self.AsObject()), methods.get_collision_point, gdextension.SizeVector3|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ index int64 }{index}))
	var ret = r_ret
	return ret
}

/*
Returns the normal of one of the multiple collisions at [param index] of the intersecting object.
*/
//go:nosplit
func (self class) GetCollisionNormal(index int64) Vector3.XYZ { //gd:ShapeCast3D.get_collision_normal
	var r_ret = gdextension.Call[Vector3.XYZ](gd.ObjectChecked(self.AsObject()), methods.get_collision_normal, gdextension.SizeVector3|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ index int64 }{index}))
	var ret = r_ret
	return ret
}

/*
Returns the fraction from this cast's origin to its [member target_position] of how far the shape can move without triggering a collision, as a value between [code]0.0[/code] and [code]1.0[/code].
*/
//go:nosplit
func (self class) GetClosestCollisionSafeFraction() float64 { //gd:ShapeCast3D.get_closest_collision_safe_fraction
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_closest_collision_safe_fraction, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the fraction from this cast's origin to its [member target_position] of how far the shape must move to trigger a collision, as a value between [code]0.0[/code] and [code]1.0[/code].
In ideal conditions this would be the same as [method get_closest_collision_safe_fraction], however shape casting is calculated in discrete steps, so the precise point of collision can occur between two calculated positions.
*/
//go:nosplit
func (self class) GetClosestCollisionUnsafeFraction() float64 { //gd:ShapeCast3D.get_closest_collision_unsafe_fraction
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_closest_collision_unsafe_fraction, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Adds a collision exception so the shape does not report collisions with the specified [RID].
*/
//go:nosplit
func (self class) AddExceptionRid(rid RID.Any) { //gd:ShapeCast3D.add_exception_rid
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_exception_rid, 0|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ rid RID.Any }{rid}))
}

/*
Adds a collision exception so the shape does not report collisions with the specified node.
*/
//go:nosplit
func (self class) AddException(node [1]gdclass.CollisionObject3D) { //gd:ShapeCast3D.add_exception
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_exception, 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ node gdextension.Object }{gdextension.Object(gd.PointerWithOwnershipTransferredToGodot(node[0].AsObject()[0]))}))
}

/*
Removes a collision exception so the shape does report collisions with the specified [RID].
*/
//go:nosplit
func (self class) RemoveExceptionRid(rid RID.Any) { //gd:ShapeCast3D.remove_exception_rid
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.remove_exception_rid, 0|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ rid RID.Any }{rid}))
}

/*
Removes a collision exception so the shape does report collisions with the specified node.
*/
//go:nosplit
func (self class) RemoveException(node [1]gdclass.CollisionObject3D) { //gd:ShapeCast3D.remove_exception
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.remove_exception, 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ node gdextension.Object }{gdextension.Object(gd.ObjectChecked(node[0].AsObject()))}))
}

/*
Removes all collision exceptions for this shape.
*/
//go:nosplit
func (self class) ClearExceptions() { //gd:ShapeCast3D.clear_exceptions
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.clear_exceptions, 0, unsafe.Pointer(&struct{}{}))
}

//go:nosplit
func (self class) SetCollisionMask(mask int64) { //gd:ShapeCast3D.set_collision_mask
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_collision_mask, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ mask int64 }{mask}))
}

//go:nosplit
func (self class) GetCollisionMask() int64 { //gd:ShapeCast3D.get_collision_mask
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_collision_mask, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Based on [param value], enables or disables the specified layer in the [member collision_mask], given a [param layer_number] between 1 and 32.
*/
//go:nosplit
func (self class) SetCollisionMaskValue(layer_number int64, value bool) { //gd:ShapeCast3D.set_collision_mask_value
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_collision_mask_value, 0|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		layer_number int64
		value        bool
	}{layer_number, value}))
}

/*
Returns whether or not the specified layer of the [member collision_mask] is enabled, given a [param layer_number] between 1 and 32.
*/
//go:nosplit
func (self class) GetCollisionMaskValue(layer_number int64) bool { //gd:ShapeCast3D.get_collision_mask_value
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.get_collision_mask_value, gdextension.SizeBool|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ layer_number int64 }{layer_number}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetExcludeParentBody(mask bool) { //gd:ShapeCast3D.set_exclude_parent_body
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_exclude_parent_body, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ mask bool }{mask}))
}

//go:nosplit
func (self class) GetExcludeParentBody() bool { //gd:ShapeCast3D.get_exclude_parent_body
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.get_exclude_parent_body, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetCollideWithAreas(enable bool) { //gd:ShapeCast3D.set_collide_with_areas
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_collide_with_areas, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

//go:nosplit
func (self class) IsCollideWithAreasEnabled() bool { //gd:ShapeCast3D.is_collide_with_areas_enabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_collide_with_areas_enabled, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetCollideWithBodies(enable bool) { //gd:ShapeCast3D.set_collide_with_bodies
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_collide_with_bodies, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

//go:nosplit
func (self class) IsCollideWithBodiesEnabled() bool { //gd:ShapeCast3D.is_collide_with_bodies_enabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_collide_with_bodies_enabled, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) GetCollisionResult() Array.Any { //gd:ShapeCast3D.get_collision_result
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), methods.get_collision_result, gdextension.SizeArray, unsafe.Pointer(&struct{}{}))
	var ret = Array.Through(gd.ArrayProxy[variant.Any]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

//go:nosplit
func (self class) SetDebugShapeCustomColor(debug_shape_custom_color Color.RGBA) { //gd:ShapeCast3D.set_debug_shape_custom_color
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_debug_shape_custom_color, 0|(gdextension.SizeColor<<4), unsafe.Pointer(&struct{ debug_shape_custom_color Color.RGBA }{debug_shape_custom_color}))
}

//go:nosplit
func (self class) GetDebugShapeCustomColor() Color.RGBA { //gd:ShapeCast3D.get_debug_shape_custom_color
	var r_ret = gdextension.Call[Color.RGBA](gd.ObjectChecked(self.AsObject()), methods.get_debug_shape_custom_color, gdextension.SizeColor, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}
func (self class) AsShapeCast3D() Advanced           { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsShapeCast3D() Instance        { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsShapeCast3D() Instance   { return self.Super().AsShapeCast3D() }
func (self class) AsNode3D() Node3D.Advanced         { return *((*Node3D.Advanced)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsNode3D() Node3D.Instance { return self.Super().AsNode3D() }
func (self Instance) AsNode3D() Node3D.Instance      { return *((*Node3D.Instance)(unsafe.Pointer(&self))) }
func (self class) AsNode() Node.Advanced             { return *((*Node.Advanced)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsNode() Node.Instance     { return self.Super().AsNode() }
func (self Instance) AsNode() Node.Instance          { return *((*Node.Instance)(unsafe.Pointer(&self))) }

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Node3D.Advanced(self.AsNode3D()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Node3D.Instance(self.AsNode3D()), name)
	}
}
func init() {
	gdclass.Register("ShapeCast3D", func(ptr gd.Object) any { return *(*Instance)(unsafe.Pointer(&ptr)) })
}

type PhysicsDirectSpaceState3D_RestInfo struct {
	ColliderID     Object.ID `gd:"collider_id"`
	LinearVelocity struct {
		X float32
		Y float32
		Z float32
	} `gd:"linear_velocity"`
	Normal struct {
		X float32
		Y float32
		Z float32
	} `gd:"normal"`
	Point struct {
		X float32
		Y float32
		Z float32
	} `gd:"point"`
	RID   RID.Any `gd:"rid"`
	Shape int     `gd:"shape"`
}
