// Code generated by the generate package DO NOT EDIT

// Package Area2D provides methods for working with Area2D object instances.
package Area2D

import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/variant/Signal"
import "graphics.gd/classdb/CanvasItem"
import "graphics.gd/classdb/CollisionObject2D"
import "graphics.gd/classdb/Node"
import "graphics.gd/classdb/Node2D"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"
import "graphics.gd/variant/Vector2"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Signal.Any
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
[Area2D] is a region of 2D space defined by one or multiple [CollisionShape2D] or [CollisionPolygon2D] child nodes. It detects when other [CollisionObject2D]s enter or exit it, and it also keeps track of which collision objects haven't exited it yet (i.e. which one are overlapping it).
This node can also locally alter or override physics parameters (gravity, damping) and route audio to custom audio buses.
[b]Note:[/b] Areas and bodies created with [PhysicsServer2D] might not interact as expected with [Area2D]s, and might not emit signals or track objects correctly.
*/
type Instance [1]gdclass.Area2D

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	set_gravity_space_override_mode      gdextension.MethodForClass `hash:"2879900038"`
	get_gravity_space_override_mode      gdextension.MethodForClass `hash:"3990256304"`
	set_gravity_is_point                 gdextension.MethodForClass `hash:"2586408642"`
	is_gravity_a_point                   gdextension.MethodForClass `hash:"36873697"`
	set_gravity_point_unit_distance      gdextension.MethodForClass `hash:"373806689"`
	get_gravity_point_unit_distance      gdextension.MethodForClass `hash:"1740695150"`
	set_gravity_point_center             gdextension.MethodForClass `hash:"743155724"`
	get_gravity_point_center             gdextension.MethodForClass `hash:"3341600327"`
	set_gravity_direction                gdextension.MethodForClass `hash:"743155724"`
	get_gravity_direction                gdextension.MethodForClass `hash:"3341600327"`
	set_gravity                          gdextension.MethodForClass `hash:"373806689"`
	get_gravity                          gdextension.MethodForClass `hash:"1740695150"`
	set_linear_damp_space_override_mode  gdextension.MethodForClass `hash:"2879900038"`
	get_linear_damp_space_override_mode  gdextension.MethodForClass `hash:"3990256304"`
	set_angular_damp_space_override_mode gdextension.MethodForClass `hash:"2879900038"`
	get_angular_damp_space_override_mode gdextension.MethodForClass `hash:"3990256304"`
	set_linear_damp                      gdextension.MethodForClass `hash:"373806689"`
	get_linear_damp                      gdextension.MethodForClass `hash:"1740695150"`
	set_angular_damp                     gdextension.MethodForClass `hash:"373806689"`
	get_angular_damp                     gdextension.MethodForClass `hash:"1740695150"`
	set_priority                         gdextension.MethodForClass `hash:"1286410249"`
	get_priority                         gdextension.MethodForClass `hash:"3905245786"`
	set_monitoring                       gdextension.MethodForClass `hash:"2586408642"`
	is_monitoring                        gdextension.MethodForClass `hash:"36873697"`
	set_monitorable                      gdextension.MethodForClass `hash:"2586408642"`
	is_monitorable                       gdextension.MethodForClass `hash:"36873697"`
	get_overlapping_bodies               gdextension.MethodForClass `hash:"3995934104"`
	get_overlapping_areas                gdextension.MethodForClass `hash:"3995934104"`
	has_overlapping_bodies               gdextension.MethodForClass `hash:"36873697"`
	has_overlapping_areas                gdextension.MethodForClass `hash:"36873697"`
	overlaps_body                        gdextension.MethodForClass `hash:"3093956946"`
	overlaps_area                        gdextension.MethodForClass `hash:"3093956946"`
	set_audio_bus_name                   gdextension.MethodForClass `hash:"3304788590"`
	get_audio_bus_name                   gdextension.MethodForClass `hash:"2002593661"`
	set_audio_bus_override               gdextension.MethodForClass `hash:"2586408642"`
	is_overriding_audio_bus              gdextension.MethodForClass `hash:"36873697"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("Area2D")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		gdextension.Free(gdextension.TypeStringName, &sname)
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsArea2D() Instance
}

/*
Returns a list of intersecting [PhysicsBody2D]s and [TileMap]s. The overlapping body's [member CollisionObject2D.collision_layer] must be part of this area's [member CollisionObject2D.collision_mask] in order to be detected.
For performance reasons (collisions are all processed at the same time) this list is modified once during the physics step, not immediately after objects are moved. Consider using signals instead.
*/
func (self Instance) GetOverlappingBodies() []Node2D.Instance { //gd:Area2D.get_overlapping_bodies
	return []Node2D.Instance(gd.ArrayAs[[]Node2D.Instance](gd.InternalArray(Advanced(self).GetOverlappingBodies())))
}

/*
Returns a list of intersecting [Area2D]s. The overlapping area's [member CollisionObject2D.collision_layer] must be part of this area's [member CollisionObject2D.collision_mask] in order to be detected.
For performance reasons (collisions are all processed at the same time) this list is modified once during the physics step, not immediately after objects are moved. Consider using signals instead.
*/
func (self Instance) GetOverlappingAreas() []Instance { //gd:Area2D.get_overlapping_areas
	return []Instance(gd.ArrayAs[[]Instance](gd.InternalArray(Advanced(self).GetOverlappingAreas())))
}

/*
Returns [code]true[/code] if intersecting any [PhysicsBody2D]s or [TileMap]s, otherwise returns [code]false[/code]. The overlapping body's [member CollisionObject2D.collision_layer] must be part of this area's [member CollisionObject2D.collision_mask] in order to be detected.
For performance reasons (collisions are all processed at the same time) the list of overlapping bodies is modified once during the physics step, not immediately after objects are moved. Consider using signals instead.
*/
func (self Instance) HasOverlappingBodies() bool { //gd:Area2D.has_overlapping_bodies
	return bool(Advanced(self).HasOverlappingBodies())
}

/*
Returns [code]true[/code] if intersecting any [Area2D]s, otherwise returns [code]false[/code]. The overlapping area's [member CollisionObject2D.collision_layer] must be part of this area's [member CollisionObject2D.collision_mask] in order to be detected.
For performance reasons (collisions are all processed at the same time) the list of overlapping areas is modified once during the physics step, not immediately after objects are moved. Consider using signals instead.
*/
func (self Instance) HasOverlappingAreas() bool { //gd:Area2D.has_overlapping_areas
	return bool(Advanced(self).HasOverlappingAreas())
}

/*
Returns [code]true[/code] if the given physics body intersects or overlaps this [Area2D], [code]false[/code] otherwise.
[b]Note:[/b] The result of this test is not immediate after moving objects. For performance, list of overlaps is updated once per frame and before the physics step. Consider using signals instead.
The [param body] argument can either be a [PhysicsBody2D] or a [TileMap] instance. While TileMaps are not physics bodies themselves, they register their tiles with collision shapes as a virtual physics body.
*/
func (self Instance) OverlapsBody(body Node.Instance) bool { //gd:Area2D.overlaps_body
	return bool(Advanced(self).OverlapsBody(body))
}

/*
Returns [code]true[/code] if the given [Area2D] intersects or overlaps this [Area2D], [code]false[/code] otherwise.
[b]Note:[/b] The result of this test is not immediate after moving objects. For performance, the list of overlaps is updated once per frame and before the physics step. Consider using signals instead.
*/
func (self Instance) OverlapsArea(area Node.Instance) bool { //gd:Area2D.overlaps_area
	return bool(Advanced(self).OverlapsArea(area))
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.Area2D

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = pointers.AsA[gdclass.Area2D](obj[0])
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = pointers.AsA[gdclass.Area2D](obj[0])
		return true
	}
	return false
}
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }
func (self *Extension[T]) AsObject() [1]gd.Object { return self.Super().AsObject() }
func New() Instance {
	if !gd.Linked {
		var placeholder = Instance([1]gdclass.Area2D{pointers.Add[gdclass.Area2D]([3]uint64{})})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(pointers.AsA[gd.Object](placeholder[0]), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	casted := Instance([1]gdclass.Area2D{pointers.New[gdclass.Area2D]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})})
	casted.AsObject()[0].Notification(0, false)
	return casted
}

func (self Instance) Monitoring() bool {
	return bool(class(self).IsMonitoring())
}

func (self Instance) SetMonitoring(value bool) {
	class(self).SetMonitoring(value)
}

func (self Instance) Monitorable() bool {
	return bool(class(self).IsMonitorable())
}

func (self Instance) SetMonitorable(value bool) {
	class(self).SetMonitorable(value)
}

func (self Instance) Priority() int {
	return int(int(class(self).GetPriority()))
}

func (self Instance) SetPriority(value int) {
	class(self).SetPriority(int64(value))
}

func (self Instance) GravitySpaceOverride() SpaceOverride {
	return SpaceOverride(class(self).GetGravitySpaceOverrideMode())
}

func (self Instance) SetGravitySpaceOverride(value SpaceOverride) {
	class(self).SetGravitySpaceOverrideMode(value)
}

func (self Instance) GravityPoint() bool {
	return bool(class(self).IsGravityAPoint())
}

func (self Instance) SetGravityPoint(value bool) {
	class(self).SetGravityIsPoint(value)
}

func (self Instance) GravityPointUnitDistance() Float.X {
	return Float.X(Float.X(class(self).GetGravityPointUnitDistance()))
}

func (self Instance) SetGravityPointUnitDistance(value Float.X) {
	class(self).SetGravityPointUnitDistance(float64(value))
}

func (self Instance) GravityPointCenter() Vector2.XY {
	return Vector2.XY(class(self).GetGravityPointCenter())
}

func (self Instance) SetGravityPointCenter(value Vector2.XY) {
	class(self).SetGravityPointCenter(Vector2.XY(value))
}

func (self Instance) GravityDirection() Vector2.XY {
	return Vector2.XY(class(self).GetGravityDirection())
}

func (self Instance) SetGravityDirection(value Vector2.XY) {
	class(self).SetGravityDirection(Vector2.XY(value))
}

func (self Instance) Gravity() Float.X {
	return Float.X(Float.X(class(self).GetGravity()))
}

func (self Instance) SetGravity(value Float.X) {
	class(self).SetGravity(float64(value))
}

func (self Instance) LinearDampSpaceOverride() SpaceOverride {
	return SpaceOverride(class(self).GetLinearDampSpaceOverrideMode())
}

func (self Instance) SetLinearDampSpaceOverride(value SpaceOverride) {
	class(self).SetLinearDampSpaceOverrideMode(value)
}

func (self Instance) LinearDamp() Float.X {
	return Float.X(Float.X(class(self).GetLinearDamp()))
}

func (self Instance) SetLinearDamp(value Float.X) {
	class(self).SetLinearDamp(float64(value))
}

func (self Instance) AngularDampSpaceOverride() SpaceOverride {
	return SpaceOverride(class(self).GetAngularDampSpaceOverrideMode())
}

func (self Instance) SetAngularDampSpaceOverride(value SpaceOverride) {
	class(self).SetAngularDampSpaceOverrideMode(value)
}

func (self Instance) AngularDamp() Float.X {
	return Float.X(Float.X(class(self).GetAngularDamp()))
}

func (self Instance) SetAngularDamp(value Float.X) {
	class(self).SetAngularDamp(float64(value))
}

func (self Instance) AudioBusOverride() bool {
	return bool(class(self).IsOverridingAudioBus())
}

func (self Instance) SetAudioBusOverride(value bool) {
	class(self).SetAudioBusOverride(value)
}

func (self Instance) AudioBusName() string {
	return string(class(self).GetAudioBusName().String())
}

func (self Instance) SetAudioBusName(value string) {
	class(self).SetAudioBusName(String.Name(String.New(value)))
}

//go:nosplit
func (self class) SetGravitySpaceOverrideMode(space_override_mode SpaceOverride) { //gd:Area2D.set_gravity_space_override_mode
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_gravity_space_override_mode, 0|(gdextension.SizeInt<<4), &struct{ space_override_mode SpaceOverride }{space_override_mode})
}

//go:nosplit
func (self class) GetGravitySpaceOverrideMode() SpaceOverride { //gd:Area2D.get_gravity_space_override_mode
	var r_ret = gdextension.Call[SpaceOverride](gd.ObjectChecked(self.AsObject()), methods.get_gravity_space_override_mode, gdextension.SizeInt, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetGravityIsPoint(enable bool) { //gd:Area2D.set_gravity_is_point
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_gravity_is_point, 0|(gdextension.SizeBool<<4), &struct{ enable bool }{enable})
}

//go:nosplit
func (self class) IsGravityAPoint() bool { //gd:Area2D.is_gravity_a_point
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_gravity_a_point, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetGravityPointUnitDistance(distance_scale float64) { //gd:Area2D.set_gravity_point_unit_distance
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_gravity_point_unit_distance, 0|(gdextension.SizeFloat<<4), &struct{ distance_scale float64 }{distance_scale})
}

//go:nosplit
func (self class) GetGravityPointUnitDistance() float64 { //gd:Area2D.get_gravity_point_unit_distance
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_gravity_point_unit_distance, gdextension.SizeFloat, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetGravityPointCenter(center Vector2.XY) { //gd:Area2D.set_gravity_point_center
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_gravity_point_center, 0|(gdextension.SizeVector2<<4), &struct{ center Vector2.XY }{center})
}

//go:nosplit
func (self class) GetGravityPointCenter() Vector2.XY { //gd:Area2D.get_gravity_point_center
	var r_ret = gdextension.Call[Vector2.XY](gd.ObjectChecked(self.AsObject()), methods.get_gravity_point_center, gdextension.SizeVector2, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetGravityDirection(direction Vector2.XY) { //gd:Area2D.set_gravity_direction
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_gravity_direction, 0|(gdextension.SizeVector2<<4), &struct{ direction Vector2.XY }{direction})
}

//go:nosplit
func (self class) GetGravityDirection() Vector2.XY { //gd:Area2D.get_gravity_direction
	var r_ret = gdextension.Call[Vector2.XY](gd.ObjectChecked(self.AsObject()), methods.get_gravity_direction, gdextension.SizeVector2, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetGravity(gravity float64) { //gd:Area2D.set_gravity
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_gravity, 0|(gdextension.SizeFloat<<4), &struct{ gravity float64 }{gravity})
}

//go:nosplit
func (self class) GetGravity() float64 { //gd:Area2D.get_gravity
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_gravity, gdextension.SizeFloat, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetLinearDampSpaceOverrideMode(space_override_mode SpaceOverride) { //gd:Area2D.set_linear_damp_space_override_mode
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_linear_damp_space_override_mode, 0|(gdextension.SizeInt<<4), &struct{ space_override_mode SpaceOverride }{space_override_mode})
}

//go:nosplit
func (self class) GetLinearDampSpaceOverrideMode() SpaceOverride { //gd:Area2D.get_linear_damp_space_override_mode
	var r_ret = gdextension.Call[SpaceOverride](gd.ObjectChecked(self.AsObject()), methods.get_linear_damp_space_override_mode, gdextension.SizeInt, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetAngularDampSpaceOverrideMode(space_override_mode SpaceOverride) { //gd:Area2D.set_angular_damp_space_override_mode
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_angular_damp_space_override_mode, 0|(gdextension.SizeInt<<4), &struct{ space_override_mode SpaceOverride }{space_override_mode})
}

//go:nosplit
func (self class) GetAngularDampSpaceOverrideMode() SpaceOverride { //gd:Area2D.get_angular_damp_space_override_mode
	var r_ret = gdextension.Call[SpaceOverride](gd.ObjectChecked(self.AsObject()), methods.get_angular_damp_space_override_mode, gdextension.SizeInt, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetLinearDamp(linear_damp float64) { //gd:Area2D.set_linear_damp
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_linear_damp, 0|(gdextension.SizeFloat<<4), &struct{ linear_damp float64 }{linear_damp})
}

//go:nosplit
func (self class) GetLinearDamp() float64 { //gd:Area2D.get_linear_damp
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_linear_damp, gdextension.SizeFloat, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetAngularDamp(angular_damp float64) { //gd:Area2D.set_angular_damp
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_angular_damp, 0|(gdextension.SizeFloat<<4), &struct{ angular_damp float64 }{angular_damp})
}

//go:nosplit
func (self class) GetAngularDamp() float64 { //gd:Area2D.get_angular_damp
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_angular_damp, gdextension.SizeFloat, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetPriority(priority int64) { //gd:Area2D.set_priority
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_priority, 0|(gdextension.SizeInt<<4), &struct{ priority int64 }{priority})
}

//go:nosplit
func (self class) GetPriority() int64 { //gd:Area2D.get_priority
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_priority, gdextension.SizeInt, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetMonitoring(enable bool) { //gd:Area2D.set_monitoring
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_monitoring, 0|(gdextension.SizeBool<<4), &struct{ enable bool }{enable})
}

//go:nosplit
func (self class) IsMonitoring() bool { //gd:Area2D.is_monitoring
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_monitoring, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetMonitorable(enable bool) { //gd:Area2D.set_monitorable
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_monitorable, 0|(gdextension.SizeBool<<4), &struct{ enable bool }{enable})
}

//go:nosplit
func (self class) IsMonitorable() bool { //gd:Area2D.is_monitorable
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_monitorable, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

/*
Returns a list of intersecting [PhysicsBody2D]s and [TileMap]s. The overlapping body's [member CollisionObject2D.collision_layer] must be part of this area's [member CollisionObject2D.collision_mask] in order to be detected.
For performance reasons (collisions are all processed at the same time) this list is modified once during the physics step, not immediately after objects are moved. Consider using signals instead.
*/
//go:nosplit
func (self class) GetOverlappingBodies() Array.Contains[[1]gdclass.Node2D] { //gd:Area2D.get_overlapping_bodies
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), methods.get_overlapping_bodies, gdextension.SizeArray, &struct{}{})
	var ret = Array.Through(gd.ArrayProxy[[1]gdclass.Node2D]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

/*
Returns a list of intersecting [Area2D]s. The overlapping area's [member CollisionObject2D.collision_layer] must be part of this area's [member CollisionObject2D.collision_mask] in order to be detected.
For performance reasons (collisions are all processed at the same time) this list is modified once during the physics step, not immediately after objects are moved. Consider using signals instead.
*/
//go:nosplit
func (self class) GetOverlappingAreas() Array.Contains[[1]gdclass.Area2D] { //gd:Area2D.get_overlapping_areas
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), methods.get_overlapping_areas, gdextension.SizeArray, &struct{}{})
	var ret = Array.Through(gd.ArrayProxy[[1]gdclass.Area2D]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

/*
Returns [code]true[/code] if intersecting any [PhysicsBody2D]s or [TileMap]s, otherwise returns [code]false[/code]. The overlapping body's [member CollisionObject2D.collision_layer] must be part of this area's [member CollisionObject2D.collision_mask] in order to be detected.
For performance reasons (collisions are all processed at the same time) the list of overlapping bodies is modified once during the physics step, not immediately after objects are moved. Consider using signals instead.
*/
//go:nosplit
func (self class) HasOverlappingBodies() bool { //gd:Area2D.has_overlapping_bodies
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.has_overlapping_bodies, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if intersecting any [Area2D]s, otherwise returns [code]false[/code]. The overlapping area's [member CollisionObject2D.collision_layer] must be part of this area's [member CollisionObject2D.collision_mask] in order to be detected.
For performance reasons (collisions are all processed at the same time) the list of overlapping areas is modified once during the physics step, not immediately after objects are moved. Consider using signals instead.
*/
//go:nosplit
func (self class) HasOverlappingAreas() bool { //gd:Area2D.has_overlapping_areas
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.has_overlapping_areas, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if the given physics body intersects or overlaps this [Area2D], [code]false[/code] otherwise.
[b]Note:[/b] The result of this test is not immediate after moving objects. For performance, list of overlaps is updated once per frame and before the physics step. Consider using signals instead.
The [param body] argument can either be a [PhysicsBody2D] or a [TileMap] instance. While TileMaps are not physics bodies themselves, they register their tiles with collision shapes as a virtual physics body.
*/
//go:nosplit
func (self class) OverlapsBody(body [1]gdclass.Node) bool { //gd:Area2D.overlaps_body
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.overlaps_body, gdextension.SizeBool|(gdextension.SizeObject<<4), &struct{ body gdextension.Object }{gdextension.Object(gd.ObjectChecked(body[0].AsObject()))})
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if the given [Area2D] intersects or overlaps this [Area2D], [code]false[/code] otherwise.
[b]Note:[/b] The result of this test is not immediate after moving objects. For performance, the list of overlaps is updated once per frame and before the physics step. Consider using signals instead.
*/
//go:nosplit
func (self class) OverlapsArea(area [1]gdclass.Node) bool { //gd:Area2D.overlaps_area
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.overlaps_area, gdextension.SizeBool|(gdextension.SizeObject<<4), &struct{ area gdextension.Object }{gdextension.Object(gd.ObjectChecked(area[0].AsObject()))})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetAudioBusName(name String.Name) { //gd:Area2D.set_audio_bus_name
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_audio_bus_name, 0|(gdextension.SizeStringName<<4), &struct{ name gdextension.StringName }{pointers.Get(gd.InternalStringName(name))})
}

//go:nosplit
func (self class) GetAudioBusName() String.Name { //gd:Area2D.get_audio_bus_name
	var r_ret = gdextension.Call[gdextension.StringName](gd.ObjectChecked(self.AsObject()), methods.get_audio_bus_name, gdextension.SizeStringName, &struct{}{})
	var ret = String.Name(String.Via(gd.StringNameProxy{}, pointers.Pack(pointers.New[gd.StringName](r_ret))))
	return ret
}

//go:nosplit
func (self class) SetAudioBusOverride(enable bool) { //gd:Area2D.set_audio_bus_override
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_audio_bus_override, 0|(gdextension.SizeBool<<4), &struct{ enable bool }{enable})
}

//go:nosplit
func (self class) IsOverridingAudioBus() bool { //gd:Area2D.is_overriding_audio_bus
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_overriding_audio_bus, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}
func (self Instance) OnBodyShapeEntered(cb func(body_rid RID.Any, body Node2D.Instance, body_shape_index int, local_shape_index int), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("body_shape_entered"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) BodyShapeEntered() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`BodyShapeEntered`))))
}

func (self Instance) OnBodyShapeExited(cb func(body_rid RID.Any, body Node2D.Instance, body_shape_index int, local_shape_index int), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("body_shape_exited"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) BodyShapeExited() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`BodyShapeExited`))))
}

func (self Instance) OnBodyEntered(cb func(body Node2D.Instance), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("body_entered"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) BodyEntered() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`BodyEntered`))))
}

func (self Instance) OnBodyExited(cb func(body Node2D.Instance), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("body_exited"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) BodyExited() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`BodyExited`))))
}

func (self Instance) OnAreaShapeEntered(cb func(area_rid RID.Any, area Instance, area_shape_index int, local_shape_index int), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("area_shape_entered"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) AreaShapeEntered() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`AreaShapeEntered`))))
}

func (self Instance) OnAreaShapeExited(cb func(area_rid RID.Any, area Instance, area_shape_index int, local_shape_index int), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("area_shape_exited"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) AreaShapeExited() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`AreaShapeExited`))))
}

func (self Instance) OnAreaEntered(cb func(area Instance), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("area_entered"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) AreaEntered() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`AreaEntered`))))
}

func (self Instance) OnAreaExited(cb func(area Instance), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("area_exited"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) AreaExited() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`AreaExited`))))
}

func (self class) AsArea2D() Advanced         { return Advanced{pointers.AsA[gdclass.Area2D](self[0])} }
func (self Instance) AsArea2D() Instance      { return Instance{pointers.AsA[gdclass.Area2D](self[0])} }
func (self *Extension[T]) AsArea2D() Instance { return self.Super().AsArea2D() }
func (self class) AsCollisionObject2D() CollisionObject2D.Advanced {
	return CollisionObject2D.Advanced{pointers.AsA[gdclass.CollisionObject2D](self[0])}
}
func (self *Extension[T]) AsCollisionObject2D() CollisionObject2D.Instance {
	return self.Super().AsCollisionObject2D()
}
func (self Instance) AsCollisionObject2D() CollisionObject2D.Instance {
	return CollisionObject2D.Instance{pointers.AsA[gdclass.CollisionObject2D](self[0])}
}
func (self class) AsNode2D() Node2D.Advanced {
	return Node2D.Advanced{pointers.AsA[gdclass.Node2D](self[0])}
}
func (self *Extension[T]) AsNode2D() Node2D.Instance { return self.Super().AsNode2D() }
func (self Instance) AsNode2D() Node2D.Instance {
	return Node2D.Instance{pointers.AsA[gdclass.Node2D](self[0])}
}
func (self class) AsCanvasItem() CanvasItem.Advanced {
	return CanvasItem.Advanced{pointers.AsA[gdclass.CanvasItem](self[0])}
}
func (self *Extension[T]) AsCanvasItem() CanvasItem.Instance { return self.Super().AsCanvasItem() }
func (self Instance) AsCanvasItem() CanvasItem.Instance {
	return CanvasItem.Instance{pointers.AsA[gdclass.CanvasItem](self[0])}
}
func (self class) AsNode() Node.Advanced         { return Node.Advanced{pointers.AsA[gdclass.Node](self[0])} }
func (self *Extension[T]) AsNode() Node.Instance { return self.Super().AsNode() }
func (self Instance) AsNode() Node.Instance {
	return Node.Instance{pointers.AsA[gdclass.Node](self[0])}
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(CollisionObject2D.Advanced(self.AsCollisionObject2D()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(CollisionObject2D.Instance(self.AsCollisionObject2D()), name)
	}
}
func init() {
	gdclass.Register("Area2D", func(ptr gd.Object) any { return Instance{pointers.AsA[gdclass.Area2D](ptr)} })
}

type SpaceOverride int //gd:Area2D.SpaceOverride

const (
	/*This area does not affect gravity/damping.*/
	SpaceOverrideDisabled SpaceOverride = 0
	/*This area adds its gravity/damping values to whatever has been calculated so far (in [member priority] order).*/
	SpaceOverrideCombine SpaceOverride = 1
	/*This area adds its gravity/damping values to whatever has been calculated so far (in [member priority] order), ignoring any lower priority areas.*/
	SpaceOverrideCombineReplace SpaceOverride = 2
	/*This area replaces any gravity/damping, even the defaults, ignoring any lower priority areas.*/
	SpaceOverrideReplace SpaceOverride = 3
	/*This area replaces any gravity/damping calculated so far (in [member priority] order), but keeps calculating the rest of the areas.*/
	SpaceOverrideReplaceCombine SpaceOverride = 4
)
