// Code generated by the generate package DO NOT EDIT

// Package PopupMenu provides methods for working with PopupMenu object instances.
package PopupMenu

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/variant/Signal"
import "graphics.gd/classdb/Control"
import "graphics.gd/classdb/Input"
import "graphics.gd/classdb/InputEvent"
import "graphics.gd/classdb/NativeMenu"
import "graphics.gd/classdb/Node"
import "graphics.gd/classdb/Popup"
import "graphics.gd/classdb/Shortcut"
import "graphics.gd/classdb/Texture2D"
import "graphics.gd/classdb/Viewport"
import "graphics.gd/classdb/Window"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Color"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Signal.Any
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
[PopupMenu] is a modal window used to display a list of options. Useful for toolbars and context menus.
The size of a [PopupMenu] can be limited by using [member Window.max_size]. If the height of the list of items is larger than the maximum height of the [PopupMenu], a [ScrollContainer] within the popup will allow the user to scroll the contents. If no maximum size is set, or if it is set to [code]0[/code], the [PopupMenu] height will be limited by its parent rect.
All [code]set_*[/code] methods allow negative item indices, i.e. [code]-1[/code] to access the last item, [code]-2[/code] to select the second-to-last item, and so on.
[b]Incremental search:[/b] Like [ItemList] and [Tree], [PopupMenu] supports searching within the list while the control is focused. Press a key that matches the first letter of an item's name to select the first item starting with the given letter. After that point, there are two ways to perform incremental search: 1) Press the same key again before the timeout duration to select the next item starting with the same letter. 2) Press letter keys that match the rest of the word before the timeout duration to match to select the item in question directly. Both of these actions will be reset to the beginning of the list if the timeout duration has passed since the last keystroke was registered. You can adjust the timeout duration by changing [member ProjectSettings.gui/timers/incremental_search_max_interval_msec].
[b]Note:[/b] The ID values used for items are limited to 32 bits, not full 64 bits of [int]. This has a range of [code]-2^32[/code] to [code]2^32 - 1[/code], i.e. [code]-2147483648[/code] to [code]2147483647[/code].
*/
type Instance [1]gdclass.PopupMenu

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	activate_item_by_event               gdextension.MethodForClass `hash:"3716412023"`
	set_prefer_native_menu               gdextension.MethodForClass `hash:"2586408642"`
	is_prefer_native_menu                gdextension.MethodForClass `hash:"36873697"`
	is_native_menu                       gdextension.MethodForClass `hash:"36873697"`
	add_item                             gdextension.MethodForClass `hash:"3674230041"`
	add_icon_item                        gdextension.MethodForClass `hash:"1086190128"`
	add_check_item                       gdextension.MethodForClass `hash:"3674230041"`
	add_icon_check_item                  gdextension.MethodForClass `hash:"1086190128"`
	add_radio_check_item                 gdextension.MethodForClass `hash:"3674230041"`
	add_icon_radio_check_item            gdextension.MethodForClass `hash:"1086190128"`
	add_multistate_item                  gdextension.MethodForClass `hash:"150780458"`
	add_shortcut                         gdextension.MethodForClass `hash:"3451850107"`
	add_icon_shortcut                    gdextension.MethodForClass `hash:"2997871092"`
	add_check_shortcut                   gdextension.MethodForClass `hash:"1642193386"`
	add_icon_check_shortcut              gdextension.MethodForClass `hash:"3856247530"`
	add_radio_check_shortcut             gdextension.MethodForClass `hash:"1642193386"`
	add_icon_radio_check_shortcut        gdextension.MethodForClass `hash:"3856247530"`
	add_submenu_item                     gdextension.MethodForClass `hash:"2979222410"`
	add_submenu_node_item                gdextension.MethodForClass `hash:"1325455216"`
	set_item_text                        gdextension.MethodForClass `hash:"501894301"`
	set_item_text_direction              gdextension.MethodForClass `hash:"1707680378"`
	set_item_language                    gdextension.MethodForClass `hash:"501894301"`
	set_item_icon                        gdextension.MethodForClass `hash:"666127730"`
	set_item_icon_max_width              gdextension.MethodForClass `hash:"3937882851"`
	set_item_icon_modulate               gdextension.MethodForClass `hash:"2878471219"`
	set_item_checked                     gdextension.MethodForClass `hash:"300928843"`
	set_item_id                          gdextension.MethodForClass `hash:"3937882851"`
	set_item_accelerator                 gdextension.MethodForClass `hash:"2992817551"`
	set_item_metadata                    gdextension.MethodForClass `hash:"2152698145"`
	set_item_disabled                    gdextension.MethodForClass `hash:"300928843"`
	set_item_submenu                     gdextension.MethodForClass `hash:"501894301"`
	set_item_submenu_node                gdextension.MethodForClass `hash:"1068370740"`
	set_item_as_separator                gdextension.MethodForClass `hash:"300928843"`
	set_item_as_checkable                gdextension.MethodForClass `hash:"300928843"`
	set_item_as_radio_checkable          gdextension.MethodForClass `hash:"300928843"`
	set_item_tooltip                     gdextension.MethodForClass `hash:"501894301"`
	set_item_shortcut                    gdextension.MethodForClass `hash:"825127832"`
	set_item_indent                      gdextension.MethodForClass `hash:"3937882851"`
	set_item_multistate                  gdextension.MethodForClass `hash:"3937882851"`
	set_item_multistate_max              gdextension.MethodForClass `hash:"3937882851"`
	set_item_shortcut_disabled           gdextension.MethodForClass `hash:"300928843"`
	toggle_item_checked                  gdextension.MethodForClass `hash:"1286410249"`
	toggle_item_multistate               gdextension.MethodForClass `hash:"1286410249"`
	get_item_text                        gdextension.MethodForClass `hash:"844755477"`
	get_item_text_direction              gdextension.MethodForClass `hash:"4235602388"`
	get_item_language                    gdextension.MethodForClass `hash:"844755477"`
	get_item_icon                        gdextension.MethodForClass `hash:"3536238170"`
	get_item_icon_max_width              gdextension.MethodForClass `hash:"923996154"`
	get_item_icon_modulate               gdextension.MethodForClass `hash:"3457211756"`
	is_item_checked                      gdextension.MethodForClass `hash:"1116898809"`
	get_item_id                          gdextension.MethodForClass `hash:"923996154"`
	get_item_index                       gdextension.MethodForClass `hash:"923996154"`
	get_item_accelerator                 gdextension.MethodForClass `hash:"253789942"`
	get_item_metadata                    gdextension.MethodForClass `hash:"4227898402"`
	is_item_disabled                     gdextension.MethodForClass `hash:"1116898809"`
	get_item_submenu                     gdextension.MethodForClass `hash:"844755477"`
	get_item_submenu_node                gdextension.MethodForClass `hash:"2100501353"`
	is_item_separator                    gdextension.MethodForClass `hash:"1116898809"`
	is_item_checkable                    gdextension.MethodForClass `hash:"1116898809"`
	is_item_radio_checkable              gdextension.MethodForClass `hash:"1116898809"`
	is_item_shortcut_disabled            gdextension.MethodForClass `hash:"1116898809"`
	get_item_tooltip                     gdextension.MethodForClass `hash:"844755477"`
	get_item_shortcut                    gdextension.MethodForClass `hash:"1449483325"`
	get_item_indent                      gdextension.MethodForClass `hash:"923996154"`
	get_item_multistate_max              gdextension.MethodForClass `hash:"923996154"`
	get_item_multistate                  gdextension.MethodForClass `hash:"923996154"`
	set_focused_item                     gdextension.MethodForClass `hash:"1286410249"`
	get_focused_item                     gdextension.MethodForClass `hash:"3905245786"`
	set_item_count                       gdextension.MethodForClass `hash:"1286410249"`
	get_item_count                       gdextension.MethodForClass `hash:"3905245786"`
	scroll_to_item                       gdextension.MethodForClass `hash:"1286410249"`
	remove_item                          gdextension.MethodForClass `hash:"1286410249"`
	add_separator                        gdextension.MethodForClass `hash:"2266703459"`
	clear                                gdextension.MethodForClass `hash:"107499316"`
	set_hide_on_item_selection           gdextension.MethodForClass `hash:"2586408642"`
	is_hide_on_item_selection            gdextension.MethodForClass `hash:"36873697"`
	set_hide_on_checkable_item_selection gdextension.MethodForClass `hash:"2586408642"`
	is_hide_on_checkable_item_selection  gdextension.MethodForClass `hash:"36873697"`
	set_hide_on_state_item_selection     gdextension.MethodForClass `hash:"2586408642"`
	is_hide_on_state_item_selection      gdextension.MethodForClass `hash:"36873697"`
	set_submenu_popup_delay              gdextension.MethodForClass `hash:"373806689"`
	get_submenu_popup_delay              gdextension.MethodForClass `hash:"1740695150"`
	set_allow_search                     gdextension.MethodForClass `hash:"2586408642"`
	get_allow_search                     gdextension.MethodForClass `hash:"36873697"`
	is_system_menu                       gdextension.MethodForClass `hash:"36873697"`
	set_system_menu                      gdextension.MethodForClass `hash:"600639674"`
	get_system_menu                      gdextension.MethodForClass `hash:"1222557358"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("PopupMenu")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		gdextension.Free(gdextension.TypeStringName, &sname)
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

type Expanded [1]gdclass.PopupMenu

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsPopupMenu() Instance
}

/*
Checks the provided [param event] against the [PopupMenu]'s shortcuts and accelerators, and activates the first item with matching events. If [param for_global_only] is [code]true[/code], only shortcuts and accelerators with [code]global[/code] set to [code]true[/code] will be called.
Returns [code]true[/code] if an item was successfully activated.
[b]Note:[/b] Certain [Control]s, such as [MenuButton], will call this method automatically.
*/
func (self Instance) ActivateItemByEvent(event InputEvent.Instance) bool { //gd:PopupMenu.activate_item_by_event
	return bool(Advanced(self).ActivateItemByEvent(event, false))
}

/*
Checks the provided [param event] against the [PopupMenu]'s shortcuts and accelerators, and activates the first item with matching events. If [param for_global_only] is [code]true[/code], only shortcuts and accelerators with [code]global[/code] set to [code]true[/code] will be called.
Returns [code]true[/code] if an item was successfully activated.
[b]Note:[/b] Certain [Control]s, such as [MenuButton], will call this method automatically.
*/
func (self Expanded) ActivateItemByEvent(event InputEvent.Instance, for_global_only bool) bool { //gd:PopupMenu.activate_item_by_event
	return bool(Advanced(self).ActivateItemByEvent(event, for_global_only))
}

/*
Returns [code]true[/code] if the system native menu is supported and currently used by this [PopupMenu].
*/
func (self Instance) IsNativeMenu() bool { //gd:PopupMenu.is_native_menu
	return bool(Advanced(self).IsNativeMenu())
}

/*
Adds a new item with text [param label].
An [param id] can optionally be provided, as well as an accelerator ([param accel]). If no [param id] is provided, one will be created from the index. If no [param accel] is provided, then the default value of 0 (corresponding to [constant @GlobalScope.KEY_NONE]) will be assigned to the item (which means it won't have any accelerator). See [method get_item_accelerator] for more info on accelerators.
[b]Note:[/b] The provided [param id] is used only in [signal id_pressed] and [signal id_focused] signals. It's not related to the [code]index[/code] arguments in e.g. [method set_item_checked].
*/
func (self Instance) AddItem(label string) { //gd:PopupMenu.add_item
	Advanced(self).AddItem(String.New(label), int64(-1), 0)
}

/*
Adds a new item with text [param label].
An [param id] can optionally be provided, as well as an accelerator ([param accel]). If no [param id] is provided, one will be created from the index. If no [param accel] is provided, then the default value of 0 (corresponding to [constant @GlobalScope.KEY_NONE]) will be assigned to the item (which means it won't have any accelerator). See [method get_item_accelerator] for more info on accelerators.
[b]Note:[/b] The provided [param id] is used only in [signal id_pressed] and [signal id_focused] signals. It's not related to the [code]index[/code] arguments in e.g. [method set_item_checked].
*/
func (self Expanded) AddItem(label string, id int, accel Input.Key) { //gd:PopupMenu.add_item
	Advanced(self).AddItem(String.New(label), int64(id), accel)
}

/*
Adds a new item with text [param label] and icon [param texture].
An [param id] can optionally be provided, as well as an accelerator ([param accel]). If no [param id] is provided, one will be created from the index. If no [param accel] is provided, then the default value of 0 (corresponding to [constant @GlobalScope.KEY_NONE]) will be assigned to the item (which means it won't have any accelerator). See [method get_item_accelerator] for more info on accelerators.
*/
func (self Instance) AddIconItem(texture Texture2D.Instance, label string) { //gd:PopupMenu.add_icon_item
	Advanced(self).AddIconItem(texture, String.New(label), int64(-1), 0)
}

/*
Adds a new item with text [param label] and icon [param texture].
An [param id] can optionally be provided, as well as an accelerator ([param accel]). If no [param id] is provided, one will be created from the index. If no [param accel] is provided, then the default value of 0 (corresponding to [constant @GlobalScope.KEY_NONE]) will be assigned to the item (which means it won't have any accelerator). See [method get_item_accelerator] for more info on accelerators.
*/
func (self Expanded) AddIconItem(texture Texture2D.Instance, label string, id int, accel Input.Key) { //gd:PopupMenu.add_icon_item
	Advanced(self).AddIconItem(texture, String.New(label), int64(id), accel)
}

/*
Adds a new checkable item with text [param label].
An [param id] can optionally be provided, as well as an accelerator ([param accel]). If no [param id] is provided, one will be created from the index. If no [param accel] is provided, then the default value of 0 (corresponding to [constant @GlobalScope.KEY_NONE]) will be assigned to the item (which means it won't have any accelerator). See [method get_item_accelerator] for more info on accelerators.
[b]Note:[/b] Checkable items just display a checkmark, but don't have any built-in checking behavior and must be checked/unchecked manually. See [method set_item_checked] for more info on how to control it.
*/
func (self Instance) AddCheckItem(label string) { //gd:PopupMenu.add_check_item
	Advanced(self).AddCheckItem(String.New(label), int64(-1), 0)
}

/*
Adds a new checkable item with text [param label].
An [param id] can optionally be provided, as well as an accelerator ([param accel]). If no [param id] is provided, one will be created from the index. If no [param accel] is provided, then the default value of 0 (corresponding to [constant @GlobalScope.KEY_NONE]) will be assigned to the item (which means it won't have any accelerator). See [method get_item_accelerator] for more info on accelerators.
[b]Note:[/b] Checkable items just display a checkmark, but don't have any built-in checking behavior and must be checked/unchecked manually. See [method set_item_checked] for more info on how to control it.
*/
func (self Expanded) AddCheckItem(label string, id int, accel Input.Key) { //gd:PopupMenu.add_check_item
	Advanced(self).AddCheckItem(String.New(label), int64(id), accel)
}

/*
Adds a new checkable item with text [param label] and icon [param texture].
An [param id] can optionally be provided, as well as an accelerator ([param accel]). If no [param id] is provided, one will be created from the index. If no [param accel] is provided, then the default value of 0 (corresponding to [constant @GlobalScope.KEY_NONE]) will be assigned to the item (which means it won't have any accelerator). See [method get_item_accelerator] for more info on accelerators.
[b]Note:[/b] Checkable items just display a checkmark, but don't have any built-in checking behavior and must be checked/unchecked manually. See [method set_item_checked] for more info on how to control it.
*/
func (self Instance) AddIconCheckItem(texture Texture2D.Instance, label string) { //gd:PopupMenu.add_icon_check_item
	Advanced(self).AddIconCheckItem(texture, String.New(label), int64(-1), 0)
}

/*
Adds a new checkable item with text [param label] and icon [param texture].
An [param id] can optionally be provided, as well as an accelerator ([param accel]). If no [param id] is provided, one will be created from the index. If no [param accel] is provided, then the default value of 0 (corresponding to [constant @GlobalScope.KEY_NONE]) will be assigned to the item (which means it won't have any accelerator). See [method get_item_accelerator] for more info on accelerators.
[b]Note:[/b] Checkable items just display a checkmark, but don't have any built-in checking behavior and must be checked/unchecked manually. See [method set_item_checked] for more info on how to control it.
*/
func (self Expanded) AddIconCheckItem(texture Texture2D.Instance, label string, id int, accel Input.Key) { //gd:PopupMenu.add_icon_check_item
	Advanced(self).AddIconCheckItem(texture, String.New(label), int64(id), accel)
}

/*
Adds a new radio check button with text [param label].
An [param id] can optionally be provided, as well as an accelerator ([param accel]). If no [param id] is provided, one will be created from the index. If no [param accel] is provided, then the default value of 0 (corresponding to [constant @GlobalScope.KEY_NONE]) will be assigned to the item (which means it won't have any accelerator). See [method get_item_accelerator] for more info on accelerators.
[b]Note:[/b] Checkable items just display a checkmark, but don't have any built-in checking behavior and must be checked/unchecked manually. See [method set_item_checked] for more info on how to control it.
*/
func (self Instance) AddRadioCheckItem(label string) { //gd:PopupMenu.add_radio_check_item
	Advanced(self).AddRadioCheckItem(String.New(label), int64(-1), 0)
}

/*
Adds a new radio check button with text [param label].
An [param id] can optionally be provided, as well as an accelerator ([param accel]). If no [param id] is provided, one will be created from the index. If no [param accel] is provided, then the default value of 0 (corresponding to [constant @GlobalScope.KEY_NONE]) will be assigned to the item (which means it won't have any accelerator). See [method get_item_accelerator] for more info on accelerators.
[b]Note:[/b] Checkable items just display a checkmark, but don't have any built-in checking behavior and must be checked/unchecked manually. See [method set_item_checked] for more info on how to control it.
*/
func (self Expanded) AddRadioCheckItem(label string, id int, accel Input.Key) { //gd:PopupMenu.add_radio_check_item
	Advanced(self).AddRadioCheckItem(String.New(label), int64(id), accel)
}

/*
Same as [method add_icon_check_item], but uses a radio check button.
*/
func (self Instance) AddIconRadioCheckItem(texture Texture2D.Instance, label string) { //gd:PopupMenu.add_icon_radio_check_item
	Advanced(self).AddIconRadioCheckItem(texture, String.New(label), int64(-1), 0)
}

/*
Same as [method add_icon_check_item], but uses a radio check button.
*/
func (self Expanded) AddIconRadioCheckItem(texture Texture2D.Instance, label string, id int, accel Input.Key) { //gd:PopupMenu.add_icon_radio_check_item
	Advanced(self).AddIconRadioCheckItem(texture, String.New(label), int64(id), accel)
}

/*
Adds a new multistate item with text [param label].
Contrarily to normal binary items, multistate items can have more than two states, as defined by [param max_states]. The default value is defined by [param default_state].
An [param id] can optionally be provided, as well as an accelerator ([param accel]). If no [param id] is provided, one will be created from the index. If no [param accel] is provided, then the default value of 0 (corresponding to [constant @GlobalScope.KEY_NONE]) will be assigned to the item (which means it won't have any accelerator). See [method get_item_accelerator] for more info on accelerators.
[codeblock]
func _ready():

	add_multistate_item("Item", 3, 0)

	index_pressed.connect(func(index: int):
	        toggle_item_multistate(index)
	        match get_item_multistate(index):
	            0:
	                print("First state")
	            1:
	                print("Second state")
	            2:
	                print("Third state")
	    )

[/codeblock]
[b]Note:[/b] Multistate items don't update their state automatically and must be done manually. See [method toggle_item_multistate], [method set_item_multistate] and [method get_item_multistate] for more info on how to control it.
*/
func (self Instance) AddMultistateItem(label string, max_states int) { //gd:PopupMenu.add_multistate_item
	Advanced(self).AddMultistateItem(String.New(label), int64(max_states), int64(0), int64(-1), 0)
}

/*
Adds a new multistate item with text [param label].
Contrarily to normal binary items, multistate items can have more than two states, as defined by [param max_states]. The default value is defined by [param default_state].
An [param id] can optionally be provided, as well as an accelerator ([param accel]). If no [param id] is provided, one will be created from the index. If no [param accel] is provided, then the default value of 0 (corresponding to [constant @GlobalScope.KEY_NONE]) will be assigned to the item (which means it won't have any accelerator). See [method get_item_accelerator] for more info on accelerators.
[codeblock]
func _ready():

	add_multistate_item("Item", 3, 0)

	index_pressed.connect(func(index: int):
	        toggle_item_multistate(index)
	        match get_item_multistate(index):
	            0:
	                print("First state")
	            1:
	                print("Second state")
	            2:
	                print("Third state")
	    )

[/codeblock]
[b]Note:[/b] Multistate items don't update their state automatically and must be done manually. See [method toggle_item_multistate], [method set_item_multistate] and [method get_item_multistate] for more info on how to control it.
*/
func (self Expanded) AddMultistateItem(label string, max_states int, default_state int, id int, accel Input.Key) { //gd:PopupMenu.add_multistate_item
	Advanced(self).AddMultistateItem(String.New(label), int64(max_states), int64(default_state), int64(id), accel)
}

/*
Adds a [Shortcut].
An [param id] can optionally be provided. If no [param id] is provided, one will be created from the index.
If [param allow_echo] is [code]true[/code], the shortcut can be activated with echo events.
*/
func (self Instance) AddShortcut(shortcut Shortcut.Instance) { //gd:PopupMenu.add_shortcut
	Advanced(self).AddShortcut(shortcut, int64(-1), false, false)
}

/*
Adds a [Shortcut].
An [param id] can optionally be provided. If no [param id] is provided, one will be created from the index.
If [param allow_echo] is [code]true[/code], the shortcut can be activated with echo events.
*/
func (self Expanded) AddShortcut(shortcut Shortcut.Instance, id int, global bool, allow_echo bool) { //gd:PopupMenu.add_shortcut
	Advanced(self).AddShortcut(shortcut, int64(id), global, allow_echo)
}

/*
Adds a new item and assigns the specified [Shortcut] and icon [param texture] to it. Sets the label of the checkbox to the [Shortcut]'s name.
An [param id] can optionally be provided. If no [param id] is provided, one will be created from the index.
If [param allow_echo] is [code]true[/code], the shortcut can be activated with echo events.
*/
func (self Instance) AddIconShortcut(texture Texture2D.Instance, shortcut Shortcut.Instance) { //gd:PopupMenu.add_icon_shortcut
	Advanced(self).AddIconShortcut(texture, shortcut, int64(-1), false, false)
}

/*
Adds a new item and assigns the specified [Shortcut] and icon [param texture] to it. Sets the label of the checkbox to the [Shortcut]'s name.
An [param id] can optionally be provided. If no [param id] is provided, one will be created from the index.
If [param allow_echo] is [code]true[/code], the shortcut can be activated with echo events.
*/
func (self Expanded) AddIconShortcut(texture Texture2D.Instance, shortcut Shortcut.Instance, id int, global bool, allow_echo bool) { //gd:PopupMenu.add_icon_shortcut
	Advanced(self).AddIconShortcut(texture, shortcut, int64(id), global, allow_echo)
}

/*
Adds a new checkable item and assigns the specified [Shortcut] to it. Sets the label of the checkbox to the [Shortcut]'s name.
An [param id] can optionally be provided. If no [param id] is provided, one will be created from the index.
[b]Note:[/b] Checkable items just display a checkmark, but don't have any built-in checking behavior and must be checked/unchecked manually. See [method set_item_checked] for more info on how to control it.
*/
func (self Instance) AddCheckShortcut(shortcut Shortcut.Instance) { //gd:PopupMenu.add_check_shortcut
	Advanced(self).AddCheckShortcut(shortcut, int64(-1), false)
}

/*
Adds a new checkable item and assigns the specified [Shortcut] to it. Sets the label of the checkbox to the [Shortcut]'s name.
An [param id] can optionally be provided. If no [param id] is provided, one will be created from the index.
[b]Note:[/b] Checkable items just display a checkmark, but don't have any built-in checking behavior and must be checked/unchecked manually. See [method set_item_checked] for more info on how to control it.
*/
func (self Expanded) AddCheckShortcut(shortcut Shortcut.Instance, id int, global bool) { //gd:PopupMenu.add_check_shortcut
	Advanced(self).AddCheckShortcut(shortcut, int64(id), global)
}

/*
Adds a new checkable item and assigns the specified [Shortcut] and icon [param texture] to it. Sets the label of the checkbox to the [Shortcut]'s name.
An [param id] can optionally be provided. If no [param id] is provided, one will be created from the index.
[b]Note:[/b] Checkable items just display a checkmark, but don't have any built-in checking behavior and must be checked/unchecked manually. See [method set_item_checked] for more info on how to control it.
*/
func (self Instance) AddIconCheckShortcut(texture Texture2D.Instance, shortcut Shortcut.Instance) { //gd:PopupMenu.add_icon_check_shortcut
	Advanced(self).AddIconCheckShortcut(texture, shortcut, int64(-1), false)
}

/*
Adds a new checkable item and assigns the specified [Shortcut] and icon [param texture] to it. Sets the label of the checkbox to the [Shortcut]'s name.
An [param id] can optionally be provided. If no [param id] is provided, one will be created from the index.
[b]Note:[/b] Checkable items just display a checkmark, but don't have any built-in checking behavior and must be checked/unchecked manually. See [method set_item_checked] for more info on how to control it.
*/
func (self Expanded) AddIconCheckShortcut(texture Texture2D.Instance, shortcut Shortcut.Instance, id int, global bool) { //gd:PopupMenu.add_icon_check_shortcut
	Advanced(self).AddIconCheckShortcut(texture, shortcut, int64(id), global)
}

/*
Adds a new radio check button and assigns a [Shortcut] to it. Sets the label of the checkbox to the [Shortcut]'s name.
An [param id] can optionally be provided. If no [param id] is provided, one will be created from the index.
[b]Note:[/b] Checkable items just display a checkmark, but don't have any built-in checking behavior and must be checked/unchecked manually. See [method set_item_checked] for more info on how to control it.
*/
func (self Instance) AddRadioCheckShortcut(shortcut Shortcut.Instance) { //gd:PopupMenu.add_radio_check_shortcut
	Advanced(self).AddRadioCheckShortcut(shortcut, int64(-1), false)
}

/*
Adds a new radio check button and assigns a [Shortcut] to it. Sets the label of the checkbox to the [Shortcut]'s name.
An [param id] can optionally be provided. If no [param id] is provided, one will be created from the index.
[b]Note:[/b] Checkable items just display a checkmark, but don't have any built-in checking behavior and must be checked/unchecked manually. See [method set_item_checked] for more info on how to control it.
*/
func (self Expanded) AddRadioCheckShortcut(shortcut Shortcut.Instance, id int, global bool) { //gd:PopupMenu.add_radio_check_shortcut
	Advanced(self).AddRadioCheckShortcut(shortcut, int64(id), global)
}

/*
Same as [method add_icon_check_shortcut], but uses a radio check button.
*/
func (self Instance) AddIconRadioCheckShortcut(texture Texture2D.Instance, shortcut Shortcut.Instance) { //gd:PopupMenu.add_icon_radio_check_shortcut
	Advanced(self).AddIconRadioCheckShortcut(texture, shortcut, int64(-1), false)
}

/*
Same as [method add_icon_check_shortcut], but uses a radio check button.
*/
func (self Expanded) AddIconRadioCheckShortcut(texture Texture2D.Instance, shortcut Shortcut.Instance, id int, global bool) { //gd:PopupMenu.add_icon_radio_check_shortcut
	Advanced(self).AddIconRadioCheckShortcut(texture, shortcut, int64(id), global)
}

/*
Adds an item that will act as a submenu of the parent [PopupMenu] node when clicked. The [param submenu] argument must be the name of an existing [PopupMenu] that has been added as a child to this node. This submenu will be shown when the item is clicked, hovered for long enough, or activated using the [code]ui_select[/code] or [code]ui_right[/code] input actions.
An [param id] can optionally be provided. If no [param id] is provided, one will be created from the index.
*/
func (self Instance) AddSubmenuItem(label string, submenu string) { //gd:PopupMenu.add_submenu_item
	Advanced(self).AddSubmenuItem(String.New(label), String.New(submenu), int64(-1))
}

/*
Adds an item that will act as a submenu of the parent [PopupMenu] node when clicked. The [param submenu] argument must be the name of an existing [PopupMenu] that has been added as a child to this node. This submenu will be shown when the item is clicked, hovered for long enough, or activated using the [code]ui_select[/code] or [code]ui_right[/code] input actions.
An [param id] can optionally be provided. If no [param id] is provided, one will be created from the index.
*/
func (self Expanded) AddSubmenuItem(label string, submenu string, id int) { //gd:PopupMenu.add_submenu_item
	Advanced(self).AddSubmenuItem(String.New(label), String.New(submenu), int64(id))
}

/*
Adds an item that will act as a submenu of the parent [PopupMenu] node when clicked. This submenu will be shown when the item is clicked, hovered for long enough, or activated using the [code]ui_select[/code] or [code]ui_right[/code] input actions.
[param submenu] must be either child of this [PopupMenu] or has no parent node (in which case it will be automatically added as a child). If the [param submenu] popup has another parent, this method will fail.
An [param id] can optionally be provided. If no [param id] is provided, one will be created from the index.
*/
func (self Instance) AddSubmenuNodeItem(label string, submenu Instance) { //gd:PopupMenu.add_submenu_node_item
	Advanced(self).AddSubmenuNodeItem(String.New(label), submenu, int64(-1))
}

/*
Adds an item that will act as a submenu of the parent [PopupMenu] node when clicked. This submenu will be shown when the item is clicked, hovered for long enough, or activated using the [code]ui_select[/code] or [code]ui_right[/code] input actions.
[param submenu] must be either child of this [PopupMenu] or has no parent node (in which case it will be automatically added as a child). If the [param submenu] popup has another parent, this method will fail.
An [param id] can optionally be provided. If no [param id] is provided, one will be created from the index.
*/
func (self Expanded) AddSubmenuNodeItem(label string, submenu Instance, id int) { //gd:PopupMenu.add_submenu_node_item
	Advanced(self).AddSubmenuNodeItem(String.New(label), submenu, int64(id))
}

/*
Sets the text of the item at the given [param index].
*/
func (self Instance) SetItemText(index int, text string) { //gd:PopupMenu.set_item_text
	Advanced(self).SetItemText(int64(index), String.New(text))
}

/*
Sets item's text base writing direction.
*/
func (self Instance) SetItemTextDirection(index int, direction Control.TextDirection) { //gd:PopupMenu.set_item_text_direction
	Advanced(self).SetItemTextDirection(int64(index), direction)
}

/*
Sets language code of item's text used for line-breaking and text shaping algorithms, if left empty current locale is used instead.
*/
func (self Instance) SetItemLanguage(index int, language string) { //gd:PopupMenu.set_item_language
	Advanced(self).SetItemLanguage(int64(index), String.New(language))
}

/*
Replaces the [Texture2D] icon of the item at the given [param index].
*/
func (self Instance) SetItemIcon(index int, icon Texture2D.Instance) { //gd:PopupMenu.set_item_icon
	Advanced(self).SetItemIcon(int64(index), icon)
}

/*
Sets the maximum allowed width of the icon for the item at the given [param index]. This limit is applied on top of the default size of the icon and on top of [theme_item icon_max_width]. The height is adjusted according to the icon's ratio.
*/
func (self Instance) SetItemIconMaxWidth(index int, width int) { //gd:PopupMenu.set_item_icon_max_width
	Advanced(self).SetItemIconMaxWidth(int64(index), int64(width))
}

/*
Sets a modulating [Color] of the item's icon at the given [param index].
*/
func (self Instance) SetItemIconModulate(index int, modulate Color.RGBA) { //gd:PopupMenu.set_item_icon_modulate
	Advanced(self).SetItemIconModulate(int64(index), Color.RGBA(modulate))
}

/*
Sets the checkstate status of the item at the given [param index].
*/
func (self Instance) SetItemChecked(index int, checked bool) { //gd:PopupMenu.set_item_checked
	Advanced(self).SetItemChecked(int64(index), checked)
}

/*
Sets the [param id] of the item at the given [param index].
The [param id] is used in [signal id_pressed] and [signal id_focused] signals.
*/
func (self Instance) SetItemId(index int, id int) { //gd:PopupMenu.set_item_id
	Advanced(self).SetItemId(int64(index), int64(id))
}

/*
Sets the accelerator of the item at the given [param index]. An accelerator is a keyboard shortcut that can be pressed to trigger the menu button even if it's not currently open. [param accel] is generally a combination of [enum KeyModifierMask]s and [enum Key]s using bitwise OR such as [code]KEY_MASK_CTRL | KEY_A[/code] ([kbd]Ctrl + A[/kbd]).
*/
func (self Instance) SetItemAccelerator(index int, accel Input.Key) { //gd:PopupMenu.set_item_accelerator
	Advanced(self).SetItemAccelerator(int64(index), accel)
}

/*
Sets the metadata of an item, which may be of any type. You can later get it with [method get_item_metadata], which provides a simple way of assigning context data to items.
*/
func (self Instance) SetItemMetadata(index int, metadata any) { //gd:PopupMenu.set_item_metadata
	Advanced(self).SetItemMetadata(int64(index), variant.New(metadata))
}

/*
Enables/disables the item at the given [param index]. When it is disabled, it can't be selected and its action can't be invoked.
*/
func (self Instance) SetItemDisabled(index int, disabled bool) { //gd:PopupMenu.set_item_disabled
	Advanced(self).SetItemDisabled(int64(index), disabled)
}

/*
Sets the submenu of the item at the given [param index]. The submenu is the name of a child [PopupMenu] node that would be shown when the item is clicked.
*/
func (self Instance) SetItemSubmenu(index int, submenu string) { //gd:PopupMenu.set_item_submenu
	Advanced(self).SetItemSubmenu(int64(index), String.New(submenu))
}

/*
Sets the submenu of the item at the given [param index]. The submenu is a [PopupMenu] node that would be shown when the item is clicked. It must either be a child of this [PopupMenu] or has no parent (in which case it will be automatically added as a child). If the [param submenu] popup has another parent, this method will fail.
*/
func (self Instance) SetItemSubmenuNode(index int, submenu Instance) { //gd:PopupMenu.set_item_submenu_node
	Advanced(self).SetItemSubmenuNode(int64(index), submenu)
}

/*
Mark the item at the given [param index] as a separator, which means that it would be displayed as a line. If [code]false[/code], sets the type of the item to plain text.
*/
func (self Instance) SetItemAsSeparator(index int, enable bool) { //gd:PopupMenu.set_item_as_separator
	Advanced(self).SetItemAsSeparator(int64(index), enable)
}

/*
Sets whether the item at the given [param index] has a checkbox. If [code]false[/code], sets the type of the item to plain text.
[b]Note:[/b] Checkable items just display a checkmark, but don't have any built-in checking behavior and must be checked/unchecked manually.
*/
func (self Instance) SetItemAsCheckable(index int, enable bool) { //gd:PopupMenu.set_item_as_checkable
	Advanced(self).SetItemAsCheckable(int64(index), enable)
}

/*
Sets the type of the item at the given [param index] to radio button. If [code]false[/code], sets the type of the item to plain text.
*/
func (self Instance) SetItemAsRadioCheckable(index int, enable bool) { //gd:PopupMenu.set_item_as_radio_checkable
	Advanced(self).SetItemAsRadioCheckable(int64(index), enable)
}

/*
Sets the [String] tooltip of the item at the given [param index].
*/
func (self Instance) SetItemTooltip(index int, tooltip string) { //gd:PopupMenu.set_item_tooltip
	Advanced(self).SetItemTooltip(int64(index), String.New(tooltip))
}

/*
Sets a [Shortcut] for the item at the given [param index].
*/
func (self Instance) SetItemShortcut(index int, shortcut Shortcut.Instance) { //gd:PopupMenu.set_item_shortcut
	Advanced(self).SetItemShortcut(int64(index), shortcut, false)
}

/*
Sets a [Shortcut] for the item at the given [param index].
*/
func (self Expanded) SetItemShortcut(index int, shortcut Shortcut.Instance, global bool) { //gd:PopupMenu.set_item_shortcut
	Advanced(self).SetItemShortcut(int64(index), shortcut, global)
}

/*
Sets the horizontal offset of the item at the given [param index].
*/
func (self Instance) SetItemIndent(index int, indent int) { //gd:PopupMenu.set_item_indent
	Advanced(self).SetItemIndent(int64(index), int64(indent))
}

/*
Sets the state of a multistate item. See [method add_multistate_item] for details.
*/
func (self Instance) SetItemMultistate(index int, state int) { //gd:PopupMenu.set_item_multistate
	Advanced(self).SetItemMultistate(int64(index), int64(state))
}

/*
Sets the max states of a multistate item. See [method add_multistate_item] for details.
*/
func (self Instance) SetItemMultistateMax(index int, max_states int) { //gd:PopupMenu.set_item_multistate_max
	Advanced(self).SetItemMultistateMax(int64(index), int64(max_states))
}

/*
Disables the [Shortcut] of the item at the given [param index].
*/
func (self Instance) SetItemShortcutDisabled(index int, disabled bool) { //gd:PopupMenu.set_item_shortcut_disabled
	Advanced(self).SetItemShortcutDisabled(int64(index), disabled)
}

/*
Toggles the check state of the item at the given [param index].
*/
func (self Instance) ToggleItemChecked(index int) { //gd:PopupMenu.toggle_item_checked
	Advanced(self).ToggleItemChecked(int64(index))
}

/*
Cycle to the next state of a multistate item. See [method add_multistate_item] for details.
*/
func (self Instance) ToggleItemMultistate(index int) { //gd:PopupMenu.toggle_item_multistate
	Advanced(self).ToggleItemMultistate(int64(index))
}

/*
Returns the text of the item at the given [param index].
*/
func (self Instance) GetItemText(index int) string { //gd:PopupMenu.get_item_text
	return string(Advanced(self).GetItemText(int64(index)).String())
}

/*
Returns item's text base writing direction.
*/
func (self Instance) GetItemTextDirection(index int) Control.TextDirection { //gd:PopupMenu.get_item_text_direction
	return Control.TextDirection(Advanced(self).GetItemTextDirection(int64(index)))
}

/*
Returns item's text language code.
*/
func (self Instance) GetItemLanguage(index int) string { //gd:PopupMenu.get_item_language
	return string(Advanced(self).GetItemLanguage(int64(index)).String())
}

/*
Returns the icon of the item at the given [param index].
*/
func (self Instance) GetItemIcon(index int) Texture2D.Instance { //gd:PopupMenu.get_item_icon
	return Texture2D.Instance(Advanced(self).GetItemIcon(int64(index)))
}

/*
Returns the maximum allowed width of the icon for the item at the given [param index].
*/
func (self Instance) GetItemIconMaxWidth(index int) int { //gd:PopupMenu.get_item_icon_max_width
	return int(int(Advanced(self).GetItemIconMaxWidth(int64(index))))
}

/*
Returns a [Color] modulating the item's icon at the given [param index].
*/
func (self Instance) GetItemIconModulate(index int) Color.RGBA { //gd:PopupMenu.get_item_icon_modulate
	return Color.RGBA(Advanced(self).GetItemIconModulate(int64(index)))
}

/*
Returns [code]true[/code] if the item at the given [param index] is checked.
*/
func (self Instance) IsItemChecked(index int) bool { //gd:PopupMenu.is_item_checked
	return bool(Advanced(self).IsItemChecked(int64(index)))
}

/*
Returns the ID of the item at the given [param index]. [code]id[/code] can be manually assigned, while index can not.
*/
func (self Instance) GetItemId(index int) int { //gd:PopupMenu.get_item_id
	return int(int(Advanced(self).GetItemId(int64(index))))
}

/*
Returns the index of the item containing the specified [param id]. Index is automatically assigned to each item by the engine and can not be set manually.
*/
func (self Instance) GetItemIndex(id int) int { //gd:PopupMenu.get_item_index
	return int(int(Advanced(self).GetItemIndex(int64(id))))
}

/*
Returns the accelerator of the item at the given [param index]. An accelerator is a keyboard shortcut that can be pressed to trigger the menu button even if it's not currently open. The return value is an integer which is generally a combination of [enum KeyModifierMask]s and [enum Key]s using bitwise OR such as [code]KEY_MASK_CTRL | KEY_A[/code] ([kbd]Ctrl + A[/kbd]). If no accelerator is defined for the specified [param index], [method get_item_accelerator] returns [code]0[/code] (corresponding to [constant @GlobalScope.KEY_NONE]).
*/
func (self Instance) GetItemAccelerator(index int) Input.Key { //gd:PopupMenu.get_item_accelerator
	return Input.Key(Advanced(self).GetItemAccelerator(int64(index)))
}

/*
Returns the metadata of the specified item, which might be of any type. You can set it with [method set_item_metadata], which provides a simple way of assigning context data to items.
*/
func (self Instance) GetItemMetadata(index int) any { //gd:PopupMenu.get_item_metadata
	return any(Advanced(self).GetItemMetadata(int64(index)).Interface())
}

/*
Returns [code]true[/code] if the item at the given [param index] is disabled. When it is disabled it can't be selected, or its action invoked.
See [method set_item_disabled] for more info on how to disable an item.
*/
func (self Instance) IsItemDisabled(index int) bool { //gd:PopupMenu.is_item_disabled
	return bool(Advanced(self).IsItemDisabled(int64(index)))
}

/*
Returns the submenu name of the item at the given [param index]. See [method add_submenu_item] for more info on how to add a submenu.
*/
func (self Instance) GetItemSubmenu(index int) string { //gd:PopupMenu.get_item_submenu
	return string(Advanced(self).GetItemSubmenu(int64(index)).String())
}

/*
Returns the submenu of the item at the given [param index], or [code]null[/code] if no submenu was added. See [method add_submenu_node_item] for more info on how to add a submenu.
*/
func (self Instance) GetItemSubmenuNode(index int) Instance { //gd:PopupMenu.get_item_submenu_node
	return Instance(Advanced(self).GetItemSubmenuNode(int64(index)))
}

/*
Returns [code]true[/code] if the item is a separator. If it is, it will be displayed as a line. See [method add_separator] for more info on how to add a separator.
*/
func (self Instance) IsItemSeparator(index int) bool { //gd:PopupMenu.is_item_separator
	return bool(Advanced(self).IsItemSeparator(int64(index)))
}

/*
Returns [code]true[/code] if the item at the given [param index] is checkable in some way, i.e. if it has a checkbox or radio button.
[b]Note:[/b] Checkable items just display a checkmark or radio button, but don't have any built-in checking behavior and must be checked/unchecked manually.
*/
func (self Instance) IsItemCheckable(index int) bool { //gd:PopupMenu.is_item_checkable
	return bool(Advanced(self).IsItemCheckable(int64(index)))
}

/*
Returns [code]true[/code] if the item at the given [param index] has radio button-style checkability.
[b]Note:[/b] This is purely cosmetic; you must add the logic for checking/unchecking items in radio groups.
*/
func (self Instance) IsItemRadioCheckable(index int) bool { //gd:PopupMenu.is_item_radio_checkable
	return bool(Advanced(self).IsItemRadioCheckable(int64(index)))
}

/*
Returns [code]true[/code] if the specified item's shortcut is disabled.
*/
func (self Instance) IsItemShortcutDisabled(index int) bool { //gd:PopupMenu.is_item_shortcut_disabled
	return bool(Advanced(self).IsItemShortcutDisabled(int64(index)))
}

/*
Returns the tooltip associated with the item at the given [param index].
*/
func (self Instance) GetItemTooltip(index int) string { //gd:PopupMenu.get_item_tooltip
	return string(Advanced(self).GetItemTooltip(int64(index)).String())
}

/*
Returns the [Shortcut] associated with the item at the given [param index].
*/
func (self Instance) GetItemShortcut(index int) Shortcut.Instance { //gd:PopupMenu.get_item_shortcut
	return Shortcut.Instance(Advanced(self).GetItemShortcut(int64(index)))
}

/*
Returns the horizontal offset of the item at the given [param index].
*/
func (self Instance) GetItemIndent(index int) int { //gd:PopupMenu.get_item_indent
	return int(int(Advanced(self).GetItemIndent(int64(index))))
}

/*
Returns the max states of the item at the given [param index].
*/
func (self Instance) GetItemMultistateMax(index int) int { //gd:PopupMenu.get_item_multistate_max
	return int(int(Advanced(self).GetItemMultistateMax(int64(index))))
}

/*
Returns the state of the item at the given [param index].
*/
func (self Instance) GetItemMultistate(index int) int { //gd:PopupMenu.get_item_multistate
	return int(int(Advanced(self).GetItemMultistate(int64(index))))
}

/*
Sets the currently focused item as the given [param index].
Passing [code]-1[/code] as the index makes so that no item is focused.
*/
func (self Instance) SetFocusedItem(index int) { //gd:PopupMenu.set_focused_item
	Advanced(self).SetFocusedItem(int64(index))
}

/*
Returns the index of the currently focused item. Returns [code]-1[/code] if no item is focused.
*/
func (self Instance) GetFocusedItem() int { //gd:PopupMenu.get_focused_item
	return int(int(Advanced(self).GetFocusedItem()))
}

/*
Moves the scroll view to make the item at the given [param index] visible.
*/
func (self Instance) ScrollToItem(index int) { //gd:PopupMenu.scroll_to_item
	Advanced(self).ScrollToItem(int64(index))
}

/*
Removes the item at the given [param index] from the menu.
[b]Note:[/b] The indices of items after the removed item will be shifted by one.
*/
func (self Instance) RemoveItem(index int) { //gd:PopupMenu.remove_item
	Advanced(self).RemoveItem(int64(index))
}

/*
Adds a separator between items. Separators also occupy an index, which you can set by using the [param id] parameter.
A [param label] can optionally be provided, which will appear at the center of the separator.
*/
func (self Instance) AddSeparator() { //gd:PopupMenu.add_separator
	Advanced(self).AddSeparator(String.New(""), int64(-1))
}

/*
Adds a separator between items. Separators also occupy an index, which you can set by using the [param id] parameter.
A [param label] can optionally be provided, which will appear at the center of the separator.
*/
func (self Expanded) AddSeparator(label string, id int) { //gd:PopupMenu.add_separator
	Advanced(self).AddSeparator(String.New(label), int64(id))
}

/*
Removes all items from the [PopupMenu]. If [param free_submenus] is [code]true[/code], the submenu nodes are automatically freed.
*/
func (self Instance) Clear() { //gd:PopupMenu.clear
	Advanced(self).Clear(false)
}

/*
Removes all items from the [PopupMenu]. If [param free_submenus] is [code]true[/code], the submenu nodes are automatically freed.
*/
func (self Expanded) Clear(free_submenus bool) { //gd:PopupMenu.clear
	Advanced(self).Clear(free_submenus)
}

/*
Returns [code]true[/code] if the menu is bound to the special system menu.
*/
func (self Instance) IsSystemMenu() bool { //gd:PopupMenu.is_system_menu
	return bool(Advanced(self).IsSystemMenu())
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.PopupMenu

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.PopupMenu)(unsafe.Pointer(&obj))
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.PopupMenu)(unsafe.Pointer(&obj))
		return true
	}
	return false
}

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {

	if !gd.Linked {
		var placeholder Instance
		*(*gd.Object)(unsafe.Pointer(&placeholder)) = pointers.Add[gd.Object]([3]uint64{})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(*(*gd.Object)(unsafe.Pointer(&placeholder)), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	object := [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})}
	casted := Instance{*(*gdclass.PopupMenu)(unsafe.Pointer(&object))}
	object[0].Notification(0, false)
	return casted
}

func (self Instance) HideOnItemSelection() bool {
	return bool(class(self).IsHideOnItemSelection())
}

func (self Instance) SetHideOnItemSelection(value bool) {
	class(self).SetHideOnItemSelection(value)
}

func (self Instance) HideOnCheckableItemSelection() bool {
	return bool(class(self).IsHideOnCheckableItemSelection())
}

func (self Instance) SetHideOnCheckableItemSelection(value bool) {
	class(self).SetHideOnCheckableItemSelection(value)
}

func (self Instance) HideOnStateItemSelection() bool {
	return bool(class(self).IsHideOnStateItemSelection())
}

func (self Instance) SetHideOnStateItemSelection(value bool) {
	class(self).SetHideOnStateItemSelection(value)
}

func (self Instance) SubmenuPopupDelay() Float.X {
	return Float.X(Float.X(class(self).GetSubmenuPopupDelay()))
}

func (self Instance) SetSubmenuPopupDelay(value Float.X) {
	class(self).SetSubmenuPopupDelay(float64(value))
}

func (self Instance) AllowSearch() bool {
	return bool(class(self).GetAllowSearch())
}

func (self Instance) SetAllowSearch(value bool) {
	class(self).SetAllowSearch(value)
}

func (self Instance) SystemMenuId() NativeMenu.SystemMenus {
	return NativeMenu.SystemMenus(class(self).GetSystemMenu())
}

func (self Instance) SetSystemMenuId(value NativeMenu.SystemMenus) {
	class(self).SetSystemMenu(value)
}

func (self Instance) PreferNativeMenu() bool {
	return bool(class(self).IsPreferNativeMenu())
}

func (self Instance) SetPreferNativeMenu(value bool) {
	class(self).SetPreferNativeMenu(value)
}

func (self Instance) ItemCount() int {
	return int(int(class(self).GetItemCount()))
}

func (self Instance) SetItemCount(value int) {
	class(self).SetItemCount(int64(value))
}

/*
Checks the provided [param event] against the [PopupMenu]'s shortcuts and accelerators, and activates the first item with matching events. If [param for_global_only] is [code]true[/code], only shortcuts and accelerators with [code]global[/code] set to [code]true[/code] will be called.
Returns [code]true[/code] if an item was successfully activated.
[b]Note:[/b] Certain [Control]s, such as [MenuButton], will call this method automatically.
*/
//go:nosplit
func (self class) ActivateItemByEvent(event [1]gdclass.InputEvent, for_global_only bool) bool { //gd:PopupMenu.activate_item_by_event
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.activate_item_by_event, gdextension.SizeBool|(gdextension.SizeObject<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		event           gdextension.Object
		for_global_only bool
	}{gdextension.Object(gd.ObjectChecked(event[0].AsObject())), for_global_only}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetPreferNativeMenu(enabled bool) { //gd:PopupMenu.set_prefer_native_menu
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_prefer_native_menu, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enabled bool }{enabled}))
}

//go:nosplit
func (self class) IsPreferNativeMenu() bool { //gd:PopupMenu.is_prefer_native_menu
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_prefer_native_menu, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if the system native menu is supported and currently used by this [PopupMenu].
*/
//go:nosplit
func (self class) IsNativeMenu() bool { //gd:PopupMenu.is_native_menu
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_native_menu, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Adds a new item with text [param label].
An [param id] can optionally be provided, as well as an accelerator ([param accel]). If no [param id] is provided, one will be created from the index. If no [param accel] is provided, then the default value of 0 (corresponding to [constant @GlobalScope.KEY_NONE]) will be assigned to the item (which means it won't have any accelerator). See [method get_item_accelerator] for more info on accelerators.
[b]Note:[/b] The provided [param id] is used only in [signal id_pressed] and [signal id_focused] signals. It's not related to the [code]index[/code] arguments in e.g. [method set_item_checked].
*/
//go:nosplit
func (self class) AddItem(label String.Readable, id int64, accel Input.Key) { //gd:PopupMenu.add_item
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_item, 0|(gdextension.SizeString<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		label gdextension.String
		id    int64
		accel Input.Key
	}{pointers.Get(gd.InternalString(label)), id, accel}))
}

/*
Adds a new item with text [param label] and icon [param texture].
An [param id] can optionally be provided, as well as an accelerator ([param accel]). If no [param id] is provided, one will be created from the index. If no [param accel] is provided, then the default value of 0 (corresponding to [constant @GlobalScope.KEY_NONE]) will be assigned to the item (which means it won't have any accelerator). See [method get_item_accelerator] for more info on accelerators.
*/
//go:nosplit
func (self class) AddIconItem(texture [1]gdclass.Texture2D, label String.Readable, id int64, accel Input.Key) { //gd:PopupMenu.add_icon_item
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_icon_item, 0|(gdextension.SizeObject<<4)|(gdextension.SizeString<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeInt<<16), unsafe.Pointer(&struct {
		texture gdextension.Object
		label   gdextension.String
		id      int64
		accel   Input.Key
	}{gdextension.Object(gd.ObjectChecked(texture[0].AsObject())), pointers.Get(gd.InternalString(label)), id, accel}))
}

/*
Adds a new checkable item with text [param label].
An [param id] can optionally be provided, as well as an accelerator ([param accel]). If no [param id] is provided, one will be created from the index. If no [param accel] is provided, then the default value of 0 (corresponding to [constant @GlobalScope.KEY_NONE]) will be assigned to the item (which means it won't have any accelerator). See [method get_item_accelerator] for more info on accelerators.
[b]Note:[/b] Checkable items just display a checkmark, but don't have any built-in checking behavior and must be checked/unchecked manually. See [method set_item_checked] for more info on how to control it.
*/
//go:nosplit
func (self class) AddCheckItem(label String.Readable, id int64, accel Input.Key) { //gd:PopupMenu.add_check_item
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_check_item, 0|(gdextension.SizeString<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		label gdextension.String
		id    int64
		accel Input.Key
	}{pointers.Get(gd.InternalString(label)), id, accel}))
}

/*
Adds a new checkable item with text [param label] and icon [param texture].
An [param id] can optionally be provided, as well as an accelerator ([param accel]). If no [param id] is provided, one will be created from the index. If no [param accel] is provided, then the default value of 0 (corresponding to [constant @GlobalScope.KEY_NONE]) will be assigned to the item (which means it won't have any accelerator). See [method get_item_accelerator] for more info on accelerators.
[b]Note:[/b] Checkable items just display a checkmark, but don't have any built-in checking behavior and must be checked/unchecked manually. See [method set_item_checked] for more info on how to control it.
*/
//go:nosplit
func (self class) AddIconCheckItem(texture [1]gdclass.Texture2D, label String.Readable, id int64, accel Input.Key) { //gd:PopupMenu.add_icon_check_item
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_icon_check_item, 0|(gdextension.SizeObject<<4)|(gdextension.SizeString<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeInt<<16), unsafe.Pointer(&struct {
		texture gdextension.Object
		label   gdextension.String
		id      int64
		accel   Input.Key
	}{gdextension.Object(gd.ObjectChecked(texture[0].AsObject())), pointers.Get(gd.InternalString(label)), id, accel}))
}

/*
Adds a new radio check button with text [param label].
An [param id] can optionally be provided, as well as an accelerator ([param accel]). If no [param id] is provided, one will be created from the index. If no [param accel] is provided, then the default value of 0 (corresponding to [constant @GlobalScope.KEY_NONE]) will be assigned to the item (which means it won't have any accelerator). See [method get_item_accelerator] for more info on accelerators.
[b]Note:[/b] Checkable items just display a checkmark, but don't have any built-in checking behavior and must be checked/unchecked manually. See [method set_item_checked] for more info on how to control it.
*/
//go:nosplit
func (self class) AddRadioCheckItem(label String.Readable, id int64, accel Input.Key) { //gd:PopupMenu.add_radio_check_item
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_radio_check_item, 0|(gdextension.SizeString<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		label gdextension.String
		id    int64
		accel Input.Key
	}{pointers.Get(gd.InternalString(label)), id, accel}))
}

/*
Same as [method add_icon_check_item], but uses a radio check button.
*/
//go:nosplit
func (self class) AddIconRadioCheckItem(texture [1]gdclass.Texture2D, label String.Readable, id int64, accel Input.Key) { //gd:PopupMenu.add_icon_radio_check_item
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_icon_radio_check_item, 0|(gdextension.SizeObject<<4)|(gdextension.SizeString<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeInt<<16), unsafe.Pointer(&struct {
		texture gdextension.Object
		label   gdextension.String
		id      int64
		accel   Input.Key
	}{gdextension.Object(gd.ObjectChecked(texture[0].AsObject())), pointers.Get(gd.InternalString(label)), id, accel}))
}

/*
Adds a new multistate item with text [param label].
Contrarily to normal binary items, multistate items can have more than two states, as defined by [param max_states]. The default value is defined by [param default_state].
An [param id] can optionally be provided, as well as an accelerator ([param accel]). If no [param id] is provided, one will be created from the index. If no [param accel] is provided, then the default value of 0 (corresponding to [constant @GlobalScope.KEY_NONE]) will be assigned to the item (which means it won't have any accelerator). See [method get_item_accelerator] for more info on accelerators.
[codeblock]
func _ready():
    add_multistate_item("Item", 3, 0)

    index_pressed.connect(func(index: int):
            toggle_item_multistate(index)
            match get_item_multistate(index):
                0:
                    print("First state")
                1:
                    print("Second state")
                2:
                    print("Third state")
        )
[/codeblock]
[b]Note:[/b] Multistate items don't update their state automatically and must be done manually. See [method toggle_item_multistate], [method set_item_multistate] and [method get_item_multistate] for more info on how to control it.
*/
//go:nosplit
func (self class) AddMultistateItem(label String.Readable, max_states int64, default_state int64, id int64, accel Input.Key) { //gd:PopupMenu.add_multistate_item
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_multistate_item, 0|(gdextension.SizeString<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeInt<<16)|(gdextension.SizeInt<<20), unsafe.Pointer(&struct {
		label         gdextension.String
		max_states    int64
		default_state int64
		id            int64
		accel         Input.Key
	}{pointers.Get(gd.InternalString(label)), max_states, default_state, id, accel}))
}

/*
Adds a [Shortcut].
An [param id] can optionally be provided. If no [param id] is provided, one will be created from the index.
If [param allow_echo] is [code]true[/code], the shortcut can be activated with echo events.
*/
//go:nosplit
func (self class) AddShortcut(shortcut [1]gdclass.Shortcut, id int64, global bool, allow_echo bool) { //gd:PopupMenu.add_shortcut
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_shortcut, 0|(gdextension.SizeObject<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeBool<<12)|(gdextension.SizeBool<<16), unsafe.Pointer(&struct {
		shortcut   gdextension.Object
		id         int64
		global     bool
		allow_echo bool
	}{gdextension.Object(gd.ObjectChecked(shortcut[0].AsObject())), id, global, allow_echo}))
}

/*
Adds a new item and assigns the specified [Shortcut] and icon [param texture] to it. Sets the label of the checkbox to the [Shortcut]'s name.
An [param id] can optionally be provided. If no [param id] is provided, one will be created from the index.
If [param allow_echo] is [code]true[/code], the shortcut can be activated with echo events.
*/
//go:nosplit
func (self class) AddIconShortcut(texture [1]gdclass.Texture2D, shortcut [1]gdclass.Shortcut, id int64, global bool, allow_echo bool) { //gd:PopupMenu.add_icon_shortcut
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_icon_shortcut, 0|(gdextension.SizeObject<<4)|(gdextension.SizeObject<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeBool<<16)|(gdextension.SizeBool<<20), unsafe.Pointer(&struct {
		texture    gdextension.Object
		shortcut   gdextension.Object
		id         int64
		global     bool
		allow_echo bool
	}{gdextension.Object(gd.ObjectChecked(texture[0].AsObject())), gdextension.Object(gd.ObjectChecked(shortcut[0].AsObject())), id, global, allow_echo}))
}

/*
Adds a new checkable item and assigns the specified [Shortcut] to it. Sets the label of the checkbox to the [Shortcut]'s name.
An [param id] can optionally be provided. If no [param id] is provided, one will be created from the index.
[b]Note:[/b] Checkable items just display a checkmark, but don't have any built-in checking behavior and must be checked/unchecked manually. See [method set_item_checked] for more info on how to control it.
*/
//go:nosplit
func (self class) AddCheckShortcut(shortcut [1]gdclass.Shortcut, id int64, global bool) { //gd:PopupMenu.add_check_shortcut
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_check_shortcut, 0|(gdextension.SizeObject<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeBool<<12), unsafe.Pointer(&struct {
		shortcut gdextension.Object
		id       int64
		global   bool
	}{gdextension.Object(gd.ObjectChecked(shortcut[0].AsObject())), id, global}))
}

/*
Adds a new checkable item and assigns the specified [Shortcut] and icon [param texture] to it. Sets the label of the checkbox to the [Shortcut]'s name.
An [param id] can optionally be provided. If no [param id] is provided, one will be created from the index.
[b]Note:[/b] Checkable items just display a checkmark, but don't have any built-in checking behavior and must be checked/unchecked manually. See [method set_item_checked] for more info on how to control it.
*/
//go:nosplit
func (self class) AddIconCheckShortcut(texture [1]gdclass.Texture2D, shortcut [1]gdclass.Shortcut, id int64, global bool) { //gd:PopupMenu.add_icon_check_shortcut
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_icon_check_shortcut, 0|(gdextension.SizeObject<<4)|(gdextension.SizeObject<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeBool<<16), unsafe.Pointer(&struct {
		texture  gdextension.Object
		shortcut gdextension.Object
		id       int64
		global   bool
	}{gdextension.Object(gd.ObjectChecked(texture[0].AsObject())), gdextension.Object(gd.ObjectChecked(shortcut[0].AsObject())), id, global}))
}

/*
Adds a new radio check button and assigns a [Shortcut] to it. Sets the label of the checkbox to the [Shortcut]'s name.
An [param id] can optionally be provided. If no [param id] is provided, one will be created from the index.
[b]Note:[/b] Checkable items just display a checkmark, but don't have any built-in checking behavior and must be checked/unchecked manually. See [method set_item_checked] for more info on how to control it.
*/
//go:nosplit
func (self class) AddRadioCheckShortcut(shortcut [1]gdclass.Shortcut, id int64, global bool) { //gd:PopupMenu.add_radio_check_shortcut
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_radio_check_shortcut, 0|(gdextension.SizeObject<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeBool<<12), unsafe.Pointer(&struct {
		shortcut gdextension.Object
		id       int64
		global   bool
	}{gdextension.Object(gd.ObjectChecked(shortcut[0].AsObject())), id, global}))
}

/*
Same as [method add_icon_check_shortcut], but uses a radio check button.
*/
//go:nosplit
func (self class) AddIconRadioCheckShortcut(texture [1]gdclass.Texture2D, shortcut [1]gdclass.Shortcut, id int64, global bool) { //gd:PopupMenu.add_icon_radio_check_shortcut
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_icon_radio_check_shortcut, 0|(gdextension.SizeObject<<4)|(gdextension.SizeObject<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeBool<<16), unsafe.Pointer(&struct {
		texture  gdextension.Object
		shortcut gdextension.Object
		id       int64
		global   bool
	}{gdextension.Object(gd.ObjectChecked(texture[0].AsObject())), gdextension.Object(gd.ObjectChecked(shortcut[0].AsObject())), id, global}))
}

/*
Adds an item that will act as a submenu of the parent [PopupMenu] node when clicked. The [param submenu] argument must be the name of an existing [PopupMenu] that has been added as a child to this node. This submenu will be shown when the item is clicked, hovered for long enough, or activated using the [code]ui_select[/code] or [code]ui_right[/code] input actions.
An [param id] can optionally be provided. If no [param id] is provided, one will be created from the index.
*/
//go:nosplit
func (self class) AddSubmenuItem(label String.Readable, submenu String.Readable, id int64) { //gd:PopupMenu.add_submenu_item
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_submenu_item, 0|(gdextension.SizeString<<4)|(gdextension.SizeString<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		label   gdextension.String
		submenu gdextension.String
		id      int64
	}{pointers.Get(gd.InternalString(label)), pointers.Get(gd.InternalString(submenu)), id}))
}

/*
Adds an item that will act as a submenu of the parent [PopupMenu] node when clicked. This submenu will be shown when the item is clicked, hovered for long enough, or activated using the [code]ui_select[/code] or [code]ui_right[/code] input actions.
[param submenu] must be either child of this [PopupMenu] or has no parent node (in which case it will be automatically added as a child). If the [param submenu] popup has another parent, this method will fail.
An [param id] can optionally be provided. If no [param id] is provided, one will be created from the index.
*/
//go:nosplit
func (self class) AddSubmenuNodeItem(label String.Readable, submenu [1]gdclass.PopupMenu, id int64) { //gd:PopupMenu.add_submenu_node_item
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_submenu_node_item, 0|(gdextension.SizeString<<4)|(gdextension.SizeObject<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		label   gdextension.String
		submenu gdextension.Object
		id      int64
	}{pointers.Get(gd.InternalString(label)), gdextension.Object(gd.PointerWithOwnershipTransferredToGodot(submenu[0].AsObject()[0])), id}))
}

/*
Sets the text of the item at the given [param index].
*/
//go:nosplit
func (self class) SetItemText(index int64, text String.Readable) { //gd:PopupMenu.set_item_text
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_text, 0|(gdextension.SizeInt<<4)|(gdextension.SizeString<<8), unsafe.Pointer(&struct {
		index int64
		text  gdextension.String
	}{index, pointers.Get(gd.InternalString(text))}))
}

/*
Sets item's text base writing direction.
*/
//go:nosplit
func (self class) SetItemTextDirection(index int64, direction Control.TextDirection) { //gd:PopupMenu.set_item_text_direction
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_text_direction, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		index     int64
		direction Control.TextDirection
	}{index, direction}))
}

/*
Sets language code of item's text used for line-breaking and text shaping algorithms, if left empty current locale is used instead.
*/
//go:nosplit
func (self class) SetItemLanguage(index int64, language String.Readable) { //gd:PopupMenu.set_item_language
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_language, 0|(gdextension.SizeInt<<4)|(gdextension.SizeString<<8), unsafe.Pointer(&struct {
		index    int64
		language gdextension.String
	}{index, pointers.Get(gd.InternalString(language))}))
}

/*
Replaces the [Texture2D] icon of the item at the given [param index].
*/
//go:nosplit
func (self class) SetItemIcon(index int64, icon [1]gdclass.Texture2D) { //gd:PopupMenu.set_item_icon
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_icon, 0|(gdextension.SizeInt<<4)|(gdextension.SizeObject<<8), unsafe.Pointer(&struct {
		index int64
		icon  gdextension.Object
	}{index, gdextension.Object(gd.ObjectChecked(icon[0].AsObject()))}))
}

/*
Sets the maximum allowed width of the icon for the item at the given [param index]. This limit is applied on top of the default size of the icon and on top of [theme_item icon_max_width]. The height is adjusted according to the icon's ratio.
*/
//go:nosplit
func (self class) SetItemIconMaxWidth(index int64, width int64) { //gd:PopupMenu.set_item_icon_max_width
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_icon_max_width, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		index int64
		width int64
	}{index, width}))
}

/*
Sets a modulating [Color] of the item's icon at the given [param index].
*/
//go:nosplit
func (self class) SetItemIconModulate(index int64, modulate Color.RGBA) { //gd:PopupMenu.set_item_icon_modulate
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_icon_modulate, 0|(gdextension.SizeInt<<4)|(gdextension.SizeColor<<8), unsafe.Pointer(&struct {
		index    int64
		modulate Color.RGBA
	}{index, modulate}))
}

/*
Sets the checkstate status of the item at the given [param index].
*/
//go:nosplit
func (self class) SetItemChecked(index int64, checked bool) { //gd:PopupMenu.set_item_checked
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_checked, 0|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		index   int64
		checked bool
	}{index, checked}))
}

/*
Sets the [param id] of the item at the given [param index].
The [param id] is used in [signal id_pressed] and [signal id_focused] signals.
*/
//go:nosplit
func (self class) SetItemId(index int64, id int64) { //gd:PopupMenu.set_item_id
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_id, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		index int64
		id    int64
	}{index, id}))
}

/*
Sets the accelerator of the item at the given [param index]. An accelerator is a keyboard shortcut that can be pressed to trigger the menu button even if it's not currently open. [param accel] is generally a combination of [enum KeyModifierMask]s and [enum Key]s using bitwise OR such as [code]KEY_MASK_CTRL | KEY_A[/code] ([kbd]Ctrl + A[/kbd]).
*/
//go:nosplit
func (self class) SetItemAccelerator(index int64, accel Input.Key) { //gd:PopupMenu.set_item_accelerator
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_accelerator, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		index int64
		accel Input.Key
	}{index, accel}))
}

/*
Sets the metadata of an item, which may be of any type. You can later get it with [method get_item_metadata], which provides a simple way of assigning context data to items.
*/
//go:nosplit
func (self class) SetItemMetadata(index int64, metadata variant.Any) { //gd:PopupMenu.set_item_metadata
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_metadata, 0|(gdextension.SizeInt<<4)|(gdextension.SizeVariant<<8), unsafe.Pointer(&struct {
		index    int64
		metadata gdextension.Variant
	}{index, gdextension.Variant(pointers.Get(gd.InternalVariant(metadata)))}))
}

/*
Enables/disables the item at the given [param index]. When it is disabled, it can't be selected and its action can't be invoked.
*/
//go:nosplit
func (self class) SetItemDisabled(index int64, disabled bool) { //gd:PopupMenu.set_item_disabled
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_disabled, 0|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		index    int64
		disabled bool
	}{index, disabled}))
}

/*
Sets the submenu of the item at the given [param index]. The submenu is the name of a child [PopupMenu] node that would be shown when the item is clicked.
*/
//go:nosplit
func (self class) SetItemSubmenu(index int64, submenu String.Readable) { //gd:PopupMenu.set_item_submenu
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_submenu, 0|(gdextension.SizeInt<<4)|(gdextension.SizeString<<8), unsafe.Pointer(&struct {
		index   int64
		submenu gdextension.String
	}{index, pointers.Get(gd.InternalString(submenu))}))
}

/*
Sets the submenu of the item at the given [param index]. The submenu is a [PopupMenu] node that would be shown when the item is clicked. It must either be a child of this [PopupMenu] or has no parent (in which case it will be automatically added as a child). If the [param submenu] popup has another parent, this method will fail.
*/
//go:nosplit
func (self class) SetItemSubmenuNode(index int64, submenu [1]gdclass.PopupMenu) { //gd:PopupMenu.set_item_submenu_node
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_submenu_node, 0|(gdextension.SizeInt<<4)|(gdextension.SizeObject<<8), unsafe.Pointer(&struct {
		index   int64
		submenu gdextension.Object
	}{index, gdextension.Object(gd.PointerWithOwnershipTransferredToGodot(submenu[0].AsObject()[0]))}))
}

/*
Mark the item at the given [param index] as a separator, which means that it would be displayed as a line. If [code]false[/code], sets the type of the item to plain text.
*/
//go:nosplit
func (self class) SetItemAsSeparator(index int64, enable bool) { //gd:PopupMenu.set_item_as_separator
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_as_separator, 0|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		index  int64
		enable bool
	}{index, enable}))
}

/*
Sets whether the item at the given [param index] has a checkbox. If [code]false[/code], sets the type of the item to plain text.
[b]Note:[/b] Checkable items just display a checkmark, but don't have any built-in checking behavior and must be checked/unchecked manually.
*/
//go:nosplit
func (self class) SetItemAsCheckable(index int64, enable bool) { //gd:PopupMenu.set_item_as_checkable
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_as_checkable, 0|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		index  int64
		enable bool
	}{index, enable}))
}

/*
Sets the type of the item at the given [param index] to radio button. If [code]false[/code], sets the type of the item to plain text.
*/
//go:nosplit
func (self class) SetItemAsRadioCheckable(index int64, enable bool) { //gd:PopupMenu.set_item_as_radio_checkable
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_as_radio_checkable, 0|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		index  int64
		enable bool
	}{index, enable}))
}

/*
Sets the [String] tooltip of the item at the given [param index].
*/
//go:nosplit
func (self class) SetItemTooltip(index int64, tooltip String.Readable) { //gd:PopupMenu.set_item_tooltip
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_tooltip, 0|(gdextension.SizeInt<<4)|(gdextension.SizeString<<8), unsafe.Pointer(&struct {
		index   int64
		tooltip gdextension.String
	}{index, pointers.Get(gd.InternalString(tooltip))}))
}

/*
Sets a [Shortcut] for the item at the given [param index].
*/
//go:nosplit
func (self class) SetItemShortcut(index int64, shortcut [1]gdclass.Shortcut, global bool) { //gd:PopupMenu.set_item_shortcut
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_shortcut, 0|(gdextension.SizeInt<<4)|(gdextension.SizeObject<<8)|(gdextension.SizeBool<<12), unsafe.Pointer(&struct {
		index    int64
		shortcut gdextension.Object
		global   bool
	}{index, gdextension.Object(gd.ObjectChecked(shortcut[0].AsObject())), global}))
}

/*
Sets the horizontal offset of the item at the given [param index].
*/
//go:nosplit
func (self class) SetItemIndent(index int64, indent int64) { //gd:PopupMenu.set_item_indent
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_indent, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		index  int64
		indent int64
	}{index, indent}))
}

/*
Sets the state of a multistate item. See [method add_multistate_item] for details.
*/
//go:nosplit
func (self class) SetItemMultistate(index int64, state int64) { //gd:PopupMenu.set_item_multistate
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_multistate, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		index int64
		state int64
	}{index, state}))
}

/*
Sets the max states of a multistate item. See [method add_multistate_item] for details.
*/
//go:nosplit
func (self class) SetItemMultistateMax(index int64, max_states int64) { //gd:PopupMenu.set_item_multistate_max
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_multistate_max, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		index      int64
		max_states int64
	}{index, max_states}))
}

/*
Disables the [Shortcut] of the item at the given [param index].
*/
//go:nosplit
func (self class) SetItemShortcutDisabled(index int64, disabled bool) { //gd:PopupMenu.set_item_shortcut_disabled
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_shortcut_disabled, 0|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		index    int64
		disabled bool
	}{index, disabled}))
}

/*
Toggles the check state of the item at the given [param index].
*/
//go:nosplit
func (self class) ToggleItemChecked(index int64) { //gd:PopupMenu.toggle_item_checked
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.toggle_item_checked, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ index int64 }{index}))
}

/*
Cycle to the next state of a multistate item. See [method add_multistate_item] for details.
*/
//go:nosplit
func (self class) ToggleItemMultistate(index int64) { //gd:PopupMenu.toggle_item_multistate
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.toggle_item_multistate, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ index int64 }{index}))
}

/*
Returns the text of the item at the given [param index].
*/
//go:nosplit
func (self class) GetItemText(index int64) String.Readable { //gd:PopupMenu.get_item_text
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_item_text, gdextension.SizeString|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ index int64 }{index}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Returns item's text base writing direction.
*/
//go:nosplit
func (self class) GetItemTextDirection(index int64) Control.TextDirection { //gd:PopupMenu.get_item_text_direction
	var r_ret = gdextension.Call[Control.TextDirection](gd.ObjectChecked(self.AsObject()), methods.get_item_text_direction, gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ index int64 }{index}))
	var ret = r_ret
	return ret
}

/*
Returns item's text language code.
*/
//go:nosplit
func (self class) GetItemLanguage(index int64) String.Readable { //gd:PopupMenu.get_item_language
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_item_language, gdextension.SizeString|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ index int64 }{index}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Returns the icon of the item at the given [param index].
*/
//go:nosplit
func (self class) GetItemIcon(index int64) [1]gdclass.Texture2D { //gd:PopupMenu.get_item_icon
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_item_icon, gdextension.SizeObject|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ index int64 }{index}))
	var ret = [1]gdclass.Texture2D{gd.PointerWithOwnershipTransferredToGo[gdclass.Texture2D](r_ret)}
	return ret
}

/*
Returns the maximum allowed width of the icon for the item at the given [param index].
*/
//go:nosplit
func (self class) GetItemIconMaxWidth(index int64) int64 { //gd:PopupMenu.get_item_icon_max_width
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_item_icon_max_width, gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ index int64 }{index}))
	var ret = r_ret
	return ret
}

/*
Returns a [Color] modulating the item's icon at the given [param index].
*/
//go:nosplit
func (self class) GetItemIconModulate(index int64) Color.RGBA { //gd:PopupMenu.get_item_icon_modulate
	var r_ret = gdextension.Call[Color.RGBA](gd.ObjectChecked(self.AsObject()), methods.get_item_icon_modulate, gdextension.SizeColor|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ index int64 }{index}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if the item at the given [param index] is checked.
*/
//go:nosplit
func (self class) IsItemChecked(index int64) bool { //gd:PopupMenu.is_item_checked
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_item_checked, gdextension.SizeBool|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ index int64 }{index}))
	var ret = r_ret
	return ret
}

/*
Returns the ID of the item at the given [param index]. [code]id[/code] can be manually assigned, while index can not.
*/
//go:nosplit
func (self class) GetItemId(index int64) int64 { //gd:PopupMenu.get_item_id
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_item_id, gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ index int64 }{index}))
	var ret = r_ret
	return ret
}

/*
Returns the index of the item containing the specified [param id]. Index is automatically assigned to each item by the engine and can not be set manually.
*/
//go:nosplit
func (self class) GetItemIndex(id int64) int64 { //gd:PopupMenu.get_item_index
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_item_index, gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ id int64 }{id}))
	var ret = r_ret
	return ret
}

/*
Returns the accelerator of the item at the given [param index]. An accelerator is a keyboard shortcut that can be pressed to trigger the menu button even if it's not currently open. The return value is an integer which is generally a combination of [enum KeyModifierMask]s and [enum Key]s using bitwise OR such as [code]KEY_MASK_CTRL | KEY_A[/code] ([kbd]Ctrl + A[/kbd]). If no accelerator is defined for the specified [param index], [method get_item_accelerator] returns [code]0[/code] (corresponding to [constant @GlobalScope.KEY_NONE]).
*/
//go:nosplit
func (self class) GetItemAccelerator(index int64) Input.Key { //gd:PopupMenu.get_item_accelerator
	var r_ret = gdextension.Call[Input.Key](gd.ObjectChecked(self.AsObject()), methods.get_item_accelerator, gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ index int64 }{index}))
	var ret = r_ret
	return ret
}

/*
Returns the metadata of the specified item, which might be of any type. You can set it with [method set_item_metadata], which provides a simple way of assigning context data to items.
*/
//go:nosplit
func (self class) GetItemMetadata(index int64) variant.Any { //gd:PopupMenu.get_item_metadata
	var r_ret = gdextension.Call[gdextension.Variant](gd.ObjectChecked(self.AsObject()), methods.get_item_metadata, gdextension.SizeVariant|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ index int64 }{index}))
	var ret = variant.Implementation(gd.VariantProxy{}, pointers.Pack(pointers.New[gd.Variant](r_ret)))
	return ret
}

/*
Returns [code]true[/code] if the item at the given [param index] is disabled. When it is disabled it can't be selected, or its action invoked.
See [method set_item_disabled] for more info on how to disable an item.
*/
//go:nosplit
func (self class) IsItemDisabled(index int64) bool { //gd:PopupMenu.is_item_disabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_item_disabled, gdextension.SizeBool|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ index int64 }{index}))
	var ret = r_ret
	return ret
}

/*
Returns the submenu name of the item at the given [param index]. See [method add_submenu_item] for more info on how to add a submenu.
*/
//go:nosplit
func (self class) GetItemSubmenu(index int64) String.Readable { //gd:PopupMenu.get_item_submenu
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_item_submenu, gdextension.SizeString|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ index int64 }{index}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Returns the submenu of the item at the given [param index], or [code]null[/code] if no submenu was added. See [method add_submenu_node_item] for more info on how to add a submenu.
*/
//go:nosplit
func (self class) GetItemSubmenuNode(index int64) [1]gdclass.PopupMenu { //gd:PopupMenu.get_item_submenu_node
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_item_submenu_node, gdextension.SizeObject|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ index int64 }{index}))
	var ret = [1]gdclass.PopupMenu{gd.PointerLifetimeBoundTo[gdclass.PopupMenu](self.AsObject(), r_ret)}
	return ret
}

/*
Returns [code]true[/code] if the item is a separator. If it is, it will be displayed as a line. See [method add_separator] for more info on how to add a separator.
*/
//go:nosplit
func (self class) IsItemSeparator(index int64) bool { //gd:PopupMenu.is_item_separator
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_item_separator, gdextension.SizeBool|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ index int64 }{index}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if the item at the given [param index] is checkable in some way, i.e. if it has a checkbox or radio button.
[b]Note:[/b] Checkable items just display a checkmark or radio button, but don't have any built-in checking behavior and must be checked/unchecked manually.
*/
//go:nosplit
func (self class) IsItemCheckable(index int64) bool { //gd:PopupMenu.is_item_checkable
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_item_checkable, gdextension.SizeBool|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ index int64 }{index}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if the item at the given [param index] has radio button-style checkability.
[b]Note:[/b] This is purely cosmetic; you must add the logic for checking/unchecking items in radio groups.
*/
//go:nosplit
func (self class) IsItemRadioCheckable(index int64) bool { //gd:PopupMenu.is_item_radio_checkable
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_item_radio_checkable, gdextension.SizeBool|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ index int64 }{index}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if the specified item's shortcut is disabled.
*/
//go:nosplit
func (self class) IsItemShortcutDisabled(index int64) bool { //gd:PopupMenu.is_item_shortcut_disabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_item_shortcut_disabled, gdextension.SizeBool|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ index int64 }{index}))
	var ret = r_ret
	return ret
}

/*
Returns the tooltip associated with the item at the given [param index].
*/
//go:nosplit
func (self class) GetItemTooltip(index int64) String.Readable { //gd:PopupMenu.get_item_tooltip
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_item_tooltip, gdextension.SizeString|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ index int64 }{index}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Returns the [Shortcut] associated with the item at the given [param index].
*/
//go:nosplit
func (self class) GetItemShortcut(index int64) [1]gdclass.Shortcut { //gd:PopupMenu.get_item_shortcut
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_item_shortcut, gdextension.SizeObject|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ index int64 }{index}))
	var ret = [1]gdclass.Shortcut{gd.PointerWithOwnershipTransferredToGo[gdclass.Shortcut](r_ret)}
	return ret
}

/*
Returns the horizontal offset of the item at the given [param index].
*/
//go:nosplit
func (self class) GetItemIndent(index int64) int64 { //gd:PopupMenu.get_item_indent
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_item_indent, gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ index int64 }{index}))
	var ret = r_ret
	return ret
}

/*
Returns the max states of the item at the given [param index].
*/
//go:nosplit
func (self class) GetItemMultistateMax(index int64) int64 { //gd:PopupMenu.get_item_multistate_max
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_item_multistate_max, gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ index int64 }{index}))
	var ret = r_ret
	return ret
}

/*
Returns the state of the item at the given [param index].
*/
//go:nosplit
func (self class) GetItemMultistate(index int64) int64 { //gd:PopupMenu.get_item_multistate
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_item_multistate, gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ index int64 }{index}))
	var ret = r_ret
	return ret
}

/*
Sets the currently focused item as the given [param index].
Passing [code]-1[/code] as the index makes so that no item is focused.
*/
//go:nosplit
func (self class) SetFocusedItem(index int64) { //gd:PopupMenu.set_focused_item
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_focused_item, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ index int64 }{index}))
}

/*
Returns the index of the currently focused item. Returns [code]-1[/code] if no item is focused.
*/
//go:nosplit
func (self class) GetFocusedItem() int64 { //gd:PopupMenu.get_focused_item
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_focused_item, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetItemCount(count int64) { //gd:PopupMenu.set_item_count
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_count, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ count int64 }{count}))
}

//go:nosplit
func (self class) GetItemCount() int64 { //gd:PopupMenu.get_item_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_item_count, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Moves the scroll view to make the item at the given [param index] visible.
*/
//go:nosplit
func (self class) ScrollToItem(index int64) { //gd:PopupMenu.scroll_to_item
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.scroll_to_item, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ index int64 }{index}))
}

/*
Removes the item at the given [param index] from the menu.
[b]Note:[/b] The indices of items after the removed item will be shifted by one.
*/
//go:nosplit
func (self class) RemoveItem(index int64) { //gd:PopupMenu.remove_item
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.remove_item, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ index int64 }{index}))
}

/*
Adds a separator between items. Separators also occupy an index, which you can set by using the [param id] parameter.
A [param label] can optionally be provided, which will appear at the center of the separator.
*/
//go:nosplit
func (self class) AddSeparator(label String.Readable, id int64) { //gd:PopupMenu.add_separator
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_separator, 0|(gdextension.SizeString<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		label gdextension.String
		id    int64
	}{pointers.Get(gd.InternalString(label)), id}))
}

/*
Removes all items from the [PopupMenu]. If [param free_submenus] is [code]true[/code], the submenu nodes are automatically freed.
*/
//go:nosplit
func (self class) Clear(free_submenus bool) { //gd:PopupMenu.clear
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.clear, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ free_submenus bool }{free_submenus}))
}

//go:nosplit
func (self class) SetHideOnItemSelection(enable bool) { //gd:PopupMenu.set_hide_on_item_selection
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_hide_on_item_selection, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

//go:nosplit
func (self class) IsHideOnItemSelection() bool { //gd:PopupMenu.is_hide_on_item_selection
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_hide_on_item_selection, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetHideOnCheckableItemSelection(enable bool) { //gd:PopupMenu.set_hide_on_checkable_item_selection
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_hide_on_checkable_item_selection, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

//go:nosplit
func (self class) IsHideOnCheckableItemSelection() bool { //gd:PopupMenu.is_hide_on_checkable_item_selection
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_hide_on_checkable_item_selection, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetHideOnStateItemSelection(enable bool) { //gd:PopupMenu.set_hide_on_state_item_selection
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_hide_on_state_item_selection, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

//go:nosplit
func (self class) IsHideOnStateItemSelection() bool { //gd:PopupMenu.is_hide_on_state_item_selection
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_hide_on_state_item_selection, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetSubmenuPopupDelay(seconds float64) { //gd:PopupMenu.set_submenu_popup_delay
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_submenu_popup_delay, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ seconds float64 }{seconds}))
}

//go:nosplit
func (self class) GetSubmenuPopupDelay() float64 { //gd:PopupMenu.get_submenu_popup_delay
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_submenu_popup_delay, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetAllowSearch(allow bool) { //gd:PopupMenu.set_allow_search
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_allow_search, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ allow bool }{allow}))
}

//go:nosplit
func (self class) GetAllowSearch() bool { //gd:PopupMenu.get_allow_search
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.get_allow_search, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if the menu is bound to the special system menu.
*/
//go:nosplit
func (self class) IsSystemMenu() bool { //gd:PopupMenu.is_system_menu
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_system_menu, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetSystemMenu(system_menu_id NativeMenu.SystemMenus) { //gd:PopupMenu.set_system_menu
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_system_menu, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ system_menu_id NativeMenu.SystemMenus }{system_menu_id}))
}

//go:nosplit
func (self class) GetSystemMenu() NativeMenu.SystemMenus { //gd:PopupMenu.get_system_menu
	var r_ret = gdextension.Call[NativeMenu.SystemMenus](gd.ObjectChecked(self.AsObject()), methods.get_system_menu, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}
func (self Instance) OnIdPressed(cb func(id int), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("id_pressed"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) IdPressed() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`IdPressed`))))
}

func (self Instance) OnIdFocused(cb func(id int), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("id_focused"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) IdFocused() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`IdFocused`))))
}

func (self Instance) OnIndexPressed(cb func(index int), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("index_pressed"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) IndexPressed() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`IndexPressed`))))
}

func (self Instance) OnMenuChanged(cb func(), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("menu_changed"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) MenuChanged() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`MenuChanged`))))
}

func (self class) AsPopupMenu() Advanced             { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsPopupMenu() Instance          { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsPopupMenu() Instance     { return self.Super().AsPopupMenu() }
func (self class) AsPopup() Popup.Advanced           { return *((*Popup.Advanced)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsPopup() Popup.Instance   { return self.Super().AsPopup() }
func (self Instance) AsPopup() Popup.Instance        { return *((*Popup.Instance)(unsafe.Pointer(&self))) }
func (self class) AsWindow() Window.Advanced         { return *((*Window.Advanced)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsWindow() Window.Instance { return self.Super().AsWindow() }
func (self Instance) AsWindow() Window.Instance      { return *((*Window.Instance)(unsafe.Pointer(&self))) }
func (self class) AsViewport() Viewport.Advanced {
	return *((*Viewport.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsViewport() Viewport.Instance { return self.Super().AsViewport() }
func (self Instance) AsViewport() Viewport.Instance {
	return *((*Viewport.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsNode() Node.Advanced         { return *((*Node.Advanced)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsNode() Node.Instance { return self.Super().AsNode() }
func (self Instance) AsNode() Node.Instance      { return *((*Node.Instance)(unsafe.Pointer(&self))) }

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Popup.Advanced(self.AsPopup()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Popup.Instance(self.AsPopup()), name)
	}
}
func init() {
	gdclass.Register("PopupMenu", func(ptr gd.Object) any { return *(*Instance)(unsafe.Pointer(&ptr)) })
}
