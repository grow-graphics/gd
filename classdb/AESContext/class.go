// Code generated by the generate package DO NOT EDIT

// Package AESContext provides methods for working with AESContext object instances.
package AESContext

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/variant/Signal"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Signal.Any
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
This class holds the context information required for encryption and decryption operations with AES (Advanced Encryption Standard). Both AES-ECB and AES-CBC modes are supported.
[codeblocks]
[gdscript]
extends Node

var aes = AESContext.new()

func _ready():

	var key = "My secret key!!!" # Key must be either 16 or 32 bytes.
	var data = "My secret text!!" # Data size must be multiple of 16 bytes, apply padding if needed.
	# Encrypt ECB
	aes.start(AESContext.MODE_ECB_ENCRYPT, key.to_utf8_buffer())
	var encrypted = aes.update(data.to_utf8_buffer())
	aes.finish()
	# Decrypt ECB
	aes.start(AESContext.MODE_ECB_DECRYPT, key.to_utf8_buffer())
	var decrypted = aes.update(encrypted)
	aes.finish()
	# Check ECB
	assert(decrypted == data.to_utf8_buffer())

	var iv = "My secret iv!!!!" # IV must be of exactly 16 bytes.
	# Encrypt CBC
	aes.start(AESContext.MODE_CBC_ENCRYPT, key.to_utf8_buffer(), iv.to_utf8_buffer())
	encrypted = aes.update(data.to_utf8_buffer())
	aes.finish()
	# Decrypt CBC
	aes.start(AESContext.MODE_CBC_DECRYPT, key.to_utf8_buffer(), iv.to_utf8_buffer())
	decrypted = aes.update(encrypted)
	aes.finish()
	# Check CBC
	assert(decrypted == data.to_utf8_buffer())

[/gdscript]
[csharp]
using Godot;
using System.Diagnostics;

public partial class MyNode : Node

	{
	    private AesContext _aes = new AesContext();

	    public override void _Ready()
	    {
	        string key = "My secret key!!!"; // Key must be either 16 or 32 bytes.
	        string data = "My secret text!!"; // Data size must be multiple of 16 bytes, apply padding if needed.
	        // Encrypt ECB
	        _aes.Start(AesContext.Mode.EcbEncrypt, key.ToUtf8Buffer());
	        byte[] encrypted = _aes.Update(data.ToUtf8Buffer());
	        _aes.Finish();
	        // Decrypt ECB
	        _aes.Start(AesContext.Mode.EcbDecrypt, key.ToUtf8Buffer());
	        byte[] decrypted = _aes.Update(encrypted);
	        _aes.Finish();
	        // Check ECB
	        Debug.Assert(decrypted == data.ToUtf8Buffer());

	        string iv = "My secret iv!!!!"; // IV must be of exactly 16 bytes.
	        // Encrypt CBC
	        _aes.Start(AesContext.Mode.EcbEncrypt, key.ToUtf8Buffer(), iv.ToUtf8Buffer());
	        encrypted = _aes.Update(data.ToUtf8Buffer());
	        _aes.Finish();
	        // Decrypt CBC
	        _aes.Start(AesContext.Mode.EcbDecrypt, key.ToUtf8Buffer(), iv.ToUtf8Buffer());
	        decrypted = _aes.Update(encrypted);
	        _aes.Finish();
	        // Check CBC
	        Debug.Assert(decrypted == data.ToUtf8Buffer());
	    }
	}

[/csharp]
[/codeblocks]
*/
type Instance [1]gdclass.AESContext

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	start        gdextension.MethodForClass `hash:"3122411423"`
	update       gdextension.MethodForClass `hash:"527836100"`
	get_iv_state gdextension.MethodForClass `hash:"2115431945"`
	finish       gdextension.MethodForClass `hash:"3218959716"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("AESContext")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		gdextension.Free(gdextension.TypeStringName, &sname)
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

type Expanded [1]gdclass.AESContext

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsAESContext() Instance
}

/*
Start the AES context in the given [param mode]. A [param key] of either 16 or 32 bytes must always be provided, while an [param iv] (initialization vector) of exactly 16 bytes, is only needed when [param mode] is either [constant MODE_CBC_ENCRYPT] or [constant MODE_CBC_DECRYPT].
*/
func (self Instance) Start(mode Mode, key []byte) error { //gd:AESContext.start
	return error(gd.ToError(Advanced(self).Start(mode, Packed.Bytes(Packed.New(key...)), Packed.Bytes(Packed.New([1][]byte{}[0]...)))))
}

/*
Start the AES context in the given [param mode]. A [param key] of either 16 or 32 bytes must always be provided, while an [param iv] (initialization vector) of exactly 16 bytes, is only needed when [param mode] is either [constant MODE_CBC_ENCRYPT] or [constant MODE_CBC_DECRYPT].
*/
func (self Expanded) Start(mode Mode, key []byte, iv []byte) error { //gd:AESContext.start
	return error(gd.ToError(Advanced(self).Start(mode, Packed.Bytes(Packed.New(key...)), Packed.Bytes(Packed.New(iv...)))))
}

/*
Run the desired operation for this AES context. Will return a [PackedByteArray] containing the result of encrypting (or decrypting) the given [param src]. See [method start] for mode of operation.
[b]Note:[/b] The size of [param src] must be a multiple of 16. Apply some padding if needed.
*/
func (self Instance) Update(src []byte) []byte { //gd:AESContext.update
	return []byte(Advanced(self).Update(Packed.Bytes(Packed.New(src...))).Bytes())
}

/*
Get the current IV state for this context (IV gets updated when calling [method update]). You normally don't need this function.
[b]Note:[/b] This function only makes sense when the context is started with [constant MODE_CBC_ENCRYPT] or [constant MODE_CBC_DECRYPT].
*/
func (self Instance) GetIvState() []byte { //gd:AESContext.get_iv_state
	return []byte(Advanced(self).GetIvState().Bytes())
}

/*
Close this AES context so it can be started again. See [method start].
*/
func (self Instance) Finish() { //gd:AESContext.finish
	Advanced(self).Finish()
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.AESContext

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = pointers.AsA[gdclass.AESContext](obj[0])
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = pointers.AsA[gdclass.AESContext](obj[0])
		return true
	}
	return false
}
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }
func (self *Extension[T]) AsObject() [1]gd.Object { return self.Super().AsObject() }
func New() Instance {
	if !gd.Linked {
		var placeholder = Instance([1]gdclass.AESContext{pointers.Add[gdclass.AESContext]([3]uint64{})})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(pointers.AsA[gd.Object](placeholder[0]), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	casted := Instance([1]gdclass.AESContext{pointers.New[gdclass.AESContext]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})})
	casted.AsRefCounted()[0].InitRef()
	casted.AsObject()[0].Notification(0, false)
	return casted
}

/*
Start the AES context in the given [param mode]. A [param key] of either 16 or 32 bytes must always be provided, while an [param iv] (initialization vector) of exactly 16 bytes, is only needed when [param mode] is either [constant MODE_CBC_ENCRYPT] or [constant MODE_CBC_DECRYPT].
*/
//go:nosplit
func (self class) Start(mode Mode, key Packed.Bytes, iv Packed.Bytes) Error.Code { //gd:AESContext.start
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.start, gdextension.SizeInt|(gdextension.SizeInt<<4)|(gdextension.SizePackedArray<<8)|(gdextension.SizePackedArray<<12), unsafe.Pointer(&struct {
		mode Mode
		key  gdextension.PackedArray[byte]
		iv   gdextension.PackedArray[byte]
	}{mode, pointers.Get(gd.InternalPacked[gd.PackedByteArray, byte](Packed.Array[byte](key))), pointers.Get(gd.InternalPacked[gd.PackedByteArray, byte](Packed.Array[byte](iv)))}))
	var ret = Error.Code(r_ret)
	return ret
}

/*
Run the desired operation for this AES context. Will return a [PackedByteArray] containing the result of encrypting (or decrypting) the given [param src]. See [method start] for mode of operation.
[b]Note:[/b] The size of [param src] must be a multiple of 16. Apply some padding if needed.
*/
//go:nosplit
func (self class) Update(src Packed.Bytes) Packed.Bytes { //gd:AESContext.update
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.update, gdextension.SizePackedArray|(gdextension.SizePackedArray<<4), unsafe.Pointer(&struct{ src gdextension.PackedArray[byte] }{pointers.Get(gd.InternalPacked[gd.PackedByteArray, byte](Packed.Array[byte](src)))}))
	var ret = Packed.Bytes(Array.Through(gd.PackedProxy[gd.PackedByteArray, byte]{}, pointers.Pack(pointers.Let[gd.PackedByteArray](r_ret))))
	return ret
}

/*
Get the current IV state for this context (IV gets updated when calling [method update]). You normally don't need this function.
[b]Note:[/b] This function only makes sense when the context is started with [constant MODE_CBC_ENCRYPT] or [constant MODE_CBC_DECRYPT].
*/
//go:nosplit
func (self class) GetIvState() Packed.Bytes { //gd:AESContext.get_iv_state
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.get_iv_state, gdextension.SizePackedArray, unsafe.Pointer(&struct{}{}))
	var ret = Packed.Bytes(Array.Through(gd.PackedProxy[gd.PackedByteArray, byte]{}, pointers.Pack(pointers.Let[gd.PackedByteArray](r_ret))))
	return ret
}

/*
Close this AES context so it can be started again. See [method start].
*/
//go:nosplit
func (self class) Finish() { //gd:AESContext.finish
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.finish, 0, unsafe.Pointer(&struct{}{}))
}
func (self class) AsAESContext() Advanced { return Advanced{pointers.AsA[gdclass.AESContext](self[0])} }
func (self Instance) AsAESContext() Instance {
	return Instance{pointers.AsA[gdclass.AESContext](self[0])}
}
func (self *Extension[T]) AsAESContext() Instance { return self.Super().AsAESContext() }
func (self class) AsRefCounted() [1]gd.RefCounted {
	return [1]gd.RefCounted{gd.RefCounted(pointers.AsA[gd.Object](self[0]))}
}
func (self *Extension[T]) AsRefCounted() [1]gd.RefCounted { return self.Super().AsRefCounted() }
func (self Instance) AsRefCounted() [1]gd.RefCounted {
	return [1]gd.RefCounted{gd.RefCounted(pointers.AsA[gd.Object](self[0]))}
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(RefCounted.Advanced(self.AsRefCounted()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(RefCounted.Instance(self.AsRefCounted()), name)
	}
}
func init() {
	gdclass.Register("AESContext", func(ptr gd.Object) any { return Instance{pointers.AsA[gdclass.AESContext](ptr)} })
}

type Mode int //gd:AESContext.Mode

const (
	/*AES electronic codebook encryption mode.*/
	ModeEcbEncrypt Mode = 0
	/*AES electronic codebook decryption mode.*/
	ModeEcbDecrypt Mode = 1
	/*AES cipher blocker chaining encryption mode.*/
	ModeCbcEncrypt Mode = 2
	/*AES cipher blocker chaining decryption mode.*/
	ModeCbcDecrypt Mode = 3
	/*Maximum value for the mode enum.*/
	ModeMax Mode = 4
)
