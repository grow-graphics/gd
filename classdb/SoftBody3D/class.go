// Code generated by the generate package DO NOT EDIT

// Package SoftBody3D provides methods for working with SoftBody3D object instances.
package SoftBody3D

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/GeometryInstance3D"
import "graphics.gd/classdb/MeshInstance3D"
import "graphics.gd/classdb/Node"
import "graphics.gd/classdb/Node3D"
import "graphics.gd/classdb/PhysicsBody3D"
import "graphics.gd/classdb/VisualInstance3D"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"
import "graphics.gd/variant/Vector3"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
A deformable 3D physics mesh. Used to create elastic or deformable objects such as cloth, rubber, or other flexible materials.
Additionally, [SoftBody3D] is subject to wind forces defined in [Area3D] (see [member Area3D.wind_source_path], [member Area3D.wind_force_magnitude], and [member Area3D.wind_attenuation_factor]).
[b]Note:[/b] There are many known bugs in [SoftBody3D]. Therefore, it's not recommended to use them for things that can affect gameplay (such as trampolines).
*/
type Instance [1]gdclass.SoftBody3D

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	get_physics_rid                 gdextension.MethodForClass `hash:"2944877500"`
	set_collision_mask              gdextension.MethodForClass `hash:"1286410249"`
	get_collision_mask              gdextension.MethodForClass `hash:"3905245786"`
	set_collision_layer             gdextension.MethodForClass `hash:"1286410249"`
	get_collision_layer             gdextension.MethodForClass `hash:"3905245786"`
	set_collision_mask_value        gdextension.MethodForClass `hash:"300928843"`
	get_collision_mask_value        gdextension.MethodForClass `hash:"1116898809"`
	set_collision_layer_value       gdextension.MethodForClass `hash:"300928843"`
	get_collision_layer_value       gdextension.MethodForClass `hash:"1116898809"`
	set_parent_collision_ignore     gdextension.MethodForClass `hash:"1348162250"`
	get_parent_collision_ignore     gdextension.MethodForClass `hash:"4075236667"`
	set_disable_mode                gdextension.MethodForClass `hash:"1104158384"`
	get_disable_mode                gdextension.MethodForClass `hash:"4135042476"`
	get_collision_exceptions        gdextension.MethodForClass `hash:"2915620761"`
	add_collision_exception_with    gdextension.MethodForClass `hash:"1078189570"`
	remove_collision_exception_with gdextension.MethodForClass `hash:"1078189570"`
	set_simulation_precision        gdextension.MethodForClass `hash:"1286410249"`
	get_simulation_precision        gdextension.MethodForClass `hash:"2455072627"`
	set_total_mass                  gdextension.MethodForClass `hash:"373806689"`
	get_total_mass                  gdextension.MethodForClass `hash:"191475506"`
	set_linear_stiffness            gdextension.MethodForClass `hash:"373806689"`
	get_linear_stiffness            gdextension.MethodForClass `hash:"191475506"`
	set_pressure_coefficient        gdextension.MethodForClass `hash:"373806689"`
	get_pressure_coefficient        gdextension.MethodForClass `hash:"191475506"`
	set_damping_coefficient         gdextension.MethodForClass `hash:"373806689"`
	get_damping_coefficient         gdextension.MethodForClass `hash:"191475506"`
	set_drag_coefficient            gdextension.MethodForClass `hash:"373806689"`
	get_drag_coefficient            gdextension.MethodForClass `hash:"191475506"`
	get_point_transform             gdextension.MethodForClass `hash:"871989493"`
	set_point_pinned                gdextension.MethodForClass `hash:"528784402"`
	is_point_pinned                 gdextension.MethodForClass `hash:"1116898809"`
	set_ray_pickable                gdextension.MethodForClass `hash:"2586408642"`
	is_ray_pickable                 gdextension.MethodForClass `hash:"36873697"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("SoftBody3D")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		pointers.Raw[gd.StringName](sname).Free()
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

type Expanded [1]gdclass.SoftBody3D

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsSoftBody3D() Instance
}

/*
Returns the internal [RID] used by the [PhysicsServer3D] for this body.
*/
func (self Instance) GetPhysicsRid() RID.SoftBody3D { //gd:SoftBody3D.get_physics_rid
	return RID.SoftBody3D(Advanced(self).GetPhysicsRid())
}

/*
Based on [param value], enables or disables the specified layer in the [member collision_mask], given a [param layer_number] between 1 and 32.
*/
func (self Instance) SetCollisionMaskValue(layer_number int, value bool) { //gd:SoftBody3D.set_collision_mask_value
	Advanced(self).SetCollisionMaskValue(int64(layer_number), value)
}

/*
Returns whether or not the specified layer of the [member collision_mask] is enabled, given a [param layer_number] between 1 and 32.
*/
func (self Instance) GetCollisionMaskValue(layer_number int) bool { //gd:SoftBody3D.get_collision_mask_value
	return bool(Advanced(self).GetCollisionMaskValue(int64(layer_number)))
}

/*
Based on [param value], enables or disables the specified layer in the [member collision_layer], given a [param layer_number] between 1 and 32.
*/
func (self Instance) SetCollisionLayerValue(layer_number int, value bool) { //gd:SoftBody3D.set_collision_layer_value
	Advanced(self).SetCollisionLayerValue(int64(layer_number), value)
}

/*
Returns whether or not the specified layer of the [member collision_layer] is enabled, given a [param layer_number] between 1 and 32.
*/
func (self Instance) GetCollisionLayerValue(layer_number int) bool { //gd:SoftBody3D.get_collision_layer_value
	return bool(Advanced(self).GetCollisionLayerValue(int64(layer_number)))
}

/*
Returns an array of nodes that were added as collision exceptions for this body.
*/
func (self Instance) GetCollisionExceptions() []PhysicsBody3D.Instance { //gd:SoftBody3D.get_collision_exceptions
	return []PhysicsBody3D.Instance(gd.ArrayAs[[]PhysicsBody3D.Instance](gd.InternalArray(Advanced(self).GetCollisionExceptions())))
}

/*
Adds a body to the list of bodies that this body can't collide with.
*/
func (self Instance) AddCollisionExceptionWith(body Node.Instance) { //gd:SoftBody3D.add_collision_exception_with
	Advanced(self).AddCollisionExceptionWith(body)
}

/*
Removes a body from the list of bodies that this body can't collide with.
*/
func (self Instance) RemoveCollisionExceptionWith(body Node.Instance) { //gd:SoftBody3D.remove_collision_exception_with
	Advanced(self).RemoveCollisionExceptionWith(body)
}

/*
Returns local translation of a vertex in the surface array.
*/
func (self Instance) GetPointTransform(point_index int) Vector3.XYZ { //gd:SoftBody3D.get_point_transform
	return Vector3.XYZ(Advanced(self).GetPointTransform(int64(point_index)))
}

/*
Sets the pinned state of a surface vertex. When set to [code]true[/code], the optional [param attachment_path] can define a [Node3D] the pinned vertex will be attached to.
*/
func (self Instance) SetPointPinned(point_index int, pinned bool) { //gd:SoftBody3D.set_point_pinned
	Advanced(self).SetPointPinned(int64(point_index), pinned, Path.ToNode(String.New("")), int64(-1))
}

/*
Sets the pinned state of a surface vertex. When set to [code]true[/code], the optional [param attachment_path] can define a [Node3D] the pinned vertex will be attached to.
*/
func (self Expanded) SetPointPinned(point_index int, pinned bool, attachment_path string, insert_at int) { //gd:SoftBody3D.set_point_pinned
	Advanced(self).SetPointPinned(int64(point_index), pinned, Path.ToNode(String.New(attachment_path)), int64(insert_at))
}

/*
Returns [code]true[/code] if vertex is set to pinned.
*/
func (self Instance) IsPointPinned(point_index int) bool { //gd:SoftBody3D.is_point_pinned
	return bool(Advanced(self).IsPointPinned(int64(point_index)))
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.SoftBody3D

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.SoftBody3D)(unsafe.Pointer(&obj))
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.SoftBody3D)(unsafe.Pointer(&obj))
		return true
	}
	return false
}

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {

	if !gd.Linked {
		var placeholder Instance
		*(*gd.Object)(unsafe.Pointer(&placeholder)) = pointers.Add[gd.Object]([3]uint64{})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(*(*gd.Object)(unsafe.Pointer(&placeholder)), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	object := [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})}
	casted := Instance{*(*gdclass.SoftBody3D)(unsafe.Pointer(&object))}
	object[0].Notification(0, false)
	return casted
}

func (self Instance) CollisionLayer() int {
	return int(int(class(self).GetCollisionLayer()))
}

func (self Instance) SetCollisionLayer(value int) {
	class(self).SetCollisionLayer(int64(value))
}

func (self Instance) CollisionMask() int {
	return int(int(class(self).GetCollisionMask()))
}

func (self Instance) SetCollisionMask(value int) {
	class(self).SetCollisionMask(int64(value))
}

func (self Instance) ParentCollisionIgnore() string {
	return string(class(self).GetParentCollisionIgnore().String())
}

func (self Instance) SetParentCollisionIgnore(value string) {
	class(self).SetParentCollisionIgnore(Path.ToNode(String.New(value)))
}

func (self Instance) SimulationPrecision() int {
	return int(int(class(self).GetSimulationPrecision()))
}

func (self Instance) SetSimulationPrecision(value int) {
	class(self).SetSimulationPrecision(int64(value))
}

func (self Instance) TotalMass() Float.X {
	return Float.X(Float.X(class(self).GetTotalMass()))
}

func (self Instance) SetTotalMass(value Float.X) {
	class(self).SetTotalMass(float64(value))
}

func (self Instance) LinearStiffness() Float.X {
	return Float.X(Float.X(class(self).GetLinearStiffness()))
}

func (self Instance) SetLinearStiffness(value Float.X) {
	class(self).SetLinearStiffness(float64(value))
}

func (self Instance) PressureCoefficient() Float.X {
	return Float.X(Float.X(class(self).GetPressureCoefficient()))
}

func (self Instance) SetPressureCoefficient(value Float.X) {
	class(self).SetPressureCoefficient(float64(value))
}

func (self Instance) DampingCoefficient() Float.X {
	return Float.X(Float.X(class(self).GetDampingCoefficient()))
}

func (self Instance) SetDampingCoefficient(value Float.X) {
	class(self).SetDampingCoefficient(float64(value))
}

func (self Instance) DragCoefficient() Float.X {
	return Float.X(Float.X(class(self).GetDragCoefficient()))
}

func (self Instance) SetDragCoefficient(value Float.X) {
	class(self).SetDragCoefficient(float64(value))
}

func (self Instance) RayPickable() bool {
	return bool(class(self).IsRayPickable())
}

func (self Instance) SetRayPickable(value bool) {
	class(self).SetRayPickable(value)
}

func (self Instance) DisableMode() DisableMode {
	return DisableMode(class(self).GetDisableMode())
}

func (self Instance) SetDisableMode(value DisableMode) {
	class(self).SetDisableMode(value)
}

/*
Returns the internal [RID] used by the [PhysicsServer3D] for this body.
*/
//go:nosplit
func (self class) GetPhysicsRid() RID.Any { //gd:SoftBody3D.get_physics_rid
	var r_ret = gdextension.Call[RID.Any](gd.ObjectChecked(self.AsObject()), methods.get_physics_rid, gdextension.SizeRID, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetCollisionMask(collision_mask int64) { //gd:SoftBody3D.set_collision_mask
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_collision_mask, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ collision_mask int64 }{collision_mask}))
}

//go:nosplit
func (self class) GetCollisionMask() int64 { //gd:SoftBody3D.get_collision_mask
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_collision_mask, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetCollisionLayer(collision_layer int64) { //gd:SoftBody3D.set_collision_layer
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_collision_layer, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ collision_layer int64 }{collision_layer}))
}

//go:nosplit
func (self class) GetCollisionLayer() int64 { //gd:SoftBody3D.get_collision_layer
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_collision_layer, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Based on [param value], enables or disables the specified layer in the [member collision_mask], given a [param layer_number] between 1 and 32.
*/
//go:nosplit
func (self class) SetCollisionMaskValue(layer_number int64, value bool) { //gd:SoftBody3D.set_collision_mask_value
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_collision_mask_value, 0|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		layer_number int64
		value        bool
	}{layer_number, value}))
}

/*
Returns whether or not the specified layer of the [member collision_mask] is enabled, given a [param layer_number] between 1 and 32.
*/
//go:nosplit
func (self class) GetCollisionMaskValue(layer_number int64) bool { //gd:SoftBody3D.get_collision_mask_value
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.get_collision_mask_value, gdextension.SizeBool|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ layer_number int64 }{layer_number}))
	var ret = r_ret
	return ret
}

/*
Based on [param value], enables or disables the specified layer in the [member collision_layer], given a [param layer_number] between 1 and 32.
*/
//go:nosplit
func (self class) SetCollisionLayerValue(layer_number int64, value bool) { //gd:SoftBody3D.set_collision_layer_value
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_collision_layer_value, 0|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		layer_number int64
		value        bool
	}{layer_number, value}))
}

/*
Returns whether or not the specified layer of the [member collision_layer] is enabled, given a [param layer_number] between 1 and 32.
*/
//go:nosplit
func (self class) GetCollisionLayerValue(layer_number int64) bool { //gd:SoftBody3D.get_collision_layer_value
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.get_collision_layer_value, gdextension.SizeBool|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ layer_number int64 }{layer_number}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetParentCollisionIgnore(parent_collision_ignore Path.ToNode) { //gd:SoftBody3D.set_parent_collision_ignore
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_parent_collision_ignore, 0|(gdextension.SizeNodePath<<4), unsafe.Pointer(&struct{ parent_collision_ignore gdextension.NodePath }{pointers.Get(gd.InternalNodePath(parent_collision_ignore))}))
}

//go:nosplit
func (self class) GetParentCollisionIgnore() Path.ToNode { //gd:SoftBody3D.get_parent_collision_ignore
	var r_ret = gdextension.Call[gdextension.NodePath](gd.ObjectChecked(self.AsObject()), methods.get_parent_collision_ignore, gdextension.SizeNodePath, unsafe.Pointer(&struct{}{}))
	var ret = Path.ToNode(String.Via(gd.NodePathProxy{}, pointers.Pack(pointers.New[gd.NodePath](r_ret))))
	return ret
}

//go:nosplit
func (self class) SetDisableMode(mode DisableMode) { //gd:SoftBody3D.set_disable_mode
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_disable_mode, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ mode DisableMode }{mode}))
}

//go:nosplit
func (self class) GetDisableMode() DisableMode { //gd:SoftBody3D.get_disable_mode
	var r_ret = gdextension.Call[DisableMode](gd.ObjectChecked(self.AsObject()), methods.get_disable_mode, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns an array of nodes that were added as collision exceptions for this body.
*/
//go:nosplit
func (self class) GetCollisionExceptions() Array.Contains[[1]gdclass.PhysicsBody3D] { //gd:SoftBody3D.get_collision_exceptions
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), methods.get_collision_exceptions, gdextension.SizeArray, unsafe.Pointer(&struct{}{}))
	var ret = Array.Through(gd.ArrayProxy[[1]gdclass.PhysicsBody3D]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

/*
Adds a body to the list of bodies that this body can't collide with.
*/
//go:nosplit
func (self class) AddCollisionExceptionWith(body [1]gdclass.Node) { //gd:SoftBody3D.add_collision_exception_with
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_collision_exception_with, 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ body gdextension.Object }{gdextension.Object(gd.ObjectChecked(body[0].AsObject()))}))
}

/*
Removes a body from the list of bodies that this body can't collide with.
*/
//go:nosplit
func (self class) RemoveCollisionExceptionWith(body [1]gdclass.Node) { //gd:SoftBody3D.remove_collision_exception_with
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.remove_collision_exception_with, 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ body gdextension.Object }{gdextension.Object(gd.ObjectChecked(body[0].AsObject()))}))
}

//go:nosplit
func (self class) SetSimulationPrecision(simulation_precision int64) { //gd:SoftBody3D.set_simulation_precision
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_simulation_precision, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ simulation_precision int64 }{simulation_precision}))
}

//go:nosplit
func (self class) GetSimulationPrecision() int64 { //gd:SoftBody3D.get_simulation_precision
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_simulation_precision, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetTotalMass(mass float64) { //gd:SoftBody3D.set_total_mass
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_total_mass, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ mass float64 }{mass}))
}

//go:nosplit
func (self class) GetTotalMass() float64 { //gd:SoftBody3D.get_total_mass
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_total_mass, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetLinearStiffness(linear_stiffness float64) { //gd:SoftBody3D.set_linear_stiffness
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_linear_stiffness, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ linear_stiffness float64 }{linear_stiffness}))
}

//go:nosplit
func (self class) GetLinearStiffness() float64 { //gd:SoftBody3D.get_linear_stiffness
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_linear_stiffness, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetPressureCoefficient(pressure_coefficient float64) { //gd:SoftBody3D.set_pressure_coefficient
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_pressure_coefficient, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ pressure_coefficient float64 }{pressure_coefficient}))
}

//go:nosplit
func (self class) GetPressureCoefficient() float64 { //gd:SoftBody3D.get_pressure_coefficient
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_pressure_coefficient, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetDampingCoefficient(damping_coefficient float64) { //gd:SoftBody3D.set_damping_coefficient
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_damping_coefficient, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ damping_coefficient float64 }{damping_coefficient}))
}

//go:nosplit
func (self class) GetDampingCoefficient() float64 { //gd:SoftBody3D.get_damping_coefficient
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_damping_coefficient, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetDragCoefficient(drag_coefficient float64) { //gd:SoftBody3D.set_drag_coefficient
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_drag_coefficient, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ drag_coefficient float64 }{drag_coefficient}))
}

//go:nosplit
func (self class) GetDragCoefficient() float64 { //gd:SoftBody3D.get_drag_coefficient
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_drag_coefficient, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns local translation of a vertex in the surface array.
*/
//go:nosplit
func (self class) GetPointTransform(point_index int64) Vector3.XYZ { //gd:SoftBody3D.get_point_transform
	var r_ret = gdextension.Call[Vector3.XYZ](gd.ObjectChecked(self.AsObject()), methods.get_point_transform, gdextension.SizeVector3|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ point_index int64 }{point_index}))
	var ret = r_ret
	return ret
}

/*
Sets the pinned state of a surface vertex. When set to [code]true[/code], the optional [param attachment_path] can define a [Node3D] the pinned vertex will be attached to.
*/
//go:nosplit
func (self class) SetPointPinned(point_index int64, pinned bool, attachment_path Path.ToNode, insert_at int64) { //gd:SoftBody3D.set_point_pinned
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_point_pinned, 0|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8)|(gdextension.SizeNodePath<<12)|(gdextension.SizeInt<<16), unsafe.Pointer(&struct {
		point_index     int64
		pinned          bool
		attachment_path gdextension.NodePath
		insert_at       int64
	}{point_index, pinned, pointers.Get(gd.InternalNodePath(attachment_path)), insert_at}))
}

/*
Returns [code]true[/code] if vertex is set to pinned.
*/
//go:nosplit
func (self class) IsPointPinned(point_index int64) bool { //gd:SoftBody3D.is_point_pinned
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_point_pinned, gdextension.SizeBool|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ point_index int64 }{point_index}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetRayPickable(ray_pickable bool) { //gd:SoftBody3D.set_ray_pickable
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_ray_pickable, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ ray_pickable bool }{ray_pickable}))
}

//go:nosplit
func (self class) IsRayPickable() bool { //gd:SoftBody3D.is_ray_pickable
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_ray_pickable, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}
func (self class) AsSoftBody3D() Advanced         { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsSoftBody3D() Instance      { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsSoftBody3D() Instance { return self.Super().AsSoftBody3D() }
func (self class) AsMeshInstance3D() MeshInstance3D.Advanced {
	return *((*MeshInstance3D.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsMeshInstance3D() MeshInstance3D.Instance {
	return self.Super().AsMeshInstance3D()
}
func (self Instance) AsMeshInstance3D() MeshInstance3D.Instance {
	return *((*MeshInstance3D.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsGeometryInstance3D() GeometryInstance3D.Advanced {
	return *((*GeometryInstance3D.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsGeometryInstance3D() GeometryInstance3D.Instance {
	return self.Super().AsGeometryInstance3D()
}
func (self Instance) AsGeometryInstance3D() GeometryInstance3D.Instance {
	return *((*GeometryInstance3D.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsVisualInstance3D() VisualInstance3D.Advanced {
	return *((*VisualInstance3D.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsVisualInstance3D() VisualInstance3D.Instance {
	return self.Super().AsVisualInstance3D()
}
func (self Instance) AsVisualInstance3D() VisualInstance3D.Instance {
	return *((*VisualInstance3D.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsNode3D() Node3D.Advanced         { return *((*Node3D.Advanced)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsNode3D() Node3D.Instance { return self.Super().AsNode3D() }
func (self Instance) AsNode3D() Node3D.Instance      { return *((*Node3D.Instance)(unsafe.Pointer(&self))) }
func (self class) AsNode() Node.Advanced             { return *((*Node.Advanced)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsNode() Node.Instance     { return self.Super().AsNode() }
func (self Instance) AsNode() Node.Instance          { return *((*Node.Instance)(unsafe.Pointer(&self))) }

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(MeshInstance3D.Advanced(self.AsMeshInstance3D()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(MeshInstance3D.Instance(self.AsMeshInstance3D()), name)
	}
}
func init() {
	gdclass.Register("SoftBody3D", func(ptr gd.Object) any { return *(*Instance)(unsafe.Pointer(&ptr)) })
}

type DisableMode int //gd:SoftBody3D.DisableMode

const (
	/*When [member Node.process_mode] is set to [constant Node.PROCESS_MODE_DISABLED], remove from the physics simulation to stop all physics interactions with this [SoftBody3D].
	  Automatically re-added to the physics simulation when the [Node] is processed again.*/
	DisableModeRemove DisableMode = 0
	/*When [member Node.process_mode] is set to [constant Node.PROCESS_MODE_DISABLED], do not affect the physics simulation.*/
	DisableModeKeepActive DisableMode = 1
)
