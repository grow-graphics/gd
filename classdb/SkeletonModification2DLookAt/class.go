// Code generated by the generate package DO NOT EDIT

// Package SkeletonModification2DLookAt provides methods for working with SkeletonModification2DLookAt object instances.
package SkeletonModification2DLookAt

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/Resource"
import "graphics.gd/classdb/SkeletonModification2D"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
This [SkeletonModification2D] rotates a bone to look a target. This is extremely helpful for moving character's head to look at the player, rotating a turret to look at a target, or any other case where you want to make a bone rotate towards something quickly and easily.
*/
type Instance [1]gdclass.SkeletonModification2DLookAt

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	set_bone2d_node             gdextension.MethodForClass `hash:"1348162250"`
	get_bone2d_node             gdextension.MethodForClass `hash:"4075236667"`
	set_bone_index              gdextension.MethodForClass `hash:"1286410249"`
	get_bone_index              gdextension.MethodForClass `hash:"3905245786"`
	set_target_node             gdextension.MethodForClass `hash:"1348162250"`
	get_target_node             gdextension.MethodForClass `hash:"4075236667"`
	set_additional_rotation     gdextension.MethodForClass `hash:"373806689"`
	get_additional_rotation     gdextension.MethodForClass `hash:"1740695150"`
	set_enable_constraint       gdextension.MethodForClass `hash:"2586408642"`
	get_enable_constraint       gdextension.MethodForClass `hash:"36873697"`
	set_constraint_angle_min    gdextension.MethodForClass `hash:"373806689"`
	get_constraint_angle_min    gdextension.MethodForClass `hash:"1740695150"`
	set_constraint_angle_max    gdextension.MethodForClass `hash:"373806689"`
	get_constraint_angle_max    gdextension.MethodForClass `hash:"1740695150"`
	set_constraint_angle_invert gdextension.MethodForClass `hash:"2586408642"`
	get_constraint_angle_invert gdextension.MethodForClass `hash:"36873697"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("SkeletonModification2DLookAt")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		gdextension.Free(gdextension.TypeStringName, &sname)
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsSkeletonModification2DLookAt() Instance
}

/*
Sets the amount of additional rotation that is to be applied after executing the modification. This allows for offsetting the results by the inputted rotation amount.
*/
func (self Instance) SetAdditionalRotation(rotation Angle.Radians) { //gd:SkeletonModification2DLookAt.set_additional_rotation
	Advanced(self).SetAdditionalRotation(float64(rotation))
}

/*
Returns the amount of additional rotation that is applied after the LookAt modification executes.
*/
func (self Instance) GetAdditionalRotation() Angle.Radians { //gd:SkeletonModification2DLookAt.get_additional_rotation
	return Angle.Radians(Float.X(Advanced(self).GetAdditionalRotation()))
}

/*
Sets whether this modification will use constraints or not. When [code]true[/code], constraints will be applied when solving the LookAt modification.
*/
func (self Instance) SetEnableConstraint(enable_constraint bool) { //gd:SkeletonModification2DLookAt.set_enable_constraint
	Advanced(self).SetEnableConstraint(enable_constraint)
}

/*
Returns [code]true[/code] if the LookAt modification is using constraints.
*/
func (self Instance) GetEnableConstraint() bool { //gd:SkeletonModification2DLookAt.get_enable_constraint
	return bool(Advanced(self).GetEnableConstraint())
}

/*
Sets the constraint's minimum allowed angle.
*/
func (self Instance) SetConstraintAngleMin(angle_min Angle.Radians) { //gd:SkeletonModification2DLookAt.set_constraint_angle_min
	Advanced(self).SetConstraintAngleMin(float64(angle_min))
}

/*
Returns the constraint's minimum allowed angle.
*/
func (self Instance) GetConstraintAngleMin() Angle.Radians { //gd:SkeletonModification2DLookAt.get_constraint_angle_min
	return Angle.Radians(Float.X(Advanced(self).GetConstraintAngleMin()))
}

/*
Sets the constraint's maximum allowed angle.
*/
func (self Instance) SetConstraintAngleMax(angle_max Angle.Radians) { //gd:SkeletonModification2DLookAt.set_constraint_angle_max
	Advanced(self).SetConstraintAngleMax(float64(angle_max))
}

/*
Returns the constraint's maximum allowed angle.
*/
func (self Instance) GetConstraintAngleMax() Angle.Radians { //gd:SkeletonModification2DLookAt.get_constraint_angle_max
	return Angle.Radians(Float.X(Advanced(self).GetConstraintAngleMax()))
}

/*
When [code]true[/code], the modification will use an inverted joint constraint.
An inverted joint constraint only constraints the [Bone2D] to the angles [i]outside of[/i] the inputted minimum and maximum angles. For this reason, it is referred to as an inverted joint constraint, as it constraints the joint to the outside of the inputted values.
*/
func (self Instance) SetConstraintAngleInvert(invert bool) { //gd:SkeletonModification2DLookAt.set_constraint_angle_invert
	Advanced(self).SetConstraintAngleInvert(invert)
}

/*
Returns whether the constraints to this modification are inverted or not.
*/
func (self Instance) GetConstraintAngleInvert() bool { //gd:SkeletonModification2DLookAt.get_constraint_angle_invert
	return bool(Advanced(self).GetConstraintAngleInvert())
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.SkeletonModification2DLookAt

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.SkeletonModification2DLookAt)(unsafe.Pointer(&obj))
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.SkeletonModification2DLookAt)(unsafe.Pointer(&obj))
		return true
	}
	return false
}

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {

	if !gd.Linked {
		var placeholder Instance
		*(*gd.Object)(unsafe.Pointer(&placeholder)) = pointers.Add[gd.Object]([3]uint64{})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(*(*gd.Object)(unsafe.Pointer(&placeholder)), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	object := [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})}
	casted := Instance{*(*gdclass.SkeletonModification2DLookAt)(unsafe.Pointer(&object))}
	object[0].Notification(0, false)
	return casted
}

func (self Instance) BoneIndex() int {
	return int(int(class(self).GetBoneIndex()))
}

func (self Instance) SetBoneIndex(value int) {
	class(self).SetBoneIndex(int64(value))
}

func (self Instance) Bone2dNode() string {
	return string(class(self).GetBone2dNode().String())
}

func (self Instance) SetBone2dNode(value string) {
	class(self).SetBone2dNode(Path.ToNode(String.New(value)))
}

func (self Instance) TargetNodepath() string {
	return string(class(self).GetTargetNode().String())
}

func (self Instance) SetTargetNodepath(value string) {
	class(self).SetTargetNode(Path.ToNode(String.New(value)))
}

//go:nosplit
func (self class) SetBone2dNode(bone2d_nodepath Path.ToNode) { //gd:SkeletonModification2DLookAt.set_bone2d_node
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_bone2d_node, 0|(gdextension.SizeNodePath<<4), unsafe.Pointer(&struct{ bone2d_nodepath gdextension.NodePath }{pointers.Get(gd.InternalNodePath(bone2d_nodepath))}))
}

//go:nosplit
func (self class) GetBone2dNode() Path.ToNode { //gd:SkeletonModification2DLookAt.get_bone2d_node
	var r_ret = gdextension.Call[gdextension.NodePath](gd.ObjectChecked(self.AsObject()), methods.get_bone2d_node, gdextension.SizeNodePath, unsafe.Pointer(&struct{}{}))
	var ret = Path.ToNode(String.Via(gd.NodePathProxy{}, pointers.Pack(pointers.New[gd.NodePath](r_ret))))
	return ret
}

//go:nosplit
func (self class) SetBoneIndex(bone_idx int64) { //gd:SkeletonModification2DLookAt.set_bone_index
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_bone_index, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ bone_idx int64 }{bone_idx}))
}

//go:nosplit
func (self class) GetBoneIndex() int64 { //gd:SkeletonModification2DLookAt.get_bone_index
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_bone_index, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetTargetNode(target_nodepath Path.ToNode) { //gd:SkeletonModification2DLookAt.set_target_node
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_target_node, 0|(gdextension.SizeNodePath<<4), unsafe.Pointer(&struct{ target_nodepath gdextension.NodePath }{pointers.Get(gd.InternalNodePath(target_nodepath))}))
}

//go:nosplit
func (self class) GetTargetNode() Path.ToNode { //gd:SkeletonModification2DLookAt.get_target_node
	var r_ret = gdextension.Call[gdextension.NodePath](gd.ObjectChecked(self.AsObject()), methods.get_target_node, gdextension.SizeNodePath, unsafe.Pointer(&struct{}{}))
	var ret = Path.ToNode(String.Via(gd.NodePathProxy{}, pointers.Pack(pointers.New[gd.NodePath](r_ret))))
	return ret
}

/*
Sets the amount of additional rotation that is to be applied after executing the modification. This allows for offsetting the results by the inputted rotation amount.
*/
//go:nosplit
func (self class) SetAdditionalRotation(rotation float64) { //gd:SkeletonModification2DLookAt.set_additional_rotation
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_additional_rotation, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ rotation float64 }{rotation}))
}

/*
Returns the amount of additional rotation that is applied after the LookAt modification executes.
*/
//go:nosplit
func (self class) GetAdditionalRotation() float64 { //gd:SkeletonModification2DLookAt.get_additional_rotation
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_additional_rotation, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Sets whether this modification will use constraints or not. When [code]true[/code], constraints will be applied when solving the LookAt modification.
*/
//go:nosplit
func (self class) SetEnableConstraint(enable_constraint bool) { //gd:SkeletonModification2DLookAt.set_enable_constraint
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_enable_constraint, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable_constraint bool }{enable_constraint}))
}

/*
Returns [code]true[/code] if the LookAt modification is using constraints.
*/
//go:nosplit
func (self class) GetEnableConstraint() bool { //gd:SkeletonModification2DLookAt.get_enable_constraint
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.get_enable_constraint, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Sets the constraint's minimum allowed angle.
*/
//go:nosplit
func (self class) SetConstraintAngleMin(angle_min float64) { //gd:SkeletonModification2DLookAt.set_constraint_angle_min
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_constraint_angle_min, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ angle_min float64 }{angle_min}))
}

/*
Returns the constraint's minimum allowed angle.
*/
//go:nosplit
func (self class) GetConstraintAngleMin() float64 { //gd:SkeletonModification2DLookAt.get_constraint_angle_min
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_constraint_angle_min, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Sets the constraint's maximum allowed angle.
*/
//go:nosplit
func (self class) SetConstraintAngleMax(angle_max float64) { //gd:SkeletonModification2DLookAt.set_constraint_angle_max
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_constraint_angle_max, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ angle_max float64 }{angle_max}))
}

/*
Returns the constraint's maximum allowed angle.
*/
//go:nosplit
func (self class) GetConstraintAngleMax() float64 { //gd:SkeletonModification2DLookAt.get_constraint_angle_max
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_constraint_angle_max, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
When [code]true[/code], the modification will use an inverted joint constraint.
An inverted joint constraint only constraints the [Bone2D] to the angles [i]outside of[/i] the inputted minimum and maximum angles. For this reason, it is referred to as an inverted joint constraint, as it constraints the joint to the outside of the inputted values.
*/
//go:nosplit
func (self class) SetConstraintAngleInvert(invert bool) { //gd:SkeletonModification2DLookAt.set_constraint_angle_invert
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_constraint_angle_invert, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ invert bool }{invert}))
}

/*
Returns whether the constraints to this modification are inverted or not.
*/
//go:nosplit
func (self class) GetConstraintAngleInvert() bool { //gd:SkeletonModification2DLookAt.get_constraint_angle_invert
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.get_constraint_angle_invert, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}
func (self class) AsSkeletonModification2DLookAt() Advanced {
	return *((*Advanced)(unsafe.Pointer(&self)))
}
func (self Instance) AsSkeletonModification2DLookAt() Instance {
	return *((*Instance)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsSkeletonModification2DLookAt() Instance {
	return self.Super().AsSkeletonModification2DLookAt()
}
func (self class) AsSkeletonModification2D() SkeletonModification2D.Advanced {
	return *((*SkeletonModification2D.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsSkeletonModification2D() SkeletonModification2D.Instance {
	return self.Super().AsSkeletonModification2D()
}
func (self Instance) AsSkeletonModification2D() SkeletonModification2D.Instance {
	return *((*SkeletonModification2D.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsResource() Resource.Advanced {
	return *((*Resource.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsResource() Resource.Instance { return self.Super().AsResource() }
func (self Instance) AsResource() Resource.Instance {
	return *((*Resource.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsRefCounted() [1]gd.RefCounted { return self.Super().AsRefCounted() }
func (self Instance) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(SkeletonModification2D.Advanced(self.AsSkeletonModification2D()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(SkeletonModification2D.Instance(self.AsSkeletonModification2D()), name)
	}
}
func init() {
	gdclass.Register("SkeletonModification2DLookAt", func(ptr gd.Object) any { return *(*Instance)(unsafe.Pointer(&ptr)) })
}
