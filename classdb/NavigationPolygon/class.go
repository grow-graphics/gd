// Code generated by the generate package DO NOT EDIT

// Package NavigationPolygon provides methods for working with NavigationPolygon object instances.
package NavigationPolygon

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/NavigationMesh"
import "graphics.gd/classdb/Resource"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/Rect2"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"
import "graphics.gd/variant/Vector2"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
A navigation mesh can be created either by baking it with the help of the [NavigationServer2D], or by adding vertices and convex polygon indices arrays manually.
To bake a navigation mesh at least one outline needs to be added that defines the outer bounds of the baked area.
[codeblocks]
[gdscript]
var new_navigation_mesh = NavigationPolygon.new()
var bounding_outline = PackedVector2Array([Vector2(0, 0), Vector2(0, 50), Vector2(50, 50), Vector2(50, 0)])
new_navigation_mesh.add_outline(bounding_outline)
NavigationServer2D.bake_from_source_geometry_data(new_navigation_mesh, NavigationMeshSourceGeometryData2D.new());
$NavigationRegion2D.navigation_polygon = new_navigation_mesh
[/gdscript]
[csharp]
var newNavigationMesh = new NavigationPolygon();
Vector2[] boundingOutline = [new Vector2(0, 0), new Vector2(0, 50), new Vector2(50, 50), new Vector2(50, 0)];
newNavigationMesh.AddOutline(boundingOutline);
NavigationServer2D.BakeFromSourceGeometryData(newNavigationMesh, new NavigationMeshSourceGeometryData2D());
GetNode<NavigationRegion2D>("NavigationRegion2D").NavigationPolygon = newNavigationMesh;
[/csharp]
[/codeblocks]
Adding vertices and polygon indices manually.
[codeblocks]
[gdscript]
var new_navigation_mesh = NavigationPolygon.new()
var new_vertices = PackedVector2Array([Vector2(0, 0), Vector2(0, 50), Vector2(50, 50), Vector2(50, 0)])
new_navigation_mesh.vertices = new_vertices
var new_polygon_indices = PackedInt32Array([0, 1, 2, 3])
new_navigation_mesh.add_polygon(new_polygon_indices)
$NavigationRegion2D.navigation_polygon = new_navigation_mesh
[/gdscript]
[csharp]
var newNavigationMesh = new NavigationPolygon();
Vector2[] newVertices = [new Vector2(0, 0), new Vector2(0, 50), new Vector2(50, 50), new Vector2(50, 0)];
newNavigationMesh.Vertices = newVertices;
int[] newPolygonIndices = [0, 1, 2, 3];
newNavigationMesh.AddPolygon(newPolygonIndices);
GetNode<NavigationRegion2D>("NavigationRegion2D").NavigationPolygon = newNavigationMesh;
[/csharp]
[/codeblocks]
*/
type Instance [1]gdclass.NavigationPolygon

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	set_vertices                    gdextension.MethodForClass `hash:"1509147220"`
	get_vertices                    gdextension.MethodForClass `hash:"2961356807"`
	add_polygon                     gdextension.MethodForClass `hash:"3614634198"`
	get_polygon_count               gdextension.MethodForClass `hash:"3905245786"`
	get_polygon                     gdextension.MethodForClass `hash:"3668444399"`
	clear_polygons                  gdextension.MethodForClass `hash:"3218959716"`
	get_navigation_mesh             gdextension.MethodForClass `hash:"330232164"`
	add_outline                     gdextension.MethodForClass `hash:"1509147220"`
	add_outline_at_index            gdextension.MethodForClass `hash:"1569738947"`
	get_outline_count               gdextension.MethodForClass `hash:"3905245786"`
	set_outline                     gdextension.MethodForClass `hash:"1201971903"`
	get_outline                     gdextension.MethodForClass `hash:"3946907486"`
	remove_outline                  gdextension.MethodForClass `hash:"1286410249"`
	clear_outlines                  gdextension.MethodForClass `hash:"3218959716"`
	make_polygons_from_outlines     gdextension.MethodForClass `hash:"3218959716"`
	set_cell_size                   gdextension.MethodForClass `hash:"373806689"`
	get_cell_size                   gdextension.MethodForClass `hash:"1740695150"`
	set_border_size                 gdextension.MethodForClass `hash:"373806689"`
	get_border_size                 gdextension.MethodForClass `hash:"1740695150"`
	set_sample_partition_type       gdextension.MethodForClass `hash:"2441478482"`
	get_sample_partition_type       gdextension.MethodForClass `hash:"3887422851"`
	set_parsed_geometry_type        gdextension.MethodForClass `hash:"2507971764"`
	get_parsed_geometry_type        gdextension.MethodForClass `hash:"1073219508"`
	set_parsed_collision_mask       gdextension.MethodForClass `hash:"1286410249"`
	get_parsed_collision_mask       gdextension.MethodForClass `hash:"3905245786"`
	set_parsed_collision_mask_value gdextension.MethodForClass `hash:"300928843"`
	get_parsed_collision_mask_value gdextension.MethodForClass `hash:"1116898809"`
	set_source_geometry_mode        gdextension.MethodForClass `hash:"4002316705"`
	get_source_geometry_mode        gdextension.MethodForClass `hash:"459686762"`
	set_source_geometry_group_name  gdextension.MethodForClass `hash:"3304788590"`
	get_source_geometry_group_name  gdextension.MethodForClass `hash:"2002593661"`
	set_agent_radius                gdextension.MethodForClass `hash:"373806689"`
	get_agent_radius                gdextension.MethodForClass `hash:"1740695150"`
	set_baking_rect                 gdextension.MethodForClass `hash:"2046264180"`
	get_baking_rect                 gdextension.MethodForClass `hash:"1639390495"`
	set_baking_rect_offset          gdextension.MethodForClass `hash:"743155724"`
	get_baking_rect_offset          gdextension.MethodForClass `hash:"3341600327"`
	clear                           gdextension.MethodForClass `hash:"3218959716"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("NavigationPolygon")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		gdextension.Free(gdextension.TypeStringName, &sname)
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsNavigationPolygon() Instance
}

/*
Adds a polygon using the indices of the vertices you get when calling [method get_vertices].
*/
func (self Instance) AddPolygon(polygon []int32) { //gd:NavigationPolygon.add_polygon
	Advanced(self).AddPolygon(Packed.New(polygon...))
}

/*
Returns the count of all polygons.
*/
func (self Instance) GetPolygonCount() int { //gd:NavigationPolygon.get_polygon_count
	return int(int(Advanced(self).GetPolygonCount()))
}

/*
Returns a [PackedInt32Array] containing the indices of the vertices of a created polygon.
*/
func (self Instance) GetPolygon(idx int) []int32 { //gd:NavigationPolygon.get_polygon
	return []int32(slices.Collect(Advanced(self).GetPolygon(int64(idx)).Values()))
}

/*
Clears the array of polygons, but it doesn't clear the array of outlines and vertices.
*/
func (self Instance) ClearPolygons() { //gd:NavigationPolygon.clear_polygons
	Advanced(self).ClearPolygons()
}

/*
Returns the [NavigationMesh] resulting from this navigation polygon. This navigation mesh can be used to update the navigation mesh of a region with the [method NavigationServer3D.region_set_navigation_mesh] API directly (as 2D uses the 3D server behind the scene).
*/
func (self Instance) GetNavigationMesh() NavigationMesh.Instance { //gd:NavigationPolygon.get_navigation_mesh
	return NavigationMesh.Instance(Advanced(self).GetNavigationMesh())
}

/*
Appends a [PackedVector2Array] that contains the vertices of an outline to the internal array that contains all the outlines.
*/
func (self Instance) AddOutline(outline []Vector2.XY) { //gd:NavigationPolygon.add_outline
	Advanced(self).AddOutline(Packed.New(outline...))
}

/*
Adds a [PackedVector2Array] that contains the vertices of an outline to the internal array that contains all the outlines at a fixed position.
*/
func (self Instance) AddOutlineAtIndex(outline []Vector2.XY, index int) { //gd:NavigationPolygon.add_outline_at_index
	Advanced(self).AddOutlineAtIndex(Packed.New(outline...), int64(index))
}

/*
Returns the number of outlines that were created in the editor or by script.
*/
func (self Instance) GetOutlineCount() int { //gd:NavigationPolygon.get_outline_count
	return int(int(Advanced(self).GetOutlineCount()))
}

/*
Changes an outline created in the editor or by script. You have to call [method make_polygons_from_outlines] for the polygons to update.
*/
func (self Instance) SetOutline(idx int, outline []Vector2.XY) { //gd:NavigationPolygon.set_outline
	Advanced(self).SetOutline(int64(idx), Packed.New(outline...))
}

/*
Returns a [PackedVector2Array] containing the vertices of an outline that was created in the editor or by script.
*/
func (self Instance) GetOutline(idx int) []Vector2.XY { //gd:NavigationPolygon.get_outline
	return []Vector2.XY(slices.Collect(Advanced(self).GetOutline(int64(idx)).Values()))
}

/*
Removes an outline created in the editor or by script. You have to call [method make_polygons_from_outlines] for the polygons to update.
*/
func (self Instance) RemoveOutline(idx int) { //gd:NavigationPolygon.remove_outline
	Advanced(self).RemoveOutline(int64(idx))
}

/*
Clears the array of the outlines, but it doesn't clear the vertices and the polygons that were created by them.
*/
func (self Instance) ClearOutlines() { //gd:NavigationPolygon.clear_outlines
	Advanced(self).ClearOutlines()
}

/*
Creates polygons from the outlines added in the editor or by script.
*/
func (self Instance) MakePolygonsFromOutlines() { //gd:NavigationPolygon.make_polygons_from_outlines
	Advanced(self).MakePolygonsFromOutlines()
}

/*
Based on [param value], enables or disables the specified layer in the [member parsed_collision_mask], given a [param layer_number] between 1 and 32.
*/
func (self Instance) SetParsedCollisionMaskValue(layer_number int, value bool) { //gd:NavigationPolygon.set_parsed_collision_mask_value
	Advanced(self).SetParsedCollisionMaskValue(int64(layer_number), value)
}

/*
Returns whether or not the specified layer of the [member parsed_collision_mask] is enabled, given a [param layer_number] between 1 and 32.
*/
func (self Instance) GetParsedCollisionMaskValue(layer_number int) bool { //gd:NavigationPolygon.get_parsed_collision_mask_value
	return bool(Advanced(self).GetParsedCollisionMaskValue(int64(layer_number)))
}

/*
Clears the internal arrays for vertices and polygon indices.
*/
func (self Instance) Clear() { //gd:NavigationPolygon.clear
	Advanced(self).Clear()
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.NavigationPolygon

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.NavigationPolygon)(unsafe.Pointer(&obj))
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.NavigationPolygon)(unsafe.Pointer(&obj))
		return true
	}
	return false
}

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {

	if !gd.Linked {
		var placeholder Instance
		*(*gd.Object)(unsafe.Pointer(&placeholder)) = pointers.Add[gd.Object]([3]uint64{})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(*(*gd.Object)(unsafe.Pointer(&placeholder)), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	object := [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})}
	casted := Instance{*(*gdclass.NavigationPolygon)(unsafe.Pointer(&object))}
	casted.AsRefCounted()[0].InitRef()
	object[0].Notification(0, false)
	return casted
}

func (self Instance) Vertices() []Vector2.XY {
	return []Vector2.XY(slices.Collect(class(self).GetVertices().Values()))
}

func (self Instance) SetVertices(value []Vector2.XY) {
	class(self).SetVertices(Packed.New(value...))
}

func (self Instance) SamplePartitionType() SamplePartitionType {
	return SamplePartitionType(class(self).GetSamplePartitionType())
}

func (self Instance) SetSamplePartitionType(value SamplePartitionType) {
	class(self).SetSamplePartitionType(value)
}

func (self Instance) ParsedGeometryType() ParsedGeometryType {
	return ParsedGeometryType(class(self).GetParsedGeometryType())
}

func (self Instance) SetParsedGeometryType(value ParsedGeometryType) {
	class(self).SetParsedGeometryType(value)
}

func (self Instance) ParsedCollisionMask() int {
	return int(int(class(self).GetParsedCollisionMask()))
}

func (self Instance) SetParsedCollisionMask(value int) {
	class(self).SetParsedCollisionMask(int64(value))
}

func (self Instance) SourceGeometryMode() SourceGeometryMode {
	return SourceGeometryMode(class(self).GetSourceGeometryMode())
}

func (self Instance) SetSourceGeometryMode(value SourceGeometryMode) {
	class(self).SetSourceGeometryMode(value)
}

func (self Instance) SourceGeometryGroupName() string {
	return string(class(self).GetSourceGeometryGroupName().String())
}

func (self Instance) SetSourceGeometryGroupName(value string) {
	class(self).SetSourceGeometryGroupName(String.Name(String.New(value)))
}

func (self Instance) CellSize() Float.X {
	return Float.X(Float.X(class(self).GetCellSize()))
}

func (self Instance) SetCellSize(value Float.X) {
	class(self).SetCellSize(float64(value))
}

func (self Instance) BorderSize() Float.X {
	return Float.X(Float.X(class(self).GetBorderSize()))
}

func (self Instance) SetBorderSize(value Float.X) {
	class(self).SetBorderSize(float64(value))
}

func (self Instance) AgentRadius() Float.X {
	return Float.X(Float.X(class(self).GetAgentRadius()))
}

func (self Instance) SetAgentRadius(value Float.X) {
	class(self).SetAgentRadius(float64(value))
}

func (self Instance) BakingRect() Rect2.PositionSize {
	return Rect2.PositionSize(class(self).GetBakingRect())
}

func (self Instance) SetBakingRect(value Rect2.PositionSize) {
	class(self).SetBakingRect(Rect2.PositionSize(value))
}

func (self Instance) BakingRectOffset() Vector2.XY {
	return Vector2.XY(class(self).GetBakingRectOffset())
}

func (self Instance) SetBakingRectOffset(value Vector2.XY) {
	class(self).SetBakingRectOffset(Vector2.XY(value))
}

/*
Sets the vertices that can be then indexed to create polygons with the [method add_polygon] method.
*/
//go:nosplit
func (self class) SetVertices(vertices Packed.Array[Vector2.XY]) { //gd:NavigationPolygon.set_vertices
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_vertices, 0|(gdextension.SizePackedArray<<4), unsafe.Pointer(&struct {
		vertices gdextension.PackedArray[Vector2.XY]
	}{pointers.Get(gd.InternalPacked[gd.PackedVector2Array, Vector2.XY](vertices))}))
}

/*
Returns a [PackedVector2Array] containing all the vertices being used to create the polygons.
*/
//go:nosplit
func (self class) GetVertices() Packed.Array[Vector2.XY] { //gd:NavigationPolygon.get_vertices
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.get_vertices, gdextension.SizePackedArray, unsafe.Pointer(&struct{}{}))
	var ret = Packed.Array[Vector2.XY](Array.Through(gd.PackedProxy[gd.PackedVector2Array, Vector2.XY]{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

/*
Adds a polygon using the indices of the vertices you get when calling [method get_vertices].
*/
//go:nosplit
func (self class) AddPolygon(polygon Packed.Array[int32]) { //gd:NavigationPolygon.add_polygon
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_polygon, 0|(gdextension.SizePackedArray<<4), unsafe.Pointer(&struct {
		polygon gdextension.PackedArray[int32]
	}{pointers.Get(gd.InternalPacked[gd.PackedInt32Array, int32](polygon))}))
}

/*
Returns the count of all polygons.
*/
//go:nosplit
func (self class) GetPolygonCount() int64 { //gd:NavigationPolygon.get_polygon_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_polygon_count, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns a [PackedInt32Array] containing the indices of the vertices of a created polygon.
*/
//go:nosplit
func (self class) GetPolygon(idx int64) Packed.Array[int32] { //gd:NavigationPolygon.get_polygon
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.get_polygon, gdextension.SizePackedArray|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ idx int64 }{idx}))
	var ret = Packed.Array[int32](Array.Through(gd.PackedProxy[gd.PackedInt32Array, int32]{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

/*
Clears the array of polygons, but it doesn't clear the array of outlines and vertices.
*/
//go:nosplit
func (self class) ClearPolygons() { //gd:NavigationPolygon.clear_polygons
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.clear_polygons, 0, unsafe.Pointer(&struct{}{}))
}

/*
Returns the [NavigationMesh] resulting from this navigation polygon. This navigation mesh can be used to update the navigation mesh of a region with the [method NavigationServer3D.region_set_navigation_mesh] API directly (as 2D uses the 3D server behind the scene).
*/
//go:nosplit
func (self class) GetNavigationMesh() [1]gdclass.NavigationMesh { //gd:NavigationPolygon.get_navigation_mesh
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_navigation_mesh, gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.NavigationMesh{gd.PointerWithOwnershipTransferredToGo[gdclass.NavigationMesh](r_ret)}
	return ret
}

/*
Appends a [PackedVector2Array] that contains the vertices of an outline to the internal array that contains all the outlines.
*/
//go:nosplit
func (self class) AddOutline(outline Packed.Array[Vector2.XY]) { //gd:NavigationPolygon.add_outline
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_outline, 0|(gdextension.SizePackedArray<<4), unsafe.Pointer(&struct {
		outline gdextension.PackedArray[Vector2.XY]
	}{pointers.Get(gd.InternalPacked[gd.PackedVector2Array, Vector2.XY](outline))}))
}

/*
Adds a [PackedVector2Array] that contains the vertices of an outline to the internal array that contains all the outlines at a fixed position.
*/
//go:nosplit
func (self class) AddOutlineAtIndex(outline Packed.Array[Vector2.XY], index int64) { //gd:NavigationPolygon.add_outline_at_index
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_outline_at_index, 0|(gdextension.SizePackedArray<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		outline gdextension.PackedArray[Vector2.XY]
		index   int64
	}{pointers.Get(gd.InternalPacked[gd.PackedVector2Array, Vector2.XY](outline)), index}))
}

/*
Returns the number of outlines that were created in the editor or by script.
*/
//go:nosplit
func (self class) GetOutlineCount() int64 { //gd:NavigationPolygon.get_outline_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_outline_count, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Changes an outline created in the editor or by script. You have to call [method make_polygons_from_outlines] for the polygons to update.
*/
//go:nosplit
func (self class) SetOutline(idx int64, outline Packed.Array[Vector2.XY]) { //gd:NavigationPolygon.set_outline
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_outline, 0|(gdextension.SizeInt<<4)|(gdextension.SizePackedArray<<8), unsafe.Pointer(&struct {
		idx     int64
		outline gdextension.PackedArray[Vector2.XY]
	}{idx, pointers.Get(gd.InternalPacked[gd.PackedVector2Array, Vector2.XY](outline))}))
}

/*
Returns a [PackedVector2Array] containing the vertices of an outline that was created in the editor or by script.
*/
//go:nosplit
func (self class) GetOutline(idx int64) Packed.Array[Vector2.XY] { //gd:NavigationPolygon.get_outline
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.get_outline, gdextension.SizePackedArray|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ idx int64 }{idx}))
	var ret = Packed.Array[Vector2.XY](Array.Through(gd.PackedProxy[gd.PackedVector2Array, Vector2.XY]{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

/*
Removes an outline created in the editor or by script. You have to call [method make_polygons_from_outlines] for the polygons to update.
*/
//go:nosplit
func (self class) RemoveOutline(idx int64) { //gd:NavigationPolygon.remove_outline
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.remove_outline, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ idx int64 }{idx}))
}

/*
Clears the array of the outlines, but it doesn't clear the vertices and the polygons that were created by them.
*/
//go:nosplit
func (self class) ClearOutlines() { //gd:NavigationPolygon.clear_outlines
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.clear_outlines, 0, unsafe.Pointer(&struct{}{}))
}

/*
Creates polygons from the outlines added in the editor or by script.
*/
//go:nosplit
func (self class) MakePolygonsFromOutlines() { //gd:NavigationPolygon.make_polygons_from_outlines
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.make_polygons_from_outlines, 0, unsafe.Pointer(&struct{}{}))
}

//go:nosplit
func (self class) SetCellSize(cell_size float64) { //gd:NavigationPolygon.set_cell_size
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_cell_size, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ cell_size float64 }{cell_size}))
}

//go:nosplit
func (self class) GetCellSize() float64 { //gd:NavigationPolygon.get_cell_size
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_cell_size, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetBorderSize(border_size float64) { //gd:NavigationPolygon.set_border_size
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_border_size, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ border_size float64 }{border_size}))
}

//go:nosplit
func (self class) GetBorderSize() float64 { //gd:NavigationPolygon.get_border_size
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_border_size, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetSamplePartitionType(sample_partition_type SamplePartitionType) { //gd:NavigationPolygon.set_sample_partition_type
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_sample_partition_type, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ sample_partition_type SamplePartitionType }{sample_partition_type}))
}

//go:nosplit
func (self class) GetSamplePartitionType() SamplePartitionType { //gd:NavigationPolygon.get_sample_partition_type
	var r_ret = gdextension.Call[SamplePartitionType](gd.ObjectChecked(self.AsObject()), methods.get_sample_partition_type, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetParsedGeometryType(geometry_type ParsedGeometryType) { //gd:NavigationPolygon.set_parsed_geometry_type
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_parsed_geometry_type, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ geometry_type ParsedGeometryType }{geometry_type}))
}

//go:nosplit
func (self class) GetParsedGeometryType() ParsedGeometryType { //gd:NavigationPolygon.get_parsed_geometry_type
	var r_ret = gdextension.Call[ParsedGeometryType](gd.ObjectChecked(self.AsObject()), methods.get_parsed_geometry_type, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetParsedCollisionMask(mask int64) { //gd:NavigationPolygon.set_parsed_collision_mask
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_parsed_collision_mask, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ mask int64 }{mask}))
}

//go:nosplit
func (self class) GetParsedCollisionMask() int64 { //gd:NavigationPolygon.get_parsed_collision_mask
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_parsed_collision_mask, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Based on [param value], enables or disables the specified layer in the [member parsed_collision_mask], given a [param layer_number] between 1 and 32.
*/
//go:nosplit
func (self class) SetParsedCollisionMaskValue(layer_number int64, value bool) { //gd:NavigationPolygon.set_parsed_collision_mask_value
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_parsed_collision_mask_value, 0|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		layer_number int64
		value        bool
	}{layer_number, value}))
}

/*
Returns whether or not the specified layer of the [member parsed_collision_mask] is enabled, given a [param layer_number] between 1 and 32.
*/
//go:nosplit
func (self class) GetParsedCollisionMaskValue(layer_number int64) bool { //gd:NavigationPolygon.get_parsed_collision_mask_value
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.get_parsed_collision_mask_value, gdextension.SizeBool|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ layer_number int64 }{layer_number}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetSourceGeometryMode(geometry_mode SourceGeometryMode) { //gd:NavigationPolygon.set_source_geometry_mode
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_source_geometry_mode, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ geometry_mode SourceGeometryMode }{geometry_mode}))
}

//go:nosplit
func (self class) GetSourceGeometryMode() SourceGeometryMode { //gd:NavigationPolygon.get_source_geometry_mode
	var r_ret = gdextension.Call[SourceGeometryMode](gd.ObjectChecked(self.AsObject()), methods.get_source_geometry_mode, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetSourceGeometryGroupName(group_name String.Name) { //gd:NavigationPolygon.set_source_geometry_group_name
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_source_geometry_group_name, 0|(gdextension.SizeStringName<<4), unsafe.Pointer(&struct{ group_name gdextension.StringName }{pointers.Get(gd.InternalStringName(group_name))}))
}

//go:nosplit
func (self class) GetSourceGeometryGroupName() String.Name { //gd:NavigationPolygon.get_source_geometry_group_name
	var r_ret = gdextension.Call[gdextension.StringName](gd.ObjectChecked(self.AsObject()), methods.get_source_geometry_group_name, gdextension.SizeStringName, unsafe.Pointer(&struct{}{}))
	var ret = String.Name(String.Via(gd.StringNameProxy{}, pointers.Pack(pointers.New[gd.StringName](r_ret))))
	return ret
}

//go:nosplit
func (self class) SetAgentRadius(agent_radius float64) { //gd:NavigationPolygon.set_agent_radius
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_agent_radius, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ agent_radius float64 }{agent_radius}))
}

//go:nosplit
func (self class) GetAgentRadius() float64 { //gd:NavigationPolygon.get_agent_radius
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_agent_radius, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetBakingRect(rect Rect2.PositionSize) { //gd:NavigationPolygon.set_baking_rect
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_baking_rect, 0|(gdextension.SizeRect2<<4), unsafe.Pointer(&struct{ rect Rect2.PositionSize }{rect}))
}

//go:nosplit
func (self class) GetBakingRect() Rect2.PositionSize { //gd:NavigationPolygon.get_baking_rect
	var r_ret = gdextension.Call[Rect2.PositionSize](gd.ObjectChecked(self.AsObject()), methods.get_baking_rect, gdextension.SizeRect2, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetBakingRectOffset(rect_offset Vector2.XY) { //gd:NavigationPolygon.set_baking_rect_offset
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_baking_rect_offset, 0|(gdextension.SizeVector2<<4), unsafe.Pointer(&struct{ rect_offset Vector2.XY }{rect_offset}))
}

//go:nosplit
func (self class) GetBakingRectOffset() Vector2.XY { //gd:NavigationPolygon.get_baking_rect_offset
	var r_ret = gdextension.Call[Vector2.XY](gd.ObjectChecked(self.AsObject()), methods.get_baking_rect_offset, gdextension.SizeVector2, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Clears the internal arrays for vertices and polygon indices.
*/
//go:nosplit
func (self class) Clear() { //gd:NavigationPolygon.clear
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.clear, 0, unsafe.Pointer(&struct{}{}))
}
func (self class) AsNavigationPolygon() Advanced         { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsNavigationPolygon() Instance      { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsNavigationPolygon() Instance { return self.Super().AsNavigationPolygon() }
func (self class) AsResource() Resource.Advanced {
	return *((*Resource.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsResource() Resource.Instance { return self.Super().AsResource() }
func (self Instance) AsResource() Resource.Instance {
	return *((*Resource.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsRefCounted() [1]gd.RefCounted { return self.Super().AsRefCounted() }
func (self Instance) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Resource.Advanced(self.AsResource()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Resource.Instance(self.AsResource()), name)
	}
}
func init() {
	gdclass.Register("NavigationPolygon", func(ptr gd.Object) any { return *(*Instance)(unsafe.Pointer(&ptr)) })
}

type SamplePartitionType int //gd:NavigationPolygon.SamplePartitionType

const (
	/*Convex partitioning that yields navigation mesh with convex polygons.*/
	SamplePartitionConvexPartition SamplePartitionType = 0
	/*Triangulation partitioning that yields navigation mesh with triangle polygons.*/
	SamplePartitionTriangulate SamplePartitionType = 1
	/*Represents the size of the [enum SamplePartitionType] enum.*/
	SamplePartitionMax SamplePartitionType = 2
)

type ParsedGeometryType int //gd:NavigationPolygon.ParsedGeometryType

const (
	/*Parses mesh instances as obstruction geometry. This includes [Polygon2D], [MeshInstance2D], [MultiMeshInstance2D], and [TileMap] nodes.
	  Meshes are only parsed when they use a 2D vertices surface format.*/
	ParsedGeometryMeshInstances ParsedGeometryType = 0
	/*Parses [StaticBody2D] and [TileMap] colliders as obstruction geometry. The collider should be in any of the layers specified by [member parsed_collision_mask].*/
	ParsedGeometryStaticColliders ParsedGeometryType = 1
	/*Both [constant PARSED_GEOMETRY_MESH_INSTANCES] and [constant PARSED_GEOMETRY_STATIC_COLLIDERS].*/
	ParsedGeometryBoth ParsedGeometryType = 2
	/*Represents the size of the [enum ParsedGeometryType] enum.*/
	ParsedGeometryMax ParsedGeometryType = 3
)

type SourceGeometryMode int //gd:NavigationPolygon.SourceGeometryMode

const (
	/*Scans the child nodes of the root node recursively for geometry.*/
	SourceGeometryRootNodeChildren SourceGeometryMode = 0
	/*Scans nodes in a group and their child nodes recursively for geometry. The group is specified by [member source_geometry_group_name].*/
	SourceGeometryGroupsWithChildren SourceGeometryMode = 1
	/*Uses nodes in a group for geometry. The group is specified by [member source_geometry_group_name].*/
	SourceGeometryGroupsExplicit SourceGeometryMode = 2
	/*Represents the size of the [enum SourceGeometryMode] enum.*/
	SourceGeometryMax SourceGeometryMode = 3
)
