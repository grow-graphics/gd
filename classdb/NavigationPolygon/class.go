// Code generated by the generate package DO NOT EDIT

// Package NavigationPolygon provides methods for working with NavigationPolygon object instances.
package NavigationPolygon

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/NavigationMesh"
import "graphics.gd/classdb/Resource"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/Rect2"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"
import "graphics.gd/variant/Vector2"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
A navigation mesh can be created either by baking it with the help of the [NavigationServer2D], or by adding vertices and convex polygon indices arrays manually.
To bake a navigation mesh at least one outline needs to be added that defines the outer bounds of the baked area.
[codeblocks]
[gdscript]
var new_navigation_mesh = NavigationPolygon.new()
var bounding_outline = PackedVector2Array([Vector2(0, 0), Vector2(0, 50), Vector2(50, 50), Vector2(50, 0)])
new_navigation_mesh.add_outline(bounding_outline)
NavigationServer2D.bake_from_source_geometry_data(new_navigation_mesh, NavigationMeshSourceGeometryData2D.new());
$NavigationRegion2D.navigation_polygon = new_navigation_mesh
[/gdscript]
[csharp]
var newNavigationMesh = new NavigationPolygon();
Vector2[] boundingOutline = [new Vector2(0, 0), new Vector2(0, 50), new Vector2(50, 50), new Vector2(50, 0)];
newNavigationMesh.AddOutline(boundingOutline);
NavigationServer2D.BakeFromSourceGeometryData(newNavigationMesh, new NavigationMeshSourceGeometryData2D());
GetNode<NavigationRegion2D>("NavigationRegion2D").NavigationPolygon = newNavigationMesh;
[/csharp]
[/codeblocks]
Adding vertices and polygon indices manually.
[codeblocks]
[gdscript]
var new_navigation_mesh = NavigationPolygon.new()
var new_vertices = PackedVector2Array([Vector2(0, 0), Vector2(0, 50), Vector2(50, 50), Vector2(50, 0)])
new_navigation_mesh.vertices = new_vertices
var new_polygon_indices = PackedInt32Array([0, 1, 2, 3])
new_navigation_mesh.add_polygon(new_polygon_indices)
$NavigationRegion2D.navigation_polygon = new_navigation_mesh
[/gdscript]
[csharp]
var newNavigationMesh = new NavigationPolygon();
Vector2[] newVertices = [new Vector2(0, 0), new Vector2(0, 50), new Vector2(50, 50), new Vector2(50, 0)];
newNavigationMesh.Vertices = newVertices;
int[] newPolygonIndices = [0, 1, 2, 3];
newNavigationMesh.AddPolygon(newPolygonIndices);
GetNode<NavigationRegion2D>("NavigationRegion2D").NavigationPolygon = newNavigationMesh;
[/csharp]
[/codeblocks]
*/
type Instance [1]gdclass.NavigationPolygon

func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsNavigationPolygon() Instance
}

/*
Adds a polygon using the indices of the vertices you get when calling [method get_vertices].
*/
func (self Instance) AddPolygon(polygon []int32) { //gd:NavigationPolygon.add_polygon
	Advanced(self).AddPolygon(Packed.New(polygon...))
}

/*
Returns the count of all polygons.
*/
func (self Instance) GetPolygonCount() int { //gd:NavigationPolygon.get_polygon_count
	return int(int(Advanced(self).GetPolygonCount()))
}

/*
Returns a [PackedInt32Array] containing the indices of the vertices of a created polygon.
*/
func (self Instance) GetPolygon(idx int) []int32 { //gd:NavigationPolygon.get_polygon
	return []int32(slices.Collect(Advanced(self).GetPolygon(int64(idx)).Values()))
}

/*
Clears the array of polygons, but it doesn't clear the array of outlines and vertices.
*/
func (self Instance) ClearPolygons() { //gd:NavigationPolygon.clear_polygons
	Advanced(self).ClearPolygons()
}

/*
Returns the [NavigationMesh] resulting from this navigation polygon. This navigation mesh can be used to update the navigation mesh of a region with the [method NavigationServer3D.region_set_navigation_mesh] API directly (as 2D uses the 3D server behind the scene).
*/
func (self Instance) GetNavigationMesh() NavigationMesh.Instance { //gd:NavigationPolygon.get_navigation_mesh
	return NavigationMesh.Instance(Advanced(self).GetNavigationMesh())
}

/*
Appends a [PackedVector2Array] that contains the vertices of an outline to the internal array that contains all the outlines.
*/
func (self Instance) AddOutline(outline []Vector2.XY) { //gd:NavigationPolygon.add_outline
	Advanced(self).AddOutline(Packed.New(outline...))
}

/*
Adds a [PackedVector2Array] that contains the vertices of an outline to the internal array that contains all the outlines at a fixed position.
*/
func (self Instance) AddOutlineAtIndex(outline []Vector2.XY, index int) { //gd:NavigationPolygon.add_outline_at_index
	Advanced(self).AddOutlineAtIndex(Packed.New(outline...), int64(index))
}

/*
Returns the number of outlines that were created in the editor or by script.
*/
func (self Instance) GetOutlineCount() int { //gd:NavigationPolygon.get_outline_count
	return int(int(Advanced(self).GetOutlineCount()))
}

/*
Changes an outline created in the editor or by script. You have to call [method make_polygons_from_outlines] for the polygons to update.
*/
func (self Instance) SetOutline(idx int, outline []Vector2.XY) { //gd:NavigationPolygon.set_outline
	Advanced(self).SetOutline(int64(idx), Packed.New(outline...))
}

/*
Returns a [PackedVector2Array] containing the vertices of an outline that was created in the editor or by script.
*/
func (self Instance) GetOutline(idx int) []Vector2.XY { //gd:NavigationPolygon.get_outline
	return []Vector2.XY(slices.Collect(Advanced(self).GetOutline(int64(idx)).Values()))
}

/*
Removes an outline created in the editor or by script. You have to call [method make_polygons_from_outlines] for the polygons to update.
*/
func (self Instance) RemoveOutline(idx int) { //gd:NavigationPolygon.remove_outline
	Advanced(self).RemoveOutline(int64(idx))
}

/*
Clears the array of the outlines, but it doesn't clear the vertices and the polygons that were created by them.
*/
func (self Instance) ClearOutlines() { //gd:NavigationPolygon.clear_outlines
	Advanced(self).ClearOutlines()
}

/*
Creates polygons from the outlines added in the editor or by script.
*/
func (self Instance) MakePolygonsFromOutlines() { //gd:NavigationPolygon.make_polygons_from_outlines
	Advanced(self).MakePolygonsFromOutlines()
}

/*
Based on [param value], enables or disables the specified layer in the [member parsed_collision_mask], given a [param layer_number] between 1 and 32.
*/
func (self Instance) SetParsedCollisionMaskValue(layer_number int, value bool) { //gd:NavigationPolygon.set_parsed_collision_mask_value
	Advanced(self).SetParsedCollisionMaskValue(int64(layer_number), value)
}

/*
Returns whether or not the specified layer of the [member parsed_collision_mask] is enabled, given a [param layer_number] between 1 and 32.
*/
func (self Instance) GetParsedCollisionMaskValue(layer_number int) bool { //gd:NavigationPolygon.get_parsed_collision_mask_value
	return bool(Advanced(self).GetParsedCollisionMaskValue(int64(layer_number)))
}

/*
Clears the internal arrays for vertices and polygon indices.
*/
func (self Instance) Clear() { //gd:NavigationPolygon.clear
	Advanced(self).Clear()
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.NavigationPolygon

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {
	object := gd.Global.ClassDB.ConstructObject(gd.NewStringName("NavigationPolygon"))
	casted := Instance{*(*gdclass.NavigationPolygon)(unsafe.Pointer(&object))}
	casted.AsRefCounted()[0].Reference()
	return casted
}

func (self Instance) Vertices() []Vector2.XY {
	return []Vector2.XY(slices.Collect(class(self).GetVertices().Values()))
}

func (self Instance) SetVertices(value []Vector2.XY) {
	class(self).SetVertices(Packed.New(value...))
}

func (self Instance) SamplePartitionType() SamplePartitionType {
	return SamplePartitionType(class(self).GetSamplePartitionType())
}

func (self Instance) SetSamplePartitionType(value SamplePartitionType) {
	class(self).SetSamplePartitionType(value)
}

func (self Instance) ParsedGeometryType() ParsedGeometryType {
	return ParsedGeometryType(class(self).GetParsedGeometryType())
}

func (self Instance) SetParsedGeometryType(value ParsedGeometryType) {
	class(self).SetParsedGeometryType(value)
}

func (self Instance) ParsedCollisionMask() int {
	return int(int(class(self).GetParsedCollisionMask()))
}

func (self Instance) SetParsedCollisionMask(value int) {
	class(self).SetParsedCollisionMask(int64(value))
}

func (self Instance) SourceGeometryMode() SourceGeometryMode {
	return SourceGeometryMode(class(self).GetSourceGeometryMode())
}

func (self Instance) SetSourceGeometryMode(value SourceGeometryMode) {
	class(self).SetSourceGeometryMode(value)
}

func (self Instance) SourceGeometryGroupName() string {
	return string(class(self).GetSourceGeometryGroupName().String())
}

func (self Instance) SetSourceGeometryGroupName(value string) {
	class(self).SetSourceGeometryGroupName(String.Name(String.New(value)))
}

func (self Instance) CellSize() Float.X {
	return Float.X(Float.X(class(self).GetCellSize()))
}

func (self Instance) SetCellSize(value Float.X) {
	class(self).SetCellSize(float64(value))
}

func (self Instance) BorderSize() Float.X {
	return Float.X(Float.X(class(self).GetBorderSize()))
}

func (self Instance) SetBorderSize(value Float.X) {
	class(self).SetBorderSize(float64(value))
}

func (self Instance) AgentRadius() Float.X {
	return Float.X(Float.X(class(self).GetAgentRadius()))
}

func (self Instance) SetAgentRadius(value Float.X) {
	class(self).SetAgentRadius(float64(value))
}

func (self Instance) BakingRect() Rect2.PositionSize {
	return Rect2.PositionSize(class(self).GetBakingRect())
}

func (self Instance) SetBakingRect(value Rect2.PositionSize) {
	class(self).SetBakingRect(Rect2.PositionSize(value))
}

func (self Instance) BakingRectOffset() Vector2.XY {
	return Vector2.XY(class(self).GetBakingRectOffset())
}

func (self Instance) SetBakingRectOffset(value Vector2.XY) {
	class(self).SetBakingRectOffset(Vector2.XY(value))
}

/*
Sets the vertices that can be then indexed to create polygons with the [method add_polygon] method.
*/
//go:nosplit
func (self class) SetVertices(vertices Packed.Array[Vector2.XY]) { //gd:NavigationPolygon.set_vertices
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalPacked[gd.PackedVector2Array, Vector2.XY](vertices)))
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.NavigationPolygon.Bind_set_vertices, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Returns a [PackedVector2Array] containing all the vertices being used to create the polygons.
*/
//go:nosplit
func (self class) GetVertices() Packed.Array[Vector2.XY] { //gd:NavigationPolygon.get_vertices
	var frame = callframe.New()
	var r_ret = callframe.Ret[gd.PackedPointers](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.NavigationPolygon.Bind_get_vertices, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Packed.Array[Vector2.XY](Array.Through(gd.PackedProxy[gd.PackedVector2Array, Vector2.XY]{}, pointers.Pack(pointers.New[gd.PackedStringArray](r_ret.Get()))))
	frame.Free()
	return ret
}

/*
Adds a polygon using the indices of the vertices you get when calling [method get_vertices].
*/
//go:nosplit
func (self class) AddPolygon(polygon Packed.Array[int32]) { //gd:NavigationPolygon.add_polygon
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalPacked[gd.PackedInt32Array, int32](polygon)))
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.NavigationPolygon.Bind_add_polygon, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Returns the count of all polygons.
*/
//go:nosplit
func (self class) GetPolygonCount() int64 { //gd:NavigationPolygon.get_polygon_count
	var frame = callframe.New()
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.NavigationPolygon.Bind_get_polygon_count, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns a [PackedInt32Array] containing the indices of the vertices of a created polygon.
*/
//go:nosplit
func (self class) GetPolygon(idx int64) Packed.Array[int32] { //gd:NavigationPolygon.get_polygon
	var frame = callframe.New()
	callframe.Arg(frame, idx)
	var r_ret = callframe.Ret[gd.PackedPointers](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.NavigationPolygon.Bind_get_polygon, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Packed.Array[int32](Array.Through(gd.PackedProxy[gd.PackedInt32Array, int32]{}, pointers.Pack(pointers.New[gd.PackedStringArray](r_ret.Get()))))
	frame.Free()
	return ret
}

/*
Clears the array of polygons, but it doesn't clear the array of outlines and vertices.
*/
//go:nosplit
func (self class) ClearPolygons() { //gd:NavigationPolygon.clear_polygons
	var frame = callframe.New()
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.NavigationPolygon.Bind_clear_polygons, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Returns the [NavigationMesh] resulting from this navigation polygon. This navigation mesh can be used to update the navigation mesh of a region with the [method NavigationServer3D.region_set_navigation_mesh] API directly (as 2D uses the 3D server behind the scene).
*/
//go:nosplit
func (self class) GetNavigationMesh() [1]gdclass.NavigationMesh { //gd:NavigationPolygon.get_navigation_mesh
	var frame = callframe.New()
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.NavigationPolygon.Bind_get_navigation_mesh, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.NavigationMesh{gd.PointerWithOwnershipTransferredToGo[gdclass.NavigationMesh](r_ret.Get())}
	frame.Free()
	return ret
}

/*
Appends a [PackedVector2Array] that contains the vertices of an outline to the internal array that contains all the outlines.
*/
//go:nosplit
func (self class) AddOutline(outline Packed.Array[Vector2.XY]) { //gd:NavigationPolygon.add_outline
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalPacked[gd.PackedVector2Array, Vector2.XY](outline)))
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.NavigationPolygon.Bind_add_outline, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Adds a [PackedVector2Array] that contains the vertices of an outline to the internal array that contains all the outlines at a fixed position.
*/
//go:nosplit
func (self class) AddOutlineAtIndex(outline Packed.Array[Vector2.XY], index int64) { //gd:NavigationPolygon.add_outline_at_index
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalPacked[gd.PackedVector2Array, Vector2.XY](outline)))
	callframe.Arg(frame, index)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.NavigationPolygon.Bind_add_outline_at_index, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Returns the number of outlines that were created in the editor or by script.
*/
//go:nosplit
func (self class) GetOutlineCount() int64 { //gd:NavigationPolygon.get_outline_count
	var frame = callframe.New()
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.NavigationPolygon.Bind_get_outline_count, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Changes an outline created in the editor or by script. You have to call [method make_polygons_from_outlines] for the polygons to update.
*/
//go:nosplit
func (self class) SetOutline(idx int64, outline Packed.Array[Vector2.XY]) { //gd:NavigationPolygon.set_outline
	var frame = callframe.New()
	callframe.Arg(frame, idx)
	callframe.Arg(frame, pointers.Get(gd.InternalPacked[gd.PackedVector2Array, Vector2.XY](outline)))
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.NavigationPolygon.Bind_set_outline, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Returns a [PackedVector2Array] containing the vertices of an outline that was created in the editor or by script.
*/
//go:nosplit
func (self class) GetOutline(idx int64) Packed.Array[Vector2.XY] { //gd:NavigationPolygon.get_outline
	var frame = callframe.New()
	callframe.Arg(frame, idx)
	var r_ret = callframe.Ret[gd.PackedPointers](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.NavigationPolygon.Bind_get_outline, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Packed.Array[Vector2.XY](Array.Through(gd.PackedProxy[gd.PackedVector2Array, Vector2.XY]{}, pointers.Pack(pointers.New[gd.PackedStringArray](r_ret.Get()))))
	frame.Free()
	return ret
}

/*
Removes an outline created in the editor or by script. You have to call [method make_polygons_from_outlines] for the polygons to update.
*/
//go:nosplit
func (self class) RemoveOutline(idx int64) { //gd:NavigationPolygon.remove_outline
	var frame = callframe.New()
	callframe.Arg(frame, idx)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.NavigationPolygon.Bind_remove_outline, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Clears the array of the outlines, but it doesn't clear the vertices and the polygons that were created by them.
*/
//go:nosplit
func (self class) ClearOutlines() { //gd:NavigationPolygon.clear_outlines
	var frame = callframe.New()
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.NavigationPolygon.Bind_clear_outlines, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Creates polygons from the outlines added in the editor or by script.
*/
//go:nosplit
func (self class) MakePolygonsFromOutlines() { //gd:NavigationPolygon.make_polygons_from_outlines
	var frame = callframe.New()
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.NavigationPolygon.Bind_make_polygons_from_outlines, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) SetCellSize(cell_size float64) { //gd:NavigationPolygon.set_cell_size
	var frame = callframe.New()
	callframe.Arg(frame, cell_size)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.NavigationPolygon.Bind_set_cell_size, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) GetCellSize() float64 { //gd:NavigationPolygon.get_cell_size
	var frame = callframe.New()
	var r_ret = callframe.Ret[float64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.NavigationPolygon.Bind_get_cell_size, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

//go:nosplit
func (self class) SetBorderSize(border_size float64) { //gd:NavigationPolygon.set_border_size
	var frame = callframe.New()
	callframe.Arg(frame, border_size)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.NavigationPolygon.Bind_set_border_size, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) GetBorderSize() float64 { //gd:NavigationPolygon.get_border_size
	var frame = callframe.New()
	var r_ret = callframe.Ret[float64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.NavigationPolygon.Bind_get_border_size, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

//go:nosplit
func (self class) SetSamplePartitionType(sample_partition_type SamplePartitionType) { //gd:NavigationPolygon.set_sample_partition_type
	var frame = callframe.New()
	callframe.Arg(frame, sample_partition_type)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.NavigationPolygon.Bind_set_sample_partition_type, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) GetSamplePartitionType() SamplePartitionType { //gd:NavigationPolygon.get_sample_partition_type
	var frame = callframe.New()
	var r_ret = callframe.Ret[SamplePartitionType](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.NavigationPolygon.Bind_get_sample_partition_type, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

//go:nosplit
func (self class) SetParsedGeometryType(geometry_type ParsedGeometryType) { //gd:NavigationPolygon.set_parsed_geometry_type
	var frame = callframe.New()
	callframe.Arg(frame, geometry_type)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.NavigationPolygon.Bind_set_parsed_geometry_type, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) GetParsedGeometryType() ParsedGeometryType { //gd:NavigationPolygon.get_parsed_geometry_type
	var frame = callframe.New()
	var r_ret = callframe.Ret[ParsedGeometryType](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.NavigationPolygon.Bind_get_parsed_geometry_type, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

//go:nosplit
func (self class) SetParsedCollisionMask(mask int64) { //gd:NavigationPolygon.set_parsed_collision_mask
	var frame = callframe.New()
	callframe.Arg(frame, mask)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.NavigationPolygon.Bind_set_parsed_collision_mask, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) GetParsedCollisionMask() int64 { //gd:NavigationPolygon.get_parsed_collision_mask
	var frame = callframe.New()
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.NavigationPolygon.Bind_get_parsed_collision_mask, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Based on [param value], enables or disables the specified layer in the [member parsed_collision_mask], given a [param layer_number] between 1 and 32.
*/
//go:nosplit
func (self class) SetParsedCollisionMaskValue(layer_number int64, value bool) { //gd:NavigationPolygon.set_parsed_collision_mask_value
	var frame = callframe.New()
	callframe.Arg(frame, layer_number)
	callframe.Arg(frame, value)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.NavigationPolygon.Bind_set_parsed_collision_mask_value, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Returns whether or not the specified layer of the [member parsed_collision_mask] is enabled, given a [param layer_number] between 1 and 32.
*/
//go:nosplit
func (self class) GetParsedCollisionMaskValue(layer_number int64) bool { //gd:NavigationPolygon.get_parsed_collision_mask_value
	var frame = callframe.New()
	callframe.Arg(frame, layer_number)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.NavigationPolygon.Bind_get_parsed_collision_mask_value, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

//go:nosplit
func (self class) SetSourceGeometryMode(geometry_mode SourceGeometryMode) { //gd:NavigationPolygon.set_source_geometry_mode
	var frame = callframe.New()
	callframe.Arg(frame, geometry_mode)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.NavigationPolygon.Bind_set_source_geometry_mode, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) GetSourceGeometryMode() SourceGeometryMode { //gd:NavigationPolygon.get_source_geometry_mode
	var frame = callframe.New()
	var r_ret = callframe.Ret[SourceGeometryMode](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.NavigationPolygon.Bind_get_source_geometry_mode, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

//go:nosplit
func (self class) SetSourceGeometryGroupName(group_name String.Name) { //gd:NavigationPolygon.set_source_geometry_group_name
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalStringName(group_name)))
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.NavigationPolygon.Bind_set_source_geometry_group_name, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) GetSourceGeometryGroupName() String.Name { //gd:NavigationPolygon.get_source_geometry_group_name
	var frame = callframe.New()
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.NavigationPolygon.Bind_get_source_geometry_group_name, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Name(String.Via(gd.StringNameProxy{}, pointers.Pack(pointers.New[gd.StringName](r_ret.Get()))))
	frame.Free()
	return ret
}

//go:nosplit
func (self class) SetAgentRadius(agent_radius float64) { //gd:NavigationPolygon.set_agent_radius
	var frame = callframe.New()
	callframe.Arg(frame, agent_radius)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.NavigationPolygon.Bind_set_agent_radius, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) GetAgentRadius() float64 { //gd:NavigationPolygon.get_agent_radius
	var frame = callframe.New()
	var r_ret = callframe.Ret[float64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.NavigationPolygon.Bind_get_agent_radius, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

//go:nosplit
func (self class) SetBakingRect(rect Rect2.PositionSize) { //gd:NavigationPolygon.set_baking_rect
	var frame = callframe.New()
	callframe.Arg(frame, rect)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.NavigationPolygon.Bind_set_baking_rect, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) GetBakingRect() Rect2.PositionSize { //gd:NavigationPolygon.get_baking_rect
	var frame = callframe.New()
	var r_ret = callframe.Ret[Rect2.PositionSize](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.NavigationPolygon.Bind_get_baking_rect, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

//go:nosplit
func (self class) SetBakingRectOffset(rect_offset Vector2.XY) { //gd:NavigationPolygon.set_baking_rect_offset
	var frame = callframe.New()
	callframe.Arg(frame, rect_offset)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.NavigationPolygon.Bind_set_baking_rect_offset, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) GetBakingRectOffset() Vector2.XY { //gd:NavigationPolygon.get_baking_rect_offset
	var frame = callframe.New()
	var r_ret = callframe.Ret[Vector2.XY](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.NavigationPolygon.Bind_get_baking_rect_offset, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Clears the internal arrays for vertices and polygon indices.
*/
//go:nosplit
func (self class) Clear() { //gd:NavigationPolygon.clear
	var frame = callframe.New()
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.NavigationPolygon.Bind_clear, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}
func (self class) AsNavigationPolygon() Advanced         { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsNavigationPolygon() Instance      { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsNavigationPolygon() Instance { return self.Super().AsNavigationPolygon() }
func (self class) AsResource() Resource.Advanced {
	return *((*Resource.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsResource() Resource.Instance { return self.Super().AsResource() }
func (self Instance) AsResource() Resource.Instance {
	return *((*Resource.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsRefCounted() [1]gd.RefCounted { return self.Super().AsRefCounted() }
func (self Instance) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Resource.Advanced(self.AsResource()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Resource.Instance(self.AsResource()), name)
	}
}
func init() {
	gdclass.Register("NavigationPolygon", func(ptr gd.Object) any {
		return [1]gdclass.NavigationPolygon{*(*gdclass.NavigationPolygon)(unsafe.Pointer(&ptr))}
	})
}

type SamplePartitionType int //gd:NavigationPolygon.SamplePartitionType

const (
	/*Convex partitioning that yields navigation mesh with convex polygons.*/
	SamplePartitionConvexPartition SamplePartitionType = 0
	/*Triangulation partitioning that yields navigation mesh with triangle polygons.*/
	SamplePartitionTriangulate SamplePartitionType = 1
	/*Represents the size of the [enum SamplePartitionType] enum.*/
	SamplePartitionMax SamplePartitionType = 2
)

type ParsedGeometryType int //gd:NavigationPolygon.ParsedGeometryType

const (
	/*Parses mesh instances as obstruction geometry. This includes [Polygon2D], [MeshInstance2D], [MultiMeshInstance2D], and [TileMap] nodes.
	  Meshes are only parsed when they use a 2D vertices surface format.*/
	ParsedGeometryMeshInstances ParsedGeometryType = 0
	/*Parses [StaticBody2D] and [TileMap] colliders as obstruction geometry. The collider should be in any of the layers specified by [member parsed_collision_mask].*/
	ParsedGeometryStaticColliders ParsedGeometryType = 1
	/*Both [constant PARSED_GEOMETRY_MESH_INSTANCES] and [constant PARSED_GEOMETRY_STATIC_COLLIDERS].*/
	ParsedGeometryBoth ParsedGeometryType = 2
	/*Represents the size of the [enum ParsedGeometryType] enum.*/
	ParsedGeometryMax ParsedGeometryType = 3
)

type SourceGeometryMode int //gd:NavigationPolygon.SourceGeometryMode

const (
	/*Scans the child nodes of the root node recursively for geometry.*/
	SourceGeometryRootNodeChildren SourceGeometryMode = 0
	/*Scans nodes in a group and their child nodes recursively for geometry. The group is specified by [member source_geometry_group_name].*/
	SourceGeometryGroupsWithChildren SourceGeometryMode = 1
	/*Uses nodes in a group for geometry. The group is specified by [member source_geometry_group_name].*/
	SourceGeometryGroupsExplicit SourceGeometryMode = 2
	/*Represents the size of the [enum SourceGeometryMode] enum.*/
	SourceGeometryMax SourceGeometryMode = 3
)
