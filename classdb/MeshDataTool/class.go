// Code generated by the generate package DO NOT EDIT

// Package MeshDataTool provides methods for working with MeshDataTool object instances.
package MeshDataTool

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/ArrayMesh"
import "graphics.gd/classdb/Material"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Color"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/Plane"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"
import "graphics.gd/variant/Vector2"
import "graphics.gd/variant/Vector3"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
MeshDataTool provides access to individual vertices in a [Mesh]. It allows users to read and edit vertex data of meshes. It also creates an array of faces and edges.
To use MeshDataTool, load a mesh with [method create_from_surface]. When you are finished editing the data commit the data to a mesh with [method commit_to_surface].
Below is an example of how MeshDataTool may be used.
[codeblocks]
[gdscript]
var mesh = ArrayMesh.new()
mesh.add_surface_from_arrays(Mesh.PRIMITIVE_TRIANGLES, BoxMesh.new().get_mesh_arrays())
var mdt = MeshDataTool.new()
mdt.create_from_surface(mesh, 0)
for i in range(mdt.get_vertex_count()):

	var vertex = mdt.get_vertex(i)
	# In this example we extend the mesh by one unit, which results in separated faces as it is flat shaded.
	vertex += mdt.get_vertex_normal(i)
	# Save your change.
	mdt.set_vertex(i, vertex)

mesh.clear_surfaces()
mdt.commit_to_surface(mesh)
var mi = MeshInstance.new()
mi.mesh = mesh
add_child(mi)
[/gdscript]
[csharp]
var mesh = new ArrayMesh();
mesh.AddSurfaceFromArrays(Mesh.PrimitiveType.Triangles, new BoxMesh().GetMeshArrays());
var mdt = new MeshDataTool();
mdt.CreateFromSurface(mesh, 0);
for (var i = 0; i < mdt.GetVertexCount(); i++)

	{
	    Vector3 vertex = mdt.GetVertex(i);
	    // In this example we extend the mesh by one unit, which results in separated faces as it is flat shaded.
	    vertex += mdt.GetVertexNormal(i);
	    // Save your change.
	    mdt.SetVertex(i, vertex);
	}

mesh.ClearSurfaces();
mdt.CommitToSurface(mesh);
var mi = new MeshInstance();
mi.Mesh = mesh;
AddChild(mi);
[/csharp]
[/codeblocks]
See also [ArrayMesh], [ImmediateMesh] and [SurfaceTool] for procedural geometry generation.
[b]Note:[/b] Godot uses clockwise [url=https://learnopengl.com/Advanced-OpenGL/Face-culling]winding order[/url] for front faces of triangle primitive modes.
*/
type Instance [1]gdclass.MeshDataTool

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	clear               gdextension.MethodForClass `hash:"3218959716"`
	create_from_surface gdextension.MethodForClass `hash:"2727020678"`
	commit_to_surface   gdextension.MethodForClass `hash:"2021686445"`
	get_format          gdextension.MethodForClass `hash:"3905245786"`
	get_vertex_count    gdextension.MethodForClass `hash:"3905245786"`
	get_edge_count      gdextension.MethodForClass `hash:"3905245786"`
	get_face_count      gdextension.MethodForClass `hash:"3905245786"`
	set_vertex          gdextension.MethodForClass `hash:"1530502735"`
	get_vertex          gdextension.MethodForClass `hash:"711720468"`
	set_vertex_normal   gdextension.MethodForClass `hash:"1530502735"`
	get_vertex_normal   gdextension.MethodForClass `hash:"711720468"`
	set_vertex_tangent  gdextension.MethodForClass `hash:"1104099133"`
	get_vertex_tangent  gdextension.MethodForClass `hash:"1372055458"`
	set_vertex_uv       gdextension.MethodForClass `hash:"163021252"`
	get_vertex_uv       gdextension.MethodForClass `hash:"2299179447"`
	set_vertex_uv2      gdextension.MethodForClass `hash:"163021252"`
	get_vertex_uv2      gdextension.MethodForClass `hash:"2299179447"`
	set_vertex_color    gdextension.MethodForClass `hash:"2878471219"`
	get_vertex_color    gdextension.MethodForClass `hash:"3457211756"`
	set_vertex_bones    gdextension.MethodForClass `hash:"3500328261"`
	get_vertex_bones    gdextension.MethodForClass `hash:"1706082319"`
	set_vertex_weights  gdextension.MethodForClass `hash:"1345852415"`
	get_vertex_weights  gdextension.MethodForClass `hash:"1542882410"`
	set_vertex_meta     gdextension.MethodForClass `hash:"2152698145"`
	get_vertex_meta     gdextension.MethodForClass `hash:"4227898402"`
	get_vertex_edges    gdextension.MethodForClass `hash:"1706082319"`
	get_vertex_faces    gdextension.MethodForClass `hash:"1706082319"`
	get_edge_vertex     gdextension.MethodForClass `hash:"3175239445"`
	get_edge_faces      gdextension.MethodForClass `hash:"1706082319"`
	set_edge_meta       gdextension.MethodForClass `hash:"2152698145"`
	get_edge_meta       gdextension.MethodForClass `hash:"4227898402"`
	get_face_vertex     gdextension.MethodForClass `hash:"3175239445"`
	get_face_edge       gdextension.MethodForClass `hash:"3175239445"`
	set_face_meta       gdextension.MethodForClass `hash:"2152698145"`
	get_face_meta       gdextension.MethodForClass `hash:"4227898402"`
	get_face_normal     gdextension.MethodForClass `hash:"711720468"`
	set_material        gdextension.MethodForClass `hash:"2757459619"`
	get_material        gdextension.MethodForClass `hash:"5934680"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("MeshDataTool")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		gdextension.Free(gdextension.TypeStringName, &sname)
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

type Expanded [1]gdclass.MeshDataTool

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsMeshDataTool() Instance
}

/*
Clears all data currently in MeshDataTool.
*/
func (self Instance) Clear() { //gd:MeshDataTool.clear
	Advanced(self).Clear()
}

/*
Uses specified surface of given [Mesh] to populate data for MeshDataTool.
Requires [Mesh] with primitive type [constant Mesh.PRIMITIVE_TRIANGLES].
*/
func (self Instance) CreateFromSurface(mesh ArrayMesh.Instance, surface int) error { //gd:MeshDataTool.create_from_surface
	return error(gd.ToError(Advanced(self).CreateFromSurface(mesh, int64(surface))))
}

/*
Adds a new surface to specified [Mesh] with edited data.
*/
func (self Instance) CommitToSurface(mesh ArrayMesh.Instance) error { //gd:MeshDataTool.commit_to_surface
	return error(gd.ToError(Advanced(self).CommitToSurface(mesh, int64(0))))
}

/*
Adds a new surface to specified [Mesh] with edited data.
*/
func (self Expanded) CommitToSurface(mesh ArrayMesh.Instance, compression_flags int) error { //gd:MeshDataTool.commit_to_surface
	return error(gd.ToError(Advanced(self).CommitToSurface(mesh, int64(compression_flags))))
}

/*
Returns the [Mesh]'s format as a combination of the [enum Mesh.ArrayFormat] flags. For example, a mesh containing both vertices and normals would return a format of [code]3[/code] because [constant Mesh.ARRAY_FORMAT_VERTEX] is [code]1[/code] and [constant Mesh.ARRAY_FORMAT_NORMAL] is [code]2[/code].
*/
func (self Instance) GetFormat() int { //gd:MeshDataTool.get_format
	return int(int(Advanced(self).GetFormat()))
}

/*
Returns the total number of vertices in [Mesh].
*/
func (self Instance) GetVertexCount() int { //gd:MeshDataTool.get_vertex_count
	return int(int(Advanced(self).GetVertexCount()))
}

/*
Returns the number of edges in this [Mesh].
*/
func (self Instance) GetEdgeCount() int { //gd:MeshDataTool.get_edge_count
	return int(int(Advanced(self).GetEdgeCount()))
}

/*
Returns the number of faces in this [Mesh].
*/
func (self Instance) GetFaceCount() int { //gd:MeshDataTool.get_face_count
	return int(int(Advanced(self).GetFaceCount()))
}

/*
Sets the position of the given vertex.
*/
func (self Instance) SetVertex(idx int, vertex Vector3.XYZ) { //gd:MeshDataTool.set_vertex
	Advanced(self).SetVertex(int64(idx), Vector3.XYZ(vertex))
}

/*
Returns the position of the given vertex.
*/
func (self Instance) GetVertex(idx int) Vector3.XYZ { //gd:MeshDataTool.get_vertex
	return Vector3.XYZ(Advanced(self).GetVertex(int64(idx)))
}

/*
Sets the normal of the given vertex.
*/
func (self Instance) SetVertexNormal(idx int, normal Vector3.XYZ) { //gd:MeshDataTool.set_vertex_normal
	Advanced(self).SetVertexNormal(int64(idx), Vector3.XYZ(normal))
}

/*
Returns the normal of the given vertex.
*/
func (self Instance) GetVertexNormal(idx int) Vector3.XYZ { //gd:MeshDataTool.get_vertex_normal
	return Vector3.XYZ(Advanced(self).GetVertexNormal(int64(idx)))
}

/*
Sets the tangent of the given vertex.
*/
func (self Instance) SetVertexTangent(idx int, tangent Plane.NormalD) { //gd:MeshDataTool.set_vertex_tangent
	Advanced(self).SetVertexTangent(int64(idx), Plane.NormalD(tangent))
}

/*
Returns the tangent of the given vertex.
*/
func (self Instance) GetVertexTangent(idx int) Plane.NormalD { //gd:MeshDataTool.get_vertex_tangent
	return Plane.NormalD(Advanced(self).GetVertexTangent(int64(idx)))
}

/*
Sets the UV of the given vertex.
*/
func (self Instance) SetVertexUv(idx int, uv Vector2.XY) { //gd:MeshDataTool.set_vertex_uv
	Advanced(self).SetVertexUv(int64(idx), Vector2.XY(uv))
}

/*
Returns the UV of the given vertex.
*/
func (self Instance) GetVertexUv(idx int) Vector2.XY { //gd:MeshDataTool.get_vertex_uv
	return Vector2.XY(Advanced(self).GetVertexUv(int64(idx)))
}

/*
Sets the UV2 of the given vertex.
*/
func (self Instance) SetVertexUv2(idx int, uv2 Vector2.XY) { //gd:MeshDataTool.set_vertex_uv2
	Advanced(self).SetVertexUv2(int64(idx), Vector2.XY(uv2))
}

/*
Returns the UV2 of the given vertex.
*/
func (self Instance) GetVertexUv2(idx int) Vector2.XY { //gd:MeshDataTool.get_vertex_uv2
	return Vector2.XY(Advanced(self).GetVertexUv2(int64(idx)))
}

/*
Sets the color of the given vertex.
*/
func (self Instance) SetVertexColor(idx int, color Color.RGBA) { //gd:MeshDataTool.set_vertex_color
	Advanced(self).SetVertexColor(int64(idx), Color.RGBA(color))
}

/*
Returns the color of the given vertex.
*/
func (self Instance) GetVertexColor(idx int) Color.RGBA { //gd:MeshDataTool.get_vertex_color
	return Color.RGBA(Advanced(self).GetVertexColor(int64(idx)))
}

/*
Sets the bones of the given vertex.
*/
func (self Instance) SetVertexBones(idx int, bones []int32) { //gd:MeshDataTool.set_vertex_bones
	Advanced(self).SetVertexBones(int64(idx), Packed.New(bones...))
}

/*
Returns the bones of the given vertex.
*/
func (self Instance) GetVertexBones(idx int) []int32 { //gd:MeshDataTool.get_vertex_bones
	return []int32(slices.Collect(Advanced(self).GetVertexBones(int64(idx)).Values()))
}

/*
Sets the bone weights of the given vertex.
*/
func (self Instance) SetVertexWeights(idx int, weights []float32) { //gd:MeshDataTool.set_vertex_weights
	Advanced(self).SetVertexWeights(int64(idx), Packed.New(weights...))
}

/*
Returns bone weights of the given vertex.
*/
func (self Instance) GetVertexWeights(idx int) []float32 { //gd:MeshDataTool.get_vertex_weights
	return []float32(slices.Collect(Advanced(self).GetVertexWeights(int64(idx)).Values()))
}

/*
Sets the metadata associated with the given vertex.
*/
func (self Instance) SetVertexMeta(idx int, meta any) { //gd:MeshDataTool.set_vertex_meta
	Advanced(self).SetVertexMeta(int64(idx), variant.New(meta))
}

/*
Returns the metadata associated with the given vertex.
*/
func (self Instance) GetVertexMeta(idx int) any { //gd:MeshDataTool.get_vertex_meta
	return any(Advanced(self).GetVertexMeta(int64(idx)).Interface())
}

/*
Returns an array of edges that share the given vertex.
*/
func (self Instance) GetVertexEdges(idx int) []int32 { //gd:MeshDataTool.get_vertex_edges
	return []int32(slices.Collect(Advanced(self).GetVertexEdges(int64(idx)).Values()))
}

/*
Returns an array of faces that share the given vertex.
*/
func (self Instance) GetVertexFaces(idx int) []int32 { //gd:MeshDataTool.get_vertex_faces
	return []int32(slices.Collect(Advanced(self).GetVertexFaces(int64(idx)).Values()))
}

/*
Returns index of specified vertex connected to given edge.
Vertex argument can only be 0 or 1 because edges are comprised of two vertices.
*/
func (self Instance) GetEdgeVertex(idx int, vertex int) int { //gd:MeshDataTool.get_edge_vertex
	return int(int(Advanced(self).GetEdgeVertex(int64(idx), int64(vertex))))
}

/*
Returns array of faces that touch given edge.
*/
func (self Instance) GetEdgeFaces(idx int) []int32 { //gd:MeshDataTool.get_edge_faces
	return []int32(slices.Collect(Advanced(self).GetEdgeFaces(int64(idx)).Values()))
}

/*
Sets the metadata of the given edge.
*/
func (self Instance) SetEdgeMeta(idx int, meta any) { //gd:MeshDataTool.set_edge_meta
	Advanced(self).SetEdgeMeta(int64(idx), variant.New(meta))
}

/*
Returns meta information assigned to given edge.
*/
func (self Instance) GetEdgeMeta(idx int) any { //gd:MeshDataTool.get_edge_meta
	return any(Advanced(self).GetEdgeMeta(int64(idx)).Interface())
}

/*
Returns the specified vertex index of the given face.
[param vertex] must be either [code]0[/code], [code]1[/code], or [code]2[/code] because faces contain three vertices.
[codeblocks]
[gdscript]
var index = mesh_data_tool.get_face_vertex(0, 1) # Gets the index of the second vertex of the first face.
var position = mesh_data_tool.get_vertex(index)
var normal = mesh_data_tool.get_vertex_normal(index)
[/gdscript]
[csharp]
int index = meshDataTool.GetFaceVertex(0, 1); // Gets the index of the second vertex of the first face.
Vector3 position = meshDataTool.GetVertex(index);
Vector3 normal = meshDataTool.GetVertexNormal(index);
[/csharp]
[/codeblocks]
*/
func (self Instance) GetFaceVertex(idx int, vertex int) int { //gd:MeshDataTool.get_face_vertex
	return int(int(Advanced(self).GetFaceVertex(int64(idx), int64(vertex))))
}

/*
Returns specified edge associated with given face.
Edge argument must be either 0, 1, or 2 because a face only has three edges.
*/
func (self Instance) GetFaceEdge(idx int, edge int) int { //gd:MeshDataTool.get_face_edge
	return int(int(Advanced(self).GetFaceEdge(int64(idx), int64(edge))))
}

/*
Sets the metadata of the given face.
*/
func (self Instance) SetFaceMeta(idx int, meta any) { //gd:MeshDataTool.set_face_meta
	Advanced(self).SetFaceMeta(int64(idx), variant.New(meta))
}

/*
Returns the metadata associated with the given face.
*/
func (self Instance) GetFaceMeta(idx int) any { //gd:MeshDataTool.get_face_meta
	return any(Advanced(self).GetFaceMeta(int64(idx)).Interface())
}

/*
Calculates and returns the face normal of the given face.
*/
func (self Instance) GetFaceNormal(idx int) Vector3.XYZ { //gd:MeshDataTool.get_face_normal
	return Vector3.XYZ(Advanced(self).GetFaceNormal(int64(idx)))
}

/*
Sets the material to be used by newly-constructed [Mesh].
*/
func (self Instance) SetMaterial(material Material.Instance) { //gd:MeshDataTool.set_material
	Advanced(self).SetMaterial(material)
}

/*
Returns the material assigned to the [Mesh].
*/
func (self Instance) GetMaterial() Material.Instance { //gd:MeshDataTool.get_material
	return Material.Instance(Advanced(self).GetMaterial())
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.MeshDataTool

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.MeshDataTool)(unsafe.Pointer(&obj))
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.MeshDataTool)(unsafe.Pointer(&obj))
		return true
	}
	return false
}

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {

	if !gd.Linked {
		var placeholder Instance
		*(*gd.Object)(unsafe.Pointer(&placeholder)) = pointers.Add[gd.Object]([3]uint64{})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(*(*gd.Object)(unsafe.Pointer(&placeholder)), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	object := [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})}
	casted := Instance{*(*gdclass.MeshDataTool)(unsafe.Pointer(&object))}
	casted.AsRefCounted()[0].InitRef()
	object[0].Notification(0, false)
	return casted
}

/*
Clears all data currently in MeshDataTool.
*/
//go:nosplit
func (self class) Clear() { //gd:MeshDataTool.clear
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.clear, 0, unsafe.Pointer(&struct{}{}))
}

/*
Uses specified surface of given [Mesh] to populate data for MeshDataTool.
Requires [Mesh] with primitive type [constant Mesh.PRIMITIVE_TRIANGLES].
*/
//go:nosplit
func (self class) CreateFromSurface(mesh [1]gdclass.ArrayMesh, surface int64) Error.Code { //gd:MeshDataTool.create_from_surface
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.create_from_surface, gdextension.SizeInt|(gdextension.SizeObject<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		mesh    gdextension.Object
		surface int64
	}{gdextension.Object(gd.ObjectChecked(mesh[0].AsObject())), surface}))
	var ret = Error.Code(r_ret)
	return ret
}

/*
Adds a new surface to specified [Mesh] with edited data.
*/
//go:nosplit
func (self class) CommitToSurface(mesh [1]gdclass.ArrayMesh, compression_flags int64) Error.Code { //gd:MeshDataTool.commit_to_surface
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.commit_to_surface, gdextension.SizeInt|(gdextension.SizeObject<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		mesh              gdextension.Object
		compression_flags int64
	}{gdextension.Object(gd.ObjectChecked(mesh[0].AsObject())), compression_flags}))
	var ret = Error.Code(r_ret)
	return ret
}

/*
Returns the [Mesh]'s format as a combination of the [enum Mesh.ArrayFormat] flags. For example, a mesh containing both vertices and normals would return a format of [code]3[/code] because [constant Mesh.ARRAY_FORMAT_VERTEX] is [code]1[/code] and [constant Mesh.ARRAY_FORMAT_NORMAL] is [code]2[/code].
*/
//go:nosplit
func (self class) GetFormat() int64 { //gd:MeshDataTool.get_format
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_format, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the total number of vertices in [Mesh].
*/
//go:nosplit
func (self class) GetVertexCount() int64 { //gd:MeshDataTool.get_vertex_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_vertex_count, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the number of edges in this [Mesh].
*/
//go:nosplit
func (self class) GetEdgeCount() int64 { //gd:MeshDataTool.get_edge_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_edge_count, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the number of faces in this [Mesh].
*/
//go:nosplit
func (self class) GetFaceCount() int64 { //gd:MeshDataTool.get_face_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_face_count, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Sets the position of the given vertex.
*/
//go:nosplit
func (self class) SetVertex(idx int64, vertex Vector3.XYZ) { //gd:MeshDataTool.set_vertex
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_vertex, 0|(gdextension.SizeInt<<4)|(gdextension.SizeVector3<<8), unsafe.Pointer(&struct {
		idx    int64
		vertex Vector3.XYZ
	}{idx, vertex}))
}

/*
Returns the position of the given vertex.
*/
//go:nosplit
func (self class) GetVertex(idx int64) Vector3.XYZ { //gd:MeshDataTool.get_vertex
	var r_ret = gdextension.Call[Vector3.XYZ](gd.ObjectChecked(self.AsObject()), methods.get_vertex, gdextension.SizeVector3|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ idx int64 }{idx}))
	var ret = r_ret
	return ret
}

/*
Sets the normal of the given vertex.
*/
//go:nosplit
func (self class) SetVertexNormal(idx int64, normal Vector3.XYZ) { //gd:MeshDataTool.set_vertex_normal
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_vertex_normal, 0|(gdextension.SizeInt<<4)|(gdextension.SizeVector3<<8), unsafe.Pointer(&struct {
		idx    int64
		normal Vector3.XYZ
	}{idx, normal}))
}

/*
Returns the normal of the given vertex.
*/
//go:nosplit
func (self class) GetVertexNormal(idx int64) Vector3.XYZ { //gd:MeshDataTool.get_vertex_normal
	var r_ret = gdextension.Call[Vector3.XYZ](gd.ObjectChecked(self.AsObject()), methods.get_vertex_normal, gdextension.SizeVector3|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ idx int64 }{idx}))
	var ret = r_ret
	return ret
}

/*
Sets the tangent of the given vertex.
*/
//go:nosplit
func (self class) SetVertexTangent(idx int64, tangent Plane.NormalD) { //gd:MeshDataTool.set_vertex_tangent
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_vertex_tangent, 0|(gdextension.SizeInt<<4)|(gdextension.SizePlane<<8), unsafe.Pointer(&struct {
		idx     int64
		tangent Plane.NormalD
	}{idx, tangent}))
}

/*
Returns the tangent of the given vertex.
*/
//go:nosplit
func (self class) GetVertexTangent(idx int64) Plane.NormalD { //gd:MeshDataTool.get_vertex_tangent
	var r_ret = gdextension.Call[Plane.NormalD](gd.ObjectChecked(self.AsObject()), methods.get_vertex_tangent, gdextension.SizePlane|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ idx int64 }{idx}))
	var ret = r_ret
	return ret
}

/*
Sets the UV of the given vertex.
*/
//go:nosplit
func (self class) SetVertexUv(idx int64, uv Vector2.XY) { //gd:MeshDataTool.set_vertex_uv
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_vertex_uv, 0|(gdextension.SizeInt<<4)|(gdextension.SizeVector2<<8), unsafe.Pointer(&struct {
		idx int64
		uv  Vector2.XY
	}{idx, uv}))
}

/*
Returns the UV of the given vertex.
*/
//go:nosplit
func (self class) GetVertexUv(idx int64) Vector2.XY { //gd:MeshDataTool.get_vertex_uv
	var r_ret = gdextension.Call[Vector2.XY](gd.ObjectChecked(self.AsObject()), methods.get_vertex_uv, gdextension.SizeVector2|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ idx int64 }{idx}))
	var ret = r_ret
	return ret
}

/*
Sets the UV2 of the given vertex.
*/
//go:nosplit
func (self class) SetVertexUv2(idx int64, uv2 Vector2.XY) { //gd:MeshDataTool.set_vertex_uv2
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_vertex_uv2, 0|(gdextension.SizeInt<<4)|(gdextension.SizeVector2<<8), unsafe.Pointer(&struct {
		idx int64
		uv2 Vector2.XY
	}{idx, uv2}))
}

/*
Returns the UV2 of the given vertex.
*/
//go:nosplit
func (self class) GetVertexUv2(idx int64) Vector2.XY { //gd:MeshDataTool.get_vertex_uv2
	var r_ret = gdextension.Call[Vector2.XY](gd.ObjectChecked(self.AsObject()), methods.get_vertex_uv2, gdextension.SizeVector2|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ idx int64 }{idx}))
	var ret = r_ret
	return ret
}

/*
Sets the color of the given vertex.
*/
//go:nosplit
func (self class) SetVertexColor(idx int64, color Color.RGBA) { //gd:MeshDataTool.set_vertex_color
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_vertex_color, 0|(gdextension.SizeInt<<4)|(gdextension.SizeColor<<8), unsafe.Pointer(&struct {
		idx   int64
		color Color.RGBA
	}{idx, color}))
}

/*
Returns the color of the given vertex.
*/
//go:nosplit
func (self class) GetVertexColor(idx int64) Color.RGBA { //gd:MeshDataTool.get_vertex_color
	var r_ret = gdextension.Call[Color.RGBA](gd.ObjectChecked(self.AsObject()), methods.get_vertex_color, gdextension.SizeColor|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ idx int64 }{idx}))
	var ret = r_ret
	return ret
}

/*
Sets the bones of the given vertex.
*/
//go:nosplit
func (self class) SetVertexBones(idx int64, bones Packed.Array[int32]) { //gd:MeshDataTool.set_vertex_bones
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_vertex_bones, 0|(gdextension.SizeInt<<4)|(gdextension.SizePackedArray<<8), unsafe.Pointer(&struct {
		idx   int64
		bones gdextension.PackedArray[int32]
	}{idx, pointers.Get(gd.InternalPacked[gd.PackedInt32Array, int32](bones))}))
}

/*
Returns the bones of the given vertex.
*/
//go:nosplit
func (self class) GetVertexBones(idx int64) Packed.Array[int32] { //gd:MeshDataTool.get_vertex_bones
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.get_vertex_bones, gdextension.SizePackedArray|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ idx int64 }{idx}))
	var ret = Packed.Array[int32](Array.Through(gd.PackedProxy[gd.PackedInt32Array, int32]{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

/*
Sets the bone weights of the given vertex.
*/
//go:nosplit
func (self class) SetVertexWeights(idx int64, weights Packed.Array[float32]) { //gd:MeshDataTool.set_vertex_weights
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_vertex_weights, 0|(gdextension.SizeInt<<4)|(gdextension.SizePackedArray<<8), unsafe.Pointer(&struct {
		idx     int64
		weights gdextension.PackedArray[float32]
	}{idx, pointers.Get(gd.InternalPacked[gd.PackedFloat32Array, float32](weights))}))
}

/*
Returns bone weights of the given vertex.
*/
//go:nosplit
func (self class) GetVertexWeights(idx int64) Packed.Array[float32] { //gd:MeshDataTool.get_vertex_weights
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.get_vertex_weights, gdextension.SizePackedArray|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ idx int64 }{idx}))
	var ret = Packed.Array[float32](Array.Through(gd.PackedProxy[gd.PackedFloat32Array, float32]{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

/*
Sets the metadata associated with the given vertex.
*/
//go:nosplit
func (self class) SetVertexMeta(idx int64, meta variant.Any) { //gd:MeshDataTool.set_vertex_meta
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_vertex_meta, 0|(gdextension.SizeInt<<4)|(gdextension.SizeVariant<<8), unsafe.Pointer(&struct {
		idx  int64
		meta gdextension.Variant
	}{idx, gdextension.Variant(pointers.Get(gd.InternalVariant(meta)))}))
}

/*
Returns the metadata associated with the given vertex.
*/
//go:nosplit
func (self class) GetVertexMeta(idx int64) variant.Any { //gd:MeshDataTool.get_vertex_meta
	var r_ret = gdextension.Call[gdextension.Variant](gd.ObjectChecked(self.AsObject()), methods.get_vertex_meta, gdextension.SizeVariant|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ idx int64 }{idx}))
	var ret = variant.Implementation(gd.VariantProxy{}, pointers.Pack(pointers.New[gd.Variant](r_ret)))
	return ret
}

/*
Returns an array of edges that share the given vertex.
*/
//go:nosplit
func (self class) GetVertexEdges(idx int64) Packed.Array[int32] { //gd:MeshDataTool.get_vertex_edges
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.get_vertex_edges, gdextension.SizePackedArray|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ idx int64 }{idx}))
	var ret = Packed.Array[int32](Array.Through(gd.PackedProxy[gd.PackedInt32Array, int32]{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

/*
Returns an array of faces that share the given vertex.
*/
//go:nosplit
func (self class) GetVertexFaces(idx int64) Packed.Array[int32] { //gd:MeshDataTool.get_vertex_faces
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.get_vertex_faces, gdextension.SizePackedArray|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ idx int64 }{idx}))
	var ret = Packed.Array[int32](Array.Through(gd.PackedProxy[gd.PackedInt32Array, int32]{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

/*
Returns index of specified vertex connected to given edge.
Vertex argument can only be 0 or 1 because edges are comprised of two vertices.
*/
//go:nosplit
func (self class) GetEdgeVertex(idx int64, vertex int64) int64 { //gd:MeshDataTool.get_edge_vertex
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_edge_vertex, gdextension.SizeInt|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		idx    int64
		vertex int64
	}{idx, vertex}))
	var ret = r_ret
	return ret
}

/*
Returns array of faces that touch given edge.
*/
//go:nosplit
func (self class) GetEdgeFaces(idx int64) Packed.Array[int32] { //gd:MeshDataTool.get_edge_faces
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.get_edge_faces, gdextension.SizePackedArray|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ idx int64 }{idx}))
	var ret = Packed.Array[int32](Array.Through(gd.PackedProxy[gd.PackedInt32Array, int32]{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

/*
Sets the metadata of the given edge.
*/
//go:nosplit
func (self class) SetEdgeMeta(idx int64, meta variant.Any) { //gd:MeshDataTool.set_edge_meta
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_edge_meta, 0|(gdextension.SizeInt<<4)|(gdextension.SizeVariant<<8), unsafe.Pointer(&struct {
		idx  int64
		meta gdextension.Variant
	}{idx, gdextension.Variant(pointers.Get(gd.InternalVariant(meta)))}))
}

/*
Returns meta information assigned to given edge.
*/
//go:nosplit
func (self class) GetEdgeMeta(idx int64) variant.Any { //gd:MeshDataTool.get_edge_meta
	var r_ret = gdextension.Call[gdextension.Variant](gd.ObjectChecked(self.AsObject()), methods.get_edge_meta, gdextension.SizeVariant|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ idx int64 }{idx}))
	var ret = variant.Implementation(gd.VariantProxy{}, pointers.Pack(pointers.New[gd.Variant](r_ret)))
	return ret
}

/*
Returns the specified vertex index of the given face.
[param vertex] must be either [code]0[/code], [code]1[/code], or [code]2[/code] because faces contain three vertices.
[codeblocks]
[gdscript]
var index = mesh_data_tool.get_face_vertex(0, 1) # Gets the index of the second vertex of the first face.
var position = mesh_data_tool.get_vertex(index)
var normal = mesh_data_tool.get_vertex_normal(index)
[/gdscript]
[csharp]
int index = meshDataTool.GetFaceVertex(0, 1); // Gets the index of the second vertex of the first face.
Vector3 position = meshDataTool.GetVertex(index);
Vector3 normal = meshDataTool.GetVertexNormal(index);
[/csharp]
[/codeblocks]
*/
//go:nosplit
func (self class) GetFaceVertex(idx int64, vertex int64) int64 { //gd:MeshDataTool.get_face_vertex
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_face_vertex, gdextension.SizeInt|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		idx    int64
		vertex int64
	}{idx, vertex}))
	var ret = r_ret
	return ret
}

/*
Returns specified edge associated with given face.
Edge argument must be either 0, 1, or 2 because a face only has three edges.
*/
//go:nosplit
func (self class) GetFaceEdge(idx int64, edge int64) int64 { //gd:MeshDataTool.get_face_edge
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_face_edge, gdextension.SizeInt|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		idx  int64
		edge int64
	}{idx, edge}))
	var ret = r_ret
	return ret
}

/*
Sets the metadata of the given face.
*/
//go:nosplit
func (self class) SetFaceMeta(idx int64, meta variant.Any) { //gd:MeshDataTool.set_face_meta
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_face_meta, 0|(gdextension.SizeInt<<4)|(gdextension.SizeVariant<<8), unsafe.Pointer(&struct {
		idx  int64
		meta gdextension.Variant
	}{idx, gdextension.Variant(pointers.Get(gd.InternalVariant(meta)))}))
}

/*
Returns the metadata associated with the given face.
*/
//go:nosplit
func (self class) GetFaceMeta(idx int64) variant.Any { //gd:MeshDataTool.get_face_meta
	var r_ret = gdextension.Call[gdextension.Variant](gd.ObjectChecked(self.AsObject()), methods.get_face_meta, gdextension.SizeVariant|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ idx int64 }{idx}))
	var ret = variant.Implementation(gd.VariantProxy{}, pointers.Pack(pointers.New[gd.Variant](r_ret)))
	return ret
}

/*
Calculates and returns the face normal of the given face.
*/
//go:nosplit
func (self class) GetFaceNormal(idx int64) Vector3.XYZ { //gd:MeshDataTool.get_face_normal
	var r_ret = gdextension.Call[Vector3.XYZ](gd.ObjectChecked(self.AsObject()), methods.get_face_normal, gdextension.SizeVector3|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ idx int64 }{idx}))
	var ret = r_ret
	return ret
}

/*
Sets the material to be used by newly-constructed [Mesh].
*/
//go:nosplit
func (self class) SetMaterial(material [1]gdclass.Material) { //gd:MeshDataTool.set_material
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_material, 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ material gdextension.Object }{gdextension.Object(gd.ObjectChecked(material[0].AsObject()))}))
}

/*
Returns the material assigned to the [Mesh].
*/
//go:nosplit
func (self class) GetMaterial() [1]gdclass.Material { //gd:MeshDataTool.get_material
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_material, gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.Material{gd.PointerWithOwnershipTransferredToGo[gdclass.Material](r_ret)}
	return ret
}
func (self class) AsMeshDataTool() Advanced         { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsMeshDataTool() Instance      { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsMeshDataTool() Instance { return self.Super().AsMeshDataTool() }
func (self class) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsRefCounted() [1]gd.RefCounted { return self.Super().AsRefCounted() }
func (self Instance) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(RefCounted.Advanced(self.AsRefCounted()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(RefCounted.Instance(self.AsRefCounted()), name)
	}
}
func init() {
	gdclass.Register("MeshDataTool", func(ptr gd.Object) any { return *(*Instance)(unsafe.Pointer(&ptr)) })
}
