// Code generated by the generate package DO NOT EDIT

// Package EditorInspector provides methods for working with EditorInspector object instances.
package EditorInspector

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdunsafe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/CanvasItem"
import "graphics.gd/classdb/ClassDB"
import "graphics.gd/classdb/Container"
import "graphics.gd/classdb/Control"
import "graphics.gd/classdb/EditorProperty"
import "graphics.gd/classdb/Node"
import "graphics.gd/classdb/Resource"
import "graphics.gd/classdb/ScrollContainer"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = gdunsafe.Use{}
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
This is the control that implements property editing in the editor's Settings dialogs, the Inspector dock, etc. To get the [EditorInspector] used in the editor's Inspector dock, use [method EditorInterface.get_inspector].
[EditorInspector] will show properties in the same order as the array returned by [method Object.get_property_list].
If a property's name is path-like (i.e. if it contains forward slashes), [EditorInspector] will create nested sections for "directories" along the path. For example, if a property is named [code]highlighting/gdscript/node_path_color[/code], it will be shown as "Node Path Color" inside the "GDScript" section nested inside the "Highlighting" section.
If a property has [constant PROPERTY_USAGE_GROUP] usage, it will group subsequent properties whose name starts with the property's hint string. The group ends when a property does not start with that hint string or when a new group starts. An empty group name effectively ends the current group. [EditorInspector] will create a top-level section for each group. For example, if a property with group usage is named [code]Collide With[/code] and its hint string is [code]collide_with_[/code], a subsequent [code]collide_with_area[/code] property will be shown as "Area" inside the "Collide With" section. There is also a special case: when the hint string contains the name of a property, that property is grouped too. This is mainly to help grouping properties like [code]font[/code], [code]font_color[/code] and [code]font_size[/code] (using the hint string [code]font_[/code]).
If a property has [constant PROPERTY_USAGE_SUBGROUP] usage, a subgroup will be created in the same way as a group, and a second-level section will be created for each subgroup.
[b]Note:[/b] Unlike sections created from path-like property names, [EditorInspector] won't capitalize the name for sections created from groups. So properties with group usage usually use capitalized names instead of snake_cased names.
*/
type Instance [1]gdclass.EditorInspector

func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsEditorInspector() Instance
}

/*
Shows the properties of the given [param object] in this inspector for editing. To clear the inspector, call this method with [code]null[/code].
[b]Note:[/b] If you want to edit an object in the editor's main inspector, use the [code]edit_*[/code] methods in [EditorInterface] instead.
*/
func (self Instance) Edit(obj Object.Instance) { //gd:EditorInspector.edit
	Advanced(self).Edit(obj)
}

/*
Gets the path of the currently selected property.
*/
func (self Instance) GetSelectedPath() string { //gd:EditorInspector.get_selected_path
	return string(Advanced(self).GetSelectedPath().String())
}

/*
Returns the object currently selected in this inspector.
*/
func (self Instance) GetEditedObject() Object.Instance { //gd:EditorInspector.get_edited_object
	return Object.Instance(Advanced(self).GetEditedObject())
}

/*
Creates a property editor that can be used by plugin UI to edit the specified property of an [param object].
*/
func InstantiatePropertyEditor(obj Object.Instance, atype variant.Type, path string, hint ClassDB.PropertyHint, hint_text string, usage int, wide bool) EditorProperty.Instance { //gd:EditorInspector.instantiate_property_editor
	self := Instance{}
	return EditorProperty.Instance(Advanced(self).InstantiatePropertyEditor(obj, atype, String.New(path), hint, String.New(hint_text), int64(usage), wide))
}

/*
Creates a property editor that can be used by plugin UI to edit the specified property of an [param object].
*/
func InstantiatePropertyEditorOptions(obj Object.Instance, atype variant.Type, path string, hint ClassDB.PropertyHint, hint_text string, usage int, wide bool) EditorProperty.Instance { //gd:EditorInspector.instantiate_property_editor
	self := Instance{}
	return EditorProperty.Instance(Advanced(self).InstantiatePropertyEditor(obj, atype, String.New(path), hint, String.New(hint_text), int64(usage), wide))
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.EditorInspector

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {
	object := gd.Global.ClassDB.ConstructObject(gd.NewStringName("EditorInspector"))
	casted := Instance{*(*gdclass.EditorInspector)(unsafe.Pointer(&object))}
	return casted
}

/*
Shows the properties of the given [param object] in this inspector for editing. To clear the inspector, call this method with [code]null[/code].
[b]Note:[/b] If you want to edit an object in the editor's main inspector, use the [code]edit_*[/code] methods in [EditorInterface] instead.
*/
//go:nosplit
func (self class) Edit(obj [1]gd.Object) { //gd:EditorInspector.edit
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.EditorInspector.Bind_edit, 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ obj gdextension.Object }{gdextension.Object(gd.ObjectChecked(obj[0].AsObject()))}))
}

/*
Gets the path of the currently selected property.
*/
//go:nosplit
func (self class) GetSelectedPath() String.Readable { //gd:EditorInspector.get_selected_path
	var r_ret = gdunsafe.Call[[1]gd.EnginePointer](self.AsObject(), gd.Global.Methods.EditorInspector.Bind_get_selected_path, gdextension.SizeString, unsafe.Pointer(&struct{}{}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Returns the object currently selected in this inspector.
*/
//go:nosplit
func (self class) GetEditedObject() [1]gd.Object { //gd:EditorInspector.get_edited_object
	var r_ret = gdunsafe.Call[gd.EnginePointer](self.AsObject(), gd.Global.Methods.EditorInspector.Bind_get_edited_object, gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gd.Object{gd.PointerMustAssertInstanceID[gd.Object](r_ret)}
	return ret
}

/*
Creates a property editor that can be used by plugin UI to edit the specified property of an [param object].
*/
//go:nosplit
func (self class) InstantiatePropertyEditor(obj [1]gd.Object, atype variant.Type, path String.Readable, hint ClassDB.PropertyHint, hint_text String.Readable, usage int64, wide bool) [1]gdclass.EditorProperty { //gd:EditorInspector.instantiate_property_editor
	var r_ret = gdunsafe.CallStatic[gd.EnginePointer](gd.Global.Methods.EditorInspector.Bind_instantiate_property_editor, gdextension.SizeObject|(gdextension.SizeObject<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeString<<12)|(gdextension.SizeInt<<16)|(gdextension.SizeString<<20)|(gdextension.SizeInt<<24)|(gdextension.SizeBool<<28), unsafe.Pointer(&struct {
		obj       gdextension.Object
		atype     variant.Type
		path      gdextension.String
		hint      ClassDB.PropertyHint
		hint_text gdextension.String
		usage     int64
		wide      bool
	}{gdextension.Object(gd.ObjectChecked(obj[0].AsObject())), atype, gdextension.String(pointers.Get(gd.InternalString(path))[0]), hint, gdextension.String(pointers.Get(gd.InternalString(hint_text))[0]), usage, wide}))
	var ret = [1]gdclass.EditorProperty{gd.PointerMustAssertInstanceID[gdclass.EditorProperty](r_ret)}
	return ret
}
func (self Instance) OnPropertySelected(cb func(property string)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("property_selected"), gd.NewCallable(cb), 0)
}

func (self Instance) OnPropertyKeyed(cb func(property string, value any, advance bool)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("property_keyed"), gd.NewCallable(cb), 0)
}

func (self Instance) OnPropertyDeleted(cb func(property string)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("property_deleted"), gd.NewCallable(cb), 0)
}

func (self Instance) OnResourceSelected(cb func(resource Resource.Instance, path string)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("resource_selected"), gd.NewCallable(cb), 0)
}

func (self Instance) OnObjectIdSelected(cb func(id int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("object_id_selected"), gd.NewCallable(cb), 0)
}

func (self Instance) OnPropertyEdited(cb func(property string)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("property_edited"), gd.NewCallable(cb), 0)
}

func (self Instance) OnPropertyToggled(cb func(property string, checked bool)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("property_toggled"), gd.NewCallable(cb), 0)
}

func (self Instance) OnEditedObjectChanged(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("edited_object_changed"), gd.NewCallable(cb), 0)
}

func (self Instance) OnRestartRequested(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("restart_requested"), gd.NewCallable(cb), 0)
}

func (self class) AsEditorInspector() Advanced         { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsEditorInspector() Instance      { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsEditorInspector() Instance { return self.Super().AsEditorInspector() }
func (self class) AsScrollContainer() ScrollContainer.Advanced {
	return *((*ScrollContainer.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsScrollContainer() ScrollContainer.Instance {
	return self.Super().AsScrollContainer()
}
func (self Instance) AsScrollContainer() ScrollContainer.Instance {
	return *((*ScrollContainer.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsContainer() Container.Advanced {
	return *((*Container.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsContainer() Container.Instance { return self.Super().AsContainer() }
func (self Instance) AsContainer() Container.Instance {
	return *((*Container.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsControl() Control.Advanced         { return *((*Control.Advanced)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsControl() Control.Instance { return self.Super().AsControl() }
func (self Instance) AsControl() Control.Instance {
	return *((*Control.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsCanvasItem() CanvasItem.Advanced {
	return *((*CanvasItem.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsCanvasItem() CanvasItem.Instance { return self.Super().AsCanvasItem() }
func (self Instance) AsCanvasItem() CanvasItem.Instance {
	return *((*CanvasItem.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsNode() Node.Advanced         { return *((*Node.Advanced)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsNode() Node.Instance { return self.Super().AsNode() }
func (self Instance) AsNode() Node.Instance      { return *((*Node.Instance)(unsafe.Pointer(&self))) }

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(ScrollContainer.Advanced(self.AsScrollContainer()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(ScrollContainer.Instance(self.AsScrollContainer()), name)
	}
}
func init() {
	gdclass.Register("EditorInspector", func(ptr gd.Object) any {
		return [1]gdclass.EditorInspector{*(*gdclass.EditorInspector)(unsafe.Pointer(&ptr))}
	})
}
