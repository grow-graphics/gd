// Code generated by the generate package DO NOT EDIT

// Package TileSet provides methods for working with TileSet object instances.
package TileSet

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/variant/Signal"
import "graphics.gd/classdb/PhysicsMaterial"
import "graphics.gd/classdb/Resource"
import "graphics.gd/classdb/TileMapPattern"
import "graphics.gd/classdb/TileSetSource"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Color"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"
import "graphics.gd/variant/Vector2i"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Signal.Any
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
A TileSet is a library of tiles for a [TileMapLayer]. A TileSet handles a list of [TileSetSource], each of them storing a set of tiles.
Tiles can either be from a [TileSetAtlasSource], which renders tiles out of a texture with support for physics, navigation, etc., or from a [TileSetScenesCollectionSource], which exposes scene-based tiles.
Tiles are referenced by using three IDs: their source ID, their atlas coordinates ID, and their alternative tile ID.
A TileSet can be configured so that its tiles expose more or fewer properties. To do so, the TileSet resources use property layers, which you can add or remove depending on your needs.
For example, adding a physics layer allows giving collision shapes to your tiles. Each layer has dedicated properties (physics layer and mask), so you may add several TileSet physics layers for each type of collision you need.
See the functions to add new layers for more information.
*/
type Instance [1]gdclass.TileSet

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	get_next_source_id                   gdextension.MethodForClass `hash:"3905245786"`
	add_source                           gdextension.MethodForClass `hash:"1059186179"`
	remove_source                        gdextension.MethodForClass `hash:"1286410249"`
	set_source_id                        gdextension.MethodForClass `hash:"3937882851"`
	get_source_count                     gdextension.MethodForClass `hash:"3905245786"`
	get_source_id                        gdextension.MethodForClass `hash:"923996154"`
	has_source                           gdextension.MethodForClass `hash:"1116898809"`
	get_source                           gdextension.MethodForClass `hash:"1763540252"`
	set_tile_shape                       gdextension.MethodForClass `hash:"2131427112"`
	get_tile_shape                       gdextension.MethodForClass `hash:"716918169"`
	set_tile_layout                      gdextension.MethodForClass `hash:"1071216679"`
	get_tile_layout                      gdextension.MethodForClass `hash:"194628839"`
	set_tile_offset_axis                 gdextension.MethodForClass `hash:"3300198521"`
	get_tile_offset_axis                 gdextension.MethodForClass `hash:"762494114"`
	set_tile_size                        gdextension.MethodForClass `hash:"1130785943"`
	get_tile_size                        gdextension.MethodForClass `hash:"3690982128"`
	set_uv_clipping                      gdextension.MethodForClass `hash:"2586408642"`
	is_uv_clipping                       gdextension.MethodForClass `hash:"36873697"`
	get_occlusion_layers_count           gdextension.MethodForClass `hash:"3905245786"`
	add_occlusion_layer                  gdextension.MethodForClass `hash:"1025054187"`
	move_occlusion_layer                 gdextension.MethodForClass `hash:"3937882851"`
	remove_occlusion_layer               gdextension.MethodForClass `hash:"1286410249"`
	set_occlusion_layer_light_mask       gdextension.MethodForClass `hash:"3937882851"`
	get_occlusion_layer_light_mask       gdextension.MethodForClass `hash:"923996154"`
	set_occlusion_layer_sdf_collision    gdextension.MethodForClass `hash:"300928843"`
	get_occlusion_layer_sdf_collision    gdextension.MethodForClass `hash:"1116898809"`
	get_physics_layers_count             gdextension.MethodForClass `hash:"3905245786"`
	add_physics_layer                    gdextension.MethodForClass `hash:"1025054187"`
	move_physics_layer                   gdextension.MethodForClass `hash:"3937882851"`
	remove_physics_layer                 gdextension.MethodForClass `hash:"1286410249"`
	set_physics_layer_collision_layer    gdextension.MethodForClass `hash:"3937882851"`
	get_physics_layer_collision_layer    gdextension.MethodForClass `hash:"923996154"`
	set_physics_layer_collision_mask     gdextension.MethodForClass `hash:"3937882851"`
	get_physics_layer_collision_mask     gdextension.MethodForClass `hash:"923996154"`
	set_physics_layer_collision_priority gdextension.MethodForClass `hash:"1602489585"`
	get_physics_layer_collision_priority gdextension.MethodForClass `hash:"2339986948"`
	set_physics_layer_physics_material   gdextension.MethodForClass `hash:"1018687357"`
	get_physics_layer_physics_material   gdextension.MethodForClass `hash:"788318639"`
	get_terrain_sets_count               gdextension.MethodForClass `hash:"3905245786"`
	add_terrain_set                      gdextension.MethodForClass `hash:"1025054187"`
	move_terrain_set                     gdextension.MethodForClass `hash:"3937882851"`
	remove_terrain_set                   gdextension.MethodForClass `hash:"1286410249"`
	set_terrain_set_mode                 gdextension.MethodForClass `hash:"3943003916"`
	get_terrain_set_mode                 gdextension.MethodForClass `hash:"2084469411"`
	get_terrains_count                   gdextension.MethodForClass `hash:"923996154"`
	add_terrain                          gdextension.MethodForClass `hash:"1230568737"`
	move_terrain                         gdextension.MethodForClass `hash:"1649997291"`
	remove_terrain                       gdextension.MethodForClass `hash:"3937882851"`
	set_terrain_name                     gdextension.MethodForClass `hash:"2285447957"`
	get_terrain_name                     gdextension.MethodForClass `hash:"1391810591"`
	set_terrain_color                    gdextension.MethodForClass `hash:"3733378741"`
	get_terrain_color                    gdextension.MethodForClass `hash:"2165839948"`
	get_navigation_layers_count          gdextension.MethodForClass `hash:"3905245786"`
	add_navigation_layer                 gdextension.MethodForClass `hash:"1025054187"`
	move_navigation_layer                gdextension.MethodForClass `hash:"3937882851"`
	remove_navigation_layer              gdextension.MethodForClass `hash:"1286410249"`
	set_navigation_layer_layers          gdextension.MethodForClass `hash:"3937882851"`
	get_navigation_layer_layers          gdextension.MethodForClass `hash:"923996154"`
	set_navigation_layer_layer_value     gdextension.MethodForClass `hash:"1383440665"`
	get_navigation_layer_layer_value     gdextension.MethodForClass `hash:"2522259332"`
	get_custom_data_layers_count         gdextension.MethodForClass `hash:"3905245786"`
	add_custom_data_layer                gdextension.MethodForClass `hash:"1025054187"`
	move_custom_data_layer               gdextension.MethodForClass `hash:"3937882851"`
	remove_custom_data_layer             gdextension.MethodForClass `hash:"1286410249"`
	get_custom_data_layer_by_name        gdextension.MethodForClass `hash:"1321353865"`
	set_custom_data_layer_name           gdextension.MethodForClass `hash:"501894301"`
	has_custom_data_layer_by_name        gdextension.MethodForClass `hash:"3927539163"`
	get_custom_data_layer_name           gdextension.MethodForClass `hash:"844755477"`
	set_custom_data_layer_type           gdextension.MethodForClass `hash:"3492912874"`
	get_custom_data_layer_type           gdextension.MethodForClass `hash:"2990820875"`
	set_source_level_tile_proxy          gdextension.MethodForClass `hash:"3937882851"`
	get_source_level_tile_proxy          gdextension.MethodForClass `hash:"3744713108"`
	has_source_level_tile_proxy          gdextension.MethodForClass `hash:"3067735520"`
	remove_source_level_tile_proxy       gdextension.MethodForClass `hash:"1286410249"`
	set_coords_level_tile_proxy          gdextension.MethodForClass `hash:"1769939278"`
	get_coords_level_tile_proxy          gdextension.MethodForClass `hash:"2856536371"`
	has_coords_level_tile_proxy          gdextension.MethodForClass `hash:"3957903770"`
	remove_coords_level_tile_proxy       gdextension.MethodForClass `hash:"2311374912"`
	set_alternative_level_tile_proxy     gdextension.MethodForClass `hash:"3862385460"`
	get_alternative_level_tile_proxy     gdextension.MethodForClass `hash:"2303761075"`
	has_alternative_level_tile_proxy     gdextension.MethodForClass `hash:"180086755"`
	remove_alternative_level_tile_proxy  gdextension.MethodForClass `hash:"2328951467"`
	map_tile_proxy                       gdextension.MethodForClass `hash:"4267935328"`
	cleanup_invalid_tile_proxies         gdextension.MethodForClass `hash:"3218959716"`
	clear_tile_proxies                   gdextension.MethodForClass `hash:"3218959716"`
	add_pattern                          gdextension.MethodForClass `hash:"763712015"`
	get_pattern                          gdextension.MethodForClass `hash:"4207737510"`
	remove_pattern                       gdextension.MethodForClass `hash:"1286410249"`
	get_patterns_count                   gdextension.MethodForClass `hash:"2455072627"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("TileSet")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		gdextension.Free(gdextension.TypeStringName, &sname)
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

type Expanded [1]gdclass.TileSet

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsTileSet() Instance
}

/*
Returns a new unused source ID. This generated ID is the same that a call to [method add_source] would return.
*/
func (self Instance) GetNextSourceId() int { //gd:TileSet.get_next_source_id
	return int(int(Advanced(self).GetNextSourceId()))
}

/*
Adds a [TileSetSource] to the TileSet. If [param atlas_source_id_override] is not -1, also set its source ID. Otherwise, a unique identifier is automatically generated.
The function returns the added source ID or -1 if the source could not be added.
[b]Warning:[/b] A source cannot belong to two TileSets at the same time. If the added source was attached to another [TileSet], it will be removed from that one.
*/
func (self Instance) AddSource(source TileSetSource.Instance) int { //gd:TileSet.add_source
	return int(int(Advanced(self).AddSource(source, int64(-1))))
}

/*
Adds a [TileSetSource] to the TileSet. If [param atlas_source_id_override] is not -1, also set its source ID. Otherwise, a unique identifier is automatically generated.
The function returns the added source ID or -1 if the source could not be added.
[b]Warning:[/b] A source cannot belong to two TileSets at the same time. If the added source was attached to another [TileSet], it will be removed from that one.
*/
func (self Expanded) AddSource(source TileSetSource.Instance, atlas_source_id_override int) int { //gd:TileSet.add_source
	return int(int(Advanced(self).AddSource(source, int64(atlas_source_id_override))))
}

/*
Removes the source with the given source ID.
*/
func (self Instance) RemoveSource(source_id int) { //gd:TileSet.remove_source
	Advanced(self).RemoveSource(int64(source_id))
}

/*
Changes a source's ID.
*/
func (self Instance) SetSourceId(source_id int, new_source_id int) { //gd:TileSet.set_source_id
	Advanced(self).SetSourceId(int64(source_id), int64(new_source_id))
}

/*
Returns the number of [TileSetSource] in this TileSet.
*/
func (self Instance) GetSourceCount() int { //gd:TileSet.get_source_count
	return int(int(Advanced(self).GetSourceCount()))
}

/*
Returns the source ID for source with index [param index].
*/
func (self Instance) GetSourceId(index int) int { //gd:TileSet.get_source_id
	return int(int(Advanced(self).GetSourceId(int64(index))))
}

/*
Returns if this TileSet has a source for the given source ID.
*/
func (self Instance) HasSource(source_id int) bool { //gd:TileSet.has_source
	return bool(Advanced(self).HasSource(int64(source_id)))
}

/*
Returns the [TileSetSource] with ID [param source_id].
*/
func (self Instance) GetSource(source_id int) TileSetSource.Instance { //gd:TileSet.get_source
	return TileSetSource.Instance(Advanced(self).GetSource(int64(source_id)))
}

/*
Returns the occlusion layers count.
*/
func (self Instance) GetOcclusionLayersCount() int { //gd:TileSet.get_occlusion_layers_count
	return int(int(Advanced(self).GetOcclusionLayersCount()))
}

/*
Adds an occlusion layer to the TileSet at the given position [param to_position] in the array. If [param to_position] is -1, adds it at the end of the array.
Occlusion layers allow assigning occlusion polygons to atlas tiles.
*/
func (self Instance) AddOcclusionLayer() { //gd:TileSet.add_occlusion_layer
	Advanced(self).AddOcclusionLayer(int64(-1))
}

/*
Adds an occlusion layer to the TileSet at the given position [param to_position] in the array. If [param to_position] is -1, adds it at the end of the array.
Occlusion layers allow assigning occlusion polygons to atlas tiles.
*/
func (self Expanded) AddOcclusionLayer(to_position int) { //gd:TileSet.add_occlusion_layer
	Advanced(self).AddOcclusionLayer(int64(to_position))
}

/*
Moves the occlusion layer at index [param layer_index] to the given position [param to_position] in the array. Also updates the atlas tiles accordingly.
*/
func (self Instance) MoveOcclusionLayer(layer_index int, to_position int) { //gd:TileSet.move_occlusion_layer
	Advanced(self).MoveOcclusionLayer(int64(layer_index), int64(to_position))
}

/*
Removes the occlusion layer at index [param layer_index]. Also updates the atlas tiles accordingly.
*/
func (self Instance) RemoveOcclusionLayer(layer_index int) { //gd:TileSet.remove_occlusion_layer
	Advanced(self).RemoveOcclusionLayer(int64(layer_index))
}

/*
Sets the occlusion layer (as in the rendering server) for occluders in the given TileSet occlusion layer.
*/
func (self Instance) SetOcclusionLayerLightMask(layer_index int, light_mask int) { //gd:TileSet.set_occlusion_layer_light_mask
	Advanced(self).SetOcclusionLayerLightMask(int64(layer_index), int64(light_mask))
}

/*
Returns the light mask of the occlusion layer.
*/
func (self Instance) GetOcclusionLayerLightMask(layer_index int) int { //gd:TileSet.get_occlusion_layer_light_mask
	return int(int(Advanced(self).GetOcclusionLayerLightMask(int64(layer_index))))
}

/*
Enables or disables SDF collision for occluders in the given TileSet occlusion layer.
*/
func (self Instance) SetOcclusionLayerSdfCollision(layer_index int, sdf_collision bool) { //gd:TileSet.set_occlusion_layer_sdf_collision
	Advanced(self).SetOcclusionLayerSdfCollision(int64(layer_index), sdf_collision)
}

/*
Returns if the occluders from this layer use [code]sdf_collision[/code].
*/
func (self Instance) GetOcclusionLayerSdfCollision(layer_index int) bool { //gd:TileSet.get_occlusion_layer_sdf_collision
	return bool(Advanced(self).GetOcclusionLayerSdfCollision(int64(layer_index)))
}

/*
Returns the physics layers count.
*/
func (self Instance) GetPhysicsLayersCount() int { //gd:TileSet.get_physics_layers_count
	return int(int(Advanced(self).GetPhysicsLayersCount()))
}

/*
Adds a physics layer to the TileSet at the given position [param to_position] in the array. If [param to_position] is -1, adds it at the end of the array.
Physics layers allow assigning collision polygons to atlas tiles.
*/
func (self Instance) AddPhysicsLayer() { //gd:TileSet.add_physics_layer
	Advanced(self).AddPhysicsLayer(int64(-1))
}

/*
Adds a physics layer to the TileSet at the given position [param to_position] in the array. If [param to_position] is -1, adds it at the end of the array.
Physics layers allow assigning collision polygons to atlas tiles.
*/
func (self Expanded) AddPhysicsLayer(to_position int) { //gd:TileSet.add_physics_layer
	Advanced(self).AddPhysicsLayer(int64(to_position))
}

/*
Moves the physics layer at index [param layer_index] to the given position [param to_position] in the array. Also updates the atlas tiles accordingly.
*/
func (self Instance) MovePhysicsLayer(layer_index int, to_position int) { //gd:TileSet.move_physics_layer
	Advanced(self).MovePhysicsLayer(int64(layer_index), int64(to_position))
}

/*
Removes the physics layer at index [param layer_index]. Also updates the atlas tiles accordingly.
*/
func (self Instance) RemovePhysicsLayer(layer_index int) { //gd:TileSet.remove_physics_layer
	Advanced(self).RemovePhysicsLayer(int64(layer_index))
}

/*
Sets the collision layer (as in the physics server) for bodies in the given TileSet physics layer.
*/
func (self Instance) SetPhysicsLayerCollisionLayer(layer_index int, layer int) { //gd:TileSet.set_physics_layer_collision_layer
	Advanced(self).SetPhysicsLayerCollisionLayer(int64(layer_index), int64(layer))
}

/*
Returns the collision layer (as in the physics server) bodies on the given TileSet's physics layer are in.
*/
func (self Instance) GetPhysicsLayerCollisionLayer(layer_index int) int { //gd:TileSet.get_physics_layer_collision_layer
	return int(int(Advanced(self).GetPhysicsLayerCollisionLayer(int64(layer_index))))
}

/*
Sets the collision mask for bodies in the given TileSet physics layer.
*/
func (self Instance) SetPhysicsLayerCollisionMask(layer_index int, mask int) { //gd:TileSet.set_physics_layer_collision_mask
	Advanced(self).SetPhysicsLayerCollisionMask(int64(layer_index), int64(mask))
}

/*
Returns the collision mask of bodies on the given TileSet's physics layer.
*/
func (self Instance) GetPhysicsLayerCollisionMask(layer_index int) int { //gd:TileSet.get_physics_layer_collision_mask
	return int(int(Advanced(self).GetPhysicsLayerCollisionMask(int64(layer_index))))
}

/*
Sets the collision priority for bodies in the given TileSet physics layer.
*/
func (self Instance) SetPhysicsLayerCollisionPriority(layer_index int, priority Float.X) { //gd:TileSet.set_physics_layer_collision_priority
	Advanced(self).SetPhysicsLayerCollisionPriority(int64(layer_index), float64(priority))
}

/*
Returns the collision priority of bodies on the given TileSet's physics layer.
*/
func (self Instance) GetPhysicsLayerCollisionPriority(layer_index int) Float.X { //gd:TileSet.get_physics_layer_collision_priority
	return Float.X(Float.X(Advanced(self).GetPhysicsLayerCollisionPriority(int64(layer_index))))
}

/*
Sets the physics material for bodies in the given TileSet physics layer.
*/
func (self Instance) SetPhysicsLayerPhysicsMaterial(layer_index int, physics_material PhysicsMaterial.Instance) { //gd:TileSet.set_physics_layer_physics_material
	Advanced(self).SetPhysicsLayerPhysicsMaterial(int64(layer_index), physics_material)
}

/*
Returns the physics material of bodies on the given TileSet's physics layer.
*/
func (self Instance) GetPhysicsLayerPhysicsMaterial(layer_index int) PhysicsMaterial.Instance { //gd:TileSet.get_physics_layer_physics_material
	return PhysicsMaterial.Instance(Advanced(self).GetPhysicsLayerPhysicsMaterial(int64(layer_index)))
}

/*
Returns the terrain sets count.
*/
func (self Instance) GetTerrainSetsCount() int { //gd:TileSet.get_terrain_sets_count
	return int(int(Advanced(self).GetTerrainSetsCount()))
}

/*
Adds a new terrain set at the given position [param to_position] in the array. If [param to_position] is -1, adds it at the end of the array.
*/
func (self Instance) AddTerrainSet() { //gd:TileSet.add_terrain_set
	Advanced(self).AddTerrainSet(int64(-1))
}

/*
Adds a new terrain set at the given position [param to_position] in the array. If [param to_position] is -1, adds it at the end of the array.
*/
func (self Expanded) AddTerrainSet(to_position int) { //gd:TileSet.add_terrain_set
	Advanced(self).AddTerrainSet(int64(to_position))
}

/*
Moves the terrain set at index [param terrain_set] to the given position [param to_position] in the array. Also updates the atlas tiles accordingly.
*/
func (self Instance) MoveTerrainSet(terrain_set int, to_position int) { //gd:TileSet.move_terrain_set
	Advanced(self).MoveTerrainSet(int64(terrain_set), int64(to_position))
}

/*
Removes the terrain set at index [param terrain_set]. Also updates the atlas tiles accordingly.
*/
func (self Instance) RemoveTerrainSet(terrain_set int) { //gd:TileSet.remove_terrain_set
	Advanced(self).RemoveTerrainSet(int64(terrain_set))
}

/*
Sets a terrain mode. Each mode determines which bits of a tile shape is used to match the neighboring tiles' terrains.
*/
func (self Instance) SetTerrainSetMode(terrain_set int, mode TerrainMode) { //gd:TileSet.set_terrain_set_mode
	Advanced(self).SetTerrainSetMode(int64(terrain_set), mode)
}

/*
Returns a terrain set mode.
*/
func (self Instance) GetTerrainSetMode(terrain_set int) TerrainMode { //gd:TileSet.get_terrain_set_mode
	return TerrainMode(Advanced(self).GetTerrainSetMode(int64(terrain_set)))
}

/*
Returns the number of terrains in the given terrain set.
*/
func (self Instance) GetTerrainsCount(terrain_set int) int { //gd:TileSet.get_terrains_count
	return int(int(Advanced(self).GetTerrainsCount(int64(terrain_set))))
}

/*
Adds a new terrain to the given terrain set [param terrain_set] at the given position [param to_position] in the array. If [param to_position] is -1, adds it at the end of the array.
*/
func (self Instance) AddTerrain(terrain_set int) { //gd:TileSet.add_terrain
	Advanced(self).AddTerrain(int64(terrain_set), int64(-1))
}

/*
Adds a new terrain to the given terrain set [param terrain_set] at the given position [param to_position] in the array. If [param to_position] is -1, adds it at the end of the array.
*/
func (self Expanded) AddTerrain(terrain_set int, to_position int) { //gd:TileSet.add_terrain
	Advanced(self).AddTerrain(int64(terrain_set), int64(to_position))
}

/*
Moves the terrain at index [param terrain_index] for terrain set [param terrain_set] to the given position [param to_position] in the array. Also updates the atlas tiles accordingly.
*/
func (self Instance) MoveTerrain(terrain_set int, terrain_index int, to_position int) { //gd:TileSet.move_terrain
	Advanced(self).MoveTerrain(int64(terrain_set), int64(terrain_index), int64(to_position))
}

/*
Removes the terrain at index [param terrain_index] in the given terrain set [param terrain_set]. Also updates the atlas tiles accordingly.
*/
func (self Instance) RemoveTerrain(terrain_set int, terrain_index int) { //gd:TileSet.remove_terrain
	Advanced(self).RemoveTerrain(int64(terrain_set), int64(terrain_index))
}

/*
Sets a terrain's name.
*/
func (self Instance) SetTerrainName(terrain_set int, terrain_index int, name string) { //gd:TileSet.set_terrain_name
	Advanced(self).SetTerrainName(int64(terrain_set), int64(terrain_index), String.New(name))
}

/*
Returns a terrain's name.
*/
func (self Instance) GetTerrainName(terrain_set int, terrain_index int) string { //gd:TileSet.get_terrain_name
	return string(Advanced(self).GetTerrainName(int64(terrain_set), int64(terrain_index)).String())
}

/*
Sets a terrain's color. This color is used for identifying the different terrains in the TileSet editor.
*/
func (self Instance) SetTerrainColor(terrain_set int, terrain_index int, color Color.RGBA) { //gd:TileSet.set_terrain_color
	Advanced(self).SetTerrainColor(int64(terrain_set), int64(terrain_index), Color.RGBA(color))
}

/*
Returns a terrain's color.
*/
func (self Instance) GetTerrainColor(terrain_set int, terrain_index int) Color.RGBA { //gd:TileSet.get_terrain_color
	return Color.RGBA(Advanced(self).GetTerrainColor(int64(terrain_set), int64(terrain_index)))
}

/*
Returns the navigation layers count.
*/
func (self Instance) GetNavigationLayersCount() int { //gd:TileSet.get_navigation_layers_count
	return int(int(Advanced(self).GetNavigationLayersCount()))
}

/*
Adds a navigation layer to the TileSet at the given position [param to_position] in the array. If [param to_position] is -1, adds it at the end of the array.
Navigation layers allow assigning a navigable area to atlas tiles.
*/
func (self Instance) AddNavigationLayer() { //gd:TileSet.add_navigation_layer
	Advanced(self).AddNavigationLayer(int64(-1))
}

/*
Adds a navigation layer to the TileSet at the given position [param to_position] in the array. If [param to_position] is -1, adds it at the end of the array.
Navigation layers allow assigning a navigable area to atlas tiles.
*/
func (self Expanded) AddNavigationLayer(to_position int) { //gd:TileSet.add_navigation_layer
	Advanced(self).AddNavigationLayer(int64(to_position))
}

/*
Moves the navigation layer at index [param layer_index] to the given position [param to_position] in the array. Also updates the atlas tiles accordingly.
*/
func (self Instance) MoveNavigationLayer(layer_index int, to_position int) { //gd:TileSet.move_navigation_layer
	Advanced(self).MoveNavigationLayer(int64(layer_index), int64(to_position))
}

/*
Removes the navigation layer at index [param layer_index]. Also updates the atlas tiles accordingly.
*/
func (self Instance) RemoveNavigationLayer(layer_index int) { //gd:TileSet.remove_navigation_layer
	Advanced(self).RemoveNavigationLayer(int64(layer_index))
}

/*
Sets the navigation layers (as in the navigation server) for navigation regions in the given TileSet navigation layer.
*/
func (self Instance) SetNavigationLayerLayers(layer_index int, layers int) { //gd:TileSet.set_navigation_layer_layers
	Advanced(self).SetNavigationLayerLayers(int64(layer_index), int64(layers))
}

/*
Returns the navigation layers (as in the Navigation server) of the given TileSet navigation layer.
*/
func (self Instance) GetNavigationLayerLayers(layer_index int) int { //gd:TileSet.get_navigation_layer_layers
	return int(int(Advanced(self).GetNavigationLayerLayers(int64(layer_index))))
}

/*
Based on [param value], enables or disables the specified navigation layer of the TileSet navigation data layer identified by the given [param layer_index], given a navigation_layers [param layer_number] between 1 and 32.
*/
func (self Instance) SetNavigationLayerLayerValue(layer_index int, layer_number int, value bool) { //gd:TileSet.set_navigation_layer_layer_value
	Advanced(self).SetNavigationLayerLayerValue(int64(layer_index), int64(layer_number), value)
}

/*
Returns whether or not the specified navigation layer of the TileSet navigation data layer identified by the given [param layer_index] is enabled, given a navigation_layers [param layer_number] between 1 and 32.
*/
func (self Instance) GetNavigationLayerLayerValue(layer_index int, layer_number int) bool { //gd:TileSet.get_navigation_layer_layer_value
	return bool(Advanced(self).GetNavigationLayerLayerValue(int64(layer_index), int64(layer_number)))
}

/*
Returns the custom data layers count.
*/
func (self Instance) GetCustomDataLayersCount() int { //gd:TileSet.get_custom_data_layers_count
	return int(int(Advanced(self).GetCustomDataLayersCount()))
}

/*
Adds a custom data layer to the TileSet at the given position [param to_position] in the array. If [param to_position] is -1, adds it at the end of the array.
Custom data layers allow assigning custom properties to atlas tiles.
*/
func (self Instance) AddCustomDataLayer() { //gd:TileSet.add_custom_data_layer
	Advanced(self).AddCustomDataLayer(int64(-1))
}

/*
Adds a custom data layer to the TileSet at the given position [param to_position] in the array. If [param to_position] is -1, adds it at the end of the array.
Custom data layers allow assigning custom properties to atlas tiles.
*/
func (self Expanded) AddCustomDataLayer(to_position int) { //gd:TileSet.add_custom_data_layer
	Advanced(self).AddCustomDataLayer(int64(to_position))
}

/*
Moves the custom data layer at index [param layer_index] to the given position [param to_position] in the array. Also updates the atlas tiles accordingly.
*/
func (self Instance) MoveCustomDataLayer(layer_index int, to_position int) { //gd:TileSet.move_custom_data_layer
	Advanced(self).MoveCustomDataLayer(int64(layer_index), int64(to_position))
}

/*
Removes the custom data layer at index [param layer_index]. Also updates the atlas tiles accordingly.
*/
func (self Instance) RemoveCustomDataLayer(layer_index int) { //gd:TileSet.remove_custom_data_layer
	Advanced(self).RemoveCustomDataLayer(int64(layer_index))
}

/*
Returns the index of the custom data layer identified by the given name.
*/
func (self Instance) GetCustomDataLayerByName(layer_name string) int { //gd:TileSet.get_custom_data_layer_by_name
	return int(int(Advanced(self).GetCustomDataLayerByName(String.New(layer_name))))
}

/*
Sets the name of the custom data layer identified by the given index. Names are identifiers of the layer therefore if the name is already taken it will fail and raise an error.
*/
func (self Instance) SetCustomDataLayerName(layer_index int, layer_name string) { //gd:TileSet.set_custom_data_layer_name
	Advanced(self).SetCustomDataLayerName(int64(layer_index), String.New(layer_name))
}

/*
Returns if there is a custom data layer named [param layer_name].
*/
func (self Instance) HasCustomDataLayerByName(layer_name string) bool { //gd:TileSet.has_custom_data_layer_by_name
	return bool(Advanced(self).HasCustomDataLayerByName(String.New(layer_name)))
}

/*
Returns the name of the custom data layer identified by the given index.
*/
func (self Instance) GetCustomDataLayerName(layer_index int) string { //gd:TileSet.get_custom_data_layer_name
	return string(Advanced(self).GetCustomDataLayerName(int64(layer_index)).String())
}

/*
Sets the type of the custom data layer identified by the given index.
*/
func (self Instance) SetCustomDataLayerType(layer_index int, layer_type variant.Type) { //gd:TileSet.set_custom_data_layer_type
	Advanced(self).SetCustomDataLayerType(int64(layer_index), layer_type)
}

/*
Returns the type of the custom data layer identified by the given index.
*/
func (self Instance) GetCustomDataLayerType(layer_index int) variant.Type { //gd:TileSet.get_custom_data_layer_type
	return variant.Type(Advanced(self).GetCustomDataLayerType(int64(layer_index)))
}

/*
Creates a source-level proxy for the given source ID. A proxy will map set of tile identifiers to another set of identifiers. Both the atlas coordinates ID and the alternative tile ID are kept the same when using source-level proxies.
This can be used to replace a source in all TileMaps using this TileSet, as TileMap nodes will find and use the proxy's target source when one is available.
Proxied tiles can be automatically replaced in TileMap nodes using the editor.
*/
func (self Instance) SetSourceLevelTileProxy(source_from int, source_to int) { //gd:TileSet.set_source_level_tile_proxy
	Advanced(self).SetSourceLevelTileProxy(int64(source_from), int64(source_to))
}

/*
Returns the source-level proxy for the given source identifier.
If the TileSet has no proxy for the given identifier, returns -1.
*/
func (self Instance) GetSourceLevelTileProxy(source_from int) int { //gd:TileSet.get_source_level_tile_proxy
	return int(int(Advanced(self).GetSourceLevelTileProxy(int64(source_from))))
}

/*
Returns if there is a source-level proxy for the given source ID.
*/
func (self Instance) HasSourceLevelTileProxy(source_from int) bool { //gd:TileSet.has_source_level_tile_proxy
	return bool(Advanced(self).HasSourceLevelTileProxy(int64(source_from)))
}

/*
Removes a source-level tile proxy.
*/
func (self Instance) RemoveSourceLevelTileProxy(source_from int) { //gd:TileSet.remove_source_level_tile_proxy
	Advanced(self).RemoveSourceLevelTileProxy(int64(source_from))
}

/*
Creates a coordinates-level proxy for the given identifiers. A proxy will map set of tile identifiers to another set of identifiers. The alternative tile ID is kept the same when using coordinates-level proxies.
This can be used to replace a tile in all TileMaps using this TileSet, as TileMap nodes will find and use the proxy's target tile when one is available.
Proxied tiles can be automatically replaced in TileMap nodes using the editor.
*/
func (self Instance) SetCoordsLevelTileProxy(p_source_from int, coords_from Vector2i.XY, source_to int, coords_to Vector2i.XY) { //gd:TileSet.set_coords_level_tile_proxy
	Advanced(self).SetCoordsLevelTileProxy(int64(p_source_from), Vector2i.XY(coords_from), int64(source_to), Vector2i.XY(coords_to))
}

/*
Returns the coordinate-level proxy for the given identifiers. The returned array contains the two target identifiers of the proxy (source ID and atlas coordinates ID).
If the TileSet has no proxy for the given identifiers, returns an empty Array.
*/
func (self Instance) GetCoordsLevelTileProxy(source_from int, coords_from Vector2i.XY) []any { //gd:TileSet.get_coords_level_tile_proxy
	return []any(gd.ArrayAs[[]any](gd.InternalArray(Advanced(self).GetCoordsLevelTileProxy(int64(source_from), Vector2i.XY(coords_from)))))
}

/*
Returns if there is a coodinates-level proxy for the given identifiers.
*/
func (self Instance) HasCoordsLevelTileProxy(source_from int, coords_from Vector2i.XY) bool { //gd:TileSet.has_coords_level_tile_proxy
	return bool(Advanced(self).HasCoordsLevelTileProxy(int64(source_from), Vector2i.XY(coords_from)))
}

/*
Removes a coordinates-level proxy for the given identifiers.
*/
func (self Instance) RemoveCoordsLevelTileProxy(source_from int, coords_from Vector2i.XY) { //gd:TileSet.remove_coords_level_tile_proxy
	Advanced(self).RemoveCoordsLevelTileProxy(int64(source_from), Vector2i.XY(coords_from))
}

/*
Create an alternative-level proxy for the given identifiers. A proxy will map set of tile identifiers to another set of identifiers.
This can be used to replace a tile in all TileMaps using this TileSet, as TileMap nodes will find and use the proxy's target tile when one is available.
Proxied tiles can be automatically replaced in TileMap nodes using the editor.
*/
func (self Instance) SetAlternativeLevelTileProxy(source_from int, coords_from Vector2i.XY, alternative_from int, source_to int, coords_to Vector2i.XY, alternative_to int) { //gd:TileSet.set_alternative_level_tile_proxy
	Advanced(self).SetAlternativeLevelTileProxy(int64(source_from), Vector2i.XY(coords_from), int64(alternative_from), int64(source_to), Vector2i.XY(coords_to), int64(alternative_to))
}

/*
Returns the alternative-level proxy for the given identifiers. The returned array contains the three proxie's target identifiers (source ID, atlas coords ID and alternative tile ID).
If the TileSet has no proxy for the given identifiers, returns an empty Array.
*/
func (self Instance) GetAlternativeLevelTileProxy(source_from int, coords_from Vector2i.XY, alternative_from int) []any { //gd:TileSet.get_alternative_level_tile_proxy
	return []any(gd.ArrayAs[[]any](gd.InternalArray(Advanced(self).GetAlternativeLevelTileProxy(int64(source_from), Vector2i.XY(coords_from), int64(alternative_from)))))
}

/*
Returns if there is an alternative-level proxy for the given identifiers.
*/
func (self Instance) HasAlternativeLevelTileProxy(source_from int, coords_from Vector2i.XY, alternative_from int) bool { //gd:TileSet.has_alternative_level_tile_proxy
	return bool(Advanced(self).HasAlternativeLevelTileProxy(int64(source_from), Vector2i.XY(coords_from), int64(alternative_from)))
}

/*
Removes an alternative-level proxy for the given identifiers.
*/
func (self Instance) RemoveAlternativeLevelTileProxy(source_from int, coords_from Vector2i.XY, alternative_from int) { //gd:TileSet.remove_alternative_level_tile_proxy
	Advanced(self).RemoveAlternativeLevelTileProxy(int64(source_from), Vector2i.XY(coords_from), int64(alternative_from))
}

/*
According to the configured proxies, maps the provided identifiers to a new set of identifiers. The source ID, atlas coordinates ID and alternative tile ID are returned as a 3 elements Array.
This function first look for matching alternative-level proxies, then coordinates-level proxies, then source-level proxies.
If no proxy corresponding to provided identifiers are found, returns the same values the ones used as arguments.
*/
func (self Instance) MapTileProxy(source_from int, coords_from Vector2i.XY, alternative_from int) []any { //gd:TileSet.map_tile_proxy
	return []any(gd.ArrayAs[[]any](gd.InternalArray(Advanced(self).MapTileProxy(int64(source_from), Vector2i.XY(coords_from), int64(alternative_from)))))
}

/*
Clears tile proxies pointing to invalid tiles.
*/
func (self Instance) CleanupInvalidTileProxies() { //gd:TileSet.cleanup_invalid_tile_proxies
	Advanced(self).CleanupInvalidTileProxies()
}

/*
Clears all tile proxies.
*/
func (self Instance) ClearTileProxies() { //gd:TileSet.clear_tile_proxies
	Advanced(self).ClearTileProxies()
}

/*
Adds a [TileMapPattern] to be stored in the TileSet resource. If provided, insert it at the given [param index].
*/
func (self Instance) AddPattern(pattern TileMapPattern.Instance) int { //gd:TileSet.add_pattern
	return int(int(Advanced(self).AddPattern(pattern, int64(-1))))
}

/*
Adds a [TileMapPattern] to be stored in the TileSet resource. If provided, insert it at the given [param index].
*/
func (self Expanded) AddPattern(pattern TileMapPattern.Instance, index int) int { //gd:TileSet.add_pattern
	return int(int(Advanced(self).AddPattern(pattern, int64(index))))
}

/*
Returns the [TileMapPattern] at the given [param index].
*/
func (self Instance) GetPattern() TileMapPattern.Instance { //gd:TileSet.get_pattern
	return TileMapPattern.Instance(Advanced(self).GetPattern(int64(-1)))
}

/*
Returns the [TileMapPattern] at the given [param index].
*/
func (self Expanded) GetPattern(index int) TileMapPattern.Instance { //gd:TileSet.get_pattern
	return TileMapPattern.Instance(Advanced(self).GetPattern(int64(index)))
}

/*
Remove the [TileMapPattern] at the given index.
*/
func (self Instance) RemovePattern(index int) { //gd:TileSet.remove_pattern
	Advanced(self).RemovePattern(int64(index))
}

/*
Returns the number of [TileMapPattern] this tile set handles.
*/
func (self Instance) GetPatternsCount() int { //gd:TileSet.get_patterns_count
	return int(int(Advanced(self).GetPatternsCount()))
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.TileSet

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.TileSet)(unsafe.Pointer(&obj))
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.TileSet)(unsafe.Pointer(&obj))
		return true
	}
	return false
}

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {

	if !gd.Linked {
		var placeholder Instance
		*(*gd.Object)(unsafe.Pointer(&placeholder)) = pointers.Add[gd.Object]([3]uint64{})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(*(*gd.Object)(unsafe.Pointer(&placeholder)), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	object := [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})}
	casted := Instance{*(*gdclass.TileSet)(unsafe.Pointer(&object))}
	casted.AsRefCounted()[0].InitRef()
	object[0].Notification(0, false)
	return casted
}

func (self Instance) TileShape() TileShape {
	return TileShape(class(self).GetTileShape())
}

func (self Instance) SetTileShape(value TileShape) {
	class(self).SetTileShape(value)
}

func (self Instance) TileLayout() TileLayout {
	return TileLayout(class(self).GetTileLayout())
}

func (self Instance) SetTileLayout(value TileLayout) {
	class(self).SetTileLayout(value)
}

func (self Instance) TileOffsetAxis() TileOffsetAxis {
	return TileOffsetAxis(class(self).GetTileOffsetAxis())
}

func (self Instance) SetTileOffsetAxis(value TileOffsetAxis) {
	class(self).SetTileOffsetAxis(value)
}

func (self Instance) TileSize() Vector2i.XY {
	return Vector2i.XY(class(self).GetTileSize())
}

func (self Instance) SetTileSize(value Vector2i.XY) {
	class(self).SetTileSize(Vector2i.XY(value))
}

func (self Instance) UvClipping() bool {
	return bool(class(self).IsUvClipping())
}

func (self Instance) SetUvClipping(value bool) {
	class(self).SetUvClipping(value)
}

/*
Returns a new unused source ID. This generated ID is the same that a call to [method add_source] would return.
*/
//go:nosplit
func (self class) GetNextSourceId() int64 { //gd:TileSet.get_next_source_id
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_next_source_id, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Adds a [TileSetSource] to the TileSet. If [param atlas_source_id_override] is not -1, also set its source ID. Otherwise, a unique identifier is automatically generated.
The function returns the added source ID or -1 if the source could not be added.
[b]Warning:[/b] A source cannot belong to two TileSets at the same time. If the added source was attached to another [TileSet], it will be removed from that one.
*/
//go:nosplit
func (self class) AddSource(source [1]gdclass.TileSetSource, atlas_source_id_override int64) int64 { //gd:TileSet.add_source
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.add_source, gdextension.SizeInt|(gdextension.SizeObject<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		source                   gdextension.Object
		atlas_source_id_override int64
	}{gdextension.Object(gd.ObjectChecked(source[0].AsObject())), atlas_source_id_override}))
	var ret = r_ret
	return ret
}

/*
Removes the source with the given source ID.
*/
//go:nosplit
func (self class) RemoveSource(source_id int64) { //gd:TileSet.remove_source
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.remove_source, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ source_id int64 }{source_id}))
}

/*
Changes a source's ID.
*/
//go:nosplit
func (self class) SetSourceId(source_id int64, new_source_id int64) { //gd:TileSet.set_source_id
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_source_id, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		source_id     int64
		new_source_id int64
	}{source_id, new_source_id}))
}

/*
Returns the number of [TileSetSource] in this TileSet.
*/
//go:nosplit
func (self class) GetSourceCount() int64 { //gd:TileSet.get_source_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_source_count, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the source ID for source with index [param index].
*/
//go:nosplit
func (self class) GetSourceId(index int64) int64 { //gd:TileSet.get_source_id
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_source_id, gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ index int64 }{index}))
	var ret = r_ret
	return ret
}

/*
Returns if this TileSet has a source for the given source ID.
*/
//go:nosplit
func (self class) HasSource(source_id int64) bool { //gd:TileSet.has_source
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.has_source, gdextension.SizeBool|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ source_id int64 }{source_id}))
	var ret = r_ret
	return ret
}

/*
Returns the [TileSetSource] with ID [param source_id].
*/
//go:nosplit
func (self class) GetSource(source_id int64) [1]gdclass.TileSetSource { //gd:TileSet.get_source
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_source, gdextension.SizeObject|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ source_id int64 }{source_id}))
	var ret = [1]gdclass.TileSetSource{gd.PointerWithOwnershipTransferredToGo[gdclass.TileSetSource](r_ret)}
	return ret
}

//go:nosplit
func (self class) SetTileShape(shape TileShape) { //gd:TileSet.set_tile_shape
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_tile_shape, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ shape TileShape }{shape}))
}

//go:nosplit
func (self class) GetTileShape() TileShape { //gd:TileSet.get_tile_shape
	var r_ret = gdextension.Call[TileShape](gd.ObjectChecked(self.AsObject()), methods.get_tile_shape, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetTileLayout(layout TileLayout) { //gd:TileSet.set_tile_layout
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_tile_layout, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ layout TileLayout }{layout}))
}

//go:nosplit
func (self class) GetTileLayout() TileLayout { //gd:TileSet.get_tile_layout
	var r_ret = gdextension.Call[TileLayout](gd.ObjectChecked(self.AsObject()), methods.get_tile_layout, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetTileOffsetAxis(alignment TileOffsetAxis) { //gd:TileSet.set_tile_offset_axis
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_tile_offset_axis, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ alignment TileOffsetAxis }{alignment}))
}

//go:nosplit
func (self class) GetTileOffsetAxis() TileOffsetAxis { //gd:TileSet.get_tile_offset_axis
	var r_ret = gdextension.Call[TileOffsetAxis](gd.ObjectChecked(self.AsObject()), methods.get_tile_offset_axis, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetTileSize(size Vector2i.XY) { //gd:TileSet.set_tile_size
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_tile_size, 0|(gdextension.SizeVector2i<<4), unsafe.Pointer(&struct{ size Vector2i.XY }{size}))
}

//go:nosplit
func (self class) GetTileSize() Vector2i.XY { //gd:TileSet.get_tile_size
	var r_ret = gdextension.Call[Vector2i.XY](gd.ObjectChecked(self.AsObject()), methods.get_tile_size, gdextension.SizeVector2i, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetUvClipping(uv_clipping bool) { //gd:TileSet.set_uv_clipping
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_uv_clipping, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ uv_clipping bool }{uv_clipping}))
}

//go:nosplit
func (self class) IsUvClipping() bool { //gd:TileSet.is_uv_clipping
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_uv_clipping, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the occlusion layers count.
*/
//go:nosplit
func (self class) GetOcclusionLayersCount() int64 { //gd:TileSet.get_occlusion_layers_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_occlusion_layers_count, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Adds an occlusion layer to the TileSet at the given position [param to_position] in the array. If [param to_position] is -1, adds it at the end of the array.
Occlusion layers allow assigning occlusion polygons to atlas tiles.
*/
//go:nosplit
func (self class) AddOcclusionLayer(to_position int64) { //gd:TileSet.add_occlusion_layer
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_occlusion_layer, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ to_position int64 }{to_position}))
}

/*
Moves the occlusion layer at index [param layer_index] to the given position [param to_position] in the array. Also updates the atlas tiles accordingly.
*/
//go:nosplit
func (self class) MoveOcclusionLayer(layer_index int64, to_position int64) { //gd:TileSet.move_occlusion_layer
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.move_occlusion_layer, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		layer_index int64
		to_position int64
	}{layer_index, to_position}))
}

/*
Removes the occlusion layer at index [param layer_index]. Also updates the atlas tiles accordingly.
*/
//go:nosplit
func (self class) RemoveOcclusionLayer(layer_index int64) { //gd:TileSet.remove_occlusion_layer
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.remove_occlusion_layer, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ layer_index int64 }{layer_index}))
}

/*
Sets the occlusion layer (as in the rendering server) for occluders in the given TileSet occlusion layer.
*/
//go:nosplit
func (self class) SetOcclusionLayerLightMask(layer_index int64, light_mask int64) { //gd:TileSet.set_occlusion_layer_light_mask
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_occlusion_layer_light_mask, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		layer_index int64
		light_mask  int64
	}{layer_index, light_mask}))
}

/*
Returns the light mask of the occlusion layer.
*/
//go:nosplit
func (self class) GetOcclusionLayerLightMask(layer_index int64) int64 { //gd:TileSet.get_occlusion_layer_light_mask
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_occlusion_layer_light_mask, gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ layer_index int64 }{layer_index}))
	var ret = r_ret
	return ret
}

/*
Enables or disables SDF collision for occluders in the given TileSet occlusion layer.
*/
//go:nosplit
func (self class) SetOcclusionLayerSdfCollision(layer_index int64, sdf_collision bool) { //gd:TileSet.set_occlusion_layer_sdf_collision
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_occlusion_layer_sdf_collision, 0|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		layer_index   int64
		sdf_collision bool
	}{layer_index, sdf_collision}))
}

/*
Returns if the occluders from this layer use [code]sdf_collision[/code].
*/
//go:nosplit
func (self class) GetOcclusionLayerSdfCollision(layer_index int64) bool { //gd:TileSet.get_occlusion_layer_sdf_collision
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.get_occlusion_layer_sdf_collision, gdextension.SizeBool|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ layer_index int64 }{layer_index}))
	var ret = r_ret
	return ret
}

/*
Returns the physics layers count.
*/
//go:nosplit
func (self class) GetPhysicsLayersCount() int64 { //gd:TileSet.get_physics_layers_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_physics_layers_count, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Adds a physics layer to the TileSet at the given position [param to_position] in the array. If [param to_position] is -1, adds it at the end of the array.
Physics layers allow assigning collision polygons to atlas tiles.
*/
//go:nosplit
func (self class) AddPhysicsLayer(to_position int64) { //gd:TileSet.add_physics_layer
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_physics_layer, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ to_position int64 }{to_position}))
}

/*
Moves the physics layer at index [param layer_index] to the given position [param to_position] in the array. Also updates the atlas tiles accordingly.
*/
//go:nosplit
func (self class) MovePhysicsLayer(layer_index int64, to_position int64) { //gd:TileSet.move_physics_layer
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.move_physics_layer, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		layer_index int64
		to_position int64
	}{layer_index, to_position}))
}

/*
Removes the physics layer at index [param layer_index]. Also updates the atlas tiles accordingly.
*/
//go:nosplit
func (self class) RemovePhysicsLayer(layer_index int64) { //gd:TileSet.remove_physics_layer
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.remove_physics_layer, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ layer_index int64 }{layer_index}))
}

/*
Sets the collision layer (as in the physics server) for bodies in the given TileSet physics layer.
*/
//go:nosplit
func (self class) SetPhysicsLayerCollisionLayer(layer_index int64, layer int64) { //gd:TileSet.set_physics_layer_collision_layer
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_physics_layer_collision_layer, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		layer_index int64
		layer       int64
	}{layer_index, layer}))
}

/*
Returns the collision layer (as in the physics server) bodies on the given TileSet's physics layer are in.
*/
//go:nosplit
func (self class) GetPhysicsLayerCollisionLayer(layer_index int64) int64 { //gd:TileSet.get_physics_layer_collision_layer
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_physics_layer_collision_layer, gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ layer_index int64 }{layer_index}))
	var ret = r_ret
	return ret
}

/*
Sets the collision mask for bodies in the given TileSet physics layer.
*/
//go:nosplit
func (self class) SetPhysicsLayerCollisionMask(layer_index int64, mask int64) { //gd:TileSet.set_physics_layer_collision_mask
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_physics_layer_collision_mask, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		layer_index int64
		mask        int64
	}{layer_index, mask}))
}

/*
Returns the collision mask of bodies on the given TileSet's physics layer.
*/
//go:nosplit
func (self class) GetPhysicsLayerCollisionMask(layer_index int64) int64 { //gd:TileSet.get_physics_layer_collision_mask
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_physics_layer_collision_mask, gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ layer_index int64 }{layer_index}))
	var ret = r_ret
	return ret
}

/*
Sets the collision priority for bodies in the given TileSet physics layer.
*/
//go:nosplit
func (self class) SetPhysicsLayerCollisionPriority(layer_index int64, priority float64) { //gd:TileSet.set_physics_layer_collision_priority
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_physics_layer_collision_priority, 0|(gdextension.SizeInt<<4)|(gdextension.SizeFloat<<8), unsafe.Pointer(&struct {
		layer_index int64
		priority    float64
	}{layer_index, priority}))
}

/*
Returns the collision priority of bodies on the given TileSet's physics layer.
*/
//go:nosplit
func (self class) GetPhysicsLayerCollisionPriority(layer_index int64) float64 { //gd:TileSet.get_physics_layer_collision_priority
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_physics_layer_collision_priority, gdextension.SizeFloat|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ layer_index int64 }{layer_index}))
	var ret = r_ret
	return ret
}

/*
Sets the physics material for bodies in the given TileSet physics layer.
*/
//go:nosplit
func (self class) SetPhysicsLayerPhysicsMaterial(layer_index int64, physics_material [1]gdclass.PhysicsMaterial) { //gd:TileSet.set_physics_layer_physics_material
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_physics_layer_physics_material, 0|(gdextension.SizeInt<<4)|(gdextension.SizeObject<<8), unsafe.Pointer(&struct {
		layer_index      int64
		physics_material gdextension.Object
	}{layer_index, gdextension.Object(gd.ObjectChecked(physics_material[0].AsObject()))}))
}

/*
Returns the physics material of bodies on the given TileSet's physics layer.
*/
//go:nosplit
func (self class) GetPhysicsLayerPhysicsMaterial(layer_index int64) [1]gdclass.PhysicsMaterial { //gd:TileSet.get_physics_layer_physics_material
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_physics_layer_physics_material, gdextension.SizeObject|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ layer_index int64 }{layer_index}))
	var ret = [1]gdclass.PhysicsMaterial{gd.PointerWithOwnershipTransferredToGo[gdclass.PhysicsMaterial](r_ret)}
	return ret
}

/*
Returns the terrain sets count.
*/
//go:nosplit
func (self class) GetTerrainSetsCount() int64 { //gd:TileSet.get_terrain_sets_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_terrain_sets_count, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Adds a new terrain set at the given position [param to_position] in the array. If [param to_position] is -1, adds it at the end of the array.
*/
//go:nosplit
func (self class) AddTerrainSet(to_position int64) { //gd:TileSet.add_terrain_set
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_terrain_set, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ to_position int64 }{to_position}))
}

/*
Moves the terrain set at index [param terrain_set] to the given position [param to_position] in the array. Also updates the atlas tiles accordingly.
*/
//go:nosplit
func (self class) MoveTerrainSet(terrain_set int64, to_position int64) { //gd:TileSet.move_terrain_set
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.move_terrain_set, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		terrain_set int64
		to_position int64
	}{terrain_set, to_position}))
}

/*
Removes the terrain set at index [param terrain_set]. Also updates the atlas tiles accordingly.
*/
//go:nosplit
func (self class) RemoveTerrainSet(terrain_set int64) { //gd:TileSet.remove_terrain_set
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.remove_terrain_set, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ terrain_set int64 }{terrain_set}))
}

/*
Sets a terrain mode. Each mode determines which bits of a tile shape is used to match the neighboring tiles' terrains.
*/
//go:nosplit
func (self class) SetTerrainSetMode(terrain_set int64, mode TerrainMode) { //gd:TileSet.set_terrain_set_mode
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_terrain_set_mode, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		terrain_set int64
		mode        TerrainMode
	}{terrain_set, mode}))
}

/*
Returns a terrain set mode.
*/
//go:nosplit
func (self class) GetTerrainSetMode(terrain_set int64) TerrainMode { //gd:TileSet.get_terrain_set_mode
	var r_ret = gdextension.Call[TerrainMode](gd.ObjectChecked(self.AsObject()), methods.get_terrain_set_mode, gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ terrain_set int64 }{terrain_set}))
	var ret = r_ret
	return ret
}

/*
Returns the number of terrains in the given terrain set.
*/
//go:nosplit
func (self class) GetTerrainsCount(terrain_set int64) int64 { //gd:TileSet.get_terrains_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_terrains_count, gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ terrain_set int64 }{terrain_set}))
	var ret = r_ret
	return ret
}

/*
Adds a new terrain to the given terrain set [param terrain_set] at the given position [param to_position] in the array. If [param to_position] is -1, adds it at the end of the array.
*/
//go:nosplit
func (self class) AddTerrain(terrain_set int64, to_position int64) { //gd:TileSet.add_terrain
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_terrain, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		terrain_set int64
		to_position int64
	}{terrain_set, to_position}))
}

/*
Moves the terrain at index [param terrain_index] for terrain set [param terrain_set] to the given position [param to_position] in the array. Also updates the atlas tiles accordingly.
*/
//go:nosplit
func (self class) MoveTerrain(terrain_set int64, terrain_index int64, to_position int64) { //gd:TileSet.move_terrain
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.move_terrain, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		terrain_set   int64
		terrain_index int64
		to_position   int64
	}{terrain_set, terrain_index, to_position}))
}

/*
Removes the terrain at index [param terrain_index] in the given terrain set [param terrain_set]. Also updates the atlas tiles accordingly.
*/
//go:nosplit
func (self class) RemoveTerrain(terrain_set int64, terrain_index int64) { //gd:TileSet.remove_terrain
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.remove_terrain, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		terrain_set   int64
		terrain_index int64
	}{terrain_set, terrain_index}))
}

/*
Sets a terrain's name.
*/
//go:nosplit
func (self class) SetTerrainName(terrain_set int64, terrain_index int64, name String.Readable) { //gd:TileSet.set_terrain_name
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_terrain_name, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeString<<12), unsafe.Pointer(&struct {
		terrain_set   int64
		terrain_index int64
		name          gdextension.String
	}{terrain_set, terrain_index, pointers.Get(gd.InternalString(name))}))
}

/*
Returns a terrain's name.
*/
//go:nosplit
func (self class) GetTerrainName(terrain_set int64, terrain_index int64) String.Readable { //gd:TileSet.get_terrain_name
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_terrain_name, gdextension.SizeString|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		terrain_set   int64
		terrain_index int64
	}{terrain_set, terrain_index}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Sets a terrain's color. This color is used for identifying the different terrains in the TileSet editor.
*/
//go:nosplit
func (self class) SetTerrainColor(terrain_set int64, terrain_index int64, color Color.RGBA) { //gd:TileSet.set_terrain_color
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_terrain_color, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeColor<<12), unsafe.Pointer(&struct {
		terrain_set   int64
		terrain_index int64
		color         Color.RGBA
	}{terrain_set, terrain_index, color}))
}

/*
Returns a terrain's color.
*/
//go:nosplit
func (self class) GetTerrainColor(terrain_set int64, terrain_index int64) Color.RGBA { //gd:TileSet.get_terrain_color
	var r_ret = gdextension.Call[Color.RGBA](gd.ObjectChecked(self.AsObject()), methods.get_terrain_color, gdextension.SizeColor|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		terrain_set   int64
		terrain_index int64
	}{terrain_set, terrain_index}))
	var ret = r_ret
	return ret
}

/*
Returns the navigation layers count.
*/
//go:nosplit
func (self class) GetNavigationLayersCount() int64 { //gd:TileSet.get_navigation_layers_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_navigation_layers_count, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Adds a navigation layer to the TileSet at the given position [param to_position] in the array. If [param to_position] is -1, adds it at the end of the array.
Navigation layers allow assigning a navigable area to atlas tiles.
*/
//go:nosplit
func (self class) AddNavigationLayer(to_position int64) { //gd:TileSet.add_navigation_layer
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_navigation_layer, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ to_position int64 }{to_position}))
}

/*
Moves the navigation layer at index [param layer_index] to the given position [param to_position] in the array. Also updates the atlas tiles accordingly.
*/
//go:nosplit
func (self class) MoveNavigationLayer(layer_index int64, to_position int64) { //gd:TileSet.move_navigation_layer
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.move_navigation_layer, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		layer_index int64
		to_position int64
	}{layer_index, to_position}))
}

/*
Removes the navigation layer at index [param layer_index]. Also updates the atlas tiles accordingly.
*/
//go:nosplit
func (self class) RemoveNavigationLayer(layer_index int64) { //gd:TileSet.remove_navigation_layer
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.remove_navigation_layer, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ layer_index int64 }{layer_index}))
}

/*
Sets the navigation layers (as in the navigation server) for navigation regions in the given TileSet navigation layer.
*/
//go:nosplit
func (self class) SetNavigationLayerLayers(layer_index int64, layers int64) { //gd:TileSet.set_navigation_layer_layers
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_navigation_layer_layers, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		layer_index int64
		layers      int64
	}{layer_index, layers}))
}

/*
Returns the navigation layers (as in the Navigation server) of the given TileSet navigation layer.
*/
//go:nosplit
func (self class) GetNavigationLayerLayers(layer_index int64) int64 { //gd:TileSet.get_navigation_layer_layers
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_navigation_layer_layers, gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ layer_index int64 }{layer_index}))
	var ret = r_ret
	return ret
}

/*
Based on [param value], enables or disables the specified navigation layer of the TileSet navigation data layer identified by the given [param layer_index], given a navigation_layers [param layer_number] between 1 and 32.
*/
//go:nosplit
func (self class) SetNavigationLayerLayerValue(layer_index int64, layer_number int64, value bool) { //gd:TileSet.set_navigation_layer_layer_value
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_navigation_layer_layer_value, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeBool<<12), unsafe.Pointer(&struct {
		layer_index  int64
		layer_number int64
		value        bool
	}{layer_index, layer_number, value}))
}

/*
Returns whether or not the specified navigation layer of the TileSet navigation data layer identified by the given [param layer_index] is enabled, given a navigation_layers [param layer_number] between 1 and 32.
*/
//go:nosplit
func (self class) GetNavigationLayerLayerValue(layer_index int64, layer_number int64) bool { //gd:TileSet.get_navigation_layer_layer_value
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.get_navigation_layer_layer_value, gdextension.SizeBool|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		layer_index  int64
		layer_number int64
	}{layer_index, layer_number}))
	var ret = r_ret
	return ret
}

/*
Returns the custom data layers count.
*/
//go:nosplit
func (self class) GetCustomDataLayersCount() int64 { //gd:TileSet.get_custom_data_layers_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_custom_data_layers_count, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Adds a custom data layer to the TileSet at the given position [param to_position] in the array. If [param to_position] is -1, adds it at the end of the array.
Custom data layers allow assigning custom properties to atlas tiles.
*/
//go:nosplit
func (self class) AddCustomDataLayer(to_position int64) { //gd:TileSet.add_custom_data_layer
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_custom_data_layer, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ to_position int64 }{to_position}))
}

/*
Moves the custom data layer at index [param layer_index] to the given position [param to_position] in the array. Also updates the atlas tiles accordingly.
*/
//go:nosplit
func (self class) MoveCustomDataLayer(layer_index int64, to_position int64) { //gd:TileSet.move_custom_data_layer
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.move_custom_data_layer, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		layer_index int64
		to_position int64
	}{layer_index, to_position}))
}

/*
Removes the custom data layer at index [param layer_index]. Also updates the atlas tiles accordingly.
*/
//go:nosplit
func (self class) RemoveCustomDataLayer(layer_index int64) { //gd:TileSet.remove_custom_data_layer
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.remove_custom_data_layer, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ layer_index int64 }{layer_index}))
}

/*
Returns the index of the custom data layer identified by the given name.
*/
//go:nosplit
func (self class) GetCustomDataLayerByName(layer_name String.Readable) int64 { //gd:TileSet.get_custom_data_layer_by_name
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_custom_data_layer_by_name, gdextension.SizeInt|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ layer_name gdextension.String }{pointers.Get(gd.InternalString(layer_name))}))
	var ret = r_ret
	return ret
}

/*
Sets the name of the custom data layer identified by the given index. Names are identifiers of the layer therefore if the name is already taken it will fail and raise an error.
*/
//go:nosplit
func (self class) SetCustomDataLayerName(layer_index int64, layer_name String.Readable) { //gd:TileSet.set_custom_data_layer_name
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_custom_data_layer_name, 0|(gdextension.SizeInt<<4)|(gdextension.SizeString<<8), unsafe.Pointer(&struct {
		layer_index int64
		layer_name  gdextension.String
	}{layer_index, pointers.Get(gd.InternalString(layer_name))}))
}

/*
Returns if there is a custom data layer named [param layer_name].
*/
//go:nosplit
func (self class) HasCustomDataLayerByName(layer_name String.Readable) bool { //gd:TileSet.has_custom_data_layer_by_name
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.has_custom_data_layer_by_name, gdextension.SizeBool|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ layer_name gdextension.String }{pointers.Get(gd.InternalString(layer_name))}))
	var ret = r_ret
	return ret
}

/*
Returns the name of the custom data layer identified by the given index.
*/
//go:nosplit
func (self class) GetCustomDataLayerName(layer_index int64) String.Readable { //gd:TileSet.get_custom_data_layer_name
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_custom_data_layer_name, gdextension.SizeString|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ layer_index int64 }{layer_index}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Sets the type of the custom data layer identified by the given index.
*/
//go:nosplit
func (self class) SetCustomDataLayerType(layer_index int64, layer_type variant.Type) { //gd:TileSet.set_custom_data_layer_type
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_custom_data_layer_type, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		layer_index int64
		layer_type  variant.Type
	}{layer_index, layer_type}))
}

/*
Returns the type of the custom data layer identified by the given index.
*/
//go:nosplit
func (self class) GetCustomDataLayerType(layer_index int64) variant.Type { //gd:TileSet.get_custom_data_layer_type
	var r_ret = gdextension.Call[variant.Type](gd.ObjectChecked(self.AsObject()), methods.get_custom_data_layer_type, gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ layer_index int64 }{layer_index}))
	var ret = r_ret
	return ret
}

/*
Creates a source-level proxy for the given source ID. A proxy will map set of tile identifiers to another set of identifiers. Both the atlas coordinates ID and the alternative tile ID are kept the same when using source-level proxies.
This can be used to replace a source in all TileMaps using this TileSet, as TileMap nodes will find and use the proxy's target source when one is available.
Proxied tiles can be automatically replaced in TileMap nodes using the editor.
*/
//go:nosplit
func (self class) SetSourceLevelTileProxy(source_from int64, source_to int64) { //gd:TileSet.set_source_level_tile_proxy
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_source_level_tile_proxy, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		source_from int64
		source_to   int64
	}{source_from, source_to}))
}

/*
Returns the source-level proxy for the given source identifier.
If the TileSet has no proxy for the given identifier, returns -1.
*/
//go:nosplit
func (self class) GetSourceLevelTileProxy(source_from int64) int64 { //gd:TileSet.get_source_level_tile_proxy
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_source_level_tile_proxy, gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ source_from int64 }{source_from}))
	var ret = r_ret
	return ret
}

/*
Returns if there is a source-level proxy for the given source ID.
*/
//go:nosplit
func (self class) HasSourceLevelTileProxy(source_from int64) bool { //gd:TileSet.has_source_level_tile_proxy
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.has_source_level_tile_proxy, gdextension.SizeBool|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ source_from int64 }{source_from}))
	var ret = r_ret
	return ret
}

/*
Removes a source-level tile proxy.
*/
//go:nosplit
func (self class) RemoveSourceLevelTileProxy(source_from int64) { //gd:TileSet.remove_source_level_tile_proxy
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.remove_source_level_tile_proxy, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ source_from int64 }{source_from}))
}

/*
Creates a coordinates-level proxy for the given identifiers. A proxy will map set of tile identifiers to another set of identifiers. The alternative tile ID is kept the same when using coordinates-level proxies.
This can be used to replace a tile in all TileMaps using this TileSet, as TileMap nodes will find and use the proxy's target tile when one is available.
Proxied tiles can be automatically replaced in TileMap nodes using the editor.
*/
//go:nosplit
func (self class) SetCoordsLevelTileProxy(p_source_from int64, coords_from Vector2i.XY, source_to int64, coords_to Vector2i.XY) { //gd:TileSet.set_coords_level_tile_proxy
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_coords_level_tile_proxy, 0|(gdextension.SizeInt<<4)|(gdextension.SizeVector2i<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeVector2i<<16), unsafe.Pointer(&struct {
		p_source_from int64
		coords_from   Vector2i.XY
		source_to     int64
		coords_to     Vector2i.XY
	}{p_source_from, coords_from, source_to, coords_to}))
}

/*
Returns the coordinate-level proxy for the given identifiers. The returned array contains the two target identifiers of the proxy (source ID and atlas coordinates ID).
If the TileSet has no proxy for the given identifiers, returns an empty Array.
*/
//go:nosplit
func (self class) GetCoordsLevelTileProxy(source_from int64, coords_from Vector2i.XY) Array.Any { //gd:TileSet.get_coords_level_tile_proxy
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), methods.get_coords_level_tile_proxy, gdextension.SizeArray|(gdextension.SizeInt<<4)|(gdextension.SizeVector2i<<8), unsafe.Pointer(&struct {
		source_from int64
		coords_from Vector2i.XY
	}{source_from, coords_from}))
	var ret = Array.Through(gd.ArrayProxy[variant.Any]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

/*
Returns if there is a coodinates-level proxy for the given identifiers.
*/
//go:nosplit
func (self class) HasCoordsLevelTileProxy(source_from int64, coords_from Vector2i.XY) bool { //gd:TileSet.has_coords_level_tile_proxy
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.has_coords_level_tile_proxy, gdextension.SizeBool|(gdextension.SizeInt<<4)|(gdextension.SizeVector2i<<8), unsafe.Pointer(&struct {
		source_from int64
		coords_from Vector2i.XY
	}{source_from, coords_from}))
	var ret = r_ret
	return ret
}

/*
Removes a coordinates-level proxy for the given identifiers.
*/
//go:nosplit
func (self class) RemoveCoordsLevelTileProxy(source_from int64, coords_from Vector2i.XY) { //gd:TileSet.remove_coords_level_tile_proxy
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.remove_coords_level_tile_proxy, 0|(gdextension.SizeInt<<4)|(gdextension.SizeVector2i<<8), unsafe.Pointer(&struct {
		source_from int64
		coords_from Vector2i.XY
	}{source_from, coords_from}))
}

/*
Create an alternative-level proxy for the given identifiers. A proxy will map set of tile identifiers to another set of identifiers.
This can be used to replace a tile in all TileMaps using this TileSet, as TileMap nodes will find and use the proxy's target tile when one is available.
Proxied tiles can be automatically replaced in TileMap nodes using the editor.
*/
//go:nosplit
func (self class) SetAlternativeLevelTileProxy(source_from int64, coords_from Vector2i.XY, alternative_from int64, source_to int64, coords_to Vector2i.XY, alternative_to int64) { //gd:TileSet.set_alternative_level_tile_proxy
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_alternative_level_tile_proxy, 0|(gdextension.SizeInt<<4)|(gdextension.SizeVector2i<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeInt<<16)|(gdextension.SizeVector2i<<20)|(gdextension.SizeInt<<24), unsafe.Pointer(&struct {
		source_from      int64
		coords_from      Vector2i.XY
		alternative_from int64
		source_to        int64
		coords_to        Vector2i.XY
		alternative_to   int64
	}{source_from, coords_from, alternative_from, source_to, coords_to, alternative_to}))
}

/*
Returns the alternative-level proxy for the given identifiers. The returned array contains the three proxie's target identifiers (source ID, atlas coords ID and alternative tile ID).
If the TileSet has no proxy for the given identifiers, returns an empty Array.
*/
//go:nosplit
func (self class) GetAlternativeLevelTileProxy(source_from int64, coords_from Vector2i.XY, alternative_from int64) Array.Any { //gd:TileSet.get_alternative_level_tile_proxy
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), methods.get_alternative_level_tile_proxy, gdextension.SizeArray|(gdextension.SizeInt<<4)|(gdextension.SizeVector2i<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		source_from      int64
		coords_from      Vector2i.XY
		alternative_from int64
	}{source_from, coords_from, alternative_from}))
	var ret = Array.Through(gd.ArrayProxy[variant.Any]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

/*
Returns if there is an alternative-level proxy for the given identifiers.
*/
//go:nosplit
func (self class) HasAlternativeLevelTileProxy(source_from int64, coords_from Vector2i.XY, alternative_from int64) bool { //gd:TileSet.has_alternative_level_tile_proxy
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.has_alternative_level_tile_proxy, gdextension.SizeBool|(gdextension.SizeInt<<4)|(gdextension.SizeVector2i<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		source_from      int64
		coords_from      Vector2i.XY
		alternative_from int64
	}{source_from, coords_from, alternative_from}))
	var ret = r_ret
	return ret
}

/*
Removes an alternative-level proxy for the given identifiers.
*/
//go:nosplit
func (self class) RemoveAlternativeLevelTileProxy(source_from int64, coords_from Vector2i.XY, alternative_from int64) { //gd:TileSet.remove_alternative_level_tile_proxy
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.remove_alternative_level_tile_proxy, 0|(gdextension.SizeInt<<4)|(gdextension.SizeVector2i<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		source_from      int64
		coords_from      Vector2i.XY
		alternative_from int64
	}{source_from, coords_from, alternative_from}))
}

/*
According to the configured proxies, maps the provided identifiers to a new set of identifiers. The source ID, atlas coordinates ID and alternative tile ID are returned as a 3 elements Array.
This function first look for matching alternative-level proxies, then coordinates-level proxies, then source-level proxies.
If no proxy corresponding to provided identifiers are found, returns the same values the ones used as arguments.
*/
//go:nosplit
func (self class) MapTileProxy(source_from int64, coords_from Vector2i.XY, alternative_from int64) Array.Any { //gd:TileSet.map_tile_proxy
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), methods.map_tile_proxy, gdextension.SizeArray|(gdextension.SizeInt<<4)|(gdextension.SizeVector2i<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		source_from      int64
		coords_from      Vector2i.XY
		alternative_from int64
	}{source_from, coords_from, alternative_from}))
	var ret = Array.Through(gd.ArrayProxy[variant.Any]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

/*
Clears tile proxies pointing to invalid tiles.
*/
//go:nosplit
func (self class) CleanupInvalidTileProxies() { //gd:TileSet.cleanup_invalid_tile_proxies
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.cleanup_invalid_tile_proxies, 0, unsafe.Pointer(&struct{}{}))
}

/*
Clears all tile proxies.
*/
//go:nosplit
func (self class) ClearTileProxies() { //gd:TileSet.clear_tile_proxies
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.clear_tile_proxies, 0, unsafe.Pointer(&struct{}{}))
}

/*
Adds a [TileMapPattern] to be stored in the TileSet resource. If provided, insert it at the given [param index].
*/
//go:nosplit
func (self class) AddPattern(pattern [1]gdclass.TileMapPattern, index int64) int64 { //gd:TileSet.add_pattern
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.add_pattern, gdextension.SizeInt|(gdextension.SizeObject<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		pattern gdextension.Object
		index   int64
	}{gdextension.Object(gd.ObjectChecked(pattern[0].AsObject())), index}))
	var ret = r_ret
	return ret
}

/*
Returns the [TileMapPattern] at the given [param index].
*/
//go:nosplit
func (self class) GetPattern(index int64) [1]gdclass.TileMapPattern { //gd:TileSet.get_pattern
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_pattern, gdextension.SizeObject|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ index int64 }{index}))
	var ret = [1]gdclass.TileMapPattern{gd.PointerWithOwnershipTransferredToGo[gdclass.TileMapPattern](r_ret)}
	return ret
}

/*
Remove the [TileMapPattern] at the given index.
*/
//go:nosplit
func (self class) RemovePattern(index int64) { //gd:TileSet.remove_pattern
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.remove_pattern, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ index int64 }{index}))
}

/*
Returns the number of [TileMapPattern] this tile set handles.
*/
//go:nosplit
func (self class) GetPatternsCount() int64 { //gd:TileSet.get_patterns_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_patterns_count, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}
func (self class) AsTileSet() Advanced         { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsTileSet() Instance      { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsTileSet() Instance { return self.Super().AsTileSet() }
func (self class) AsResource() Resource.Advanced {
	return *((*Resource.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsResource() Resource.Instance { return self.Super().AsResource() }
func (self Instance) AsResource() Resource.Instance {
	return *((*Resource.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsRefCounted() [1]gd.RefCounted { return self.Super().AsRefCounted() }
func (self Instance) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Resource.Advanced(self.AsResource()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Resource.Instance(self.AsResource()), name)
	}
}
func init() {
	gdclass.Register("TileSet", func(ptr gd.Object) any { return *(*Instance)(unsafe.Pointer(&ptr)) })
}

type TileShape int //gd:TileSet.TileShape

const (
	/*Rectangular tile shape.*/
	TileShapeSquare TileShape = 0
	/*Diamond tile shape (for isometric look).
	  [b]Note:[/b] Isometric [TileSet] works best if [TileMap] and all its layers have Y-sort enabled.*/
	TileShapeIsometric TileShape = 1
	/*Rectangular tile shape with one row/column out of two offset by half a tile.*/
	TileShapeHalfOffsetSquare TileShape = 2
	/*Hexagonal tile shape.*/
	TileShapeHexagon TileShape = 3
)

type TileLayout int //gd:TileSet.TileLayout

const (
	/*Tile coordinates layout where both axis stay consistent with their respective local horizontal and vertical axis.*/
	TileLayoutStacked TileLayout = 0
	/*Same as [constant TILE_LAYOUT_STACKED], but the first half-offset is negative instead of positive.*/
	TileLayoutStackedOffset TileLayout = 1
	/*Tile coordinates layout where the horizontal axis stay horizontal, and the vertical one goes down-right.*/
	TileLayoutStairsRight TileLayout = 2
	/*Tile coordinates layout where the vertical axis stay vertical, and the horizontal one goes down-right.*/
	TileLayoutStairsDown TileLayout = 3
	/*Tile coordinates layout where the horizontal axis goes up-right, and the vertical one goes down-right.*/
	TileLayoutDiamondRight TileLayout = 4
	/*Tile coordinates layout where the horizontal axis goes down-right, and the vertical one goes down-left.*/
	TileLayoutDiamondDown TileLayout = 5
)

type TileOffsetAxis int //gd:TileSet.TileOffsetAxis

const (
	/*Horizontal half-offset.*/
	TileOffsetAxisHorizontal TileOffsetAxis = 0
	/*Vertical half-offset.*/
	TileOffsetAxisVertical TileOffsetAxis = 1
)

type CellNeighbor int //gd:TileSet.CellNeighbor

const (
	/*Neighbor on the right side.*/
	CellNeighborRightSide CellNeighbor = 0
	/*Neighbor in the right corner.*/
	CellNeighborRightCorner CellNeighbor = 1
	/*Neighbor on the bottom right side.*/
	CellNeighborBottomRightSide CellNeighbor = 2
	/*Neighbor in the bottom right corner.*/
	CellNeighborBottomRightCorner CellNeighbor = 3
	/*Neighbor on the bottom side.*/
	CellNeighborBottomSide CellNeighbor = 4
	/*Neighbor in the bottom corner.*/
	CellNeighborBottomCorner CellNeighbor = 5
	/*Neighbor on the bottom left side.*/
	CellNeighborBottomLeftSide CellNeighbor = 6
	/*Neighbor in the bottom left corner.*/
	CellNeighborBottomLeftCorner CellNeighbor = 7
	/*Neighbor on the left side.*/
	CellNeighborLeftSide CellNeighbor = 8
	/*Neighbor in the left corner.*/
	CellNeighborLeftCorner CellNeighbor = 9
	/*Neighbor on the top left side.*/
	CellNeighborTopLeftSide CellNeighbor = 10
	/*Neighbor in the top left corner.*/
	CellNeighborTopLeftCorner CellNeighbor = 11
	/*Neighbor on the top side.*/
	CellNeighborTopSide CellNeighbor = 12
	/*Neighbor in the top corner.*/
	CellNeighborTopCorner CellNeighbor = 13
	/*Neighbor on the top right side.*/
	CellNeighborTopRightSide CellNeighbor = 14
	/*Neighbor in the top right corner.*/
	CellNeighborTopRightCorner CellNeighbor = 15
)

type TerrainMode int //gd:TileSet.TerrainMode

const (
	/*Requires both corners and side to match with neighboring tiles' terrains.*/
	TerrainModeMatchCornersAndSides TerrainMode = 0
	/*Requires corners to match with neighboring tiles' terrains.*/
	TerrainModeMatchCorners TerrainMode = 1
	/*Requires sides to match with neighboring tiles' terrains.*/
	TerrainModeMatchSides TerrainMode = 2
)
