// Code generated by the generate package DO NOT EDIT

// Package EditorExportPlatform provides methods for working with EditorExportPlatform object instances.
package EditorExportPlatform

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/classdb/EditorExportPreset"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"

var _ Object.ID
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
Base resource that provides the functionality of exporting a release build of a project to a platform, from the editor. Stores platform-specific metadata such as the name and supported features of the platform, and performs the exporting of projects, PCK files, and ZIP files. Uses an export template for the platform provided at the time of project exporting.
Used in scripting by [EditorExportPlugin] to configure platform-specific customization of scenes and resources. See [method EditorExportPlugin._begin_customize_scenes] and [method EditorExportPlugin._begin_customize_resources] for more details.
*/
type Instance [1]gdclass.EditorExportPlatform

func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

type Expanded [1]gdclass.EditorExportPlatform

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsEditorExportPlatform() Instance
}

/*
Returns the name of the export operating system handled by this [EditorExportPlatform] class, as a friendly string. Possible return values are [code]Windows[/code], [code]Linux[/code], [code]macOS[/code], [code]Android[/code], [code]iOS[/code], and [code]Web[/code].
*/
func (self Instance) GetOsName() string { //gd:EditorExportPlatform.get_os_name
	return string(Advanced(self).GetOsName().String())
}

/*
Create a new preset for this platform.
*/
func (self Instance) CreatePreset() EditorExportPreset.Instance { //gd:EditorExportPlatform.create_preset
	return EditorExportPreset.Instance(Advanced(self).CreatePreset())
}

/*
Locates export template for the platform, and returns [Dictionary] with the following keys: [code]path: String[/code] and [code]error: String[/code]. This method is provided for convenience and custom export platforms aren't required to use it or keep export templates stored in the same way official templates are.
*/
func (self Instance) FindExportTemplate(template_file_name string) Template { //gd:EditorExportPlatform.find_export_template
	return Template(gd.DictionaryAs[Template](Advanced(self).FindExportTemplate(String.New(template_file_name))))
}

/*
Returns array of [EditorExportPreset]s for this platform.
*/
func (self Instance) GetCurrentPresets() []any { //gd:EditorExportPlatform.get_current_presets
	return []any(gd.ArrayAs[[]any](gd.InternalArray(Advanced(self).GetCurrentPresets())))
}

/*
Saves PCK archive and returns [Dictionary] with the following keys: [code]result: Error[/code], [code]so_files: Array[/code] (array of the shared/static objects which contains dictionaries with the following keys: [code]path: String[/code], [code]tags: PackedStringArray[/code], and [code]target_folder: String[/code]).
If [param embed] is [code]true[/code], PCK content is appended to the end of [param path] file and return [Dictionary] additionally include following keys: [code]embedded_start: int[/code] (embedded PCK offset) and [code]embedded_size: int[/code] (embedded PCK size).
*/
func (self Instance) SavePack(preset EditorExportPreset.Instance, debug bool, path string) Report { //gd:EditorExportPlatform.save_pack
	return Report(gd.DictionaryAs[Report](Advanced(self).SavePack(preset, debug, String.New(path), false)))
}

/*
Saves PCK archive and returns [Dictionary] with the following keys: [code]result: Error[/code], [code]so_files: Array[/code] (array of the shared/static objects which contains dictionaries with the following keys: [code]path: String[/code], [code]tags: PackedStringArray[/code], and [code]target_folder: String[/code]).
If [param embed] is [code]true[/code], PCK content is appended to the end of [param path] file and return [Dictionary] additionally include following keys: [code]embedded_start: int[/code] (embedded PCK offset) and [code]embedded_size: int[/code] (embedded PCK size).
*/
func (self Expanded) SavePack(preset EditorExportPreset.Instance, debug bool, path string, embed bool) Report { //gd:EditorExportPlatform.save_pack
	return Report(gd.DictionaryAs[Report](Advanced(self).SavePack(preset, debug, String.New(path), embed)))
}

/*
Saves ZIP archive and returns [Dictionary] with the following keys: [code]result: Error[/code], [code]so_files: Array[/code] (array of the shared/static objects which contains dictionaries with the following keys: [code]path: String[/code], [code]tags: PackedStringArray[/code], and [code]target_folder: String[/code]).
*/
func (self Instance) SaveZip(preset EditorExportPreset.Instance, debug bool, path string) Report { //gd:EditorExportPlatform.save_zip
	return Report(gd.DictionaryAs[Report](Advanced(self).SaveZip(preset, debug, String.New(path))))
}

/*
Saves patch PCK archive and returns [Dictionary] with the following keys: [code]result: Error[/code], [code]so_files: Array[/code] (array of the shared/static objects which contains dictionaries with the following keys: [code]path: String[/code], [code]tags: PackedStringArray[/code], and [code]target_folder: String[/code]).
*/
func (self Instance) SavePackPatch(preset EditorExportPreset.Instance, debug bool, path string) Report { //gd:EditorExportPlatform.save_pack_patch
	return Report(gd.DictionaryAs[Report](Advanced(self).SavePackPatch(preset, debug, String.New(path))))
}

/*
Saves patch ZIP archive and returns [Dictionary] with the following keys: [code]result: Error[/code], [code]so_files: Array[/code] (array of the shared/static objects which contains dictionaries with the following keys: [code]path: String[/code], [code]tags: PackedStringArray[/code], and [code]target_folder: String[/code]).
*/
func (self Instance) SaveZipPatch(preset EditorExportPreset.Instance, debug bool, path string) Report { //gd:EditorExportPlatform.save_zip_patch
	return Report(gd.DictionaryAs[Report](Advanced(self).SaveZipPatch(preset, debug, String.New(path))))
}

/*
Generates array of command line arguments for the default export templates for the debug flags and editor settings.
*/
func (self Instance) GenExportFlags(flags gdclass.EditorExportPlatformDebugFlags) []string { //gd:EditorExportPlatform.gen_export_flags
	return []string(Advanced(self).GenExportFlags(flags).Strings())
}

/*
Exports project files for the specified preset. This method can be used to implement custom export format, other than PCK and ZIP. One of the callbacks is called for each exported file.
[param save_cb] is called for all exported files and have the following arguments: [code]file_path: String[/code], [code]file_data: PackedByteArray[/code], [code]file_index: int[/code], [code]file_count: int[/code], [code]encryption_include_filters: PackedStringArray[/code], [code]encryption_exclude_filters: PackedStringArray[/code], [code]encryption_key: PackedByteArray[/code].
[param shared_cb] is called for exported native shared/static libraries and have the following arguments: [code]file_path: String[/code], [code]tags: PackedStringArray[/code], [code]target_folder: String[/code].
[b]Note:[/b] [code]file_index[/code] and [code]file_count[/code] are intended for progress tracking only and aren't necessarily unique and precise.
*/
func (self Instance) ExportProjectFiles(preset EditorExportPreset.Instance, debug bool, save_cb func(file_path string, file_data []byte, file_index int, file_count int, encryption_include_filters []string, encryption_exclude_filters []string, encryption_key []byte)) error { //gd:EditorExportPlatform.export_project_files
	return error(gd.ToError(Advanced(self).ExportProjectFiles(preset, debug, Callable.New(save_cb), Callable.New(Callable.Nil))))
}

/*
Exports project files for the specified preset. This method can be used to implement custom export format, other than PCK and ZIP. One of the callbacks is called for each exported file.
[param save_cb] is called for all exported files and have the following arguments: [code]file_path: String[/code], [code]file_data: PackedByteArray[/code], [code]file_index: int[/code], [code]file_count: int[/code], [code]encryption_include_filters: PackedStringArray[/code], [code]encryption_exclude_filters: PackedStringArray[/code], [code]encryption_key: PackedByteArray[/code].
[param shared_cb] is called for exported native shared/static libraries and have the following arguments: [code]file_path: String[/code], [code]tags: PackedStringArray[/code], [code]target_folder: String[/code].
[b]Note:[/b] [code]file_index[/code] and [code]file_count[/code] are intended for progress tracking only and aren't necessarily unique and precise.
*/
func (self Expanded) ExportProjectFiles(preset EditorExportPreset.Instance, debug bool, save_cb func(file_path string, file_data []byte, file_index int, file_count int, encryption_include_filters []string, encryption_exclude_filters []string, encryption_key []byte), shared_cb func(file_path string, tags []string, target_folder string)) error { //gd:EditorExportPlatform.export_project_files
	return error(gd.ToError(Advanced(self).ExportProjectFiles(preset, debug, Callable.New(save_cb), Callable.New(shared_cb))))
}

/*
Creates a full project at [param path] for the specified [param preset].
*/
func (self Instance) ExportProject(preset EditorExportPreset.Instance, debug bool, path string) error { //gd:EditorExportPlatform.export_project
	return error(gd.ToError(Advanced(self).ExportProject(preset, debug, String.New(path), 0)))
}

/*
Creates a full project at [param path] for the specified [param preset].
*/
func (self Expanded) ExportProject(preset EditorExportPreset.Instance, debug bool, path string, flags gdclass.EditorExportPlatformDebugFlags) error { //gd:EditorExportPlatform.export_project
	return error(gd.ToError(Advanced(self).ExportProject(preset, debug, String.New(path), flags)))
}

/*
Creates a PCK archive at [param path] for the specified [param preset].
*/
func (self Instance) ExportPack(preset EditorExportPreset.Instance, debug bool, path string) error { //gd:EditorExportPlatform.export_pack
	return error(gd.ToError(Advanced(self).ExportPack(preset, debug, String.New(path), 0)))
}

/*
Creates a PCK archive at [param path] for the specified [param preset].
*/
func (self Expanded) ExportPack(preset EditorExportPreset.Instance, debug bool, path string, flags gdclass.EditorExportPlatformDebugFlags) error { //gd:EditorExportPlatform.export_pack
	return error(gd.ToError(Advanced(self).ExportPack(preset, debug, String.New(path), flags)))
}

/*
Create a ZIP archive at [param path] for the specified [param preset].
*/
func (self Instance) ExportZip(preset EditorExportPreset.Instance, debug bool, path string) error { //gd:EditorExportPlatform.export_zip
	return error(gd.ToError(Advanced(self).ExportZip(preset, debug, String.New(path), 0)))
}

/*
Create a ZIP archive at [param path] for the specified [param preset].
*/
func (self Expanded) ExportZip(preset EditorExportPreset.Instance, debug bool, path string, flags gdclass.EditorExportPlatformDebugFlags) error { //gd:EditorExportPlatform.export_zip
	return error(gd.ToError(Advanced(self).ExportZip(preset, debug, String.New(path), flags)))
}

/*
Creates a patch PCK archive at [param path] for the specified [param preset], containing only the files that have changed since the last patch.
[b]Note:[/b] [param patches] is an optional override of the set of patches defined in the export preset. When empty the patches defined in the export preset will be used instead.
*/
func (self Instance) ExportPackPatch(preset EditorExportPreset.Instance, debug bool, path string) error { //gd:EditorExportPlatform.export_pack_patch
	return error(gd.ToError(Advanced(self).ExportPackPatch(preset, debug, String.New(path), Packed.MakeStrings([1][]string{}[0]...), 0)))
}

/*
Creates a patch PCK archive at [param path] for the specified [param preset], containing only the files that have changed since the last patch.
[b]Note:[/b] [param patches] is an optional override of the set of patches defined in the export preset. When empty the patches defined in the export preset will be used instead.
*/
func (self Expanded) ExportPackPatch(preset EditorExportPreset.Instance, debug bool, path string, patches []string, flags gdclass.EditorExportPlatformDebugFlags) error { //gd:EditorExportPlatform.export_pack_patch
	return error(gd.ToError(Advanced(self).ExportPackPatch(preset, debug, String.New(path), Packed.MakeStrings(patches...), flags)))
}

/*
Create a patch ZIP archive at [param path] for the specified [param preset], containing only the files that have changed since the last patch.
[b]Note:[/b] [param patches] is an optional override of the set of patches defined in the export preset. When empty the patches defined in the export preset will be used instead.
*/
func (self Instance) ExportZipPatch(preset EditorExportPreset.Instance, debug bool, path string) error { //gd:EditorExportPlatform.export_zip_patch
	return error(gd.ToError(Advanced(self).ExportZipPatch(preset, debug, String.New(path), Packed.MakeStrings([1][]string{}[0]...), 0)))
}

/*
Create a patch ZIP archive at [param path] for the specified [param preset], containing only the files that have changed since the last patch.
[b]Note:[/b] [param patches] is an optional override of the set of patches defined in the export preset. When empty the patches defined in the export preset will be used instead.
*/
func (self Expanded) ExportZipPatch(preset EditorExportPreset.Instance, debug bool, path string, patches []string, flags gdclass.EditorExportPlatformDebugFlags) error { //gd:EditorExportPlatform.export_zip_patch
	return error(gd.ToError(Advanced(self).ExportZipPatch(preset, debug, String.New(path), Packed.MakeStrings(patches...), flags)))
}

/*
Clears the export log.
*/
func (self Instance) ClearMessages() { //gd:EditorExportPlatform.clear_messages
	Advanced(self).ClearMessages()
}

/*
Adds a message to the export log that will be displayed when exporting ends.
*/
func (self Instance) AddMessage(atype gdclass.EditorExportPlatformExportMessageType, category string, message string) { //gd:EditorExportPlatform.add_message
	Advanced(self).AddMessage(atype, String.New(category), String.New(message))
}

/*
Returns number of messages in the export log.
*/
func (self Instance) GetMessageCount() int { //gd:EditorExportPlatform.get_message_count
	return int(int(Advanced(self).GetMessageCount()))
}

/*
Returns message type, for the message with [param index].
*/
func (self Instance) GetMessageType(index int) gdclass.EditorExportPlatformExportMessageType { //gd:EditorExportPlatform.get_message_type
	return gdclass.EditorExportPlatformExportMessageType(Advanced(self).GetMessageType(int64(index)))
}

/*
Returns message category, for the message with [param index].
*/
func (self Instance) GetMessageCategory(index int) string { //gd:EditorExportPlatform.get_message_category
	return string(Advanced(self).GetMessageCategory(int64(index)).String())
}

/*
Returns message text, for the message with [param index].
*/
func (self Instance) GetMessageText(index int) string { //gd:EditorExportPlatform.get_message_text
	return string(Advanced(self).GetMessageText(int64(index)).String())
}

/*
Returns most severe message type currently present in the export log.
*/
func (self Instance) GetWorstMessageType() gdclass.EditorExportPlatformExportMessageType { //gd:EditorExportPlatform.get_worst_message_type
	return gdclass.EditorExportPlatformExportMessageType(Advanced(self).GetWorstMessageType())
}

/*
Executes specified command on the remote host via SSH protocol and returns command output in the [param output].
*/
func (self Instance) SshRunOnRemote(host string, port string, ssh_arg []string, cmd_args string) error { //gd:EditorExportPlatform.ssh_run_on_remote
	return error(gd.ToError(Advanced(self).SshRunOnRemote(String.New(host), String.New(port), Packed.MakeStrings(ssh_arg...), String.New(cmd_args), Array.Nil, int64(-1))))
}

/*
Executes specified command on the remote host via SSH protocol and returns command output in the [param output].
*/
func (self Expanded) SshRunOnRemote(host string, port string, ssh_arg []string, cmd_args string, output []any, port_fwd int) error { //gd:EditorExportPlatform.ssh_run_on_remote
	return error(gd.ToError(Advanced(self).SshRunOnRemote(String.New(host), String.New(port), Packed.MakeStrings(ssh_arg...), String.New(cmd_args), gd.EngineArrayFromSlice(output), int64(port_fwd))))
}

/*
Executes specified command on the remote host via SSH protocol and returns process ID (on the remote host) without waiting for command to finish.
*/
func (self Instance) SshRunOnRemoteNoWait(host string, port string, ssh_args []string, cmd_args string) int { //gd:EditorExportPlatform.ssh_run_on_remote_no_wait
	return int(int(Advanced(self).SshRunOnRemoteNoWait(String.New(host), String.New(port), Packed.MakeStrings(ssh_args...), String.New(cmd_args), int64(-1))))
}

/*
Executes specified command on the remote host via SSH protocol and returns process ID (on the remote host) without waiting for command to finish.
*/
func (self Expanded) SshRunOnRemoteNoWait(host string, port string, ssh_args []string, cmd_args string, port_fwd int) int { //gd:EditorExportPlatform.ssh_run_on_remote_no_wait
	return int(int(Advanced(self).SshRunOnRemoteNoWait(String.New(host), String.New(port), Packed.MakeStrings(ssh_args...), String.New(cmd_args), int64(port_fwd))))
}

/*
Uploads specified file over SCP protocol to the remote host.
*/
func (self Instance) SshPushToRemote(host string, port string, scp_args []string, src_file string, dst_file string) error { //gd:EditorExportPlatform.ssh_push_to_remote
	return error(gd.ToError(Advanced(self).SshPushToRemote(String.New(host), String.New(port), Packed.MakeStrings(scp_args...), String.New(src_file), String.New(dst_file))))
}

/*
Returns additional files that should always be exported regardless of preset configuration, and are not part of the project source. The returned [Dictionary] contains filename keys ([String]) and their corresponding raw data ([PackedByteArray]).
*/
func (self Instance) GetInternalExportFiles(preset EditorExportPreset.Instance, debug bool) map[string][]uint8 { //gd:EditorExportPlatform.get_internal_export_files
	return map[string][]uint8(gd.DictionaryAs[map[string][]uint8](Advanced(self).GetInternalExportFiles(preset, debug)))
}

/*
Returns array of core file names that always should be exported regardless of preset config.
*/
func GetForcedExportFiles() []string { //gd:EditorExportPlatform.get_forced_export_files
	self := Instance{}
	return []string(Advanced(self).GetForcedExportFiles().Strings())
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.EditorExportPlatform

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Extension[T]) AsObject() [1]gd.Object     { return self.Super().AsObject() }
func New() Instance {
	object := gd.Global.ClassDB.ConstructObject(gd.NewStringName("EditorExportPlatform"))
	casted := Instance{*(*gdclass.EditorExportPlatform)(unsafe.Pointer(&object))}
	casted.AsRefCounted()[0].Reference()
	return casted
}

/*
Returns the name of the export operating system handled by this [EditorExportPlatform] class, as a friendly string. Possible return values are [code]Windows[/code], [code]Linux[/code], [code]macOS[/code], [code]Android[/code], [code]iOS[/code], and [code]Web[/code].
*/
//go:nosplit
func (self class) GetOsName() String.Readable { //gd:EditorExportPlatform.get_os_name
	var frame = callframe.New()
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.EditorExportPlatform.Bind_get_os_name, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Create a new preset for this platform.
*/
//go:nosplit
func (self class) CreatePreset() [1]gdclass.EditorExportPreset { //gd:EditorExportPlatform.create_preset
	var frame = callframe.New()
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.EditorExportPlatform.Bind_create_preset, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.EditorExportPreset{gd.PointerWithOwnershipTransferredToGo[gdclass.EditorExportPreset](r_ret.Get())}
	frame.Free()
	return ret
}

/*
Locates export template for the platform, and returns [Dictionary] with the following keys: [code]path: String[/code] and [code]error: String[/code]. This method is provided for convenience and custom export platforms aren't required to use it or keep export templates stored in the same way official templates are.
*/
//go:nosplit
func (self class) FindExportTemplate(template_file_name String.Readable) Dictionary.Any { //gd:EditorExportPlatform.find_export_template
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(template_file_name)))
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.EditorExportPlatform.Bind_find_export_template, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Returns array of [EditorExportPreset]s for this platform.
*/
//go:nosplit
func (self class) GetCurrentPresets() Array.Any { //gd:EditorExportPlatform.get_current_presets
	var frame = callframe.New()
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.EditorExportPlatform.Bind_get_current_presets, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Array.Through(gd.ArrayProxy[variant.Any]{}, pointers.Pack(pointers.New[gd.Array](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Saves PCK archive and returns [Dictionary] with the following keys: [code]result: Error[/code], [code]so_files: Array[/code] (array of the shared/static objects which contains dictionaries with the following keys: [code]path: String[/code], [code]tags: PackedStringArray[/code], and [code]target_folder: String[/code]).
If [param embed] is [code]true[/code], PCK content is appended to the end of [param path] file and return [Dictionary] additionally include following keys: [code]embedded_start: int[/code] (embedded PCK offset) and [code]embedded_size: int[/code] (embedded PCK size).
*/
//go:nosplit
func (self class) SavePack(preset [1]gdclass.EditorExportPreset, debug bool, path String.Readable, embed bool) Dictionary.Any { //gd:EditorExportPlatform.save_pack
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(preset[0])[0])
	callframe.Arg(frame, debug)
	callframe.Arg(frame, pointers.Get(gd.InternalString(path)))
	callframe.Arg(frame, embed)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.EditorExportPlatform.Bind_save_pack, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Saves ZIP archive and returns [Dictionary] with the following keys: [code]result: Error[/code], [code]so_files: Array[/code] (array of the shared/static objects which contains dictionaries with the following keys: [code]path: String[/code], [code]tags: PackedStringArray[/code], and [code]target_folder: String[/code]).
*/
//go:nosplit
func (self class) SaveZip(preset [1]gdclass.EditorExportPreset, debug bool, path String.Readable) Dictionary.Any { //gd:EditorExportPlatform.save_zip
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(preset[0])[0])
	callframe.Arg(frame, debug)
	callframe.Arg(frame, pointers.Get(gd.InternalString(path)))
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.EditorExportPlatform.Bind_save_zip, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Saves patch PCK archive and returns [Dictionary] with the following keys: [code]result: Error[/code], [code]so_files: Array[/code] (array of the shared/static objects which contains dictionaries with the following keys: [code]path: String[/code], [code]tags: PackedStringArray[/code], and [code]target_folder: String[/code]).
*/
//go:nosplit
func (self class) SavePackPatch(preset [1]gdclass.EditorExportPreset, debug bool, path String.Readable) Dictionary.Any { //gd:EditorExportPlatform.save_pack_patch
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(preset[0])[0])
	callframe.Arg(frame, debug)
	callframe.Arg(frame, pointers.Get(gd.InternalString(path)))
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.EditorExportPlatform.Bind_save_pack_patch, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Saves patch ZIP archive and returns [Dictionary] with the following keys: [code]result: Error[/code], [code]so_files: Array[/code] (array of the shared/static objects which contains dictionaries with the following keys: [code]path: String[/code], [code]tags: PackedStringArray[/code], and [code]target_folder: String[/code]).
*/
//go:nosplit
func (self class) SaveZipPatch(preset [1]gdclass.EditorExportPreset, debug bool, path String.Readable) Dictionary.Any { //gd:EditorExportPlatform.save_zip_patch
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(preset[0])[0])
	callframe.Arg(frame, debug)
	callframe.Arg(frame, pointers.Get(gd.InternalString(path)))
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.EditorExportPlatform.Bind_save_zip_patch, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Generates array of command line arguments for the default export templates for the debug flags and editor settings.
*/
//go:nosplit
func (self class) GenExportFlags(flags gdclass.EditorExportPlatformDebugFlags) Packed.Strings { //gd:EditorExportPlatform.gen_export_flags
	var frame = callframe.New()
	callframe.Arg(frame, flags)
	var r_ret = callframe.Ret[gd.PackedPointers](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.EditorExportPlatform.Bind_gen_export_flags, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Packed.Strings(Array.Through(gd.PackedStringArrayProxy{}, pointers.Pack(pointers.New[gd.PackedStringArray](r_ret.Get()))))
	frame.Free()
	return ret
}

/*
Exports project files for the specified preset. This method can be used to implement custom export format, other than PCK and ZIP. One of the callbacks is called for each exported file.
[param save_cb] is called for all exported files and have the following arguments: [code]file_path: String[/code], [code]file_data: PackedByteArray[/code], [code]file_index: int[/code], [code]file_count: int[/code], [code]encryption_include_filters: PackedStringArray[/code], [code]encryption_exclude_filters: PackedStringArray[/code], [code]encryption_key: PackedByteArray[/code].
[param shared_cb] is called for exported native shared/static libraries and have the following arguments: [code]file_path: String[/code], [code]tags: PackedStringArray[/code], [code]target_folder: String[/code].
[b]Note:[/b] [code]file_index[/code] and [code]file_count[/code] are intended for progress tracking only and aren't necessarily unique and precise.
*/
//go:nosplit
func (self class) ExportProjectFiles(preset [1]gdclass.EditorExportPreset, debug bool, save_cb Callable.Function, shared_cb Callable.Function) Error.Code { //gd:EditorExportPlatform.export_project_files
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(preset[0])[0])
	callframe.Arg(frame, debug)
	callframe.Arg(frame, pointers.Get(gd.InternalCallable(save_cb)))
	callframe.Arg(frame, pointers.Get(gd.InternalCallable(shared_cb)))
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.EditorExportPlatform.Bind_export_project_files, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Error.Code(r_ret.Get())
	frame.Free()
	return ret
}

/*
Creates a full project at [param path] for the specified [param preset].
*/
//go:nosplit
func (self class) ExportProject(preset [1]gdclass.EditorExportPreset, debug bool, path String.Readable, flags gdclass.EditorExportPlatformDebugFlags) Error.Code { //gd:EditorExportPlatform.export_project
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(preset[0])[0])
	callframe.Arg(frame, debug)
	callframe.Arg(frame, pointers.Get(gd.InternalString(path)))
	callframe.Arg(frame, flags)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.EditorExportPlatform.Bind_export_project, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Error.Code(r_ret.Get())
	frame.Free()
	return ret
}

/*
Creates a PCK archive at [param path] for the specified [param preset].
*/
//go:nosplit
func (self class) ExportPack(preset [1]gdclass.EditorExportPreset, debug bool, path String.Readable, flags gdclass.EditorExportPlatformDebugFlags) Error.Code { //gd:EditorExportPlatform.export_pack
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(preset[0])[0])
	callframe.Arg(frame, debug)
	callframe.Arg(frame, pointers.Get(gd.InternalString(path)))
	callframe.Arg(frame, flags)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.EditorExportPlatform.Bind_export_pack, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Error.Code(r_ret.Get())
	frame.Free()
	return ret
}

/*
Create a ZIP archive at [param path] for the specified [param preset].
*/
//go:nosplit
func (self class) ExportZip(preset [1]gdclass.EditorExportPreset, debug bool, path String.Readable, flags gdclass.EditorExportPlatformDebugFlags) Error.Code { //gd:EditorExportPlatform.export_zip
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(preset[0])[0])
	callframe.Arg(frame, debug)
	callframe.Arg(frame, pointers.Get(gd.InternalString(path)))
	callframe.Arg(frame, flags)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.EditorExportPlatform.Bind_export_zip, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Error.Code(r_ret.Get())
	frame.Free()
	return ret
}

/*
Creates a patch PCK archive at [param path] for the specified [param preset], containing only the files that have changed since the last patch.
[b]Note:[/b] [param patches] is an optional override of the set of patches defined in the export preset. When empty the patches defined in the export preset will be used instead.
*/
//go:nosplit
func (self class) ExportPackPatch(preset [1]gdclass.EditorExportPreset, debug bool, path String.Readable, patches Packed.Strings, flags gdclass.EditorExportPlatformDebugFlags) Error.Code { //gd:EditorExportPlatform.export_pack_patch
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(preset[0])[0])
	callframe.Arg(frame, debug)
	callframe.Arg(frame, pointers.Get(gd.InternalString(path)))
	callframe.Arg(frame, pointers.Get(gd.InternalPackedStrings(patches)))
	callframe.Arg(frame, flags)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.EditorExportPlatform.Bind_export_pack_patch, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Error.Code(r_ret.Get())
	frame.Free()
	return ret
}

/*
Create a patch ZIP archive at [param path] for the specified [param preset], containing only the files that have changed since the last patch.
[b]Note:[/b] [param patches] is an optional override of the set of patches defined in the export preset. When empty the patches defined in the export preset will be used instead.
*/
//go:nosplit
func (self class) ExportZipPatch(preset [1]gdclass.EditorExportPreset, debug bool, path String.Readable, patches Packed.Strings, flags gdclass.EditorExportPlatformDebugFlags) Error.Code { //gd:EditorExportPlatform.export_zip_patch
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(preset[0])[0])
	callframe.Arg(frame, debug)
	callframe.Arg(frame, pointers.Get(gd.InternalString(path)))
	callframe.Arg(frame, pointers.Get(gd.InternalPackedStrings(patches)))
	callframe.Arg(frame, flags)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.EditorExportPlatform.Bind_export_zip_patch, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Error.Code(r_ret.Get())
	frame.Free()
	return ret
}

/*
Clears the export log.
*/
//go:nosplit
func (self class) ClearMessages() { //gd:EditorExportPlatform.clear_messages
	var frame = callframe.New()
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.EditorExportPlatform.Bind_clear_messages, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Adds a message to the export log that will be displayed when exporting ends.
*/
//go:nosplit
func (self class) AddMessage(atype gdclass.EditorExportPlatformExportMessageType, category String.Readable, message String.Readable) { //gd:EditorExportPlatform.add_message
	var frame = callframe.New()
	callframe.Arg(frame, atype)
	callframe.Arg(frame, pointers.Get(gd.InternalString(category)))
	callframe.Arg(frame, pointers.Get(gd.InternalString(message)))
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.EditorExportPlatform.Bind_add_message, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Returns number of messages in the export log.
*/
//go:nosplit
func (self class) GetMessageCount() int64 { //gd:EditorExportPlatform.get_message_count
	var frame = callframe.New()
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.EditorExportPlatform.Bind_get_message_count, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns message type, for the message with [param index].
*/
//go:nosplit
func (self class) GetMessageType(index int64) gdclass.EditorExportPlatformExportMessageType { //gd:EditorExportPlatform.get_message_type
	var frame = callframe.New()
	callframe.Arg(frame, index)
	var r_ret = callframe.Ret[gdclass.EditorExportPlatformExportMessageType](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.EditorExportPlatform.Bind_get_message_type, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns message category, for the message with [param index].
*/
//go:nosplit
func (self class) GetMessageCategory(index int64) String.Readable { //gd:EditorExportPlatform.get_message_category
	var frame = callframe.New()
	callframe.Arg(frame, index)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.EditorExportPlatform.Bind_get_message_category, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Returns message text, for the message with [param index].
*/
//go:nosplit
func (self class) GetMessageText(index int64) String.Readable { //gd:EditorExportPlatform.get_message_text
	var frame = callframe.New()
	callframe.Arg(frame, index)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.EditorExportPlatform.Bind_get_message_text, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Returns most severe message type currently present in the export log.
*/
//go:nosplit
func (self class) GetWorstMessageType() gdclass.EditorExportPlatformExportMessageType { //gd:EditorExportPlatform.get_worst_message_type
	var frame = callframe.New()
	var r_ret = callframe.Ret[gdclass.EditorExportPlatformExportMessageType](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.EditorExportPlatform.Bind_get_worst_message_type, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Executes specified command on the remote host via SSH protocol and returns command output in the [param output].
*/
//go:nosplit
func (self class) SshRunOnRemote(host String.Readable, port String.Readable, ssh_arg Packed.Strings, cmd_args String.Readable, output Array.Any, port_fwd int64) Error.Code { //gd:EditorExportPlatform.ssh_run_on_remote
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(host)))
	callframe.Arg(frame, pointers.Get(gd.InternalString(port)))
	callframe.Arg(frame, pointers.Get(gd.InternalPackedStrings(ssh_arg)))
	callframe.Arg(frame, pointers.Get(gd.InternalString(cmd_args)))
	callframe.Arg(frame, pointers.Get(gd.InternalArray(output)))
	callframe.Arg(frame, port_fwd)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.EditorExportPlatform.Bind_ssh_run_on_remote, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Error.Code(r_ret.Get())
	frame.Free()
	return ret
}

/*
Executes specified command on the remote host via SSH protocol and returns process ID (on the remote host) without waiting for command to finish.
*/
//go:nosplit
func (self class) SshRunOnRemoteNoWait(host String.Readable, port String.Readable, ssh_args Packed.Strings, cmd_args String.Readable, port_fwd int64) int64 { //gd:EditorExportPlatform.ssh_run_on_remote_no_wait
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(host)))
	callframe.Arg(frame, pointers.Get(gd.InternalString(port)))
	callframe.Arg(frame, pointers.Get(gd.InternalPackedStrings(ssh_args)))
	callframe.Arg(frame, pointers.Get(gd.InternalString(cmd_args)))
	callframe.Arg(frame, port_fwd)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.EditorExportPlatform.Bind_ssh_run_on_remote_no_wait, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Uploads specified file over SCP protocol to the remote host.
*/
//go:nosplit
func (self class) SshPushToRemote(host String.Readable, port String.Readable, scp_args Packed.Strings, src_file String.Readable, dst_file String.Readable) Error.Code { //gd:EditorExportPlatform.ssh_push_to_remote
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(host)))
	callframe.Arg(frame, pointers.Get(gd.InternalString(port)))
	callframe.Arg(frame, pointers.Get(gd.InternalPackedStrings(scp_args)))
	callframe.Arg(frame, pointers.Get(gd.InternalString(src_file)))
	callframe.Arg(frame, pointers.Get(gd.InternalString(dst_file)))
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.EditorExportPlatform.Bind_ssh_push_to_remote, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Error.Code(r_ret.Get())
	frame.Free()
	return ret
}

/*
Returns additional files that should always be exported regardless of preset configuration, and are not part of the project source. The returned [Dictionary] contains filename keys ([String]) and their corresponding raw data ([PackedByteArray]).
*/
//go:nosplit
func (self class) GetInternalExportFiles(preset [1]gdclass.EditorExportPreset, debug bool) Dictionary.Any { //gd:EditorExportPlatform.get_internal_export_files
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(preset[0])[0])
	callframe.Arg(frame, debug)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.EditorExportPlatform.Bind_get_internal_export_files, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Returns array of core file names that always should be exported regardless of preset config.
*/
//go:nosplit
func (self class) GetForcedExportFiles() Packed.Strings { //gd:EditorExportPlatform.get_forced_export_files
	var frame = callframe.New()
	var r_ret = callframe.Ret[gd.PackedPointers](frame)
	gd.Global.Object.MethodBindPointerCallStatic(gd.Global.Methods.EditorExportPlatform.Bind_get_forced_export_files, frame.Array(0), r_ret.Addr())
	var ret = Packed.Strings(Array.Through(gd.PackedStringArrayProxy{}, pointers.Pack(pointers.New[gd.PackedStringArray](r_ret.Get()))))
	frame.Free()
	return ret
}
func (self class) AsEditorExportPlatform() Advanced    { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsEditorExportPlatform() Instance { return *((*Instance)(unsafe.Pointer(&self))) }
func (self Extension[T]) AsEditorExportPlatform() Instance {
	return self.Super().AsEditorExportPlatform()
}
func (self class) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}
func (self Extension[T]) AsRefCounted() [1]gd.RefCounted { return self.Super().AsRefCounted() }
func (self Instance) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(RefCounted.Advanced(self.AsRefCounted()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(RefCounted.Instance(self.AsRefCounted()), name)
	}
}
func init() {
	gdclass.Register("EditorExportPlatform", func(ptr gd.Object) any {
		return [1]gdclass.EditorExportPlatform{*(*gdclass.EditorExportPlatform)(unsafe.Pointer(&ptr))}
	})
}

type ExportMessageType = gdclass.EditorExportPlatformExportMessageType //gd:EditorExportPlatform.ExportMessageType

const (
	/*Invalid message type used as the default value when no type is specified.*/
	ExportMessageNone ExportMessageType = 0
	/*Message type for informational messages that have no effect on the export.*/
	ExportMessageInfo ExportMessageType = 1
	/*Message type for warning messages that should be addressed but still allow to complete the export.*/
	ExportMessageWarning ExportMessageType = 2
	/*Message type for error messages that must be addressed and fail the export.*/
	ExportMessageError ExportMessageType = 3
)

type DebugFlags = gdclass.EditorExportPlatformDebugFlags //gd:EditorExportPlatform.DebugFlags

const (
	/*Flag is set if remotely debugged project is expected to use remote file system. If set, [method gen_export_flags] will add [code]--remote-fs[/code] and [code]--remote-fs-password[/code] (if password is set in the editor settings) command line arguments to the list.*/
	DebugFlagDumbClient DebugFlags = 1
	/*Flag is set if remote debug is enabled. If set, [method gen_export_flags] will add [code]--remote-debug[/code] and [code]--breakpoints[/code] (if breakpoints are selected in the script editor or added by the plugin) command line arguments to the list.*/
	DebugFlagRemoteDebug DebugFlags = 2
	/*Flag is set if remotely debugged project is running on the localhost. If set, [method gen_export_flags] will use [code]localhost[/code] instead of [member EditorSettings.network/debug/remote_host] as remote debugger host.*/
	DebugFlagRemoteDebugLocalhost DebugFlags = 4
	/*Flag is set if "Visible Collision Shapes" remote debug option is enabled. If set, [method gen_export_flags] will add [code]--debug-collisions[/code] command line arguments to the list.*/
	DebugFlagViewCollisions DebugFlags = 8
	/*Flag is set if Visible Navigation" remote debug option is enabled. If set, [method gen_export_flags] will add [code]--debug-navigation[/code] command line arguments to the list.*/
	DebugFlagViewNavigation DebugFlags = 16
)

type File struct {
	Path         string   `gd:"path"`
	Tags         []string `gd:"tags"`
	TargetFolder string   `gd:"target_folder"`
}
type Report struct {
	Error         Error.Code `gd:"result"`
	Files         []File     `gd:"so_files"`
	EmbeddedStart int        `gd:"embedded_start"`
	EmbeddedSize  int        `gd:"embedded_size"`
}
type Template struct {
	Path  string `gd:"path"`
	Error string `gd:"error"`
}
