// Code generated by the generate package DO NOT EDIT

// Package LookAtModifier3D provides methods for working with LookAtModifier3D object instances.
package LookAtModifier3D

import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/variant/Signal"
import "graphics.gd/classdb/Node"
import "graphics.gd/classdb/Node3D"
import "graphics.gd/classdb/SkeletonModifier3D"
import "graphics.gd/classdb/Tween"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"
import "graphics.gd/variant/Vector3"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Signal.Any
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
This [SkeletonModifier3D] rotates a bone to look at a target. This is helpful for moving a character's head to look at the player, rotating a turret to look at a target, or any other case where you want to make a bone rotate towards something quickly and easily.
When applying multiple [LookAtModifier3D]s, the [LookAtModifier3D] assigned to the parent bone must be put above the [LookAtModifier3D] assigned to the child bone in the list in order for the child bone results to be correct.
*/
type Instance [1]gdclass.LookAtModifier3D

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	set_target_node                       gdextension.MethodForClass `hash:"1348162250"`
	get_target_node                       gdextension.MethodForClass `hash:"4075236667"`
	set_bone_name                         gdextension.MethodForClass `hash:"83702148"`
	get_bone_name                         gdextension.MethodForClass `hash:"201670096"`
	set_bone                              gdextension.MethodForClass `hash:"1286410249"`
	get_bone                              gdextension.MethodForClass `hash:"3905245786"`
	set_forward_axis                      gdextension.MethodForClass `hash:"3199955933"`
	get_forward_axis                      gdextension.MethodForClass `hash:"4076020284"`
	set_primary_rotation_axis             gdextension.MethodForClass `hash:"1144690656"`
	get_primary_rotation_axis             gdextension.MethodForClass `hash:"3050976882"`
	set_use_secondary_rotation            gdextension.MethodForClass `hash:"2586408642"`
	is_using_secondary_rotation           gdextension.MethodForClass `hash:"36873697"`
	set_origin_safe_margin                gdextension.MethodForClass `hash:"373806689"`
	get_origin_safe_margin                gdextension.MethodForClass `hash:"1740695150"`
	set_origin_from                       gdextension.MethodForClass `hash:"4254695669"`
	get_origin_from                       gdextension.MethodForClass `hash:"4057166297"`
	set_origin_bone_name                  gdextension.MethodForClass `hash:"83702148"`
	get_origin_bone_name                  gdextension.MethodForClass `hash:"201670096"`
	set_origin_bone                       gdextension.MethodForClass `hash:"1286410249"`
	get_origin_bone                       gdextension.MethodForClass `hash:"3905245786"`
	set_origin_external_node              gdextension.MethodForClass `hash:"1348162250"`
	get_origin_external_node              gdextension.MethodForClass `hash:"4075236667"`
	set_origin_offset                     gdextension.MethodForClass `hash:"3460891852"`
	get_origin_offset                     gdextension.MethodForClass `hash:"3360562783"`
	set_duration                          gdextension.MethodForClass `hash:"373806689"`
	get_duration                          gdextension.MethodForClass `hash:"1740695150"`
	set_transition_type                   gdextension.MethodForClass `hash:"1058637742"`
	get_transition_type                   gdextension.MethodForClass `hash:"3842314528"`
	set_ease_type                         gdextension.MethodForClass `hash:"1208105857"`
	get_ease_type                         gdextension.MethodForClass `hash:"631880200"`
	set_use_angle_limitation              gdextension.MethodForClass `hash:"2586408642"`
	is_using_angle_limitation             gdextension.MethodForClass `hash:"36873697"`
	set_symmetry_limitation               gdextension.MethodForClass `hash:"2586408642"`
	is_limitation_symmetry                gdextension.MethodForClass `hash:"36873697"`
	set_primary_limit_angle               gdextension.MethodForClass `hash:"373806689"`
	get_primary_limit_angle               gdextension.MethodForClass `hash:"1740695150"`
	set_primary_damp_threshold            gdextension.MethodForClass `hash:"373806689"`
	get_primary_damp_threshold            gdextension.MethodForClass `hash:"1740695150"`
	set_primary_positive_limit_angle      gdextension.MethodForClass `hash:"373806689"`
	get_primary_positive_limit_angle      gdextension.MethodForClass `hash:"1740695150"`
	set_primary_positive_damp_threshold   gdextension.MethodForClass `hash:"373806689"`
	get_primary_positive_damp_threshold   gdextension.MethodForClass `hash:"1740695150"`
	set_primary_negative_limit_angle      gdextension.MethodForClass `hash:"373806689"`
	get_primary_negative_limit_angle      gdextension.MethodForClass `hash:"1740695150"`
	set_primary_negative_damp_threshold   gdextension.MethodForClass `hash:"373806689"`
	get_primary_negative_damp_threshold   gdextension.MethodForClass `hash:"1740695150"`
	set_secondary_limit_angle             gdextension.MethodForClass `hash:"373806689"`
	get_secondary_limit_angle             gdextension.MethodForClass `hash:"1740695150"`
	set_secondary_damp_threshold          gdextension.MethodForClass `hash:"373806689"`
	get_secondary_damp_threshold          gdextension.MethodForClass `hash:"1740695150"`
	set_secondary_positive_limit_angle    gdextension.MethodForClass `hash:"373806689"`
	get_secondary_positive_limit_angle    gdextension.MethodForClass `hash:"1740695150"`
	set_secondary_positive_damp_threshold gdextension.MethodForClass `hash:"373806689"`
	get_secondary_positive_damp_threshold gdextension.MethodForClass `hash:"1740695150"`
	set_secondary_negative_limit_angle    gdextension.MethodForClass `hash:"373806689"`
	get_secondary_negative_limit_angle    gdextension.MethodForClass `hash:"1740695150"`
	set_secondary_negative_damp_threshold gdextension.MethodForClass `hash:"373806689"`
	get_secondary_negative_damp_threshold gdextension.MethodForClass `hash:"1740695150"`
	get_interpolation_remaining           gdextension.MethodForClass `hash:"1740695150"`
	is_interpolating                      gdextension.MethodForClass `hash:"36873697"`
	is_target_within_limitation           gdextension.MethodForClass `hash:"36873697"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("LookAtModifier3D")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		gdextension.Free(gdextension.TypeStringName, &sname)
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsLookAtModifier3D() Instance
}

/*
Returns the remaining seconds of the time-based interpolation.
*/
func (self Instance) GetInterpolationRemaining() Float.X { //gd:LookAtModifier3D.get_interpolation_remaining
	return Float.X(Float.X(Advanced(self).GetInterpolationRemaining()))
}

/*
Returns whether the time-based interpolation is running or not. If [code]true[/code], it is equivalent to [method get_interpolation_remaining] being [code]0[/code].
This is useful to determine whether a [LookAtModifier3D] can be removed safely.
*/
func (self Instance) IsInterpolating() bool { //gd:LookAtModifier3D.is_interpolating
	return bool(Advanced(self).IsInterpolating())
}

/*
Returns whether the target is within the angle limitations. It is useful for unsetting the [member target_node] when the target is outside of the angle limitations.
[b]Note:[/b] The value is updated after [method SkeletonModifier3D._process_modification]. To retrieve this value correctly, we recommend using the signal [signal SkeletonModifier3D.modification_processed].
*/
func (self Instance) IsTargetWithinLimitation() bool { //gd:LookAtModifier3D.is_target_within_limitation
	return bool(Advanced(self).IsTargetWithinLimitation())
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.LookAtModifier3D

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = pointers.AsA[gdclass.LookAtModifier3D](obj[0])
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = pointers.AsA[gdclass.LookAtModifier3D](obj[0])
		return true
	}
	return false
}
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }
func (self *Extension[T]) AsObject() [1]gd.Object { return self.Super().AsObject() }
func New() Instance {
	if !gd.Linked {
		var placeholder = Instance([1]gdclass.LookAtModifier3D{pointers.Add[gdclass.LookAtModifier3D]([3]uint64{})})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(pointers.AsA[gd.Object](placeholder[0]), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	casted := Instance([1]gdclass.LookAtModifier3D{pointers.New[gdclass.LookAtModifier3D]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})})
	casted.AsObject()[0].Notification(0, false)
	return casted
}

func (self Instance) TargetNode() string {
	return string(class(self).GetTargetNode().String())
}

func (self Instance) SetTargetNode(value string) {
	class(self).SetTargetNode(Path.ToNode(String.New(value)))
}

func (self Instance) BoneName() string {
	return string(class(self).GetBoneName().String())
}

func (self Instance) SetBoneName(value string) {
	class(self).SetBoneName(String.New(value))
}

func (self Instance) Bone() int {
	return int(int(class(self).GetBone()))
}

func (self Instance) SetBone(value int) {
	class(self).SetBone(int64(value))
}

func (self Instance) ForwardAxis() SkeletonModifier3D.BoneAxis {
	return SkeletonModifier3D.BoneAxis(class(self).GetForwardAxis())
}

func (self Instance) SetForwardAxis(value SkeletonModifier3D.BoneAxis) {
	class(self).SetForwardAxis(value)
}

func (self Instance) PrimaryRotationAxis() Vector3.Axis {
	return Vector3.Axis(class(self).GetPrimaryRotationAxis())
}

func (self Instance) SetPrimaryRotationAxis(value Vector3.Axis) {
	class(self).SetPrimaryRotationAxis(value)
}

func (self Instance) UseSecondaryRotation() bool {
	return bool(class(self).IsUsingSecondaryRotation())
}

func (self Instance) SetUseSecondaryRotation(value bool) {
	class(self).SetUseSecondaryRotation(value)
}

func (self Instance) OriginFrom() OriginFrom {
	return OriginFrom(class(self).GetOriginFrom())
}

func (self Instance) SetOriginFrom(value OriginFrom) {
	class(self).SetOriginFrom(value)
}

func (self Instance) OriginBoneName() string {
	return string(class(self).GetOriginBoneName().String())
}

func (self Instance) SetOriginBoneName(value string) {
	class(self).SetOriginBoneName(String.New(value))
}

func (self Instance) OriginBone() int {
	return int(int(class(self).GetOriginBone()))
}

func (self Instance) SetOriginBone(value int) {
	class(self).SetOriginBone(int64(value))
}

func (self Instance) OriginExternalNode() string {
	return string(class(self).GetOriginExternalNode().String())
}

func (self Instance) SetOriginExternalNode(value string) {
	class(self).SetOriginExternalNode(Path.ToNode(String.New(value)))
}

func (self Instance) OriginOffset() Vector3.XYZ {
	return Vector3.XYZ(class(self).GetOriginOffset())
}

func (self Instance) SetOriginOffset(value Vector3.XYZ) {
	class(self).SetOriginOffset(Vector3.XYZ(value))
}

func (self Instance) OriginSafeMargin() Float.X {
	return Float.X(Float.X(class(self).GetOriginSafeMargin()))
}

func (self Instance) SetOriginSafeMargin(value Float.X) {
	class(self).SetOriginSafeMargin(float64(value))
}

func (self Instance) Duration() Float.X {
	return Float.X(Float.X(class(self).GetDuration()))
}

func (self Instance) SetDuration(value Float.X) {
	class(self).SetDuration(float64(value))
}

func (self Instance) TransitionType() Tween.TransitionType {
	return Tween.TransitionType(class(self).GetTransitionType())
}

func (self Instance) SetTransitionType(value Tween.TransitionType) {
	class(self).SetTransitionType(value)
}

func (self Instance) EaseType() Tween.EaseType {
	return Tween.EaseType(class(self).GetEaseType())
}

func (self Instance) SetEaseType(value Tween.EaseType) {
	class(self).SetEaseType(value)
}

func (self Instance) UseAngleLimitation() bool {
	return bool(class(self).IsUsingAngleLimitation())
}

func (self Instance) SetUseAngleLimitation(value bool) {
	class(self).SetUseAngleLimitation(value)
}

func (self Instance) SymmetryLimitation() bool {
	return bool(class(self).IsLimitationSymmetry())
}

func (self Instance) SetSymmetryLimitation(value bool) {
	class(self).SetSymmetryLimitation(value)
}

func (self Instance) PrimaryLimitAngle() Angle.Radians {
	return Angle.Radians(Float.X(class(self).GetPrimaryLimitAngle()))
}

func (self Instance) SetPrimaryLimitAngle(value Angle.Radians) {
	class(self).SetPrimaryLimitAngle(float64(value))
}

func (self Instance) PrimaryDampThreshold() Float.X {
	return Float.X(Float.X(class(self).GetPrimaryDampThreshold()))
}

func (self Instance) SetPrimaryDampThreshold(value Float.X) {
	class(self).SetPrimaryDampThreshold(float64(value))
}

func (self Instance) PrimaryPositiveLimitAngle() Angle.Radians {
	return Angle.Radians(Float.X(class(self).GetPrimaryPositiveLimitAngle()))
}

func (self Instance) SetPrimaryPositiveLimitAngle(value Angle.Radians) {
	class(self).SetPrimaryPositiveLimitAngle(float64(value))
}

func (self Instance) PrimaryPositiveDampThreshold() Float.X {
	return Float.X(Float.X(class(self).GetPrimaryPositiveDampThreshold()))
}

func (self Instance) SetPrimaryPositiveDampThreshold(value Float.X) {
	class(self).SetPrimaryPositiveDampThreshold(float64(value))
}

func (self Instance) PrimaryNegativeLimitAngle() Angle.Radians {
	return Angle.Radians(Float.X(class(self).GetPrimaryNegativeLimitAngle()))
}

func (self Instance) SetPrimaryNegativeLimitAngle(value Angle.Radians) {
	class(self).SetPrimaryNegativeLimitAngle(float64(value))
}

func (self Instance) PrimaryNegativeDampThreshold() Float.X {
	return Float.X(Float.X(class(self).GetPrimaryNegativeDampThreshold()))
}

func (self Instance) SetPrimaryNegativeDampThreshold(value Float.X) {
	class(self).SetPrimaryNegativeDampThreshold(float64(value))
}

func (self Instance) SecondaryLimitAngle() Angle.Radians {
	return Angle.Radians(Float.X(class(self).GetSecondaryLimitAngle()))
}

func (self Instance) SetSecondaryLimitAngle(value Angle.Radians) {
	class(self).SetSecondaryLimitAngle(float64(value))
}

func (self Instance) SecondaryDampThreshold() Float.X {
	return Float.X(Float.X(class(self).GetSecondaryDampThreshold()))
}

func (self Instance) SetSecondaryDampThreshold(value Float.X) {
	class(self).SetSecondaryDampThreshold(float64(value))
}

func (self Instance) SecondaryPositiveLimitAngle() Angle.Radians {
	return Angle.Radians(Float.X(class(self).GetSecondaryPositiveLimitAngle()))
}

func (self Instance) SetSecondaryPositiveLimitAngle(value Angle.Radians) {
	class(self).SetSecondaryPositiveLimitAngle(float64(value))
}

func (self Instance) SecondaryPositiveDampThreshold() Float.X {
	return Float.X(Float.X(class(self).GetSecondaryPositiveDampThreshold()))
}

func (self Instance) SetSecondaryPositiveDampThreshold(value Float.X) {
	class(self).SetSecondaryPositiveDampThreshold(float64(value))
}

func (self Instance) SecondaryNegativeLimitAngle() Angle.Radians {
	return Angle.Radians(Float.X(class(self).GetSecondaryNegativeLimitAngle()))
}

func (self Instance) SetSecondaryNegativeLimitAngle(value Angle.Radians) {
	class(self).SetSecondaryNegativeLimitAngle(float64(value))
}

func (self Instance) SecondaryNegativeDampThreshold() Float.X {
	return Float.X(Float.X(class(self).GetSecondaryNegativeDampThreshold()))
}

func (self Instance) SetSecondaryNegativeDampThreshold(value Float.X) {
	class(self).SetSecondaryNegativeDampThreshold(float64(value))
}

//go:nosplit
func (self class) SetTargetNode(target_node Path.ToNode) { //gd:LookAtModifier3D.set_target_node
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_target_node, 0|(gdextension.SizeNodePath<<4), &struct{ target_node gdextension.NodePath }{pointers.Get(gd.InternalNodePath(target_node))})
}

//go:nosplit
func (self class) GetTargetNode() Path.ToNode { //gd:LookAtModifier3D.get_target_node
	var r_ret = gdextension.Call[gdextension.NodePath](gd.ObjectChecked(self.AsObject()), methods.get_target_node, gdextension.SizeNodePath, &struct{}{})
	var ret = Path.ToNode(String.Via(gd.NodePathProxy{}, pointers.Pack(pointers.New[gd.NodePath](r_ret))))
	return ret
}

//go:nosplit
func (self class) SetBoneName(bone_name String.Readable) { //gd:LookAtModifier3D.set_bone_name
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_bone_name, 0|(gdextension.SizeString<<4), &struct{ bone_name gdextension.String }{pointers.Get(gd.InternalString(bone_name))})
}

//go:nosplit
func (self class) GetBoneName() String.Readable { //gd:LookAtModifier3D.get_bone_name
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_bone_name, gdextension.SizeString, &struct{}{})
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

//go:nosplit
func (self class) SetBone(bone int64) { //gd:LookAtModifier3D.set_bone
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_bone, 0|(gdextension.SizeInt<<4), &struct{ bone int64 }{bone})
}

//go:nosplit
func (self class) GetBone() int64 { //gd:LookAtModifier3D.get_bone
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_bone, gdextension.SizeInt, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetForwardAxis(forward_axis SkeletonModifier3D.BoneAxis) { //gd:LookAtModifier3D.set_forward_axis
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_forward_axis, 0|(gdextension.SizeInt<<4), &struct{ forward_axis SkeletonModifier3D.BoneAxis }{forward_axis})
}

//go:nosplit
func (self class) GetForwardAxis() SkeletonModifier3D.BoneAxis { //gd:LookAtModifier3D.get_forward_axis
	var r_ret = gdextension.Call[SkeletonModifier3D.BoneAxis](gd.ObjectChecked(self.AsObject()), methods.get_forward_axis, gdextension.SizeInt, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetPrimaryRotationAxis(axis Vector3.Axis) { //gd:LookAtModifier3D.set_primary_rotation_axis
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_primary_rotation_axis, 0|(gdextension.SizeInt<<4), &struct{ axis Vector3.Axis }{axis})
}

//go:nosplit
func (self class) GetPrimaryRotationAxis() Vector3.Axis { //gd:LookAtModifier3D.get_primary_rotation_axis
	var r_ret = gdextension.Call[Vector3.Axis](gd.ObjectChecked(self.AsObject()), methods.get_primary_rotation_axis, gdextension.SizeInt, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetUseSecondaryRotation(enabled bool) { //gd:LookAtModifier3D.set_use_secondary_rotation
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_use_secondary_rotation, 0|(gdextension.SizeBool<<4), &struct{ enabled bool }{enabled})
}

//go:nosplit
func (self class) IsUsingSecondaryRotation() bool { //gd:LookAtModifier3D.is_using_secondary_rotation
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_using_secondary_rotation, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetOriginSafeMargin(margin float64) { //gd:LookAtModifier3D.set_origin_safe_margin
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_origin_safe_margin, 0|(gdextension.SizeFloat<<4), &struct{ margin float64 }{margin})
}

//go:nosplit
func (self class) GetOriginSafeMargin() float64 { //gd:LookAtModifier3D.get_origin_safe_margin
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_origin_safe_margin, gdextension.SizeFloat, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetOriginFrom(origin_from OriginFrom) { //gd:LookAtModifier3D.set_origin_from
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_origin_from, 0|(gdextension.SizeInt<<4), &struct{ origin_from OriginFrom }{origin_from})
}

//go:nosplit
func (self class) GetOriginFrom() OriginFrom { //gd:LookAtModifier3D.get_origin_from
	var r_ret = gdextension.Call[OriginFrom](gd.ObjectChecked(self.AsObject()), methods.get_origin_from, gdextension.SizeInt, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetOriginBoneName(bone_name String.Readable) { //gd:LookAtModifier3D.set_origin_bone_name
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_origin_bone_name, 0|(gdextension.SizeString<<4), &struct{ bone_name gdextension.String }{pointers.Get(gd.InternalString(bone_name))})
}

//go:nosplit
func (self class) GetOriginBoneName() String.Readable { //gd:LookAtModifier3D.get_origin_bone_name
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_origin_bone_name, gdextension.SizeString, &struct{}{})
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

//go:nosplit
func (self class) SetOriginBone(bone int64) { //gd:LookAtModifier3D.set_origin_bone
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_origin_bone, 0|(gdextension.SizeInt<<4), &struct{ bone int64 }{bone})
}

//go:nosplit
func (self class) GetOriginBone() int64 { //gd:LookAtModifier3D.get_origin_bone
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_origin_bone, gdextension.SizeInt, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetOriginExternalNode(external_node Path.ToNode) { //gd:LookAtModifier3D.set_origin_external_node
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_origin_external_node, 0|(gdextension.SizeNodePath<<4), &struct{ external_node gdextension.NodePath }{pointers.Get(gd.InternalNodePath(external_node))})
}

//go:nosplit
func (self class) GetOriginExternalNode() Path.ToNode { //gd:LookAtModifier3D.get_origin_external_node
	var r_ret = gdextension.Call[gdextension.NodePath](gd.ObjectChecked(self.AsObject()), methods.get_origin_external_node, gdextension.SizeNodePath, &struct{}{})
	var ret = Path.ToNode(String.Via(gd.NodePathProxy{}, pointers.Pack(pointers.New[gd.NodePath](r_ret))))
	return ret
}

//go:nosplit
func (self class) SetOriginOffset(offset Vector3.XYZ) { //gd:LookAtModifier3D.set_origin_offset
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_origin_offset, 0|(gdextension.SizeVector3<<4), &struct{ offset Vector3.XYZ }{offset})
}

//go:nosplit
func (self class) GetOriginOffset() Vector3.XYZ { //gd:LookAtModifier3D.get_origin_offset
	var r_ret = gdextension.Call[Vector3.XYZ](gd.ObjectChecked(self.AsObject()), methods.get_origin_offset, gdextension.SizeVector3, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetDuration(duration float64) { //gd:LookAtModifier3D.set_duration
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_duration, 0|(gdextension.SizeFloat<<4), &struct{ duration float64 }{duration})
}

//go:nosplit
func (self class) GetDuration() float64 { //gd:LookAtModifier3D.get_duration
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_duration, gdextension.SizeFloat, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetTransitionType(transition_type Tween.TransitionType) { //gd:LookAtModifier3D.set_transition_type
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_transition_type, 0|(gdextension.SizeInt<<4), &struct{ transition_type Tween.TransitionType }{transition_type})
}

//go:nosplit
func (self class) GetTransitionType() Tween.TransitionType { //gd:LookAtModifier3D.get_transition_type
	var r_ret = gdextension.Call[Tween.TransitionType](gd.ObjectChecked(self.AsObject()), methods.get_transition_type, gdextension.SizeInt, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetEaseType(ease_type Tween.EaseType) { //gd:LookAtModifier3D.set_ease_type
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_ease_type, 0|(gdextension.SizeInt<<4), &struct{ ease_type Tween.EaseType }{ease_type})
}

//go:nosplit
func (self class) GetEaseType() Tween.EaseType { //gd:LookAtModifier3D.get_ease_type
	var r_ret = gdextension.Call[Tween.EaseType](gd.ObjectChecked(self.AsObject()), methods.get_ease_type, gdextension.SizeInt, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetUseAngleLimitation(enabled bool) { //gd:LookAtModifier3D.set_use_angle_limitation
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_use_angle_limitation, 0|(gdextension.SizeBool<<4), &struct{ enabled bool }{enabled})
}

//go:nosplit
func (self class) IsUsingAngleLimitation() bool { //gd:LookAtModifier3D.is_using_angle_limitation
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_using_angle_limitation, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetSymmetryLimitation(enabled bool) { //gd:LookAtModifier3D.set_symmetry_limitation
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_symmetry_limitation, 0|(gdextension.SizeBool<<4), &struct{ enabled bool }{enabled})
}

//go:nosplit
func (self class) IsLimitationSymmetry() bool { //gd:LookAtModifier3D.is_limitation_symmetry
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_limitation_symmetry, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetPrimaryLimitAngle(angle float64) { //gd:LookAtModifier3D.set_primary_limit_angle
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_primary_limit_angle, 0|(gdextension.SizeFloat<<4), &struct{ angle float64 }{angle})
}

//go:nosplit
func (self class) GetPrimaryLimitAngle() float64 { //gd:LookAtModifier3D.get_primary_limit_angle
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_primary_limit_angle, gdextension.SizeFloat, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetPrimaryDampThreshold(power float64) { //gd:LookAtModifier3D.set_primary_damp_threshold
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_primary_damp_threshold, 0|(gdextension.SizeFloat<<4), &struct{ power float64 }{power})
}

//go:nosplit
func (self class) GetPrimaryDampThreshold() float64 { //gd:LookAtModifier3D.get_primary_damp_threshold
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_primary_damp_threshold, gdextension.SizeFloat, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetPrimaryPositiveLimitAngle(angle float64) { //gd:LookAtModifier3D.set_primary_positive_limit_angle
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_primary_positive_limit_angle, 0|(gdextension.SizeFloat<<4), &struct{ angle float64 }{angle})
}

//go:nosplit
func (self class) GetPrimaryPositiveLimitAngle() float64 { //gd:LookAtModifier3D.get_primary_positive_limit_angle
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_primary_positive_limit_angle, gdextension.SizeFloat, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetPrimaryPositiveDampThreshold(power float64) { //gd:LookAtModifier3D.set_primary_positive_damp_threshold
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_primary_positive_damp_threshold, 0|(gdextension.SizeFloat<<4), &struct{ power float64 }{power})
}

//go:nosplit
func (self class) GetPrimaryPositiveDampThreshold() float64 { //gd:LookAtModifier3D.get_primary_positive_damp_threshold
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_primary_positive_damp_threshold, gdextension.SizeFloat, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetPrimaryNegativeLimitAngle(angle float64) { //gd:LookAtModifier3D.set_primary_negative_limit_angle
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_primary_negative_limit_angle, 0|(gdextension.SizeFloat<<4), &struct{ angle float64 }{angle})
}

//go:nosplit
func (self class) GetPrimaryNegativeLimitAngle() float64 { //gd:LookAtModifier3D.get_primary_negative_limit_angle
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_primary_negative_limit_angle, gdextension.SizeFloat, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetPrimaryNegativeDampThreshold(power float64) { //gd:LookAtModifier3D.set_primary_negative_damp_threshold
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_primary_negative_damp_threshold, 0|(gdextension.SizeFloat<<4), &struct{ power float64 }{power})
}

//go:nosplit
func (self class) GetPrimaryNegativeDampThreshold() float64 { //gd:LookAtModifier3D.get_primary_negative_damp_threshold
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_primary_negative_damp_threshold, gdextension.SizeFloat, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetSecondaryLimitAngle(angle float64) { //gd:LookAtModifier3D.set_secondary_limit_angle
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_secondary_limit_angle, 0|(gdextension.SizeFloat<<4), &struct{ angle float64 }{angle})
}

//go:nosplit
func (self class) GetSecondaryLimitAngle() float64 { //gd:LookAtModifier3D.get_secondary_limit_angle
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_secondary_limit_angle, gdextension.SizeFloat, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetSecondaryDampThreshold(power float64) { //gd:LookAtModifier3D.set_secondary_damp_threshold
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_secondary_damp_threshold, 0|(gdextension.SizeFloat<<4), &struct{ power float64 }{power})
}

//go:nosplit
func (self class) GetSecondaryDampThreshold() float64 { //gd:LookAtModifier3D.get_secondary_damp_threshold
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_secondary_damp_threshold, gdextension.SizeFloat, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetSecondaryPositiveLimitAngle(angle float64) { //gd:LookAtModifier3D.set_secondary_positive_limit_angle
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_secondary_positive_limit_angle, 0|(gdextension.SizeFloat<<4), &struct{ angle float64 }{angle})
}

//go:nosplit
func (self class) GetSecondaryPositiveLimitAngle() float64 { //gd:LookAtModifier3D.get_secondary_positive_limit_angle
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_secondary_positive_limit_angle, gdextension.SizeFloat, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetSecondaryPositiveDampThreshold(power float64) { //gd:LookAtModifier3D.set_secondary_positive_damp_threshold
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_secondary_positive_damp_threshold, 0|(gdextension.SizeFloat<<4), &struct{ power float64 }{power})
}

//go:nosplit
func (self class) GetSecondaryPositiveDampThreshold() float64 { //gd:LookAtModifier3D.get_secondary_positive_damp_threshold
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_secondary_positive_damp_threshold, gdextension.SizeFloat, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetSecondaryNegativeLimitAngle(angle float64) { //gd:LookAtModifier3D.set_secondary_negative_limit_angle
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_secondary_negative_limit_angle, 0|(gdextension.SizeFloat<<4), &struct{ angle float64 }{angle})
}

//go:nosplit
func (self class) GetSecondaryNegativeLimitAngle() float64 { //gd:LookAtModifier3D.get_secondary_negative_limit_angle
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_secondary_negative_limit_angle, gdextension.SizeFloat, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetSecondaryNegativeDampThreshold(power float64) { //gd:LookAtModifier3D.set_secondary_negative_damp_threshold
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_secondary_negative_damp_threshold, 0|(gdextension.SizeFloat<<4), &struct{ power float64 }{power})
}

//go:nosplit
func (self class) GetSecondaryNegativeDampThreshold() float64 { //gd:LookAtModifier3D.get_secondary_negative_damp_threshold
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_secondary_negative_damp_threshold, gdextension.SizeFloat, &struct{}{})
	var ret = r_ret
	return ret
}

/*
Returns the remaining seconds of the time-based interpolation.
*/
//go:nosplit
func (self class) GetInterpolationRemaining() float64 { //gd:LookAtModifier3D.get_interpolation_remaining
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_interpolation_remaining, gdextension.SizeFloat, &struct{}{})
	var ret = r_ret
	return ret
}

/*
Returns whether the time-based interpolation is running or not. If [code]true[/code], it is equivalent to [method get_interpolation_remaining] being [code]0[/code].
This is useful to determine whether a [LookAtModifier3D] can be removed safely.
*/
//go:nosplit
func (self class) IsInterpolating() bool { //gd:LookAtModifier3D.is_interpolating
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_interpolating, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

/*
Returns whether the target is within the angle limitations. It is useful for unsetting the [member target_node] when the target is outside of the angle limitations.
[b]Note:[/b] The value is updated after [method SkeletonModifier3D._process_modification]. To retrieve this value correctly, we recommend using the signal [signal SkeletonModifier3D.modification_processed].
*/
//go:nosplit
func (self class) IsTargetWithinLimitation() bool { //gd:LookAtModifier3D.is_target_within_limitation
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_target_within_limitation, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}
func (self class) AsLookAtModifier3D() Advanced {
	return Advanced{pointers.AsA[gdclass.LookAtModifier3D](self[0])}
}
func (self Instance) AsLookAtModifier3D() Instance {
	return Instance{pointers.AsA[gdclass.LookAtModifier3D](self[0])}
}
func (self *Extension[T]) AsLookAtModifier3D() Instance { return self.Super().AsLookAtModifier3D() }
func (self class) AsSkeletonModifier3D() SkeletonModifier3D.Advanced {
	return SkeletonModifier3D.Advanced{pointers.AsA[gdclass.SkeletonModifier3D](self[0])}
}
func (self *Extension[T]) AsSkeletonModifier3D() SkeletonModifier3D.Instance {
	return self.Super().AsSkeletonModifier3D()
}
func (self Instance) AsSkeletonModifier3D() SkeletonModifier3D.Instance {
	return SkeletonModifier3D.Instance{pointers.AsA[gdclass.SkeletonModifier3D](self[0])}
}
func (self class) AsNode3D() Node3D.Advanced {
	return Node3D.Advanced{pointers.AsA[gdclass.Node3D](self[0])}
}
func (self *Extension[T]) AsNode3D() Node3D.Instance { return self.Super().AsNode3D() }
func (self Instance) AsNode3D() Node3D.Instance {
	return Node3D.Instance{pointers.AsA[gdclass.Node3D](self[0])}
}
func (self class) AsNode() Node.Advanced         { return Node.Advanced{pointers.AsA[gdclass.Node](self[0])} }
func (self *Extension[T]) AsNode() Node.Instance { return self.Super().AsNode() }
func (self Instance) AsNode() Node.Instance {
	return Node.Instance{pointers.AsA[gdclass.Node](self[0])}
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(SkeletonModifier3D.Advanced(self.AsSkeletonModifier3D()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(SkeletonModifier3D.Instance(self.AsSkeletonModifier3D()), name)
	}
}
func init() {
	gdclass.Register("LookAtModifier3D", func(ptr gd.Object) any { return Instance{pointers.AsA[gdclass.LookAtModifier3D](ptr)} })
}

type OriginFrom int //gd:LookAtModifier3D.OriginFrom

const (
	/*The bone rest position of the bone specified in [member bone] is used as origin.*/
	OriginFromSelf OriginFrom = 0
	/*The bone global pose position of the bone specified in [member origin_bone] is used as origin.
	  [b]Note:[/b] It is recommended that you select only the parent bone unless you are familiar with the bone processing process. The specified bone pose at the time the [LookAtModifier3D] is processed is used as a reference. In other words, if you specify a child bone and the [LookAtModifier3D] causes the child bone to move, the rendered result and direction will not match.*/
	OriginFromSpecificBone OriginFrom = 1
	/*The global position of the [Node3D] specified in [member origin_external_node] is used as origin.
	  [b]Note:[/b] Same as [constant ORIGIN_FROM_SPECIFIC_BONE], when specifying a [BoneAttachment3D] with a child bone assigned, the rendered result and direction will not match.*/
	OriginFromExternalNode OriginFrom = 2
)
