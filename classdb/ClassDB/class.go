// Code generated by the generate package DO NOT EDIT

// Package ClassDB provides methods for working with ClassDB object instances.
package ClassDB

import "unsafe"
import "sync"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
Provides access to metadata stored for every available class.
*/
type Instance [1]gdclass.ClassDB

func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

var self [1]gdclass.ClassDB
var once sync.Once

func singleton() {
	obj := pointers.Raw[gd.Object]([3]uint64{uint64(gdextension.Host.Objects.Global(pointers.Get(gd.Global.Singletons.ClassDB)))})
	self = *(*[1]gdclass.ClassDB)(unsafe.Pointer(&obj))
}

/*
Returns the names of all the classes available.
*/
func GetClassList() []string { //gd:ClassDB.get_class_list
	once.Do(singleton)
	return []string(Advanced().GetClassList().Strings())
}

/*
Returns the names of all the classes that directly or indirectly inherit from [param class].
*/
func GetInheritersFromClass(class_ string) []string { //gd:ClassDB.get_inheriters_from_class
	once.Do(singleton)
	return []string(Advanced().GetInheritersFromClass(String.Name(String.New(class_))).Strings())
}

/*
Returns the parent class of [param class].
*/
func GetParentClass(class_ string) string { //gd:ClassDB.get_parent_class
	once.Do(singleton)
	return string(Advanced().GetParentClass(String.Name(String.New(class_))).String())
}

/*
Returns whether the specified [param class] is available or not.
*/
func ClassExists(class_ string) bool { //gd:ClassDB.class_exists
	once.Do(singleton)
	return bool(Advanced().ClassExists(String.Name(String.New(class_))))
}

/*
Returns whether [param inherits] is an ancestor of [param class] or not.
*/
func IsParentClass(class_ string, inherits string) bool { //gd:ClassDB.is_parent_class
	once.Do(singleton)
	return bool(Advanced().IsParentClass(String.Name(String.New(class_)), String.Name(String.New(inherits))))
}

/*
Returns [code]true[/code] if objects can be instantiated from the specified [param class], otherwise returns [code]false[/code].
*/
func CanInstantiate(class_ string) bool { //gd:ClassDB.can_instantiate
	once.Do(singleton)
	return bool(Advanced().CanInstantiate(String.Name(String.New(class_))))
}

/*
Creates an instance of [param class].
*/
func Instantiate(class_ string) any { //gd:ClassDB.instantiate
	once.Do(singleton)
	return any(Advanced().Instantiate(String.Name(String.New(class_))).Interface())
}

/*
Returns the API type of [param class]. See [enum APIType].
*/
func ClassGetApiType(class_ string) APIType { //gd:ClassDB.class_get_api_type
	once.Do(singleton)
	return APIType(Advanced().ClassGetApiType(String.Name(String.New(class_))))
}

/*
Returns whether [param class] or its ancestry has a signal called [param signal] or not.
*/
func ClassHasSignal(class_ string, signal string) bool { //gd:ClassDB.class_has_signal
	once.Do(singleton)
	return bool(Advanced().ClassHasSignal(String.Name(String.New(class_)), String.Name(String.New(signal))))
}

/*
Returns the [param signal] data of [param class] or its ancestry. The returned value is a [Dictionary] with the following keys: [code]args[/code], [code]default_args[/code], [code]flags[/code], [code]id[/code], [code]name[/code], [code]return: (class_name, hint, hint_string, name, type, usage)[/code].
*/
func ClassGetSignal(class_ string, signal string) SignalInfo { //gd:ClassDB.class_get_signal
	once.Do(singleton)
	return SignalInfo(gd.DictionaryAs[SignalInfo](Advanced().ClassGetSignal(String.Name(String.New(class_)), String.Name(String.New(signal)))))
}

/*
Returns an array with all the signals of [param class] or its ancestry if [param no_inheritance] is [code]false[/code]. Every element of the array is a [Dictionary] as described in [method class_get_signal].
*/
func ClassGetSignalList(class_ string, no_inheritance bool) []SignalInfo { //gd:ClassDB.class_get_signal_list
	once.Do(singleton)
	return []SignalInfo(gd.ArrayAs[[]SignalInfo](gd.InternalArray(Advanced().ClassGetSignalList(String.Name(String.New(class_)), no_inheritance))))
}

/*
Returns an array with all the signals of [param class] or its ancestry if [param no_inheritance] is [code]false[/code]. Every element of the array is a [Dictionary] as described in [method class_get_signal].
*/
func ClassGetSignalListOptions(class_ string, no_inheritance bool) []SignalInfo { //gd:ClassDB.class_get_signal_list
	once.Do(singleton)
	return []SignalInfo(gd.ArrayAs[[]SignalInfo](gd.InternalArray(Advanced().ClassGetSignalList(String.Name(String.New(class_)), no_inheritance))))
}

/*
Returns an array with all the properties of [param class] or its ancestry if [param no_inheritance] is [code]false[/code].
*/
func ClassGetPropertyList(class_ string, no_inheritance bool) []PropertyInfo { //gd:ClassDB.class_get_property_list
	once.Do(singleton)
	return []PropertyInfo(gd.ArrayAs[[]PropertyInfo](gd.InternalArray(Advanced().ClassGetPropertyList(String.Name(String.New(class_)), no_inheritance))))
}

/*
Returns an array with all the properties of [param class] or its ancestry if [param no_inheritance] is [code]false[/code].
*/
func ClassGetPropertyListOptions(class_ string, no_inheritance bool) []PropertyInfo { //gd:ClassDB.class_get_property_list
	once.Do(singleton)
	return []PropertyInfo(gd.ArrayAs[[]PropertyInfo](gd.InternalArray(Advanced().ClassGetPropertyList(String.Name(String.New(class_)), no_inheritance))))
}

/*
Returns the getter method name of [param property] of [param class].
*/
func ClassGetPropertyGetter(class_ string, property string) string { //gd:ClassDB.class_get_property_getter
	once.Do(singleton)
	return string(Advanced().ClassGetPropertyGetter(String.Name(String.New(class_)), String.Name(String.New(property))).String())
}

/*
Returns the setter method name of [param property] of [param class].
*/
func ClassGetPropertySetter(class_ string, property string) string { //gd:ClassDB.class_get_property_setter
	once.Do(singleton)
	return string(Advanced().ClassGetPropertySetter(String.Name(String.New(class_)), String.Name(String.New(property))).String())
}

/*
Returns the value of [param property] of [param object] or its ancestry.
*/
func ClassGetProperty(obj Object.Instance, property string) any { //gd:ClassDB.class_get_property
	once.Do(singleton)
	return any(Advanced().ClassGetProperty(obj, String.Name(String.New(property))).Interface())
}

/*
Sets [param property] value of [param object] to [param value].
*/
func ClassSetProperty(obj Object.Instance, property string, value any) error { //gd:ClassDB.class_set_property
	once.Do(singleton)
	return error(gd.ToError(Advanced().ClassSetProperty(obj, String.Name(String.New(property)), variant.New(value))))
}

/*
Returns the default value of [param property] of [param class] or its ancestor classes.
*/
func ClassGetPropertyDefaultValue(class_ string, property string) any { //gd:ClassDB.class_get_property_default_value
	once.Do(singleton)
	return any(Advanced().ClassGetPropertyDefaultValue(String.Name(String.New(class_)), String.Name(String.New(property))).Interface())
}

/*
Returns whether [param class] (or its ancestry if [param no_inheritance] is [code]false[/code]) has a method called [param method] or not.
*/
func ClassHasMethod(class_ string, method string, no_inheritance bool) bool { //gd:ClassDB.class_has_method
	once.Do(singleton)
	return bool(Advanced().ClassHasMethod(String.Name(String.New(class_)), String.Name(String.New(method)), no_inheritance))
}

/*
Returns whether [param class] (or its ancestry if [param no_inheritance] is [code]false[/code]) has a method called [param method] or not.
*/
func ClassHasMethodOptions(class_ string, method string, no_inheritance bool) bool { //gd:ClassDB.class_has_method
	once.Do(singleton)
	return bool(Advanced().ClassHasMethod(String.Name(String.New(class_)), String.Name(String.New(method)), no_inheritance))
}

/*
Returns the number of arguments of the method [param method] of [param class] or its ancestry if [param no_inheritance] is [code]false[/code].
*/
func ClassGetMethodArgumentCount(class_ string, method string, no_inheritance bool) int { //gd:ClassDB.class_get_method_argument_count
	once.Do(singleton)
	return int(int(Advanced().ClassGetMethodArgumentCount(String.Name(String.New(class_)), String.Name(String.New(method)), no_inheritance)))
}

/*
Returns the number of arguments of the method [param method] of [param class] or its ancestry if [param no_inheritance] is [code]false[/code].
*/
func ClassGetMethodArgumentCountOptions(class_ string, method string, no_inheritance bool) int { //gd:ClassDB.class_get_method_argument_count
	once.Do(singleton)
	return int(int(Advanced().ClassGetMethodArgumentCount(String.Name(String.New(class_)), String.Name(String.New(method)), no_inheritance)))
}

/*
Returns an array with all the methods of [param class] or its ancestry if [param no_inheritance] is [code]false[/code]. Every element of the array is a [Dictionary] with the following keys: [code]args[/code], [code]default_args[/code], [code]flags[/code], [code]id[/code], [code]name[/code], [code]return: (class_name, hint, hint_string, name, type, usage)[/code].
[b]Note:[/b] In exported release builds the debug info is not available, so the returned dictionaries will contain only method names.
*/
func ClassGetMethodList(class_ string, no_inheritance bool) []PropertyInfo { //gd:ClassDB.class_get_method_list
	once.Do(singleton)
	return []PropertyInfo(gd.ArrayAs[[]PropertyInfo](gd.InternalArray(Advanced().ClassGetMethodList(String.Name(String.New(class_)), no_inheritance))))
}

/*
Returns an array with all the methods of [param class] or its ancestry if [param no_inheritance] is [code]false[/code]. Every element of the array is a [Dictionary] with the following keys: [code]args[/code], [code]default_args[/code], [code]flags[/code], [code]id[/code], [code]name[/code], [code]return: (class_name, hint, hint_string, name, type, usage)[/code].
[b]Note:[/b] In exported release builds the debug info is not available, so the returned dictionaries will contain only method names.
*/
func ClassGetMethodListOptions(class_ string, no_inheritance bool) []PropertyInfo { //gd:ClassDB.class_get_method_list
	once.Do(singleton)
	return []PropertyInfo(gd.ArrayAs[[]PropertyInfo](gd.InternalArray(Advanced().ClassGetMethodList(String.Name(String.New(class_)), no_inheritance))))
}

/*
Calls a static method on a class.
*/
func ClassCallStatic(class_ string, method string, args ...any) any { //gd:ClassDB.class_call_static
	once.Do(singleton)
	var converted_variants = make([]gd.Variant, len(args))
	for i, arg := range args {
		converted_variants[i] = gd.NewVariant(arg)
	}
	return any(Advanced().ClassCallStatic(String.Name(String.New(class_)), String.Name(String.New(method)), converted_variants...).Interface())
}

/*
Returns an array with the names all the integer constants of [param class] or its ancestry.
*/
func ClassGetIntegerConstantList(class_ string, no_inheritance bool) []string { //gd:ClassDB.class_get_integer_constant_list
	once.Do(singleton)
	return []string(Advanced().ClassGetIntegerConstantList(String.Name(String.New(class_)), no_inheritance).Strings())
}

/*
Returns an array with the names all the integer constants of [param class] or its ancestry.
*/
func ClassGetIntegerConstantListOptions(class_ string, no_inheritance bool) []string { //gd:ClassDB.class_get_integer_constant_list
	once.Do(singleton)
	return []string(Advanced().ClassGetIntegerConstantList(String.Name(String.New(class_)), no_inheritance).Strings())
}

/*
Returns whether [param class] or its ancestry has an integer constant called [param name] or not.
*/
func ClassHasIntegerConstant(class_ string, name string) bool { //gd:ClassDB.class_has_integer_constant
	once.Do(singleton)
	return bool(Advanced().ClassHasIntegerConstant(String.Name(String.New(class_)), String.Name(String.New(name))))
}

/*
Returns the value of the integer constant [param name] of [param class] or its ancestry. Always returns 0 when the constant could not be found.
*/
func ClassGetIntegerConstant(class_ string, name string) int { //gd:ClassDB.class_get_integer_constant
	once.Do(singleton)
	return int(int(Advanced().ClassGetIntegerConstant(String.Name(String.New(class_)), String.Name(String.New(name)))))
}

/*
Returns whether [param class] or its ancestry has an enum called [param name] or not.
*/
func ClassHasEnum(class_ string, name string, no_inheritance bool) bool { //gd:ClassDB.class_has_enum
	once.Do(singleton)
	return bool(Advanced().ClassHasEnum(String.Name(String.New(class_)), String.Name(String.New(name)), no_inheritance))
}

/*
Returns whether [param class] or its ancestry has an enum called [param name] or not.
*/
func ClassHasEnumOptions(class_ string, name string, no_inheritance bool) bool { //gd:ClassDB.class_has_enum
	once.Do(singleton)
	return bool(Advanced().ClassHasEnum(String.Name(String.New(class_)), String.Name(String.New(name)), no_inheritance))
}

/*
Returns an array with all the enums of [param class] or its ancestry.
*/
func ClassGetEnumList(class_ string, no_inheritance bool) []string { //gd:ClassDB.class_get_enum_list
	once.Do(singleton)
	return []string(Advanced().ClassGetEnumList(String.Name(String.New(class_)), no_inheritance).Strings())
}

/*
Returns an array with all the enums of [param class] or its ancestry.
*/
func ClassGetEnumListOptions(class_ string, no_inheritance bool) []string { //gd:ClassDB.class_get_enum_list
	once.Do(singleton)
	return []string(Advanced().ClassGetEnumList(String.Name(String.New(class_)), no_inheritance).Strings())
}

/*
Returns an array with all the keys in [param enum] of [param class] or its ancestry.
*/
func ClassGetEnumConstants(class_ string, enum string, no_inheritance bool) []string { //gd:ClassDB.class_get_enum_constants
	once.Do(singleton)
	return []string(Advanced().ClassGetEnumConstants(String.Name(String.New(class_)), String.Name(String.New(enum)), no_inheritance).Strings())
}

/*
Returns an array with all the keys in [param enum] of [param class] or its ancestry.
*/
func ClassGetEnumConstantsOptions(class_ string, enum string, no_inheritance bool) []string { //gd:ClassDB.class_get_enum_constants
	once.Do(singleton)
	return []string(Advanced().ClassGetEnumConstants(String.Name(String.New(class_)), String.Name(String.New(enum)), no_inheritance).Strings())
}

/*
Returns which enum the integer constant [param name] of [param class] or its ancestry belongs to.
*/
func ClassGetIntegerConstantEnum(class_ string, name string, no_inheritance bool) string { //gd:ClassDB.class_get_integer_constant_enum
	once.Do(singleton)
	return string(Advanced().ClassGetIntegerConstantEnum(String.Name(String.New(class_)), String.Name(String.New(name)), no_inheritance).String())
}

/*
Returns which enum the integer constant [param name] of [param class] or its ancestry belongs to.
*/
func ClassGetIntegerConstantEnumOptions(class_ string, name string, no_inheritance bool) string { //gd:ClassDB.class_get_integer_constant_enum
	once.Do(singleton)
	return string(Advanced().ClassGetIntegerConstantEnum(String.Name(String.New(class_)), String.Name(String.New(name)), no_inheritance).String())
}

/*
Returns whether [param class] (or its ancestor classes if [param no_inheritance] is [code]false[/code]) has an enum called [param enum] that is a bitfield.
*/
func IsClassEnumBitfield(class_ string, enum string, no_inheritance bool) bool { //gd:ClassDB.is_class_enum_bitfield
	once.Do(singleton)
	return bool(Advanced().IsClassEnumBitfield(String.Name(String.New(class_)), String.Name(String.New(enum)), no_inheritance))
}

/*
Returns whether [param class] (or its ancestor classes if [param no_inheritance] is [code]false[/code]) has an enum called [param enum] that is a bitfield.
*/
func IsClassEnumBitfieldOptions(class_ string, enum string, no_inheritance bool) bool { //gd:ClassDB.is_class_enum_bitfield
	once.Do(singleton)
	return bool(Advanced().IsClassEnumBitfield(String.Name(String.New(class_)), String.Name(String.New(enum)), no_inheritance))
}

/*
Returns whether this [param class] is enabled or not.
*/
func IsClassEnabled(class_ string) bool { //gd:ClassDB.is_class_enabled
	once.Do(singleton)
	return bool(Advanced().IsClassEnabled(String.Name(String.New(class_))))
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
func Advanced() class { once.Do(singleton); return self }

type class [1]gdclass.ClassDB

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }

/*
Returns the names of all the classes available.
*/
//go:nosplit
func (self class) GetClassList() Packed.Strings { //gd:ClassDB.get_class_list
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.ClassDB.Bind_get_class_list), gdextension.SizePackedArray, unsafe.Pointer(&struct{}{}))
	var ret = Packed.Strings(Array.Through(gd.PackedStringArrayProxy{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

/*
Returns the names of all the classes that directly or indirectly inherit from [param class].
*/
//go:nosplit
func (self class) GetInheritersFromClass(class_ String.Name) Packed.Strings { //gd:ClassDB.get_inheriters_from_class
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.ClassDB.Bind_get_inheriters_from_class), gdextension.SizePackedArray|(gdextension.SizeStringName<<4), unsafe.Pointer(&struct{ class_ gdextension.StringName }{pointers.Get(gd.InternalStringName(class_))}))
	var ret = Packed.Strings(Array.Through(gd.PackedStringArrayProxy{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

/*
Returns the parent class of [param class].
*/
//go:nosplit
func (self class) GetParentClass(class_ String.Name) String.Name { //gd:ClassDB.get_parent_class
	var r_ret = gdextension.Call[gdextension.StringName](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.ClassDB.Bind_get_parent_class), gdextension.SizeStringName|(gdextension.SizeStringName<<4), unsafe.Pointer(&struct{ class_ gdextension.StringName }{pointers.Get(gd.InternalStringName(class_))}))
	var ret = String.Name(String.Via(gd.StringNameProxy{}, pointers.Pack(pointers.New[gd.StringName](r_ret))))
	return ret
}

/*
Returns whether the specified [param class] is available or not.
*/
//go:nosplit
func (self class) ClassExists(class_ String.Name) bool { //gd:ClassDB.class_exists
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.ClassDB.Bind_class_exists), gdextension.SizeBool|(gdextension.SizeStringName<<4), unsafe.Pointer(&struct{ class_ gdextension.StringName }{pointers.Get(gd.InternalStringName(class_))}))
	var ret = r_ret
	return ret
}

/*
Returns whether [param inherits] is an ancestor of [param class] or not.
*/
//go:nosplit
func (self class) IsParentClass(class_ String.Name, inherits String.Name) bool { //gd:ClassDB.is_parent_class
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.ClassDB.Bind_is_parent_class), gdextension.SizeBool|(gdextension.SizeStringName<<4)|(gdextension.SizeStringName<<8), unsafe.Pointer(&struct {
		class_   gdextension.StringName
		inherits gdextension.StringName
	}{pointers.Get(gd.InternalStringName(class_)), pointers.Get(gd.InternalStringName(inherits))}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if objects can be instantiated from the specified [param class], otherwise returns [code]false[/code].
*/
//go:nosplit
func (self class) CanInstantiate(class_ String.Name) bool { //gd:ClassDB.can_instantiate
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.ClassDB.Bind_can_instantiate), gdextension.SizeBool|(gdextension.SizeStringName<<4), unsafe.Pointer(&struct{ class_ gdextension.StringName }{pointers.Get(gd.InternalStringName(class_))}))
	var ret = r_ret
	return ret
}

/*
Creates an instance of [param class].
*/
//go:nosplit
func (self class) Instantiate(class_ String.Name) variant.Any { //gd:ClassDB.instantiate
	var r_ret = gdextension.Call[gdextension.Variant](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.ClassDB.Bind_instantiate), gdextension.SizeVariant|(gdextension.SizeStringName<<4), unsafe.Pointer(&struct{ class_ gdextension.StringName }{pointers.Get(gd.InternalStringName(class_))}))
	var ret = variant.Implementation(gd.VariantProxy{}, pointers.Pack(pointers.New[gd.Variant](r_ret)))
	return ret
}

/*
Returns the API type of [param class]. See [enum APIType].
*/
//go:nosplit
func (self class) ClassGetApiType(class_ String.Name) APIType { //gd:ClassDB.class_get_api_type
	var r_ret = gdextension.Call[APIType](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.ClassDB.Bind_class_get_api_type), gdextension.SizeInt|(gdextension.SizeStringName<<4), unsafe.Pointer(&struct{ class_ gdextension.StringName }{pointers.Get(gd.InternalStringName(class_))}))
	var ret = r_ret
	return ret
}

/*
Returns whether [param class] or its ancestry has a signal called [param signal] or not.
*/
//go:nosplit
func (self class) ClassHasSignal(class_ String.Name, signal String.Name) bool { //gd:ClassDB.class_has_signal
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.ClassDB.Bind_class_has_signal), gdextension.SizeBool|(gdextension.SizeStringName<<4)|(gdextension.SizeStringName<<8), unsafe.Pointer(&struct {
		class_ gdextension.StringName
		signal gdextension.StringName
	}{pointers.Get(gd.InternalStringName(class_)), pointers.Get(gd.InternalStringName(signal))}))
	var ret = r_ret
	return ret
}

/*
Returns the [param signal] data of [param class] or its ancestry. The returned value is a [Dictionary] with the following keys: [code]args[/code], [code]default_args[/code], [code]flags[/code], [code]id[/code], [code]name[/code], [code]return: (class_name, hint, hint_string, name, type, usage)[/code].
*/
//go:nosplit
func (self class) ClassGetSignal(class_ String.Name, signal String.Name) Dictionary.Any { //gd:ClassDB.class_get_signal
	var r_ret = gdextension.Call[gdextension.Dictionary](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.ClassDB.Bind_class_get_signal), gdextension.SizeDictionary|(gdextension.SizeStringName<<4)|(gdextension.SizeStringName<<8), unsafe.Pointer(&struct {
		class_ gdextension.StringName
		signal gdextension.StringName
	}{pointers.Get(gd.InternalStringName(class_)), pointers.Get(gd.InternalStringName(signal))}))
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret)))
	return ret
}

/*
Returns an array with all the signals of [param class] or its ancestry if [param no_inheritance] is [code]false[/code]. Every element of the array is a [Dictionary] as described in [method class_get_signal].
*/
//go:nosplit
func (self class) ClassGetSignalList(class_ String.Name, no_inheritance bool) Array.Contains[Dictionary.Any] { //gd:ClassDB.class_get_signal_list
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.ClassDB.Bind_class_get_signal_list), gdextension.SizeArray|(gdextension.SizeStringName<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		class_         gdextension.StringName
		no_inheritance bool
	}{pointers.Get(gd.InternalStringName(class_)), no_inheritance}))
	var ret = Array.Through(gd.ArrayProxy[Dictionary.Any]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

/*
Returns an array with all the properties of [param class] or its ancestry if [param no_inheritance] is [code]false[/code].
*/
//go:nosplit
func (self class) ClassGetPropertyList(class_ String.Name, no_inheritance bool) Array.Contains[Dictionary.Any] { //gd:ClassDB.class_get_property_list
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.ClassDB.Bind_class_get_property_list), gdextension.SizeArray|(gdextension.SizeStringName<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		class_         gdextension.StringName
		no_inheritance bool
	}{pointers.Get(gd.InternalStringName(class_)), no_inheritance}))
	var ret = Array.Through(gd.ArrayProxy[Dictionary.Any]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

/*
Returns the getter method name of [param property] of [param class].
*/
//go:nosplit
func (self class) ClassGetPropertyGetter(class_ String.Name, property String.Name) String.Name { //gd:ClassDB.class_get_property_getter
	var r_ret = gdextension.Call[gdextension.StringName](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.ClassDB.Bind_class_get_property_getter), gdextension.SizeStringName|(gdextension.SizeStringName<<4)|(gdextension.SizeStringName<<8), unsafe.Pointer(&struct {
		class_   gdextension.StringName
		property gdextension.StringName
	}{pointers.Get(gd.InternalStringName(class_)), pointers.Get(gd.InternalStringName(property))}))
	var ret = String.Name(String.Via(gd.StringNameProxy{}, pointers.Pack(pointers.New[gd.StringName](r_ret))))
	return ret
}

/*
Returns the setter method name of [param property] of [param class].
*/
//go:nosplit
func (self class) ClassGetPropertySetter(class_ String.Name, property String.Name) String.Name { //gd:ClassDB.class_get_property_setter
	var r_ret = gdextension.Call[gdextension.StringName](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.ClassDB.Bind_class_get_property_setter), gdextension.SizeStringName|(gdextension.SizeStringName<<4)|(gdextension.SizeStringName<<8), unsafe.Pointer(&struct {
		class_   gdextension.StringName
		property gdextension.StringName
	}{pointers.Get(gd.InternalStringName(class_)), pointers.Get(gd.InternalStringName(property))}))
	var ret = String.Name(String.Via(gd.StringNameProxy{}, pointers.Pack(pointers.New[gd.StringName](r_ret))))
	return ret
}

/*
Returns the value of [param property] of [param object] or its ancestry.
*/
//go:nosplit
func (self class) ClassGetProperty(obj [1]gd.Object, property String.Name) variant.Any { //gd:ClassDB.class_get_property
	var r_ret = gdextension.Call[gdextension.Variant](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.ClassDB.Bind_class_get_property), gdextension.SizeVariant|(gdextension.SizeObject<<4)|(gdextension.SizeStringName<<8), unsafe.Pointer(&struct {
		obj      gdextension.Object
		property gdextension.StringName
	}{gdextension.Object(gd.ObjectChecked(obj[0].AsObject())), pointers.Get(gd.InternalStringName(property))}))
	var ret = variant.Implementation(gd.VariantProxy{}, pointers.Pack(pointers.New[gd.Variant](r_ret)))
	return ret
}

/*
Sets [param property] value of [param object] to [param value].
*/
//go:nosplit
func (self class) ClassSetProperty(obj [1]gd.Object, property String.Name, value variant.Any) Error.Code { //gd:ClassDB.class_set_property
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.ClassDB.Bind_class_set_property), gdextension.SizeInt|(gdextension.SizeObject<<4)|(gdextension.SizeStringName<<8)|(gdextension.SizeVariant<<12), unsafe.Pointer(&struct {
		obj      gdextension.Object
		property gdextension.StringName
		value    gdextension.Variant
	}{gdextension.Object(gd.ObjectChecked(obj[0].AsObject())), pointers.Get(gd.InternalStringName(property)), gdextension.Variant(pointers.Get(gd.InternalVariant(value)))}))
	var ret = Error.Code(r_ret)
	return ret
}

/*
Returns the default value of [param property] of [param class] or its ancestor classes.
*/
//go:nosplit
func (self class) ClassGetPropertyDefaultValue(class_ String.Name, property String.Name) variant.Any { //gd:ClassDB.class_get_property_default_value
	var r_ret = gdextension.Call[gdextension.Variant](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.ClassDB.Bind_class_get_property_default_value), gdextension.SizeVariant|(gdextension.SizeStringName<<4)|(gdextension.SizeStringName<<8), unsafe.Pointer(&struct {
		class_   gdextension.StringName
		property gdextension.StringName
	}{pointers.Get(gd.InternalStringName(class_)), pointers.Get(gd.InternalStringName(property))}))
	var ret = variant.Implementation(gd.VariantProxy{}, pointers.Pack(pointers.New[gd.Variant](r_ret)))
	return ret
}

/*
Returns whether [param class] (or its ancestry if [param no_inheritance] is [code]false[/code]) has a method called [param method] or not.
*/
//go:nosplit
func (self class) ClassHasMethod(class_ String.Name, method String.Name, no_inheritance bool) bool { //gd:ClassDB.class_has_method
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.ClassDB.Bind_class_has_method), gdextension.SizeBool|(gdextension.SizeStringName<<4)|(gdextension.SizeStringName<<8)|(gdextension.SizeBool<<12), unsafe.Pointer(&struct {
		class_         gdextension.StringName
		method         gdextension.StringName
		no_inheritance bool
	}{pointers.Get(gd.InternalStringName(class_)), pointers.Get(gd.InternalStringName(method)), no_inheritance}))
	var ret = r_ret
	return ret
}

/*
Returns the number of arguments of the method [param method] of [param class] or its ancestry if [param no_inheritance] is [code]false[/code].
*/
//go:nosplit
func (self class) ClassGetMethodArgumentCount(class_ String.Name, method String.Name, no_inheritance bool) int64 { //gd:ClassDB.class_get_method_argument_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.ClassDB.Bind_class_get_method_argument_count), gdextension.SizeInt|(gdextension.SizeStringName<<4)|(gdextension.SizeStringName<<8)|(gdextension.SizeBool<<12), unsafe.Pointer(&struct {
		class_         gdextension.StringName
		method         gdextension.StringName
		no_inheritance bool
	}{pointers.Get(gd.InternalStringName(class_)), pointers.Get(gd.InternalStringName(method)), no_inheritance}))
	var ret = r_ret
	return ret
}

/*
Returns an array with all the methods of [param class] or its ancestry if [param no_inheritance] is [code]false[/code]. Every element of the array is a [Dictionary] with the following keys: [code]args[/code], [code]default_args[/code], [code]flags[/code], [code]id[/code], [code]name[/code], [code]return: (class_name, hint, hint_string, name, type, usage)[/code].
[b]Note:[/b] In exported release builds the debug info is not available, so the returned dictionaries will contain only method names.
*/
//go:nosplit
func (self class) ClassGetMethodList(class_ String.Name, no_inheritance bool) Array.Contains[Dictionary.Any] { //gd:ClassDB.class_get_method_list
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.ClassDB.Bind_class_get_method_list), gdextension.SizeArray|(gdextension.SizeStringName<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		class_         gdextension.StringName
		no_inheritance bool
	}{pointers.Get(gd.InternalStringName(class_)), no_inheritance}))
	var ret = Array.Through(gd.ArrayProxy[Dictionary.Any]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

/*
Calls a static method on a class.
*/
//go:nosplit
func (self class) ClassCallStatic(class_ String.Name, method String.Name, args ...gd.Variant) variant.Any { //gd:ClassDB.class_call_static
	var fixed = [...]gdextension.Variant{gdextension.Variant(pointers.Get(gd.NewVariant(class_))), gdextension.Variant(pointers.Get(gd.NewVariant(method)))}
	ret, err := gdextension.MethodForClass(gd.Global.Methods.ClassDB.Bind_class_call_static).Call(gd.ObjectChecked(self.AsObject()), fixed[:]...)
	if err != nil {
		panic(err)
	}
	return gd.VariantAs[variant.Any](pointers.New[gd.Variant]([3]uint64(ret)))
}

/*
Returns an array with the names all the integer constants of [param class] or its ancestry.
*/
//go:nosplit
func (self class) ClassGetIntegerConstantList(class_ String.Name, no_inheritance bool) Packed.Strings { //gd:ClassDB.class_get_integer_constant_list
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.ClassDB.Bind_class_get_integer_constant_list), gdextension.SizePackedArray|(gdextension.SizeStringName<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		class_         gdextension.StringName
		no_inheritance bool
	}{pointers.Get(gd.InternalStringName(class_)), no_inheritance}))
	var ret = Packed.Strings(Array.Through(gd.PackedStringArrayProxy{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

/*
Returns whether [param class] or its ancestry has an integer constant called [param name] or not.
*/
//go:nosplit
func (self class) ClassHasIntegerConstant(class_ String.Name, name String.Name) bool { //gd:ClassDB.class_has_integer_constant
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.ClassDB.Bind_class_has_integer_constant), gdextension.SizeBool|(gdextension.SizeStringName<<4)|(gdextension.SizeStringName<<8), unsafe.Pointer(&struct {
		class_ gdextension.StringName
		name   gdextension.StringName
	}{pointers.Get(gd.InternalStringName(class_)), pointers.Get(gd.InternalStringName(name))}))
	var ret = r_ret
	return ret
}

/*
Returns the value of the integer constant [param name] of [param class] or its ancestry. Always returns 0 when the constant could not be found.
*/
//go:nosplit
func (self class) ClassGetIntegerConstant(class_ String.Name, name String.Name) int64 { //gd:ClassDB.class_get_integer_constant
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.ClassDB.Bind_class_get_integer_constant), gdextension.SizeInt|(gdextension.SizeStringName<<4)|(gdextension.SizeStringName<<8), unsafe.Pointer(&struct {
		class_ gdextension.StringName
		name   gdextension.StringName
	}{pointers.Get(gd.InternalStringName(class_)), pointers.Get(gd.InternalStringName(name))}))
	var ret = r_ret
	return ret
}

/*
Returns whether [param class] or its ancestry has an enum called [param name] or not.
*/
//go:nosplit
func (self class) ClassHasEnum(class_ String.Name, name String.Name, no_inheritance bool) bool { //gd:ClassDB.class_has_enum
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.ClassDB.Bind_class_has_enum), gdextension.SizeBool|(gdextension.SizeStringName<<4)|(gdextension.SizeStringName<<8)|(gdextension.SizeBool<<12), unsafe.Pointer(&struct {
		class_         gdextension.StringName
		name           gdextension.StringName
		no_inheritance bool
	}{pointers.Get(gd.InternalStringName(class_)), pointers.Get(gd.InternalStringName(name)), no_inheritance}))
	var ret = r_ret
	return ret
}

/*
Returns an array with all the enums of [param class] or its ancestry.
*/
//go:nosplit
func (self class) ClassGetEnumList(class_ String.Name, no_inheritance bool) Packed.Strings { //gd:ClassDB.class_get_enum_list
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.ClassDB.Bind_class_get_enum_list), gdextension.SizePackedArray|(gdextension.SizeStringName<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		class_         gdextension.StringName
		no_inheritance bool
	}{pointers.Get(gd.InternalStringName(class_)), no_inheritance}))
	var ret = Packed.Strings(Array.Through(gd.PackedStringArrayProxy{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

/*
Returns an array with all the keys in [param enum] of [param class] or its ancestry.
*/
//go:nosplit
func (self class) ClassGetEnumConstants(class_ String.Name, enum String.Name, no_inheritance bool) Packed.Strings { //gd:ClassDB.class_get_enum_constants
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.ClassDB.Bind_class_get_enum_constants), gdextension.SizePackedArray|(gdextension.SizeStringName<<4)|(gdextension.SizeStringName<<8)|(gdextension.SizeBool<<12), unsafe.Pointer(&struct {
		class_         gdextension.StringName
		enum           gdextension.StringName
		no_inheritance bool
	}{pointers.Get(gd.InternalStringName(class_)), pointers.Get(gd.InternalStringName(enum)), no_inheritance}))
	var ret = Packed.Strings(Array.Through(gd.PackedStringArrayProxy{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

/*
Returns which enum the integer constant [param name] of [param class] or its ancestry belongs to.
*/
//go:nosplit
func (self class) ClassGetIntegerConstantEnum(class_ String.Name, name String.Name, no_inheritance bool) String.Name { //gd:ClassDB.class_get_integer_constant_enum
	var r_ret = gdextension.Call[gdextension.StringName](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.ClassDB.Bind_class_get_integer_constant_enum), gdextension.SizeStringName|(gdextension.SizeStringName<<4)|(gdextension.SizeStringName<<8)|(gdextension.SizeBool<<12), unsafe.Pointer(&struct {
		class_         gdextension.StringName
		name           gdextension.StringName
		no_inheritance bool
	}{pointers.Get(gd.InternalStringName(class_)), pointers.Get(gd.InternalStringName(name)), no_inheritance}))
	var ret = String.Name(String.Via(gd.StringNameProxy{}, pointers.Pack(pointers.New[gd.StringName](r_ret))))
	return ret
}

/*
Returns whether [param class] (or its ancestor classes if [param no_inheritance] is [code]false[/code]) has an enum called [param enum] that is a bitfield.
*/
//go:nosplit
func (self class) IsClassEnumBitfield(class_ String.Name, enum String.Name, no_inheritance bool) bool { //gd:ClassDB.is_class_enum_bitfield
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.ClassDB.Bind_is_class_enum_bitfield), gdextension.SizeBool|(gdextension.SizeStringName<<4)|(gdextension.SizeStringName<<8)|(gdextension.SizeBool<<12), unsafe.Pointer(&struct {
		class_         gdextension.StringName
		enum           gdextension.StringName
		no_inheritance bool
	}{pointers.Get(gd.InternalStringName(class_)), pointers.Get(gd.InternalStringName(enum)), no_inheritance}))
	var ret = r_ret
	return ret
}

/*
Returns whether this [param class] is enabled or not.
*/
//go:nosplit
func (self class) IsClassEnabled(class_ String.Name) bool { //gd:ClassDB.is_class_enabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.ClassDB.Bind_is_class_enabled), gdextension.SizeBool|(gdextension.SizeStringName<<4), unsafe.Pointer(&struct{ class_ gdextension.StringName }{pointers.Get(gd.InternalStringName(class_))}))
	var ret = r_ret
	return ret
}
func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Object.Advanced(self.AsObject()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Object.Instance(self.AsObject()), name)
	}
}
func init() {
	gdclass.Register("ClassDB", func(ptr gd.Object) any { return [1]gdclass.ClassDB{*(*gdclass.ClassDB)(unsafe.Pointer(&ptr))} })
}

type APIType int //gd:ClassDB.APIType

const (
	/*Native Core class type.*/
	ApiCore APIType = 0
	/*Native Editor class type.*/
	ApiEditor APIType = 1
	/*GDExtension class type.*/
	ApiExtension APIType = 2
	/*GDExtension Editor class type.*/
	ApiEditorExtension APIType = 3
	/*Unknown class type.*/
	ApiNone APIType = 4
)

type MethodFlags int //gd:MethodFlags

const (
	/*Flag for a normal method.*/
	MethodFlagNormal MethodFlags = 1
	/*Flag for an editor method.*/
	MethodFlagEditor MethodFlags = 2
	/*Flag for a constant method.*/
	MethodFlagConst MethodFlags = 4
	/*Flag for a virtual method.*/
	MethodFlagVirtual MethodFlags = 8
	/*Flag for a method with a variable number of arguments.*/
	MethodFlagVararg MethodFlags = 16
	/*Flag for a static method.*/
	MethodFlagStatic MethodFlags = 32
	/*Used internally. Allows to not dump core virtual methods (such as [method Object._notification]) to the JSON API.*/
	MethodFlagObjectCore MethodFlags = 64
	/*Flag for a virtual method that is required.*/
	MethodFlagVirtualRequired MethodFlags = 128
	/*Default method flags (normal).*/
	MethodFlagsDefault MethodFlags = 1
)

type PropertyHint int //gd:PropertyHint

const (
	/*The property has no hint for the editor.*/
	PropertyHintNone PropertyHint = 0
	/*Hints that an [int] or [float] property should be within a range specified via the hint string [code]"min,max"[/code] or [code]"min,max,step"[/code]. The hint string can optionally include [code]"or_greater"[/code] and/or [code]"or_less"[/code] to allow manual input going respectively above the max or below the min values.
	  [b]Example:[/b] [code]"-360,360,1,or_greater,or_less"[/code].
	  Additionally, other keywords can be included: [code]"exp"[/code] for exponential range editing, [code]"radians_as_degrees"[/code] for editing radian angles in degrees (the range values are also in degrees), [code]"degrees"[/code] to hint at an angle and [code]"hide_slider"[/code] to hide the slider.*/
	PropertyHintRange PropertyHint = 1
	/*Hints that an [int] or [String] property is an enumerated value to pick in a list specified via a hint string.
	  The hint string is a comma separated list of names such as [code]"Hello,Something,Else"[/code]. Whitespaces are [b]not[/b] removed from either end of a name. For integer properties, the first name in the list has value 0, the next 1, and so on. Explicit values can also be specified by appending [code]:integer[/code] to the name, e.g. [code]"Zero,One,Three:3,Four,Six:6"[/code].*/
	PropertyHintEnum PropertyHint = 2
	/*Hints that a [String] property can be an enumerated value to pick in a list specified via a hint string such as [code]"Hello,Something,Else"[/code].
	  Unlike [constant PROPERTY_HINT_ENUM], a property with this hint still accepts arbitrary values and can be empty. The list of values serves to suggest possible values.*/
	PropertyHintEnumSuggestion PropertyHint = 3
	/*Hints that a [float] property should be edited via an exponential easing function. The hint string can include [code]"attenuation"[/code] to flip the curve horizontally and/or [code]"positive_only"[/code] to exclude in/out easing and limit values to be greater than or equal to zero.*/
	PropertyHintExpEasing PropertyHint = 4
	/*Hints that a vector property should allow its components to be linked. For example, this allows [member Vector2.x] and [member Vector2.y] to be edited together.*/
	PropertyHintLink PropertyHint = 5
	/*Hints that an [int] property is a bitmask with named bit flags.
	  The hint string is a comma separated list of names such as [code]"Bit0,Bit1,Bit2,Bit3"[/code]. Whitespaces are [b]not[/b] removed from either end of a name. The first name in the list has value 1, the next 2, then 4, 8, 16 and so on. Explicit values can also be specified by appending [code]:integer[/code] to the name, e.g. [code]"A:4,B:8,C:16"[/code]. You can also combine several flags ([code]"A:4,B:8,AB:12,C:16"[/code]).
	  [b]Note:[/b] A flag value must be at least [code]1[/code] and at most [code]2 ** 32 - 1[/code].
	  [b]Note:[/b] Unlike [constant PROPERTY_HINT_ENUM], the previous explicit value is not taken into account. For the hint [code]"A:16,B,C"[/code], A is 16, B is 2, C is 4.*/
	PropertyHintFlags PropertyHint = 6
	/*Hints that an [int] property is a bitmask using the optionally named 2D render layers.*/
	PropertyHintLayers2dRender PropertyHint = 7
	/*Hints that an [int] property is a bitmask using the optionally named 2D physics layers.*/
	PropertyHintLayers2dPhysics PropertyHint = 8
	/*Hints that an [int] property is a bitmask using the optionally named 2D navigation layers.*/
	PropertyHintLayers2dNavigation PropertyHint = 9
	/*Hints that an [int] property is a bitmask using the optionally named 3D render layers.*/
	PropertyHintLayers3dRender PropertyHint = 10
	/*Hints that an [int] property is a bitmask using the optionally named 3D physics layers.*/
	PropertyHintLayers3dPhysics PropertyHint = 11
	/*Hints that an [int] property is a bitmask using the optionally named 3D navigation layers.*/
	PropertyHintLayers3dNavigation PropertyHint = 12
	/*Hints that an integer property is a bitmask using the optionally named avoidance layers.*/
	PropertyHintLayersAvoidance PropertyHint = 37
	/*Hints that a [String] property is a path to a file. Editing it will show a file dialog for picking the path. The hint string can be a set of filters with wildcards like [code]"*.png,*.jpg"[/code].*/
	PropertyHintFile PropertyHint = 13
	/*Hints that a [String] property is a path to a directory. Editing it will show a file dialog for picking the path.*/
	PropertyHintDir PropertyHint = 14
	/*Hints that a [String] property is an absolute path to a file outside the project folder. Editing it will show a file dialog for picking the path. The hint string can be a set of filters with wildcards, like [code]"*.png,*.jpg"[/code].*/
	PropertyHintGlobalFile PropertyHint = 15
	/*Hints that a [String] property is an absolute path to a directory outside the project folder. Editing it will show a file dialog for picking the path.*/
	PropertyHintGlobalDir PropertyHint = 16
	/*Hints that a property is an instance of a [Resource]-derived type, optionally specified via the hint string (e.g. [code]"Texture2D"[/code]). Editing it will show a popup menu of valid resource types to instantiate.*/
	PropertyHintResourceType PropertyHint = 17
	/*Hints that a [String] property is text with line breaks. Editing it will show a text input field where line breaks can be typed.*/
	PropertyHintMultilineText PropertyHint = 18
	/*Hints that a [String] property is an [Expression].*/
	PropertyHintExpression PropertyHint = 19
	/*Hints that a [String] property should show a placeholder text on its input field, if empty. The hint string is the placeholder text to use.*/
	PropertyHintPlaceholderText PropertyHint = 20
	/*Hints that a [Color] property should be edited without affecting its transparency ([member Color.a] is not editable).*/
	PropertyHintColorNoAlpha PropertyHint = 21
	/*Hints that the property's value is an object encoded as object ID, with its type specified in the hint string. Used by the debugger.*/
	PropertyHintObjectId PropertyHint = 22
	/*If a property is [String], hints that the property represents a particular type (class). This allows to select a type from the create dialog. The property will store the selected type as a string.
	  If a property is [Array], hints the editor how to show elements. The [code]hint_string[/code] must encode nested types using [code]":"[/code] and [code]"/"[/code].
	  [codeblocks]
	  [gdscript]
	  # Array of elem_type.
	  hint_string = "%d:" % [elem_type]
	  hint_string = "%d/%d:%s" % [elem_type, elem_hint, elem_hint_string]
	  # Two-dimensional array of elem_type (array of arrays of elem_type).
	  hint_string = "%d:%d:" % [TYPE_ARRAY, elem_type]
	  hint_string = "%d:%d/%d:%s" % [TYPE_ARRAY, elem_type, elem_hint, elem_hint_string]
	  # Three-dimensional array of elem_type (array of arrays of arrays of elem_type).
	  hint_string = "%d:%d:%d:" % [TYPE_ARRAY, TYPE_ARRAY, elem_type]
	  hint_string = "%d:%d:%d/%d:%s" % [TYPE_ARRAY, TYPE_ARRAY, elem_type, elem_hint, elem_hint_string]
	  [/gdscript]
	  [csharp]
	  // Array of elemType.
	  hintString = $"{elemType:D}:";
	  hintString = $"{elemType:}/{elemHint:D}:{elemHintString}";
	  // Two-dimensional array of elemType (array of arrays of elemType).
	  hintString = $"{Variant.Type.Array:D}:{elemType:D}:";
	  hintString = $"{Variant.Type.Array:D}:{elemType:D}/{elemHint:D}:{elemHintString}";
	  // Three-dimensional array of elemType (array of arrays of arrays of elemType).
	  hintString = $"{Variant.Type.Array:D}:{Variant.Type.Array:D}:{elemType:D}:";
	  hintString = $"{Variant.Type.Array:D}:{Variant.Type.Array:D}:{elemType:D}/{elemHint:D}:{elemHintString}";
	  [/csharp]
	  [/codeblocks]
	  [b]Examples:[/b]
	  [codeblocks]
	  [gdscript]
	  hint_string = "%d:" % [TYPE_INT] # Array of integers.
	  hint_string = "%d/%d:1,10,1" % [TYPE_INT, PROPERTY_HINT_RANGE] # Array of integers (in range from 1 to 10).
	  hint_string = "%d/%d:Zero,One,Two" % [TYPE_INT, PROPERTY_HINT_ENUM] # Array of integers (an enum).
	  hint_string = "%d/%d:Zero,One,Three:3,Six:6" % [TYPE_INT, PROPERTY_HINT_ENUM] # Array of integers (an enum).
	  hint_string = "%d/%d:*.png" % [TYPE_STRING, PROPERTY_HINT_FILE] # Array of strings (file paths).
	  hint_string = "%d/%d:Texture2D" % [TYPE_OBJECT, PROPERTY_HINT_RESOURCE_TYPE] # Array of textures.

	  hint_string = "%d:%d:" % [TYPE_ARRAY, TYPE_FLOAT] # Two-dimensional array of floats.
	  hint_string = "%d:%d/%d:" % [TYPE_ARRAY, TYPE_STRING, PROPERTY_HINT_MULTILINE_TEXT] # Two-dimensional array of multiline strings.
	  hint_string = "%d:%d/%d:-1,1,0.1" % [TYPE_ARRAY, TYPE_FLOAT, PROPERTY_HINT_RANGE] # Two-dimensional array of floats (in range from -1 to 1).
	  hint_string = "%d:%d/%d:Texture2D" % [TYPE_ARRAY, TYPE_OBJECT, PROPERTY_HINT_RESOURCE_TYPE] # Two-dimensional array of textures.
	  [/gdscript]
	  [csharp]
	  hintString = $"{Variant.Type.Int:D}/{PropertyHint.Range:D}:1,10,1"; // Array of integers (in range from 1 to 10).
	  hintString = $"{Variant.Type.Int:D}/{PropertyHint.Enum:D}:Zero,One,Two"; // Array of integers (an enum).
	  hintString = $"{Variant.Type.Int:D}/{PropertyHint.Enum:D}:Zero,One,Three:3,Six:6"; // Array of integers (an enum).
	  hintString = $"{Variant.Type.String:D}/{PropertyHint.File:D}:*.png"; // Array of strings (file paths).
	  hintString = $"{Variant.Type.Object:D}/{PropertyHint.ResourceType:D}:Texture2D"; // Array of textures.

	  hintString = $"{Variant.Type.Array:D}:{Variant.Type.Float:D}:"; // Two-dimensional array of floats.
	  hintString = $"{Variant.Type.Array:D}:{Variant.Type.String:D}/{PropertyHint.MultilineText:D}:"; // Two-dimensional array of multiline strings.
	  hintString = $"{Variant.Type.Array:D}:{Variant.Type.Float:D}/{PropertyHint.Range:D}:-1,1,0.1"; // Two-dimensional array of floats (in range from -1 to 1).
	  hintString = $"{Variant.Type.Array:D}:{Variant.Type.Object:D}/{PropertyHint.ResourceType:D}:Texture2D"; // Two-dimensional array of textures.
	  [/csharp]
	  [/codeblocks]
	  [b]Note:[/b] The trailing colon is required for properly detecting built-in types.*/
	PropertyHintTypeString           PropertyHint = 23
	PropertyHintNodePathToEditedNode PropertyHint = 24
	/*Hints that an object is too big to be sent via the debugger.*/
	PropertyHintObjectTooBig PropertyHint = 25
	/*Hints that the hint string specifies valid node types for property of type [NodePath].*/
	PropertyHintNodePathValidTypes PropertyHint = 26
	/*Hints that a [String] property is a path to a file. Editing it will show a file dialog for picking the path for the file to be saved at. The dialog has access to the project's directory. The hint string can be a set of filters with wildcards like [code]"*.png,*.jpg"[/code]. See also [member FileDialog.filters].*/
	PropertyHintSaveFile PropertyHint = 27
	/*Hints that a [String] property is a path to a file. Editing it will show a file dialog for picking the path for the file to be saved at. The dialog has access to the entire filesystem. The hint string can be a set of filters with wildcards like [code]"*.png,*.jpg"[/code]. See also [member FileDialog.filters].*/
	PropertyHintGlobalSaveFile PropertyHint = 28
	PropertyHintIntIsObjectid  PropertyHint = 29
	/*Hints that an [int] property is a pointer. Used by GDExtension.*/
	PropertyHintIntIsPointer PropertyHint = 30
	/*Hints that a property is an [Array] with the stored type specified in the hint string.*/
	PropertyHintArrayType PropertyHint = 31
	/*Hints that a property is a [Dictionary] with the stored types specified in the hint string.*/
	PropertyHintDictionaryType PropertyHint = 38
	/*Hints that a string property is a locale code. Editing it will show a locale dialog for picking language and country.*/
	PropertyHintLocaleId PropertyHint = 32
	/*Hints that a dictionary property is string translation map. Dictionary keys are locale codes and, values are translated strings.*/
	PropertyHintLocalizableString PropertyHint = 33
	/*Hints that a property is an instance of a [Node]-derived type, optionally specified via the hint string (e.g. [code]"Node2D"[/code]). Editing it will show a dialog for picking a node from the scene.*/
	PropertyHintNodeType PropertyHint = 34
	/*Hints that a quaternion property should disable the temporary euler editor.*/
	PropertyHintHideQuaternionEdit PropertyHint = 35
	/*Hints that a string property is a password, and every character is replaced with the secret character.*/
	PropertyHintPassword PropertyHint = 36
	/*Hints that a [Callable] property should be displayed as a clickable button. When the button is pressed, the callable is called. The hint string specifies the button text and optionally an icon from the [code]"EditorIcons"[/code] theme type.
	  [codeblock lang=text]
	  "Click me!" - A button with the text "Click me!" and the default "Callable" icon.
	  "Click me!,ColorRect" - A button with the text "Click me!" and the "ColorRect" icon.
	  [/codeblock]
	  [b]Note:[/b] A [Callable] cannot be properly serialized and stored in a file, so it is recommended to use [constant PROPERTY_USAGE_EDITOR] instead of [constant PROPERTY_USAGE_DEFAULT].*/
	PropertyHintToolButton PropertyHint = 39
	/*Hints that a property will be changed on its own after setting, such as [member AudioStreamPlayer.playing] or [member GPUParticles3D.emitting].*/
	PropertyHintOneshot PropertyHint = 40
	/*Represents the size of the [enum PropertyHint] enum.*/
	PropertyHintMax PropertyHint = 42
)

type PropertyUsageFlags int //gd:PropertyUsageFlags

const (
	/*The property is not stored, and does not display in the editor. This is the default for non-exported properties.*/
	PropertyUsageNone PropertyUsageFlags = 0
	/*The property is serialized and saved in the scene file (default for exported properties).*/
	PropertyUsageStorage PropertyUsageFlags = 2
	/*The property is shown in the [EditorInspector] (default for exported properties).*/
	PropertyUsageEditor PropertyUsageFlags = 4
	/*The property is excluded from the class reference.*/
	PropertyUsageInternal PropertyUsageFlags = 8
	/*The property can be checked in the [EditorInspector].*/
	PropertyUsageCheckable PropertyUsageFlags = 16
	/*The property is checked in the [EditorInspector].*/
	PropertyUsageChecked PropertyUsageFlags = 32
	/*Used to group properties together in the editor. See [EditorInspector].*/
	PropertyUsageGroup PropertyUsageFlags = 64
	/*Used to categorize properties together in the editor.*/
	PropertyUsageCategory PropertyUsageFlags = 128
	/*Used to group properties together in the editor in a subgroup (under a group). See [EditorInspector].*/
	PropertyUsageSubgroup PropertyUsageFlags = 256
	/*The property is a bitfield, i.e. it contains multiple flags represented as bits.*/
	PropertyUsageClassIsBitfield PropertyUsageFlags = 512
	/*The property does not save its state in [PackedScene].*/
	PropertyUsageNoInstanceState PropertyUsageFlags = 1024
	/*Editing the property prompts the user for restarting the editor.*/
	PropertyUsageRestartIfChanged PropertyUsageFlags = 2048
	/*The property is a script variable. [constant PROPERTY_USAGE_SCRIPT_VARIABLE] can be used to distinguish between exported script variables from built-in variables (which don't have this usage flag). By default, [constant PROPERTY_USAGE_SCRIPT_VARIABLE] is [b]not[/b] applied to variables that are created by overriding [method Object._get_property_list] in a script.*/
	PropertyUsageScriptVariable PropertyUsageFlags = 4096
	/*The property value of type [Object] will be stored even if its value is [code]null[/code].*/
	PropertyUsageStoreIfNull PropertyUsageFlags = 8192
	/*If this property is modified, all inspector fields will be refreshed.*/
	PropertyUsageUpdateAllIfModified PropertyUsageFlags = 16384
	PropertyUsageScriptDefaultValue  PropertyUsageFlags = 32768
	/*The property is a variable of enum type, i.e. it only takes named integer constants from its associated enumeration.*/
	PropertyUsageClassIsEnum PropertyUsageFlags = 65536
	/*If property has [code]nil[/code] as default value, its type will be [Variant].*/
	PropertyUsageNilIsVariant PropertyUsageFlags = 131072
	/*The property is an array.*/
	PropertyUsageArray PropertyUsageFlags = 262144
	/*When duplicating a resource with [method Resource.duplicate], and this flag is set on a property of that resource, the property should always be duplicated, regardless of the [code]subresources[/code] bool parameter.*/
	PropertyUsageAlwaysDuplicate PropertyUsageFlags = 524288
	/*When duplicating a resource with [method Resource.duplicate], and this flag is set on a property of that resource, the property should never be duplicated, regardless of the [code]subresources[/code] bool parameter.*/
	PropertyUsageNeverDuplicate PropertyUsageFlags = 1048576
	/*The property is only shown in the editor if modern renderers are supported (the Compatibility rendering method is excluded).*/
	PropertyUsageHighEndGfx PropertyUsageFlags = 2097152
	/*The [NodePath] property will always be relative to the scene's root. Mostly useful for local resources.*/
	PropertyUsageNodePathFromSceneRoot PropertyUsageFlags = 4194304
	/*Use when a resource is created on the fly, i.e. the getter will always return a different instance. [ResourceSaver] needs this information to properly save such resources.*/
	PropertyUsageResourceNotPersistent PropertyUsageFlags = 8388608
	/*Inserting an animation key frame of this property will automatically increment the value, allowing to easily keyframe multiple values in a row.*/
	PropertyUsageKeyingIncrements    PropertyUsageFlags = 16777216
	PropertyUsageDeferredSetResource PropertyUsageFlags = 33554432
	/*When this property is a [Resource] and base object is a [Node], a resource instance will be automatically created whenever the node is created in the editor.*/
	PropertyUsageEditorInstantiateObject PropertyUsageFlags = 67108864
	/*The property is considered a basic setting and will appear even when advanced mode is disabled. Used for project settings.*/
	PropertyUsageEditorBasicSetting PropertyUsageFlags = 134217728
	/*The property is read-only in the [EditorInspector].*/
	PropertyUsageReadOnly PropertyUsageFlags = 268435456
	/*An export preset property with this flag contains confidential information and is stored separately from the rest of the export preset configuration.*/
	PropertyUsageSecret PropertyUsageFlags = 536870912
	/*Default usage (storage and editor).*/
	PropertyUsageDefault PropertyUsageFlags = 6
	/*Default usage but without showing the property in the editor (storage).*/
	PropertyUsageNoEditor PropertyUsageFlags = 2
)

type PropertyInfo struct {
	ClassName  string       `gd:"class_name"`
	Name       string       `gd:"name"`
	Hint       int          `gd:"hint"`
	HintString string       `gd:"hint_string"`
	Type       reflect.Type `gd:"type"`
	Usage      int          `gd:"usage"`
}
type SignalInfo struct {
	Name        string         `gd:"name"`
	Flags       int            `gd:"flags"`
	ID          int            `gd:"id"`
	DefaultArgs []interface{}  `gd:"default_args"`
	Args        []PropertyInfo `gd:"args"`
}
