// Code generated by the generate package DO NOT EDIT

// Package GeometryInstance3D provides methods for working with GeometryInstance3D object instances.
package GeometryInstance3D

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/variant/Signal"
import "graphics.gd/classdb/Material"
import "graphics.gd/classdb/Node"
import "graphics.gd/classdb/Node3D"
import "graphics.gd/classdb/VisualInstance3D"
import "graphics.gd/variant/AABB"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Signal.Any
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
Base node for geometry-based visual instances. Shares some common functionality like visibility and custom materials.
*/
type Instance [1]gdclass.GeometryInstance3D

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	set_material_override             gdextension.MethodForClass `hash:"2757459619"`
	get_material_override             gdextension.MethodForClass `hash:"5934680"`
	set_material_overlay              gdextension.MethodForClass `hash:"2757459619"`
	get_material_overlay              gdextension.MethodForClass `hash:"5934680"`
	set_cast_shadows_setting          gdextension.MethodForClass `hash:"856677339"`
	get_cast_shadows_setting          gdextension.MethodForClass `hash:"3383019359"`
	set_lod_bias                      gdextension.MethodForClass `hash:"373806689"`
	get_lod_bias                      gdextension.MethodForClass `hash:"1740695150"`
	set_transparency                  gdextension.MethodForClass `hash:"373806689"`
	get_transparency                  gdextension.MethodForClass `hash:"1740695150"`
	set_visibility_range_end_margin   gdextension.MethodForClass `hash:"373806689"`
	get_visibility_range_end_margin   gdextension.MethodForClass `hash:"1740695150"`
	set_visibility_range_end          gdextension.MethodForClass `hash:"373806689"`
	get_visibility_range_end          gdextension.MethodForClass `hash:"1740695150"`
	set_visibility_range_begin_margin gdextension.MethodForClass `hash:"373806689"`
	get_visibility_range_begin_margin gdextension.MethodForClass `hash:"1740695150"`
	set_visibility_range_begin        gdextension.MethodForClass `hash:"373806689"`
	get_visibility_range_begin        gdextension.MethodForClass `hash:"1740695150"`
	set_visibility_range_fade_mode    gdextension.MethodForClass `hash:"1440117808"`
	get_visibility_range_fade_mode    gdextension.MethodForClass `hash:"2067221882"`
	set_instance_shader_parameter     gdextension.MethodForClass `hash:"3776071444"`
	get_instance_shader_parameter     gdextension.MethodForClass `hash:"2760726917"`
	set_extra_cull_margin             gdextension.MethodForClass `hash:"373806689"`
	get_extra_cull_margin             gdextension.MethodForClass `hash:"1740695150"`
	set_lightmap_texel_scale          gdextension.MethodForClass `hash:"373806689"`
	get_lightmap_texel_scale          gdextension.MethodForClass `hash:"1740695150"`
	set_lightmap_scale                gdextension.MethodForClass `hash:"2462696582"`
	get_lightmap_scale                gdextension.MethodForClass `hash:"798767852"`
	set_gi_mode                       gdextension.MethodForClass `hash:"2548557163"`
	get_gi_mode                       gdextension.MethodForClass `hash:"2188566509"`
	set_ignore_occlusion_culling      gdextension.MethodForClass `hash:"2586408642"`
	is_ignoring_occlusion_culling     gdextension.MethodForClass `hash:"2240911060"`
	set_custom_aabb                   gdextension.MethodForClass `hash:"259215842"`
	get_custom_aabb                   gdextension.MethodForClass `hash:"1068685055"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("GeometryInstance3D")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		gdextension.Free(gdextension.TypeStringName, &sname)
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsGeometryInstance3D() Instance
}

/*
Set the value of a shader uniform for this instance only ([url=$DOCS_URL/tutorials/shaders/shader_reference/shading_language.html#per-instance-uniforms]per-instance uniform[/url]). See also [method ShaderMaterial.set_shader_parameter] to assign a uniform on all instances using the same [ShaderMaterial].
[b]Note:[/b] For a shader uniform to be assignable on a per-instance basis, it [i]must[/i] be defined with [code]instance uniform ...[/code] rather than [code]uniform ...[/code] in the shader code.
[b]Note:[/b] [param name] is case-sensitive and must match the name of the uniform in the code exactly (not the capitalized name in the inspector).
[b]Note:[/b] Per-instance shader uniforms are only available in Spatial and CanvasItem shaders, but not for Fog, Sky, or Particles shaders.
*/
func (self Instance) SetInstanceShaderParameter(name string, value any) { //gd:GeometryInstance3D.set_instance_shader_parameter
	Advanced(self).SetInstanceShaderParameter(String.Name(String.New(name)), variant.New(value))
}

/*
Get the value of a shader parameter as set on this instance.
*/
func (self Instance) GetInstanceShaderParameter(name string) any { //gd:GeometryInstance3D.get_instance_shader_parameter
	return any(Advanced(self).GetInstanceShaderParameter(String.Name(String.New(name))).Interface())
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.GeometryInstance3D

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.GeometryInstance3D)(unsafe.Pointer(&obj))
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.GeometryInstance3D)(unsafe.Pointer(&obj))
		return true
	}
	return false
}

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {

	if !gd.Linked {
		var placeholder Instance
		*(*gd.Object)(unsafe.Pointer(&placeholder)) = pointers.Add[gd.Object]([3]uint64{})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(*(*gd.Object)(unsafe.Pointer(&placeholder)), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	object := [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})}
	casted := Instance{*(*gdclass.GeometryInstance3D)(unsafe.Pointer(&object))}
	object[0].Notification(0, false)
	return casted
}

func (self Instance) MaterialOverride() Material.Instance {
	return Material.Instance(class(self).GetMaterialOverride())
}

func (self Instance) SetMaterialOverride(value Material.Instance) {
	class(self).SetMaterialOverride(value)
}

func (self Instance) MaterialOverlay() Material.Instance {
	return Material.Instance(class(self).GetMaterialOverlay())
}

func (self Instance) SetMaterialOverlay(value Material.Instance) {
	class(self).SetMaterialOverlay(value)
}

func (self Instance) Transparency() Float.X {
	return Float.X(Float.X(class(self).GetTransparency()))
}

func (self Instance) SetTransparency(value Float.X) {
	class(self).SetTransparency(float64(value))
}

func (self Instance) CastShadow() ShadowCastingSetting {
	return ShadowCastingSetting(class(self).GetCastShadowsSetting())
}

func (self Instance) SetCastShadow(value ShadowCastingSetting) {
	class(self).SetCastShadowsSetting(value)
}

func (self Instance) ExtraCullMargin() Float.X {
	return Float.X(Float.X(class(self).GetExtraCullMargin()))
}

func (self Instance) SetExtraCullMargin(value Float.X) {
	class(self).SetExtraCullMargin(float64(value))
}

func (self Instance) CustomAabb() AABB.PositionSize {
	return AABB.PositionSize(class(self).GetCustomAabb())
}

func (self Instance) SetCustomAabb(value AABB.PositionSize) {
	class(self).SetCustomAabb(AABB.PositionSize(value))
}

func (self Instance) LodBias() Float.X {
	return Float.X(Float.X(class(self).GetLodBias()))
}

func (self Instance) SetLodBias(value Float.X) {
	class(self).SetLodBias(float64(value))
}

func (self Instance) IgnoreOcclusionCulling() bool {
	return bool(class(self).IsIgnoringOcclusionCulling())
}

func (self Instance) SetIgnoreOcclusionCulling(value bool) {
	class(self).SetIgnoreOcclusionCulling(value)
}

func (self Instance) GiMode() GIMode {
	return GIMode(class(self).GetGiMode())
}

func (self Instance) SetGiMode(value GIMode) {
	class(self).SetGiMode(value)
}

func (self Instance) GiLightmapTexelScale() Float.X {
	return Float.X(Float.X(class(self).GetLightmapTexelScale()))
}

func (self Instance) SetGiLightmapTexelScale(value Float.X) {
	class(self).SetLightmapTexelScale(float64(value))
}

func (self Instance) GiLightmapScale() LightmapScale {
	return LightmapScale(class(self).GetLightmapScale())
}

func (self Instance) SetGiLightmapScale(value LightmapScale) {
	class(self).SetLightmapScale(value)
}

func (self Instance) VisibilityRangeBegin() Float.X {
	return Float.X(Float.X(class(self).GetVisibilityRangeBegin()))
}

func (self Instance) SetVisibilityRangeBegin(value Float.X) {
	class(self).SetVisibilityRangeBegin(float64(value))
}

func (self Instance) VisibilityRangeBeginMargin() Float.X {
	return Float.X(Float.X(class(self).GetVisibilityRangeBeginMargin()))
}

func (self Instance) SetVisibilityRangeBeginMargin(value Float.X) {
	class(self).SetVisibilityRangeBeginMargin(float64(value))
}

func (self Instance) VisibilityRangeEnd() Float.X {
	return Float.X(Float.X(class(self).GetVisibilityRangeEnd()))
}

func (self Instance) SetVisibilityRangeEnd(value Float.X) {
	class(self).SetVisibilityRangeEnd(float64(value))
}

func (self Instance) VisibilityRangeEndMargin() Float.X {
	return Float.X(Float.X(class(self).GetVisibilityRangeEndMargin()))
}

func (self Instance) SetVisibilityRangeEndMargin(value Float.X) {
	class(self).SetVisibilityRangeEndMargin(float64(value))
}

func (self Instance) VisibilityRangeFadeMode() VisibilityRangeFadeMode {
	return VisibilityRangeFadeMode(class(self).GetVisibilityRangeFadeMode())
}

func (self Instance) SetVisibilityRangeFadeMode(value VisibilityRangeFadeMode) {
	class(self).SetVisibilityRangeFadeMode(value)
}

//go:nosplit
func (self class) SetMaterialOverride(material [1]gdclass.Material) { //gd:GeometryInstance3D.set_material_override
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_material_override, 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ material gdextension.Object }{gdextension.Object(gd.ObjectChecked(material[0].AsObject()))}))
}

//go:nosplit
func (self class) GetMaterialOverride() [1]gdclass.Material { //gd:GeometryInstance3D.get_material_override
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_material_override, gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.Material{gd.PointerWithOwnershipTransferredToGo[gdclass.Material](r_ret)}
	return ret
}

//go:nosplit
func (self class) SetMaterialOverlay(material [1]gdclass.Material) { //gd:GeometryInstance3D.set_material_overlay
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_material_overlay, 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ material gdextension.Object }{gdextension.Object(gd.ObjectChecked(material[0].AsObject()))}))
}

//go:nosplit
func (self class) GetMaterialOverlay() [1]gdclass.Material { //gd:GeometryInstance3D.get_material_overlay
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_material_overlay, gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.Material{gd.PointerWithOwnershipTransferredToGo[gdclass.Material](r_ret)}
	return ret
}

//go:nosplit
func (self class) SetCastShadowsSetting(shadow_casting_setting ShadowCastingSetting) { //gd:GeometryInstance3D.set_cast_shadows_setting
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_cast_shadows_setting, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ shadow_casting_setting ShadowCastingSetting }{shadow_casting_setting}))
}

//go:nosplit
func (self class) GetCastShadowsSetting() ShadowCastingSetting { //gd:GeometryInstance3D.get_cast_shadows_setting
	var r_ret = gdextension.Call[ShadowCastingSetting](gd.ObjectChecked(self.AsObject()), methods.get_cast_shadows_setting, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetLodBias(bias float64) { //gd:GeometryInstance3D.set_lod_bias
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_lod_bias, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ bias float64 }{bias}))
}

//go:nosplit
func (self class) GetLodBias() float64 { //gd:GeometryInstance3D.get_lod_bias
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_lod_bias, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetTransparency(transparency float64) { //gd:GeometryInstance3D.set_transparency
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_transparency, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ transparency float64 }{transparency}))
}

//go:nosplit
func (self class) GetTransparency() float64 { //gd:GeometryInstance3D.get_transparency
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_transparency, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetVisibilityRangeEndMargin(distance float64) { //gd:GeometryInstance3D.set_visibility_range_end_margin
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_visibility_range_end_margin, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ distance float64 }{distance}))
}

//go:nosplit
func (self class) GetVisibilityRangeEndMargin() float64 { //gd:GeometryInstance3D.get_visibility_range_end_margin
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_visibility_range_end_margin, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetVisibilityRangeEnd(distance float64) { //gd:GeometryInstance3D.set_visibility_range_end
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_visibility_range_end, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ distance float64 }{distance}))
}

//go:nosplit
func (self class) GetVisibilityRangeEnd() float64 { //gd:GeometryInstance3D.get_visibility_range_end
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_visibility_range_end, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetVisibilityRangeBeginMargin(distance float64) { //gd:GeometryInstance3D.set_visibility_range_begin_margin
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_visibility_range_begin_margin, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ distance float64 }{distance}))
}

//go:nosplit
func (self class) GetVisibilityRangeBeginMargin() float64 { //gd:GeometryInstance3D.get_visibility_range_begin_margin
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_visibility_range_begin_margin, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetVisibilityRangeBegin(distance float64) { //gd:GeometryInstance3D.set_visibility_range_begin
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_visibility_range_begin, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ distance float64 }{distance}))
}

//go:nosplit
func (self class) GetVisibilityRangeBegin() float64 { //gd:GeometryInstance3D.get_visibility_range_begin
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_visibility_range_begin, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetVisibilityRangeFadeMode(mode VisibilityRangeFadeMode) { //gd:GeometryInstance3D.set_visibility_range_fade_mode
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_visibility_range_fade_mode, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ mode VisibilityRangeFadeMode }{mode}))
}

//go:nosplit
func (self class) GetVisibilityRangeFadeMode() VisibilityRangeFadeMode { //gd:GeometryInstance3D.get_visibility_range_fade_mode
	var r_ret = gdextension.Call[VisibilityRangeFadeMode](gd.ObjectChecked(self.AsObject()), methods.get_visibility_range_fade_mode, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Set the value of a shader uniform for this instance only ([url=$DOCS_URL/tutorials/shaders/shader_reference/shading_language.html#per-instance-uniforms]per-instance uniform[/url]). See also [method ShaderMaterial.set_shader_parameter] to assign a uniform on all instances using the same [ShaderMaterial].
[b]Note:[/b] For a shader uniform to be assignable on a per-instance basis, it [i]must[/i] be defined with [code]instance uniform ...[/code] rather than [code]uniform ...[/code] in the shader code.
[b]Note:[/b] [param name] is case-sensitive and must match the name of the uniform in the code exactly (not the capitalized name in the inspector).
[b]Note:[/b] Per-instance shader uniforms are only available in Spatial and CanvasItem shaders, but not for Fog, Sky, or Particles shaders.
*/
//go:nosplit
func (self class) SetInstanceShaderParameter(name String.Name, value variant.Any) { //gd:GeometryInstance3D.set_instance_shader_parameter
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_instance_shader_parameter, 0|(gdextension.SizeStringName<<4)|(gdextension.SizeVariant<<8), unsafe.Pointer(&struct {
		name  gdextension.StringName
		value gdextension.Variant
	}{pointers.Get(gd.InternalStringName(name)), gdextension.Variant(pointers.Get(gd.InternalVariant(value)))}))
}

/*
Get the value of a shader parameter as set on this instance.
*/
//go:nosplit
func (self class) GetInstanceShaderParameter(name String.Name) variant.Any { //gd:GeometryInstance3D.get_instance_shader_parameter
	var r_ret = gdextension.Call[gdextension.Variant](gd.ObjectChecked(self.AsObject()), methods.get_instance_shader_parameter, gdextension.SizeVariant|(gdextension.SizeStringName<<4), unsafe.Pointer(&struct{ name gdextension.StringName }{pointers.Get(gd.InternalStringName(name))}))
	var ret = variant.Implementation(gd.VariantProxy{}, pointers.Pack(pointers.New[gd.Variant](r_ret)))
	return ret
}

//go:nosplit
func (self class) SetExtraCullMargin(margin float64) { //gd:GeometryInstance3D.set_extra_cull_margin
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_extra_cull_margin, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ margin float64 }{margin}))
}

//go:nosplit
func (self class) GetExtraCullMargin() float64 { //gd:GeometryInstance3D.get_extra_cull_margin
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_extra_cull_margin, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetLightmapTexelScale(scale float64) { //gd:GeometryInstance3D.set_lightmap_texel_scale
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_lightmap_texel_scale, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ scale float64 }{scale}))
}

//go:nosplit
func (self class) GetLightmapTexelScale() float64 { //gd:GeometryInstance3D.get_lightmap_texel_scale
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_lightmap_texel_scale, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetLightmapScale(scale LightmapScale) { //gd:GeometryInstance3D.set_lightmap_scale
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_lightmap_scale, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ scale LightmapScale }{scale}))
}

//go:nosplit
func (self class) GetLightmapScale() LightmapScale { //gd:GeometryInstance3D.get_lightmap_scale
	var r_ret = gdextension.Call[LightmapScale](gd.ObjectChecked(self.AsObject()), methods.get_lightmap_scale, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetGiMode(mode GIMode) { //gd:GeometryInstance3D.set_gi_mode
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_gi_mode, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ mode GIMode }{mode}))
}

//go:nosplit
func (self class) GetGiMode() GIMode { //gd:GeometryInstance3D.get_gi_mode
	var r_ret = gdextension.Call[GIMode](gd.ObjectChecked(self.AsObject()), methods.get_gi_mode, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetIgnoreOcclusionCulling(ignore_culling bool) { //gd:GeometryInstance3D.set_ignore_occlusion_culling
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_ignore_occlusion_culling, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ ignore_culling bool }{ignore_culling}))
}

//go:nosplit
func (self class) IsIgnoringOcclusionCulling() bool { //gd:GeometryInstance3D.is_ignoring_occlusion_culling
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_ignoring_occlusion_culling, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetCustomAabb(aabb AABB.PositionSize) { //gd:GeometryInstance3D.set_custom_aabb
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_custom_aabb, 0|(gdextension.SizeAABB<<4), unsafe.Pointer(&struct{ aabb AABB.PositionSize }{aabb}))
}

//go:nosplit
func (self class) GetCustomAabb() AABB.PositionSize { //gd:GeometryInstance3D.get_custom_aabb
	var r_ret = gdextension.Call[AABB.PositionSize](gd.ObjectChecked(self.AsObject()), methods.get_custom_aabb, gdextension.SizeAABB, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}
func (self class) AsGeometryInstance3D() Advanced         { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsGeometryInstance3D() Instance      { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsGeometryInstance3D() Instance { return self.Super().AsGeometryInstance3D() }
func (self class) AsVisualInstance3D() VisualInstance3D.Advanced {
	return *((*VisualInstance3D.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsVisualInstance3D() VisualInstance3D.Instance {
	return self.Super().AsVisualInstance3D()
}
func (self Instance) AsVisualInstance3D() VisualInstance3D.Instance {
	return *((*VisualInstance3D.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsNode3D() Node3D.Advanced         { return *((*Node3D.Advanced)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsNode3D() Node3D.Instance { return self.Super().AsNode3D() }
func (self Instance) AsNode3D() Node3D.Instance      { return *((*Node3D.Instance)(unsafe.Pointer(&self))) }
func (self class) AsNode() Node.Advanced             { return *((*Node.Advanced)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsNode() Node.Instance     { return self.Super().AsNode() }
func (self Instance) AsNode() Node.Instance          { return *((*Node.Instance)(unsafe.Pointer(&self))) }

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(VisualInstance3D.Advanced(self.AsVisualInstance3D()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(VisualInstance3D.Instance(self.AsVisualInstance3D()), name)
	}
}
func init() {
	gdclass.Register("GeometryInstance3D", func(ptr gd.Object) any { return *(*Instance)(unsafe.Pointer(&ptr)) })
}

type ShadowCastingSetting int //gd:GeometryInstance3D.ShadowCastingSetting

const (
	/*Will not cast any shadows. Use this to improve performance for small geometry that is unlikely to cast noticeable shadows (such as debris).*/
	ShadowCastingSettingOff ShadowCastingSetting = 0
	/*Will cast shadows from all visible faces in the GeometryInstance3D.
	  Will take culling into account, so faces not being rendered will not be taken into account when shadow casting.*/
	ShadowCastingSettingOn ShadowCastingSetting = 1
	/*Will cast shadows from all visible faces in the GeometryInstance3D.
	  Will not take culling into account, so all faces will be taken into account when shadow casting.*/
	ShadowCastingSettingDoubleSided ShadowCastingSetting = 2
	/*Will only show the shadows casted from this object.
	  In other words, the actual mesh will not be visible, only the shadows casted from the mesh will be.*/
	ShadowCastingSettingShadowsOnly ShadowCastingSetting = 3
)

type GIMode int //gd:GeometryInstance3D.GIMode

const (
	/*Disabled global illumination mode. Use for dynamic objects that do not contribute to global illumination (such as characters). When using [VoxelGI] and SDFGI, the geometry will [i]receive[/i] indirect lighting and reflections but the geometry will not be considered in GI baking.*/
	GiModeDisabled GIMode = 0
	/*Baked global illumination mode. Use for static objects that contribute to global illumination (such as level geometry). This GI mode is effective when using [VoxelGI], SDFGI and [LightmapGI].*/
	GiModeStatic GIMode = 1
	/*Dynamic global illumination mode. Use for dynamic objects that contribute to global illumination. This GI mode is only effective when using [VoxelGI], but it has a higher performance impact than [constant GI_MODE_STATIC]. When using other GI methods, this will act the same as [constant GI_MODE_DISABLED]. When using [LightmapGI], the object will receive indirect lighting using lightmap probes instead of using the baked lightmap texture.*/
	GiModeDynamic GIMode = 2
)

type LightmapScale int //gd:GeometryInstance3D.LightmapScale

const (
	/*The standard texel density for lightmapping with [LightmapGI].*/
	LightmapScale1x LightmapScale = 0
	/*Multiplies texel density by 2× for lightmapping with [LightmapGI]. To ensure consistency in texel density, use this when scaling a mesh by a factor between 1.5 and 3.0.*/
	LightmapScale2x LightmapScale = 1
	/*Multiplies texel density by 4× for lightmapping with [LightmapGI]. To ensure consistency in texel density, use this when scaling a mesh by a factor between 3.0 and 6.0.*/
	LightmapScale4x LightmapScale = 2
	/*Multiplies texel density by 8× for lightmapping with [LightmapGI]. To ensure consistency in texel density, use this when scaling a mesh by a factor greater than 6.0.*/
	LightmapScale8x LightmapScale = 3
	/*Represents the size of the [enum LightmapScale] enum.*/
	LightmapScaleMax LightmapScale = 4
)

type VisibilityRangeFadeMode int //gd:GeometryInstance3D.VisibilityRangeFadeMode

const (
	/*Will not fade itself nor its visibility dependencies, hysteresis will be used instead. This is the fastest approach to manual LOD, but it can result in noticeable LOD transitions depending on how the LOD meshes are authored. See [member visibility_range_begin] and [member Node3D.visibility_parent] for more information.*/
	VisibilityRangeFadeDisabled VisibilityRangeFadeMode = 0
	/*Will fade-out itself when reaching the limits of its own visibility range. This is slower than [constant VISIBILITY_RANGE_FADE_DISABLED], but it can provide smoother transitions. The fading range is determined by [member visibility_range_begin_margin] and [member visibility_range_end_margin].
	  [b]Note:[/b] Only supported when using the Forward+ rendering method. When using the Mobile or Compatibility rendering method, this mode acts like [constant VISIBILITY_RANGE_FADE_DISABLED] but with hysteresis disabled.*/
	VisibilityRangeFadeSelf VisibilityRangeFadeMode = 1
	/*Will fade-in its visibility dependencies (see [member Node3D.visibility_parent]) when reaching the limits of its own visibility range. This is slower than [constant VISIBILITY_RANGE_FADE_DISABLED], but it can provide smoother transitions. The fading range is determined by [member visibility_range_begin_margin] and [member visibility_range_end_margin].
	  [b]Note:[/b] Only supported when using the Forward+ rendering method. When using the Mobile or Compatibility rendering method, this mode acts like [constant VISIBILITY_RANGE_FADE_DISABLED] but with hysteresis disabled.*/
	VisibilityRangeFadeDependencies VisibilityRangeFadeMode = 2
)
