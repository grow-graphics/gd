// Code generated by the generate package DO NOT EDIT

// Package OpenXRCompositionLayer provides methods for working with OpenXRCompositionLayer object instances.
package OpenXRCompositionLayer

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdunsafe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/JavaObject"
import "graphics.gd/classdb/Node"
import "graphics.gd/classdb/Node3D"
import "graphics.gd/classdb/SubViewport"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"
import "graphics.gd/variant/Vector2"
import "graphics.gd/variant/Vector2i"
import "graphics.gd/variant/Vector3"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = gdunsafe.Use{}
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
Composition layers allow 2D viewports to be displayed inside of the headset by the XR compositor through special projections that retain their quality. This allows for rendering clear text while keeping the layer at a native resolution.
[b]Note:[/b] If the OpenXR runtime doesn't support the given composition layer type, a fallback mesh can be generated with a [ViewportTexture], in order to emulate the composition layer.
*/
type Instance [1]gdclass.OpenXRCompositionLayer

func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsOpenXRCompositionLayer() Instance
}

/*
Returns a [JavaObject] representing an [code]android.view.Surface[/code] if [member use_android_surface] is enabled and OpenXR has created the surface. Otherwise, this will return [code]null[/code].
[b]Note:[/b] The surface can only be created during an active OpenXR session. So, if [member use_android_surface] is enabled outside of an OpenXR session, it won't be created until a new session fully starts.
*/
func (self Instance) GetAndroidSurface() JavaObject.Instance { //gd:OpenXRCompositionLayer.get_android_surface
	return JavaObject.Instance(Advanced(self).GetAndroidSurface())
}

/*
Returns [code]true[/code] if the OpenXR runtime natively supports this composition layer type.
[b]Note:[/b] This will only return an accurate result after the OpenXR session has started.
*/
func (self Instance) IsNativelySupported() bool { //gd:OpenXRCompositionLayer.is_natively_supported
	return bool(Advanced(self).IsNativelySupported())
}

/*
Returns UV coordinates where the given ray intersects with the composition layer. [param origin] and [param direction] must be in global space.
Returns [code]Vector2(-1.0, -1.0)[/code] if the ray doesn't intersect.
*/
func (self Instance) IntersectsRay(origin Vector3.XYZ, direction Vector3.XYZ) Vector2.XY { //gd:OpenXRCompositionLayer.intersects_ray
	return Vector2.XY(Advanced(self).IntersectsRay(Vector3.XYZ(origin), Vector3.XYZ(direction)))
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.OpenXRCompositionLayer

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {
	object := gd.Global.ClassDB.ConstructObject(gd.NewStringName("OpenXRCompositionLayer"))
	casted := Instance{*(*gdclass.OpenXRCompositionLayer)(unsafe.Pointer(&object))}
	return casted
}

func (self Instance) LayerViewport() SubViewport.Instance {
	return SubViewport.Instance(class(self).GetLayerViewport())
}

func (self Instance) SetLayerViewport(value SubViewport.Instance) {
	class(self).SetLayerViewport(value)
}

func (self Instance) UseAndroidSurface() bool {
	return bool(class(self).GetUseAndroidSurface())
}

func (self Instance) SetUseAndroidSurface(value bool) {
	class(self).SetUseAndroidSurface(value)
}

func (self Instance) AndroidSurfaceSize() Vector2i.XY {
	return Vector2i.XY(class(self).GetAndroidSurfaceSize())
}

func (self Instance) SetAndroidSurfaceSize(value Vector2i.XY) {
	class(self).SetAndroidSurfaceSize(Vector2i.XY(value))
}

func (self Instance) SortOrder() int {
	return int(int(class(self).GetSortOrder()))
}

func (self Instance) SetSortOrder(value int) {
	class(self).SetSortOrder(int64(value))
}

func (self Instance) AlphaBlend() bool {
	return bool(class(self).GetAlphaBlend())
}

func (self Instance) SetAlphaBlend(value bool) {
	class(self).SetAlphaBlend(value)
}

func (self Instance) EnableHolePunch() bool {
	return bool(class(self).GetEnableHolePunch())
}

func (self Instance) SetEnableHolePunch(value bool) {
	class(self).SetEnableHolePunch(value)
}

//go:nosplit
func (self class) SetLayerViewport(viewport [1]gdclass.SubViewport) { //gd:OpenXRCompositionLayer.set_layer_viewport
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.OpenXRCompositionLayer.Bind_set_layer_viewport, 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ viewport gdextension.Object }{gdextension.Object(gd.PointerWithOwnershipTransferredToGodot(viewport[0].AsObject()[0]))}))
}

//go:nosplit
func (self class) GetLayerViewport() [1]gdclass.SubViewport { //gd:OpenXRCompositionLayer.get_layer_viewport
	var r_ret = gdunsafe.Call[gd.EnginePointer](self.AsObject(), gd.Global.Methods.OpenXRCompositionLayer.Bind_get_layer_viewport, gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.SubViewport{gd.PointerMustAssertInstanceID[gdclass.SubViewport](r_ret)}
	return ret
}

//go:nosplit
func (self class) SetUseAndroidSurface(enable bool) { //gd:OpenXRCompositionLayer.set_use_android_surface
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.OpenXRCompositionLayer.Bind_set_use_android_surface, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

//go:nosplit
func (self class) GetUseAndroidSurface() bool { //gd:OpenXRCompositionLayer.get_use_android_surface
	var r_ret = gdunsafe.Call[bool](self.AsObject(), gd.Global.Methods.OpenXRCompositionLayer.Bind_get_use_android_surface, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetAndroidSurfaceSize(size Vector2i.XY) { //gd:OpenXRCompositionLayer.set_android_surface_size
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.OpenXRCompositionLayer.Bind_set_android_surface_size, 0|(gdextension.SizeVector2i<<4), unsafe.Pointer(&struct{ size Vector2i.XY }{size}))
}

//go:nosplit
func (self class) GetAndroidSurfaceSize() Vector2i.XY { //gd:OpenXRCompositionLayer.get_android_surface_size
	var r_ret = gdunsafe.Call[Vector2i.XY](self.AsObject(), gd.Global.Methods.OpenXRCompositionLayer.Bind_get_android_surface_size, gdextension.SizeVector2i, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetEnableHolePunch(enable bool) { //gd:OpenXRCompositionLayer.set_enable_hole_punch
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.OpenXRCompositionLayer.Bind_set_enable_hole_punch, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

//go:nosplit
func (self class) GetEnableHolePunch() bool { //gd:OpenXRCompositionLayer.get_enable_hole_punch
	var r_ret = gdunsafe.Call[bool](self.AsObject(), gd.Global.Methods.OpenXRCompositionLayer.Bind_get_enable_hole_punch, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetSortOrder(order int64) { //gd:OpenXRCompositionLayer.set_sort_order
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.OpenXRCompositionLayer.Bind_set_sort_order, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ order int64 }{order}))
}

//go:nosplit
func (self class) GetSortOrder() int64 { //gd:OpenXRCompositionLayer.get_sort_order
	var r_ret = gdunsafe.Call[int64](self.AsObject(), gd.Global.Methods.OpenXRCompositionLayer.Bind_get_sort_order, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetAlphaBlend(enabled bool) { //gd:OpenXRCompositionLayer.set_alpha_blend
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.OpenXRCompositionLayer.Bind_set_alpha_blend, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enabled bool }{enabled}))
}

//go:nosplit
func (self class) GetAlphaBlend() bool { //gd:OpenXRCompositionLayer.get_alpha_blend
	var r_ret = gdunsafe.Call[bool](self.AsObject(), gd.Global.Methods.OpenXRCompositionLayer.Bind_get_alpha_blend, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns a [JavaObject] representing an [code]android.view.Surface[/code] if [member use_android_surface] is enabled and OpenXR has created the surface. Otherwise, this will return [code]null[/code].
[b]Note:[/b] The surface can only be created during an active OpenXR session. So, if [member use_android_surface] is enabled outside of an OpenXR session, it won't be created until a new session fully starts.
*/
//go:nosplit
func (self class) GetAndroidSurface() [1]gdclass.JavaObject { //gd:OpenXRCompositionLayer.get_android_surface
	var r_ret = gdunsafe.Call[gd.EnginePointer](self.AsObject(), gd.Global.Methods.OpenXRCompositionLayer.Bind_get_android_surface, gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.JavaObject{gd.PointerWithOwnershipTransferredToGo[gdclass.JavaObject](r_ret)}
	return ret
}

/*
Returns [code]true[/code] if the OpenXR runtime natively supports this composition layer type.
[b]Note:[/b] This will only return an accurate result after the OpenXR session has started.
*/
//go:nosplit
func (self class) IsNativelySupported() bool { //gd:OpenXRCompositionLayer.is_natively_supported
	var r_ret = gdunsafe.Call[bool](self.AsObject(), gd.Global.Methods.OpenXRCompositionLayer.Bind_is_natively_supported, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns UV coordinates where the given ray intersects with the composition layer. [param origin] and [param direction] must be in global space.
Returns [code]Vector2(-1.0, -1.0)[/code] if the ray doesn't intersect.
*/
//go:nosplit
func (self class) IntersectsRay(origin Vector3.XYZ, direction Vector3.XYZ) Vector2.XY { //gd:OpenXRCompositionLayer.intersects_ray
	var r_ret = gdunsafe.Call[Vector2.XY](self.AsObject(), gd.Global.Methods.OpenXRCompositionLayer.Bind_intersects_ray, gdextension.SizeVector2|(gdextension.SizeVector3<<4)|(gdextension.SizeVector3<<8), unsafe.Pointer(&struct {
		origin    Vector3.XYZ
		direction Vector3.XYZ
	}{origin, direction}))
	var ret = r_ret
	return ret
}
func (self class) AsOpenXRCompositionLayer() Advanced { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsOpenXRCompositionLayer() Instance {
	return *((*Instance)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsOpenXRCompositionLayer() Instance {
	return self.Super().AsOpenXRCompositionLayer()
}
func (self class) AsNode3D() Node3D.Advanced         { return *((*Node3D.Advanced)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsNode3D() Node3D.Instance { return self.Super().AsNode3D() }
func (self Instance) AsNode3D() Node3D.Instance      { return *((*Node3D.Instance)(unsafe.Pointer(&self))) }
func (self class) AsNode() Node.Advanced             { return *((*Node.Advanced)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsNode() Node.Instance     { return self.Super().AsNode() }
func (self Instance) AsNode() Node.Instance          { return *((*Node.Instance)(unsafe.Pointer(&self))) }

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Node3D.Advanced(self.AsNode3D()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Node3D.Instance(self.AsNode3D()), name)
	}
}
func init() {
	gdclass.Register("OpenXRCompositionLayer", func(ptr gd.Object) any {
		return [1]gdclass.OpenXRCompositionLayer{*(*gdclass.OpenXRCompositionLayer)(unsafe.Pointer(&ptr))}
	})
}
