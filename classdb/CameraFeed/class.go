// Code generated by the generate package DO NOT EDIT

// Package CameraFeed provides methods for working with CameraFeed object instances.
package CameraFeed

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/Image"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"
import "graphics.gd/variant/Transform2D"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
A camera feed gives you access to a single physical camera attached to your device. When enabled, Godot will start capturing frames from the camera which can then be used. See also [CameraServer].
[b]Note:[/b] Many cameras will return YCbCr images which are split into two textures and need to be combined in a shader. Godot does this automatically for you if you set the environment to show the camera image in the background.
[b]Note:[/b] This class is currently only implemented on Linux, macOS, and iOS. On other platforms no [CameraFeed]s will be available. To get a [CameraFeed] on iOS, the camera plugin from [url=https://github.com/godotengine/godot-ios-plugins]godot-ios-plugins[/url] is required.

	See [Interface] for methods that can be overridden by a [Class] that extends it.
*/
type Instance [1]gdclass.CameraFeed

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	get_id             gdextension.MethodForClass `hash:"3905245786"`
	is_active          gdextension.MethodForClass `hash:"36873697"`
	set_active         gdextension.MethodForClass `hash:"2586408642"`
	get_name           gdextension.MethodForClass `hash:"201670096"`
	set_name           gdextension.MethodForClass `hash:"83702148"`
	get_position       gdextension.MethodForClass `hash:"2711679033"`
	set_position       gdextension.MethodForClass `hash:"611162623"`
	get_transform      gdextension.MethodForClass `hash:"3814499831"`
	set_transform      gdextension.MethodForClass `hash:"2761652528"`
	set_rgb_image      gdextension.MethodForClass `hash:"532598488"`
	set_ycbcr_image    gdextension.MethodForClass `hash:"532598488"`
	set_external       gdextension.MethodForClass `hash:"3937882851"`
	get_texture_tex_id gdextension.MethodForClass `hash:"1135699418"`
	get_datatype       gdextension.MethodForClass `hash:"1477782850"`
	get_formats        gdextension.MethodForClass `hash:"3995934104"`
	set_format         gdextension.MethodForClass `hash:"31872775"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("CameraFeed")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		gdextension.Free(gdextension.TypeStringName, &sname)
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsCameraFeed() Instance
}
type Interface interface {
	//Called when the camera feed is activated.
	ActivateFeed() bool
	//Called when the camera feed is deactivated.
	DeactivateFeed()
}

// Implementation implements [Interface] with empty methods.
type Implementation = implementation

type implementation struct{}

func (self implementation) ActivateFeed() (_ bool) { return }
func (self implementation) DeactivateFeed()        { return }

/*
Called when the camera feed is activated.
*/
func (Instance) _activate_feed(impl func(ptr unsafe.Pointer) bool) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		gd.UnsafeSet(p_back, ret)
	}
}

/*
Called when the camera feed is deactivated.
*/
func (Instance) _deactivate_feed(impl func(ptr unsafe.Pointer)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self)
	}
}

/*
Returns the unique ID for this feed.
*/
func (self Instance) GetId() int { //gd:CameraFeed.get_id
	return int(int(Advanced(self).GetId()))
}

/*
Returns the camera's name.
*/
func (self Instance) GetName() string { //gd:CameraFeed.get_name
	return string(Advanced(self).GetName().String())
}

/*
Sets the camera's name.
*/
func (self Instance) SetName(name string) { //gd:CameraFeed.set_name
	Advanced(self).SetName(String.New(name))
}

/*
Returns the position of camera on the device.
*/
func (self Instance) GetPosition() FeedPosition { //gd:CameraFeed.get_position
	return FeedPosition(Advanced(self).GetPosition())
}

/*
Sets the position of this camera.
*/
func (self Instance) SetPosition(position FeedPosition) { //gd:CameraFeed.set_position
	Advanced(self).SetPosition(position)
}

/*
Sets RGB image for this feed.
*/
func (self Instance) SetRgbImage(rgb_image Image.Instance) { //gd:CameraFeed.set_rgb_image
	Advanced(self).SetRgbImage(rgb_image)
}

/*
Sets YCbCr image for this feed.
*/
func (self Instance) SetYcbcrImage(ycbcr_image Image.Instance) { //gd:CameraFeed.set_ycbcr_image
	Advanced(self).SetYcbcrImage(ycbcr_image)
}

/*
Sets the feed as external feed provided by another library.
*/
func (self Instance) SetExternal(width int, height int) { //gd:CameraFeed.set_external
	Advanced(self).SetExternal(int64(width), int64(height))
}

/*
Returns the texture backend ID (usable by some external libraries that need a handle to a texture to write data).
*/
func (self Instance) GetTextureTexId(feed_image_type ImageType) int { //gd:CameraFeed.get_texture_tex_id
	return int(int(Advanced(self).GetTextureTexId(feed_image_type)))
}

/*
Returns feed image data type.
*/
func (self Instance) GetDatatype() FeedDataType { //gd:CameraFeed.get_datatype
	return FeedDataType(Advanced(self).GetDatatype())
}

/*
Sets the feed format parameters for the given index in the [member formats] array. Returns [code]true[/code] on success. By default YUYV encoded stream is transformed to FEED_RGB. YUYV encoded stream output format can be changed with [param parameters].output value:
[code]separate[/code] will result in FEED_YCBCR_SEP
[code]grayscale[/code] will result in desaturated FEED_RGB
[code]copy[/code] will result in FEED_YCBCR
*/
func (self Instance) SetFormat(index int, parameters FormatParameters) bool { //gd:CameraFeed.set_format
	return bool(Advanced(self).SetFormat(int64(index), gd.DictionaryFromMap(parameters)))
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.CameraFeed

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.CameraFeed)(unsafe.Pointer(&obj))
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.CameraFeed)(unsafe.Pointer(&obj))
		return true
	}
	return false
}

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {

	if !gd.Linked {
		var placeholder Instance
		*(*gd.Object)(unsafe.Pointer(&placeholder)) = pointers.Add[gd.Object]([3]uint64{})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(*(*gd.Object)(unsafe.Pointer(&placeholder)), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	object := [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})}
	casted := Instance{*(*gdclass.CameraFeed)(unsafe.Pointer(&object))}
	object[0].Notification(0, false)
	return casted
}

func (self Instance) FeedIsActive() bool {
	return bool(class(self).IsActive())
}

func (self Instance) SetFeedIsActive(value bool) {
	class(self).SetActive(value)
}

func (self Instance) FeedTransform() Transform2D.OriginXY {
	return Transform2D.OriginXY(class(self).GetTransform())
}

func (self Instance) SetFeedTransform(value Transform2D.OriginXY) {
	class(self).SetTransform(Transform2D.OriginXY(value))
}

func (self Instance) Formats() []any {
	return []any(gd.ArrayAs[[]any](gd.InternalArray(class(self).GetFormats())))
}

/*
Called when the camera feed is activated.
*/
func (class) _activate_feed(impl func(ptr unsafe.Pointer) bool) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		gd.UnsafeSet(p_back, ret)
	}
}

/*
Called when the camera feed is deactivated.
*/
func (class) _deactivate_feed(impl func(ptr unsafe.Pointer)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self)
	}
}

/*
Returns the unique ID for this feed.
*/
//go:nosplit
func (self class) GetId() int64 { //gd:CameraFeed.get_id
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_id, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) IsActive() bool { //gd:CameraFeed.is_active
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_active, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetActive(active bool) { //gd:CameraFeed.set_active
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_active, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ active bool }{active}))
}

/*
Returns the camera's name.
*/
//go:nosplit
func (self class) GetName() String.Readable { //gd:CameraFeed.get_name
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_name, gdextension.SizeString, unsafe.Pointer(&struct{}{}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Sets the camera's name.
*/
//go:nosplit
func (self class) SetName(name String.Readable) { //gd:CameraFeed.set_name
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_name, 0|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ name gdextension.String }{pointers.Get(gd.InternalString(name))}))
}

/*
Returns the position of camera on the device.
*/
//go:nosplit
func (self class) GetPosition() FeedPosition { //gd:CameraFeed.get_position
	var r_ret = gdextension.Call[FeedPosition](gd.ObjectChecked(self.AsObject()), methods.get_position, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Sets the position of this camera.
*/
//go:nosplit
func (self class) SetPosition(position FeedPosition) { //gd:CameraFeed.set_position
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_position, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ position FeedPosition }{position}))
}

//go:nosplit
func (self class) GetTransform() Transform2D.OriginXY { //gd:CameraFeed.get_transform
	var r_ret = gdextension.Call[Transform2D.OriginXY](gd.ObjectChecked(self.AsObject()), methods.get_transform, gdextension.SizeTransform2D, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetTransform(transform Transform2D.OriginXY) { //gd:CameraFeed.set_transform
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_transform, 0|(gdextension.SizeTransform2D<<4), unsafe.Pointer(&struct{ transform Transform2D.OriginXY }{transform}))
}

/*
Sets RGB image for this feed.
*/
//go:nosplit
func (self class) SetRgbImage(rgb_image [1]gdclass.Image) { //gd:CameraFeed.set_rgb_image
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_rgb_image, 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ rgb_image gdextension.Object }{gdextension.Object(gd.CallerIncrements(rgb_image[0].AsObject()))}))
}

/*
Sets YCbCr image for this feed.
*/
//go:nosplit
func (self class) SetYcbcrImage(ycbcr_image [1]gdclass.Image) { //gd:CameraFeed.set_ycbcr_image
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_ycbcr_image, 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ ycbcr_image gdextension.Object }{gdextension.Object(gd.CallerIncrements(ycbcr_image[0].AsObject()))}))
}

/*
Sets the feed as external feed provided by another library.
*/
//go:nosplit
func (self class) SetExternal(width int64, height int64) { //gd:CameraFeed.set_external
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_external, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		width  int64
		height int64
	}{width, height}))
}

/*
Returns the texture backend ID (usable by some external libraries that need a handle to a texture to write data).
*/
//go:nosplit
func (self class) GetTextureTexId(feed_image_type ImageType) int64 { //gd:CameraFeed.get_texture_tex_id
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_texture_tex_id, gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ feed_image_type ImageType }{feed_image_type}))
	var ret = r_ret
	return ret
}

/*
Returns feed image data type.
*/
//go:nosplit
func (self class) GetDatatype() FeedDataType { //gd:CameraFeed.get_datatype
	var r_ret = gdextension.Call[FeedDataType](gd.ObjectChecked(self.AsObject()), methods.get_datatype, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) GetFormats() Array.Any { //gd:CameraFeed.get_formats
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), methods.get_formats, gdextension.SizeArray, unsafe.Pointer(&struct{}{}))
	var ret = Array.Through(gd.ArrayProxy[variant.Any]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

/*
Sets the feed format parameters for the given index in the [member formats] array. Returns [code]true[/code] on success. By default YUYV encoded stream is transformed to FEED_RGB. YUYV encoded stream output format can be changed with [param parameters].output value:
[code]separate[/code] will result in FEED_YCBCR_SEP
[code]grayscale[/code] will result in desaturated FEED_RGB
[code]copy[/code] will result in FEED_YCBCR
*/
//go:nosplit
func (self class) SetFormat(index int64, parameters Dictionary.Any) bool { //gd:CameraFeed.set_format
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.set_format, gdextension.SizeBool|(gdextension.SizeInt<<4)|(gdextension.SizeDictionary<<8), unsafe.Pointer(&struct {
		index      int64
		parameters gdextension.Dictionary
	}{index, pointers.Get(gd.InternalDictionary(parameters))}))
	var ret = r_ret
	return ret
}
func (self Instance) OnFrameChanged(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("frame_changed"), gd.NewCallable(cb), 0)
}

func (self Instance) OnFormatChanged(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("format_changed"), gd.NewCallable(cb), 0)
}

func (self class) AsCameraFeed() Advanced         { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsCameraFeed() Instance      { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsCameraFeed() Instance { return self.Super().AsCameraFeed() }
func (self class) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsRefCounted() [1]gd.RefCounted { return self.Super().AsRefCounted() }
func (self Instance) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	case "_activate_feed":
		return reflect.ValueOf(self._activate_feed)
	case "_deactivate_feed":
		return reflect.ValueOf(self._deactivate_feed)
	default:
		return gd.VirtualByName(RefCounted.Advanced(self.AsRefCounted()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	case "_activate_feed":
		return reflect.ValueOf(self._activate_feed)
	case "_deactivate_feed":
		return reflect.ValueOf(self._deactivate_feed)
	default:
		return gd.VirtualByName(RefCounted.Instance(self.AsRefCounted()), name)
	}
}
func init() {
	gdclass.Register("CameraFeed", func(ptr gd.Object) any { return *(*Instance)(unsafe.Pointer(&ptr)) })
}

type FeedDataType int //gd:CameraFeed.FeedDataType

const (
	/*No image set for the feed.*/
	FeedNoimage FeedDataType = 0
	/*Feed supplies RGB images.*/
	FeedRgb FeedDataType = 1
	/*Feed supplies YCbCr images that need to be converted to RGB.*/
	FeedYcbcr FeedDataType = 2
	/*Feed supplies separate Y and CbCr images that need to be combined and converted to RGB.*/
	FeedYcbcrSep FeedDataType = 3
	/*Feed supplies external image.*/
	FeedExternal FeedDataType = 4
)

type FeedPosition int //gd:CameraFeed.FeedPosition

const (
	/*Unspecified position.*/
	FeedUnspecified FeedPosition = 0
	/*Camera is mounted at the front of the device.*/
	FeedFront FeedPosition = 1
	/*Camera is mounted at the back of the device.*/
	FeedBack FeedPosition = 2
)

type ImageType int //gd:CameraServer.FeedImage

const (
	/*The RGBA camera image.*/
	FeedRgbaImage ImageType = 0
	/*The [url=https://en.wikipedia.org/wiki/YCbCr]YCbCr[/url] camera image.*/
	FeedYcbcrImage ImageType = 0
	/*The Y component camera image.*/
	FeedYImage ImageType = 0
	/*The CbCr component camera image.*/
	FeedCbcrImage ImageType = 1
)

type FormatParameters struct {
	Output string `gd:"output"`
}
