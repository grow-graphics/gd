// Code generated by the generate package DO NOT EDIT

// Package OpenXRAPIExtension provides methods for working with OpenXRAPIExtension object instances.
package OpenXRAPIExtension

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/OpenXRExtensionWrapperExtension"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/Rect2i"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"
import "graphics.gd/variant/Transform3D"
import "graphics.gd/variant/Vector2i"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
[OpenXRAPIExtension] makes OpenXR available for GDExtension. It provides the OpenXR API to GDExtension through the [method get_instance_proc_addr] method, and the OpenXR instance through [method get_instance].
It also provides methods for querying the status of OpenXR initialization, and helper methods for ease of use of the API with GDExtension.
*/
type Instance [1]gdclass.OpenXRAPIExtension

func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsOpenXRAPIExtension() Instance
}

/*
Returns the [url=https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrInstance.html]XrInstance[/url] created during the initialization of the OpenXR API.
*/
func (self Instance) GetInstance() int { //gd:OpenXRAPIExtension.get_instance
	return int(int(Advanced(self).GetInstance()))
}

/*
Returns the id of the system, which is a [url=https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrSystemId.html]XrSystemId[/url] cast to an integer.
*/
func (self Instance) GetSystemId() int { //gd:OpenXRAPIExtension.get_system_id
	return int(int(Advanced(self).GetSystemId()))
}

/*
Returns the OpenXR session, which is an [url=https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrSession.html]XrSession[/url] cast to an integer.
*/
func (self Instance) GetSession() int { //gd:OpenXRAPIExtension.get_session
	return int(int(Advanced(self).GetSession()))
}

/*
Creates a [Transform3D] from an [url=https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrPosef.html]XrPosef[/url].
*/
func (self Instance) TransformFromPose(pose unsafe.Pointer) Transform3D.BasisOrigin { //gd:OpenXRAPIExtension.transform_from_pose
	return Transform3D.BasisOrigin(Advanced(self).TransformFromPose(pose))
}

/*
Returns [code]true[/code] if the provided [url=https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrResult.html]XrResult[/url] (cast to an integer) is successful. Otherwise returns [code]false[/code] and prints the [url=https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrResult.html]XrResult[/url] converted to a string, with the specified additional information.
*/
func (self Instance) XrResult(result int, format string, args []any) bool { //gd:OpenXRAPIExtension.xr_result
	return bool(Advanced(self).XrResult(int64(result), String.New(format), gd.EngineArrayFromSlice(args)))
}

/*
Returns [code]true[/code] if OpenXR is enabled.
*/
func OpenxrIsEnabled(check_run_in_editor bool) bool { //gd:OpenXRAPIExtension.openxr_is_enabled
	self := Instance{}
	return bool(Advanced(self).OpenxrIsEnabled(check_run_in_editor))
}

/*
Returns the function pointer of the OpenXR function with the specified name, cast to an integer. If the function with the given name does not exist, the method returns [code]0[/code].
[b]Note:[/b] [code]openxr/util.h[/code] contains utility macros for acquiring OpenXR functions, e.g. [code]GDEXTENSION_INIT_XR_FUNC_V(xrCreateAction)[/code].
*/
func (self Instance) GetInstanceProcAddr(name string) int { //gd:OpenXRAPIExtension.get_instance_proc_addr
	return int(int(Advanced(self).GetInstanceProcAddr(String.New(name))))
}

/*
Returns an error string for the given [url=https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrResult.html]XrResult[/url].
*/
func (self Instance) GetErrorString(result int) string { //gd:OpenXRAPIExtension.get_error_string
	return string(Advanced(self).GetErrorString(int64(result)).String())
}

/*
Returns the name of the specified swapchain format.
*/
func (self Instance) GetSwapchainFormatName(swapchain_format int) string { //gd:OpenXRAPIExtension.get_swapchain_format_name
	return string(Advanced(self).GetSwapchainFormatName(int64(swapchain_format)).String())
}

/*
Set the object name of an OpenXR object, used for debug output. [param object_type] must be a valid OpenXR [code]XrObjectType[/code] enum and [param object_handle] must be a valid OpenXR object handle.
*/
func (self Instance) SetObjectName(object_type int, object_handle int, object_name string) { //gd:OpenXRAPIExtension.set_object_name
	Advanced(self).SetObjectName(int64(object_type), int64(object_handle), String.New(object_name))
}

/*
Begins a new debug label region, this label will be reported in debug messages for any calls following this until [method end_debug_label_region] is called. Debug labels can be stacked.
*/
func (self Instance) BeginDebugLabelRegion(label_name string) { //gd:OpenXRAPIExtension.begin_debug_label_region
	Advanced(self).BeginDebugLabelRegion(String.New(label_name))
}

/*
Marks the end of a debug label region. Removes the latest debug label region added by calling [method begin_debug_label_region].
*/
func (self Instance) EndDebugLabelRegion() { //gd:OpenXRAPIExtension.end_debug_label_region
	Advanced(self).EndDebugLabelRegion()
}

/*
Inserts a debug label, this label is reported in any debug message resulting from the OpenXR calls that follows, until any of [method begin_debug_label_region], [method end_debug_label_region], or [method insert_debug_label] is called.
*/
func (self Instance) InsertDebugLabel(label_name string) { //gd:OpenXRAPIExtension.insert_debug_label
	Advanced(self).InsertDebugLabel(String.New(label_name))
}

/*
Returns [code]true[/code] if OpenXR is initialized.
*/
func (self Instance) IsInitialized() bool { //gd:OpenXRAPIExtension.is_initialized
	return bool(Advanced(self).IsInitialized())
}

/*
Returns [code]true[/code] if OpenXR is running ([url=https://registry.khronos.org/OpenXR/specs/1.0/man/html/xrBeginSession.html]xrBeginSession[/url] was successfully called and the swapchains were created).
*/
func (self Instance) IsRunning() bool { //gd:OpenXRAPIExtension.is_running
	return bool(Advanced(self).IsRunning())
}

/*
Returns the play space, which is an [url=https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrSpace.html]XrSpace[/url] cast to an integer.
*/
func (self Instance) GetPlaySpace() int { //gd:OpenXRAPIExtension.get_play_space
	return int(int(Advanced(self).GetPlaySpace()))
}

/*
Returns the predicted display timing for the current frame.
*/
func (self Instance) GetPredictedDisplayTime() int { //gd:OpenXRAPIExtension.get_predicted_display_time
	return int(int(Advanced(self).GetPredictedDisplayTime()))
}

/*
Returns the predicted display timing for the next frame.
*/
func (self Instance) GetNextFrameTime() int { //gd:OpenXRAPIExtension.get_next_frame_time
	return int(int(Advanced(self).GetNextFrameTime()))
}

/*
Returns [code]true[/code] if OpenXR is initialized for rendering with an XR viewport.
*/
func (self Instance) CanRender() bool { //gd:OpenXRAPIExtension.can_render
	return bool(Advanced(self).CanRender())
}

/*
Returns the [RID] corresponding to an [code]Action[/code] of a matching name, optionally limited to a specified action set.
*/
func (self Instance) FindAction(name string, action_set RID.ActionSet) RID.Action { //gd:OpenXRAPIExtension.find_action
	return RID.Action(Advanced(self).FindAction(String.New(name), RID.Any(action_set)))
}

/*
Returns the corresponding [code]XrAction[/code] OpenXR handle for the given action RID.
*/
func (self Instance) ActionGetHandle(action RID.Action) int { //gd:OpenXRAPIExtension.action_get_handle
	return int(int(Advanced(self).ActionGetHandle(RID.Any(action))))
}

/*
Returns the corresponding [code]XRHandTrackerEXT[/code] handle for the given hand index value.
*/
func (self Instance) GetHandTracker(hand_index int) int { //gd:OpenXRAPIExtension.get_hand_tracker
	return int(int(Advanced(self).GetHandTracker(int64(hand_index))))
}

/*
Registers the given extension as a composition layer provider.
*/
func (self Instance) RegisterCompositionLayerProvider(extension OpenXRExtensionWrapperExtension.Instance) { //gd:OpenXRAPIExtension.register_composition_layer_provider
	Advanced(self).RegisterCompositionLayerProvider(extension)
}

/*
Unregisters the given extension as a composition layer provider.
*/
func (self Instance) UnregisterCompositionLayerProvider(extension OpenXRExtensionWrapperExtension.Instance) { //gd:OpenXRAPIExtension.unregister_composition_layer_provider
	Advanced(self).UnregisterCompositionLayerProvider(extension)
}

/*
Registers the given extension as a provider of additional data structures to projections views.
*/
func (self Instance) RegisterProjectionViewsExtension(extension OpenXRExtensionWrapperExtension.Instance) { //gd:OpenXRAPIExtension.register_projection_views_extension
	Advanced(self).RegisterProjectionViewsExtension(extension)
}

/*
Unregisters the given extension as a provider of additional data structures to projections views.
*/
func (self Instance) UnregisterProjectionViewsExtension(extension OpenXRExtensionWrapperExtension.Instance) { //gd:OpenXRAPIExtension.unregister_projection_views_extension
	Advanced(self).UnregisterProjectionViewsExtension(extension)
}

/*
Returns the near boundary value of the camera frustum.
[b]Note:[/b] This is only accessible in the render thread.
*/
func (self Instance) GetRenderStateZNear() Float.X { //gd:OpenXRAPIExtension.get_render_state_z_near
	return Float.X(Float.X(Advanced(self).GetRenderStateZNear()))
}

/*
Returns the far boundary value of the camera frustum.
[b]Note:[/b] This is only accessible in the render thread.
*/
func (self Instance) GetRenderStateZFar() Float.X { //gd:OpenXRAPIExtension.get_render_state_z_far
	return Float.X(Float.X(Advanced(self).GetRenderStateZFar()))
}

/*
Sets the render target of the velocity texture.
*/
func (self Instance) SetVelocityTexture(render_target RID.Framebuffer) { //gd:OpenXRAPIExtension.set_velocity_texture
	Advanced(self).SetVelocityTexture(RID.Any(render_target))
}

/*
Sets the render target of the velocity depth texture.
*/
func (self Instance) SetVelocityDepthTexture(render_target RID.Framebuffer) { //gd:OpenXRAPIExtension.set_velocity_depth_texture
	Advanced(self).SetVelocityDepthTexture(RID.Any(render_target))
}

/*
Sets the target size of the velocity and velocity depth textures.
*/
func (self Instance) SetVelocityTargetSize(target_size Vector2i.XY) { //gd:OpenXRAPIExtension.set_velocity_target_size
	Advanced(self).SetVelocityTargetSize(Vector2i.XY(target_size))
}

/*
Returns an array of supported swapchain formats.
*/
func (self Instance) GetSupportedSwapchainFormats() []int64 { //gd:OpenXRAPIExtension.get_supported_swapchain_formats
	return []int64(slices.Collect(Advanced(self).GetSupportedSwapchainFormats().Values()))
}

/*
Returns a pointer to a new swapchain created using the provided parameters.
*/
func (self Instance) OpenxrSwapchainCreate(create_flags int, usage_flags int, swapchain_format int, width int, height int, sample_count int, array_size int) int { //gd:OpenXRAPIExtension.openxr_swapchain_create
	return int(int(Advanced(self).OpenxrSwapchainCreate(int64(create_flags), int64(usage_flags), int64(swapchain_format), int64(width), int64(height), int64(sample_count), int64(array_size))))
}

/*
Destroys the provided swapchain and frees it from memory.
*/
func (self Instance) OpenxrSwapchainFree(swapchain int) { //gd:OpenXRAPIExtension.openxr_swapchain_free
	Advanced(self).OpenxrSwapchainFree(int64(swapchain))
}

/*
Returns the [code]XrSwapchain[/code] handle of the provided swapchain.
*/
func (self Instance) OpenxrSwapchainGetSwapchain(swapchain int) int { //gd:OpenXRAPIExtension.openxr_swapchain_get_swapchain
	return int(int(Advanced(self).OpenxrSwapchainGetSwapchain(int64(swapchain))))
}

/*
Acquires the image of the provided swapchain.
*/
func (self Instance) OpenxrSwapchainAcquire(swapchain int) { //gd:OpenXRAPIExtension.openxr_swapchain_acquire
	Advanced(self).OpenxrSwapchainAcquire(int64(swapchain))
}

/*
Returns the RID of the provided swapchain's image.
*/
func (self Instance) OpenxrSwapchainGetImage(swapchain int) RID.Texture { //gd:OpenXRAPIExtension.openxr_swapchain_get_image
	return RID.Texture(Advanced(self).OpenxrSwapchainGetImage(int64(swapchain)))
}

/*
Releases the image of the provided swapchain.
*/
func (self Instance) OpenxrSwapchainRelease(swapchain int) { //gd:OpenXRAPIExtension.openxr_swapchain_release
	Advanced(self).OpenxrSwapchainRelease(int64(swapchain))
}

/*
Returns a pointer to the render state's [code]XrCompositionLayerProjection[/code] struct.
[b]Note:[/b] This method should only be called from the rendering thread.
*/
func (self Instance) GetProjectionLayer() int { //gd:OpenXRAPIExtension.get_projection_layer
	return int(int(Advanced(self).GetProjectionLayer()))
}

/*
Sets the render region to [param render_region], overriding the normal render target's rect.
*/
func (self Instance) SetRenderRegion(render_region Rect2i.PositionSize) { //gd:OpenXRAPIExtension.set_render_region
	Advanced(self).SetRenderRegion(Rect2i.PositionSize(render_region))
}

/*
If set to [code]true[/code], an OpenXR extension is loaded which is capable of emulating the [constant XRInterface.XR_ENV_BLEND_MODE_ALPHA_BLEND] blend mode.
*/
func (self Instance) SetEmulateEnvironmentBlendModeAlphaBlend(enabled bool) { //gd:OpenXRAPIExtension.set_emulate_environment_blend_mode_alpha_blend
	Advanced(self).SetEmulateEnvironmentBlendModeAlphaBlend(enabled)
}

/*
Returns [enum OpenXRAPIExtension.OpenXRAlphaBlendModeSupport] denoting if [constant XRInterface.XR_ENV_BLEND_MODE_ALPHA_BLEND] is really supported, emulated or not supported at all.
*/
func (self Instance) IsEnvironmentBlendModeAlphaSupported() OpenXRAlphaBlendModeSupport { //gd:OpenXRAPIExtension.is_environment_blend_mode_alpha_supported
	return OpenXRAlphaBlendModeSupport(Advanced(self).IsEnvironmentBlendModeAlphaSupported())
}

/*
Returns the created [OpenXRAPIExtension], which can be used to access the OpenXR API.
*/
func GetFromWrapperExtension(peer OpenXRExtensionWrapperExtension.Instance) Instance { //gd:OpenXRExtensionWrapperExtension.get_openxr_api
	return Instance(OpenXRExtensionWrapperExtension.Advanced(peer).GetOpenxrApi())
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.OpenXRAPIExtension

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {
	object := gd.Global.ClassDB.ConstructObject(gd.NewStringName("OpenXRAPIExtension"))
	casted := Instance{*(*gdclass.OpenXRAPIExtension)(unsafe.Pointer(&object))}
	casted.AsRefCounted()[0].Reference()
	return casted
}

/*
Returns the [url=https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrInstance.html]XrInstance[/url] created during the initialization of the OpenXR API.
*/
//go:nosplit
func (self class) GetInstance() int64 { //gd:OpenXRAPIExtension.get_instance
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRAPIExtension.Bind_get_instance), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the id of the system, which is a [url=https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrSystemId.html]XrSystemId[/url] cast to an integer.
*/
//go:nosplit
func (self class) GetSystemId() int64 { //gd:OpenXRAPIExtension.get_system_id
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRAPIExtension.Bind_get_system_id), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the OpenXR session, which is an [url=https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrSession.html]XrSession[/url] cast to an integer.
*/
//go:nosplit
func (self class) GetSession() int64 { //gd:OpenXRAPIExtension.get_session
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRAPIExtension.Bind_get_session), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Creates a [Transform3D] from an [url=https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrPosef.html]XrPosef[/url].
*/
//go:nosplit
func (self class) TransformFromPose(pose unsafe.Pointer) Transform3D.BasisOrigin { //gd:OpenXRAPIExtension.transform_from_pose
	var r_ret = gdextension.Call[Transform3D.BasisOrigin](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRAPIExtension.Bind_transform_from_pose), gdextension.SizeTransform3D|(gdextension.SizePointer<<4), unsafe.Pointer(&struct{ pose unsafe.Pointer }{pose}))
	var ret = gd.Transposed(r_ret)
	return ret
}

/*
Returns [code]true[/code] if the provided [url=https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrResult.html]XrResult[/url] (cast to an integer) is successful. Otherwise returns [code]false[/code] and prints the [url=https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrResult.html]XrResult[/url] converted to a string, with the specified additional information.
*/
//go:nosplit
func (self class) XrResult(result int64, format String.Readable, args Array.Any) bool { //gd:OpenXRAPIExtension.xr_result
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRAPIExtension.Bind_xr_result), gdextension.SizeBool|(gdextension.SizeInt<<4)|(gdextension.SizeString<<8)|(gdextension.SizeArray<<12), unsafe.Pointer(&struct {
		result int64
		format gdextension.String
		args   gdextension.Array
	}{result, gdextension.String(pointers.Get(gd.InternalString(format))[0]), gdextension.Array(pointers.Get(gd.InternalArray(args))[0])}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if OpenXR is enabled.
*/
//go:nosplit
func (self class) OpenxrIsEnabled(check_run_in_editor bool) bool { //gd:OpenXRAPIExtension.openxr_is_enabled
	var r_ret = gdextension.CallStatic[bool](gdextension.MethodForClass(gd.Global.Methods.OpenXRAPIExtension.Bind_openxr_is_enabled), gdextension.SizeBool|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ check_run_in_editor bool }{check_run_in_editor}))
	var ret = r_ret
	return ret
}

/*
Returns the function pointer of the OpenXR function with the specified name, cast to an integer. If the function with the given name does not exist, the method returns [code]0[/code].
[b]Note:[/b] [code]openxr/util.h[/code] contains utility macros for acquiring OpenXR functions, e.g. [code]GDEXTENSION_INIT_XR_FUNC_V(xrCreateAction)[/code].
*/
//go:nosplit
func (self class) GetInstanceProcAddr(name String.Readable) int64 { //gd:OpenXRAPIExtension.get_instance_proc_addr
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRAPIExtension.Bind_get_instance_proc_addr), gdextension.SizeInt|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ name gdextension.String }{gdextension.String(pointers.Get(gd.InternalString(name))[0])}))
	var ret = r_ret
	return ret
}

/*
Returns an error string for the given [url=https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrResult.html]XrResult[/url].
*/
//go:nosplit
func (self class) GetErrorString(result int64) String.Readable { //gd:OpenXRAPIExtension.get_error_string
	var r_ret = gdextension.Call[[1]gd.EnginePointer](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRAPIExtension.Bind_get_error_string), gdextension.SizeString|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ result int64 }{result}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Returns the name of the specified swapchain format.
*/
//go:nosplit
func (self class) GetSwapchainFormatName(swapchain_format int64) String.Readable { //gd:OpenXRAPIExtension.get_swapchain_format_name
	var r_ret = gdextension.Call[[1]gd.EnginePointer](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRAPIExtension.Bind_get_swapchain_format_name), gdextension.SizeString|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ swapchain_format int64 }{swapchain_format}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Set the object name of an OpenXR object, used for debug output. [param object_type] must be a valid OpenXR [code]XrObjectType[/code] enum and [param object_handle] must be a valid OpenXR object handle.
*/
//go:nosplit
func (self class) SetObjectName(object_type int64, object_handle int64, object_name String.Readable) { //gd:OpenXRAPIExtension.set_object_name
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRAPIExtension.Bind_set_object_name), 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeString<<12), unsafe.Pointer(&struct {
		object_type   int64
		object_handle int64
		object_name   gdextension.String
	}{object_type, object_handle, gdextension.String(pointers.Get(gd.InternalString(object_name))[0])}))
}

/*
Begins a new debug label region, this label will be reported in debug messages for any calls following this until [method end_debug_label_region] is called. Debug labels can be stacked.
*/
//go:nosplit
func (self class) BeginDebugLabelRegion(label_name String.Readable) { //gd:OpenXRAPIExtension.begin_debug_label_region
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRAPIExtension.Bind_begin_debug_label_region), 0|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ label_name gdextension.String }{gdextension.String(pointers.Get(gd.InternalString(label_name))[0])}))
}

/*
Marks the end of a debug label region. Removes the latest debug label region added by calling [method begin_debug_label_region].
*/
//go:nosplit
func (self class) EndDebugLabelRegion() { //gd:OpenXRAPIExtension.end_debug_label_region
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRAPIExtension.Bind_end_debug_label_region), 0, unsafe.Pointer(&struct{}{}))
}

/*
Inserts a debug label, this label is reported in any debug message resulting from the OpenXR calls that follows, until any of [method begin_debug_label_region], [method end_debug_label_region], or [method insert_debug_label] is called.
*/
//go:nosplit
func (self class) InsertDebugLabel(label_name String.Readable) { //gd:OpenXRAPIExtension.insert_debug_label
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRAPIExtension.Bind_insert_debug_label), 0|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ label_name gdextension.String }{gdextension.String(pointers.Get(gd.InternalString(label_name))[0])}))
}

/*
Returns [code]true[/code] if OpenXR is initialized.
*/
//go:nosplit
func (self class) IsInitialized() bool { //gd:OpenXRAPIExtension.is_initialized
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRAPIExtension.Bind_is_initialized), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if OpenXR is running ([url=https://registry.khronos.org/OpenXR/specs/1.0/man/html/xrBeginSession.html]xrBeginSession[/url] was successfully called and the swapchains were created).
*/
//go:nosplit
func (self class) IsRunning() bool { //gd:OpenXRAPIExtension.is_running
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRAPIExtension.Bind_is_running), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the play space, which is an [url=https://registry.khronos.org/OpenXR/specs/1.0/man/html/XrSpace.html]XrSpace[/url] cast to an integer.
*/
//go:nosplit
func (self class) GetPlaySpace() int64 { //gd:OpenXRAPIExtension.get_play_space
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRAPIExtension.Bind_get_play_space), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the predicted display timing for the current frame.
*/
//go:nosplit
func (self class) GetPredictedDisplayTime() int64 { //gd:OpenXRAPIExtension.get_predicted_display_time
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRAPIExtension.Bind_get_predicted_display_time), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the predicted display timing for the next frame.
*/
//go:nosplit
func (self class) GetNextFrameTime() int64 { //gd:OpenXRAPIExtension.get_next_frame_time
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRAPIExtension.Bind_get_next_frame_time), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if OpenXR is initialized for rendering with an XR viewport.
*/
//go:nosplit
func (self class) CanRender() bool { //gd:OpenXRAPIExtension.can_render
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRAPIExtension.Bind_can_render), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the [RID] corresponding to an [code]Action[/code] of a matching name, optionally limited to a specified action set.
*/
//go:nosplit
func (self class) FindAction(name String.Readable, action_set RID.Any) RID.Any { //gd:OpenXRAPIExtension.find_action
	var r_ret = gdextension.Call[RID.Any](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRAPIExtension.Bind_find_action), gdextension.SizeRID|(gdextension.SizeString<<4)|(gdextension.SizeRID<<8), unsafe.Pointer(&struct {
		name       gdextension.String
		action_set RID.Any
	}{gdextension.String(pointers.Get(gd.InternalString(name))[0]), action_set}))
	var ret = r_ret
	return ret
}

/*
Returns the corresponding [code]XrAction[/code] OpenXR handle for the given action RID.
*/
//go:nosplit
func (self class) ActionGetHandle(action RID.Any) int64 { //gd:OpenXRAPIExtension.action_get_handle
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRAPIExtension.Bind_action_get_handle), gdextension.SizeInt|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ action RID.Any }{action}))
	var ret = r_ret
	return ret
}

/*
Returns the corresponding [code]XRHandTrackerEXT[/code] handle for the given hand index value.
*/
//go:nosplit
func (self class) GetHandTracker(hand_index int64) int64 { //gd:OpenXRAPIExtension.get_hand_tracker
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRAPIExtension.Bind_get_hand_tracker), gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ hand_index int64 }{hand_index}))
	var ret = r_ret
	return ret
}

/*
Registers the given extension as a composition layer provider.
*/
//go:nosplit
func (self class) RegisterCompositionLayerProvider(extension [1]gdclass.OpenXRExtensionWrapperExtension) { //gd:OpenXRAPIExtension.register_composition_layer_provider
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRAPIExtension.Bind_register_composition_layer_provider), 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ extension gdextension.Object }{gdextension.Object(gd.PointerWithOwnershipTransferredToGodot(extension[0].AsObject()[0]))}))
}

/*
Unregisters the given extension as a composition layer provider.
*/
//go:nosplit
func (self class) UnregisterCompositionLayerProvider(extension [1]gdclass.OpenXRExtensionWrapperExtension) { //gd:OpenXRAPIExtension.unregister_composition_layer_provider
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRAPIExtension.Bind_unregister_composition_layer_provider), 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ extension gdextension.Object }{gdextension.Object(gd.ObjectChecked(extension[0].AsObject()))}))
}

/*
Registers the given extension as a provider of additional data structures to projections views.
*/
//go:nosplit
func (self class) RegisterProjectionViewsExtension(extension [1]gdclass.OpenXRExtensionWrapperExtension) { //gd:OpenXRAPIExtension.register_projection_views_extension
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRAPIExtension.Bind_register_projection_views_extension), 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ extension gdextension.Object }{gdextension.Object(gd.PointerWithOwnershipTransferredToGodot(extension[0].AsObject()[0]))}))
}

/*
Unregisters the given extension as a provider of additional data structures to projections views.
*/
//go:nosplit
func (self class) UnregisterProjectionViewsExtension(extension [1]gdclass.OpenXRExtensionWrapperExtension) { //gd:OpenXRAPIExtension.unregister_projection_views_extension
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRAPIExtension.Bind_unregister_projection_views_extension), 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ extension gdextension.Object }{gdextension.Object(gd.ObjectChecked(extension[0].AsObject()))}))
}

/*
Returns the near boundary value of the camera frustum.
[b]Note:[/b] This is only accessible in the render thread.
*/
//go:nosplit
func (self class) GetRenderStateZNear() float64 { //gd:OpenXRAPIExtension.get_render_state_z_near
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRAPIExtension.Bind_get_render_state_z_near), gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the far boundary value of the camera frustum.
[b]Note:[/b] This is only accessible in the render thread.
*/
//go:nosplit
func (self class) GetRenderStateZFar() float64 { //gd:OpenXRAPIExtension.get_render_state_z_far
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRAPIExtension.Bind_get_render_state_z_far), gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Sets the render target of the velocity texture.
*/
//go:nosplit
func (self class) SetVelocityTexture(render_target RID.Any) { //gd:OpenXRAPIExtension.set_velocity_texture
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRAPIExtension.Bind_set_velocity_texture), 0|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ render_target RID.Any }{render_target}))
}

/*
Sets the render target of the velocity depth texture.
*/
//go:nosplit
func (self class) SetVelocityDepthTexture(render_target RID.Any) { //gd:OpenXRAPIExtension.set_velocity_depth_texture
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRAPIExtension.Bind_set_velocity_depth_texture), 0|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ render_target RID.Any }{render_target}))
}

/*
Sets the target size of the velocity and velocity depth textures.
*/
//go:nosplit
func (self class) SetVelocityTargetSize(target_size Vector2i.XY) { //gd:OpenXRAPIExtension.set_velocity_target_size
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRAPIExtension.Bind_set_velocity_target_size), 0|(gdextension.SizeVector2i<<4), unsafe.Pointer(&struct{ target_size Vector2i.XY }{target_size}))
}

/*
Returns an array of supported swapchain formats.
*/
//go:nosplit
func (self class) GetSupportedSwapchainFormats() Packed.Array[int64] { //gd:OpenXRAPIExtension.get_supported_swapchain_formats
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRAPIExtension.Bind_get_supported_swapchain_formats), gdextension.SizePackedArray, unsafe.Pointer(&struct{}{}))
	var ret = Packed.Array[int64](Array.Through(gd.PackedProxy[gd.PackedInt64Array, int64]{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

/*
Returns a pointer to a new swapchain created using the provided parameters.
*/
//go:nosplit
func (self class) OpenxrSwapchainCreate(create_flags int64, usage_flags int64, swapchain_format int64, width int64, height int64, sample_count int64, array_size int64) int64 { //gd:OpenXRAPIExtension.openxr_swapchain_create
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRAPIExtension.Bind_openxr_swapchain_create), gdextension.SizeInt|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeInt<<16)|(gdextension.SizeInt<<20)|(gdextension.SizeInt<<24)|(gdextension.SizeInt<<28), unsafe.Pointer(&struct {
		create_flags     int64
		usage_flags      int64
		swapchain_format int64
		width            int64
		height           int64
		sample_count     int64
		array_size       int64
	}{create_flags, usage_flags, swapchain_format, width, height, sample_count, array_size}))
	var ret = r_ret
	return ret
}

/*
Destroys the provided swapchain and frees it from memory.
*/
//go:nosplit
func (self class) OpenxrSwapchainFree(swapchain int64) { //gd:OpenXRAPIExtension.openxr_swapchain_free
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRAPIExtension.Bind_openxr_swapchain_free), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ swapchain int64 }{swapchain}))
}

/*
Returns the [code]XrSwapchain[/code] handle of the provided swapchain.
*/
//go:nosplit
func (self class) OpenxrSwapchainGetSwapchain(swapchain int64) int64 { //gd:OpenXRAPIExtension.openxr_swapchain_get_swapchain
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRAPIExtension.Bind_openxr_swapchain_get_swapchain), gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ swapchain int64 }{swapchain}))
	var ret = r_ret
	return ret
}

/*
Acquires the image of the provided swapchain.
*/
//go:nosplit
func (self class) OpenxrSwapchainAcquire(swapchain int64) { //gd:OpenXRAPIExtension.openxr_swapchain_acquire
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRAPIExtension.Bind_openxr_swapchain_acquire), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ swapchain int64 }{swapchain}))
}

/*
Returns the RID of the provided swapchain's image.
*/
//go:nosplit
func (self class) OpenxrSwapchainGetImage(swapchain int64) RID.Any { //gd:OpenXRAPIExtension.openxr_swapchain_get_image
	var r_ret = gdextension.Call[RID.Any](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRAPIExtension.Bind_openxr_swapchain_get_image), gdextension.SizeRID|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ swapchain int64 }{swapchain}))
	var ret = r_ret
	return ret
}

/*
Releases the image of the provided swapchain.
*/
//go:nosplit
func (self class) OpenxrSwapchainRelease(swapchain int64) { //gd:OpenXRAPIExtension.openxr_swapchain_release
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRAPIExtension.Bind_openxr_swapchain_release), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ swapchain int64 }{swapchain}))
}

/*
Returns a pointer to the render state's [code]XrCompositionLayerProjection[/code] struct.
[b]Note:[/b] This method should only be called from the rendering thread.
*/
//go:nosplit
func (self class) GetProjectionLayer() int64 { //gd:OpenXRAPIExtension.get_projection_layer
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRAPIExtension.Bind_get_projection_layer), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Sets the render region to [param render_region], overriding the normal render target's rect.
*/
//go:nosplit
func (self class) SetRenderRegion(render_region Rect2i.PositionSize) { //gd:OpenXRAPIExtension.set_render_region
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRAPIExtension.Bind_set_render_region), 0|(gdextension.SizeRect2i<<4), unsafe.Pointer(&struct{ render_region Rect2i.PositionSize }{render_region}))
}

/*
If set to [code]true[/code], an OpenXR extension is loaded which is capable of emulating the [constant XRInterface.XR_ENV_BLEND_MODE_ALPHA_BLEND] blend mode.
*/
//go:nosplit
func (self class) SetEmulateEnvironmentBlendModeAlphaBlend(enabled bool) { //gd:OpenXRAPIExtension.set_emulate_environment_blend_mode_alpha_blend
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRAPIExtension.Bind_set_emulate_environment_blend_mode_alpha_blend), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enabled bool }{enabled}))
}

/*
Returns [enum OpenXRAPIExtension.OpenXRAlphaBlendModeSupport] denoting if [constant XRInterface.XR_ENV_BLEND_MODE_ALPHA_BLEND] is really supported, emulated or not supported at all.
*/
//go:nosplit
func (self class) IsEnvironmentBlendModeAlphaSupported() OpenXRAlphaBlendModeSupport { //gd:OpenXRAPIExtension.is_environment_blend_mode_alpha_supported
	var r_ret = gdextension.Call[OpenXRAlphaBlendModeSupport](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.OpenXRAPIExtension.Bind_is_environment_blend_mode_alpha_supported), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}
func (self class) AsOpenXRAPIExtension() Advanced         { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsOpenXRAPIExtension() Instance      { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsOpenXRAPIExtension() Instance { return self.Super().AsOpenXRAPIExtension() }
func (self class) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsRefCounted() [1]gd.RefCounted { return self.Super().AsRefCounted() }
func (self Instance) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(RefCounted.Advanced(self.AsRefCounted()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(RefCounted.Instance(self.AsRefCounted()), name)
	}
}
func init() {
	gdclass.Register("OpenXRAPIExtension", func(ptr gd.Object) any {
		return [1]gdclass.OpenXRAPIExtension{*(*gdclass.OpenXRAPIExtension)(unsafe.Pointer(&ptr))}
	})
}

type OpenXRAlphaBlendModeSupport int //gd:OpenXRAPIExtension.OpenXRAlphaBlendModeSupport

const (
	/*Means that [constant XRInterface.XR_ENV_BLEND_MODE_ALPHA_BLEND] isn't supported at all.*/
	OpenxrAlphaBlendModeSupportNone OpenXRAlphaBlendModeSupport = 0
	/*Means that [constant XRInterface.XR_ENV_BLEND_MODE_ALPHA_BLEND] is really supported.*/
	OpenxrAlphaBlendModeSupportReal OpenXRAlphaBlendModeSupport = 1
	/*Means that [constant XRInterface.XR_ENV_BLEND_MODE_ALPHA_BLEND] is emulated.*/
	OpenxrAlphaBlendModeSupportEmulating OpenXRAlphaBlendModeSupport = 2
)
