// Code generated by the generate package DO NOT EDIT

// Package MeshLibrary provides methods for working with MeshLibrary object instances.
package MeshLibrary

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/Mesh"
import "graphics.gd/classdb/NavigationMesh"
import "graphics.gd/classdb/RenderingServer"
import "graphics.gd/classdb/Resource"
import "graphics.gd/classdb/Texture2D"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"
import "graphics.gd/variant/Transform3D"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
A library of meshes. Contains a list of [Mesh] resources, each with a name and ID. Each item can also include collision and navigation shapes. This resource is used in [GridMap].
*/
type Instance [1]gdclass.MeshLibrary

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	create_item                        gdextension.MethodForClass `hash:"1286410249"`
	set_item_name                      gdextension.MethodForClass `hash:"501894301"`
	set_item_mesh                      gdextension.MethodForClass `hash:"969122797"`
	set_item_mesh_transform            gdextension.MethodForClass `hash:"3616898986"`
	set_item_mesh_cast_shadow          gdextension.MethodForClass `hash:"3923400443"`
	set_item_navigation_mesh           gdextension.MethodForClass `hash:"3483353960"`
	set_item_navigation_mesh_transform gdextension.MethodForClass `hash:"3616898986"`
	set_item_navigation_layers         gdextension.MethodForClass `hash:"3937882851"`
	set_item_shapes                    gdextension.MethodForClass `hash:"537221740"`
	set_item_preview                   gdextension.MethodForClass `hash:"666127730"`
	get_item_name                      gdextension.MethodForClass `hash:"844755477"`
	get_item_mesh                      gdextension.MethodForClass `hash:"1576363275"`
	get_item_mesh_transform            gdextension.MethodForClass `hash:"1965739696"`
	get_item_mesh_cast_shadow          gdextension.MethodForClass `hash:"1841766007"`
	get_item_navigation_mesh           gdextension.MethodForClass `hash:"2729647406"`
	get_item_navigation_mesh_transform gdextension.MethodForClass `hash:"1965739696"`
	get_item_navigation_layers         gdextension.MethodForClass `hash:"923996154"`
	get_item_shapes                    gdextension.MethodForClass `hash:"663333327"`
	get_item_preview                   gdextension.MethodForClass `hash:"3536238170"`
	remove_item                        gdextension.MethodForClass `hash:"1286410249"`
	find_item_by_name                  gdextension.MethodForClass `hash:"1321353865"`
	clear                              gdextension.MethodForClass `hash:"3218959716"`
	get_item_list                      gdextension.MethodForClass `hash:"1930428628"`
	get_last_unused_item_id            gdextension.MethodForClass `hash:"3905245786"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("MeshLibrary")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		gdextension.Free(gdextension.TypeStringName, &sname)
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsMeshLibrary() Instance
}

/*
Creates a new item in the library with the given ID.
You can get an unused ID from [method get_last_unused_item_id].
*/
func (self Instance) CreateItem(id int) { //gd:MeshLibrary.create_item
	Advanced(self).CreateItem(int64(id))
}

/*
Sets the item's name.
This name is shown in the editor. It can also be used to look up the item later using [method find_item_by_name].
*/
func (self Instance) SetItemName(id int, name string) { //gd:MeshLibrary.set_item_name
	Advanced(self).SetItemName(int64(id), String.New(name))
}

/*
Sets the item's mesh.
*/
func (self Instance) SetItemMesh(id int, mesh Mesh.Instance) { //gd:MeshLibrary.set_item_mesh
	Advanced(self).SetItemMesh(int64(id), mesh)
}

/*
Sets the transform to apply to the item's mesh.
*/
func (self Instance) SetItemMeshTransform(id int, mesh_transform Transform3D.BasisOrigin) { //gd:MeshLibrary.set_item_mesh_transform
	Advanced(self).SetItemMeshTransform(int64(id), Transform3D.BasisOrigin(mesh_transform))
}

/*
Sets the item's shadow casting mode. See [enum RenderingServer.ShadowCastingSetting] for possible values.
*/
func (self Instance) SetItemMeshCastShadow(id int, shadow_casting_setting RenderingServer.ShadowCastingSetting) { //gd:MeshLibrary.set_item_mesh_cast_shadow
	Advanced(self).SetItemMeshCastShadow(int64(id), shadow_casting_setting)
}

/*
Sets the item's navigation mesh.
*/
func (self Instance) SetItemNavigationMesh(id int, navigation_mesh NavigationMesh.Instance) { //gd:MeshLibrary.set_item_navigation_mesh
	Advanced(self).SetItemNavigationMesh(int64(id), navigation_mesh)
}

/*
Sets the transform to apply to the item's navigation mesh.
*/
func (self Instance) SetItemNavigationMeshTransform(id int, navigation_mesh Transform3D.BasisOrigin) { //gd:MeshLibrary.set_item_navigation_mesh_transform
	Advanced(self).SetItemNavigationMeshTransform(int64(id), Transform3D.BasisOrigin(navigation_mesh))
}

/*
Sets the item's navigation layers bitmask.
*/
func (self Instance) SetItemNavigationLayers(id int, navigation_layers int) { //gd:MeshLibrary.set_item_navigation_layers
	Advanced(self).SetItemNavigationLayers(int64(id), int64(navigation_layers))
}

/*
Sets an item's collision shapes.
The array should consist of [Shape3D] objects, each followed by a [Transform3D] that will be applied to it. For shapes that should not have a transform, use [constant Transform3D.IDENTITY].
*/
func (self Instance) SetItemShapes(id int, shapes []any) { //gd:MeshLibrary.set_item_shapes
	Advanced(self).SetItemShapes(int64(id), gd.EngineArrayFromSlice(shapes))
}

/*
Sets a texture to use as the item's preview icon in the editor.
*/
func (self Instance) SetItemPreview(id int, texture Texture2D.Instance) { //gd:MeshLibrary.set_item_preview
	Advanced(self).SetItemPreview(int64(id), texture)
}

/*
Returns the item's name.
*/
func (self Instance) GetItemName(id int) string { //gd:MeshLibrary.get_item_name
	return string(Advanced(self).GetItemName(int64(id)).String())
}

/*
Returns the item's mesh.
*/
func (self Instance) GetItemMesh(id int) Mesh.Instance { //gd:MeshLibrary.get_item_mesh
	return Mesh.Instance(Advanced(self).GetItemMesh(int64(id)))
}

/*
Returns the transform applied to the item's mesh.
*/
func (self Instance) GetItemMeshTransform(id int) Transform3D.BasisOrigin { //gd:MeshLibrary.get_item_mesh_transform
	return Transform3D.BasisOrigin(Advanced(self).GetItemMeshTransform(int64(id)))
}

/*
Returns the item's shadow casting mode. See [enum RenderingServer.ShadowCastingSetting] for possible values.
*/
func (self Instance) GetItemMeshCastShadow(id int) RenderingServer.ShadowCastingSetting { //gd:MeshLibrary.get_item_mesh_cast_shadow
	return RenderingServer.ShadowCastingSetting(Advanced(self).GetItemMeshCastShadow(int64(id)))
}

/*
Returns the item's navigation mesh.
*/
func (self Instance) GetItemNavigationMesh(id int) NavigationMesh.Instance { //gd:MeshLibrary.get_item_navigation_mesh
	return NavigationMesh.Instance(Advanced(self).GetItemNavigationMesh(int64(id)))
}

/*
Returns the transform applied to the item's navigation mesh.
*/
func (self Instance) GetItemNavigationMeshTransform(id int) Transform3D.BasisOrigin { //gd:MeshLibrary.get_item_navigation_mesh_transform
	return Transform3D.BasisOrigin(Advanced(self).GetItemNavigationMeshTransform(int64(id)))
}

/*
Returns the item's navigation layers bitmask.
*/
func (self Instance) GetItemNavigationLayers(id int) int { //gd:MeshLibrary.get_item_navigation_layers
	return int(int(Advanced(self).GetItemNavigationLayers(int64(id))))
}

/*
Returns an item's collision shapes.
The array consists of each [Shape3D] followed by its [Transform3D].
*/
func (self Instance) GetItemShapes(id int) []any { //gd:MeshLibrary.get_item_shapes
	return []any(gd.ArrayAs[[]any](gd.InternalArray(Advanced(self).GetItemShapes(int64(id)))))
}

/*
When running in the editor, returns a generated item preview (a 3D rendering in isometric perspective). When used in a running project, returns the manually-defined item preview which can be set using [method set_item_preview]. Returns an empty [Texture2D] if no preview was manually set in a running project.
*/
func (self Instance) GetItemPreview(id int) Texture2D.Instance { //gd:MeshLibrary.get_item_preview
	return Texture2D.Instance(Advanced(self).GetItemPreview(int64(id)))
}

/*
Removes the item.
*/
func (self Instance) RemoveItem(id int) { //gd:MeshLibrary.remove_item
	Advanced(self).RemoveItem(int64(id))
}

/*
Returns the first item with the given name, or [code]-1[/code] if no item is found.
*/
func (self Instance) FindItemByName(name string) int { //gd:MeshLibrary.find_item_by_name
	return int(int(Advanced(self).FindItemByName(String.New(name))))
}

/*
Clears the library.
*/
func (self Instance) Clear() { //gd:MeshLibrary.clear
	Advanced(self).Clear()
}

/*
Returns the list of item IDs in use.
*/
func (self Instance) GetItemList() []int32 { //gd:MeshLibrary.get_item_list
	return []int32(slices.Collect(Advanced(self).GetItemList().Values()))
}

/*
Gets an unused ID for a new item.
*/
func (self Instance) GetLastUnusedItemId() int { //gd:MeshLibrary.get_last_unused_item_id
	return int(int(Advanced(self).GetLastUnusedItemId()))
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.MeshLibrary

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.MeshLibrary)(unsafe.Pointer(&obj))
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.MeshLibrary)(unsafe.Pointer(&obj))
		return true
	}
	return false
}

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {

	if !gd.Linked {
		var placeholder Instance
		*(*gd.Object)(unsafe.Pointer(&placeholder)) = pointers.Add[gd.Object]([3]uint64{})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(*(*gd.Object)(unsafe.Pointer(&placeholder)), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	object := [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})}
	casted := Instance{*(*gdclass.MeshLibrary)(unsafe.Pointer(&object))}
	casted.AsRefCounted()[0].InitRef()
	object[0].Notification(0, false)
	return casted
}

/*
Creates a new item in the library with the given ID.
You can get an unused ID from [method get_last_unused_item_id].
*/
//go:nosplit
func (self class) CreateItem(id int64) { //gd:MeshLibrary.create_item
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.create_item, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ id int64 }{id}))
}

/*
Sets the item's name.
This name is shown in the editor. It can also be used to look up the item later using [method find_item_by_name].
*/
//go:nosplit
func (self class) SetItemName(id int64, name String.Readable) { //gd:MeshLibrary.set_item_name
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_name, 0|(gdextension.SizeInt<<4)|(gdextension.SizeString<<8), unsafe.Pointer(&struct {
		id   int64
		name gdextension.String
	}{id, pointers.Get(gd.InternalString(name))}))
}

/*
Sets the item's mesh.
*/
//go:nosplit
func (self class) SetItemMesh(id int64, mesh [1]gdclass.Mesh) { //gd:MeshLibrary.set_item_mesh
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_mesh, 0|(gdextension.SizeInt<<4)|(gdextension.SizeObject<<8), unsafe.Pointer(&struct {
		id   int64
		mesh gdextension.Object
	}{id, gdextension.Object(gd.ObjectChecked(mesh[0].AsObject()))}))
}

/*
Sets the transform to apply to the item's mesh.
*/
//go:nosplit
func (self class) SetItemMeshTransform(id int64, mesh_transform Transform3D.BasisOrigin) { //gd:MeshLibrary.set_item_mesh_transform
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_mesh_transform, 0|(gdextension.SizeInt<<4)|(gdextension.SizeTransform3D<<8), unsafe.Pointer(&struct {
		id             int64
		mesh_transform Transform3D.BasisOrigin
	}{id, gd.Transposed(mesh_transform)}))
}

/*
Sets the item's shadow casting mode. See [enum RenderingServer.ShadowCastingSetting] for possible values.
*/
//go:nosplit
func (self class) SetItemMeshCastShadow(id int64, shadow_casting_setting RenderingServer.ShadowCastingSetting) { //gd:MeshLibrary.set_item_mesh_cast_shadow
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_mesh_cast_shadow, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		id                     int64
		shadow_casting_setting RenderingServer.ShadowCastingSetting
	}{id, shadow_casting_setting}))
}

/*
Sets the item's navigation mesh.
*/
//go:nosplit
func (self class) SetItemNavigationMesh(id int64, navigation_mesh [1]gdclass.NavigationMesh) { //gd:MeshLibrary.set_item_navigation_mesh
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_navigation_mesh, 0|(gdextension.SizeInt<<4)|(gdextension.SizeObject<<8), unsafe.Pointer(&struct {
		id              int64
		navigation_mesh gdextension.Object
	}{id, gdextension.Object(gd.ObjectChecked(navigation_mesh[0].AsObject()))}))
}

/*
Sets the transform to apply to the item's navigation mesh.
*/
//go:nosplit
func (self class) SetItemNavigationMeshTransform(id int64, navigation_mesh Transform3D.BasisOrigin) { //gd:MeshLibrary.set_item_navigation_mesh_transform
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_navigation_mesh_transform, 0|(gdextension.SizeInt<<4)|(gdextension.SizeTransform3D<<8), unsafe.Pointer(&struct {
		id              int64
		navigation_mesh Transform3D.BasisOrigin
	}{id, gd.Transposed(navigation_mesh)}))
}

/*
Sets the item's navigation layers bitmask.
*/
//go:nosplit
func (self class) SetItemNavigationLayers(id int64, navigation_layers int64) { //gd:MeshLibrary.set_item_navigation_layers
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_navigation_layers, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		id                int64
		navigation_layers int64
	}{id, navigation_layers}))
}

/*
Sets an item's collision shapes.
The array should consist of [Shape3D] objects, each followed by a [Transform3D] that will be applied to it. For shapes that should not have a transform, use [constant Transform3D.IDENTITY].
*/
//go:nosplit
func (self class) SetItemShapes(id int64, shapes Array.Any) { //gd:MeshLibrary.set_item_shapes
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_shapes, 0|(gdextension.SizeInt<<4)|(gdextension.SizeArray<<8), unsafe.Pointer(&struct {
		id     int64
		shapes gdextension.Array
	}{id, pointers.Get(gd.InternalArray(shapes))}))
}

/*
Sets a texture to use as the item's preview icon in the editor.
*/
//go:nosplit
func (self class) SetItemPreview(id int64, texture [1]gdclass.Texture2D) { //gd:MeshLibrary.set_item_preview
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_preview, 0|(gdextension.SizeInt<<4)|(gdextension.SizeObject<<8), unsafe.Pointer(&struct {
		id      int64
		texture gdextension.Object
	}{id, gdextension.Object(gd.ObjectChecked(texture[0].AsObject()))}))
}

/*
Returns the item's name.
*/
//go:nosplit
func (self class) GetItemName(id int64) String.Readable { //gd:MeshLibrary.get_item_name
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_item_name, gdextension.SizeString|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ id int64 }{id}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Returns the item's mesh.
*/
//go:nosplit
func (self class) GetItemMesh(id int64) [1]gdclass.Mesh { //gd:MeshLibrary.get_item_mesh
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_item_mesh, gdextension.SizeObject|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ id int64 }{id}))
	var ret = [1]gdclass.Mesh{gd.PointerWithOwnershipTransferredToGo[gdclass.Mesh](r_ret)}
	return ret
}

/*
Returns the transform applied to the item's mesh.
*/
//go:nosplit
func (self class) GetItemMeshTransform(id int64) Transform3D.BasisOrigin { //gd:MeshLibrary.get_item_mesh_transform
	var r_ret = gdextension.Call[Transform3D.BasisOrigin](gd.ObjectChecked(self.AsObject()), methods.get_item_mesh_transform, gdextension.SizeTransform3D|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ id int64 }{id}))
	var ret = gd.Transposed(r_ret)
	return ret
}

/*
Returns the item's shadow casting mode. See [enum RenderingServer.ShadowCastingSetting] for possible values.
*/
//go:nosplit
func (self class) GetItemMeshCastShadow(id int64) RenderingServer.ShadowCastingSetting { //gd:MeshLibrary.get_item_mesh_cast_shadow
	var r_ret = gdextension.Call[RenderingServer.ShadowCastingSetting](gd.ObjectChecked(self.AsObject()), methods.get_item_mesh_cast_shadow, gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ id int64 }{id}))
	var ret = r_ret
	return ret
}

/*
Returns the item's navigation mesh.
*/
//go:nosplit
func (self class) GetItemNavigationMesh(id int64) [1]gdclass.NavigationMesh { //gd:MeshLibrary.get_item_navigation_mesh
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_item_navigation_mesh, gdextension.SizeObject|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ id int64 }{id}))
	var ret = [1]gdclass.NavigationMesh{gd.PointerWithOwnershipTransferredToGo[gdclass.NavigationMesh](r_ret)}
	return ret
}

/*
Returns the transform applied to the item's navigation mesh.
*/
//go:nosplit
func (self class) GetItemNavigationMeshTransform(id int64) Transform3D.BasisOrigin { //gd:MeshLibrary.get_item_navigation_mesh_transform
	var r_ret = gdextension.Call[Transform3D.BasisOrigin](gd.ObjectChecked(self.AsObject()), methods.get_item_navigation_mesh_transform, gdextension.SizeTransform3D|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ id int64 }{id}))
	var ret = gd.Transposed(r_ret)
	return ret
}

/*
Returns the item's navigation layers bitmask.
*/
//go:nosplit
func (self class) GetItemNavigationLayers(id int64) int64 { //gd:MeshLibrary.get_item_navigation_layers
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_item_navigation_layers, gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ id int64 }{id}))
	var ret = r_ret
	return ret
}

/*
Returns an item's collision shapes.
The array consists of each [Shape3D] followed by its [Transform3D].
*/
//go:nosplit
func (self class) GetItemShapes(id int64) Array.Any { //gd:MeshLibrary.get_item_shapes
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), methods.get_item_shapes, gdextension.SizeArray|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ id int64 }{id}))
	var ret = Array.Through(gd.ArrayProxy[variant.Any]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

/*
When running in the editor, returns a generated item preview (a 3D rendering in isometric perspective). When used in a running project, returns the manually-defined item preview which can be set using [method set_item_preview]. Returns an empty [Texture2D] if no preview was manually set in a running project.
*/
//go:nosplit
func (self class) GetItemPreview(id int64) [1]gdclass.Texture2D { //gd:MeshLibrary.get_item_preview
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_item_preview, gdextension.SizeObject|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ id int64 }{id}))
	var ret = [1]gdclass.Texture2D{gd.PointerWithOwnershipTransferredToGo[gdclass.Texture2D](r_ret)}
	return ret
}

/*
Removes the item.
*/
//go:nosplit
func (self class) RemoveItem(id int64) { //gd:MeshLibrary.remove_item
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.remove_item, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ id int64 }{id}))
}

/*
Returns the first item with the given name, or [code]-1[/code] if no item is found.
*/
//go:nosplit
func (self class) FindItemByName(name String.Readable) int64 { //gd:MeshLibrary.find_item_by_name
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.find_item_by_name, gdextension.SizeInt|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ name gdextension.String }{pointers.Get(gd.InternalString(name))}))
	var ret = r_ret
	return ret
}

/*
Clears the library.
*/
//go:nosplit
func (self class) Clear() { //gd:MeshLibrary.clear
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.clear, 0, unsafe.Pointer(&struct{}{}))
}

/*
Returns the list of item IDs in use.
*/
//go:nosplit
func (self class) GetItemList() Packed.Array[int32] { //gd:MeshLibrary.get_item_list
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.get_item_list, gdextension.SizePackedArray, unsafe.Pointer(&struct{}{}))
	var ret = Packed.Array[int32](Array.Through(gd.PackedProxy[gd.PackedInt32Array, int32]{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

/*
Gets an unused ID for a new item.
*/
//go:nosplit
func (self class) GetLastUnusedItemId() int64 { //gd:MeshLibrary.get_last_unused_item_id
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_last_unused_item_id, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}
func (self class) AsMeshLibrary() Advanced         { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsMeshLibrary() Instance      { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsMeshLibrary() Instance { return self.Super().AsMeshLibrary() }
func (self class) AsResource() Resource.Advanced {
	return *((*Resource.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsResource() Resource.Instance { return self.Super().AsResource() }
func (self Instance) AsResource() Resource.Instance {
	return *((*Resource.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsRefCounted() [1]gd.RefCounted { return self.Super().AsRefCounted() }
func (self Instance) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Resource.Advanced(self.AsResource()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Resource.Instance(self.AsResource()), name)
	}
}
func init() {
	gdclass.Register("MeshLibrary", func(ptr gd.Object) any { return *(*Instance)(unsafe.Pointer(&ptr)) })
}
