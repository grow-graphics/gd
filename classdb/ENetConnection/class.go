// Code generated by the generate package DO NOT EDIT

// Package ENetConnection provides methods for working with ENetConnection object instances.
package ENetConnection

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/ENetPacketPeer"
import "graphics.gd/classdb/TLSOptions"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
ENet's purpose is to provide a relatively thin, simple and robust network communication layer on top of UDP (User Datagram Protocol).
*/
type Instance [1]gdclass.ENetConnection

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	create_host_bound      gdextension.MethodForClass `hash:"1515002313"`
	create_host            gdextension.MethodForClass `hash:"117198950"`
	destroy                gdextension.MethodForClass `hash:"3218959716"`
	connect_to_host        gdextension.MethodForClass `hash:"2171300490"`
	service                gdextension.MethodForClass `hash:"2402345344"`
	flush                  gdextension.MethodForClass `hash:"3218959716"`
	bandwidth_limit        gdextension.MethodForClass `hash:"2302169788"`
	channel_limit          gdextension.MethodForClass `hash:"1286410249"`
	broadcast              gdextension.MethodForClass `hash:"2772371345"`
	compress               gdextension.MethodForClass `hash:"2660215187"`
	dtls_server_setup      gdextension.MethodForClass `hash:"1262296096"`
	dtls_client_setup      gdextension.MethodForClass `hash:"1966198364"`
	refuse_new_connections gdextension.MethodForClass `hash:"2586408642"`
	pop_statistic          gdextension.MethodForClass `hash:"2166904170"`
	get_max_channels       gdextension.MethodForClass `hash:"3905245786"`
	get_local_port         gdextension.MethodForClass `hash:"3905245786"`
	get_peers              gdextension.MethodForClass `hash:"2915620761"`
	socket_send            gdextension.MethodForClass `hash:"1100646812"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("ENetConnection")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		pointers.Raw[gd.StringName](sname).Free()
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

type Expanded [1]gdclass.ENetConnection

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsENetConnection() Instance
}

/*
Creates an ENetHost bound to the given [param bind_address] and [param bind_port] that allows up to [param max_peers] connected peers, each allocating up to [param max_channels] channels, optionally limiting bandwidth to [param in_bandwidth] and [param out_bandwidth] (if greater than zero).
[b]Note:[/b] It is necessary to create a host in both client and server in order to establish a connection.
*/
func (self Instance) CreateHostBound(bind_address string, bind_port int) error { //gd:ENetConnection.create_host_bound
	return error(gd.ToError(Advanced(self).CreateHostBound(String.New(bind_address), int64(bind_port), int64(32), int64(0), int64(0), int64(0))))
}

/*
Creates an ENetHost bound to the given [param bind_address] and [param bind_port] that allows up to [param max_peers] connected peers, each allocating up to [param max_channels] channels, optionally limiting bandwidth to [param in_bandwidth] and [param out_bandwidth] (if greater than zero).
[b]Note:[/b] It is necessary to create a host in both client and server in order to establish a connection.
*/
func (self Expanded) CreateHostBound(bind_address string, bind_port int, max_peers int, max_channels int, in_bandwidth int, out_bandwidth int) error { //gd:ENetConnection.create_host_bound
	return error(gd.ToError(Advanced(self).CreateHostBound(String.New(bind_address), int64(bind_port), int64(max_peers), int64(max_channels), int64(in_bandwidth), int64(out_bandwidth))))
}

/*
Creates an ENetHost that allows up to [param max_peers] connected peers, each allocating up to [param max_channels] channels, optionally limiting bandwidth to [param in_bandwidth] and [param out_bandwidth] (if greater than zero).
This method binds a random available dynamic UDP port on the host machine at the [i]unspecified[/i] address. Use [method create_host_bound] to specify the address and port.
[b]Note:[/b] It is necessary to create a host in both client and server in order to establish a connection.
*/
func (self Instance) CreateHost() error { //gd:ENetConnection.create_host
	return error(gd.ToError(Advanced(self).CreateHost(int64(32), int64(0), int64(0), int64(0))))
}

/*
Creates an ENetHost that allows up to [param max_peers] connected peers, each allocating up to [param max_channels] channels, optionally limiting bandwidth to [param in_bandwidth] and [param out_bandwidth] (if greater than zero).
This method binds a random available dynamic UDP port on the host machine at the [i]unspecified[/i] address. Use [method create_host_bound] to specify the address and port.
[b]Note:[/b] It is necessary to create a host in both client and server in order to establish a connection.
*/
func (self Expanded) CreateHost(max_peers int, max_channels int, in_bandwidth int, out_bandwidth int) error { //gd:ENetConnection.create_host
	return error(gd.ToError(Advanced(self).CreateHost(int64(max_peers), int64(max_channels), int64(in_bandwidth), int64(out_bandwidth))))
}

/*
Destroys the host and all resources associated with it.
*/
func (self Instance) Destroy() { //gd:ENetConnection.destroy
	Advanced(self).Destroy()
}

/*
Initiates a connection to a foreign [param address] using the specified [param port] and allocating the requested [param channels]. Optional [param data] can be passed during connection in the form of a 32 bit integer.
[b]Note:[/b] You must call either [method create_host] or [method create_host_bound] on both ends before calling this method.
*/
func (self Instance) ConnectToHost(address string, port int) ENetPacketPeer.Instance { //gd:ENetConnection.connect_to_host
	return ENetPacketPeer.Instance(Advanced(self).ConnectToHost(String.New(address), int64(port), int64(0), int64(0)))
}

/*
Initiates a connection to a foreign [param address] using the specified [param port] and allocating the requested [param channels]. Optional [param data] can be passed during connection in the form of a 32 bit integer.
[b]Note:[/b] You must call either [method create_host] or [method create_host_bound] on both ends before calling this method.
*/
func (self Expanded) ConnectToHost(address string, port int, channels int, data int) ENetPacketPeer.Instance { //gd:ENetConnection.connect_to_host
	return ENetPacketPeer.Instance(Advanced(self).ConnectToHost(String.New(address), int64(port), int64(channels), int64(data)))
}

/*
Waits for events on this connection and shuttles packets between the host and its peers, with the given [param timeout] (in milliseconds). The returned [Array] will have 4 elements. An [enum EventType], the [ENetPacketPeer] which generated the event, the event associated data (if any), the event associated channel (if any). If the generated event is [constant EVENT_RECEIVE], the received packet will be queued to the associated [ENetPacketPeer].
Call this function regularly to handle connections, disconnections, and to receive new packets.
[b]Note:[/b] This method must be called on both ends involved in the event (sending and receiving hosts).
*/
func (self Instance) Service() []any { //gd:ENetConnection.service
	return []any(gd.ArrayAs[[]any](gd.InternalArray(Advanced(self).Service(int64(0)))))
}

/*
Waits for events on this connection and shuttles packets between the host and its peers, with the given [param timeout] (in milliseconds). The returned [Array] will have 4 elements. An [enum EventType], the [ENetPacketPeer] which generated the event, the event associated data (if any), the event associated channel (if any). If the generated event is [constant EVENT_RECEIVE], the received packet will be queued to the associated [ENetPacketPeer].
Call this function regularly to handle connections, disconnections, and to receive new packets.
[b]Note:[/b] This method must be called on both ends involved in the event (sending and receiving hosts).
*/
func (self Expanded) Service(timeout int) []any { //gd:ENetConnection.service
	return []any(gd.ArrayAs[[]any](gd.InternalArray(Advanced(self).Service(int64(timeout)))))
}

/*
Sends any queued packets on the host specified to its designated peers.
*/
func (self Instance) Flush() { //gd:ENetConnection.flush
	Advanced(self).Flush()
}

/*
Adjusts the bandwidth limits of a host.
*/
func (self Instance) BandwidthLimit() { //gd:ENetConnection.bandwidth_limit
	Advanced(self).BandwidthLimit(int64(0), int64(0))
}

/*
Adjusts the bandwidth limits of a host.
*/
func (self Expanded) BandwidthLimit(in_bandwidth int, out_bandwidth int) { //gd:ENetConnection.bandwidth_limit
	Advanced(self).BandwidthLimit(int64(in_bandwidth), int64(out_bandwidth))
}

/*
Limits the maximum allowed channels of future incoming connections.
*/
func (self Instance) ChannelLimit(limit int) { //gd:ENetConnection.channel_limit
	Advanced(self).ChannelLimit(int64(limit))
}

/*
Queues a [param packet] to be sent to all peers associated with the host over the specified [param channel]. See [ENetPacketPeer] [code]FLAG_*[/code] constants for available packet flags.
*/
func (self Instance) Broadcast(channel int, packet []byte, flags int) { //gd:ENetConnection.broadcast
	Advanced(self).Broadcast(int64(channel), Packed.Bytes(Packed.New(packet...)), int64(flags))
}

/*
Sets the compression method used for network packets. These have different tradeoffs of compression speed versus bandwidth, you may need to test which one works best for your use case if you use compression at all.
[b]Note:[/b] Most games' network design involve sending many small packets frequently (smaller than 4 KB each). If in doubt, it is recommended to keep the default compression algorithm as it works best on these small packets.
[b]Note:[/b] The compression mode must be set to the same value on both the server and all its clients. Clients will fail to connect if the compression mode set on the client differs from the one set on the server.
*/
func (self Instance) Compress(mode CompressionMode) { //gd:ENetConnection.compress
	Advanced(self).Compress(mode)
}

/*
Configure this ENetHost to use the custom Godot extension allowing DTLS encryption for ENet servers. Call this right after [method create_host_bound] to have ENet expect peers to connect using DTLS. See [method TLSOptions.server].
*/
func (self Instance) DtlsServerSetup(server_options TLSOptions.Instance) error { //gd:ENetConnection.dtls_server_setup
	return error(gd.ToError(Advanced(self).DtlsServerSetup(server_options)))
}

/*
Configure this ENetHost to use the custom Godot extension allowing DTLS encryption for ENet clients. Call this before [method connect_to_host] to have ENet connect using DTLS validating the server certificate against [param hostname]. You can pass the optional [param client_options] parameter to customize the trusted certification authorities, or disable the common name verification. See [method TLSOptions.client] and [method TLSOptions.client_unsafe].
*/
func (self Instance) DtlsClientSetup(hostname string) error { //gd:ENetConnection.dtls_client_setup
	return error(gd.ToError(Advanced(self).DtlsClientSetup(String.New(hostname), [1]TLSOptions.Instance{}[0])))
}

/*
Configure this ENetHost to use the custom Godot extension allowing DTLS encryption for ENet clients. Call this before [method connect_to_host] to have ENet connect using DTLS validating the server certificate against [param hostname]. You can pass the optional [param client_options] parameter to customize the trusted certification authorities, or disable the common name verification. See [method TLSOptions.client] and [method TLSOptions.client_unsafe].
*/
func (self Expanded) DtlsClientSetup(hostname string, client_options TLSOptions.Instance) error { //gd:ENetConnection.dtls_client_setup
	return error(gd.ToError(Advanced(self).DtlsClientSetup(String.New(hostname), client_options)))
}

/*
Configures the DTLS server to automatically drop new connections.
[b]Note:[/b] This method is only relevant after calling [method dtls_server_setup].
*/
func (self Instance) RefuseNewConnections(refuse bool) { //gd:ENetConnection.refuse_new_connections
	Advanced(self).RefuseNewConnections(refuse)
}

/*
Returns and resets host statistics. See [enum HostStatistic] for more info.
*/
func (self Instance) PopStatistic(statistic HostStatistic) Float.X { //gd:ENetConnection.pop_statistic
	return Float.X(Float.X(Advanced(self).PopStatistic(statistic)))
}

/*
Returns the maximum number of channels allowed for connected peers.
*/
func (self Instance) GetMaxChannels() int { //gd:ENetConnection.get_max_channels
	return int(int(Advanced(self).GetMaxChannels()))
}

/*
Returns the local port to which this peer is bound.
*/
func (self Instance) GetLocalPort() int { //gd:ENetConnection.get_local_port
	return int(int(Advanced(self).GetLocalPort()))
}

/*
Returns the list of peers associated with this host.
[b]Note:[/b] This list might include some peers that are not fully connected or are still being disconnected.
*/
func (self Instance) GetPeers() []ENetPacketPeer.Instance { //gd:ENetConnection.get_peers
	return []ENetPacketPeer.Instance(gd.ArrayAs[[]ENetPacketPeer.Instance](gd.InternalArray(Advanced(self).GetPeers())))
}

/*
Sends a [param packet] toward a destination from the address and port currently bound by this ENetConnection instance.
This is useful as it serves to establish entries in NAT routing tables on all devices between this bound instance and the public facing internet, allowing a prospective client's connection packets to be routed backward through the NAT device(s) between the public internet and this host.
This requires forward knowledge of a prospective client's address and communication port as seen by the public internet - after any NAT devices have handled their connection request. This information can be obtained by a [url=https://en.wikipedia.org/wiki/STUN]STUN[/url] service, and must be handed off to your host by an entity that is not the prospective client. This will never work for a client behind a Symmetric NAT due to the nature of the Symmetric NAT routing algorithm, as their IP and Port cannot be known beforehand.
*/
func (self Instance) SocketSend(destination_address string, destination_port int, packet []byte) { //gd:ENetConnection.socket_send
	Advanced(self).SocketSend(String.New(destination_address), int64(destination_port), Packed.Bytes(Packed.New(packet...)))
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.ENetConnection

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.ENetConnection)(unsafe.Pointer(&obj))
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.ENetConnection)(unsafe.Pointer(&obj))
		return true
	}
	return false
}

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {

	if !gd.Linked {
		var placeholder Instance
		*(*gd.Object)(unsafe.Pointer(&placeholder)) = pointers.Add[gd.Object]([3]uint64{})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(*(*gd.Object)(unsafe.Pointer(&placeholder)), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	object := [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})}
	casted := Instance{*(*gdclass.ENetConnection)(unsafe.Pointer(&object))}
	casted.AsRefCounted()[0].Reference()
	object[0].Notification(0, false)
	return casted
}

/*
Creates an ENetHost bound to the given [param bind_address] and [param bind_port] that allows up to [param max_peers] connected peers, each allocating up to [param max_channels] channels, optionally limiting bandwidth to [param in_bandwidth] and [param out_bandwidth] (if greater than zero).
[b]Note:[/b] It is necessary to create a host in both client and server in order to establish a connection.
*/
//go:nosplit
func (self class) CreateHostBound(bind_address String.Readable, bind_port int64, max_peers int64, max_channels int64, in_bandwidth int64, out_bandwidth int64) Error.Code { //gd:ENetConnection.create_host_bound
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.create_host_bound, gdextension.SizeInt|(gdextension.SizeString<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeInt<<16)|(gdextension.SizeInt<<20)|(gdextension.SizeInt<<24), unsafe.Pointer(&struct {
		bind_address  gdextension.String
		bind_port     int64
		max_peers     int64
		max_channels  int64
		in_bandwidth  int64
		out_bandwidth int64
	}{pointers.Get(gd.InternalString(bind_address)), bind_port, max_peers, max_channels, in_bandwidth, out_bandwidth}))
	var ret = Error.Code(r_ret)
	return ret
}

/*
Creates an ENetHost that allows up to [param max_peers] connected peers, each allocating up to [param max_channels] channels, optionally limiting bandwidth to [param in_bandwidth] and [param out_bandwidth] (if greater than zero).
This method binds a random available dynamic UDP port on the host machine at the [i]unspecified[/i] address. Use [method create_host_bound] to specify the address and port.
[b]Note:[/b] It is necessary to create a host in both client and server in order to establish a connection.
*/
//go:nosplit
func (self class) CreateHost(max_peers int64, max_channels int64, in_bandwidth int64, out_bandwidth int64) Error.Code { //gd:ENetConnection.create_host
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.create_host, gdextension.SizeInt|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeInt<<16), unsafe.Pointer(&struct {
		max_peers     int64
		max_channels  int64
		in_bandwidth  int64
		out_bandwidth int64
	}{max_peers, max_channels, in_bandwidth, out_bandwidth}))
	var ret = Error.Code(r_ret)
	return ret
}

/*
Destroys the host and all resources associated with it.
*/
//go:nosplit
func (self class) Destroy() { //gd:ENetConnection.destroy
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.destroy, 0, unsafe.Pointer(&struct{}{}))
}

/*
Initiates a connection to a foreign [param address] using the specified [param port] and allocating the requested [param channels]. Optional [param data] can be passed during connection in the form of a 32 bit integer.
[b]Note:[/b] You must call either [method create_host] or [method create_host_bound] on both ends before calling this method.
*/
//go:nosplit
func (self class) ConnectToHost(address String.Readable, port int64, channels int64, data int64) [1]gdclass.ENetPacketPeer { //gd:ENetConnection.connect_to_host
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.connect_to_host, gdextension.SizeObject|(gdextension.SizeString<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeInt<<16), unsafe.Pointer(&struct {
		address  gdextension.String
		port     int64
		channels int64
		data     int64
	}{pointers.Get(gd.InternalString(address)), port, channels, data}))
	var ret = [1]gdclass.ENetPacketPeer{gd.PointerWithOwnershipTransferredToGo[gdclass.ENetPacketPeer](r_ret)}
	return ret
}

/*
Waits for events on this connection and shuttles packets between the host and its peers, with the given [param timeout] (in milliseconds). The returned [Array] will have 4 elements. An [enum EventType], the [ENetPacketPeer] which generated the event, the event associated data (if any), the event associated channel (if any). If the generated event is [constant EVENT_RECEIVE], the received packet will be queued to the associated [ENetPacketPeer].
Call this function regularly to handle connections, disconnections, and to receive new packets.
[b]Note:[/b] This method must be called on both ends involved in the event (sending and receiving hosts).
*/
//go:nosplit
func (self class) Service(timeout int64) Array.Any { //gd:ENetConnection.service
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), methods.service, gdextension.SizeArray|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ timeout int64 }{timeout}))
	var ret = Array.Through(gd.ArrayProxy[variant.Any]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

/*
Sends any queued packets on the host specified to its designated peers.
*/
//go:nosplit
func (self class) Flush() { //gd:ENetConnection.flush
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.flush, 0, unsafe.Pointer(&struct{}{}))
}

/*
Adjusts the bandwidth limits of a host.
*/
//go:nosplit
func (self class) BandwidthLimit(in_bandwidth int64, out_bandwidth int64) { //gd:ENetConnection.bandwidth_limit
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.bandwidth_limit, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		in_bandwidth  int64
		out_bandwidth int64
	}{in_bandwidth, out_bandwidth}))
}

/*
Limits the maximum allowed channels of future incoming connections.
*/
//go:nosplit
func (self class) ChannelLimit(limit int64) { //gd:ENetConnection.channel_limit
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.channel_limit, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ limit int64 }{limit}))
}

/*
Queues a [param packet] to be sent to all peers associated with the host over the specified [param channel]. See [ENetPacketPeer] [code]FLAG_*[/code] constants for available packet flags.
*/
//go:nosplit
func (self class) Broadcast(channel int64, packet Packed.Bytes, flags int64) { //gd:ENetConnection.broadcast
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.broadcast, 0|(gdextension.SizeInt<<4)|(gdextension.SizePackedArray<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		channel int64
		packet  gdextension.PackedArray[byte]
		flags   int64
	}{channel, pointers.Get(gd.InternalPacked[gd.PackedByteArray, byte](Packed.Array[byte](packet))), flags}))
}

/*
Sets the compression method used for network packets. These have different tradeoffs of compression speed versus bandwidth, you may need to test which one works best for your use case if you use compression at all.
[b]Note:[/b] Most games' network design involve sending many small packets frequently (smaller than 4 KB each). If in doubt, it is recommended to keep the default compression algorithm as it works best on these small packets.
[b]Note:[/b] The compression mode must be set to the same value on both the server and all its clients. Clients will fail to connect if the compression mode set on the client differs from the one set on the server.
*/
//go:nosplit
func (self class) Compress(mode CompressionMode) { //gd:ENetConnection.compress
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.compress, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ mode CompressionMode }{mode}))
}

/*
Configure this ENetHost to use the custom Godot extension allowing DTLS encryption for ENet servers. Call this right after [method create_host_bound] to have ENet expect peers to connect using DTLS. See [method TLSOptions.server].
*/
//go:nosplit
func (self class) DtlsServerSetup(server_options [1]gdclass.TLSOptions) Error.Code { //gd:ENetConnection.dtls_server_setup
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.dtls_server_setup, gdextension.SizeInt|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ server_options gdextension.Object }{gdextension.Object(gd.ObjectChecked(server_options[0].AsObject()))}))
	var ret = Error.Code(r_ret)
	return ret
}

/*
Configure this ENetHost to use the custom Godot extension allowing DTLS encryption for ENet clients. Call this before [method connect_to_host] to have ENet connect using DTLS validating the server certificate against [param hostname]. You can pass the optional [param client_options] parameter to customize the trusted certification authorities, or disable the common name verification. See [method TLSOptions.client] and [method TLSOptions.client_unsafe].
*/
//go:nosplit
func (self class) DtlsClientSetup(hostname String.Readable, client_options [1]gdclass.TLSOptions) Error.Code { //gd:ENetConnection.dtls_client_setup
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.dtls_client_setup, gdextension.SizeInt|(gdextension.SizeString<<4)|(gdextension.SizeObject<<8), unsafe.Pointer(&struct {
		hostname       gdextension.String
		client_options gdextension.Object
	}{pointers.Get(gd.InternalString(hostname)), gdextension.Object(gd.ObjectChecked(client_options[0].AsObject()))}))
	var ret = Error.Code(r_ret)
	return ret
}

/*
Configures the DTLS server to automatically drop new connections.
[b]Note:[/b] This method is only relevant after calling [method dtls_server_setup].
*/
//go:nosplit
func (self class) RefuseNewConnections(refuse bool) { //gd:ENetConnection.refuse_new_connections
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.refuse_new_connections, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ refuse bool }{refuse}))
}

/*
Returns and resets host statistics. See [enum HostStatistic] for more info.
*/
//go:nosplit
func (self class) PopStatistic(statistic HostStatistic) float64 { //gd:ENetConnection.pop_statistic
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.pop_statistic, gdextension.SizeFloat|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ statistic HostStatistic }{statistic}))
	var ret = r_ret
	return ret
}

/*
Returns the maximum number of channels allowed for connected peers.
*/
//go:nosplit
func (self class) GetMaxChannels() int64 { //gd:ENetConnection.get_max_channels
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_max_channels, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the local port to which this peer is bound.
*/
//go:nosplit
func (self class) GetLocalPort() int64 { //gd:ENetConnection.get_local_port
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_local_port, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the list of peers associated with this host.
[b]Note:[/b] This list might include some peers that are not fully connected or are still being disconnected.
*/
//go:nosplit
func (self class) GetPeers() Array.Contains[[1]gdclass.ENetPacketPeer] { //gd:ENetConnection.get_peers
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), methods.get_peers, gdextension.SizeArray, unsafe.Pointer(&struct{}{}))
	var ret = Array.Through(gd.ArrayProxy[[1]gdclass.ENetPacketPeer]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

/*
Sends a [param packet] toward a destination from the address and port currently bound by this ENetConnection instance.
This is useful as it serves to establish entries in NAT routing tables on all devices between this bound instance and the public facing internet, allowing a prospective client's connection packets to be routed backward through the NAT device(s) between the public internet and this host.
This requires forward knowledge of a prospective client's address and communication port as seen by the public internet - after any NAT devices have handled their connection request. This information can be obtained by a [url=https://en.wikipedia.org/wiki/STUN]STUN[/url] service, and must be handed off to your host by an entity that is not the prospective client. This will never work for a client behind a Symmetric NAT due to the nature of the Symmetric NAT routing algorithm, as their IP and Port cannot be known beforehand.
*/
//go:nosplit
func (self class) SocketSend(destination_address String.Readable, destination_port int64, packet Packed.Bytes) { //gd:ENetConnection.socket_send
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.socket_send, 0|(gdextension.SizeString<<4)|(gdextension.SizeInt<<8)|(gdextension.SizePackedArray<<12), unsafe.Pointer(&struct {
		destination_address gdextension.String
		destination_port    int64
		packet              gdextension.PackedArray[byte]
	}{pointers.Get(gd.InternalString(destination_address)), destination_port, pointers.Get(gd.InternalPacked[gd.PackedByteArray, byte](Packed.Array[byte](packet)))}))
}
func (self class) AsENetConnection() Advanced         { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsENetConnection() Instance      { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsENetConnection() Instance { return self.Super().AsENetConnection() }
func (self class) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsRefCounted() [1]gd.RefCounted { return self.Super().AsRefCounted() }
func (self Instance) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(RefCounted.Advanced(self.AsRefCounted()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(RefCounted.Instance(self.AsRefCounted()), name)
	}
}
func init() {
	gdclass.Register("ENetConnection", func(ptr gd.Object) any { return *(*Instance)(unsafe.Pointer(&ptr)) })
}

type CompressionMode int //gd:ENetConnection.CompressionMode

const (
	/*No compression. This uses the most bandwidth, but has the upside of requiring the fewest CPU resources. This option may also be used to make network debugging using tools like Wireshark easier.*/
	CompressNone CompressionMode = 0
	/*ENet's built-in range encoding. Works well on small packets, but is not the most efficient algorithm on packets larger than 4 KB.*/
	CompressRangeCoder CompressionMode = 1
	/*[url=https://fastlz.org/]FastLZ[/url] compression. This option uses less CPU resources compared to [constant COMPRESS_ZLIB], at the expense of using more bandwidth.*/
	CompressFastlz CompressionMode = 2
	/*[url=https://www.zlib.net/]Zlib[/url] compression. This option uses less bandwidth compared to [constant COMPRESS_FASTLZ], at the expense of using more CPU resources.*/
	CompressZlib CompressionMode = 3
	/*[url=https://facebook.github.io/zstd/]Zstandard[/url] compression. Note that this algorithm is not very efficient on packets smaller than 4 KB. Therefore, it's recommended to use other compression algorithms in most cases.*/
	CompressZstd CompressionMode = 4
)

type EventType int //gd:ENetConnection.EventType

const (
	/*An error occurred during [method service]. You will likely need to [method destroy] the host and recreate it.*/
	EventError EventType = -1
	/*No event occurred within the specified time limit.*/
	EventNone EventType = 0
	/*A connection request initiated by enet_host_connect has completed. The array will contain the peer which successfully connected.*/
	EventConnect EventType = 1
	/*A peer has disconnected. This event is generated on a successful completion of a disconnect initiated by [method ENetPacketPeer.peer_disconnect], if a peer has timed out, or if a connection request initialized by [method connect_to_host] has timed out. The array will contain the peer which disconnected. The data field contains user supplied data describing the disconnection, or 0, if none is available.*/
	EventDisconnect EventType = 2
	/*A packet has been received from a peer. The array will contain the peer which sent the packet and the channel number upon which the packet was received. The received packet will be queued to the associated [ENetPacketPeer].*/
	EventReceive EventType = 3
)

type HostStatistic int //gd:ENetConnection.HostStatistic

const (
	/*Total data sent.*/
	HostTotalSentData HostStatistic = 0
	/*Total UDP packets sent.*/
	HostTotalSentPackets HostStatistic = 1
	/*Total data received.*/
	HostTotalReceivedData HostStatistic = 2
	/*Total UDP packets received.*/
	HostTotalReceivedPackets HostStatistic = 3
)
