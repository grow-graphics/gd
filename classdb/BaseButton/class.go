// Code generated by the generate package DO NOT EDIT

// Package BaseButton provides methods for working with BaseButton object instances.
package BaseButton

import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/variant/Signal"
import "graphics.gd/classdb/CanvasItem"
import "graphics.gd/classdb/Control"
import "graphics.gd/classdb/Input"
import "graphics.gd/classdb/Node"
import "graphics.gd/classdb/Shortcut"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Signal.Any
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
[BaseButton] is an abstract base class for GUI buttons. It doesn't display anything by itself.

	See [Interface] for methods that can be overridden by a [Class] that extends it.
*/
type Instance [1]gdclass.BaseButton

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	set_pressed                    gdextension.MethodForClass `hash:"2586408642"`
	is_pressed                     gdextension.MethodForClass `hash:"36873697"`
	set_pressed_no_signal          gdextension.MethodForClass `hash:"2586408642"`
	is_hovered                     gdextension.MethodForClass `hash:"36873697"`
	set_toggle_mode                gdextension.MethodForClass `hash:"2586408642"`
	is_toggle_mode                 gdextension.MethodForClass `hash:"36873697"`
	set_shortcut_in_tooltip        gdextension.MethodForClass `hash:"2586408642"`
	is_shortcut_in_tooltip_enabled gdextension.MethodForClass `hash:"36873697"`
	set_disabled                   gdextension.MethodForClass `hash:"2586408642"`
	is_disabled                    gdextension.MethodForClass `hash:"36873697"`
	set_action_mode                gdextension.MethodForClass `hash:"1985162088"`
	get_action_mode                gdextension.MethodForClass `hash:"2589712189"`
	set_button_mask                gdextension.MethodForClass `hash:"3950145251"`
	get_button_mask                gdextension.MethodForClass `hash:"2512161324"`
	get_draw_mode                  gdextension.MethodForClass `hash:"2492721305"`
	set_keep_pressed_outside       gdextension.MethodForClass `hash:"2586408642"`
	is_keep_pressed_outside        gdextension.MethodForClass `hash:"36873697"`
	set_shortcut_feedback          gdextension.MethodForClass `hash:"2586408642"`
	is_shortcut_feedback           gdextension.MethodForClass `hash:"36873697"`
	set_shortcut                   gdextension.MethodForClass `hash:"857163497"`
	get_shortcut                   gdextension.MethodForClass `hash:"3415666916"`
	set_button_group               gdextension.MethodForClass `hash:"1794463739"`
	get_button_group               gdextension.MethodForClass `hash:"281644053"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("BaseButton")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		gdextension.Free(gdextension.TypeStringName, &sname)
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsBaseButton() Instance
}
type Interface interface {
	//Called when the button is pressed. If you need to know the button's pressed state (and [member toggle_mode] is active), use [method _toggled] instead.
	Pressed()
	//Called when the button is toggled (only if [member toggle_mode] is active).
	Toggled(toggled_on bool)
}

// Implementation implements [Interface] with empty methods.
type Implementation = implementation

type implementation struct{}

func (self implementation) Pressed()                { return }
func (self implementation) Toggled(toggled_on bool) { return }

/*
Called when the button is pressed. If you need to know the button's pressed state (and [member toggle_mode] is active), use [method _toggled] instead.
*/
func (Instance) _pressed(impl func(ptr gdclass.Receiver)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args, p_back gdextension.Pointer) {
		self := gdclass.Receiver(reflect.ValueOf(class).UnsafePointer())
		impl(self)
	}
}

/*
Called when the button is toggled (only if [member toggle_mode] is active).
*/
func (Instance) _toggled(impl func(ptr gdclass.Receiver, toggled_on bool)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args, p_back gdextension.Pointer) {
		var toggled_on = gd.UnsafeGet[bool](p_args, 0)
		self := gdclass.Receiver(reflect.ValueOf(class).UnsafePointer())
		impl(self, toggled_on)
	}
}

/*
Changes the [member button_pressed] state of the button, without emitting [signal toggled]. Use when you just want to change the state of the button without sending the pressed event (e.g. when initializing scene). Only works if [member toggle_mode] is [code]true[/code].
[b]Note:[/b] This method doesn't unpress other buttons in [member button_group].
*/
func (self Instance) SetPressedNoSignal(pressed bool) { //gd:BaseButton.set_pressed_no_signal
	Advanced(self).SetPressedNoSignal(pressed)
}

/*
Returns [code]true[/code] if the mouse has entered the button and has not left it yet.
*/
func (self Instance) IsHovered() bool { //gd:BaseButton.is_hovered
	return bool(Advanced(self).IsHovered())
}

/*
Returns the visual state used to draw the button. This is useful mainly when implementing your own draw code by either overriding _draw() or connecting to "draw" signal. The visual state of the button is defined by the [enum DrawMode] enum.
*/
func (self Instance) GetDrawMode() DrawMode { //gd:BaseButton.get_draw_mode
	return DrawMode(Advanced(self).GetDrawMode())
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.BaseButton

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = pointers.AsA[gdclass.BaseButton](obj[0])
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = pointers.AsA[gdclass.BaseButton](obj[0])
		return true
	}
	return false
}
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }
func (self *Extension[T]) AsObject() [1]gd.Object { return self.Super().AsObject() }
func New() Instance {
	if !gd.Linked {
		var placeholder = Instance([1]gdclass.BaseButton{pointers.Add[gdclass.BaseButton]([3]uint64{})})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(pointers.AsA[gd.Object](placeholder[0]), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	casted := Instance([1]gdclass.BaseButton{pointers.New[gdclass.BaseButton]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})})
	casted.AsObject()[0].Notification(0, false)
	return casted
}

func (self Instance) Disabled() bool {
	return bool(class(self).IsDisabled())
}

func (self Instance) SetDisabled(value bool) {
	class(self).SetDisabled(value)
}

func (self Instance) ToggleMode() bool {
	return bool(class(self).IsToggleMode())
}

func (self Instance) SetToggleMode(value bool) {
	class(self).SetToggleMode(value)
}

func (self Instance) ButtonPressed() bool {
	return bool(class(self).IsPressed())
}

func (self Instance) SetButtonPressed(value bool) {
	class(self).SetPressed(value)
}

func (self Instance) ActionMode() ActionMode {
	return ActionMode(class(self).GetActionMode())
}

func (self Instance) SetActionMode(value ActionMode) {
	class(self).SetActionMode(value)
}

func (self Instance) ButtonMask() Input.MouseButtonMask {
	return Input.MouseButtonMask(class(self).GetButtonMask())
}

func (self Instance) SetButtonMask(value Input.MouseButtonMask) {
	class(self).SetButtonMask(value)
}

func (self Instance) KeepPressedOutside() bool {
	return bool(class(self).IsKeepPressedOutside())
}

func (self Instance) SetKeepPressedOutside(value bool) {
	class(self).SetKeepPressedOutside(value)
}

func (self Instance) Shortcut() Shortcut.Instance {
	return Shortcut.Instance(class(self).GetShortcut())
}

func (self Instance) SetShortcut(value Shortcut.Instance) {
	class(self).SetShortcut(value)
}

func (self Instance) ShortcutFeedback() bool {
	return bool(class(self).IsShortcutFeedback())
}

func (self Instance) SetShortcutFeedback(value bool) {
	class(self).SetShortcutFeedback(value)
}

func (self Instance) ShortcutInTooltip() bool {
	return bool(class(self).IsShortcutInTooltipEnabled())
}

func (self Instance) SetShortcutInTooltip(value bool) {
	class(self).SetShortcutInTooltip(value)
}

/*
Called when the button is pressed. If you need to know the button's pressed state (and [member toggle_mode] is active), use [method _toggled] instead.
*/
func (class) _pressed(impl func(ptr gdclass.Receiver)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args, p_back gdextension.Pointer) {
		self := gdclass.Receiver(reflect.ValueOf(class).UnsafePointer())
		impl(self)
	}
}

/*
Called when the button is toggled (only if [member toggle_mode] is active).
*/
func (class) _toggled(impl func(ptr gdclass.Receiver, toggled_on bool)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args, p_back gdextension.Pointer) {
		var toggled_on = gd.UnsafeGet[bool](p_args, 0)
		self := gdclass.Receiver(reflect.ValueOf(class).UnsafePointer())
		impl(self, toggled_on)
	}
}

//go:nosplit
func (self class) SetPressed(pressed bool) { //gd:BaseButton.set_pressed
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_pressed, 0|(gdextension.SizeBool<<4), &struct{ pressed bool }{pressed})
}

//go:nosplit
func (self class) IsPressed() bool { //gd:BaseButton.is_pressed
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_pressed, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

/*
Changes the [member button_pressed] state of the button, without emitting [signal toggled]. Use when you just want to change the state of the button without sending the pressed event (e.g. when initializing scene). Only works if [member toggle_mode] is [code]true[/code].
[b]Note:[/b] This method doesn't unpress other buttons in [member button_group].
*/
//go:nosplit
func (self class) SetPressedNoSignal(pressed bool) { //gd:BaseButton.set_pressed_no_signal
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_pressed_no_signal, 0|(gdextension.SizeBool<<4), &struct{ pressed bool }{pressed})
}

/*
Returns [code]true[/code] if the mouse has entered the button and has not left it yet.
*/
//go:nosplit
func (self class) IsHovered() bool { //gd:BaseButton.is_hovered
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_hovered, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetToggleMode(enabled bool) { //gd:BaseButton.set_toggle_mode
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_toggle_mode, 0|(gdextension.SizeBool<<4), &struct{ enabled bool }{enabled})
}

//go:nosplit
func (self class) IsToggleMode() bool { //gd:BaseButton.is_toggle_mode
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_toggle_mode, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetShortcutInTooltip(enabled bool) { //gd:BaseButton.set_shortcut_in_tooltip
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_shortcut_in_tooltip, 0|(gdextension.SizeBool<<4), &struct{ enabled bool }{enabled})
}

//go:nosplit
func (self class) IsShortcutInTooltipEnabled() bool { //gd:BaseButton.is_shortcut_in_tooltip_enabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_shortcut_in_tooltip_enabled, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetDisabled(disabled bool) { //gd:BaseButton.set_disabled
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_disabled, 0|(gdextension.SizeBool<<4), &struct{ disabled bool }{disabled})
}

//go:nosplit
func (self class) IsDisabled() bool { //gd:BaseButton.is_disabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_disabled, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetActionMode(mode ActionMode) { //gd:BaseButton.set_action_mode
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_action_mode, 0|(gdextension.SizeInt<<4), &struct{ mode ActionMode }{mode})
}

//go:nosplit
func (self class) GetActionMode() ActionMode { //gd:BaseButton.get_action_mode
	var r_ret = gdextension.Call[ActionMode](gd.ObjectChecked(self.AsObject()), methods.get_action_mode, gdextension.SizeInt, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetButtonMask(mask Input.MouseButtonMask) { //gd:BaseButton.set_button_mask
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_button_mask, 0|(gdextension.SizeInt<<4), &struct{ mask Input.MouseButtonMask }{mask})
}

//go:nosplit
func (self class) GetButtonMask() Input.MouseButtonMask { //gd:BaseButton.get_button_mask
	var r_ret = gdextension.Call[Input.MouseButtonMask](gd.ObjectChecked(self.AsObject()), methods.get_button_mask, gdextension.SizeInt, &struct{}{})
	var ret = r_ret
	return ret
}

/*
Returns the visual state used to draw the button. This is useful mainly when implementing your own draw code by either overriding _draw() or connecting to "draw" signal. The visual state of the button is defined by the [enum DrawMode] enum.
*/
//go:nosplit
func (self class) GetDrawMode() DrawMode { //gd:BaseButton.get_draw_mode
	var r_ret = gdextension.Call[DrawMode](gd.ObjectChecked(self.AsObject()), methods.get_draw_mode, gdextension.SizeInt, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetKeepPressedOutside(enabled bool) { //gd:BaseButton.set_keep_pressed_outside
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_keep_pressed_outside, 0|(gdextension.SizeBool<<4), &struct{ enabled bool }{enabled})
}

//go:nosplit
func (self class) IsKeepPressedOutside() bool { //gd:BaseButton.is_keep_pressed_outside
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_keep_pressed_outside, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetShortcutFeedback(enabled bool) { //gd:BaseButton.set_shortcut_feedback
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_shortcut_feedback, 0|(gdextension.SizeBool<<4), &struct{ enabled bool }{enabled})
}

//go:nosplit
func (self class) IsShortcutFeedback() bool { //gd:BaseButton.is_shortcut_feedback
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_shortcut_feedback, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetShortcut(shortcut [1]gdclass.Shortcut) { //gd:BaseButton.set_shortcut
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_shortcut, 0|(gdextension.SizeObject<<4), &struct{ shortcut gdextension.Object }{gdextension.Object(gd.ObjectChecked(shortcut[0].AsObject()))})
}

//go:nosplit
func (self class) GetShortcut() [1]gdclass.Shortcut { //gd:BaseButton.get_shortcut
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_shortcut, gdextension.SizeObject, &struct{}{})
	var ret = [1]gdclass.Shortcut{gd.PointerWithOwnershipTransferredToGo[gdclass.Shortcut](r_ret)}
	return ret
}

//go:nosplit
func (self class) SetButtonGroup(button_group [1]gdclass.ButtonGroup) { //gd:BaseButton.set_button_group
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_button_group, 0|(gdextension.SizeObject<<4), &struct{ button_group gdextension.Object }{gdextension.Object(gd.ObjectChecked(button_group[0].AsObject()))})
}

//go:nosplit
func (self class) GetButtonGroup() [1]gdclass.ButtonGroup { //gd:BaseButton.get_button_group
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_button_group, gdextension.SizeObject, &struct{}{})
	var ret = [1]gdclass.ButtonGroup{gd.PointerWithOwnershipTransferredToGo[gdclass.ButtonGroup](r_ret)}
	return ret
}
func (self Instance) OnPressed(cb func(), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("pressed"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) Pressed() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`Pressed`))))
}

func (self Instance) OnButtonUp(cb func(), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("button_up"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) ButtonUp() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`ButtonUp`))))
}

func (self Instance) OnButtonDown(cb func(), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("button_down"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) ButtonDown() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`ButtonDown`))))
}

func (self Instance) OnToggled(cb func(toggled_on bool), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("toggled"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) Toggled() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`Toggled`))))
}

func (self class) AsBaseButton() Advanced { return Advanced{pointers.AsA[gdclass.BaseButton](self[0])} }
func (self Instance) AsBaseButton() Instance {
	return Instance{pointers.AsA[gdclass.BaseButton](self[0])}
}
func (self *Extension[T]) AsBaseButton() Instance { return self.Super().AsBaseButton() }
func (self class) AsControl() Control.Advanced {
	return Control.Advanced{pointers.AsA[gdclass.Control](self[0])}
}
func (self *Extension[T]) AsControl() Control.Instance { return self.Super().AsControl() }
func (self Instance) AsControl() Control.Instance {
	return Control.Instance{pointers.AsA[gdclass.Control](self[0])}
}
func (self class) AsCanvasItem() CanvasItem.Advanced {
	return CanvasItem.Advanced{pointers.AsA[gdclass.CanvasItem](self[0])}
}
func (self *Extension[T]) AsCanvasItem() CanvasItem.Instance { return self.Super().AsCanvasItem() }
func (self Instance) AsCanvasItem() CanvasItem.Instance {
	return CanvasItem.Instance{pointers.AsA[gdclass.CanvasItem](self[0])}
}
func (self class) AsNode() Node.Advanced         { return Node.Advanced{pointers.AsA[gdclass.Node](self[0])} }
func (self *Extension[T]) AsNode() Node.Instance { return self.Super().AsNode() }
func (self Instance) AsNode() Node.Instance {
	return Node.Instance{pointers.AsA[gdclass.Node](self[0])}
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	case "_pressed":
		return reflect.ValueOf(self._pressed)
	case "_toggled":
		return reflect.ValueOf(self._toggled)
	default:
		return gd.VirtualByName(Control.Advanced(self.AsControl()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	case "_pressed":
		return reflect.ValueOf(self._pressed)
	case "_toggled":
		return reflect.ValueOf(self._toggled)
	default:
		return gd.VirtualByName(Control.Instance(self.AsControl()), name)
	}
}
func init() {
	gdclass.Register("BaseButton", func(ptr gd.Object) any { return Instance{pointers.AsA[gdclass.BaseButton](ptr)} })
}

type DrawMode int //gd:BaseButton.DrawMode

const (
	/*The normal state (i.e. not pressed, not hovered, not toggled and enabled) of buttons.*/
	DrawNormal DrawMode = 0
	/*The state of buttons are pressed.*/
	DrawPressed DrawMode = 1
	/*The state of buttons are hovered.*/
	DrawHover DrawMode = 2
	/*The state of buttons are disabled.*/
	DrawDisabled DrawMode = 3
	/*The state of buttons are both hovered and pressed.*/
	DrawHoverPressed DrawMode = 4
)

type ActionMode int //gd:BaseButton.ActionMode

const (
	/*Require just a press to consider the button clicked.*/
	ActionModeButtonPress ActionMode = 0
	/*Require a press and a subsequent release before considering the button clicked.*/
	ActionModeButtonRelease ActionMode = 1
)
