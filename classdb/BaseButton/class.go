// Code generated by the generate package DO NOT EDIT

// Package BaseButton provides methods for working with BaseButton object instances.
package BaseButton

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdunsafe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/CanvasItem"
import "graphics.gd/classdb/Control"
import "graphics.gd/classdb/Input"
import "graphics.gd/classdb/Node"
import "graphics.gd/classdb/Shortcut"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = gdunsafe.Use{}
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
[BaseButton] is an abstract base class for GUI buttons. It doesn't display anything by itself.

	See [Interface] for methods that can be overridden by a [Class] that extends it.
*/
type Instance [1]gdclass.BaseButton

func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsBaseButton() Instance
}
type Interface interface {
	//Called when the button is pressed. If you need to know the button's pressed state (and [member toggle_mode] is active), use [method _toggled] instead.
	Pressed()
	//Called when the button is toggled (only if [member toggle_mode] is active).
	Toggled(toggled_on bool)
}

// Implementation implements [Interface] with empty methods.
type Implementation = implementation

type implementation struct{}

func (self implementation) Pressed()                { return }
func (self implementation) Toggled(toggled_on bool) { return }

/*
Called when the button is pressed. If you need to know the button's pressed state (and [member toggle_mode] is active), use [method _toggled] instead.
*/
func (Instance) _pressed(impl func(ptr unsafe.Pointer)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self)
	}
}

/*
Called when the button is toggled (only if [member toggle_mode] is active).
*/
func (Instance) _toggled(impl func(ptr unsafe.Pointer, toggled_on bool)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var toggled_on = gd.UnsafeGet[bool](p_args, 0)
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, toggled_on)
	}
}

/*
Changes the [member button_pressed] state of the button, without emitting [signal toggled]. Use when you just want to change the state of the button without sending the pressed event (e.g. when initializing scene). Only works if [member toggle_mode] is [code]true[/code].
[b]Note:[/b] This method doesn't unpress other buttons in [member button_group].
*/
func (self Instance) SetPressedNoSignal(pressed bool) { //gd:BaseButton.set_pressed_no_signal
	Advanced(self).SetPressedNoSignal(pressed)
}

/*
Returns [code]true[/code] if the mouse has entered the button and has not left it yet.
*/
func (self Instance) IsHovered() bool { //gd:BaseButton.is_hovered
	return bool(Advanced(self).IsHovered())
}

/*
Returns the visual state used to draw the button. This is useful mainly when implementing your own draw code by either overriding _draw() or connecting to "draw" signal. The visual state of the button is defined by the [enum DrawMode] enum.
*/
func (self Instance) GetDrawMode() DrawMode { //gd:BaseButton.get_draw_mode
	return DrawMode(Advanced(self).GetDrawMode())
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.BaseButton

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {
	object := gd.Global.ClassDB.ConstructObject(gd.NewStringName("BaseButton"))
	casted := Instance{*(*gdclass.BaseButton)(unsafe.Pointer(&object))}
	return casted
}

func (self Instance) Disabled() bool {
	return bool(class(self).IsDisabled())
}

func (self Instance) SetDisabled(value bool) {
	class(self).SetDisabled(value)
}

func (self Instance) ToggleMode() bool {
	return bool(class(self).IsToggleMode())
}

func (self Instance) SetToggleMode(value bool) {
	class(self).SetToggleMode(value)
}

func (self Instance) ButtonPressed() bool {
	return bool(class(self).IsPressed())
}

func (self Instance) SetButtonPressed(value bool) {
	class(self).SetPressed(value)
}

func (self Instance) ActionMode() ActionMode {
	return ActionMode(class(self).GetActionMode())
}

func (self Instance) SetActionMode(value ActionMode) {
	class(self).SetActionMode(value)
}

func (self Instance) ButtonMask() Input.MouseButtonMask {
	return Input.MouseButtonMask(class(self).GetButtonMask())
}

func (self Instance) SetButtonMask(value Input.MouseButtonMask) {
	class(self).SetButtonMask(value)
}

func (self Instance) KeepPressedOutside() bool {
	return bool(class(self).IsKeepPressedOutside())
}

func (self Instance) SetKeepPressedOutside(value bool) {
	class(self).SetKeepPressedOutside(value)
}

func (self Instance) Shortcut() Shortcut.Instance {
	return Shortcut.Instance(class(self).GetShortcut())
}

func (self Instance) SetShortcut(value Shortcut.Instance) {
	class(self).SetShortcut(value)
}

func (self Instance) ShortcutFeedback() bool {
	return bool(class(self).IsShortcutFeedback())
}

func (self Instance) SetShortcutFeedback(value bool) {
	class(self).SetShortcutFeedback(value)
}

func (self Instance) ShortcutInTooltip() bool {
	return bool(class(self).IsShortcutInTooltipEnabled())
}

func (self Instance) SetShortcutInTooltip(value bool) {
	class(self).SetShortcutInTooltip(value)
}

/*
Called when the button is pressed. If you need to know the button's pressed state (and [member toggle_mode] is active), use [method _toggled] instead.
*/
func (class) _pressed(impl func(ptr unsafe.Pointer)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self)
	}
}

/*
Called when the button is toggled (only if [member toggle_mode] is active).
*/
func (class) _toggled(impl func(ptr unsafe.Pointer, toggled_on bool)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var toggled_on = gd.UnsafeGet[bool](p_args, 0)
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, toggled_on)
	}
}

//go:nosplit
func (self class) SetPressed(pressed bool) { //gd:BaseButton.set_pressed
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.BaseButton.Bind_set_pressed, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ pressed bool }{pressed}))
}

//go:nosplit
func (self class) IsPressed() bool { //gd:BaseButton.is_pressed
	var r_ret = gdunsafe.Call[bool](self.AsObject(), gd.Global.Methods.BaseButton.Bind_is_pressed, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Changes the [member button_pressed] state of the button, without emitting [signal toggled]. Use when you just want to change the state of the button without sending the pressed event (e.g. when initializing scene). Only works if [member toggle_mode] is [code]true[/code].
[b]Note:[/b] This method doesn't unpress other buttons in [member button_group].
*/
//go:nosplit
func (self class) SetPressedNoSignal(pressed bool) { //gd:BaseButton.set_pressed_no_signal
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.BaseButton.Bind_set_pressed_no_signal, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ pressed bool }{pressed}))
}

/*
Returns [code]true[/code] if the mouse has entered the button and has not left it yet.
*/
//go:nosplit
func (self class) IsHovered() bool { //gd:BaseButton.is_hovered
	var r_ret = gdunsafe.Call[bool](self.AsObject(), gd.Global.Methods.BaseButton.Bind_is_hovered, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetToggleMode(enabled bool) { //gd:BaseButton.set_toggle_mode
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.BaseButton.Bind_set_toggle_mode, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enabled bool }{enabled}))
}

//go:nosplit
func (self class) IsToggleMode() bool { //gd:BaseButton.is_toggle_mode
	var r_ret = gdunsafe.Call[bool](self.AsObject(), gd.Global.Methods.BaseButton.Bind_is_toggle_mode, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetShortcutInTooltip(enabled bool) { //gd:BaseButton.set_shortcut_in_tooltip
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.BaseButton.Bind_set_shortcut_in_tooltip, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enabled bool }{enabled}))
}

//go:nosplit
func (self class) IsShortcutInTooltipEnabled() bool { //gd:BaseButton.is_shortcut_in_tooltip_enabled
	var r_ret = gdunsafe.Call[bool](self.AsObject(), gd.Global.Methods.BaseButton.Bind_is_shortcut_in_tooltip_enabled, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetDisabled(disabled bool) { //gd:BaseButton.set_disabled
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.BaseButton.Bind_set_disabled, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ disabled bool }{disabled}))
}

//go:nosplit
func (self class) IsDisabled() bool { //gd:BaseButton.is_disabled
	var r_ret = gdunsafe.Call[bool](self.AsObject(), gd.Global.Methods.BaseButton.Bind_is_disabled, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetActionMode(mode ActionMode) { //gd:BaseButton.set_action_mode
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.BaseButton.Bind_set_action_mode, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ mode ActionMode }{mode}))
}

//go:nosplit
func (self class) GetActionMode() ActionMode { //gd:BaseButton.get_action_mode
	var r_ret = gdunsafe.Call[ActionMode](self.AsObject(), gd.Global.Methods.BaseButton.Bind_get_action_mode, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetButtonMask(mask Input.MouseButtonMask) { //gd:BaseButton.set_button_mask
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.BaseButton.Bind_set_button_mask, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ mask Input.MouseButtonMask }{mask}))
}

//go:nosplit
func (self class) GetButtonMask() Input.MouseButtonMask { //gd:BaseButton.get_button_mask
	var r_ret = gdunsafe.Call[Input.MouseButtonMask](self.AsObject(), gd.Global.Methods.BaseButton.Bind_get_button_mask, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the visual state used to draw the button. This is useful mainly when implementing your own draw code by either overriding _draw() or connecting to "draw" signal. The visual state of the button is defined by the [enum DrawMode] enum.
*/
//go:nosplit
func (self class) GetDrawMode() DrawMode { //gd:BaseButton.get_draw_mode
	var r_ret = gdunsafe.Call[DrawMode](self.AsObject(), gd.Global.Methods.BaseButton.Bind_get_draw_mode, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetKeepPressedOutside(enabled bool) { //gd:BaseButton.set_keep_pressed_outside
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.BaseButton.Bind_set_keep_pressed_outside, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enabled bool }{enabled}))
}

//go:nosplit
func (self class) IsKeepPressedOutside() bool { //gd:BaseButton.is_keep_pressed_outside
	var r_ret = gdunsafe.Call[bool](self.AsObject(), gd.Global.Methods.BaseButton.Bind_is_keep_pressed_outside, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetShortcutFeedback(enabled bool) { //gd:BaseButton.set_shortcut_feedback
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.BaseButton.Bind_set_shortcut_feedback, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enabled bool }{enabled}))
}

//go:nosplit
func (self class) IsShortcutFeedback() bool { //gd:BaseButton.is_shortcut_feedback
	var r_ret = gdunsafe.Call[bool](self.AsObject(), gd.Global.Methods.BaseButton.Bind_is_shortcut_feedback, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetShortcut(shortcut [1]gdclass.Shortcut) { //gd:BaseButton.set_shortcut
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.BaseButton.Bind_set_shortcut, 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ shortcut gdextension.Object }{gdextension.Object(pointers.Get(shortcut[0])[0])}))
}

//go:nosplit
func (self class) GetShortcut() [1]gdclass.Shortcut { //gd:BaseButton.get_shortcut
	var r_ret = gdunsafe.Call[gd.EnginePointer](self.AsObject(), gd.Global.Methods.BaseButton.Bind_get_shortcut, gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.Shortcut{gd.PointerWithOwnershipTransferredToGo[gdclass.Shortcut](r_ret)}
	return ret
}

//go:nosplit
func (self class) SetButtonGroup(button_group [1]gdclass.ButtonGroup) { //gd:BaseButton.set_button_group
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.BaseButton.Bind_set_button_group, 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ button_group gdextension.Object }{gdextension.Object(pointers.Get(button_group[0])[0])}))
}

//go:nosplit
func (self class) GetButtonGroup() [1]gdclass.ButtonGroup { //gd:BaseButton.get_button_group
	var r_ret = gdunsafe.Call[gd.EnginePointer](self.AsObject(), gd.Global.Methods.BaseButton.Bind_get_button_group, gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.ButtonGroup{gd.PointerWithOwnershipTransferredToGo[gdclass.ButtonGroup](r_ret)}
	return ret
}
func (self Instance) OnPressed(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("pressed"), gd.NewCallable(cb), 0)
}

func (self Instance) OnButtonUp(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("button_up"), gd.NewCallable(cb), 0)
}

func (self Instance) OnButtonDown(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("button_down"), gd.NewCallable(cb), 0)
}

func (self Instance) OnToggled(cb func(toggled_on bool)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("toggled"), gd.NewCallable(cb), 0)
}

func (self class) AsBaseButton() Advanced              { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsBaseButton() Instance           { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsBaseButton() Instance      { return self.Super().AsBaseButton() }
func (self class) AsControl() Control.Advanced         { return *((*Control.Advanced)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsControl() Control.Instance { return self.Super().AsControl() }
func (self Instance) AsControl() Control.Instance {
	return *((*Control.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsCanvasItem() CanvasItem.Advanced {
	return *((*CanvasItem.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsCanvasItem() CanvasItem.Instance { return self.Super().AsCanvasItem() }
func (self Instance) AsCanvasItem() CanvasItem.Instance {
	return *((*CanvasItem.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsNode() Node.Advanced         { return *((*Node.Advanced)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsNode() Node.Instance { return self.Super().AsNode() }
func (self Instance) AsNode() Node.Instance      { return *((*Node.Instance)(unsafe.Pointer(&self))) }

func (self class) Virtual(name string) reflect.Value {
	switch name {
	case "_pressed":
		return reflect.ValueOf(self._pressed)
	case "_toggled":
		return reflect.ValueOf(self._toggled)
	default:
		return gd.VirtualByName(Control.Advanced(self.AsControl()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	case "_pressed":
		return reflect.ValueOf(self._pressed)
	case "_toggled":
		return reflect.ValueOf(self._toggled)
	default:
		return gd.VirtualByName(Control.Instance(self.AsControl()), name)
	}
}
func init() {
	gdclass.Register("BaseButton", func(ptr gd.Object) any { return [1]gdclass.BaseButton{*(*gdclass.BaseButton)(unsafe.Pointer(&ptr))} })
}

type DrawMode int //gd:BaseButton.DrawMode

const (
	/*The normal state (i.e. not pressed, not hovered, not toggled and enabled) of buttons.*/
	DrawNormal DrawMode = 0
	/*The state of buttons are pressed.*/
	DrawPressed DrawMode = 1
	/*The state of buttons are hovered.*/
	DrawHover DrawMode = 2
	/*The state of buttons are disabled.*/
	DrawDisabled DrawMode = 3
	/*The state of buttons are both hovered and pressed.*/
	DrawHoverPressed DrawMode = 4
)

type ActionMode int //gd:BaseButton.ActionMode

const (
	/*Require just a press to consider the button clicked.*/
	ActionModeButtonPress ActionMode = 0
	/*Require a press and a subsequent release before considering the button clicked.*/
	ActionModeButtonRelease ActionMode = 1
)
