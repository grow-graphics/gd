// Code generated by the generate package DO NOT EDIT

// Package SkeletonModification2DJiggle provides methods for working with SkeletonModification2DJiggle object instances.
package SkeletonModification2DJiggle

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/variant/Signal"
import "graphics.gd/classdb/Resource"
import "graphics.gd/classdb/SkeletonModification2D"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"
import "graphics.gd/variant/Vector2"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Signal.Any
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
This modification moves a series of bones, typically called a bone chain, towards a target. What makes this modification special is that it calculates the velocity and acceleration for each bone in the bone chain, and runs a very light physics-like calculation using the inputted values. This allows the bones to overshoot the target and "jiggle" around. It can be configured to act more like a spring, or sway around like cloth might.
This modification is useful for adding additional motion to things like hair, the edges of clothing, and more. It has several settings to that allow control over how the joint moves when the target moves.
[b]Note:[/b] The Jiggle modifier has [code]jiggle_joints[/code], which are the data objects that hold the data for each joint in the Jiggle chain. This is different from than [Bone2D] nodes! Jiggle joints hold the data needed for each [Bone2D] in the bone chain used by the Jiggle modification.
*/
type Instance [1]gdclass.SkeletonModification2DJiggle

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	set_target_node              gdextension.MethodForClass `hash:"1348162250"`
	get_target_node              gdextension.MethodForClass `hash:"4075236667"`
	set_jiggle_data_chain_length gdextension.MethodForClass `hash:"1286410249"`
	get_jiggle_data_chain_length gdextension.MethodForClass `hash:"2455072627"`
	set_stiffness                gdextension.MethodForClass `hash:"373806689"`
	get_stiffness                gdextension.MethodForClass `hash:"1740695150"`
	set_mass                     gdextension.MethodForClass `hash:"373806689"`
	get_mass                     gdextension.MethodForClass `hash:"1740695150"`
	set_damping                  gdextension.MethodForClass `hash:"373806689"`
	get_damping                  gdextension.MethodForClass `hash:"1740695150"`
	set_use_gravity              gdextension.MethodForClass `hash:"2586408642"`
	get_use_gravity              gdextension.MethodForClass `hash:"36873697"`
	set_gravity                  gdextension.MethodForClass `hash:"743155724"`
	get_gravity                  gdextension.MethodForClass `hash:"3341600327"`
	set_use_colliders            gdextension.MethodForClass `hash:"2586408642"`
	get_use_colliders            gdextension.MethodForClass `hash:"36873697"`
	set_collision_mask           gdextension.MethodForClass `hash:"1286410249"`
	get_collision_mask           gdextension.MethodForClass `hash:"3905245786"`
	set_jiggle_joint_bone2d_node gdextension.MethodForClass `hash:"2761262315"`
	get_jiggle_joint_bone2d_node gdextension.MethodForClass `hash:"408788394"`
	set_jiggle_joint_bone_index  gdextension.MethodForClass `hash:"3937882851"`
	get_jiggle_joint_bone_index  gdextension.MethodForClass `hash:"923996154"`
	set_jiggle_joint_override    gdextension.MethodForClass `hash:"300928843"`
	get_jiggle_joint_override    gdextension.MethodForClass `hash:"1116898809"`
	set_jiggle_joint_stiffness   gdextension.MethodForClass `hash:"1602489585"`
	get_jiggle_joint_stiffness   gdextension.MethodForClass `hash:"2339986948"`
	set_jiggle_joint_mass        gdextension.MethodForClass `hash:"1602489585"`
	get_jiggle_joint_mass        gdextension.MethodForClass `hash:"2339986948"`
	set_jiggle_joint_damping     gdextension.MethodForClass `hash:"1602489585"`
	get_jiggle_joint_damping     gdextension.MethodForClass `hash:"2339986948"`
	set_jiggle_joint_use_gravity gdextension.MethodForClass `hash:"300928843"`
	get_jiggle_joint_use_gravity gdextension.MethodForClass `hash:"1116898809"`
	set_jiggle_joint_gravity     gdextension.MethodForClass `hash:"163021252"`
	get_jiggle_joint_gravity     gdextension.MethodForClass `hash:"2299179447"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("SkeletonModification2DJiggle")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		gdextension.Free(gdextension.TypeStringName, &sname)
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsSkeletonModification2DJiggle() Instance
}

/*
If [code]true[/code], the Jiggle modifier will take colliders into account, keeping them from entering into these collision objects.
*/
func (self Instance) SetUseColliders(use_colliders bool) { //gd:SkeletonModification2DJiggle.set_use_colliders
	Advanced(self).SetUseColliders(use_colliders)
}

/*
Returns whether the jiggle modifier is taking physics colliders into account when solving.
*/
func (self Instance) GetUseColliders() bool { //gd:SkeletonModification2DJiggle.get_use_colliders
	return bool(Advanced(self).GetUseColliders())
}

/*
Sets the collision mask that the Jiggle modifier will use when reacting to colliders, if the Jiggle modifier is set to take colliders into account.
*/
func (self Instance) SetCollisionMask(collision_mask int) { //gd:SkeletonModification2DJiggle.set_collision_mask
	Advanced(self).SetCollisionMask(int64(collision_mask))
}

/*
Returns the collision mask used by the Jiggle modifier when collisions are enabled.
*/
func (self Instance) GetCollisionMask() int { //gd:SkeletonModification2DJiggle.get_collision_mask
	return int(int(Advanced(self).GetCollisionMask()))
}

/*
Sets the [Bone2D] node assigned to the Jiggle joint at [param joint_idx].
*/
func (self Instance) SetJiggleJointBone2dNode(joint_idx int, bone2d_node string) { //gd:SkeletonModification2DJiggle.set_jiggle_joint_bone2d_node
	Advanced(self).SetJiggleJointBone2dNode(int64(joint_idx), Path.ToNode(String.New(bone2d_node)))
}

/*
Returns the [Bone2D] node assigned to the Jiggle joint at [param joint_idx].
*/
func (self Instance) GetJiggleJointBone2dNode(joint_idx int) string { //gd:SkeletonModification2DJiggle.get_jiggle_joint_bone2d_node
	return string(Advanced(self).GetJiggleJointBone2dNode(int64(joint_idx)).String())
}

/*
Sets the bone index, [param bone_idx], of the Jiggle joint at [param joint_idx]. When possible, this will also update the [code]bone2d_node[/code] of the Jiggle joint based on data provided by the linked skeleton.
*/
func (self Instance) SetJiggleJointBoneIndex(joint_idx int, bone_idx int) { //gd:SkeletonModification2DJiggle.set_jiggle_joint_bone_index
	Advanced(self).SetJiggleJointBoneIndex(int64(joint_idx), int64(bone_idx))
}

/*
Returns the index of the [Bone2D] node assigned to the Jiggle joint at [param joint_idx].
*/
func (self Instance) GetJiggleJointBoneIndex(joint_idx int) int { //gd:SkeletonModification2DJiggle.get_jiggle_joint_bone_index
	return int(int(Advanced(self).GetJiggleJointBoneIndex(int64(joint_idx))))
}

/*
Sets whether the Jiggle joint at [param joint_idx] should override the default Jiggle joint settings. Setting this to [code]true[/code] will make the joint use its own settings rather than the default ones attached to the modification.
*/
func (self Instance) SetJiggleJointOverride(joint_idx int, override bool) { //gd:SkeletonModification2DJiggle.set_jiggle_joint_override
	Advanced(self).SetJiggleJointOverride(int64(joint_idx), override)
}

/*
Returns a boolean that indicates whether the joint at [param joint_idx] is overriding the default Jiggle joint data defined in the modification.
*/
func (self Instance) GetJiggleJointOverride(joint_idx int) bool { //gd:SkeletonModification2DJiggle.get_jiggle_joint_override
	return bool(Advanced(self).GetJiggleJointOverride(int64(joint_idx)))
}

/*
Sets the of stiffness of the Jiggle joint at [param joint_idx].
*/
func (self Instance) SetJiggleJointStiffness(joint_idx int, stiffness Float.X) { //gd:SkeletonModification2DJiggle.set_jiggle_joint_stiffness
	Advanced(self).SetJiggleJointStiffness(int64(joint_idx), float64(stiffness))
}

/*
Returns the stiffness of the Jiggle joint at [param joint_idx].
*/
func (self Instance) GetJiggleJointStiffness(joint_idx int) Float.X { //gd:SkeletonModification2DJiggle.get_jiggle_joint_stiffness
	return Float.X(Float.X(Advanced(self).GetJiggleJointStiffness(int64(joint_idx))))
}

/*
Sets the of mass of the Jiggle joint at [param joint_idx].
*/
func (self Instance) SetJiggleJointMass(joint_idx int, mass Float.X) { //gd:SkeletonModification2DJiggle.set_jiggle_joint_mass
	Advanced(self).SetJiggleJointMass(int64(joint_idx), float64(mass))
}

/*
Returns the amount of mass of the jiggle joint at [param joint_idx].
*/
func (self Instance) GetJiggleJointMass(joint_idx int) Float.X { //gd:SkeletonModification2DJiggle.get_jiggle_joint_mass
	return Float.X(Float.X(Advanced(self).GetJiggleJointMass(int64(joint_idx))))
}

/*
Sets the amount of damping of the Jiggle joint at [param joint_idx].
*/
func (self Instance) SetJiggleJointDamping(joint_idx int, damping Float.X) { //gd:SkeletonModification2DJiggle.set_jiggle_joint_damping
	Advanced(self).SetJiggleJointDamping(int64(joint_idx), float64(damping))
}

/*
Returns the amount of damping of the Jiggle joint at [param joint_idx].
*/
func (self Instance) GetJiggleJointDamping(joint_idx int) Float.X { //gd:SkeletonModification2DJiggle.get_jiggle_joint_damping
	return Float.X(Float.X(Advanced(self).GetJiggleJointDamping(int64(joint_idx))))
}

/*
Sets whether the Jiggle joint at [param joint_idx] should use gravity.
*/
func (self Instance) SetJiggleJointUseGravity(joint_idx int, use_gravity bool) { //gd:SkeletonModification2DJiggle.set_jiggle_joint_use_gravity
	Advanced(self).SetJiggleJointUseGravity(int64(joint_idx), use_gravity)
}

/*
Returns a boolean that indicates whether the joint at [param joint_idx] is using gravity or not.
*/
func (self Instance) GetJiggleJointUseGravity(joint_idx int) bool { //gd:SkeletonModification2DJiggle.get_jiggle_joint_use_gravity
	return bool(Advanced(self).GetJiggleJointUseGravity(int64(joint_idx)))
}

/*
Sets the gravity vector of the Jiggle joint at [param joint_idx].
*/
func (self Instance) SetJiggleJointGravity(joint_idx int, gravity Vector2.XY) { //gd:SkeletonModification2DJiggle.set_jiggle_joint_gravity
	Advanced(self).SetJiggleJointGravity(int64(joint_idx), Vector2.XY(gravity))
}

/*
Returns a [Vector2] representing the amount of gravity the Jiggle joint at [param joint_idx] is influenced by.
*/
func (self Instance) GetJiggleJointGravity(joint_idx int) Vector2.XY { //gd:SkeletonModification2DJiggle.get_jiggle_joint_gravity
	return Vector2.XY(Advanced(self).GetJiggleJointGravity(int64(joint_idx)))
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.SkeletonModification2DJiggle

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.SkeletonModification2DJiggle)(unsafe.Pointer(&obj))
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.SkeletonModification2DJiggle)(unsafe.Pointer(&obj))
		return true
	}
	return false
}

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {

	if !gd.Linked {
		var placeholder Instance
		*(*gd.Object)(unsafe.Pointer(&placeholder)) = pointers.Add[gd.Object]([3]uint64{})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(*(*gd.Object)(unsafe.Pointer(&placeholder)), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	object := [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})}
	casted := Instance{*(*gdclass.SkeletonModification2DJiggle)(unsafe.Pointer(&object))}
	casted.AsRefCounted()[0].InitRef()
	object[0].Notification(0, false)
	return casted
}

func (self Instance) TargetNodepath() string {
	return string(class(self).GetTargetNode().String())
}

func (self Instance) SetTargetNodepath(value string) {
	class(self).SetTargetNode(Path.ToNode(String.New(value)))
}

func (self Instance) JiggleDataChainLength() int {
	return int(int(class(self).GetJiggleDataChainLength()))
}

func (self Instance) SetJiggleDataChainLength(value int) {
	class(self).SetJiggleDataChainLength(int64(value))
}

func (self Instance) Stiffness() Float.X {
	return Float.X(Float.X(class(self).GetStiffness()))
}

func (self Instance) SetStiffness(value Float.X) {
	class(self).SetStiffness(float64(value))
}

func (self Instance) Mass() Float.X {
	return Float.X(Float.X(class(self).GetMass()))
}

func (self Instance) SetMass(value Float.X) {
	class(self).SetMass(float64(value))
}

func (self Instance) Damping() Float.X {
	return Float.X(Float.X(class(self).GetDamping()))
}

func (self Instance) SetDamping(value Float.X) {
	class(self).SetDamping(float64(value))
}

func (self Instance) UseGravity() bool {
	return bool(class(self).GetUseGravity())
}

func (self Instance) SetUseGravity(value bool) {
	class(self).SetUseGravity(value)
}

func (self Instance) Gravity() Vector2.XY {
	return Vector2.XY(class(self).GetGravity())
}

func (self Instance) SetGravity(value Vector2.XY) {
	class(self).SetGravity(Vector2.XY(value))
}

//go:nosplit
func (self class) SetTargetNode(target_nodepath Path.ToNode) { //gd:SkeletonModification2DJiggle.set_target_node
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_target_node, 0|(gdextension.SizeNodePath<<4), unsafe.Pointer(&struct{ target_nodepath gdextension.NodePath }{pointers.Get(gd.InternalNodePath(target_nodepath))}))
}

//go:nosplit
func (self class) GetTargetNode() Path.ToNode { //gd:SkeletonModification2DJiggle.get_target_node
	var r_ret = gdextension.Call[gdextension.NodePath](gd.ObjectChecked(self.AsObject()), methods.get_target_node, gdextension.SizeNodePath, unsafe.Pointer(&struct{}{}))
	var ret = Path.ToNode(String.Via(gd.NodePathProxy{}, pointers.Pack(pointers.New[gd.NodePath](r_ret))))
	return ret
}

//go:nosplit
func (self class) SetJiggleDataChainLength(length int64) { //gd:SkeletonModification2DJiggle.set_jiggle_data_chain_length
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_jiggle_data_chain_length, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ length int64 }{length}))
}

//go:nosplit
func (self class) GetJiggleDataChainLength() int64 { //gd:SkeletonModification2DJiggle.get_jiggle_data_chain_length
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_jiggle_data_chain_length, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetStiffness(stiffness float64) { //gd:SkeletonModification2DJiggle.set_stiffness
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_stiffness, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ stiffness float64 }{stiffness}))
}

//go:nosplit
func (self class) GetStiffness() float64 { //gd:SkeletonModification2DJiggle.get_stiffness
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_stiffness, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetMass(mass float64) { //gd:SkeletonModification2DJiggle.set_mass
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_mass, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ mass float64 }{mass}))
}

//go:nosplit
func (self class) GetMass() float64 { //gd:SkeletonModification2DJiggle.get_mass
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_mass, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetDamping(damping float64) { //gd:SkeletonModification2DJiggle.set_damping
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_damping, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ damping float64 }{damping}))
}

//go:nosplit
func (self class) GetDamping() float64 { //gd:SkeletonModification2DJiggle.get_damping
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_damping, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetUseGravity(use_gravity bool) { //gd:SkeletonModification2DJiggle.set_use_gravity
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_use_gravity, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ use_gravity bool }{use_gravity}))
}

//go:nosplit
func (self class) GetUseGravity() bool { //gd:SkeletonModification2DJiggle.get_use_gravity
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.get_use_gravity, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetGravity(gravity Vector2.XY) { //gd:SkeletonModification2DJiggle.set_gravity
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_gravity, 0|(gdextension.SizeVector2<<4), unsafe.Pointer(&struct{ gravity Vector2.XY }{gravity}))
}

//go:nosplit
func (self class) GetGravity() Vector2.XY { //gd:SkeletonModification2DJiggle.get_gravity
	var r_ret = gdextension.Call[Vector2.XY](gd.ObjectChecked(self.AsObject()), methods.get_gravity, gdextension.SizeVector2, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
If [code]true[/code], the Jiggle modifier will take colliders into account, keeping them from entering into these collision objects.
*/
//go:nosplit
func (self class) SetUseColliders(use_colliders bool) { //gd:SkeletonModification2DJiggle.set_use_colliders
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_use_colliders, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ use_colliders bool }{use_colliders}))
}

/*
Returns whether the jiggle modifier is taking physics colliders into account when solving.
*/
//go:nosplit
func (self class) GetUseColliders() bool { //gd:SkeletonModification2DJiggle.get_use_colliders
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.get_use_colliders, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Sets the collision mask that the Jiggle modifier will use when reacting to colliders, if the Jiggle modifier is set to take colliders into account.
*/
//go:nosplit
func (self class) SetCollisionMask(collision_mask int64) { //gd:SkeletonModification2DJiggle.set_collision_mask
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_collision_mask, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ collision_mask int64 }{collision_mask}))
}

/*
Returns the collision mask used by the Jiggle modifier when collisions are enabled.
*/
//go:nosplit
func (self class) GetCollisionMask() int64 { //gd:SkeletonModification2DJiggle.get_collision_mask
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_collision_mask, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Sets the [Bone2D] node assigned to the Jiggle joint at [param joint_idx].
*/
//go:nosplit
func (self class) SetJiggleJointBone2dNode(joint_idx int64, bone2d_node Path.ToNode) { //gd:SkeletonModification2DJiggle.set_jiggle_joint_bone2d_node
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_jiggle_joint_bone2d_node, 0|(gdextension.SizeInt<<4)|(gdextension.SizeNodePath<<8), unsafe.Pointer(&struct {
		joint_idx   int64
		bone2d_node gdextension.NodePath
	}{joint_idx, pointers.Get(gd.InternalNodePath(bone2d_node))}))
}

/*
Returns the [Bone2D] node assigned to the Jiggle joint at [param joint_idx].
*/
//go:nosplit
func (self class) GetJiggleJointBone2dNode(joint_idx int64) Path.ToNode { //gd:SkeletonModification2DJiggle.get_jiggle_joint_bone2d_node
	var r_ret = gdextension.Call[gdextension.NodePath](gd.ObjectChecked(self.AsObject()), methods.get_jiggle_joint_bone2d_node, gdextension.SizeNodePath|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ joint_idx int64 }{joint_idx}))
	var ret = Path.ToNode(String.Via(gd.NodePathProxy{}, pointers.Pack(pointers.New[gd.NodePath](r_ret))))
	return ret
}

/*
Sets the bone index, [param bone_idx], of the Jiggle joint at [param joint_idx]. When possible, this will also update the [code]bone2d_node[/code] of the Jiggle joint based on data provided by the linked skeleton.
*/
//go:nosplit
func (self class) SetJiggleJointBoneIndex(joint_idx int64, bone_idx int64) { //gd:SkeletonModification2DJiggle.set_jiggle_joint_bone_index
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_jiggle_joint_bone_index, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		joint_idx int64
		bone_idx  int64
	}{joint_idx, bone_idx}))
}

/*
Returns the index of the [Bone2D] node assigned to the Jiggle joint at [param joint_idx].
*/
//go:nosplit
func (self class) GetJiggleJointBoneIndex(joint_idx int64) int64 { //gd:SkeletonModification2DJiggle.get_jiggle_joint_bone_index
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_jiggle_joint_bone_index, gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ joint_idx int64 }{joint_idx}))
	var ret = r_ret
	return ret
}

/*
Sets whether the Jiggle joint at [param joint_idx] should override the default Jiggle joint settings. Setting this to [code]true[/code] will make the joint use its own settings rather than the default ones attached to the modification.
*/
//go:nosplit
func (self class) SetJiggleJointOverride(joint_idx int64, override bool) { //gd:SkeletonModification2DJiggle.set_jiggle_joint_override
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_jiggle_joint_override, 0|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		joint_idx int64
		override  bool
	}{joint_idx, override}))
}

/*
Returns a boolean that indicates whether the joint at [param joint_idx] is overriding the default Jiggle joint data defined in the modification.
*/
//go:nosplit
func (self class) GetJiggleJointOverride(joint_idx int64) bool { //gd:SkeletonModification2DJiggle.get_jiggle_joint_override
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.get_jiggle_joint_override, gdextension.SizeBool|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ joint_idx int64 }{joint_idx}))
	var ret = r_ret
	return ret
}

/*
Sets the of stiffness of the Jiggle joint at [param joint_idx].
*/
//go:nosplit
func (self class) SetJiggleJointStiffness(joint_idx int64, stiffness float64) { //gd:SkeletonModification2DJiggle.set_jiggle_joint_stiffness
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_jiggle_joint_stiffness, 0|(gdextension.SizeInt<<4)|(gdextension.SizeFloat<<8), unsafe.Pointer(&struct {
		joint_idx int64
		stiffness float64
	}{joint_idx, stiffness}))
}

/*
Returns the stiffness of the Jiggle joint at [param joint_idx].
*/
//go:nosplit
func (self class) GetJiggleJointStiffness(joint_idx int64) float64 { //gd:SkeletonModification2DJiggle.get_jiggle_joint_stiffness
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_jiggle_joint_stiffness, gdextension.SizeFloat|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ joint_idx int64 }{joint_idx}))
	var ret = r_ret
	return ret
}

/*
Sets the of mass of the Jiggle joint at [param joint_idx].
*/
//go:nosplit
func (self class) SetJiggleJointMass(joint_idx int64, mass float64) { //gd:SkeletonModification2DJiggle.set_jiggle_joint_mass
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_jiggle_joint_mass, 0|(gdextension.SizeInt<<4)|(gdextension.SizeFloat<<8), unsafe.Pointer(&struct {
		joint_idx int64
		mass      float64
	}{joint_idx, mass}))
}

/*
Returns the amount of mass of the jiggle joint at [param joint_idx].
*/
//go:nosplit
func (self class) GetJiggleJointMass(joint_idx int64) float64 { //gd:SkeletonModification2DJiggle.get_jiggle_joint_mass
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_jiggle_joint_mass, gdextension.SizeFloat|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ joint_idx int64 }{joint_idx}))
	var ret = r_ret
	return ret
}

/*
Sets the amount of damping of the Jiggle joint at [param joint_idx].
*/
//go:nosplit
func (self class) SetJiggleJointDamping(joint_idx int64, damping float64) { //gd:SkeletonModification2DJiggle.set_jiggle_joint_damping
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_jiggle_joint_damping, 0|(gdextension.SizeInt<<4)|(gdextension.SizeFloat<<8), unsafe.Pointer(&struct {
		joint_idx int64
		damping   float64
	}{joint_idx, damping}))
}

/*
Returns the amount of damping of the Jiggle joint at [param joint_idx].
*/
//go:nosplit
func (self class) GetJiggleJointDamping(joint_idx int64) float64 { //gd:SkeletonModification2DJiggle.get_jiggle_joint_damping
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_jiggle_joint_damping, gdextension.SizeFloat|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ joint_idx int64 }{joint_idx}))
	var ret = r_ret
	return ret
}

/*
Sets whether the Jiggle joint at [param joint_idx] should use gravity.
*/
//go:nosplit
func (self class) SetJiggleJointUseGravity(joint_idx int64, use_gravity bool) { //gd:SkeletonModification2DJiggle.set_jiggle_joint_use_gravity
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_jiggle_joint_use_gravity, 0|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		joint_idx   int64
		use_gravity bool
	}{joint_idx, use_gravity}))
}

/*
Returns a boolean that indicates whether the joint at [param joint_idx] is using gravity or not.
*/
//go:nosplit
func (self class) GetJiggleJointUseGravity(joint_idx int64) bool { //gd:SkeletonModification2DJiggle.get_jiggle_joint_use_gravity
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.get_jiggle_joint_use_gravity, gdextension.SizeBool|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ joint_idx int64 }{joint_idx}))
	var ret = r_ret
	return ret
}

/*
Sets the gravity vector of the Jiggle joint at [param joint_idx].
*/
//go:nosplit
func (self class) SetJiggleJointGravity(joint_idx int64, gravity Vector2.XY) { //gd:SkeletonModification2DJiggle.set_jiggle_joint_gravity
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_jiggle_joint_gravity, 0|(gdextension.SizeInt<<4)|(gdextension.SizeVector2<<8), unsafe.Pointer(&struct {
		joint_idx int64
		gravity   Vector2.XY
	}{joint_idx, gravity}))
}

/*
Returns a [Vector2] representing the amount of gravity the Jiggle joint at [param joint_idx] is influenced by.
*/
//go:nosplit
func (self class) GetJiggleJointGravity(joint_idx int64) Vector2.XY { //gd:SkeletonModification2DJiggle.get_jiggle_joint_gravity
	var r_ret = gdextension.Call[Vector2.XY](gd.ObjectChecked(self.AsObject()), methods.get_jiggle_joint_gravity, gdextension.SizeVector2|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ joint_idx int64 }{joint_idx}))
	var ret = r_ret
	return ret
}
func (self class) AsSkeletonModification2DJiggle() Advanced {
	return *((*Advanced)(unsafe.Pointer(&self)))
}
func (self Instance) AsSkeletonModification2DJiggle() Instance {
	return *((*Instance)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsSkeletonModification2DJiggle() Instance {
	return self.Super().AsSkeletonModification2DJiggle()
}
func (self class) AsSkeletonModification2D() SkeletonModification2D.Advanced {
	return *((*SkeletonModification2D.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsSkeletonModification2D() SkeletonModification2D.Instance {
	return self.Super().AsSkeletonModification2D()
}
func (self Instance) AsSkeletonModification2D() SkeletonModification2D.Instance {
	return *((*SkeletonModification2D.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsResource() Resource.Advanced {
	return *((*Resource.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsResource() Resource.Instance { return self.Super().AsResource() }
func (self Instance) AsResource() Resource.Instance {
	return *((*Resource.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsRefCounted() [1]gd.RefCounted { return self.Super().AsRefCounted() }
func (self Instance) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(SkeletonModification2D.Advanced(self.AsSkeletonModification2D()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(SkeletonModification2D.Instance(self.AsSkeletonModification2D()), name)
	}
}
func init() {
	gdclass.Register("SkeletonModification2DJiggle", func(ptr gd.Object) any { return *(*Instance)(unsafe.Pointer(&ptr)) })
}
