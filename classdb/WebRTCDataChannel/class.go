// Code generated by the generate package DO NOT EDIT

// Package WebRTCDataChannel provides methods for working with WebRTCDataChannel object instances.
package WebRTCDataChannel

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/variant/Signal"
import "graphics.gd/classdb/PacketPeer"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Signal.Any
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }
type Instance [1]gdclass.WebRTCDataChannel

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	poll                     gdextension.MethodForClass `hash:"166280745"`
	close                    gdextension.MethodForClass `hash:"3218959716"`
	was_string_packet        gdextension.MethodForClass `hash:"36873697"`
	set_write_mode           gdextension.MethodForClass `hash:"1999768052"`
	get_write_mode           gdextension.MethodForClass `hash:"2848495172"`
	get_ready_state          gdextension.MethodForClass `hash:"3501143017"`
	get_label                gdextension.MethodForClass `hash:"201670096"`
	is_ordered               gdextension.MethodForClass `hash:"36873697"`
	get_id                   gdextension.MethodForClass `hash:"3905245786"`
	get_max_packet_life_time gdextension.MethodForClass `hash:"3905245786"`
	get_max_retransmits      gdextension.MethodForClass `hash:"3905245786"`
	get_protocol             gdextension.MethodForClass `hash:"201670096"`
	is_negotiated            gdextension.MethodForClass `hash:"36873697"`
	get_buffered_amount      gdextension.MethodForClass `hash:"3905245786"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("WebRTCDataChannel")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		gdextension.Free(gdextension.TypeStringName, &sname)
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsWebRTCDataChannel() Instance
}

/*
Reserved, but not used for now.
*/
func (self Instance) Poll() error { //gd:WebRTCDataChannel.poll
	return error(gd.ToError(Advanced(self).Poll()))
}

/*
Closes this data channel, notifying the other peer.
*/
func (self Instance) Close() { //gd:WebRTCDataChannel.close
	Advanced(self).Close()
}

/*
Returns [code]true[/code] if the last received packet was transferred as text. See [member write_mode].
*/
func (self Instance) WasStringPacket() bool { //gd:WebRTCDataChannel.was_string_packet
	return bool(Advanced(self).WasStringPacket())
}

/*
Returns the current state of this channel, see [enum ChannelState].
*/
func (self Instance) GetReadyState() ChannelState { //gd:WebRTCDataChannel.get_ready_state
	return ChannelState(Advanced(self).GetReadyState())
}

/*
Returns the label assigned to this channel during creation.
*/
func (self Instance) GetLabel() string { //gd:WebRTCDataChannel.get_label
	return string(Advanced(self).GetLabel().String())
}

/*
Returns [code]true[/code] if this channel was created with ordering enabled (default).
*/
func (self Instance) IsOrdered() bool { //gd:WebRTCDataChannel.is_ordered
	return bool(Advanced(self).IsOrdered())
}

/*
Returns the ID assigned to this channel during creation (or auto-assigned during negotiation).
If the channel is not negotiated out-of-band the ID will only be available after the connection is established (will return [code]65535[/code] until then).
*/
func (self Instance) GetId() int { //gd:WebRTCDataChannel.get_id
	return int(int(Advanced(self).GetId()))
}

/*
Returns the [code]maxPacketLifeTime[/code] value assigned to this channel during creation.
Will be [code]65535[/code] if not specified.
*/
func (self Instance) GetMaxPacketLifeTime() int { //gd:WebRTCDataChannel.get_max_packet_life_time
	return int(int(Advanced(self).GetMaxPacketLifeTime()))
}

/*
Returns the [code]maxRetransmits[/code] value assigned to this channel during creation.
Will be [code]65535[/code] if not specified.
*/
func (self Instance) GetMaxRetransmits() int { //gd:WebRTCDataChannel.get_max_retransmits
	return int(int(Advanced(self).GetMaxRetransmits()))
}

/*
Returns the sub-protocol assigned to this channel during creation. An empty string if not specified.
*/
func (self Instance) GetProtocol() string { //gd:WebRTCDataChannel.get_protocol
	return string(Advanced(self).GetProtocol().String())
}

/*
Returns [code]true[/code] if this channel was created with out-of-band configuration.
*/
func (self Instance) IsNegotiated() bool { //gd:WebRTCDataChannel.is_negotiated
	return bool(Advanced(self).IsNegotiated())
}

/*
Returns the number of bytes currently queued to be sent over this channel.
*/
func (self Instance) GetBufferedAmount() int { //gd:WebRTCDataChannel.get_buffered_amount
	return int(int(Advanced(self).GetBufferedAmount()))
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.WebRTCDataChannel

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.WebRTCDataChannel)(unsafe.Pointer(&obj))
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.WebRTCDataChannel)(unsafe.Pointer(&obj))
		return true
	}
	return false
}

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {

	if !gd.Linked {
		var placeholder Instance
		*(*gd.Object)(unsafe.Pointer(&placeholder)) = pointers.Add[gd.Object]([3]uint64{})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(*(*gd.Object)(unsafe.Pointer(&placeholder)), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	object := [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})}
	casted := Instance{*(*gdclass.WebRTCDataChannel)(unsafe.Pointer(&object))}
	casted.AsRefCounted()[0].InitRef()
	object[0].Notification(0, false)
	return casted
}

func (self Instance) WriteMode() WriteMode {
	return WriteMode(class(self).GetWriteMode())
}

func (self Instance) SetWriteMode(value WriteMode) {
	class(self).SetWriteMode(value)
}

/*
Reserved, but not used for now.
*/
//go:nosplit
func (self class) Poll() Error.Code { //gd:WebRTCDataChannel.poll
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.poll, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = Error.Code(r_ret)
	return ret
}

/*
Closes this data channel, notifying the other peer.
*/
//go:nosplit
func (self class) Close() { //gd:WebRTCDataChannel.close
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.close, 0, unsafe.Pointer(&struct{}{}))
}

/*
Returns [code]true[/code] if the last received packet was transferred as text. See [member write_mode].
*/
//go:nosplit
func (self class) WasStringPacket() bool { //gd:WebRTCDataChannel.was_string_packet
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.was_string_packet, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetWriteMode(write_mode WriteMode) { //gd:WebRTCDataChannel.set_write_mode
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_write_mode, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ write_mode WriteMode }{write_mode}))
}

//go:nosplit
func (self class) GetWriteMode() WriteMode { //gd:WebRTCDataChannel.get_write_mode
	var r_ret = gdextension.Call[WriteMode](gd.ObjectChecked(self.AsObject()), methods.get_write_mode, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the current state of this channel, see [enum ChannelState].
*/
//go:nosplit
func (self class) GetReadyState() ChannelState { //gd:WebRTCDataChannel.get_ready_state
	var r_ret = gdextension.Call[ChannelState](gd.ObjectChecked(self.AsObject()), methods.get_ready_state, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the label assigned to this channel during creation.
*/
//go:nosplit
func (self class) GetLabel() String.Readable { //gd:WebRTCDataChannel.get_label
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_label, gdextension.SizeString, unsafe.Pointer(&struct{}{}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Returns [code]true[/code] if this channel was created with ordering enabled (default).
*/
//go:nosplit
func (self class) IsOrdered() bool { //gd:WebRTCDataChannel.is_ordered
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_ordered, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the ID assigned to this channel during creation (or auto-assigned during negotiation).
If the channel is not negotiated out-of-band the ID will only be available after the connection is established (will return [code]65535[/code] until then).
*/
//go:nosplit
func (self class) GetId() int64 { //gd:WebRTCDataChannel.get_id
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_id, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the [code]maxPacketLifeTime[/code] value assigned to this channel during creation.
Will be [code]65535[/code] if not specified.
*/
//go:nosplit
func (self class) GetMaxPacketLifeTime() int64 { //gd:WebRTCDataChannel.get_max_packet_life_time
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_max_packet_life_time, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the [code]maxRetransmits[/code] value assigned to this channel during creation.
Will be [code]65535[/code] if not specified.
*/
//go:nosplit
func (self class) GetMaxRetransmits() int64 { //gd:WebRTCDataChannel.get_max_retransmits
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_max_retransmits, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the sub-protocol assigned to this channel during creation. An empty string if not specified.
*/
//go:nosplit
func (self class) GetProtocol() String.Readable { //gd:WebRTCDataChannel.get_protocol
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_protocol, gdextension.SizeString, unsafe.Pointer(&struct{}{}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Returns [code]true[/code] if this channel was created with out-of-band configuration.
*/
//go:nosplit
func (self class) IsNegotiated() bool { //gd:WebRTCDataChannel.is_negotiated
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_negotiated, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the number of bytes currently queued to be sent over this channel.
*/
//go:nosplit
func (self class) GetBufferedAmount() int64 { //gd:WebRTCDataChannel.get_buffered_amount
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_buffered_amount, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}
func (self class) AsWebRTCDataChannel() Advanced         { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsWebRTCDataChannel() Instance      { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsWebRTCDataChannel() Instance { return self.Super().AsWebRTCDataChannel() }
func (self class) AsPacketPeer() PacketPeer.Advanced {
	return *((*PacketPeer.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsPacketPeer() PacketPeer.Instance { return self.Super().AsPacketPeer() }
func (self Instance) AsPacketPeer() PacketPeer.Instance {
	return *((*PacketPeer.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsRefCounted() [1]gd.RefCounted { return self.Super().AsRefCounted() }
func (self Instance) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(PacketPeer.Advanced(self.AsPacketPeer()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(PacketPeer.Instance(self.AsPacketPeer()), name)
	}
}
func init() {
	gdclass.Register("WebRTCDataChannel", func(ptr gd.Object) any { return *(*Instance)(unsafe.Pointer(&ptr)) })
}

type WriteMode int //gd:WebRTCDataChannel.WriteMode

const (
	/*Tells the channel to send data over this channel as text. An external peer (non-Godot) would receive this as a string.*/
	WriteModeText WriteMode = 0
	/*Tells the channel to send data over this channel as binary. An external peer (non-Godot) would receive this as array buffer or blob.*/
	WriteModeBinary WriteMode = 1
)

type ChannelState int //gd:WebRTCDataChannel.ChannelState

const (
	/*The channel was created, but it's still trying to connect.*/
	StateConnecting ChannelState = 0
	/*The channel is currently open, and data can flow over it.*/
	StateOpen ChannelState = 1
	/*The channel is being closed, no new messages will be accepted, but those already in queue will be flushed.*/
	StateClosing ChannelState = 2
	/*The channel was closed, or connection failed.*/
	StateClosed ChannelState = 3
)
