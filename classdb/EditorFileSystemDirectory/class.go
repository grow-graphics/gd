// Code generated by the generate package DO NOT EDIT

// Package EditorFileSystemDirectory provides methods for working with EditorFileSystemDirectory object instances.
package EditorFileSystemDirectory

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
A more generalized, low-level variation of the directory concept.
*/
type Instance [1]gdclass.EditorFileSystemDirectory

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	get_subdir_count              gdextension.MethodForClass `hash:"3905245786"`
	get_subdir                    gdextension.MethodForClass `hash:"2330964164"`
	get_file_count                gdextension.MethodForClass `hash:"3905245786"`
	get_file                      gdextension.MethodForClass `hash:"844755477"`
	get_file_path                 gdextension.MethodForClass `hash:"844755477"`
	get_file_type                 gdextension.MethodForClass `hash:"659327637"`
	get_file_script_class_name    gdextension.MethodForClass `hash:"844755477"`
	get_file_script_class_extends gdextension.MethodForClass `hash:"844755477"`
	get_file_import_is_valid      gdextension.MethodForClass `hash:"1116898809"`
	get_name                      gdextension.MethodForClass `hash:"2841200299"`
	get_path                      gdextension.MethodForClass `hash:"201670096"`
	get_parent                    gdextension.MethodForClass `hash:"842323275"`
	find_file_index               gdextension.MethodForClass `hash:"1321353865"`
	find_dir_index                gdextension.MethodForClass `hash:"1321353865"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("EditorFileSystemDirectory")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, true)
	})
	gd.RegisterCleanup(func() {
		pointers.Raw[gd.StringName](sname).Free()
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsEditorFileSystemDirectory() Instance
}

/*
Returns the number of subdirectories in this directory.
*/
func (self Instance) GetSubdirCount() int { //gd:EditorFileSystemDirectory.get_subdir_count
	return int(int(Advanced(self).GetSubdirCount()))
}

/*
Returns the subdirectory at index [param idx].
*/
func (self Instance) GetSubdir(idx int) Instance { //gd:EditorFileSystemDirectory.get_subdir
	return Instance(Advanced(self).GetSubdir(int64(idx)))
}

/*
Returns the number of files in this directory.
*/
func (self Instance) GetFileCount() int { //gd:EditorFileSystemDirectory.get_file_count
	return int(int(Advanced(self).GetFileCount()))
}

/*
Returns the name of the file at index [param idx].
*/
func (self Instance) GetFile(idx int) string { //gd:EditorFileSystemDirectory.get_file
	return string(Advanced(self).GetFile(int64(idx)).String())
}

/*
Returns the path to the file at index [param idx].
*/
func (self Instance) GetFilePath(idx int) string { //gd:EditorFileSystemDirectory.get_file_path
	return string(Advanced(self).GetFilePath(int64(idx)).String())
}

/*
Returns the resource type of the file at index [param idx]. This returns a string such as [code]"Resource"[/code] or [code]"GDScript"[/code], [i]not[/i] a file extension such as [code]".gd"[/code].
*/
func (self Instance) GetFileType(idx int) string { //gd:EditorFileSystemDirectory.get_file_type
	return string(Advanced(self).GetFileType(int64(idx)).String())
}

/*
Returns the name of the script class defined in the file at index [param idx]. If the file doesn't define a script class using the [code]class_name[/code] syntax, this will return an empty string.
*/
func (self Instance) GetFileScriptClassName(idx int) string { //gd:EditorFileSystemDirectory.get_file_script_class_name
	return string(Advanced(self).GetFileScriptClassName(int64(idx)).String())
}

/*
Returns the base class of the script class defined in the file at index [param idx]. If the file doesn't define a script class using the [code]class_name[/code] syntax, this will return an empty string.
*/
func (self Instance) GetFileScriptClassExtends(idx int) string { //gd:EditorFileSystemDirectory.get_file_script_class_extends
	return string(Advanced(self).GetFileScriptClassExtends(int64(idx)).String())
}

/*
Returns [code]true[/code] if the file at index [param idx] imported properly.
*/
func (self Instance) GetFileImportIsValid(idx int) bool { //gd:EditorFileSystemDirectory.get_file_import_is_valid
	return bool(Advanced(self).GetFileImportIsValid(int64(idx)))
}

/*
Returns the name of this directory.
*/
func (self Instance) GetName() string { //gd:EditorFileSystemDirectory.get_name
	return string(Advanced(self).GetName().String())
}

/*
Returns the path to this directory.
*/
func (self Instance) GetPath() string { //gd:EditorFileSystemDirectory.get_path
	return string(Advanced(self).GetPath().String())
}

/*
Returns the parent directory for this directory or [code]null[/code] if called on a directory at [code]res://[/code] or [code]user://[/code].
*/
func (self Instance) GetParent() Instance { //gd:EditorFileSystemDirectory.get_parent
	return Instance(Advanced(self).GetParent())
}

/*
Returns the index of the file with name [param name] or [code]-1[/code] if not found.
*/
func (self Instance) FindFileIndex(name string) int { //gd:EditorFileSystemDirectory.find_file_index
	return int(int(Advanced(self).FindFileIndex(String.New(name))))
}

/*
Returns the index of the directory with name [param name] or [code]-1[/code] if not found.
*/
func (self Instance) FindDirIndex(name string) int { //gd:EditorFileSystemDirectory.find_dir_index
	return int(int(Advanced(self).FindDirIndex(String.New(name))))
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.EditorFileSystemDirectory

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.EditorFileSystemDirectory)(unsafe.Pointer(&obj))
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.EditorFileSystemDirectory)(unsafe.Pointer(&obj))
		return true
	}
	return false
}

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {

	if !gd.Linked {
		var placeholder Instance
		*(*gd.Object)(unsafe.Pointer(&placeholder)) = pointers.Add[gd.Object]([3]uint64{})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(*(*gd.Object)(unsafe.Pointer(&placeholder)), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	object := [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})}
	casted := Instance{*(*gdclass.EditorFileSystemDirectory)(unsafe.Pointer(&object))}
	object[0].Notification(0, false)
	return casted
}

/*
Returns the number of subdirectories in this directory.
*/
//go:nosplit
func (self class) GetSubdirCount() int64 { //gd:EditorFileSystemDirectory.get_subdir_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_subdir_count, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the subdirectory at index [param idx].
*/
//go:nosplit
func (self class) GetSubdir(idx int64) [1]gdclass.EditorFileSystemDirectory { //gd:EditorFileSystemDirectory.get_subdir
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_subdir, gdextension.SizeObject|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ idx int64 }{idx}))
	var ret = [1]gdclass.EditorFileSystemDirectory{gd.PointerMustAssertInstanceID[gdclass.EditorFileSystemDirectory](r_ret)}
	return ret
}

/*
Returns the number of files in this directory.
*/
//go:nosplit
func (self class) GetFileCount() int64 { //gd:EditorFileSystemDirectory.get_file_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_file_count, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the name of the file at index [param idx].
*/
//go:nosplit
func (self class) GetFile(idx int64) String.Readable { //gd:EditorFileSystemDirectory.get_file
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_file, gdextension.SizeString|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ idx int64 }{idx}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Returns the path to the file at index [param idx].
*/
//go:nosplit
func (self class) GetFilePath(idx int64) String.Readable { //gd:EditorFileSystemDirectory.get_file_path
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_file_path, gdextension.SizeString|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ idx int64 }{idx}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Returns the resource type of the file at index [param idx]. This returns a string such as [code]"Resource"[/code] or [code]"GDScript"[/code], [i]not[/i] a file extension such as [code]".gd"[/code].
*/
//go:nosplit
func (self class) GetFileType(idx int64) String.Name { //gd:EditorFileSystemDirectory.get_file_type
	var r_ret = gdextension.Call[gdextension.StringName](gd.ObjectChecked(self.AsObject()), methods.get_file_type, gdextension.SizeStringName|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ idx int64 }{idx}))
	var ret = String.Name(String.Via(gd.StringNameProxy{}, pointers.Pack(pointers.New[gd.StringName](r_ret))))
	return ret
}

/*
Returns the name of the script class defined in the file at index [param idx]. If the file doesn't define a script class using the [code]class_name[/code] syntax, this will return an empty string.
*/
//go:nosplit
func (self class) GetFileScriptClassName(idx int64) String.Readable { //gd:EditorFileSystemDirectory.get_file_script_class_name
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_file_script_class_name, gdextension.SizeString|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ idx int64 }{idx}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Returns the base class of the script class defined in the file at index [param idx]. If the file doesn't define a script class using the [code]class_name[/code] syntax, this will return an empty string.
*/
//go:nosplit
func (self class) GetFileScriptClassExtends(idx int64) String.Readable { //gd:EditorFileSystemDirectory.get_file_script_class_extends
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_file_script_class_extends, gdextension.SizeString|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ idx int64 }{idx}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Returns [code]true[/code] if the file at index [param idx] imported properly.
*/
//go:nosplit
func (self class) GetFileImportIsValid(idx int64) bool { //gd:EditorFileSystemDirectory.get_file_import_is_valid
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.get_file_import_is_valid, gdextension.SizeBool|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ idx int64 }{idx}))
	var ret = r_ret
	return ret
}

/*
Returns the name of this directory.
*/
//go:nosplit
func (self class) GetName() String.Readable { //gd:EditorFileSystemDirectory.get_name
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_name, gdextension.SizeString, unsafe.Pointer(&struct{}{}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Returns the path to this directory.
*/
//go:nosplit
func (self class) GetPath() String.Readable { //gd:EditorFileSystemDirectory.get_path
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_path, gdextension.SizeString, unsafe.Pointer(&struct{}{}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Returns the parent directory for this directory or [code]null[/code] if called on a directory at [code]res://[/code] or [code]user://[/code].
*/
//go:nosplit
func (self class) GetParent() [1]gdclass.EditorFileSystemDirectory { //gd:EditorFileSystemDirectory.get_parent
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_parent, gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.EditorFileSystemDirectory{gd.PointerMustAssertInstanceID[gdclass.EditorFileSystemDirectory](r_ret)}
	return ret
}

/*
Returns the index of the file with name [param name] or [code]-1[/code] if not found.
*/
//go:nosplit
func (self class) FindFileIndex(name String.Readable) int64 { //gd:EditorFileSystemDirectory.find_file_index
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.find_file_index, gdextension.SizeInt|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ name gdextension.String }{pointers.Get(gd.InternalString(name))}))
	var ret = r_ret
	return ret
}

/*
Returns the index of the directory with name [param name] or [code]-1[/code] if not found.
*/
//go:nosplit
func (self class) FindDirIndex(name String.Readable) int64 { //gd:EditorFileSystemDirectory.find_dir_index
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.find_dir_index, gdextension.SizeInt|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ name gdextension.String }{pointers.Get(gd.InternalString(name))}))
	var ret = r_ret
	return ret
}
func (self class) AsEditorFileSystemDirectory() Advanced {
	return *((*Advanced)(unsafe.Pointer(&self)))
}
func (self Instance) AsEditorFileSystemDirectory() Instance {
	return *((*Instance)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsEditorFileSystemDirectory() Instance {
	return self.Super().AsEditorFileSystemDirectory()
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Object.Advanced(self.AsObject()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Object.Instance(self.AsObject()), name)
	}
}
func init() {
	gdclass.Register("EditorFileSystemDirectory", func(ptr gd.Object) any { return *(*Instance)(unsafe.Pointer(&ptr)) })
}
