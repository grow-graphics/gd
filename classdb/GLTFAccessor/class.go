// Code generated by the generate package DO NOT EDIT

// Package GLTFAccessor provides methods for working with GLTFAccessor object instances.
package GLTFAccessor

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/Resource"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
GLTFAccessor is a data structure representing a glTF [code]accessor[/code] that would be found in the [code]"accessors"[/code] array. A buffer is a blob of binary data. A buffer view is a slice of a buffer. An accessor is a typed interpretation of the data in a buffer view.
Most custom data stored in glTF does not need accessors, only buffer views (see [GLTFBufferView]). Accessors are for more advanced use cases such as interleaved mesh data encoded for the GPU.
*/
type Instance [1]gdclass.GLTFAccessor

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	get_buffer_view                   gdextension.MethodForClass `hash:"2455072627"`
	set_buffer_view                   gdextension.MethodForClass `hash:"1286410249"`
	get_byte_offset                   gdextension.MethodForClass `hash:"2455072627"`
	set_byte_offset                   gdextension.MethodForClass `hash:"1286410249"`
	get_component_type                gdextension.MethodForClass `hash:"2455072627"`
	set_component_type                gdextension.MethodForClass `hash:"1286410249"`
	get_normalized                    gdextension.MethodForClass `hash:"2240911060"`
	set_normalized                    gdextension.MethodForClass `hash:"2586408642"`
	get_count                         gdextension.MethodForClass `hash:"2455072627"`
	set_count                         gdextension.MethodForClass `hash:"1286410249"`
	get_accessor_type                 gdextension.MethodForClass `hash:"679305214"`
	set_accessor_type                 gdextension.MethodForClass `hash:"2347728198"`
	get_type                          gdextension.MethodForClass `hash:"2455072627"`
	set_type                          gdextension.MethodForClass `hash:"1286410249"`
	get_min                           gdextension.MethodForClass `hash:"148677866"`
	set_min                           gdextension.MethodForClass `hash:"2576592201"`
	get_max                           gdextension.MethodForClass `hash:"148677866"`
	set_max                           gdextension.MethodForClass `hash:"2576592201"`
	get_sparse_count                  gdextension.MethodForClass `hash:"2455072627"`
	set_sparse_count                  gdextension.MethodForClass `hash:"1286410249"`
	get_sparse_indices_buffer_view    gdextension.MethodForClass `hash:"2455072627"`
	set_sparse_indices_buffer_view    gdextension.MethodForClass `hash:"1286410249"`
	get_sparse_indices_byte_offset    gdextension.MethodForClass `hash:"2455072627"`
	set_sparse_indices_byte_offset    gdextension.MethodForClass `hash:"1286410249"`
	get_sparse_indices_component_type gdextension.MethodForClass `hash:"2455072627"`
	set_sparse_indices_component_type gdextension.MethodForClass `hash:"1286410249"`
	get_sparse_values_buffer_view     gdextension.MethodForClass `hash:"2455072627"`
	set_sparse_values_buffer_view     gdextension.MethodForClass `hash:"1286410249"`
	get_sparse_values_byte_offset     gdextension.MethodForClass `hash:"2455072627"`
	set_sparse_values_byte_offset     gdextension.MethodForClass `hash:"1286410249"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("GLTFAccessor")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		pointers.Raw[gd.StringName](sname).Free()
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsGLTFAccessor() Instance
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.GLTFAccessor

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.GLTFAccessor)(unsafe.Pointer(&obj))
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.GLTFAccessor)(unsafe.Pointer(&obj))
		return true
	}
	return false
}

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {
	object := [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})}
	casted := Instance{*(*gdclass.GLTFAccessor)(unsafe.Pointer(&object))}
	casted.AsRefCounted()[0].Reference()
	object[0].Notification(0, false)
	return casted
}

func (self Instance) BufferView() int {
	return int(int(class(self).GetBufferView()))
}

func (self Instance) SetBufferView(value int) {
	class(self).SetBufferView(int64(value))
}

func (self Instance) ByteOffset() int {
	return int(int(class(self).GetByteOffset()))
}

func (self Instance) SetByteOffset(value int) {
	class(self).SetByteOffset(int64(value))
}

func (self Instance) ComponentType() int {
	return int(int(class(self).GetComponentType()))
}

func (self Instance) SetComponentType(value int) {
	class(self).SetComponentType(int64(value))
}

func (self Instance) Normalized() bool {
	return bool(class(self).GetNormalized())
}

func (self Instance) SetNormalized(value bool) {
	class(self).SetNormalized(value)
}

func (self Instance) Count() int {
	return int(int(class(self).GetCount()))
}

func (self Instance) SetCount(value int) {
	class(self).SetCount(int64(value))
}

func (self Instance) AccessorType() GLTFAccessorType {
	return GLTFAccessorType(class(self).GetAccessorType())
}

func (self Instance) SetAccessorType(value GLTFAccessorType) {
	class(self).SetAccessorType(value)
}

func (self Instance) Type() int {
	return int(int(class(self).GetType()))
}

func (self Instance) SetType(value int) {
	class(self).SetType(int64(value))
}

func (self Instance) Min() []float64 {
	return []float64(slices.Collect(class(self).GetMin().Values()))
}

func (self Instance) SetMin(value []float64) {
	class(self).SetMin(Packed.New(value...))
}

func (self Instance) Max() []float64 {
	return []float64(slices.Collect(class(self).GetMax().Values()))
}

func (self Instance) SetMax(value []float64) {
	class(self).SetMax(Packed.New(value...))
}

func (self Instance) SparseCount() int {
	return int(int(class(self).GetSparseCount()))
}

func (self Instance) SetSparseCount(value int) {
	class(self).SetSparseCount(int64(value))
}

func (self Instance) SparseIndicesBufferView() int {
	return int(int(class(self).GetSparseIndicesBufferView()))
}

func (self Instance) SetSparseIndicesBufferView(value int) {
	class(self).SetSparseIndicesBufferView(int64(value))
}

func (self Instance) SparseIndicesByteOffset() int {
	return int(int(class(self).GetSparseIndicesByteOffset()))
}

func (self Instance) SetSparseIndicesByteOffset(value int) {
	class(self).SetSparseIndicesByteOffset(int64(value))
}

func (self Instance) SparseIndicesComponentType() int {
	return int(int(class(self).GetSparseIndicesComponentType()))
}

func (self Instance) SetSparseIndicesComponentType(value int) {
	class(self).SetSparseIndicesComponentType(int64(value))
}

func (self Instance) SparseValuesBufferView() int {
	return int(int(class(self).GetSparseValuesBufferView()))
}

func (self Instance) SetSparseValuesBufferView(value int) {
	class(self).SetSparseValuesBufferView(int64(value))
}

func (self Instance) SparseValuesByteOffset() int {
	return int(int(class(self).GetSparseValuesByteOffset()))
}

func (self Instance) SetSparseValuesByteOffset(value int) {
	class(self).SetSparseValuesByteOffset(int64(value))
}

//go:nosplit
func (self class) GetBufferView() int64 { //gd:GLTFAccessor.get_buffer_view
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_buffer_view, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetBufferView(buffer_view int64) { //gd:GLTFAccessor.set_buffer_view
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_buffer_view, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ buffer_view int64 }{buffer_view}))
}

//go:nosplit
func (self class) GetByteOffset() int64 { //gd:GLTFAccessor.get_byte_offset
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_byte_offset, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetByteOffset(byte_offset int64) { //gd:GLTFAccessor.set_byte_offset
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_byte_offset, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ byte_offset int64 }{byte_offset}))
}

//go:nosplit
func (self class) GetComponentType() int64 { //gd:GLTFAccessor.get_component_type
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_component_type, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetComponentType(component_type int64) { //gd:GLTFAccessor.set_component_type
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_component_type, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ component_type int64 }{component_type}))
}

//go:nosplit
func (self class) GetNormalized() bool { //gd:GLTFAccessor.get_normalized
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.get_normalized, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetNormalized(normalized bool) { //gd:GLTFAccessor.set_normalized
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_normalized, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ normalized bool }{normalized}))
}

//go:nosplit
func (self class) GetCount() int64 { //gd:GLTFAccessor.get_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_count, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetCount(count int64) { //gd:GLTFAccessor.set_count
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_count, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ count int64 }{count}))
}

//go:nosplit
func (self class) GetAccessorType() GLTFAccessorType { //gd:GLTFAccessor.get_accessor_type
	var r_ret = gdextension.Call[GLTFAccessorType](gd.ObjectChecked(self.AsObject()), methods.get_accessor_type, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetAccessorType(accessor_type GLTFAccessorType) { //gd:GLTFAccessor.set_accessor_type
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_accessor_type, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ accessor_type GLTFAccessorType }{accessor_type}))
}

//go:nosplit
func (self class) GetType() int64 { //gd:GLTFAccessor.get_type
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_type, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetType(atype int64) { //gd:GLTFAccessor.set_type
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_type, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ atype int64 }{atype}))
}

//go:nosplit
func (self class) GetMin() Packed.Array[float64] { //gd:GLTFAccessor.get_min
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.get_min, gdextension.SizePackedArray, unsafe.Pointer(&struct{}{}))
	var ret = Packed.Array[float64](Array.Through(gd.PackedProxy[gd.PackedFloat64Array, float64]{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

//go:nosplit
func (self class) SetMin(min Packed.Array[float64]) { //gd:GLTFAccessor.set_min
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_min, 0|(gdextension.SizePackedArray<<4), unsafe.Pointer(&struct {
		min gdextension.PackedArray[float64]
	}{pointers.Get(gd.InternalPacked[gd.PackedFloat64Array, float64](min))}))
}

//go:nosplit
func (self class) GetMax() Packed.Array[float64] { //gd:GLTFAccessor.get_max
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.get_max, gdextension.SizePackedArray, unsafe.Pointer(&struct{}{}))
	var ret = Packed.Array[float64](Array.Through(gd.PackedProxy[gd.PackedFloat64Array, float64]{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

//go:nosplit
func (self class) SetMax(max Packed.Array[float64]) { //gd:GLTFAccessor.set_max
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_max, 0|(gdextension.SizePackedArray<<4), unsafe.Pointer(&struct {
		max gdextension.PackedArray[float64]
	}{pointers.Get(gd.InternalPacked[gd.PackedFloat64Array, float64](max))}))
}

//go:nosplit
func (self class) GetSparseCount() int64 { //gd:GLTFAccessor.get_sparse_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_sparse_count, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetSparseCount(sparse_count int64) { //gd:GLTFAccessor.set_sparse_count
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_sparse_count, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ sparse_count int64 }{sparse_count}))
}

//go:nosplit
func (self class) GetSparseIndicesBufferView() int64 { //gd:GLTFAccessor.get_sparse_indices_buffer_view
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_sparse_indices_buffer_view, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetSparseIndicesBufferView(sparse_indices_buffer_view int64) { //gd:GLTFAccessor.set_sparse_indices_buffer_view
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_sparse_indices_buffer_view, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ sparse_indices_buffer_view int64 }{sparse_indices_buffer_view}))
}

//go:nosplit
func (self class) GetSparseIndicesByteOffset() int64 { //gd:GLTFAccessor.get_sparse_indices_byte_offset
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_sparse_indices_byte_offset, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetSparseIndicesByteOffset(sparse_indices_byte_offset int64) { //gd:GLTFAccessor.set_sparse_indices_byte_offset
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_sparse_indices_byte_offset, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ sparse_indices_byte_offset int64 }{sparse_indices_byte_offset}))
}

//go:nosplit
func (self class) GetSparseIndicesComponentType() int64 { //gd:GLTFAccessor.get_sparse_indices_component_type
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_sparse_indices_component_type, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetSparseIndicesComponentType(sparse_indices_component_type int64) { //gd:GLTFAccessor.set_sparse_indices_component_type
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_sparse_indices_component_type, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ sparse_indices_component_type int64 }{sparse_indices_component_type}))
}

//go:nosplit
func (self class) GetSparseValuesBufferView() int64 { //gd:GLTFAccessor.get_sparse_values_buffer_view
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_sparse_values_buffer_view, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetSparseValuesBufferView(sparse_values_buffer_view int64) { //gd:GLTFAccessor.set_sparse_values_buffer_view
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_sparse_values_buffer_view, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ sparse_values_buffer_view int64 }{sparse_values_buffer_view}))
}

//go:nosplit
func (self class) GetSparseValuesByteOffset() int64 { //gd:GLTFAccessor.get_sparse_values_byte_offset
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_sparse_values_byte_offset, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetSparseValuesByteOffset(sparse_values_byte_offset int64) { //gd:GLTFAccessor.set_sparse_values_byte_offset
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_sparse_values_byte_offset, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ sparse_values_byte_offset int64 }{sparse_values_byte_offset}))
}
func (self class) AsGLTFAccessor() Advanced         { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsGLTFAccessor() Instance      { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsGLTFAccessor() Instance { return self.Super().AsGLTFAccessor() }
func (self class) AsResource() Resource.Advanced {
	return *((*Resource.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsResource() Resource.Instance { return self.Super().AsResource() }
func (self Instance) AsResource() Resource.Instance {
	return *((*Resource.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsRefCounted() [1]gd.RefCounted { return self.Super().AsRefCounted() }
func (self Instance) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Resource.Advanced(self.AsResource()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Resource.Instance(self.AsResource()), name)
	}
}
func init() {
	gdclass.Register("GLTFAccessor", func(ptr gd.Object) any { return *(*Instance)(unsafe.Pointer(&ptr)) })
}

type GLTFAccessorType int //gd:GLTFAccessor.GLTFAccessorType

const (
	/*Accessor type "SCALAR". For the glTF object model, this can be used to map to a single float, int, or bool value, or a float array.*/
	TypeScalar GLTFAccessorType = 0
	/*Accessor type "VEC2". For the glTF object model, this maps to "float2", represented in the glTF JSON as an array of two floats.*/
	TypeVec2 GLTFAccessorType = 1
	/*Accessor type "VEC3". For the glTF object model, this maps to "float3", represented in the glTF JSON as an array of three floats.*/
	TypeVec3 GLTFAccessorType = 2
	/*Accessor type "VEC4". For the glTF object model, this maps to "float4", represented in the glTF JSON as an array of four floats.*/
	TypeVec4 GLTFAccessorType = 3
	/*Accessor type "MAT2". For the glTF object model, this maps to "float2x2", represented in the glTF JSON as an array of four floats.*/
	TypeMat2 GLTFAccessorType = 4
	/*Accessor type "MAT3". For the glTF object model, this maps to "float3x3", represented in the glTF JSON as an array of nine floats.*/
	TypeMat3 GLTFAccessorType = 5
	/*Accessor type "MAT4". For the glTF object model, this maps to "float4x4", represented in the glTF JSON as an array of sixteen floats.*/
	TypeMat4 GLTFAccessorType = 6
)

type GLTFComponentType int //gd:GLTFAccessor.GLTFComponentType

const (
	/*Component type "NONE". This is not a valid component type, and is used to indicate that the component type is not set.*/
	ComponentTypeNone GLTFComponentType = 0
	/*Component type "BYTE". The value is [code]0x1400[/code] which comes from OpenGL. This indicates data is stored in 1-byte or 8-bit signed integers. This is a core part of the glTF specification.*/
	ComponentTypeSignedByte GLTFComponentType = 5120
	/*Component type "UNSIGNED_BYTE". The value is [code]0x1401[/code] which comes from OpenGL. This indicates data is stored in 1-byte or 8-bit unsigned integers. This is a core part of the glTF specification.*/
	ComponentTypeUnsignedByte GLTFComponentType = 5121
	/*Component type "SHORT". The value is [code]0x1402[/code] which comes from OpenGL. This indicates data is stored in 2-byte or 16-bit signed integers. This is a core part of the glTF specification.*/
	ComponentTypeSignedShort GLTFComponentType = 5122
	/*Component type "UNSIGNED_SHORT". The value is [code]0x1403[/code] which comes from OpenGL. This indicates data is stored in 2-byte or 16-bit unsigned integers. This is a core part of the glTF specification.*/
	ComponentTypeUnsignedShort GLTFComponentType = 5123
	/*Component type "INT". The value is [code]0x1404[/code] which comes from OpenGL. This indicates data is stored in 4-byte or 32-bit signed integers. This is NOT a core part of the glTF specification, and may not be supported by all glTF importers. May be used by some extensions including [code]KHR_interactivity[/code].*/
	ComponentTypeSignedInt GLTFComponentType = 5124
	/*Component type "UNSIGNED_INT". The value is [code]0x1405[/code] which comes from OpenGL. This indicates data is stored in 4-byte or 32-bit unsigned integers. This is a core part of the glTF specification.*/
	ComponentTypeUnsignedInt GLTFComponentType = 5125
	/*Component type "FLOAT". The value is [code]0x1406[/code] which comes from OpenGL. This indicates data is stored in 4-byte or 32-bit floating-point numbers. This is a core part of the glTF specification.*/
	ComponentTypeSingleFloat GLTFComponentType = 5126
	/*Component type "DOUBLE". The value is [code]0x140A[/code] which comes from OpenGL. This indicates data is stored in 8-byte or 64-bit floating-point numbers. This is NOT a core part of the glTF specification, and may not be supported by all glTF importers. May be used by some extensions including [code]KHR_interactivity[/code].*/
	ComponentTypeDoubleFloat GLTFComponentType = 5130
	/*Component type "HALF_FLOAT". The value is [code]0x140B[/code] which comes from OpenGL. This indicates data is stored in 2-byte or 16-bit floating-point numbers. This is NOT a core part of the glTF specification, and may not be supported by all glTF importers. May be used by some extensions including [code]KHR_interactivity[/code].*/
	ComponentTypeHalfFloat GLTFComponentType = 5131
	/*Component type "LONG". The value is [code]0x140E[/code] which comes from OpenGL. This indicates data is stored in 8-byte or 64-bit signed integers. This is NOT a core part of the glTF specification, and may not be supported by all glTF importers. May be used by some extensions including [code]KHR_interactivity[/code].*/
	ComponentTypeSignedLong GLTFComponentType = 5134
	/*Component type "UNSIGNED_LONG". The value is [code]0x140F[/code] which comes from OpenGL. This indicates data is stored in 8-byte or 64-bit unsigned integers. This is NOT a core part of the glTF specification, and may not be supported by all glTF importers. May be used by some extensions including [code]KHR_interactivity[/code].*/
	ComponentTypeUnsignedLong GLTFComponentType = 5135
)
