// Code generated by the generate package DO NOT EDIT

// Package NavigationMeshSourceGeometryData2D provides methods for working with NavigationMeshSourceGeometryData2D object instances.
package NavigationMeshSourceGeometryData2D

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/Resource"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/Rect2"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"
import "graphics.gd/variant/Vector2"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
Container for parsed source geometry data used in navigation mesh baking.
*/
type Instance [1]gdclass.NavigationMeshSourceGeometryData2D

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	clear                        gdextension.MethodForClass `hash:"3218959716"`
	has_data                     gdextension.MethodForClass `hash:"2240911060"`
	set_traversable_outlines     gdextension.MethodForClass `hash:"381264803"`
	get_traversable_outlines     gdextension.MethodForClass `hash:"3995934104"`
	set_obstruction_outlines     gdextension.MethodForClass `hash:"381264803"`
	get_obstruction_outlines     gdextension.MethodForClass `hash:"3995934104"`
	append_traversable_outlines  gdextension.MethodForClass `hash:"381264803"`
	append_obstruction_outlines  gdextension.MethodForClass `hash:"381264803"`
	add_traversable_outline      gdextension.MethodForClass `hash:"1509147220"`
	add_obstruction_outline      gdextension.MethodForClass `hash:"1509147220"`
	merge                        gdextension.MethodForClass `hash:"742424872"`
	add_projected_obstruction    gdextension.MethodForClass `hash:"3882407395"`
	clear_projected_obstructions gdextension.MethodForClass `hash:"3218959716"`
	set_projected_obstructions   gdextension.MethodForClass `hash:"381264803"`
	get_projected_obstructions   gdextension.MethodForClass `hash:"3995934104"`
	get_bounds                   gdextension.MethodForClass `hash:"3248174"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("NavigationMeshSourceGeometryData2D")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		gdextension.Free(gdextension.TypeStringName, &sname)
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsNavigationMeshSourceGeometryData2D() Instance
}

/*
Clears the internal data.
*/
func (self Instance) Clear() { //gd:NavigationMeshSourceGeometryData2D.clear
	Advanced(self).Clear()
}

/*
Returns [code]true[/code] when parsed source geometry data exists.
*/
func (self Instance) HasData() bool { //gd:NavigationMeshSourceGeometryData2D.has_data
	return bool(Advanced(self).HasData())
}

/*
Appends another array of [param traversable_outlines] at the end of the existing traversable outlines array.
*/
func (self Instance) AppendTraversableOutlines(traversable_outlines [][]Vector2.XY) { //gd:NavigationMeshSourceGeometryData2D.append_traversable_outlines
	Advanced(self).AppendTraversableOutlines(gd.ArrayFromSlice[Array.Contains[Packed.Array[Vector2.XY]]](traversable_outlines))
}

/*
Appends another array of [param obstruction_outlines] at the end of the existing obstruction outlines array.
*/
func (self Instance) AppendObstructionOutlines(obstruction_outlines [][]Vector2.XY) { //gd:NavigationMeshSourceGeometryData2D.append_obstruction_outlines
	Advanced(self).AppendObstructionOutlines(gd.ArrayFromSlice[Array.Contains[Packed.Array[Vector2.XY]]](obstruction_outlines))
}

/*
Adds the outline points of a shape as traversable area.
*/
func (self Instance) AddTraversableOutline(shape_outline []Vector2.XY) { //gd:NavigationMeshSourceGeometryData2D.add_traversable_outline
	Advanced(self).AddTraversableOutline(Packed.New(shape_outline...))
}

/*
Adds the outline points of a shape as obstructed area.
*/
func (self Instance) AddObstructionOutline(shape_outline []Vector2.XY) { //gd:NavigationMeshSourceGeometryData2D.add_obstruction_outline
	Advanced(self).AddObstructionOutline(Packed.New(shape_outline...))
}

/*
Adds the geometry data of another [NavigationMeshSourceGeometryData2D] to the navigation mesh baking data.
*/
func (self Instance) Merge(other_geometry Instance) { //gd:NavigationMeshSourceGeometryData2D.merge
	Advanced(self).Merge(other_geometry)
}

/*
Adds a projected obstruction shape to the source geometry. If [param carve] is [code]true[/code] the carved shape will not be affected by additional offsets (e.g. agent radius) of the navigation mesh baking process.
*/
func (self Instance) AddProjectedObstruction(vertices []Vector2.XY, carve bool) { //gd:NavigationMeshSourceGeometryData2D.add_projected_obstruction
	Advanced(self).AddProjectedObstruction(Packed.New(vertices...), carve)
}

/*
Clears all projected obstructions.
*/
func (self Instance) ClearProjectedObstructions() { //gd:NavigationMeshSourceGeometryData2D.clear_projected_obstructions
	Advanced(self).ClearProjectedObstructions()
}

/*
Returns an axis-aligned bounding box that covers all the stored geometry data. The bounds are calculated when calling this function with the result cached until further geometry changes are made.
*/
func (self Instance) GetBounds() Rect2.PositionSize { //gd:NavigationMeshSourceGeometryData2D.get_bounds
	return Rect2.PositionSize(Advanced(self).GetBounds())
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.NavigationMeshSourceGeometryData2D

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.NavigationMeshSourceGeometryData2D)(unsafe.Pointer(&obj))
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.NavigationMeshSourceGeometryData2D)(unsafe.Pointer(&obj))
		return true
	}
	return false
}

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {

	if !gd.Linked {
		var placeholder Instance
		*(*gd.Object)(unsafe.Pointer(&placeholder)) = pointers.Add[gd.Object]([3]uint64{})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(*(*gd.Object)(unsafe.Pointer(&placeholder)), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	object := [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})}
	casted := Instance{*(*gdclass.NavigationMeshSourceGeometryData2D)(unsafe.Pointer(&object))}
	object[0].Notification(0, false)
	return casted
}

func (self Instance) TraversableOutlines() [][]Vector2.XY {
	return [][]Vector2.XY(gd.ArrayAs[[][]Vector2.XY](gd.InternalArray(class(self).GetTraversableOutlines())))
}

func (self Instance) SetTraversableOutlines(value [][]Vector2.XY) {
	class(self).SetTraversableOutlines(gd.ArrayFromSlice[Array.Contains[Packed.Array[Vector2.XY]]](value))
}

func (self Instance) ObstructionOutlines() [][]Vector2.XY {
	return [][]Vector2.XY(gd.ArrayAs[[][]Vector2.XY](gd.InternalArray(class(self).GetObstructionOutlines())))
}

func (self Instance) SetObstructionOutlines(value [][]Vector2.XY) {
	class(self).SetObstructionOutlines(gd.ArrayFromSlice[Array.Contains[Packed.Array[Vector2.XY]]](value))
}

func (self Instance) ProjectedObstructions() []any {
	return []any(gd.ArrayAs[[]any](gd.InternalArray(class(self).GetProjectedObstructions())))
}

func (self Instance) SetProjectedObstructions(value []any) {
	class(self).SetProjectedObstructions(gd.EngineArrayFromSlice(value))
}

/*
Clears the internal data.
*/
//go:nosplit
func (self class) Clear() { //gd:NavigationMeshSourceGeometryData2D.clear
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.clear, 0, unsafe.Pointer(&struct{}{}))
}

/*
Returns [code]true[/code] when parsed source geometry data exists.
*/
//go:nosplit
func (self class) HasData() bool { //gd:NavigationMeshSourceGeometryData2D.has_data
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.has_data, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Sets all the traversable area outlines arrays.
*/
//go:nosplit
func (self class) SetTraversableOutlines(traversable_outlines Array.Contains[Packed.Array[Vector2.XY]]) { //gd:NavigationMeshSourceGeometryData2D.set_traversable_outlines
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_traversable_outlines, 0|(gdextension.SizeArray<<4), unsafe.Pointer(&struct{ traversable_outlines gdextension.Array }{pointers.Get(gd.InternalArray(traversable_outlines))}))
}

/*
Returns all the traversable area outlines arrays.
*/
//go:nosplit
func (self class) GetTraversableOutlines() Array.Contains[Packed.Array[Vector2.XY]] { //gd:NavigationMeshSourceGeometryData2D.get_traversable_outlines
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), methods.get_traversable_outlines, gdextension.SizeArray, unsafe.Pointer(&struct{}{}))
	var ret = Array.Through(gd.ArrayProxy[Packed.Array[Vector2.XY]]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

/*
Sets all the obstructed area outlines arrays.
*/
//go:nosplit
func (self class) SetObstructionOutlines(obstruction_outlines Array.Contains[Packed.Array[Vector2.XY]]) { //gd:NavigationMeshSourceGeometryData2D.set_obstruction_outlines
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_obstruction_outlines, 0|(gdextension.SizeArray<<4), unsafe.Pointer(&struct{ obstruction_outlines gdextension.Array }{pointers.Get(gd.InternalArray(obstruction_outlines))}))
}

/*
Returns all the obstructed area outlines arrays.
*/
//go:nosplit
func (self class) GetObstructionOutlines() Array.Contains[Packed.Array[Vector2.XY]] { //gd:NavigationMeshSourceGeometryData2D.get_obstruction_outlines
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), methods.get_obstruction_outlines, gdextension.SizeArray, unsafe.Pointer(&struct{}{}))
	var ret = Array.Through(gd.ArrayProxy[Packed.Array[Vector2.XY]]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

/*
Appends another array of [param traversable_outlines] at the end of the existing traversable outlines array.
*/
//go:nosplit
func (self class) AppendTraversableOutlines(traversable_outlines Array.Contains[Packed.Array[Vector2.XY]]) { //gd:NavigationMeshSourceGeometryData2D.append_traversable_outlines
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.append_traversable_outlines, 0|(gdextension.SizeArray<<4), unsafe.Pointer(&struct{ traversable_outlines gdextension.Array }{pointers.Get(gd.InternalArray(traversable_outlines))}))
}

/*
Appends another array of [param obstruction_outlines] at the end of the existing obstruction outlines array.
*/
//go:nosplit
func (self class) AppendObstructionOutlines(obstruction_outlines Array.Contains[Packed.Array[Vector2.XY]]) { //gd:NavigationMeshSourceGeometryData2D.append_obstruction_outlines
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.append_obstruction_outlines, 0|(gdextension.SizeArray<<4), unsafe.Pointer(&struct{ obstruction_outlines gdextension.Array }{pointers.Get(gd.InternalArray(obstruction_outlines))}))
}

/*
Adds the outline points of a shape as traversable area.
*/
//go:nosplit
func (self class) AddTraversableOutline(shape_outline Packed.Array[Vector2.XY]) { //gd:NavigationMeshSourceGeometryData2D.add_traversable_outline
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_traversable_outline, 0|(gdextension.SizePackedArray<<4), unsafe.Pointer(&struct {
		shape_outline gdextension.PackedArray[Vector2.XY]
	}{pointers.Get(gd.InternalPacked[gd.PackedVector2Array, Vector2.XY](shape_outline))}))
}

/*
Adds the outline points of a shape as obstructed area.
*/
//go:nosplit
func (self class) AddObstructionOutline(shape_outline Packed.Array[Vector2.XY]) { //gd:NavigationMeshSourceGeometryData2D.add_obstruction_outline
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_obstruction_outline, 0|(gdextension.SizePackedArray<<4), unsafe.Pointer(&struct {
		shape_outline gdextension.PackedArray[Vector2.XY]
	}{pointers.Get(gd.InternalPacked[gd.PackedVector2Array, Vector2.XY](shape_outline))}))
}

/*
Adds the geometry data of another [NavigationMeshSourceGeometryData2D] to the navigation mesh baking data.
*/
//go:nosplit
func (self class) Merge(other_geometry [1]gdclass.NavigationMeshSourceGeometryData2D) { //gd:NavigationMeshSourceGeometryData2D.merge
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.merge, 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ other_geometry gdextension.Object }{gdextension.Object(gd.CallerIncrements(other_geometry[0].AsObject()))}))
}

/*
Adds a projected obstruction shape to the source geometry. If [param carve] is [code]true[/code] the carved shape will not be affected by additional offsets (e.g. agent radius) of the navigation mesh baking process.
*/
//go:nosplit
func (self class) AddProjectedObstruction(vertices Packed.Array[Vector2.XY], carve bool) { //gd:NavigationMeshSourceGeometryData2D.add_projected_obstruction
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_projected_obstruction, 0|(gdextension.SizePackedArray<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		vertices gdextension.PackedArray[Vector2.XY]
		carve    bool
	}{pointers.Get(gd.InternalPacked[gd.PackedVector2Array, Vector2.XY](vertices)), carve}))
}

/*
Clears all projected obstructions.
*/
//go:nosplit
func (self class) ClearProjectedObstructions() { //gd:NavigationMeshSourceGeometryData2D.clear_projected_obstructions
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.clear_projected_obstructions, 0, unsafe.Pointer(&struct{}{}))
}

/*
Sets the projected obstructions with an Array of Dictionaries with the following key value pairs:
[codeblocks]
[gdscript]
"vertices" : PackedFloat32Array
"carve" : bool
[/gdscript]
[/codeblocks]
*/
//go:nosplit
func (self class) SetProjectedObstructions(projected_obstructions Array.Any) { //gd:NavigationMeshSourceGeometryData2D.set_projected_obstructions
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_projected_obstructions, 0|(gdextension.SizeArray<<4), unsafe.Pointer(&struct{ projected_obstructions gdextension.Array }{pointers.Get(gd.InternalArray(projected_obstructions))}))
}

/*
Returns the projected obstructions as an [Array] of dictionaries. Each [Dictionary] contains the following entries:
- [code]vertices[/code] - A [PackedFloat32Array] that defines the outline points of the projected shape.
- [code]carve[/code] - A [bool] that defines how the projected shape affects the navigation mesh baking. If [code]true[/code] the projected shape will not be affected by addition offsets, e.g. agent radius.
*/
//go:nosplit
func (self class) GetProjectedObstructions() Array.Any { //gd:NavigationMeshSourceGeometryData2D.get_projected_obstructions
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), methods.get_projected_obstructions, gdextension.SizeArray, unsafe.Pointer(&struct{}{}))
	var ret = Array.Through(gd.ArrayProxy[variant.Any]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

/*
Returns an axis-aligned bounding box that covers all the stored geometry data. The bounds are calculated when calling this function with the result cached until further geometry changes are made.
*/
//go:nosplit
func (self class) GetBounds() Rect2.PositionSize { //gd:NavigationMeshSourceGeometryData2D.get_bounds
	var r_ret = gdextension.Call[Rect2.PositionSize](gd.ObjectChecked(self.AsObject()), methods.get_bounds, gdextension.SizeRect2, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}
func (self class) AsNavigationMeshSourceGeometryData2D() Advanced {
	return *((*Advanced)(unsafe.Pointer(&self)))
}
func (self Instance) AsNavigationMeshSourceGeometryData2D() Instance {
	return *((*Instance)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsNavigationMeshSourceGeometryData2D() Instance {
	return self.Super().AsNavigationMeshSourceGeometryData2D()
}
func (self class) AsResource() Resource.Advanced {
	return *((*Resource.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsResource() Resource.Instance { return self.Super().AsResource() }
func (self Instance) AsResource() Resource.Instance {
	return *((*Resource.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsRefCounted() [1]gd.RefCounted { return self.Super().AsRefCounted() }
func (self Instance) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Resource.Advanced(self.AsResource()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Resource.Instance(self.AsResource()), name)
	}
}
func init() {
	gdclass.Register("NavigationMeshSourceGeometryData2D", func(ptr gd.Object) any { return *(*Instance)(unsafe.Pointer(&ptr)) })
}
