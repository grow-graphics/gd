// Code generated by the generate package DO NOT EDIT

// Package SplitContainer provides methods for working with SplitContainer object instances.
package SplitContainer

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdunsafe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/CanvasItem"
import "graphics.gd/classdb/Container"
import "graphics.gd/classdb/Control"
import "graphics.gd/classdb/Node"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = gdunsafe.Use{}
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
A container that accepts only two child controls, then arranges them horizontally or vertically and creates a divisor between them. The divisor can be dragged around to change the size relation between the child controls.
*/
type Instance [1]gdclass.SplitContainer

func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsSplitContainer() Instance
}

/*
Clamps the [member split_offset] value to not go outside the currently possible minimal and maximum values.
*/
func (self Instance) ClampSplitOffset() { //gd:SplitContainer.clamp_split_offset
	Advanced(self).ClampSplitOffset()
}

/*
Returns the drag area [Control]. For example, you can move a pre-configured button into the drag area [Control] so that it rides along with the split bar. Try setting the [Button] anchors to [code]center[/code] prior to the [code]reparent()[/code] call.
[codeblock]
$BarnacleButton.reparent($SplitContainer.get_drag_area_control())
[/codeblock]
[b]Note:[/b] The drag area [Control] is drawn over the [SplitContainer]'s children, so [CanvasItem] draw objects called from the [Control] and children added to the [Control] will also appear over the [SplitContainer]'s children. Try setting [member Control.mouse_filter] of custom children to [constant Control.MOUSE_FILTER_IGNORE] to prevent blocking the mouse from dragging if desired.
[b]Warning:[/b] This is a required internal node, removing and freeing it may cause a crash.
*/
func (self Instance) GetDragAreaControl() Control.Instance { //gd:SplitContainer.get_drag_area_control
	return Control.Instance(Advanced(self).GetDragAreaControl())
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.SplitContainer

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {
	object := gd.Global.ClassDB.ConstructObject(gd.NewStringName("SplitContainer"))
	casted := Instance{*(*gdclass.SplitContainer)(unsafe.Pointer(&object))}
	return casted
}

func (self Instance) SplitOffset() int {
	return int(int(class(self).GetSplitOffset()))
}

func (self Instance) SetSplitOffset(value int) {
	class(self).SetSplitOffset(int64(value))
}

func (self Instance) Collapsed() bool {
	return bool(class(self).IsCollapsed())
}

func (self Instance) SetCollapsed(value bool) {
	class(self).SetCollapsed(value)
}

func (self Instance) DraggingEnabled() bool {
	return bool(class(self).IsDraggingEnabled())
}

func (self Instance) SetDraggingEnabled(value bool) {
	class(self).SetDraggingEnabled(value)
}

func (self Instance) DraggerVisibility() DraggerVisibility {
	return DraggerVisibility(class(self).GetDraggerVisibility())
}

func (self Instance) SetDraggerVisibility(value DraggerVisibility) {
	class(self).SetDraggerVisibility(value)
}

func (self Instance) Vertical() bool {
	return bool(class(self).IsVertical())
}

func (self Instance) SetVertical(value bool) {
	class(self).SetVertical(value)
}

func (self Instance) DragAreaMarginBegin() int {
	return int(int(class(self).GetDragAreaMarginBegin()))
}

func (self Instance) SetDragAreaMarginBegin(value int) {
	class(self).SetDragAreaMarginBegin(int64(value))
}

func (self Instance) DragAreaMarginEnd() int {
	return int(int(class(self).GetDragAreaMarginEnd()))
}

func (self Instance) SetDragAreaMarginEnd(value int) {
	class(self).SetDragAreaMarginEnd(int64(value))
}

func (self Instance) DragAreaOffset() int {
	return int(int(class(self).GetDragAreaOffset()))
}

func (self Instance) SetDragAreaOffset(value int) {
	class(self).SetDragAreaOffset(int64(value))
}

func (self Instance) DragAreaHighlightInEditor() bool {
	return bool(class(self).IsDragAreaHighlightInEditorEnabled())
}

func (self Instance) SetDragAreaHighlightInEditor(value bool) {
	class(self).SetDragAreaHighlightInEditor(value)
}

//go:nosplit
func (self class) SetSplitOffset(offset int64) { //gd:SplitContainer.set_split_offset
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.SplitContainer.Bind_set_split_offset, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ offset int64 }{offset}))
}

//go:nosplit
func (self class) GetSplitOffset() int64 { //gd:SplitContainer.get_split_offset
	var r_ret = gdunsafe.Call[int64](self.AsObject(), gd.Global.Methods.SplitContainer.Bind_get_split_offset, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Clamps the [member split_offset] value to not go outside the currently possible minimal and maximum values.
*/
//go:nosplit
func (self class) ClampSplitOffset() { //gd:SplitContainer.clamp_split_offset
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.SplitContainer.Bind_clamp_split_offset, 0, unsafe.Pointer(&struct{}{}))
}

//go:nosplit
func (self class) SetCollapsed(collapsed bool) { //gd:SplitContainer.set_collapsed
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.SplitContainer.Bind_set_collapsed, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ collapsed bool }{collapsed}))
}

//go:nosplit
func (self class) IsCollapsed() bool { //gd:SplitContainer.is_collapsed
	var r_ret = gdunsafe.Call[bool](self.AsObject(), gd.Global.Methods.SplitContainer.Bind_is_collapsed, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetDraggerVisibility(mode DraggerVisibility) { //gd:SplitContainer.set_dragger_visibility
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.SplitContainer.Bind_set_dragger_visibility, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ mode DraggerVisibility }{mode}))
}

//go:nosplit
func (self class) GetDraggerVisibility() DraggerVisibility { //gd:SplitContainer.get_dragger_visibility
	var r_ret = gdunsafe.Call[DraggerVisibility](self.AsObject(), gd.Global.Methods.SplitContainer.Bind_get_dragger_visibility, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetVertical(vertical bool) { //gd:SplitContainer.set_vertical
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.SplitContainer.Bind_set_vertical, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ vertical bool }{vertical}))
}

//go:nosplit
func (self class) IsVertical() bool { //gd:SplitContainer.is_vertical
	var r_ret = gdunsafe.Call[bool](self.AsObject(), gd.Global.Methods.SplitContainer.Bind_is_vertical, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetDraggingEnabled(dragging_enabled bool) { //gd:SplitContainer.set_dragging_enabled
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.SplitContainer.Bind_set_dragging_enabled, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ dragging_enabled bool }{dragging_enabled}))
}

//go:nosplit
func (self class) IsDraggingEnabled() bool { //gd:SplitContainer.is_dragging_enabled
	var r_ret = gdunsafe.Call[bool](self.AsObject(), gd.Global.Methods.SplitContainer.Bind_is_dragging_enabled, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetDragAreaMarginBegin(margin int64) { //gd:SplitContainer.set_drag_area_margin_begin
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.SplitContainer.Bind_set_drag_area_margin_begin, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ margin int64 }{margin}))
}

//go:nosplit
func (self class) GetDragAreaMarginBegin() int64 { //gd:SplitContainer.get_drag_area_margin_begin
	var r_ret = gdunsafe.Call[int64](self.AsObject(), gd.Global.Methods.SplitContainer.Bind_get_drag_area_margin_begin, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetDragAreaMarginEnd(margin int64) { //gd:SplitContainer.set_drag_area_margin_end
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.SplitContainer.Bind_set_drag_area_margin_end, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ margin int64 }{margin}))
}

//go:nosplit
func (self class) GetDragAreaMarginEnd() int64 { //gd:SplitContainer.get_drag_area_margin_end
	var r_ret = gdunsafe.Call[int64](self.AsObject(), gd.Global.Methods.SplitContainer.Bind_get_drag_area_margin_end, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetDragAreaOffset(offset int64) { //gd:SplitContainer.set_drag_area_offset
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.SplitContainer.Bind_set_drag_area_offset, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ offset int64 }{offset}))
}

//go:nosplit
func (self class) GetDragAreaOffset() int64 { //gd:SplitContainer.get_drag_area_offset
	var r_ret = gdunsafe.Call[int64](self.AsObject(), gd.Global.Methods.SplitContainer.Bind_get_drag_area_offset, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetDragAreaHighlightInEditor(drag_area_highlight_in_editor bool) { //gd:SplitContainer.set_drag_area_highlight_in_editor
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.SplitContainer.Bind_set_drag_area_highlight_in_editor, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ drag_area_highlight_in_editor bool }{drag_area_highlight_in_editor}))
}

//go:nosplit
func (self class) IsDragAreaHighlightInEditorEnabled() bool { //gd:SplitContainer.is_drag_area_highlight_in_editor_enabled
	var r_ret = gdunsafe.Call[bool](self.AsObject(), gd.Global.Methods.SplitContainer.Bind_is_drag_area_highlight_in_editor_enabled, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the drag area [Control]. For example, you can move a pre-configured button into the drag area [Control] so that it rides along with the split bar. Try setting the [Button] anchors to [code]center[/code] prior to the [code]reparent()[/code] call.
[codeblock]
$BarnacleButton.reparent($SplitContainer.get_drag_area_control())
[/codeblock]
[b]Note:[/b] The drag area [Control] is drawn over the [SplitContainer]'s children, so [CanvasItem] draw objects called from the [Control] and children added to the [Control] will also appear over the [SplitContainer]'s children. Try setting [member Control.mouse_filter] of custom children to [constant Control.MOUSE_FILTER_IGNORE] to prevent blocking the mouse from dragging if desired.
[b]Warning:[/b] This is a required internal node, removing and freeing it may cause a crash.
*/
//go:nosplit
func (self class) GetDragAreaControl() [1]gdclass.Control { //gd:SplitContainer.get_drag_area_control
	var r_ret = gdunsafe.Call[gd.EnginePointer](self.AsObject(), gd.Global.Methods.SplitContainer.Bind_get_drag_area_control, gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.Control{gd.PointerLifetimeBoundTo[gdclass.Control](self.AsObject(), r_ret)}
	return ret
}
func (self Instance) OnDragged(cb func(offset int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("dragged"), gd.NewCallable(cb), 0)
}

func (self Instance) OnDragStarted(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("drag_started"), gd.NewCallable(cb), 0)
}

func (self Instance) OnDragEnded(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("drag_ended"), gd.NewCallable(cb), 0)
}

func (self class) AsSplitContainer() Advanced         { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsSplitContainer() Instance      { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsSplitContainer() Instance { return self.Super().AsSplitContainer() }
func (self class) AsContainer() Container.Advanced {
	return *((*Container.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsContainer() Container.Instance { return self.Super().AsContainer() }
func (self Instance) AsContainer() Container.Instance {
	return *((*Container.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsControl() Control.Advanced         { return *((*Control.Advanced)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsControl() Control.Instance { return self.Super().AsControl() }
func (self Instance) AsControl() Control.Instance {
	return *((*Control.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsCanvasItem() CanvasItem.Advanced {
	return *((*CanvasItem.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsCanvasItem() CanvasItem.Instance { return self.Super().AsCanvasItem() }
func (self Instance) AsCanvasItem() CanvasItem.Instance {
	return *((*CanvasItem.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsNode() Node.Advanced         { return *((*Node.Advanced)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsNode() Node.Instance { return self.Super().AsNode() }
func (self Instance) AsNode() Node.Instance      { return *((*Node.Instance)(unsafe.Pointer(&self))) }

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Container.Advanced(self.AsContainer()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Container.Instance(self.AsContainer()), name)
	}
}
func init() {
	gdclass.Register("SplitContainer", func(ptr gd.Object) any {
		return [1]gdclass.SplitContainer{*(*gdclass.SplitContainer)(unsafe.Pointer(&ptr))}
	})
}

type DraggerVisibility int //gd:SplitContainer.DraggerVisibility

const (
	/*The split dragger icon is always visible when [theme_item autohide] is [code]false[/code], otherwise visible only when the cursor hovers it.
	  The size of the grabber icon determines the minimum [theme_item separation].
	  The dragger icon is automatically hidden if the length of the grabber icon is longer than the split bar.*/
	DraggerVisible DraggerVisibility = 0
	/*The split dragger icon is never visible regardless of the value of [theme_item autohide].
	  The size of the grabber icon determines the minimum [theme_item separation].*/
	DraggerHidden DraggerVisibility = 1
	/*The split dragger icon is not visible, and the split bar is collapsed to zero thickness.*/
	DraggerHiddenCollapsed DraggerVisibility = 2
)
