// Code generated by the generate package DO NOT EDIT

// Package UDPServer provides methods for working with UDPServer object instances.
package UDPServer

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/PacketPeerUDP"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
A simple server that opens a UDP socket and returns connected [PacketPeerUDP] upon receiving new packets. See also [method PacketPeerUDP.connect_to_host].
After starting the server ([method listen]), you will need to [method poll] it at regular intervals (e.g. inside [method Node._process]) for it to process new packets, delivering them to the appropriate [PacketPeerUDP], and taking new connections.
Below a small example of how it can be used:
[codeblocks]
[gdscript]
# server_node.gd
class_name ServerNode
extends Node

var server = UDPServer.new()
var peers = []

func _ready():

	server.listen(4242)

func _process(delta):

	server.poll() # Important!
	if server.is_connection_available():
	    var peer = server.take_connection()
	    var packet = peer.get_packet()
	    print("Accepted peer: %s:%s" % [peer.get_packet_ip(), peer.get_packet_port()])
	    print("Received data: %s" % [packet.get_string_from_utf8()])
	    # Reply so it knows we received the message.
	    peer.put_packet(packet)
	    # Keep a reference so we can keep contacting the remote peer.
	    peers.append(peer)

	for i in range(0, peers.size()):
	    pass # Do something with the connected peers.

[/gdscript]
[csharp]
// ServerNode.cs
using Godot;
using System.Collections.Generic;

public partial class ServerNode : Node

	{
	    private UdpServer _server = new UdpServer();
	    private List<PacketPeerUdp> _peers  = new List<PacketPeerUdp>();

	    public override void _Ready()
	    {
	        _server.Listen(4242);
	    }

	    public override void _Process(double delta)
	    {
	        _server.Poll(); // Important!
	        if (_server.IsConnectionAvailable())
	        {
	            PacketPeerUdp peer = _server.TakeConnection();
	            byte[] packet = peer.GetPacket();
	            GD.Print($"Accepted Peer: {peer.GetPacketIP()}:{peer.GetPacketPort()}");
	            GD.Print($"Received Data: {packet.GetStringFromUtf8()}");
	            // Reply so it knows we received the message.
	            peer.PutPacket(packet);
	            // Keep a reference so we can keep contacting the remote peer.
	            _peers.Add(peer);
	        }
	        foreach (var peer in _peers)
	        {
	            // Do something with the peers.
	        }
	    }
	}

[/csharp]
[/codeblocks]
[codeblocks]
[gdscript]
# client_node.gd
class_name ClientNode
extends Node

var udp = PacketPeerUDP.new()
var connected = false

func _ready():

	udp.connect_to_host("127.0.0.1", 4242)

func _process(delta):

	if !connected:
	    # Try to contact server
	    udp.put_packet("The answer is... 42!".to_utf8_buffer())
	if udp.get_available_packet_count() > 0:
	    print("Connected: %s" % udp.get_packet().get_string_from_utf8())
	    connected = true

[/gdscript]
[csharp]
// ClientNode.cs
using Godot;

public partial class ClientNode : Node

	{
	    private PacketPeerUdp _udp = new PacketPeerUdp();
	    private bool _connected = false;

	    public override void _Ready()
	    {
	        _udp.ConnectToHost("127.0.0.1", 4242);
	    }

	    public override void _Process(double delta)
	    {
	        if (!_connected)
	        {
	            // Try to contact server
	            _udp.PutPacket("The Answer Is..42!".ToUtf8Buffer());
	        }
	        if (_udp.GetAvailablePacketCount() > 0)
	        {
	            GD.Print($"Connected: {_udp.GetPacket().GetStringFromUtf8()}");
	            _connected = true;
	        }
	    }
	}

[/csharp]
[/codeblocks]
*/
type Instance [1]gdclass.UDPServer

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	listen                      gdextension.MethodForClass `hash:"3167955072"`
	poll                        gdextension.MethodForClass `hash:"166280745"`
	is_connection_available     gdextension.MethodForClass `hash:"36873697"`
	get_local_port              gdextension.MethodForClass `hash:"3905245786"`
	is_listening                gdextension.MethodForClass `hash:"36873697"`
	take_connection             gdextension.MethodForClass `hash:"808734560"`
	stop                        gdextension.MethodForClass `hash:"3218959716"`
	set_max_pending_connections gdextension.MethodForClass `hash:"1286410249"`
	get_max_pending_connections gdextension.MethodForClass `hash:"3905245786"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("UDPServer")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		pointers.Raw[gd.StringName](sname).Free()
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

type Expanded [1]gdclass.UDPServer

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsUDPServer() Instance
}

/*
Starts the server by opening a UDP socket listening on the given [param port]. You can optionally specify a [param bind_address] to only listen for packets sent to that address. See also [method PacketPeerUDP.bind].
*/
func (self Instance) Listen(port int) error { //gd:UDPServer.listen
	return error(gd.ToError(Advanced(self).Listen(int64(port), String.New("*"))))
}

/*
Starts the server by opening a UDP socket listening on the given [param port]. You can optionally specify a [param bind_address] to only listen for packets sent to that address. See also [method PacketPeerUDP.bind].
*/
func (self Expanded) Listen(port int, bind_address string) error { //gd:UDPServer.listen
	return error(gd.ToError(Advanced(self).Listen(int64(port), String.New(bind_address))))
}

/*
Call this method at regular intervals (e.g. inside [method Node._process]) to process new packets. And packet from known address/port pair will be delivered to the appropriate [PacketPeerUDP], any packet received from an unknown address/port pair will be added as a pending connection (see [method is_connection_available], [method take_connection]). The maximum number of pending connection is defined via [member max_pending_connections].
*/
func (self Instance) Poll() error { //gd:UDPServer.poll
	return error(gd.ToError(Advanced(self).Poll()))
}

/*
Returns [code]true[/code] if a packet with a new address/port combination was received on the socket.
*/
func (self Instance) IsConnectionAvailable() bool { //gd:UDPServer.is_connection_available
	return bool(Advanced(self).IsConnectionAvailable())
}

/*
Returns the local port this server is listening to.
*/
func (self Instance) GetLocalPort() int { //gd:UDPServer.get_local_port
	return int(int(Advanced(self).GetLocalPort()))
}

/*
Returns [code]true[/code] if the socket is open and listening on a port.
*/
func (self Instance) IsListening() bool { //gd:UDPServer.is_listening
	return bool(Advanced(self).IsListening())
}

/*
Returns the first pending connection (connected to the appropriate address/port). Will return [code]null[/code] if no new connection is available. See also [method is_connection_available], [method PacketPeerUDP.connect_to_host].
*/
func (self Instance) TakeConnection() PacketPeerUDP.Instance { //gd:UDPServer.take_connection
	return PacketPeerUDP.Instance(Advanced(self).TakeConnection())
}

/*
Stops the server, closing the UDP socket if open. Will close all connected [PacketPeerUDP] accepted via [method take_connection] (remote peers will not be notified).
*/
func (self Instance) Stop() { //gd:UDPServer.stop
	Advanced(self).Stop()
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.UDPServer

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.UDPServer)(unsafe.Pointer(&obj))
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.UDPServer)(unsafe.Pointer(&obj))
		return true
	}
	return false
}

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {
	object := [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})}
	casted := Instance{*(*gdclass.UDPServer)(unsafe.Pointer(&object))}
	casted.AsRefCounted()[0].Reference()
	object[0].Notification(0, false)
	return casted
}

func (self Instance) MaxPendingConnections() int {
	return int(int(class(self).GetMaxPendingConnections()))
}

func (self Instance) SetMaxPendingConnections(value int) {
	class(self).SetMaxPendingConnections(int64(value))
}

/*
Starts the server by opening a UDP socket listening on the given [param port]. You can optionally specify a [param bind_address] to only listen for packets sent to that address. See also [method PacketPeerUDP.bind].
*/
//go:nosplit
func (self class) Listen(port int64, bind_address String.Readable) Error.Code { //gd:UDPServer.listen
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.listen, gdextension.SizeInt|(gdextension.SizeInt<<4)|(gdextension.SizeString<<8), unsafe.Pointer(&struct {
		port         int64
		bind_address gdextension.String
	}{port, pointers.Get(gd.InternalString(bind_address))}))
	var ret = Error.Code(r_ret)
	return ret
}

/*
Call this method at regular intervals (e.g. inside [method Node._process]) to process new packets. And packet from known address/port pair will be delivered to the appropriate [PacketPeerUDP], any packet received from an unknown address/port pair will be added as a pending connection (see [method is_connection_available], [method take_connection]). The maximum number of pending connection is defined via [member max_pending_connections].
*/
//go:nosplit
func (self class) Poll() Error.Code { //gd:UDPServer.poll
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.poll, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = Error.Code(r_ret)
	return ret
}

/*
Returns [code]true[/code] if a packet with a new address/port combination was received on the socket.
*/
//go:nosplit
func (self class) IsConnectionAvailable() bool { //gd:UDPServer.is_connection_available
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_connection_available, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the local port this server is listening to.
*/
//go:nosplit
func (self class) GetLocalPort() int64 { //gd:UDPServer.get_local_port
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_local_port, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if the socket is open and listening on a port.
*/
//go:nosplit
func (self class) IsListening() bool { //gd:UDPServer.is_listening
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_listening, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the first pending connection (connected to the appropriate address/port). Will return [code]null[/code] if no new connection is available. See also [method is_connection_available], [method PacketPeerUDP.connect_to_host].
*/
//go:nosplit
func (self class) TakeConnection() [1]gdclass.PacketPeerUDP { //gd:UDPServer.take_connection
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.take_connection, gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.PacketPeerUDP{gd.PointerWithOwnershipTransferredToGo[gdclass.PacketPeerUDP](r_ret)}
	return ret
}

/*
Stops the server, closing the UDP socket if open. Will close all connected [PacketPeerUDP] accepted via [method take_connection] (remote peers will not be notified).
*/
//go:nosplit
func (self class) Stop() { //gd:UDPServer.stop
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.stop, 0, unsafe.Pointer(&struct{}{}))
}

//go:nosplit
func (self class) SetMaxPendingConnections(max_pending_connections int64) { //gd:UDPServer.set_max_pending_connections
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_max_pending_connections, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ max_pending_connections int64 }{max_pending_connections}))
}

//go:nosplit
func (self class) GetMaxPendingConnections() int64 { //gd:UDPServer.get_max_pending_connections
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_max_pending_connections, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}
func (self class) AsUDPServer() Advanced         { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsUDPServer() Instance      { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsUDPServer() Instance { return self.Super().AsUDPServer() }
func (self class) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsRefCounted() [1]gd.RefCounted { return self.Super().AsRefCounted() }
func (self Instance) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(RefCounted.Advanced(self.AsRefCounted()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(RefCounted.Instance(self.AsRefCounted()), name)
	}
}
func init() {
	gdclass.Register("UDPServer", func(ptr gd.Object) any { return *(*Instance)(unsafe.Pointer(&ptr)) })
}
