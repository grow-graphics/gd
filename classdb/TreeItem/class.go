// Code generated by the generate package DO NOT EDIT

// Package TreeItem provides methods for working with TreeItem object instances.
package TreeItem

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/variant/Signal"
import "graphics.gd/classdb/Control"
import "graphics.gd/classdb/Font"
import "graphics.gd/classdb/GUI"
import "graphics.gd/classdb/Node"
import "graphics.gd/classdb/TextServer"
import "graphics.gd/classdb/Texture2D"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Color"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/Rect2"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Signal.Any
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
A single item of a [Tree] control. It can contain other [TreeItem]s as children, which allows it to create a hierarchy. It can also contain text and buttons. [TreeItem] is not a [Node], it is internal to the [Tree].
To create a [TreeItem], use [method Tree.create_item] or [method TreeItem.create_child]. To remove a [TreeItem], use [method Object.free].
[b]Note:[/b] The ID values used for buttons are 32-bit, unlike [int] which is always 64-bit. They go from [code]-2147483648[/code] to [code]2147483647[/code].
*/
type Instance [1]gdclass.TreeItem

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	set_cell_mode                             gdextension.MethodForClass `hash:"289920701"`
	get_cell_mode                             gdextension.MethodForClass `hash:"3406114978"`
	set_auto_translate_mode                   gdextension.MethodForClass `hash:"287402019"`
	get_auto_translate_mode                   gdextension.MethodForClass `hash:"906302372"`
	set_edit_multiline                        gdextension.MethodForClass `hash:"300928843"`
	is_edit_multiline                         gdextension.MethodForClass `hash:"1116898809"`
	set_checked                               gdextension.MethodForClass `hash:"300928843"`
	set_indeterminate                         gdextension.MethodForClass `hash:"300928843"`
	is_checked                                gdextension.MethodForClass `hash:"1116898809"`
	is_indeterminate                          gdextension.MethodForClass `hash:"1116898809"`
	propagate_check                           gdextension.MethodForClass `hash:"972357352"`
	set_text                                  gdextension.MethodForClass `hash:"501894301"`
	get_text                                  gdextension.MethodForClass `hash:"844755477"`
	set_text_direction                        gdextension.MethodForClass `hash:"1707680378"`
	get_text_direction                        gdextension.MethodForClass `hash:"4235602388"`
	set_autowrap_mode                         gdextension.MethodForClass `hash:"3633006561"`
	get_autowrap_mode                         gdextension.MethodForClass `hash:"2902757236"`
	set_text_overrun_behavior                 gdextension.MethodForClass `hash:"1940772195"`
	get_text_overrun_behavior                 gdextension.MethodForClass `hash:"3782727860"`
	set_structured_text_bidi_override         gdextension.MethodForClass `hash:"868756907"`
	get_structured_text_bidi_override         gdextension.MethodForClass `hash:"3377823772"`
	set_structured_text_bidi_override_options gdextension.MethodForClass `hash:"537221740"`
	get_structured_text_bidi_override_options gdextension.MethodForClass `hash:"663333327"`
	set_language                              gdextension.MethodForClass `hash:"501894301"`
	get_language                              gdextension.MethodForClass `hash:"844755477"`
	set_suffix                                gdextension.MethodForClass `hash:"501894301"`
	get_suffix                                gdextension.MethodForClass `hash:"844755477"`
	set_icon                                  gdextension.MethodForClass `hash:"666127730"`
	get_icon                                  gdextension.MethodForClass `hash:"3536238170"`
	set_icon_overlay                          gdextension.MethodForClass `hash:"666127730"`
	get_icon_overlay                          gdextension.MethodForClass `hash:"3536238170"`
	set_icon_region                           gdextension.MethodForClass `hash:"1356297692"`
	get_icon_region                           gdextension.MethodForClass `hash:"3327874267"`
	set_icon_max_width                        gdextension.MethodForClass `hash:"3937882851"`
	get_icon_max_width                        gdextension.MethodForClass `hash:"923996154"`
	set_icon_modulate                         gdextension.MethodForClass `hash:"2878471219"`
	get_icon_modulate                         gdextension.MethodForClass `hash:"3457211756"`
	set_range                                 gdextension.MethodForClass `hash:"1602489585"`
	get_range                                 gdextension.MethodForClass `hash:"2339986948"`
	set_range_config                          gdextension.MethodForClass `hash:"1547181014"`
	get_range_config                          gdextension.MethodForClass `hash:"3554694381"`
	set_metadata                              gdextension.MethodForClass `hash:"2152698145"`
	get_metadata                              gdextension.MethodForClass `hash:"4227898402"`
	set_custom_draw                           gdextension.MethodForClass `hash:"272420368"`
	set_custom_draw_callback                  gdextension.MethodForClass `hash:"957362965"`
	get_custom_draw_callback                  gdextension.MethodForClass `hash:"1317077508"`
	set_collapsed                             gdextension.MethodForClass `hash:"2586408642"`
	is_collapsed                              gdextension.MethodForClass `hash:"2240911060"`
	set_collapsed_recursive                   gdextension.MethodForClass `hash:"2586408642"`
	is_any_collapsed                          gdextension.MethodForClass `hash:"2595650253"`
	set_visible                               gdextension.MethodForClass `hash:"2586408642"`
	is_visible                                gdextension.MethodForClass `hash:"2240911060"`
	is_visible_in_tree                        gdextension.MethodForClass `hash:"36873697"`
	uncollapse_tree                           gdextension.MethodForClass `hash:"3218959716"`
	set_custom_minimum_height                 gdextension.MethodForClass `hash:"1286410249"`
	get_custom_minimum_height                 gdextension.MethodForClass `hash:"3905245786"`
	set_selectable                            gdextension.MethodForClass `hash:"300928843"`
	is_selectable                             gdextension.MethodForClass `hash:"1116898809"`
	is_selected                               gdextension.MethodForClass `hash:"3067735520"`
	select_                                   gdextension.MethodForClass `hash:"1286410249"`
	deselect                                  gdextension.MethodForClass `hash:"1286410249"`
	set_editable                              gdextension.MethodForClass `hash:"300928843"`
	is_editable                               gdextension.MethodForClass `hash:"3067735520"`
	set_custom_color                          gdextension.MethodForClass `hash:"2878471219"`
	get_custom_color                          gdextension.MethodForClass `hash:"3457211756"`
	clear_custom_color                        gdextension.MethodForClass `hash:"1286410249"`
	set_custom_font                           gdextension.MethodForClass `hash:"2637609184"`
	get_custom_font                           gdextension.MethodForClass `hash:"4244553094"`
	set_custom_font_size                      gdextension.MethodForClass `hash:"3937882851"`
	get_custom_font_size                      gdextension.MethodForClass `hash:"923996154"`
	set_custom_bg_color                       gdextension.MethodForClass `hash:"894174518"`
	clear_custom_bg_color                     gdextension.MethodForClass `hash:"1286410249"`
	get_custom_bg_color                       gdextension.MethodForClass `hash:"3457211756"`
	set_custom_as_button                      gdextension.MethodForClass `hash:"300928843"`
	is_custom_set_as_button                   gdextension.MethodForClass `hash:"1116898809"`
	clear_buttons                             gdextension.MethodForClass `hash:"3218959716"`
	add_button                                gdextension.MethodForClass `hash:"1688223362"`
	get_button_count                          gdextension.MethodForClass `hash:"923996154"`
	get_button_tooltip_text                   gdextension.MethodForClass `hash:"1391810591"`
	get_button_id                             gdextension.MethodForClass `hash:"3175239445"`
	get_button_by_id                          gdextension.MethodForClass `hash:"3175239445"`
	get_button_color                          gdextension.MethodForClass `hash:"2165839948"`
	get_button                                gdextension.MethodForClass `hash:"2584904275"`
	set_button_tooltip_text                   gdextension.MethodForClass `hash:"2285447957"`
	set_button                                gdextension.MethodForClass `hash:"176101966"`
	erase_button                              gdextension.MethodForClass `hash:"3937882851"`
	set_button_disabled                       gdextension.MethodForClass `hash:"1383440665"`
	set_button_color                          gdextension.MethodForClass `hash:"3733378741"`
	is_button_disabled                        gdextension.MethodForClass `hash:"2522259332"`
	set_tooltip_text                          gdextension.MethodForClass `hash:"501894301"`
	get_tooltip_text                          gdextension.MethodForClass `hash:"844755477"`
	set_text_alignment                        gdextension.MethodForClass `hash:"3276431499"`
	get_text_alignment                        gdextension.MethodForClass `hash:"4171562184"`
	set_expand_right                          gdextension.MethodForClass `hash:"300928843"`
	get_expand_right                          gdextension.MethodForClass `hash:"1116898809"`
	set_disable_folding                       gdextension.MethodForClass `hash:"2586408642"`
	is_folding_disabled                       gdextension.MethodForClass `hash:"36873697"`
	create_child                              gdextension.MethodForClass `hash:"954243986"`
	add_child                                 gdextension.MethodForClass `hash:"1819951137"`
	remove_child                              gdextension.MethodForClass `hash:"1819951137"`
	get_tree                                  gdextension.MethodForClass `hash:"2243340556"`
	get_next                                  gdextension.MethodForClass `hash:"1514277247"`
	get_prev                                  gdextension.MethodForClass `hash:"2768121250"`
	get_parent                                gdextension.MethodForClass `hash:"1514277247"`
	get_first_child                           gdextension.MethodForClass `hash:"1514277247"`
	get_next_in_tree                          gdextension.MethodForClass `hash:"1666920593"`
	get_prev_in_tree                          gdextension.MethodForClass `hash:"1666920593"`
	get_next_visible                          gdextension.MethodForClass `hash:"1666920593"`
	get_prev_visible                          gdextension.MethodForClass `hash:"1666920593"`
	get_child                                 gdextension.MethodForClass `hash:"306700752"`
	get_child_count                           gdextension.MethodForClass `hash:"2455072627"`
	get_children                              gdextension.MethodForClass `hash:"2915620761"`
	get_index                                 gdextension.MethodForClass `hash:"2455072627"`
	move_before                               gdextension.MethodForClass `hash:"1819951137"`
	move_after                                gdextension.MethodForClass `hash:"1819951137"`
	call_recursive                            gdextension.MethodForClass `hash:"2866548813"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("TreeItem")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		gdextension.Free(gdextension.TypeStringName, &sname)
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

type Expanded [1]gdclass.TreeItem

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsTreeItem() Instance
}

/*
Sets the given column's cell mode to [param mode]. This determines how the cell is displayed and edited. See [enum TreeCellMode] constants for details.
*/
func (self Instance) SetCellMode(column int, mode TreeCellMode) { //gd:TreeItem.set_cell_mode
	Advanced(self).SetCellMode(int64(column), mode)
}

/*
Returns the column's cell mode.
*/
func (self Instance) GetCellMode(column int) TreeCellMode { //gd:TreeItem.get_cell_mode
	return TreeCellMode(Advanced(self).GetCellMode(int64(column)))
}

/*
Sets the given column's auto translate mode to [param mode].
All columns use [constant Node.AUTO_TRANSLATE_MODE_INHERIT] by default, which uses the same auto translate mode as the [Tree] itself.
*/
func (self Instance) SetAutoTranslateMode(column int, mode Node.AutoTranslateMode) { //gd:TreeItem.set_auto_translate_mode
	Advanced(self).SetAutoTranslateMode(int64(column), mode)
}

/*
Returns the column's auto translate mode.
*/
func (self Instance) GetAutoTranslateMode(column int) Node.AutoTranslateMode { //gd:TreeItem.get_auto_translate_mode
	return Node.AutoTranslateMode(Advanced(self).GetAutoTranslateMode(int64(column)))
}

/*
If [param multiline] is [code]true[/code], the given [param column] is multiline editable.
[b]Note:[/b] This option only affects the type of control ([LineEdit] or [TextEdit]) that appears when editing the column. You can set multiline values with [method set_text] even if the column is not multiline editable.
*/
func (self Instance) SetEditMultiline(column int, multiline bool) { //gd:TreeItem.set_edit_multiline
	Advanced(self).SetEditMultiline(int64(column), multiline)
}

/*
Returns [code]true[/code] if the given [param column] is multiline editable.
*/
func (self Instance) IsEditMultiline(column int) bool { //gd:TreeItem.is_edit_multiline
	return bool(Advanced(self).IsEditMultiline(int64(column)))
}

/*
If [param checked] is [code]true[/code], the given [param column] is checked. Clears column's indeterminate status.
*/
func (self Instance) SetChecked(column int, checked bool) { //gd:TreeItem.set_checked
	Advanced(self).SetChecked(int64(column), checked)
}

/*
If [param indeterminate] is [code]true[/code], the given [param column] is marked indeterminate.
[b]Note:[/b] If set [code]true[/code] from [code]false[/code], then column is cleared of checked status.
*/
func (self Instance) SetIndeterminate(column int, indeterminate bool) { //gd:TreeItem.set_indeterminate
	Advanced(self).SetIndeterminate(int64(column), indeterminate)
}

/*
Returns [code]true[/code] if the given [param column] is checked.
*/
func (self Instance) IsChecked(column int) bool { //gd:TreeItem.is_checked
	return bool(Advanced(self).IsChecked(int64(column)))
}

/*
Returns [code]true[/code] if the given [param column] is indeterminate.
*/
func (self Instance) IsIndeterminate(column int) bool { //gd:TreeItem.is_indeterminate
	return bool(Advanced(self).IsIndeterminate(int64(column)))
}

/*
Propagates this item's checked status to its children and parents for the given [param column]. It is possible to process the items affected by this method call by connecting to [signal Tree.check_propagated_to_item]. The order that the items affected will be processed is as follows: the item invoking this method, children of that item, and finally parents of that item. If [param emit_signal] is [code]false[/code], then [signal Tree.check_propagated_to_item] will not be emitted.
*/
func (self Instance) PropagateCheck(column int) { //gd:TreeItem.propagate_check
	Advanced(self).PropagateCheck(int64(column), true)
}

/*
Propagates this item's checked status to its children and parents for the given [param column]. It is possible to process the items affected by this method call by connecting to [signal Tree.check_propagated_to_item]. The order that the items affected will be processed is as follows: the item invoking this method, children of that item, and finally parents of that item. If [param emit_signal] is [code]false[/code], then [signal Tree.check_propagated_to_item] will not be emitted.
*/
func (self Expanded) PropagateCheck(column int, emit_signal bool) { //gd:TreeItem.propagate_check
	Advanced(self).PropagateCheck(int64(column), emit_signal)
}

/*
Sets the given column's text value.
*/
func (self Instance) SetText(column int, text string) { //gd:TreeItem.set_text
	Advanced(self).SetText(int64(column), String.New(text))
}

/*
Returns the given column's text.
*/
func (self Instance) GetText(column int) string { //gd:TreeItem.get_text
	return string(Advanced(self).GetText(int64(column)).String())
}

/*
Sets item's text base writing direction.
*/
func (self Instance) SetTextDirection(column int, direction Control.TextDirection) { //gd:TreeItem.set_text_direction
	Advanced(self).SetTextDirection(int64(column), direction)
}

/*
Returns item's text base writing direction.
*/
func (self Instance) GetTextDirection(column int) Control.TextDirection { //gd:TreeItem.get_text_direction
	return Control.TextDirection(Advanced(self).GetTextDirection(int64(column)))
}

/*
Sets the autowrap mode in the given [param column]. If set to something other than [constant TextServer.AUTOWRAP_OFF], the text gets wrapped inside the cell's bounding rectangle.
*/
func (self Instance) SetAutowrapMode(column int, autowrap_mode TextServer.AutowrapMode) { //gd:TreeItem.set_autowrap_mode
	Advanced(self).SetAutowrapMode(int64(column), autowrap_mode)
}

/*
Returns the text autowrap mode in the given [param column]. By default it is [constant TextServer.AUTOWRAP_OFF].
*/
func (self Instance) GetAutowrapMode(column int) TextServer.AutowrapMode { //gd:TreeItem.get_autowrap_mode
	return TextServer.AutowrapMode(Advanced(self).GetAutowrapMode(int64(column)))
}

/*
Sets the clipping behavior when the text exceeds the item's bounding rectangle in the given [param column].
*/
func (self Instance) SetTextOverrunBehavior(column int, overrun_behavior TextServer.OverrunBehavior) { //gd:TreeItem.set_text_overrun_behavior
	Advanced(self).SetTextOverrunBehavior(int64(column), overrun_behavior)
}

/*
Returns the clipping behavior when the text exceeds the item's bounding rectangle in the given [param column]. By default it is [constant TextServer.OVERRUN_TRIM_ELLIPSIS].
*/
func (self Instance) GetTextOverrunBehavior(column int) TextServer.OverrunBehavior { //gd:TreeItem.get_text_overrun_behavior
	return TextServer.OverrunBehavior(Advanced(self).GetTextOverrunBehavior(int64(column)))
}

/*
Set BiDi algorithm override for the structured text. Has effect for cells that display text.
*/
func (self Instance) SetStructuredTextBidiOverride(column int, parser TextServer.StructuredTextParser) { //gd:TreeItem.set_structured_text_bidi_override
	Advanced(self).SetStructuredTextBidiOverride(int64(column), parser)
}

/*
Returns the BiDi algorithm override set for this cell.
*/
func (self Instance) GetStructuredTextBidiOverride(column int) TextServer.StructuredTextParser { //gd:TreeItem.get_structured_text_bidi_override
	return TextServer.StructuredTextParser(Advanced(self).GetStructuredTextBidiOverride(int64(column)))
}

/*
Set additional options for BiDi override. Has effect for cells that display text.
*/
func (self Instance) SetStructuredTextBidiOverrideOptions(column int, args []any) { //gd:TreeItem.set_structured_text_bidi_override_options
	Advanced(self).SetStructuredTextBidiOverrideOptions(int64(column), gd.EngineArrayFromSlice(args))
}

/*
Returns the additional BiDi options set for this cell.
*/
func (self Instance) GetStructuredTextBidiOverrideOptions(column int) []any { //gd:TreeItem.get_structured_text_bidi_override_options
	return []any(gd.ArrayAs[[]any](gd.InternalArray(Advanced(self).GetStructuredTextBidiOverrideOptions(int64(column)))))
}

/*
Sets language code of item's text used for line-breaking and text shaping algorithms, if left empty current locale is used instead.
*/
func (self Instance) SetLanguage(column int, language string) { //gd:TreeItem.set_language
	Advanced(self).SetLanguage(int64(column), String.New(language))
}

/*
Returns item's text language code.
*/
func (self Instance) GetLanguage(column int) string { //gd:TreeItem.get_language
	return string(Advanced(self).GetLanguage(int64(column)).String())
}

/*
Sets a string to be shown after a column's value (for example, a unit abbreviation).
*/
func (self Instance) SetSuffix(column int, text string) { //gd:TreeItem.set_suffix
	Advanced(self).SetSuffix(int64(column), String.New(text))
}

/*
Gets the suffix string shown after the column value.
*/
func (self Instance) GetSuffix(column int) string { //gd:TreeItem.get_suffix
	return string(Advanced(self).GetSuffix(int64(column)).String())
}

/*
Sets the given cell's icon [Texture2D]. If the cell is in [constant CELL_MODE_ICON] mode, the icon is displayed in the center of the cell. Otherwise, the icon is displayed before the cell's text. [constant CELL_MODE_RANGE] does not display an icon.
*/
func (self Instance) SetIcon(column int, texture Texture2D.Instance) { //gd:TreeItem.set_icon
	Advanced(self).SetIcon(int64(column), texture)
}

/*
Returns the given column's icon [Texture2D]. Error if no icon is set.
*/
func (self Instance) GetIcon(column int) Texture2D.Instance { //gd:TreeItem.get_icon
	return Texture2D.Instance(Advanced(self).GetIcon(int64(column)))
}

/*
Sets the given cell's icon overlay [Texture2D]. The cell has to be in [constant CELL_MODE_ICON] mode, and icon has to be set. Overlay is drawn on top of icon, in the bottom left corner.
*/
func (self Instance) SetIconOverlay(column int, texture Texture2D.Instance) { //gd:TreeItem.set_icon_overlay
	Advanced(self).SetIconOverlay(int64(column), texture)
}

/*
Returns the given column's icon overlay [Texture2D].
*/
func (self Instance) GetIconOverlay(column int) Texture2D.Instance { //gd:TreeItem.get_icon_overlay
	return Texture2D.Instance(Advanced(self).GetIconOverlay(int64(column)))
}

/*
Sets the given column's icon's texture region.
*/
func (self Instance) SetIconRegion(column int, region Rect2.PositionSize) { //gd:TreeItem.set_icon_region
	Advanced(self).SetIconRegion(int64(column), Rect2.PositionSize(region))
}

/*
Returns the icon [Texture2D] region as [Rect2].
*/
func (self Instance) GetIconRegion(column int) Rect2.PositionSize { //gd:TreeItem.get_icon_region
	return Rect2.PositionSize(Advanced(self).GetIconRegion(int64(column)))
}

/*
Sets the maximum allowed width of the icon in the given [param column]. This limit is applied on top of the default size of the icon and on top of [theme_item Tree.icon_max_width]. The height is adjusted according to the icon's ratio.
*/
func (self Instance) SetIconMaxWidth(column int, width int) { //gd:TreeItem.set_icon_max_width
	Advanced(self).SetIconMaxWidth(int64(column), int64(width))
}

/*
Returns the maximum allowed width of the icon in the given [param column].
*/
func (self Instance) GetIconMaxWidth(column int) int { //gd:TreeItem.get_icon_max_width
	return int(int(Advanced(self).GetIconMaxWidth(int64(column))))
}

/*
Modulates the given column's icon with [param modulate].
*/
func (self Instance) SetIconModulate(column int, modulate Color.RGBA) { //gd:TreeItem.set_icon_modulate
	Advanced(self).SetIconModulate(int64(column), Color.RGBA(modulate))
}

/*
Returns the [Color] modulating the column's icon.
*/
func (self Instance) GetIconModulate(column int) Color.RGBA { //gd:TreeItem.get_icon_modulate
	return Color.RGBA(Advanced(self).GetIconModulate(int64(column)))
}

/*
Sets the value of a [constant CELL_MODE_RANGE] column.
*/
func (self Instance) SetRange(column int, value Float.X) { //gd:TreeItem.set_range
	Advanced(self).SetRange(int64(column), float64(value))
}

/*
Returns the value of a [constant CELL_MODE_RANGE] column.
*/
func (self Instance) GetRange(column int) Float.X { //gd:TreeItem.get_range
	return Float.X(Float.X(Advanced(self).GetRange(int64(column))))
}

/*
Sets the range of accepted values for a column. The column must be in the [constant CELL_MODE_RANGE] mode.
If [param expr] is [code]true[/code], the edit mode slider will use an exponential scale as with [member Range.exp_edit].
*/
func (self Instance) SetRangeConfig(column int, min Float.X, max Float.X, step Float.X) { //gd:TreeItem.set_range_config
	Advanced(self).SetRangeConfig(int64(column), float64(min), float64(max), float64(step), false)
}

/*
Sets the range of accepted values for a column. The column must be in the [constant CELL_MODE_RANGE] mode.
If [param expr] is [code]true[/code], the edit mode slider will use an exponential scale as with [member Range.exp_edit].
*/
func (self Expanded) SetRangeConfig(column int, min Float.X, max Float.X, step Float.X, expr bool) { //gd:TreeItem.set_range_config
	Advanced(self).SetRangeConfig(int64(column), float64(min), float64(max), float64(step), expr)
}

/*
Returns a dictionary containing the range parameters for a given column. The keys are "min", "max", "step", and "expr".
*/
func (self Instance) GetRangeConfig(column int) RangeConfig { //gd:TreeItem.get_range_config
	return RangeConfig(gd.DictionaryAs[RangeConfig](Advanced(self).GetRangeConfig(int64(column))))
}

/*
Sets the metadata value for the given column, which can be retrieved later using [method get_metadata]. This can be used, for example, to store a reference to the original data.
*/
func (self Instance) SetMetadata(column int, meta any) { //gd:TreeItem.set_metadata
	Advanced(self).SetMetadata(int64(column), variant.New(meta))
}

/*
Returns the metadata value that was set for the given column using [method set_metadata].
*/
func (self Instance) GetMetadata(column int) any { //gd:TreeItem.get_metadata
	return any(Advanced(self).GetMetadata(int64(column)).Interface())
}

/*
Sets the given column's custom draw callback to the [param callback] method on [param object].
The method named [param callback] should accept two arguments: the [TreeItem] that is drawn and its position and size as a [Rect2].
*/
func (self Instance) SetCustomDraw(column int, obj Object.Instance, callback string) { //gd:TreeItem.set_custom_draw
	Advanced(self).SetCustomDraw(int64(column), obj, String.Name(String.New(callback)))
}

/*
Sets the given column's custom draw callback. Use an empty [Callable] ([code skip-lint]Callable()[/code]) to clear the custom callback. The cell has to be in [constant CELL_MODE_CUSTOM] to use this feature.
The [param callback] should accept two arguments: the [TreeItem] that is drawn and its position and size as a [Rect2].
*/
func (self Instance) SetCustomDrawCallback(column int, callback func(item Instance, rect Rect2.PositionSize)) { //gd:TreeItem.set_custom_draw_callback
	Advanced(self).SetCustomDrawCallback(int64(column), Callable.New(callback))
}

/*
Returns the custom callback of column [param column].
*/
func (self Instance) GetCustomDrawCallback(column int) Callable.Function { //gd:TreeItem.get_custom_draw_callback
	return Callable.Function(Advanced(self).GetCustomDrawCallback(int64(column)))
}

/*
Collapses or uncollapses this [TreeItem] and all the descendants of this item.
*/
func (self Instance) SetCollapsedRecursive(enable bool) { //gd:TreeItem.set_collapsed_recursive
	Advanced(self).SetCollapsedRecursive(enable)
}

/*
Returns [code]true[/code] if this [TreeItem], or any of its descendants, is collapsed.
If [param only_visible] is [code]true[/code] it ignores non-visible [TreeItem]s.
*/
func (self Instance) IsAnyCollapsed() bool { //gd:TreeItem.is_any_collapsed
	return bool(Advanced(self).IsAnyCollapsed(false))
}

/*
Returns [code]true[/code] if this [TreeItem], or any of its descendants, is collapsed.
If [param only_visible] is [code]true[/code] it ignores non-visible [TreeItem]s.
*/
func (self Expanded) IsAnyCollapsed(only_visible bool) bool { //gd:TreeItem.is_any_collapsed
	return bool(Advanced(self).IsAnyCollapsed(only_visible))
}

/*
Returns [code]true[/code] if [member visible] is [code]true[/code] and all its ancestors are also visible.
*/
func (self Instance) IsVisibleInTree() bool { //gd:TreeItem.is_visible_in_tree
	return bool(Advanced(self).IsVisibleInTree())
}

/*
Uncollapses all [TreeItem]s necessary to reveal this [TreeItem], i.e. all ancestor [TreeItem]s.
*/
func (self Instance) UncollapseTree() { //gd:TreeItem.uncollapse_tree
	Advanced(self).UncollapseTree()
}

/*
If [param selectable] is [code]true[/code], the given [param column] is selectable.
*/
func (self Instance) SetSelectable(column int, selectable bool) { //gd:TreeItem.set_selectable
	Advanced(self).SetSelectable(int64(column), selectable)
}

/*
Returns [code]true[/code] if the given [param column] is selectable.
*/
func (self Instance) IsSelectable(column int) bool { //gd:TreeItem.is_selectable
	return bool(Advanced(self).IsSelectable(int64(column)))
}

/*
Returns [code]true[/code] if the given [param column] is selected.
*/
func (self Instance) IsSelected(column int) bool { //gd:TreeItem.is_selected
	return bool(Advanced(self).IsSelected(int64(column)))
}

/*
Selects the given [param column].
*/
func (self Instance) Select(column int) { //gd:TreeItem.select
	Advanced(self).Select(int64(column))
}

/*
Deselects the given column.
*/
func (self Instance) Deselect(column int) { //gd:TreeItem.deselect
	Advanced(self).Deselect(int64(column))
}

/*
If [param enabled] is [code]true[/code], the given [param column] is editable.
*/
func (self Instance) SetEditable(column int, enabled bool) { //gd:TreeItem.set_editable
	Advanced(self).SetEditable(int64(column), enabled)
}

/*
Returns [code]true[/code] if the given [param column] is editable.
*/
func (self Instance) IsEditable(column int) bool { //gd:TreeItem.is_editable
	return bool(Advanced(self).IsEditable(int64(column)))
}

/*
Sets the given column's custom color.
*/
func (self Instance) SetCustomColor(column int, color Color.RGBA) { //gd:TreeItem.set_custom_color
	Advanced(self).SetCustomColor(int64(column), Color.RGBA(color))
}

/*
Returns the custom color of column [param column].
*/
func (self Instance) GetCustomColor(column int) Color.RGBA { //gd:TreeItem.get_custom_color
	return Color.RGBA(Advanced(self).GetCustomColor(int64(column)))
}

/*
Resets the color for the given column to default.
*/
func (self Instance) ClearCustomColor(column int) { //gd:TreeItem.clear_custom_color
	Advanced(self).ClearCustomColor(int64(column))
}

/*
Sets custom font used to draw text in the given [param column].
*/
func (self Instance) SetCustomFont(column int, font Font.Instance) { //gd:TreeItem.set_custom_font
	Advanced(self).SetCustomFont(int64(column), font)
}

/*
Returns custom font used to draw text in the column [param column].
*/
func (self Instance) GetCustomFont(column int) Font.Instance { //gd:TreeItem.get_custom_font
	return Font.Instance(Advanced(self).GetCustomFont(int64(column)))
}

/*
Sets custom font size used to draw text in the given [param column].
*/
func (self Instance) SetCustomFontSize(column int, font_size int) { //gd:TreeItem.set_custom_font_size
	Advanced(self).SetCustomFontSize(int64(column), int64(font_size))
}

/*
Returns custom font size used to draw text in the column [param column].
*/
func (self Instance) GetCustomFontSize(column int) int { //gd:TreeItem.get_custom_font_size
	return int(int(Advanced(self).GetCustomFontSize(int64(column))))
}

/*
Sets the given column's custom background color and whether to just use it as an outline.
*/
func (self Instance) SetCustomBgColor(column int, color Color.RGBA) { //gd:TreeItem.set_custom_bg_color
	Advanced(self).SetCustomBgColor(int64(column), Color.RGBA(color), false)
}

/*
Sets the given column's custom background color and whether to just use it as an outline.
*/
func (self Expanded) SetCustomBgColor(column int, color Color.RGBA, just_outline bool) { //gd:TreeItem.set_custom_bg_color
	Advanced(self).SetCustomBgColor(int64(column), Color.RGBA(color), just_outline)
}

/*
Resets the background color for the given column to default.
*/
func (self Instance) ClearCustomBgColor(column int) { //gd:TreeItem.clear_custom_bg_color
	Advanced(self).ClearCustomBgColor(int64(column))
}

/*
Returns the custom background color of column [param column].
*/
func (self Instance) GetCustomBgColor(column int) Color.RGBA { //gd:TreeItem.get_custom_bg_color
	return Color.RGBA(Advanced(self).GetCustomBgColor(int64(column)))
}

/*
Makes a cell with [constant CELL_MODE_CUSTOM] display as a non-flat button with a [StyleBox].
*/
func (self Instance) SetCustomAsButton(column int, enable bool) { //gd:TreeItem.set_custom_as_button
	Advanced(self).SetCustomAsButton(int64(column), enable)
}

/*
Returns [code]true[/code] if the cell was made into a button with [method set_custom_as_button].
*/
func (self Instance) IsCustomSetAsButton(column int) bool { //gd:TreeItem.is_custom_set_as_button
	return bool(Advanced(self).IsCustomSetAsButton(int64(column)))
}

/*
Removes all buttons from all columns of this item.
*/
func (self Instance) ClearButtons() { //gd:TreeItem.clear_buttons
	Advanced(self).ClearButtons()
}

/*
Adds a button with [Texture2D] [param button] to the end of the cell at column [param column]. The [param id] is used to identify the button in the according [signal Tree.button_clicked] signal and can be different from the buttons index. If not specified, the next available index is used, which may be retrieved by calling [method get_button_count] immediately before this method. Optionally, the button can be [param disabled] and have a [param tooltip_text].
*/
func (self Instance) AddButton(column int, button Texture2D.Instance) { //gd:TreeItem.add_button
	Advanced(self).AddButton(int64(column), button, int64(-1), false, String.New(""))
}

/*
Adds a button with [Texture2D] [param button] to the end of the cell at column [param column]. The [param id] is used to identify the button in the according [signal Tree.button_clicked] signal and can be different from the buttons index. If not specified, the next available index is used, which may be retrieved by calling [method get_button_count] immediately before this method. Optionally, the button can be [param disabled] and have a [param tooltip_text].
*/
func (self Expanded) AddButton(column int, button Texture2D.Instance, id int, disabled bool, tooltip_text string) { //gd:TreeItem.add_button
	Advanced(self).AddButton(int64(column), button, int64(id), disabled, String.New(tooltip_text))
}

/*
Returns the number of buttons in column [param column].
*/
func (self Instance) GetButtonCount(column int) int { //gd:TreeItem.get_button_count
	return int(int(Advanced(self).GetButtonCount(int64(column))))
}

/*
Returns the tooltip text for the button at index [param button_index] in column [param column].
*/
func (self Instance) GetButtonTooltipText(column int, button_index int) string { //gd:TreeItem.get_button_tooltip_text
	return string(Advanced(self).GetButtonTooltipText(int64(column), int64(button_index)).String())
}

/*
Returns the ID for the button at index [param button_index] in column [param column].
*/
func (self Instance) GetButtonId(column int, button_index int) int { //gd:TreeItem.get_button_id
	return int(int(Advanced(self).GetButtonId(int64(column), int64(button_index))))
}

/*
Returns the button index if there is a button with ID [param id] in column [param column], otherwise returns -1.
*/
func (self Instance) GetButtonById(column int, id int) int { //gd:TreeItem.get_button_by_id
	return int(int(Advanced(self).GetButtonById(int64(column), int64(id))))
}

/*
Returns the color of the button with ID [param id] in column [param column]. If the specified button does not exist, returns [constant Color.BLACK].
*/
func (self Instance) GetButtonColor(column int, id int) Color.RGBA { //gd:TreeItem.get_button_color
	return Color.RGBA(Advanced(self).GetButtonColor(int64(column), int64(id)))
}

/*
Returns the [Texture2D] of the button at index [param button_index] in column [param column].
*/
func (self Instance) GetButton(column int, button_index int) Texture2D.Instance { //gd:TreeItem.get_button
	return Texture2D.Instance(Advanced(self).GetButton(int64(column), int64(button_index)))
}

/*
Sets the tooltip text for the button at index [param button_index] in the given [param column].
*/
func (self Instance) SetButtonTooltipText(column int, button_index int, tooltip string) { //gd:TreeItem.set_button_tooltip_text
	Advanced(self).SetButtonTooltipText(int64(column), int64(button_index), String.New(tooltip))
}

/*
Sets the given column's button [Texture2D] at index [param button_index] to [param button].
*/
func (self Instance) SetButton(column int, button_index int, button Texture2D.Instance) { //gd:TreeItem.set_button
	Advanced(self).SetButton(int64(column), int64(button_index), button)
}

/*
Removes the button at index [param button_index] in column [param column].
*/
func (self Instance) EraseButton(column int, button_index int) { //gd:TreeItem.erase_button
	Advanced(self).EraseButton(int64(column), int64(button_index))
}

/*
If [code]true[/code], disables the button at index [param button_index] in the given [param column].
*/
func (self Instance) SetButtonDisabled(column int, button_index int, disabled bool) { //gd:TreeItem.set_button_disabled
	Advanced(self).SetButtonDisabled(int64(column), int64(button_index), disabled)
}

/*
Sets the given column's button color at index [param button_index] to [param color].
*/
func (self Instance) SetButtonColor(column int, button_index int, color Color.RGBA) { //gd:TreeItem.set_button_color
	Advanced(self).SetButtonColor(int64(column), int64(button_index), Color.RGBA(color))
}

/*
Returns [code]true[/code] if the button at index [param button_index] for the given [param column] is disabled.
*/
func (self Instance) IsButtonDisabled(column int, button_index int) bool { //gd:TreeItem.is_button_disabled
	return bool(Advanced(self).IsButtonDisabled(int64(column), int64(button_index)))
}

/*
Sets the given column's tooltip text.
*/
func (self Instance) SetTooltipText(column int, tooltip string) { //gd:TreeItem.set_tooltip_text
	Advanced(self).SetTooltipText(int64(column), String.New(tooltip))
}

/*
Returns the given column's tooltip text.
*/
func (self Instance) GetTooltipText(column int) string { //gd:TreeItem.get_tooltip_text
	return string(Advanced(self).GetTooltipText(int64(column)).String())
}

/*
Sets the given column's text alignment. See [enum HorizontalAlignment] for possible values.
*/
func (self Instance) SetTextAlignment(column int, text_alignment GUI.HorizontalAlignment) { //gd:TreeItem.set_text_alignment
	Advanced(self).SetTextAlignment(int64(column), text_alignment)
}

/*
Returns the given column's text alignment.
*/
func (self Instance) GetTextAlignment(column int) GUI.HorizontalAlignment { //gd:TreeItem.get_text_alignment
	return GUI.HorizontalAlignment(Advanced(self).GetTextAlignment(int64(column)))
}

/*
If [param enable] is [code]true[/code], the given [param column] is expanded to the right.
*/
func (self Instance) SetExpandRight(column int, enable bool) { //gd:TreeItem.set_expand_right
	Advanced(self).SetExpandRight(int64(column), enable)
}

/*
Returns [code]true[/code] if [code]expand_right[/code] is set.
*/
func (self Instance) GetExpandRight(column int) bool { //gd:TreeItem.get_expand_right
	return bool(Advanced(self).GetExpandRight(int64(column)))
}

/*
Creates an item and adds it as a child.
The new item will be inserted as position [param index] (the default value [code]-1[/code] means the last position), or it will be the last child if [param index] is higher than the child count.
*/
func (self Instance) CreateChild() Instance { //gd:TreeItem.create_child
	return Instance(Advanced(self).CreateChild(int64(-1)))
}

/*
Creates an item and adds it as a child.
The new item will be inserted as position [param index] (the default value [code]-1[/code] means the last position), or it will be the last child if [param index] is higher than the child count.
*/
func (self Expanded) CreateChild(index int) Instance { //gd:TreeItem.create_child
	return Instance(Advanced(self).CreateChild(int64(index)))
}

/*
Adds a previously unparented [TreeItem] as a direct child of this one. The [param child] item must not be a part of any [Tree] or parented to any [TreeItem]. See also [method remove_child].
*/
func (self Instance) AddChild(child Instance) { //gd:TreeItem.add_child
	Advanced(self).AddChild(child)
}

/*
Removes the given child [TreeItem] and all its children from the [Tree]. Note that it doesn't free the item from memory, so it can be reused later (see [method add_child]). To completely remove a [TreeItem] use [method Object.free].
[b]Note:[/b] If you want to move a child from one [Tree] to another, then instead of removing and adding it manually you can use [method move_before] or [method move_after].
*/
func (self Instance) RemoveChild(child Instance) { //gd:TreeItem.remove_child
	Advanced(self).RemoveChild(child)
}

/*
Returns the next sibling TreeItem in the tree or a [code]null[/code] object if there is none.
*/
func (self Instance) GetNext() Instance { //gd:TreeItem.get_next
	return Instance(Advanced(self).GetNext())
}

/*
Returns the previous sibling TreeItem in the tree or a [code]null[/code] object if there is none.
*/
func (self Instance) GetPrev() Instance { //gd:TreeItem.get_prev
	return Instance(Advanced(self).GetPrev())
}

/*
Returns the parent TreeItem or a [code]null[/code] object if there is none.
*/
func (self Instance) GetParent() Instance { //gd:TreeItem.get_parent
	return Instance(Advanced(self).GetParent())
}

/*
Returns the TreeItem's first child.
*/
func (self Instance) GetFirstChild() Instance { //gd:TreeItem.get_first_child
	return Instance(Advanced(self).GetFirstChild())
}

/*
Returns the next TreeItem in the tree (in the context of a depth-first search) or a [code]null[/code] object if there is none.
If [param wrap] is enabled, the method will wrap around to the first element in the tree when called on the last element, otherwise it returns [code]null[/code].
*/
func (self Instance) GetNextInTree() Instance { //gd:TreeItem.get_next_in_tree
	return Instance(Advanced(self).GetNextInTree(false))
}

/*
Returns the next TreeItem in the tree (in the context of a depth-first search) or a [code]null[/code] object if there is none.
If [param wrap] is enabled, the method will wrap around to the first element in the tree when called on the last element, otherwise it returns [code]null[/code].
*/
func (self Expanded) GetNextInTree(wrap bool) Instance { //gd:TreeItem.get_next_in_tree
	return Instance(Advanced(self).GetNextInTree(wrap))
}

/*
Returns the previous TreeItem in the tree (in the context of a depth-first search) or a [code]null[/code] object if there is none.
If [param wrap] is enabled, the method will wrap around to the last element in the tree when called on the first visible element, otherwise it returns [code]null[/code].
*/
func (self Instance) GetPrevInTree() Instance { //gd:TreeItem.get_prev_in_tree
	return Instance(Advanced(self).GetPrevInTree(false))
}

/*
Returns the previous TreeItem in the tree (in the context of a depth-first search) or a [code]null[/code] object if there is none.
If [param wrap] is enabled, the method will wrap around to the last element in the tree when called on the first visible element, otherwise it returns [code]null[/code].
*/
func (self Expanded) GetPrevInTree(wrap bool) Instance { //gd:TreeItem.get_prev_in_tree
	return Instance(Advanced(self).GetPrevInTree(wrap))
}

/*
Returns the next visible TreeItem in the tree (in the context of a depth-first search) or a [code]null[/code] object if there is none.
If [param wrap] is enabled, the method will wrap around to the first visible element in the tree when called on the last visible element, otherwise it returns [code]null[/code].
*/
func (self Instance) GetNextVisible() Instance { //gd:TreeItem.get_next_visible
	return Instance(Advanced(self).GetNextVisible(false))
}

/*
Returns the next visible TreeItem in the tree (in the context of a depth-first search) or a [code]null[/code] object if there is none.
If [param wrap] is enabled, the method will wrap around to the first visible element in the tree when called on the last visible element, otherwise it returns [code]null[/code].
*/
func (self Expanded) GetNextVisible(wrap bool) Instance { //gd:TreeItem.get_next_visible
	return Instance(Advanced(self).GetNextVisible(wrap))
}

/*
Returns the previous visible sibling TreeItem in the tree (in the context of a depth-first search) or a [code]null[/code] object if there is none.
If [param wrap] is enabled, the method will wrap around to the last visible element in the tree when called on the first visible element, otherwise it returns [code]null[/code].
*/
func (self Instance) GetPrevVisible() Instance { //gd:TreeItem.get_prev_visible
	return Instance(Advanced(self).GetPrevVisible(false))
}

/*
Returns the previous visible sibling TreeItem in the tree (in the context of a depth-first search) or a [code]null[/code] object if there is none.
If [param wrap] is enabled, the method will wrap around to the last visible element in the tree when called on the first visible element, otherwise it returns [code]null[/code].
*/
func (self Expanded) GetPrevVisible(wrap bool) Instance { //gd:TreeItem.get_prev_visible
	return Instance(Advanced(self).GetPrevVisible(wrap))
}

/*
Returns a child item by its [param index] (see [method get_child_count]). This method is often used for iterating all children of an item.
Negative indices access the children from the last one.
*/
func (self Instance) GetChild(index int) Instance { //gd:TreeItem.get_child
	return Instance(Advanced(self).GetChild(int64(index)))
}

/*
Returns the number of child items.
*/
func (self Instance) GetChildCount() int { //gd:TreeItem.get_child_count
	return int(int(Advanced(self).GetChildCount()))
}

/*
Returns an array of references to the item's children.
*/
func (self Instance) GetChildren() []Instance { //gd:TreeItem.get_children
	return []Instance(gd.ArrayAs[[]Instance](gd.InternalArray(Advanced(self).GetChildren())))
}

/*
Returns the node's order in the tree. For example, if called on the first child item the position is [code]0[/code].
*/
func (self Instance) GetIndex() int { //gd:TreeItem.get_index
	return int(int(Advanced(self).GetIndex()))
}

/*
Moves this TreeItem right before the given [param item].
[b]Note:[/b] You can't move to the root or move the root.
*/
func (self Instance) MoveBefore(item Instance) { //gd:TreeItem.move_before
	Advanced(self).MoveBefore(item)
}

/*
Moves this TreeItem right after the given [param item].
[b]Note:[/b] You can't move to the root or move the root.
*/
func (self Instance) MoveAfter(item Instance) { //gd:TreeItem.move_after
	Advanced(self).MoveAfter(item)
}

/*
Calls the [param method] on the actual TreeItem and its children recursively. Pass parameters as a comma separated list.
*/
func (self Instance) CallRecursive(method string, args ...any) { //gd:TreeItem.call_recursive
	var converted_variants = make([]gd.Variant, len(args))
	for i, arg := range args {
		converted_variants[i] = gd.NewVariant(arg)
	}
	Advanced(self).CallRecursive(String.Name(String.New(method)), converted_variants...)
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.TreeItem

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.TreeItem)(unsafe.Pointer(&obj))
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.TreeItem)(unsafe.Pointer(&obj))
		return true
	}
	return false
}

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {

	if !gd.Linked {
		var placeholder Instance
		*(*gd.Object)(unsafe.Pointer(&placeholder)) = pointers.Add[gd.Object]([3]uint64{})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(*(*gd.Object)(unsafe.Pointer(&placeholder)), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	object := [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})}
	casted := Instance{*(*gdclass.TreeItem)(unsafe.Pointer(&object))}
	object[0].Notification(0, false)
	return casted
}

func (self Instance) Collapsed() bool {
	return bool(class(self).IsCollapsed())
}

func (self Instance) SetCollapsed(value bool) {
	class(self).SetCollapsed(value)
}

func (self Instance) Visible() bool {
	return bool(class(self).IsVisible())
}

func (self Instance) SetVisible(value bool) {
	class(self).SetVisible(value)
}

func (self Instance) DisableFolding() bool {
	return bool(class(self).IsFoldingDisabled())
}

func (self Instance) SetDisableFolding(value bool) {
	class(self).SetDisableFolding(value)
}

func (self Instance) CustomMinimumHeight() int {
	return int(int(class(self).GetCustomMinimumHeight()))
}

func (self Instance) SetCustomMinimumHeight(value int) {
	class(self).SetCustomMinimumHeight(int64(value))
}

/*
Sets the given column's cell mode to [param mode]. This determines how the cell is displayed and edited. See [enum TreeCellMode] constants for details.
*/
//go:nosplit
func (self class) SetCellMode(column int64, mode TreeCellMode) { //gd:TreeItem.set_cell_mode
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_cell_mode, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		column int64
		mode   TreeCellMode
	}{column, mode}))
}

/*
Returns the column's cell mode.
*/
//go:nosplit
func (self class) GetCellMode(column int64) TreeCellMode { //gd:TreeItem.get_cell_mode
	var r_ret = gdextension.Call[TreeCellMode](gd.ObjectChecked(self.AsObject()), methods.get_cell_mode, gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ column int64 }{column}))
	var ret = r_ret
	return ret
}

/*
Sets the given column's auto translate mode to [param mode].
All columns use [constant Node.AUTO_TRANSLATE_MODE_INHERIT] by default, which uses the same auto translate mode as the [Tree] itself.
*/
//go:nosplit
func (self class) SetAutoTranslateMode(column int64, mode Node.AutoTranslateMode) { //gd:TreeItem.set_auto_translate_mode
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_auto_translate_mode, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		column int64
		mode   Node.AutoTranslateMode
	}{column, mode}))
}

/*
Returns the column's auto translate mode.
*/
//go:nosplit
func (self class) GetAutoTranslateMode(column int64) Node.AutoTranslateMode { //gd:TreeItem.get_auto_translate_mode
	var r_ret = gdextension.Call[Node.AutoTranslateMode](gd.ObjectChecked(self.AsObject()), methods.get_auto_translate_mode, gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ column int64 }{column}))
	var ret = r_ret
	return ret
}

/*
If [param multiline] is [code]true[/code], the given [param column] is multiline editable.
[b]Note:[/b] This option only affects the type of control ([LineEdit] or [TextEdit]) that appears when editing the column. You can set multiline values with [method set_text] even if the column is not multiline editable.
*/
//go:nosplit
func (self class) SetEditMultiline(column int64, multiline bool) { //gd:TreeItem.set_edit_multiline
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_edit_multiline, 0|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		column    int64
		multiline bool
	}{column, multiline}))
}

/*
Returns [code]true[/code] if the given [param column] is multiline editable.
*/
//go:nosplit
func (self class) IsEditMultiline(column int64) bool { //gd:TreeItem.is_edit_multiline
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_edit_multiline, gdextension.SizeBool|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ column int64 }{column}))
	var ret = r_ret
	return ret
}

/*
If [param checked] is [code]true[/code], the given [param column] is checked. Clears column's indeterminate status.
*/
//go:nosplit
func (self class) SetChecked(column int64, checked bool) { //gd:TreeItem.set_checked
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_checked, 0|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		column  int64
		checked bool
	}{column, checked}))
}

/*
If [param indeterminate] is [code]true[/code], the given [param column] is marked indeterminate.
[b]Note:[/b] If set [code]true[/code] from [code]false[/code], then column is cleared of checked status.
*/
//go:nosplit
func (self class) SetIndeterminate(column int64, indeterminate bool) { //gd:TreeItem.set_indeterminate
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_indeterminate, 0|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		column        int64
		indeterminate bool
	}{column, indeterminate}))
}

/*
Returns [code]true[/code] if the given [param column] is checked.
*/
//go:nosplit
func (self class) IsChecked(column int64) bool { //gd:TreeItem.is_checked
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_checked, gdextension.SizeBool|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ column int64 }{column}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if the given [param column] is indeterminate.
*/
//go:nosplit
func (self class) IsIndeterminate(column int64) bool { //gd:TreeItem.is_indeterminate
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_indeterminate, gdextension.SizeBool|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ column int64 }{column}))
	var ret = r_ret
	return ret
}

/*
Propagates this item's checked status to its children and parents for the given [param column]. It is possible to process the items affected by this method call by connecting to [signal Tree.check_propagated_to_item]. The order that the items affected will be processed is as follows: the item invoking this method, children of that item, and finally parents of that item. If [param emit_signal] is [code]false[/code], then [signal Tree.check_propagated_to_item] will not be emitted.
*/
//go:nosplit
func (self class) PropagateCheck(column int64, emit_signal bool) { //gd:TreeItem.propagate_check
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.propagate_check, 0|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		column      int64
		emit_signal bool
	}{column, emit_signal}))
}

/*
Sets the given column's text value.
*/
//go:nosplit
func (self class) SetText(column int64, text String.Readable) { //gd:TreeItem.set_text
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_text, 0|(gdextension.SizeInt<<4)|(gdextension.SizeString<<8), unsafe.Pointer(&struct {
		column int64
		text   gdextension.String
	}{column, pointers.Get(gd.InternalString(text))}))
}

/*
Returns the given column's text.
*/
//go:nosplit
func (self class) GetText(column int64) String.Readable { //gd:TreeItem.get_text
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_text, gdextension.SizeString|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ column int64 }{column}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Sets item's text base writing direction.
*/
//go:nosplit
func (self class) SetTextDirection(column int64, direction Control.TextDirection) { //gd:TreeItem.set_text_direction
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_text_direction, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		column    int64
		direction Control.TextDirection
	}{column, direction}))
}

/*
Returns item's text base writing direction.
*/
//go:nosplit
func (self class) GetTextDirection(column int64) Control.TextDirection { //gd:TreeItem.get_text_direction
	var r_ret = gdextension.Call[Control.TextDirection](gd.ObjectChecked(self.AsObject()), methods.get_text_direction, gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ column int64 }{column}))
	var ret = r_ret
	return ret
}

/*
Sets the autowrap mode in the given [param column]. If set to something other than [constant TextServer.AUTOWRAP_OFF], the text gets wrapped inside the cell's bounding rectangle.
*/
//go:nosplit
func (self class) SetAutowrapMode(column int64, autowrap_mode TextServer.AutowrapMode) { //gd:TreeItem.set_autowrap_mode
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_autowrap_mode, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		column        int64
		autowrap_mode TextServer.AutowrapMode
	}{column, autowrap_mode}))
}

/*
Returns the text autowrap mode in the given [param column]. By default it is [constant TextServer.AUTOWRAP_OFF].
*/
//go:nosplit
func (self class) GetAutowrapMode(column int64) TextServer.AutowrapMode { //gd:TreeItem.get_autowrap_mode
	var r_ret = gdextension.Call[TextServer.AutowrapMode](gd.ObjectChecked(self.AsObject()), methods.get_autowrap_mode, gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ column int64 }{column}))
	var ret = r_ret
	return ret
}

/*
Sets the clipping behavior when the text exceeds the item's bounding rectangle in the given [param column].
*/
//go:nosplit
func (self class) SetTextOverrunBehavior(column int64, overrun_behavior TextServer.OverrunBehavior) { //gd:TreeItem.set_text_overrun_behavior
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_text_overrun_behavior, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		column           int64
		overrun_behavior TextServer.OverrunBehavior
	}{column, overrun_behavior}))
}

/*
Returns the clipping behavior when the text exceeds the item's bounding rectangle in the given [param column]. By default it is [constant TextServer.OVERRUN_TRIM_ELLIPSIS].
*/
//go:nosplit
func (self class) GetTextOverrunBehavior(column int64) TextServer.OverrunBehavior { //gd:TreeItem.get_text_overrun_behavior
	var r_ret = gdextension.Call[TextServer.OverrunBehavior](gd.ObjectChecked(self.AsObject()), methods.get_text_overrun_behavior, gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ column int64 }{column}))
	var ret = r_ret
	return ret
}

/*
Set BiDi algorithm override for the structured text. Has effect for cells that display text.
*/
//go:nosplit
func (self class) SetStructuredTextBidiOverride(column int64, parser TextServer.StructuredTextParser) { //gd:TreeItem.set_structured_text_bidi_override
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_structured_text_bidi_override, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		column int64
		parser TextServer.StructuredTextParser
	}{column, parser}))
}

/*
Returns the BiDi algorithm override set for this cell.
*/
//go:nosplit
func (self class) GetStructuredTextBidiOverride(column int64) TextServer.StructuredTextParser { //gd:TreeItem.get_structured_text_bidi_override
	var r_ret = gdextension.Call[TextServer.StructuredTextParser](gd.ObjectChecked(self.AsObject()), methods.get_structured_text_bidi_override, gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ column int64 }{column}))
	var ret = r_ret
	return ret
}

/*
Set additional options for BiDi override. Has effect for cells that display text.
*/
//go:nosplit
func (self class) SetStructuredTextBidiOverrideOptions(column int64, args Array.Any) { //gd:TreeItem.set_structured_text_bidi_override_options
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_structured_text_bidi_override_options, 0|(gdextension.SizeInt<<4)|(gdextension.SizeArray<<8), unsafe.Pointer(&struct {
		column int64
		args   gdextension.Array
	}{column, pointers.Get(gd.InternalArray(args))}))
}

/*
Returns the additional BiDi options set for this cell.
*/
//go:nosplit
func (self class) GetStructuredTextBidiOverrideOptions(column int64) Array.Any { //gd:TreeItem.get_structured_text_bidi_override_options
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), methods.get_structured_text_bidi_override_options, gdextension.SizeArray|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ column int64 }{column}))
	var ret = Array.Through(gd.ArrayProxy[variant.Any]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

/*
Sets language code of item's text used for line-breaking and text shaping algorithms, if left empty current locale is used instead.
*/
//go:nosplit
func (self class) SetLanguage(column int64, language String.Readable) { //gd:TreeItem.set_language
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_language, 0|(gdextension.SizeInt<<4)|(gdextension.SizeString<<8), unsafe.Pointer(&struct {
		column   int64
		language gdextension.String
	}{column, pointers.Get(gd.InternalString(language))}))
}

/*
Returns item's text language code.
*/
//go:nosplit
func (self class) GetLanguage(column int64) String.Readable { //gd:TreeItem.get_language
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_language, gdextension.SizeString|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ column int64 }{column}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Sets a string to be shown after a column's value (for example, a unit abbreviation).
*/
//go:nosplit
func (self class) SetSuffix(column int64, text String.Readable) { //gd:TreeItem.set_suffix
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_suffix, 0|(gdextension.SizeInt<<4)|(gdextension.SizeString<<8), unsafe.Pointer(&struct {
		column int64
		text   gdextension.String
	}{column, pointers.Get(gd.InternalString(text))}))
}

/*
Gets the suffix string shown after the column value.
*/
//go:nosplit
func (self class) GetSuffix(column int64) String.Readable { //gd:TreeItem.get_suffix
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_suffix, gdextension.SizeString|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ column int64 }{column}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Sets the given cell's icon [Texture2D]. If the cell is in [constant CELL_MODE_ICON] mode, the icon is displayed in the center of the cell. Otherwise, the icon is displayed before the cell's text. [constant CELL_MODE_RANGE] does not display an icon.
*/
//go:nosplit
func (self class) SetIcon(column int64, texture [1]gdclass.Texture2D) { //gd:TreeItem.set_icon
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_icon, 0|(gdextension.SizeInt<<4)|(gdextension.SizeObject<<8), unsafe.Pointer(&struct {
		column  int64
		texture gdextension.Object
	}{column, gdextension.Object(gd.ObjectChecked(texture[0].AsObject()))}))
}

/*
Returns the given column's icon [Texture2D]. Error if no icon is set.
*/
//go:nosplit
func (self class) GetIcon(column int64) [1]gdclass.Texture2D { //gd:TreeItem.get_icon
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_icon, gdextension.SizeObject|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ column int64 }{column}))
	var ret = [1]gdclass.Texture2D{gd.PointerWithOwnershipTransferredToGo[gdclass.Texture2D](r_ret)}
	return ret
}

/*
Sets the given cell's icon overlay [Texture2D]. The cell has to be in [constant CELL_MODE_ICON] mode, and icon has to be set. Overlay is drawn on top of icon, in the bottom left corner.
*/
//go:nosplit
func (self class) SetIconOverlay(column int64, texture [1]gdclass.Texture2D) { //gd:TreeItem.set_icon_overlay
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_icon_overlay, 0|(gdextension.SizeInt<<4)|(gdextension.SizeObject<<8), unsafe.Pointer(&struct {
		column  int64
		texture gdextension.Object
	}{column, gdextension.Object(gd.ObjectChecked(texture[0].AsObject()))}))
}

/*
Returns the given column's icon overlay [Texture2D].
*/
//go:nosplit
func (self class) GetIconOverlay(column int64) [1]gdclass.Texture2D { //gd:TreeItem.get_icon_overlay
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_icon_overlay, gdextension.SizeObject|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ column int64 }{column}))
	var ret = [1]gdclass.Texture2D{gd.PointerWithOwnershipTransferredToGo[gdclass.Texture2D](r_ret)}
	return ret
}

/*
Sets the given column's icon's texture region.
*/
//go:nosplit
func (self class) SetIconRegion(column int64, region Rect2.PositionSize) { //gd:TreeItem.set_icon_region
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_icon_region, 0|(gdextension.SizeInt<<4)|(gdextension.SizeRect2<<8), unsafe.Pointer(&struct {
		column int64
		region Rect2.PositionSize
	}{column, region}))
}

/*
Returns the icon [Texture2D] region as [Rect2].
*/
//go:nosplit
func (self class) GetIconRegion(column int64) Rect2.PositionSize { //gd:TreeItem.get_icon_region
	var r_ret = gdextension.Call[Rect2.PositionSize](gd.ObjectChecked(self.AsObject()), methods.get_icon_region, gdextension.SizeRect2|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ column int64 }{column}))
	var ret = r_ret
	return ret
}

/*
Sets the maximum allowed width of the icon in the given [param column]. This limit is applied on top of the default size of the icon and on top of [theme_item Tree.icon_max_width]. The height is adjusted according to the icon's ratio.
*/
//go:nosplit
func (self class) SetIconMaxWidth(column int64, width int64) { //gd:TreeItem.set_icon_max_width
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_icon_max_width, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		column int64
		width  int64
	}{column, width}))
}

/*
Returns the maximum allowed width of the icon in the given [param column].
*/
//go:nosplit
func (self class) GetIconMaxWidth(column int64) int64 { //gd:TreeItem.get_icon_max_width
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_icon_max_width, gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ column int64 }{column}))
	var ret = r_ret
	return ret
}

/*
Modulates the given column's icon with [param modulate].
*/
//go:nosplit
func (self class) SetIconModulate(column int64, modulate Color.RGBA) { //gd:TreeItem.set_icon_modulate
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_icon_modulate, 0|(gdextension.SizeInt<<4)|(gdextension.SizeColor<<8), unsafe.Pointer(&struct {
		column   int64
		modulate Color.RGBA
	}{column, modulate}))
}

/*
Returns the [Color] modulating the column's icon.
*/
//go:nosplit
func (self class) GetIconModulate(column int64) Color.RGBA { //gd:TreeItem.get_icon_modulate
	var r_ret = gdextension.Call[Color.RGBA](gd.ObjectChecked(self.AsObject()), methods.get_icon_modulate, gdextension.SizeColor|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ column int64 }{column}))
	var ret = r_ret
	return ret
}

/*
Sets the value of a [constant CELL_MODE_RANGE] column.
*/
//go:nosplit
func (self class) SetRange(column int64, value float64) { //gd:TreeItem.set_range
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_range, 0|(gdextension.SizeInt<<4)|(gdextension.SizeFloat<<8), unsafe.Pointer(&struct {
		column int64
		value  float64
	}{column, value}))
}

/*
Returns the value of a [constant CELL_MODE_RANGE] column.
*/
//go:nosplit
func (self class) GetRange(column int64) float64 { //gd:TreeItem.get_range
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_range, gdextension.SizeFloat|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ column int64 }{column}))
	var ret = r_ret
	return ret
}

/*
Sets the range of accepted values for a column. The column must be in the [constant CELL_MODE_RANGE] mode.
If [param expr] is [code]true[/code], the edit mode slider will use an exponential scale as with [member Range.exp_edit].
*/
//go:nosplit
func (self class) SetRangeConfig(column int64, min float64, max float64, step float64, expr bool) { //gd:TreeItem.set_range_config
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_range_config, 0|(gdextension.SizeInt<<4)|(gdextension.SizeFloat<<8)|(gdextension.SizeFloat<<12)|(gdextension.SizeFloat<<16)|(gdextension.SizeBool<<20), unsafe.Pointer(&struct {
		column int64
		min    float64
		max    float64
		step   float64
		expr   bool
	}{column, min, max, step, expr}))
}

/*
Returns a dictionary containing the range parameters for a given column. The keys are "min", "max", "step", and "expr".
*/
//go:nosplit
func (self class) GetRangeConfig(column int64) Dictionary.Any { //gd:TreeItem.get_range_config
	var r_ret = gdextension.Call[gdextension.Dictionary](gd.ObjectChecked(self.AsObject()), methods.get_range_config, gdextension.SizeDictionary|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ column int64 }{column}))
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret)))
	return ret
}

/*
Sets the metadata value for the given column, which can be retrieved later using [method get_metadata]. This can be used, for example, to store a reference to the original data.
*/
//go:nosplit
func (self class) SetMetadata(column int64, meta variant.Any) { //gd:TreeItem.set_metadata
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_metadata, 0|(gdextension.SizeInt<<4)|(gdextension.SizeVariant<<8), unsafe.Pointer(&struct {
		column int64
		meta   gdextension.Variant
	}{column, gdextension.Variant(pointers.Get(gd.InternalVariant(meta)))}))
}

/*
Returns the metadata value that was set for the given column using [method set_metadata].
*/
//go:nosplit
func (self class) GetMetadata(column int64) variant.Any { //gd:TreeItem.get_metadata
	var r_ret = gdextension.Call[gdextension.Variant](gd.ObjectChecked(self.AsObject()), methods.get_metadata, gdextension.SizeVariant|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ column int64 }{column}))
	var ret = variant.Implementation(gd.VariantProxy{}, pointers.Pack(pointers.New[gd.Variant](r_ret)))
	return ret
}

/*
Sets the given column's custom draw callback to the [param callback] method on [param object].
The method named [param callback] should accept two arguments: the [TreeItem] that is drawn and its position and size as a [Rect2].
*/
//go:nosplit
func (self class) SetCustomDraw(column int64, obj [1]gd.Object, callback String.Name) { //gd:TreeItem.set_custom_draw
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_custom_draw, 0|(gdextension.SizeInt<<4)|(gdextension.SizeObject<<8)|(gdextension.SizeStringName<<12), unsafe.Pointer(&struct {
		column   int64
		obj      gdextension.Object
		callback gdextension.StringName
	}{column, gdextension.Object(gd.ObjectChecked(obj[0].AsObject())), pointers.Get(gd.InternalStringName(callback))}))
}

/*
Sets the given column's custom draw callback. Use an empty [Callable] ([code skip-lint]Callable()[/code]) to clear the custom callback. The cell has to be in [constant CELL_MODE_CUSTOM] to use this feature.
The [param callback] should accept two arguments: the [TreeItem] that is drawn and its position and size as a [Rect2].
*/
//go:nosplit
func (self class) SetCustomDrawCallback(column int64, callback Callable.Function) { //gd:TreeItem.set_custom_draw_callback
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_custom_draw_callback, 0|(gdextension.SizeInt<<4)|(gdextension.SizeCallable<<8), unsafe.Pointer(&struct {
		column   int64
		callback gdextension.Callable
	}{column, pointers.Get(gd.InternalCallable(callback))}))
}

/*
Returns the custom callback of column [param column].
*/
//go:nosplit
func (self class) GetCustomDrawCallback(column int64) Callable.Function { //gd:TreeItem.get_custom_draw_callback
	var r_ret = gdextension.Call[gdextension.Callable](gd.ObjectChecked(self.AsObject()), methods.get_custom_draw_callback, gdextension.SizeCallable|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ column int64 }{column}))
	var ret = Callable.Through(gd.CallableProxy{}, pointers.Pack(pointers.New[gd.Callable](r_ret)))
	return ret
}

//go:nosplit
func (self class) SetCollapsed(enable bool) { //gd:TreeItem.set_collapsed
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_collapsed, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

//go:nosplit
func (self class) IsCollapsed() bool { //gd:TreeItem.is_collapsed
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_collapsed, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Collapses or uncollapses this [TreeItem] and all the descendants of this item.
*/
//go:nosplit
func (self class) SetCollapsedRecursive(enable bool) { //gd:TreeItem.set_collapsed_recursive
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_collapsed_recursive, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

/*
Returns [code]true[/code] if this [TreeItem], or any of its descendants, is collapsed.
If [param only_visible] is [code]true[/code] it ignores non-visible [TreeItem]s.
*/
//go:nosplit
func (self class) IsAnyCollapsed(only_visible bool) bool { //gd:TreeItem.is_any_collapsed
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_any_collapsed, gdextension.SizeBool|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ only_visible bool }{only_visible}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetVisible(enable bool) { //gd:TreeItem.set_visible
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_visible, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

//go:nosplit
func (self class) IsVisible() bool { //gd:TreeItem.is_visible
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_visible, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if [member visible] is [code]true[/code] and all its ancestors are also visible.
*/
//go:nosplit
func (self class) IsVisibleInTree() bool { //gd:TreeItem.is_visible_in_tree
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_visible_in_tree, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Uncollapses all [TreeItem]s necessary to reveal this [TreeItem], i.e. all ancestor [TreeItem]s.
*/
//go:nosplit
func (self class) UncollapseTree() { //gd:TreeItem.uncollapse_tree
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.uncollapse_tree, 0, unsafe.Pointer(&struct{}{}))
}

//go:nosplit
func (self class) SetCustomMinimumHeight(height int64) { //gd:TreeItem.set_custom_minimum_height
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_custom_minimum_height, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ height int64 }{height}))
}

//go:nosplit
func (self class) GetCustomMinimumHeight() int64 { //gd:TreeItem.get_custom_minimum_height
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_custom_minimum_height, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
If [param selectable] is [code]true[/code], the given [param column] is selectable.
*/
//go:nosplit
func (self class) SetSelectable(column int64, selectable bool) { //gd:TreeItem.set_selectable
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_selectable, 0|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		column     int64
		selectable bool
	}{column, selectable}))
}

/*
Returns [code]true[/code] if the given [param column] is selectable.
*/
//go:nosplit
func (self class) IsSelectable(column int64) bool { //gd:TreeItem.is_selectable
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_selectable, gdextension.SizeBool|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ column int64 }{column}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if the given [param column] is selected.
*/
//go:nosplit
func (self class) IsSelected(column int64) bool { //gd:TreeItem.is_selected
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_selected, gdextension.SizeBool|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ column int64 }{column}))
	var ret = r_ret
	return ret
}

/*
Selects the given [param column].
*/
//go:nosplit
func (self class) Select(column int64) { //gd:TreeItem.select_
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.select_, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ column int64 }{column}))
}

/*
Deselects the given column.
*/
//go:nosplit
func (self class) Deselect(column int64) { //gd:TreeItem.deselect
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.deselect, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ column int64 }{column}))
}

/*
If [param enabled] is [code]true[/code], the given [param column] is editable.
*/
//go:nosplit
func (self class) SetEditable(column int64, enabled bool) { //gd:TreeItem.set_editable
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_editable, 0|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		column  int64
		enabled bool
	}{column, enabled}))
}

/*
Returns [code]true[/code] if the given [param column] is editable.
*/
//go:nosplit
func (self class) IsEditable(column int64) bool { //gd:TreeItem.is_editable
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_editable, gdextension.SizeBool|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ column int64 }{column}))
	var ret = r_ret
	return ret
}

/*
Sets the given column's custom color.
*/
//go:nosplit
func (self class) SetCustomColor(column int64, color Color.RGBA) { //gd:TreeItem.set_custom_color
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_custom_color, 0|(gdextension.SizeInt<<4)|(gdextension.SizeColor<<8), unsafe.Pointer(&struct {
		column int64
		color  Color.RGBA
	}{column, color}))
}

/*
Returns the custom color of column [param column].
*/
//go:nosplit
func (self class) GetCustomColor(column int64) Color.RGBA { //gd:TreeItem.get_custom_color
	var r_ret = gdextension.Call[Color.RGBA](gd.ObjectChecked(self.AsObject()), methods.get_custom_color, gdextension.SizeColor|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ column int64 }{column}))
	var ret = r_ret
	return ret
}

/*
Resets the color for the given column to default.
*/
//go:nosplit
func (self class) ClearCustomColor(column int64) { //gd:TreeItem.clear_custom_color
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.clear_custom_color, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ column int64 }{column}))
}

/*
Sets custom font used to draw text in the given [param column].
*/
//go:nosplit
func (self class) SetCustomFont(column int64, font [1]gdclass.Font) { //gd:TreeItem.set_custom_font
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_custom_font, 0|(gdextension.SizeInt<<4)|(gdextension.SizeObject<<8), unsafe.Pointer(&struct {
		column int64
		font   gdextension.Object
	}{column, gdextension.Object(gd.ObjectChecked(font[0].AsObject()))}))
}

/*
Returns custom font used to draw text in the column [param column].
*/
//go:nosplit
func (self class) GetCustomFont(column int64) [1]gdclass.Font { //gd:TreeItem.get_custom_font
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_custom_font, gdextension.SizeObject|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ column int64 }{column}))
	var ret = [1]gdclass.Font{gd.PointerWithOwnershipTransferredToGo[gdclass.Font](r_ret)}
	return ret
}

/*
Sets custom font size used to draw text in the given [param column].
*/
//go:nosplit
func (self class) SetCustomFontSize(column int64, font_size int64) { //gd:TreeItem.set_custom_font_size
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_custom_font_size, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		column    int64
		font_size int64
	}{column, font_size}))
}

/*
Returns custom font size used to draw text in the column [param column].
*/
//go:nosplit
func (self class) GetCustomFontSize(column int64) int64 { //gd:TreeItem.get_custom_font_size
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_custom_font_size, gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ column int64 }{column}))
	var ret = r_ret
	return ret
}

/*
Sets the given column's custom background color and whether to just use it as an outline.
*/
//go:nosplit
func (self class) SetCustomBgColor(column int64, color Color.RGBA, just_outline bool) { //gd:TreeItem.set_custom_bg_color
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_custom_bg_color, 0|(gdextension.SizeInt<<4)|(gdextension.SizeColor<<8)|(gdextension.SizeBool<<12), unsafe.Pointer(&struct {
		column       int64
		color        Color.RGBA
		just_outline bool
	}{column, color, just_outline}))
}

/*
Resets the background color for the given column to default.
*/
//go:nosplit
func (self class) ClearCustomBgColor(column int64) { //gd:TreeItem.clear_custom_bg_color
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.clear_custom_bg_color, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ column int64 }{column}))
}

/*
Returns the custom background color of column [param column].
*/
//go:nosplit
func (self class) GetCustomBgColor(column int64) Color.RGBA { //gd:TreeItem.get_custom_bg_color
	var r_ret = gdextension.Call[Color.RGBA](gd.ObjectChecked(self.AsObject()), methods.get_custom_bg_color, gdextension.SizeColor|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ column int64 }{column}))
	var ret = r_ret
	return ret
}

/*
Makes a cell with [constant CELL_MODE_CUSTOM] display as a non-flat button with a [StyleBox].
*/
//go:nosplit
func (self class) SetCustomAsButton(column int64, enable bool) { //gd:TreeItem.set_custom_as_button
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_custom_as_button, 0|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		column int64
		enable bool
	}{column, enable}))
}

/*
Returns [code]true[/code] if the cell was made into a button with [method set_custom_as_button].
*/
//go:nosplit
func (self class) IsCustomSetAsButton(column int64) bool { //gd:TreeItem.is_custom_set_as_button
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_custom_set_as_button, gdextension.SizeBool|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ column int64 }{column}))
	var ret = r_ret
	return ret
}

/*
Removes all buttons from all columns of this item.
*/
//go:nosplit
func (self class) ClearButtons() { //gd:TreeItem.clear_buttons
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.clear_buttons, 0, unsafe.Pointer(&struct{}{}))
}

/*
Adds a button with [Texture2D] [param button] to the end of the cell at column [param column]. The [param id] is used to identify the button in the according [signal Tree.button_clicked] signal and can be different from the buttons index. If not specified, the next available index is used, which may be retrieved by calling [method get_button_count] immediately before this method. Optionally, the button can be [param disabled] and have a [param tooltip_text].
*/
//go:nosplit
func (self class) AddButton(column int64, button [1]gdclass.Texture2D, id int64, disabled bool, tooltip_text String.Readable) { //gd:TreeItem.add_button
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_button, 0|(gdextension.SizeInt<<4)|(gdextension.SizeObject<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeBool<<16)|(gdextension.SizeString<<20), unsafe.Pointer(&struct {
		column       int64
		button       gdextension.Object
		id           int64
		disabled     bool
		tooltip_text gdextension.String
	}{column, gdextension.Object(gd.ObjectChecked(button[0].AsObject())), id, disabled, pointers.Get(gd.InternalString(tooltip_text))}))
}

/*
Returns the number of buttons in column [param column].
*/
//go:nosplit
func (self class) GetButtonCount(column int64) int64 { //gd:TreeItem.get_button_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_button_count, gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ column int64 }{column}))
	var ret = r_ret
	return ret
}

/*
Returns the tooltip text for the button at index [param button_index] in column [param column].
*/
//go:nosplit
func (self class) GetButtonTooltipText(column int64, button_index int64) String.Readable { //gd:TreeItem.get_button_tooltip_text
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_button_tooltip_text, gdextension.SizeString|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		column       int64
		button_index int64
	}{column, button_index}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Returns the ID for the button at index [param button_index] in column [param column].
*/
//go:nosplit
func (self class) GetButtonId(column int64, button_index int64) int64 { //gd:TreeItem.get_button_id
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_button_id, gdextension.SizeInt|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		column       int64
		button_index int64
	}{column, button_index}))
	var ret = r_ret
	return ret
}

/*
Returns the button index if there is a button with ID [param id] in column [param column], otherwise returns -1.
*/
//go:nosplit
func (self class) GetButtonById(column int64, id int64) int64 { //gd:TreeItem.get_button_by_id
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_button_by_id, gdextension.SizeInt|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		column int64
		id     int64
	}{column, id}))
	var ret = r_ret
	return ret
}

/*
Returns the color of the button with ID [param id] in column [param column]. If the specified button does not exist, returns [constant Color.BLACK].
*/
//go:nosplit
func (self class) GetButtonColor(column int64, id int64) Color.RGBA { //gd:TreeItem.get_button_color
	var r_ret = gdextension.Call[Color.RGBA](gd.ObjectChecked(self.AsObject()), methods.get_button_color, gdextension.SizeColor|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		column int64
		id     int64
	}{column, id}))
	var ret = r_ret
	return ret
}

/*
Returns the [Texture2D] of the button at index [param button_index] in column [param column].
*/
//go:nosplit
func (self class) GetButton(column int64, button_index int64) [1]gdclass.Texture2D { //gd:TreeItem.get_button
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_button, gdextension.SizeObject|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		column       int64
		button_index int64
	}{column, button_index}))
	var ret = [1]gdclass.Texture2D{gd.PointerWithOwnershipTransferredToGo[gdclass.Texture2D](r_ret)}
	return ret
}

/*
Sets the tooltip text for the button at index [param button_index] in the given [param column].
*/
//go:nosplit
func (self class) SetButtonTooltipText(column int64, button_index int64, tooltip String.Readable) { //gd:TreeItem.set_button_tooltip_text
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_button_tooltip_text, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeString<<12), unsafe.Pointer(&struct {
		column       int64
		button_index int64
		tooltip      gdextension.String
	}{column, button_index, pointers.Get(gd.InternalString(tooltip))}))
}

/*
Sets the given column's button [Texture2D] at index [param button_index] to [param button].
*/
//go:nosplit
func (self class) SetButton(column int64, button_index int64, button [1]gdclass.Texture2D) { //gd:TreeItem.set_button
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_button, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeObject<<12), unsafe.Pointer(&struct {
		column       int64
		button_index int64
		button       gdextension.Object
	}{column, button_index, gdextension.Object(gd.ObjectChecked(button[0].AsObject()))}))
}

/*
Removes the button at index [param button_index] in column [param column].
*/
//go:nosplit
func (self class) EraseButton(column int64, button_index int64) { //gd:TreeItem.erase_button
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.erase_button, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		column       int64
		button_index int64
	}{column, button_index}))
}

/*
If [code]true[/code], disables the button at index [param button_index] in the given [param column].
*/
//go:nosplit
func (self class) SetButtonDisabled(column int64, button_index int64, disabled bool) { //gd:TreeItem.set_button_disabled
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_button_disabled, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeBool<<12), unsafe.Pointer(&struct {
		column       int64
		button_index int64
		disabled     bool
	}{column, button_index, disabled}))
}

/*
Sets the given column's button color at index [param button_index] to [param color].
*/
//go:nosplit
func (self class) SetButtonColor(column int64, button_index int64, color Color.RGBA) { //gd:TreeItem.set_button_color
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_button_color, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeColor<<12), unsafe.Pointer(&struct {
		column       int64
		button_index int64
		color        Color.RGBA
	}{column, button_index, color}))
}

/*
Returns [code]true[/code] if the button at index [param button_index] for the given [param column] is disabled.
*/
//go:nosplit
func (self class) IsButtonDisabled(column int64, button_index int64) bool { //gd:TreeItem.is_button_disabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_button_disabled, gdextension.SizeBool|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		column       int64
		button_index int64
	}{column, button_index}))
	var ret = r_ret
	return ret
}

/*
Sets the given column's tooltip text.
*/
//go:nosplit
func (self class) SetTooltipText(column int64, tooltip String.Readable) { //gd:TreeItem.set_tooltip_text
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_tooltip_text, 0|(gdextension.SizeInt<<4)|(gdextension.SizeString<<8), unsafe.Pointer(&struct {
		column  int64
		tooltip gdextension.String
	}{column, pointers.Get(gd.InternalString(tooltip))}))
}

/*
Returns the given column's tooltip text.
*/
//go:nosplit
func (self class) GetTooltipText(column int64) String.Readable { //gd:TreeItem.get_tooltip_text
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_tooltip_text, gdextension.SizeString|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ column int64 }{column}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Sets the given column's text alignment. See [enum HorizontalAlignment] for possible values.
*/
//go:nosplit
func (self class) SetTextAlignment(column int64, text_alignment GUI.HorizontalAlignment) { //gd:TreeItem.set_text_alignment
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_text_alignment, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		column         int64
		text_alignment GUI.HorizontalAlignment
	}{column, text_alignment}))
}

/*
Returns the given column's text alignment.
*/
//go:nosplit
func (self class) GetTextAlignment(column int64) GUI.HorizontalAlignment { //gd:TreeItem.get_text_alignment
	var r_ret = gdextension.Call[GUI.HorizontalAlignment](gd.ObjectChecked(self.AsObject()), methods.get_text_alignment, gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ column int64 }{column}))
	var ret = r_ret
	return ret
}

/*
If [param enable] is [code]true[/code], the given [param column] is expanded to the right.
*/
//go:nosplit
func (self class) SetExpandRight(column int64, enable bool) { //gd:TreeItem.set_expand_right
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_expand_right, 0|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		column int64
		enable bool
	}{column, enable}))
}

/*
Returns [code]true[/code] if [code]expand_right[/code] is set.
*/
//go:nosplit
func (self class) GetExpandRight(column int64) bool { //gd:TreeItem.get_expand_right
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.get_expand_right, gdextension.SizeBool|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ column int64 }{column}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetDisableFolding(disable bool) { //gd:TreeItem.set_disable_folding
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_disable_folding, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ disable bool }{disable}))
}

//go:nosplit
func (self class) IsFoldingDisabled() bool { //gd:TreeItem.is_folding_disabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_folding_disabled, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Creates an item and adds it as a child.
The new item will be inserted as position [param index] (the default value [code]-1[/code] means the last position), or it will be the last child if [param index] is higher than the child count.
*/
//go:nosplit
func (self class) CreateChild(index int64) [1]gdclass.TreeItem { //gd:TreeItem.create_child
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.create_child, gdextension.SizeObject|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ index int64 }{index}))
	var ret = [1]gdclass.TreeItem{gd.PointerMustAssertInstanceID[gdclass.TreeItem](r_ret)}
	return ret
}

/*
Adds a previously unparented [TreeItem] as a direct child of this one. The [param child] item must not be a part of any [Tree] or parented to any [TreeItem]. See also [method remove_child].
*/
//go:nosplit
func (self class) AddChild(child [1]gdclass.TreeItem) { //gd:TreeItem.add_child
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_child, 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ child gdextension.Object }{gdextension.Object(gd.PointerWithOwnershipTransferredToGodot(child[0].AsObject()[0]))}))
}

/*
Removes the given child [TreeItem] and all its children from the [Tree]. Note that it doesn't free the item from memory, so it can be reused later (see [method add_child]). To completely remove a [TreeItem] use [method Object.free].
[b]Note:[/b] If you want to move a child from one [Tree] to another, then instead of removing and adding it manually you can use [method move_before] or [method move_after].
*/
//go:nosplit
func (self class) RemoveChild(child [1]gdclass.TreeItem) { //gd:TreeItem.remove_child
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.remove_child, 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ child gdextension.Object }{gdextension.Object(gd.ObjectChecked(child[0].AsObject()))}))
}

/*
Returns the [Tree] that owns this TreeItem.
*/
//go:nosplit
func (self class) GetTree() [1]gdclass.Tree { //gd:TreeItem.get_tree
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_tree, gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.Tree{gd.PointerMustAssertInstanceID[gdclass.Tree](r_ret)}
	return ret
}

/*
Returns the next sibling TreeItem in the tree or a [code]null[/code] object if there is none.
*/
//go:nosplit
func (self class) GetNext() [1]gdclass.TreeItem { //gd:TreeItem.get_next
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_next, gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.TreeItem{gd.PointerMustAssertInstanceID[gdclass.TreeItem](r_ret)}
	return ret
}

/*
Returns the previous sibling TreeItem in the tree or a [code]null[/code] object if there is none.
*/
//go:nosplit
func (self class) GetPrev() [1]gdclass.TreeItem { //gd:TreeItem.get_prev
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_prev, gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.TreeItem{gd.PointerMustAssertInstanceID[gdclass.TreeItem](r_ret)}
	return ret
}

/*
Returns the parent TreeItem or a [code]null[/code] object if there is none.
*/
//go:nosplit
func (self class) GetParent() [1]gdclass.TreeItem { //gd:TreeItem.get_parent
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_parent, gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.TreeItem{gd.PointerMustAssertInstanceID[gdclass.TreeItem](r_ret)}
	return ret
}

/*
Returns the TreeItem's first child.
*/
//go:nosplit
func (self class) GetFirstChild() [1]gdclass.TreeItem { //gd:TreeItem.get_first_child
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_first_child, gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.TreeItem{gd.PointerMustAssertInstanceID[gdclass.TreeItem](r_ret)}
	return ret
}

/*
Returns the next TreeItem in the tree (in the context of a depth-first search) or a [code]null[/code] object if there is none.
If [param wrap] is enabled, the method will wrap around to the first element in the tree when called on the last element, otherwise it returns [code]null[/code].
*/
//go:nosplit
func (self class) GetNextInTree(wrap bool) [1]gdclass.TreeItem { //gd:TreeItem.get_next_in_tree
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_next_in_tree, gdextension.SizeObject|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ wrap bool }{wrap}))
	var ret = [1]gdclass.TreeItem{gd.PointerMustAssertInstanceID[gdclass.TreeItem](r_ret)}
	return ret
}

/*
Returns the previous TreeItem in the tree (in the context of a depth-first search) or a [code]null[/code] object if there is none.
If [param wrap] is enabled, the method will wrap around to the last element in the tree when called on the first visible element, otherwise it returns [code]null[/code].
*/
//go:nosplit
func (self class) GetPrevInTree(wrap bool) [1]gdclass.TreeItem { //gd:TreeItem.get_prev_in_tree
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_prev_in_tree, gdextension.SizeObject|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ wrap bool }{wrap}))
	var ret = [1]gdclass.TreeItem{gd.PointerMustAssertInstanceID[gdclass.TreeItem](r_ret)}
	return ret
}

/*
Returns the next visible TreeItem in the tree (in the context of a depth-first search) or a [code]null[/code] object if there is none.
If [param wrap] is enabled, the method will wrap around to the first visible element in the tree when called on the last visible element, otherwise it returns [code]null[/code].
*/
//go:nosplit
func (self class) GetNextVisible(wrap bool) [1]gdclass.TreeItem { //gd:TreeItem.get_next_visible
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_next_visible, gdextension.SizeObject|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ wrap bool }{wrap}))
	var ret = [1]gdclass.TreeItem{gd.PointerMustAssertInstanceID[gdclass.TreeItem](r_ret)}
	return ret
}

/*
Returns the previous visible sibling TreeItem in the tree (in the context of a depth-first search) or a [code]null[/code] object if there is none.
If [param wrap] is enabled, the method will wrap around to the last visible element in the tree when called on the first visible element, otherwise it returns [code]null[/code].
*/
//go:nosplit
func (self class) GetPrevVisible(wrap bool) [1]gdclass.TreeItem { //gd:TreeItem.get_prev_visible
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_prev_visible, gdextension.SizeObject|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ wrap bool }{wrap}))
	var ret = [1]gdclass.TreeItem{gd.PointerMustAssertInstanceID[gdclass.TreeItem](r_ret)}
	return ret
}

/*
Returns a child item by its [param index] (see [method get_child_count]). This method is often used for iterating all children of an item.
Negative indices access the children from the last one.
*/
//go:nosplit
func (self class) GetChild(index int64) [1]gdclass.TreeItem { //gd:TreeItem.get_child
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_child, gdextension.SizeObject|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ index int64 }{index}))
	var ret = [1]gdclass.TreeItem{gd.PointerMustAssertInstanceID[gdclass.TreeItem](r_ret)}
	return ret
}

/*
Returns the number of child items.
*/
//go:nosplit
func (self class) GetChildCount() int64 { //gd:TreeItem.get_child_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_child_count, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns an array of references to the item's children.
*/
//go:nosplit
func (self class) GetChildren() Array.Contains[[1]gdclass.TreeItem] { //gd:TreeItem.get_children
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), methods.get_children, gdextension.SizeArray, unsafe.Pointer(&struct{}{}))
	var ret = Array.Through(gd.ArrayProxy[[1]gdclass.TreeItem]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

/*
Returns the node's order in the tree. For example, if called on the first child item the position is [code]0[/code].
*/
//go:nosplit
func (self class) GetIndex() int64 { //gd:TreeItem.get_index
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_index, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Moves this TreeItem right before the given [param item].
[b]Note:[/b] You can't move to the root or move the root.
*/
//go:nosplit
func (self class) MoveBefore(item [1]gdclass.TreeItem) { //gd:TreeItem.move_before
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.move_before, 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ item gdextension.Object }{gdextension.Object(gd.ObjectChecked(item[0].AsObject()))}))
}

/*
Moves this TreeItem right after the given [param item].
[b]Note:[/b] You can't move to the root or move the root.
*/
//go:nosplit
func (self class) MoveAfter(item [1]gdclass.TreeItem) { //gd:TreeItem.move_after
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.move_after, 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ item gdextension.Object }{gdextension.Object(gd.ObjectChecked(item[0].AsObject()))}))
}

/*
Calls the [param method] on the actual TreeItem and its children recursively. Pass parameters as a comma separated list.
*/
//go:nosplit
func (self class) CallRecursive(method String.Name, args ...gd.Variant) { //gd:TreeItem.call_recursive
	var fixed = [...]gdextension.Variant{gdextension.Variant(pointers.Get(gd.NewVariant(method)))}
	var dynamic []gdextension.Variant
	for _, arg := range args {
		dynamic = append(dynamic, gdextension.Variant(pointers.Get(gd.NewVariant(arg))))
	}
	ret, err := methods.call_recursive.Call(gd.ObjectChecked(self.AsObject()), append(fixed[:], dynamic...)...)
	if err != nil {
		panic(err)
	}
	_ = ret
}

func (self class) AsTreeItem() Advanced         { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsTreeItem() Instance      { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsTreeItem() Instance { return self.Super().AsTreeItem() }

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Object.Advanced(self.AsObject()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Object.Instance(self.AsObject()), name)
	}
}
func init() {
	gdclass.Register("TreeItem", func(ptr gd.Object) any { return *(*Instance)(unsafe.Pointer(&ptr)) })
}

type TreeCellMode int //gd:TreeItem.TreeCellMode

const (
	/*Cell shows a string label, optionally with an icon. When editable, the text can be edited using a [LineEdit], or a [TextEdit] popup if [method set_edit_multiline] is used.*/
	CellModeString TreeCellMode = 0
	/*Cell shows a checkbox, optionally with text and an icon. The checkbox can be pressed, released, or indeterminate (via [method set_indeterminate]). The checkbox can't be clicked unless the cell is editable.*/
	CellModeCheck TreeCellMode = 1
	/*Cell shows a numeric range. When editable, it can be edited using a range slider. Use [method set_range] to set the value and [method set_range_config] to configure the range.
	  This cell can also be used in a text dropdown mode when you assign a text with [method set_text]. Separate options with a comma, e.g. [code]"Option1,Option2,Option3"[/code].*/
	CellModeRange TreeCellMode = 2
	/*Cell shows an icon. It can't be edited nor display text. The icon is always centered within the cell.*/
	CellModeIcon TreeCellMode = 3
	/*Cell shows as a clickable button. It will display an arrow similar to [OptionButton], but doesn't feature a dropdown (for that you can use [constant CELL_MODE_RANGE]). Clicking the button emits the [signal Tree.item_edited] signal. The button is flat by default, you can use [method set_custom_as_button] to display it with a [StyleBox].
	  This mode also supports custom drawing using [method set_custom_draw_callback].*/
	CellModeCustom TreeCellMode = 4
)

type RangeConfig struct {
	Min  float32 `gd:"min"`
	Max  float32 `gd:"max"`
	Step float32 `gd:"step"`
	Expr string  `gd:"expr"`
}
