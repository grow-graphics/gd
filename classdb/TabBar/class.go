// Code generated by the generate package DO NOT EDIT

// Package TabBar provides methods for working with TabBar object instances.
package TabBar

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/CanvasItem"
import "graphics.gd/classdb/Control"
import "graphics.gd/classdb/Node"
import "graphics.gd/classdb/Texture2D"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/Rect2"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"
import "graphics.gd/variant/Vector2"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
A control that provides a horizontal bar with tabs. Similar to [TabContainer] but is only in charge of drawing tabs, not interacting with children.
*/
type Instance [1]gdclass.TabBar

func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

type Expanded [1]gdclass.TabBar

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsTabBar() Instance
}

/*
Returns the previously active tab index.
*/
func (self Instance) GetPreviousTab() int { //gd:TabBar.get_previous_tab
	return int(int(Advanced(self).GetPreviousTab()))
}

/*
Selects the first available tab with lower index than the currently selected. Returns [code]true[/code] if tab selection changed.
*/
func (self Instance) SelectPreviousAvailable() bool { //gd:TabBar.select_previous_available
	return bool(Advanced(self).SelectPreviousAvailable())
}

/*
Selects the first available tab with greater index than the currently selected. Returns [code]true[/code] if tab selection changed.
*/
func (self Instance) SelectNextAvailable() bool { //gd:TabBar.select_next_available
	return bool(Advanced(self).SelectNextAvailable())
}

/*
Sets a [param title] for the tab at index [param tab_idx].
*/
func (self Instance) SetTabTitle(tab_idx int, title string) { //gd:TabBar.set_tab_title
	Advanced(self).SetTabTitle(int64(tab_idx), String.New(title))
}

/*
Returns the title of the tab at index [param tab_idx].
*/
func (self Instance) GetTabTitle(tab_idx int) string { //gd:TabBar.get_tab_title
	return string(Advanced(self).GetTabTitle(int64(tab_idx)).String())
}

/*
Sets a [param tooltip] for tab at index [param tab_idx].
[b]Note:[/b] By default, if the [param tooltip] is empty and the tab text is truncated (not all characters fit into the tab), the title will be displayed as a tooltip. To hide the tooltip, assign [code]" "[/code] as the [param tooltip] text.
*/
func (self Instance) SetTabTooltip(tab_idx int, tooltip string) { //gd:TabBar.set_tab_tooltip
	Advanced(self).SetTabTooltip(int64(tab_idx), String.New(tooltip))
}

/*
Returns the tooltip text of the tab at index [param tab_idx].
*/
func (self Instance) GetTabTooltip(tab_idx int) string { //gd:TabBar.get_tab_tooltip
	return string(Advanced(self).GetTabTooltip(int64(tab_idx)).String())
}

/*
Sets tab title base writing direction.
*/
func (self Instance) SetTabTextDirection(tab_idx int, direction Control.TextDirection) { //gd:TabBar.set_tab_text_direction
	Advanced(self).SetTabTextDirection(int64(tab_idx), direction)
}

/*
Returns tab title text base writing direction.
*/
func (self Instance) GetTabTextDirection(tab_idx int) Control.TextDirection { //gd:TabBar.get_tab_text_direction
	return Control.TextDirection(Advanced(self).GetTabTextDirection(int64(tab_idx)))
}

/*
Sets language code of tab title used for line-breaking and text shaping algorithms, if left empty current locale is used instead.
*/
func (self Instance) SetTabLanguage(tab_idx int, language string) { //gd:TabBar.set_tab_language
	Advanced(self).SetTabLanguage(int64(tab_idx), String.New(language))
}

/*
Returns tab title language code.
*/
func (self Instance) GetTabLanguage(tab_idx int) string { //gd:TabBar.get_tab_language
	return string(Advanced(self).GetTabLanguage(int64(tab_idx)).String())
}

/*
Sets an [param icon] for the tab at index [param tab_idx].
*/
func (self Instance) SetTabIcon(tab_idx int, icon Texture2D.Instance) { //gd:TabBar.set_tab_icon
	Advanced(self).SetTabIcon(int64(tab_idx), icon)
}

/*
Returns the icon for the tab at index [param tab_idx] or [code]null[/code] if the tab has no icon.
*/
func (self Instance) GetTabIcon(tab_idx int) Texture2D.Instance { //gd:TabBar.get_tab_icon
	return Texture2D.Instance(Advanced(self).GetTabIcon(int64(tab_idx)))
}

/*
Sets the maximum allowed width of the icon for the tab at index [param tab_idx]. This limit is applied on top of the default size of the icon and on top of [theme_item icon_max_width]. The height is adjusted according to the icon's ratio.
*/
func (self Instance) SetTabIconMaxWidth(tab_idx int, width int) { //gd:TabBar.set_tab_icon_max_width
	Advanced(self).SetTabIconMaxWidth(int64(tab_idx), int64(width))
}

/*
Returns the maximum allowed width of the icon for the tab at index [param tab_idx].
*/
func (self Instance) GetTabIconMaxWidth(tab_idx int) int { //gd:TabBar.get_tab_icon_max_width
	return int(int(Advanced(self).GetTabIconMaxWidth(int64(tab_idx))))
}

/*
Sets an [param icon] for the button of the tab at index [param tab_idx] (located to the right, before the close button), making it visible and clickable (See [signal tab_button_pressed]). Giving it a [code]null[/code] value will hide the button.
*/
func (self Instance) SetTabButtonIcon(tab_idx int, icon Texture2D.Instance) { //gd:TabBar.set_tab_button_icon
	Advanced(self).SetTabButtonIcon(int64(tab_idx), icon)
}

/*
Returns the icon for the right button of the tab at index [param tab_idx] or [code]null[/code] if the right button has no icon.
*/
func (self Instance) GetTabButtonIcon(tab_idx int) Texture2D.Instance { //gd:TabBar.get_tab_button_icon
	return Texture2D.Instance(Advanced(self).GetTabButtonIcon(int64(tab_idx)))
}

/*
If [param disabled] is [code]true[/code], disables the tab at index [param tab_idx], making it non-interactable.
*/
func (self Instance) SetTabDisabled(tab_idx int, disabled bool) { //gd:TabBar.set_tab_disabled
	Advanced(self).SetTabDisabled(int64(tab_idx), disabled)
}

/*
Returns [code]true[/code] if the tab at index [param tab_idx] is disabled.
*/
func (self Instance) IsTabDisabled(tab_idx int) bool { //gd:TabBar.is_tab_disabled
	return bool(Advanced(self).IsTabDisabled(int64(tab_idx)))
}

/*
If [param hidden] is [code]true[/code], hides the tab at index [param tab_idx], making it disappear from the tab area.
*/
func (self Instance) SetTabHidden(tab_idx int, hidden bool) { //gd:TabBar.set_tab_hidden
	Advanced(self).SetTabHidden(int64(tab_idx), hidden)
}

/*
Returns [code]true[/code] if the tab at index [param tab_idx] is hidden.
*/
func (self Instance) IsTabHidden(tab_idx int) bool { //gd:TabBar.is_tab_hidden
	return bool(Advanced(self).IsTabHidden(int64(tab_idx)))
}

/*
Sets the metadata value for the tab at index [param tab_idx], which can be retrieved later using [method get_tab_metadata].
*/
func (self Instance) SetTabMetadata(tab_idx int, metadata any) { //gd:TabBar.set_tab_metadata
	Advanced(self).SetTabMetadata(int64(tab_idx), variant.New(metadata))
}

/*
Returns the metadata value set to the tab at index [param tab_idx] using [method set_tab_metadata]. If no metadata was previously set, returns [code]null[/code] by default.
*/
func (self Instance) GetTabMetadata(tab_idx int) any { //gd:TabBar.get_tab_metadata
	return any(Advanced(self).GetTabMetadata(int64(tab_idx)).Interface())
}

/*
Removes the tab at index [param tab_idx].
*/
func (self Instance) RemoveTab(tab_idx int) { //gd:TabBar.remove_tab
	Advanced(self).RemoveTab(int64(tab_idx))
}

/*
Adds a new tab.
*/
func (self Instance) AddTab() { //gd:TabBar.add_tab
	Advanced(self).AddTab(String.New(""), [1]Texture2D.Instance{}[0])
}

/*
Adds a new tab.
*/
func (self Expanded) AddTab(title string, icon Texture2D.Instance) { //gd:TabBar.add_tab
	Advanced(self).AddTab(String.New(title), icon)
}

/*
Returns the index of the tab at local coordinates [param point]. Returns [code]-1[/code] if the point is outside the control boundaries or if there's no tab at the queried position.
*/
func (self Instance) GetTabIdxAtPoint(point Vector2.XY) int { //gd:TabBar.get_tab_idx_at_point
	return int(int(Advanced(self).GetTabIdxAtPoint(Vector2.XY(point))))
}

/*
Returns the number of hidden tabs offsetted to the left.
*/
func (self Instance) GetTabOffset() int { //gd:TabBar.get_tab_offset
	return int(int(Advanced(self).GetTabOffset()))
}

/*
Returns [code]true[/code] if the offset buttons (the ones that appear when there's not enough space for all tabs) are visible.
*/
func (self Instance) GetOffsetButtonsVisible() bool { //gd:TabBar.get_offset_buttons_visible
	return bool(Advanced(self).GetOffsetButtonsVisible())
}

/*
Moves the scroll view to make the tab visible.
*/
func (self Instance) EnsureTabVisible(idx int) { //gd:TabBar.ensure_tab_visible
	Advanced(self).EnsureTabVisible(int64(idx))
}

/*
Returns tab [Rect2] with local position and size.
*/
func (self Instance) GetTabRect(tab_idx int) Rect2.PositionSize { //gd:TabBar.get_tab_rect
	return Rect2.PositionSize(Advanced(self).GetTabRect(int64(tab_idx)))
}

/*
Moves a tab from [param from] to [param to].
*/
func (self Instance) MoveTab(from int, to int) { //gd:TabBar.move_tab
	Advanced(self).MoveTab(int64(from), int64(to))
}

/*
Clears all tabs.
*/
func (self Instance) ClearTabs() { //gd:TabBar.clear_tabs
	Advanced(self).ClearTabs()
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.TabBar

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {
	object := gd.Global.ClassDB.ConstructObject(gd.NewStringName("TabBar"))
	casted := Instance{*(*gdclass.TabBar)(unsafe.Pointer(&object))}
	return casted
}

func (self Instance) CurrentTab() int {
	return int(int(class(self).GetCurrentTab()))
}

func (self Instance) SetCurrentTab(value int) {
	class(self).SetCurrentTab(int64(value))
}

func (self Instance) TabAlignment() AlignmentMode {
	return AlignmentMode(class(self).GetTabAlignment())
}

func (self Instance) SetTabAlignment(value AlignmentMode) {
	class(self).SetTabAlignment(value)
}

func (self Instance) ClipTabs() bool {
	return bool(class(self).GetClipTabs())
}

func (self Instance) SetClipTabs(value bool) {
	class(self).SetClipTabs(value)
}

func (self Instance) TabCloseDisplayPolicy() CloseButtonDisplayPolicy {
	return CloseButtonDisplayPolicy(class(self).GetTabCloseDisplayPolicy())
}

func (self Instance) SetTabCloseDisplayPolicy(value CloseButtonDisplayPolicy) {
	class(self).SetTabCloseDisplayPolicy(value)
}

func (self Instance) MaxTabWidth() int {
	return int(int(class(self).GetMaxTabWidth()))
}

func (self Instance) SetMaxTabWidth(value int) {
	class(self).SetMaxTabWidth(int64(value))
}

func (self Instance) ScrollingEnabled() bool {
	return bool(class(self).GetScrollingEnabled())
}

func (self Instance) SetScrollingEnabled(value bool) {
	class(self).SetScrollingEnabled(value)
}

func (self Instance) DragToRearrangeEnabled() bool {
	return bool(class(self).GetDragToRearrangeEnabled())
}

func (self Instance) SetDragToRearrangeEnabled(value bool) {
	class(self).SetDragToRearrangeEnabled(value)
}

func (self Instance) TabsRearrangeGroup() int {
	return int(int(class(self).GetTabsRearrangeGroup()))
}

func (self Instance) SetTabsRearrangeGroup(value int) {
	class(self).SetTabsRearrangeGroup(int64(value))
}

func (self Instance) ScrollToSelected() bool {
	return bool(class(self).GetScrollToSelected())
}

func (self Instance) SetScrollToSelected(value bool) {
	class(self).SetScrollToSelected(value)
}

func (self Instance) SelectWithRmb() bool {
	return bool(class(self).GetSelectWithRmb())
}

func (self Instance) SetSelectWithRmb(value bool) {
	class(self).SetSelectWithRmb(value)
}

func (self Instance) DeselectEnabled() bool {
	return bool(class(self).GetDeselectEnabled())
}

func (self Instance) SetDeselectEnabled(value bool) {
	class(self).SetDeselectEnabled(value)
}

func (self Instance) TabCount() int {
	return int(int(class(self).GetTabCount()))
}

func (self Instance) SetTabCount(value int) {
	class(self).SetTabCount(int64(value))
}

//go:nosplit
func (self class) SetTabCount(count int64) { //gd:TabBar.set_tab_count
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TabBar.Bind_set_tab_count), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ count int64 }{count}))
}

//go:nosplit
func (self class) GetTabCount() int64 { //gd:TabBar.get_tab_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TabBar.Bind_get_tab_count), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetCurrentTab(tab_idx int64) { //gd:TabBar.set_current_tab
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TabBar.Bind_set_current_tab), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ tab_idx int64 }{tab_idx}))
}

//go:nosplit
func (self class) GetCurrentTab() int64 { //gd:TabBar.get_current_tab
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TabBar.Bind_get_current_tab), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the previously active tab index.
*/
//go:nosplit
func (self class) GetPreviousTab() int64 { //gd:TabBar.get_previous_tab
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TabBar.Bind_get_previous_tab), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Selects the first available tab with lower index than the currently selected. Returns [code]true[/code] if tab selection changed.
*/
//go:nosplit
func (self class) SelectPreviousAvailable() bool { //gd:TabBar.select_previous_available
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TabBar.Bind_select_previous_available), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Selects the first available tab with greater index than the currently selected. Returns [code]true[/code] if tab selection changed.
*/
//go:nosplit
func (self class) SelectNextAvailable() bool { //gd:TabBar.select_next_available
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TabBar.Bind_select_next_available), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Sets a [param title] for the tab at index [param tab_idx].
*/
//go:nosplit
func (self class) SetTabTitle(tab_idx int64, title String.Readable) { //gd:TabBar.set_tab_title
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TabBar.Bind_set_tab_title), 0|(gdextension.SizeInt<<4)|(gdextension.SizeString<<8), unsafe.Pointer(&struct {
		tab_idx int64
		title   gdextension.String
	}{tab_idx, gdextension.String(pointers.Get(gd.InternalString(title))[0])}))
}

/*
Returns the title of the tab at index [param tab_idx].
*/
//go:nosplit
func (self class) GetTabTitle(tab_idx int64) String.Readable { //gd:TabBar.get_tab_title
	var r_ret = gdextension.Call[[1]gd.EnginePointer](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TabBar.Bind_get_tab_title), gdextension.SizeString|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ tab_idx int64 }{tab_idx}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Sets a [param tooltip] for tab at index [param tab_idx].
[b]Note:[/b] By default, if the [param tooltip] is empty and the tab text is truncated (not all characters fit into the tab), the title will be displayed as a tooltip. To hide the tooltip, assign [code]" "[/code] as the [param tooltip] text.
*/
//go:nosplit
func (self class) SetTabTooltip(tab_idx int64, tooltip String.Readable) { //gd:TabBar.set_tab_tooltip
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TabBar.Bind_set_tab_tooltip), 0|(gdextension.SizeInt<<4)|(gdextension.SizeString<<8), unsafe.Pointer(&struct {
		tab_idx int64
		tooltip gdextension.String
	}{tab_idx, gdextension.String(pointers.Get(gd.InternalString(tooltip))[0])}))
}

/*
Returns the tooltip text of the tab at index [param tab_idx].
*/
//go:nosplit
func (self class) GetTabTooltip(tab_idx int64) String.Readable { //gd:TabBar.get_tab_tooltip
	var r_ret = gdextension.Call[[1]gd.EnginePointer](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TabBar.Bind_get_tab_tooltip), gdextension.SizeString|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ tab_idx int64 }{tab_idx}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Sets tab title base writing direction.
*/
//go:nosplit
func (self class) SetTabTextDirection(tab_idx int64, direction Control.TextDirection) { //gd:TabBar.set_tab_text_direction
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TabBar.Bind_set_tab_text_direction), 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		tab_idx   int64
		direction Control.TextDirection
	}{tab_idx, direction}))
}

/*
Returns tab title text base writing direction.
*/
//go:nosplit
func (self class) GetTabTextDirection(tab_idx int64) Control.TextDirection { //gd:TabBar.get_tab_text_direction
	var r_ret = gdextension.Call[Control.TextDirection](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TabBar.Bind_get_tab_text_direction), gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ tab_idx int64 }{tab_idx}))
	var ret = r_ret
	return ret
}

/*
Sets language code of tab title used for line-breaking and text shaping algorithms, if left empty current locale is used instead.
*/
//go:nosplit
func (self class) SetTabLanguage(tab_idx int64, language String.Readable) { //gd:TabBar.set_tab_language
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TabBar.Bind_set_tab_language), 0|(gdextension.SizeInt<<4)|(gdextension.SizeString<<8), unsafe.Pointer(&struct {
		tab_idx  int64
		language gdextension.String
	}{tab_idx, gdextension.String(pointers.Get(gd.InternalString(language))[0])}))
}

/*
Returns tab title language code.
*/
//go:nosplit
func (self class) GetTabLanguage(tab_idx int64) String.Readable { //gd:TabBar.get_tab_language
	var r_ret = gdextension.Call[[1]gd.EnginePointer](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TabBar.Bind_get_tab_language), gdextension.SizeString|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ tab_idx int64 }{tab_idx}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Sets an [param icon] for the tab at index [param tab_idx].
*/
//go:nosplit
func (self class) SetTabIcon(tab_idx int64, icon [1]gdclass.Texture2D) { //gd:TabBar.set_tab_icon
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TabBar.Bind_set_tab_icon), 0|(gdextension.SizeInt<<4)|(gdextension.SizeObject<<8), unsafe.Pointer(&struct {
		tab_idx int64
		icon    gdextension.Object
	}{tab_idx, gdextension.Object(gd.ObjectChecked(icon[0].AsObject()))}))
}

/*
Returns the icon for the tab at index [param tab_idx] or [code]null[/code] if the tab has no icon.
*/
//go:nosplit
func (self class) GetTabIcon(tab_idx int64) [1]gdclass.Texture2D { //gd:TabBar.get_tab_icon
	var r_ret = gdextension.Call[gd.EnginePointer](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TabBar.Bind_get_tab_icon), gdextension.SizeObject|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ tab_idx int64 }{tab_idx}))
	var ret = [1]gdclass.Texture2D{gd.PointerWithOwnershipTransferredToGo[gdclass.Texture2D](r_ret)}
	return ret
}

/*
Sets the maximum allowed width of the icon for the tab at index [param tab_idx]. This limit is applied on top of the default size of the icon and on top of [theme_item icon_max_width]. The height is adjusted according to the icon's ratio.
*/
//go:nosplit
func (self class) SetTabIconMaxWidth(tab_idx int64, width int64) { //gd:TabBar.set_tab_icon_max_width
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TabBar.Bind_set_tab_icon_max_width), 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		tab_idx int64
		width   int64
	}{tab_idx, width}))
}

/*
Returns the maximum allowed width of the icon for the tab at index [param tab_idx].
*/
//go:nosplit
func (self class) GetTabIconMaxWidth(tab_idx int64) int64 { //gd:TabBar.get_tab_icon_max_width
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TabBar.Bind_get_tab_icon_max_width), gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ tab_idx int64 }{tab_idx}))
	var ret = r_ret
	return ret
}

/*
Sets an [param icon] for the button of the tab at index [param tab_idx] (located to the right, before the close button), making it visible and clickable (See [signal tab_button_pressed]). Giving it a [code]null[/code] value will hide the button.
*/
//go:nosplit
func (self class) SetTabButtonIcon(tab_idx int64, icon [1]gdclass.Texture2D) { //gd:TabBar.set_tab_button_icon
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TabBar.Bind_set_tab_button_icon), 0|(gdextension.SizeInt<<4)|(gdextension.SizeObject<<8), unsafe.Pointer(&struct {
		tab_idx int64
		icon    gdextension.Object
	}{tab_idx, gdextension.Object(gd.ObjectChecked(icon[0].AsObject()))}))
}

/*
Returns the icon for the right button of the tab at index [param tab_idx] or [code]null[/code] if the right button has no icon.
*/
//go:nosplit
func (self class) GetTabButtonIcon(tab_idx int64) [1]gdclass.Texture2D { //gd:TabBar.get_tab_button_icon
	var r_ret = gdextension.Call[gd.EnginePointer](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TabBar.Bind_get_tab_button_icon), gdextension.SizeObject|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ tab_idx int64 }{tab_idx}))
	var ret = [1]gdclass.Texture2D{gd.PointerWithOwnershipTransferredToGo[gdclass.Texture2D](r_ret)}
	return ret
}

/*
If [param disabled] is [code]true[/code], disables the tab at index [param tab_idx], making it non-interactable.
*/
//go:nosplit
func (self class) SetTabDisabled(tab_idx int64, disabled bool) { //gd:TabBar.set_tab_disabled
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TabBar.Bind_set_tab_disabled), 0|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		tab_idx  int64
		disabled bool
	}{tab_idx, disabled}))
}

/*
Returns [code]true[/code] if the tab at index [param tab_idx] is disabled.
*/
//go:nosplit
func (self class) IsTabDisabled(tab_idx int64) bool { //gd:TabBar.is_tab_disabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TabBar.Bind_is_tab_disabled), gdextension.SizeBool|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ tab_idx int64 }{tab_idx}))
	var ret = r_ret
	return ret
}

/*
If [param hidden] is [code]true[/code], hides the tab at index [param tab_idx], making it disappear from the tab area.
*/
//go:nosplit
func (self class) SetTabHidden(tab_idx int64, hidden bool) { //gd:TabBar.set_tab_hidden
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TabBar.Bind_set_tab_hidden), 0|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		tab_idx int64
		hidden  bool
	}{tab_idx, hidden}))
}

/*
Returns [code]true[/code] if the tab at index [param tab_idx] is hidden.
*/
//go:nosplit
func (self class) IsTabHidden(tab_idx int64) bool { //gd:TabBar.is_tab_hidden
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TabBar.Bind_is_tab_hidden), gdextension.SizeBool|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ tab_idx int64 }{tab_idx}))
	var ret = r_ret
	return ret
}

/*
Sets the metadata value for the tab at index [param tab_idx], which can be retrieved later using [method get_tab_metadata].
*/
//go:nosplit
func (self class) SetTabMetadata(tab_idx int64, metadata variant.Any) { //gd:TabBar.set_tab_metadata
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TabBar.Bind_set_tab_metadata), 0|(gdextension.SizeInt<<4)|(gdextension.SizeVariant<<8), unsafe.Pointer(&struct {
		tab_idx  int64
		metadata gdextension.Variant
	}{tab_idx, gdextension.Variant(pointers.Get(gd.InternalVariant(metadata)))}))
}

/*
Returns the metadata value set to the tab at index [param tab_idx] using [method set_tab_metadata]. If no metadata was previously set, returns [code]null[/code] by default.
*/
//go:nosplit
func (self class) GetTabMetadata(tab_idx int64) variant.Any { //gd:TabBar.get_tab_metadata
	var r_ret = gdextension.Call[[3]uint64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TabBar.Bind_get_tab_metadata), gdextension.SizeVariant|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ tab_idx int64 }{tab_idx}))
	var ret = variant.Implementation(gd.VariantProxy{}, pointers.Pack(pointers.New[gd.Variant](r_ret)))
	return ret
}

/*
Removes the tab at index [param tab_idx].
*/
//go:nosplit
func (self class) RemoveTab(tab_idx int64) { //gd:TabBar.remove_tab
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TabBar.Bind_remove_tab), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ tab_idx int64 }{tab_idx}))
}

/*
Adds a new tab.
*/
//go:nosplit
func (self class) AddTab(title String.Readable, icon [1]gdclass.Texture2D) { //gd:TabBar.add_tab
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TabBar.Bind_add_tab), 0|(gdextension.SizeString<<4)|(gdextension.SizeObject<<8), unsafe.Pointer(&struct {
		title gdextension.String
		icon  gdextension.Object
	}{gdextension.String(pointers.Get(gd.InternalString(title))[0]), gdextension.Object(gd.ObjectChecked(icon[0].AsObject()))}))
}

/*
Returns the index of the tab at local coordinates [param point]. Returns [code]-1[/code] if the point is outside the control boundaries or if there's no tab at the queried position.
*/
//go:nosplit
func (self class) GetTabIdxAtPoint(point Vector2.XY) int64 { //gd:TabBar.get_tab_idx_at_point
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TabBar.Bind_get_tab_idx_at_point), gdextension.SizeInt|(gdextension.SizeVector2<<4), unsafe.Pointer(&struct{ point Vector2.XY }{point}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetTabAlignment(alignment AlignmentMode) { //gd:TabBar.set_tab_alignment
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TabBar.Bind_set_tab_alignment), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ alignment AlignmentMode }{alignment}))
}

//go:nosplit
func (self class) GetTabAlignment() AlignmentMode { //gd:TabBar.get_tab_alignment
	var r_ret = gdextension.Call[AlignmentMode](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TabBar.Bind_get_tab_alignment), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetClipTabs(clip_tabs bool) { //gd:TabBar.set_clip_tabs
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TabBar.Bind_set_clip_tabs), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ clip_tabs bool }{clip_tabs}))
}

//go:nosplit
func (self class) GetClipTabs() bool { //gd:TabBar.get_clip_tabs
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TabBar.Bind_get_clip_tabs), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the number of hidden tabs offsetted to the left.
*/
//go:nosplit
func (self class) GetTabOffset() int64 { //gd:TabBar.get_tab_offset
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TabBar.Bind_get_tab_offset), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if the offset buttons (the ones that appear when there's not enough space for all tabs) are visible.
*/
//go:nosplit
func (self class) GetOffsetButtonsVisible() bool { //gd:TabBar.get_offset_buttons_visible
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TabBar.Bind_get_offset_buttons_visible), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Moves the scroll view to make the tab visible.
*/
//go:nosplit
func (self class) EnsureTabVisible(idx int64) { //gd:TabBar.ensure_tab_visible
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TabBar.Bind_ensure_tab_visible), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ idx int64 }{idx}))
}

/*
Returns tab [Rect2] with local position and size.
*/
//go:nosplit
func (self class) GetTabRect(tab_idx int64) Rect2.PositionSize { //gd:TabBar.get_tab_rect
	var r_ret = gdextension.Call[Rect2.PositionSize](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TabBar.Bind_get_tab_rect), gdextension.SizeRect2|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ tab_idx int64 }{tab_idx}))
	var ret = r_ret
	return ret
}

/*
Moves a tab from [param from] to [param to].
*/
//go:nosplit
func (self class) MoveTab(from int64, to int64) { //gd:TabBar.move_tab
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TabBar.Bind_move_tab), 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		from int64
		to   int64
	}{from, to}))
}

//go:nosplit
func (self class) SetTabCloseDisplayPolicy(policy CloseButtonDisplayPolicy) { //gd:TabBar.set_tab_close_display_policy
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TabBar.Bind_set_tab_close_display_policy), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ policy CloseButtonDisplayPolicy }{policy}))
}

//go:nosplit
func (self class) GetTabCloseDisplayPolicy() CloseButtonDisplayPolicy { //gd:TabBar.get_tab_close_display_policy
	var r_ret = gdextension.Call[CloseButtonDisplayPolicy](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TabBar.Bind_get_tab_close_display_policy), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetMaxTabWidth(width int64) { //gd:TabBar.set_max_tab_width
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TabBar.Bind_set_max_tab_width), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ width int64 }{width}))
}

//go:nosplit
func (self class) GetMaxTabWidth() int64 { //gd:TabBar.get_max_tab_width
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TabBar.Bind_get_max_tab_width), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetScrollingEnabled(enabled bool) { //gd:TabBar.set_scrolling_enabled
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TabBar.Bind_set_scrolling_enabled), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enabled bool }{enabled}))
}

//go:nosplit
func (self class) GetScrollingEnabled() bool { //gd:TabBar.get_scrolling_enabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TabBar.Bind_get_scrolling_enabled), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetDragToRearrangeEnabled(enabled bool) { //gd:TabBar.set_drag_to_rearrange_enabled
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TabBar.Bind_set_drag_to_rearrange_enabled), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enabled bool }{enabled}))
}

//go:nosplit
func (self class) GetDragToRearrangeEnabled() bool { //gd:TabBar.get_drag_to_rearrange_enabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TabBar.Bind_get_drag_to_rearrange_enabled), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetTabsRearrangeGroup(group_id int64) { //gd:TabBar.set_tabs_rearrange_group
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TabBar.Bind_set_tabs_rearrange_group), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ group_id int64 }{group_id}))
}

//go:nosplit
func (self class) GetTabsRearrangeGroup() int64 { //gd:TabBar.get_tabs_rearrange_group
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TabBar.Bind_get_tabs_rearrange_group), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetScrollToSelected(enabled bool) { //gd:TabBar.set_scroll_to_selected
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TabBar.Bind_set_scroll_to_selected), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enabled bool }{enabled}))
}

//go:nosplit
func (self class) GetScrollToSelected() bool { //gd:TabBar.get_scroll_to_selected
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TabBar.Bind_get_scroll_to_selected), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetSelectWithRmb(enabled bool) { //gd:TabBar.set_select_with_rmb
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TabBar.Bind_set_select_with_rmb), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enabled bool }{enabled}))
}

//go:nosplit
func (self class) GetSelectWithRmb() bool { //gd:TabBar.get_select_with_rmb
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TabBar.Bind_get_select_with_rmb), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetDeselectEnabled(enabled bool) { //gd:TabBar.set_deselect_enabled
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TabBar.Bind_set_deselect_enabled), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enabled bool }{enabled}))
}

//go:nosplit
func (self class) GetDeselectEnabled() bool { //gd:TabBar.get_deselect_enabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TabBar.Bind_get_deselect_enabled), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Clears all tabs.
*/
//go:nosplit
func (self class) ClearTabs() { //gd:TabBar.clear_tabs
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TabBar.Bind_clear_tabs), 0, unsafe.Pointer(&struct{}{}))
}
func (self Instance) OnTabSelected(cb func(tab int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("tab_selected"), gd.NewCallable(cb), 0)
}

func (self Instance) OnTabChanged(cb func(tab int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("tab_changed"), gd.NewCallable(cb), 0)
}

func (self Instance) OnTabClicked(cb func(tab int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("tab_clicked"), gd.NewCallable(cb), 0)
}

func (self Instance) OnTabRmbClicked(cb func(tab int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("tab_rmb_clicked"), gd.NewCallable(cb), 0)
}

func (self Instance) OnTabClosePressed(cb func(tab int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("tab_close_pressed"), gd.NewCallable(cb), 0)
}

func (self Instance) OnTabButtonPressed(cb func(tab int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("tab_button_pressed"), gd.NewCallable(cb), 0)
}

func (self Instance) OnTabHovered(cb func(tab int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("tab_hovered"), gd.NewCallable(cb), 0)
}

func (self Instance) OnActiveTabRearranged(cb func(idx_to int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("active_tab_rearranged"), gd.NewCallable(cb), 0)
}

func (self class) AsTabBar() Advanced                  { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsTabBar() Instance               { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsTabBar() Instance          { return self.Super().AsTabBar() }
func (self class) AsControl() Control.Advanced         { return *((*Control.Advanced)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsControl() Control.Instance { return self.Super().AsControl() }
func (self Instance) AsControl() Control.Instance {
	return *((*Control.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsCanvasItem() CanvasItem.Advanced {
	return *((*CanvasItem.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsCanvasItem() CanvasItem.Instance { return self.Super().AsCanvasItem() }
func (self Instance) AsCanvasItem() CanvasItem.Instance {
	return *((*CanvasItem.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsNode() Node.Advanced         { return *((*Node.Advanced)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsNode() Node.Instance { return self.Super().AsNode() }
func (self Instance) AsNode() Node.Instance      { return *((*Node.Instance)(unsafe.Pointer(&self))) }

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Control.Advanced(self.AsControl()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Control.Instance(self.AsControl()), name)
	}
}
func init() {
	gdclass.Register("TabBar", func(ptr gd.Object) any { return [1]gdclass.TabBar{*(*gdclass.TabBar)(unsafe.Pointer(&ptr))} })
}

type AlignmentMode int //gd:TabBar.AlignmentMode

const (
	/*Places tabs to the left.*/
	AlignmentLeft AlignmentMode = 0
	/*Places tabs in the middle.*/
	AlignmentCenter AlignmentMode = 1
	/*Places tabs to the right.*/
	AlignmentRight AlignmentMode = 2
	/*Represents the size of the [enum AlignmentMode] enum.*/
	AlignmentMax AlignmentMode = 3
)

type CloseButtonDisplayPolicy int //gd:TabBar.CloseButtonDisplayPolicy

const (
	/*Never show the close buttons.*/
	CloseButtonShowNever CloseButtonDisplayPolicy = 0
	/*Only show the close button on the currently active tab.*/
	CloseButtonShowActiveOnly CloseButtonDisplayPolicy = 1
	/*Show the close button on all tabs.*/
	CloseButtonShowAlways CloseButtonDisplayPolicy = 2
	/*Represents the size of the [enum CloseButtonDisplayPolicy] enum.*/
	CloseButtonMax CloseButtonDisplayPolicy = 3
)
