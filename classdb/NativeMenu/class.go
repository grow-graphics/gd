// Code generated by the generate package DO NOT EDIT

// Package NativeMenu provides methods for working with NativeMenu object instances.
package NativeMenu

import "unsafe"
import "sync"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/variant/Signal"
import "graphics.gd/classdb/Input"
import "graphics.gd/classdb/Texture2D"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"
import "graphics.gd/variant/Vector2"
import "graphics.gd/variant/Vector2i"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Signal.Any
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
[NativeMenu] handles low-level access to the OS native global menu bar and popup menus.
[b]Note:[/b] This is low-level API, consider using [MenuBar] with [member MenuBar.prefer_global_menu] set to [code]true[/code], and [PopupMenu] with [member PopupMenu.prefer_native_menu] set to [code]true[/code].
To create a menu, use [method create_menu], add menu items using [code]add_*_item[/code] methods. To remove a menu, use [method free_menu].
[codeblock]
var menu

func _menu_callback(item_id):

	if item_id == "ITEM_CUT":
	    cut()
	elif item_id == "ITEM_COPY":
	    copy()
	elif item_id == "ITEM_PASTE":
	    paste()

func _enter_tree():

	# Create new menu and add items:
	menu = NativeMenu.create_menu()
	NativeMenu.add_item(menu, "Cut", _menu_callback, Callable(), "ITEM_CUT")
	NativeMenu.add_item(menu, "Copy", _menu_callback, Callable(), "ITEM_COPY")
	NativeMenu.add_separator(menu)
	NativeMenu.add_item(menu, "Paste", _menu_callback, Callable(), "ITEM_PASTE")

func _on_button_pressed():

	# Show popup menu at mouse position:
	NativeMenu.popup(menu, DisplayServer.mouse_get_position())

func _exit_tree():

	# Remove menu when it's no longer needed:
	NativeMenu.free_menu(menu)

[/codeblock]
*/
type Instance [1]gdclass.NativeMenu

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	has_feature                  gdextension.MethodForClass `hash:"1708975490"`
	has_system_menu              gdextension.MethodForClass `hash:"718213027"`
	get_system_menu              gdextension.MethodForClass `hash:"469707506"`
	get_system_menu_name         gdextension.MethodForClass `hash:"1281499290"`
	create_menu                  gdextension.MethodForClass `hash:"529393457"`
	has_menu                     gdextension.MethodForClass `hash:"4155700596"`
	free_menu                    gdextension.MethodForClass `hash:"2722037293"`
	get_size                     gdextension.MethodForClass `hash:"2440833711"`
	popup                        gdextension.MethodForClass `hash:"2450610377"`
	set_interface_direction      gdextension.MethodForClass `hash:"1265174801"`
	set_popup_open_callback      gdextension.MethodForClass `hash:"3379118538"`
	get_popup_open_callback      gdextension.MethodForClass `hash:"3170603026"`
	set_popup_close_callback     gdextension.MethodForClass `hash:"3379118538"`
	get_popup_close_callback     gdextension.MethodForClass `hash:"3170603026"`
	set_minimum_width            gdextension.MethodForClass `hash:"1794382983"`
	get_minimum_width            gdextension.MethodForClass `hash:"866169185"`
	is_opened                    gdextension.MethodForClass `hash:"4155700596"`
	add_submenu_item             gdextension.MethodForClass `hash:"1002030223"`
	add_item                     gdextension.MethodForClass `hash:"980552939"`
	add_check_item               gdextension.MethodForClass `hash:"980552939"`
	add_icon_item                gdextension.MethodForClass `hash:"1372188274"`
	add_icon_check_item          gdextension.MethodForClass `hash:"1372188274"`
	add_radio_check_item         gdextension.MethodForClass `hash:"980552939"`
	add_icon_radio_check_item    gdextension.MethodForClass `hash:"1372188274"`
	add_multistate_item          gdextension.MethodForClass `hash:"2674635658"`
	add_separator                gdextension.MethodForClass `hash:"448810126"`
	find_item_index_with_text    gdextension.MethodForClass `hash:"1362438794"`
	find_item_index_with_tag     gdextension.MethodForClass `hash:"1260085030"`
	find_item_index_with_submenu gdextension.MethodForClass `hash:"893635918"`
	is_item_checked              gdextension.MethodForClass `hash:"3120086654"`
	is_item_checkable            gdextension.MethodForClass `hash:"3120086654"`
	is_item_radio_checkable      gdextension.MethodForClass `hash:"3120086654"`
	get_item_callback            gdextension.MethodForClass `hash:"1639989698"`
	get_item_key_callback        gdextension.MethodForClass `hash:"1639989698"`
	get_item_tag                 gdextension.MethodForClass `hash:"4069510997"`
	get_item_text                gdextension.MethodForClass `hash:"1464764419"`
	get_item_submenu             gdextension.MethodForClass `hash:"1066463050"`
	get_item_accelerator         gdextension.MethodForClass `hash:"316800700"`
	is_item_disabled             gdextension.MethodForClass `hash:"3120086654"`
	is_item_hidden               gdextension.MethodForClass `hash:"3120086654"`
	get_item_tooltip             gdextension.MethodForClass `hash:"1464764419"`
	get_item_state               gdextension.MethodForClass `hash:"1120910005"`
	get_item_max_states          gdextension.MethodForClass `hash:"1120910005"`
	get_item_icon                gdextension.MethodForClass `hash:"3391850701"`
	get_item_indentation_level   gdextension.MethodForClass `hash:"1120910005"`
	set_item_checked             gdextension.MethodForClass `hash:"2658558584"`
	set_item_checkable           gdextension.MethodForClass `hash:"2658558584"`
	set_item_radio_checkable     gdextension.MethodForClass `hash:"2658558584"`
	set_item_callback            gdextension.MethodForClass `hash:"2779810226"`
	set_item_hover_callbacks     gdextension.MethodForClass `hash:"2779810226"`
	set_item_key_callback        gdextension.MethodForClass `hash:"2779810226"`
	set_item_tag                 gdextension.MethodForClass `hash:"2706844827"`
	set_item_text                gdextension.MethodForClass `hash:"4153150897"`
	set_item_submenu             gdextension.MethodForClass `hash:"2310537182"`
	set_item_accelerator         gdextension.MethodForClass `hash:"786300043"`
	set_item_disabled            gdextension.MethodForClass `hash:"2658558584"`
	set_item_hidden              gdextension.MethodForClass `hash:"2658558584"`
	set_item_tooltip             gdextension.MethodForClass `hash:"4153150897"`
	set_item_state               gdextension.MethodForClass `hash:"4288446313"`
	set_item_max_states          gdextension.MethodForClass `hash:"4288446313"`
	set_item_icon                gdextension.MethodForClass `hash:"1388763257"`
	set_item_indentation_level   gdextension.MethodForClass `hash:"4288446313"`
	get_item_count               gdextension.MethodForClass `hash:"2198884583"`
	is_system_menu               gdextension.MethodForClass `hash:"4155700596"`
	remove_item                  gdextension.MethodForClass `hash:"3411492887"`
	clear                        gdextension.MethodForClass `hash:"2722037293"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("NativeMenu")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		gdextension.Free(gdextension.TypeStringName, &sname)
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

var self [1]gdclass.NativeMenu
var once sync.Once

func singleton() {
	self[0] = pointers.Raw[gdclass.NativeMenu]([3]uint64{uint64(gdextension.Host.Objects.Global(sname))})
}

/*
Returns [code]true[/code] if the specified [param feature] is supported by the current [NativeMenu], [code]false[/code] otherwise.
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
func HasFeature(feature Feature) bool { //gd:NativeMenu.has_feature
	once.Do(singleton)
	return bool(Advanced().HasFeature(feature))
}

/*
Returns [code]true[/code] if a special system menu is supported.
[b]Note:[/b] This method is implemented only on macOS.
*/
func HasSystemMenu(menu_id SystemMenus) bool { //gd:NativeMenu.has_system_menu
	once.Do(singleton)
	return bool(Advanced().HasSystemMenu(menu_id))
}

/*
Returns RID of a special system menu.
[b]Note:[/b] This method is implemented only on macOS.
*/
func GetSystemMenu(menu_id SystemMenus) RID.NativeMenu { //gd:NativeMenu.get_system_menu
	once.Do(singleton)
	return RID.NativeMenu(Advanced().GetSystemMenu(menu_id))
}

/*
Returns readable name of a special system menu.
[b]Note:[/b] This method is implemented only on macOS.
*/
func GetSystemMenuName(menu_id SystemMenus) string { //gd:NativeMenu.get_system_menu_name
	once.Do(singleton)
	return string(Advanced().GetSystemMenuName(menu_id).String())
}

/*
Creates a new global menu object.
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
func CreateMenu() RID.NativeMenu { //gd:NativeMenu.create_menu
	once.Do(singleton)
	return RID.NativeMenu(Advanced().CreateMenu())
}

/*
Returns [code]true[/code] if [param rid] is valid global menu.
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
func HasMenu(rid RID.NativeMenu) bool { //gd:NativeMenu.has_menu
	once.Do(singleton)
	return bool(Advanced().HasMenu(RID.Any(rid)))
}

/*
Frees a global menu object created by this [NativeMenu].
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
func FreeMenu(rid RID.NativeMenu) { //gd:NativeMenu.free_menu
	once.Do(singleton)
	Advanced().FreeMenu(RID.Any(rid))
}

/*
Returns global menu size.
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
func GetSize(rid RID.NativeMenu) Vector2.XY { //gd:NativeMenu.get_size
	once.Do(singleton)
	return Vector2.XY(Advanced().GetSize(RID.Any(rid)))
}

/*
Shows the global menu at [param position] in the screen coordinates.
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
func Popup(rid RID.NativeMenu, position Vector2i.XY) { //gd:NativeMenu.popup
	once.Do(singleton)
	Advanced().Popup(RID.Any(rid), Vector2i.XY(position))
}

/*
Sets the menu text layout direction from right-to-left if [param is_rtl] is [code]true[/code].
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
func SetInterfaceDirection(rid RID.NativeMenu, is_rtl bool) { //gd:NativeMenu.set_interface_direction
	once.Do(singleton)
	Advanced().SetInterfaceDirection(RID.Any(rid), is_rtl)
}

/*
Registers callable to emit after the menu is closed.
[b]Note:[/b] This method is implemented only on macOS.
*/
func SetPopupOpenCallback(rid RID.NativeMenu, callback func()) { //gd:NativeMenu.set_popup_open_callback
	once.Do(singleton)
	Advanced().SetPopupOpenCallback(RID.Any(rid), Callable.New(callback))
}

/*
Returns global menu open callback.
b]Note:[/b] This method is implemented only on macOS.
*/
func GetPopupOpenCallback(rid RID.NativeMenu) Callable.Function { //gd:NativeMenu.get_popup_open_callback
	once.Do(singleton)
	return Callable.Function(Advanced().GetPopupOpenCallback(RID.Any(rid)))
}

/*
Registers callable to emit when the menu is about to show.
[b]Note:[/b] The OS can simulate menu opening to track menu item changes and global shortcuts, in which case the corresponding close callback is not triggered. Use [method is_opened] to check if the menu is currently opened.
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
func SetPopupCloseCallback(rid RID.NativeMenu, callback func()) { //gd:NativeMenu.set_popup_close_callback
	once.Do(singleton)
	Advanced().SetPopupCloseCallback(RID.Any(rid), Callable.New(callback))
}

/*
Returns global menu close callback.
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
func GetPopupCloseCallback(rid RID.NativeMenu) Callable.Function { //gd:NativeMenu.get_popup_close_callback
	once.Do(singleton)
	return Callable.Function(Advanced().GetPopupCloseCallback(RID.Any(rid)))
}

/*
Sets the minimum width of the global menu.
[b]Note:[/b] This method is implemented only on macOS.
*/
func SetMinimumWidth(rid RID.NativeMenu, width Float.X) { //gd:NativeMenu.set_minimum_width
	once.Do(singleton)
	Advanced().SetMinimumWidth(RID.Any(rid), float64(width))
}

/*
Returns global menu minimum width.
[b]Note:[/b] This method is implemented only on macOS.
*/
func GetMinimumWidth(rid RID.NativeMenu) Float.X { //gd:NativeMenu.get_minimum_width
	once.Do(singleton)
	return Float.X(Float.X(Advanced().GetMinimumWidth(RID.Any(rid))))
}

/*
Returns [code]true[/code] if the menu is currently opened.
[b]Note:[/b] This method is implemented only on macOS.
*/
func IsOpened(rid RID.NativeMenu) bool { //gd:NativeMenu.is_opened
	once.Do(singleton)
	return bool(Advanced().IsOpened(RID.Any(rid)))
}

/*
Adds an item that will act as a submenu of the global menu [param rid]. The [param submenu_rid] argument is the RID of the global menu that will be shown when the item is clicked.
Returns index of the inserted item, it's not guaranteed to be the same as [param index] value.
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
func AddSubmenuItem(rid RID.NativeMenu, label string, submenu_rid RID.NativeMenu, tag any) int { //gd:NativeMenu.add_submenu_item
	once.Do(singleton)
	return int(int(Advanced().AddSubmenuItem(RID.Any(rid), String.New(label), RID.Any(submenu_rid), variant.New(tag), int64(-1))))
}

/*
Adds an item that will act as a submenu of the global menu [param rid]. The [param submenu_rid] argument is the RID of the global menu that will be shown when the item is clicked.
Returns index of the inserted item, it's not guaranteed to be the same as [param index] value.
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
func AddSubmenuItemOptions(rid RID.NativeMenu, label string, submenu_rid RID.NativeMenu, tag any, index int) int { //gd:NativeMenu.add_submenu_item
	once.Do(singleton)
	return int(int(Advanced().AddSubmenuItem(RID.Any(rid), String.New(label), RID.Any(submenu_rid), variant.New(tag), int64(index))))
}

/*
Adds a new item with text [param label] to the global menu [param rid].
Returns index of the inserted item, it's not guaranteed to be the same as [param index] value.
An [param accelerator] can optionally be defined, which is a keyboard shortcut that can be pressed to trigger the menu button even if it's not currently open. The [param accelerator] is generally a combination of [enum KeyModifierMask]s and [enum Key]s using bitwise OR such as [code]KEY_MASK_CTRL | KEY_A[/code] ([kbd]Ctrl + A[/kbd]).
[b]Note:[/b] The [param callback] and [param key_callback] Callables need to accept exactly one Variant parameter, the parameter passed to the Callables will be the value passed to [param tag].
[b]Note:[/b] This method is implemented on macOS and Windows.
[b]Note:[/b] On Windows, [param accelerator] and [param key_callback] are ignored.
*/
func AddItem(rid RID.NativeMenu, label string, callback func(tag any), key_callback func(tag any), tag any, accelerator Input.Key) int { //gd:NativeMenu.add_item
	once.Do(singleton)
	return int(int(Advanced().AddItem(RID.Any(rid), String.New(label), Callable.New(callback), Callable.New(key_callback), variant.New(tag), accelerator, int64(-1))))
}

/*
Adds a new item with text [param label] to the global menu [param rid].
Returns index of the inserted item, it's not guaranteed to be the same as [param index] value.
An [param accelerator] can optionally be defined, which is a keyboard shortcut that can be pressed to trigger the menu button even if it's not currently open. The [param accelerator] is generally a combination of [enum KeyModifierMask]s and [enum Key]s using bitwise OR such as [code]KEY_MASK_CTRL | KEY_A[/code] ([kbd]Ctrl + A[/kbd]).
[b]Note:[/b] The [param callback] and [param key_callback] Callables need to accept exactly one Variant parameter, the parameter passed to the Callables will be the value passed to [param tag].
[b]Note:[/b] This method is implemented on macOS and Windows.
[b]Note:[/b] On Windows, [param accelerator] and [param key_callback] are ignored.
*/
func AddItemOptions(rid RID.NativeMenu, label string, callback func(tag any), key_callback func(tag any), tag any, accelerator Input.Key, index int) int { //gd:NativeMenu.add_item
	once.Do(singleton)
	return int(int(Advanced().AddItem(RID.Any(rid), String.New(label), Callable.New(callback), Callable.New(key_callback), variant.New(tag), accelerator, int64(index))))
}

/*
Adds a new checkable item with text [param label] to the global menu [param rid].
Returns index of the inserted item, it's not guaranteed to be the same as [param index] value.
An [param accelerator] can optionally be defined, which is a keyboard shortcut that can be pressed to trigger the menu button even if it's not currently open. The [param accelerator] is generally a combination of [enum KeyModifierMask]s and [enum Key]s using bitwise OR such as [code]KEY_MASK_CTRL | KEY_A[/code] ([kbd]Ctrl + A[/kbd]).
[b]Note:[/b] The [param callback] and [param key_callback] Callables need to accept exactly one Variant parameter, the parameter passed to the Callables will be the value passed to [param tag].
[b]Note:[/b] This method is implemented on macOS and Windows.
[b]Note:[/b] On Windows, [param accelerator] and [param key_callback] are ignored.
*/
func AddCheckItem(rid RID.NativeMenu, label string, callback func(tag any), key_callback func(tag any), tag any, accelerator Input.Key) int { //gd:NativeMenu.add_check_item
	once.Do(singleton)
	return int(int(Advanced().AddCheckItem(RID.Any(rid), String.New(label), Callable.New(callback), Callable.New(key_callback), variant.New(tag), accelerator, int64(-1))))
}

/*
Adds a new checkable item with text [param label] to the global menu [param rid].
Returns index of the inserted item, it's not guaranteed to be the same as [param index] value.
An [param accelerator] can optionally be defined, which is a keyboard shortcut that can be pressed to trigger the menu button even if it's not currently open. The [param accelerator] is generally a combination of [enum KeyModifierMask]s and [enum Key]s using bitwise OR such as [code]KEY_MASK_CTRL | KEY_A[/code] ([kbd]Ctrl + A[/kbd]).
[b]Note:[/b] The [param callback] and [param key_callback] Callables need to accept exactly one Variant parameter, the parameter passed to the Callables will be the value passed to [param tag].
[b]Note:[/b] This method is implemented on macOS and Windows.
[b]Note:[/b] On Windows, [param accelerator] and [param key_callback] are ignored.
*/
func AddCheckItemOptions(rid RID.NativeMenu, label string, callback func(tag any), key_callback func(tag any), tag any, accelerator Input.Key, index int) int { //gd:NativeMenu.add_check_item
	once.Do(singleton)
	return int(int(Advanced().AddCheckItem(RID.Any(rid), String.New(label), Callable.New(callback), Callable.New(key_callback), variant.New(tag), accelerator, int64(index))))
}

/*
Adds a new item with text [param label] and icon [param icon] to the global menu [param rid].
Returns index of the inserted item, it's not guaranteed to be the same as [param index] value.
An [param accelerator] can optionally be defined, which is a keyboard shortcut that can be pressed to trigger the menu button even if it's not currently open. The [param accelerator] is generally a combination of [enum KeyModifierMask]s and [enum Key]s using bitwise OR such as [code]KEY_MASK_CTRL | KEY_A[/code] ([kbd]Ctrl + A[/kbd]).
[b]Note:[/b] The [param callback] and [param key_callback] Callables need to accept exactly one Variant parameter, the parameter passed to the Callables will be the value passed to [param tag].
[b]Note:[/b] This method is implemented on macOS and Windows.
[b]Note:[/b] On Windows, [param accelerator] and [param key_callback] are ignored.
*/
func AddIconItem(rid RID.NativeMenu, icon Texture2D.Instance, label string, callback func(tag any), key_callback func(tag any), tag any, accelerator Input.Key) int { //gd:NativeMenu.add_icon_item
	once.Do(singleton)
	return int(int(Advanced().AddIconItem(RID.Any(rid), icon, String.New(label), Callable.New(callback), Callable.New(key_callback), variant.New(tag), accelerator, int64(-1))))
}

/*
Adds a new item with text [param label] and icon [param icon] to the global menu [param rid].
Returns index of the inserted item, it's not guaranteed to be the same as [param index] value.
An [param accelerator] can optionally be defined, which is a keyboard shortcut that can be pressed to trigger the menu button even if it's not currently open. The [param accelerator] is generally a combination of [enum KeyModifierMask]s and [enum Key]s using bitwise OR such as [code]KEY_MASK_CTRL | KEY_A[/code] ([kbd]Ctrl + A[/kbd]).
[b]Note:[/b] The [param callback] and [param key_callback] Callables need to accept exactly one Variant parameter, the parameter passed to the Callables will be the value passed to [param tag].
[b]Note:[/b] This method is implemented on macOS and Windows.
[b]Note:[/b] On Windows, [param accelerator] and [param key_callback] are ignored.
*/
func AddIconItemOptions(rid RID.NativeMenu, icon Texture2D.Instance, label string, callback func(tag any), key_callback func(tag any), tag any, accelerator Input.Key, index int) int { //gd:NativeMenu.add_icon_item
	once.Do(singleton)
	return int(int(Advanced().AddIconItem(RID.Any(rid), icon, String.New(label), Callable.New(callback), Callable.New(key_callback), variant.New(tag), accelerator, int64(index))))
}

/*
Adds a new checkable item with text [param label] and icon [param icon] to the global menu [param rid].
Returns index of the inserted item, it's not guaranteed to be the same as [param index] value.
An [param accelerator] can optionally be defined, which is a keyboard shortcut that can be pressed to trigger the menu button even if it's not currently open. The [param accelerator] is generally a combination of [enum KeyModifierMask]s and [enum Key]s using bitwise OR such as [code]KEY_MASK_CTRL | KEY_A[/code] ([kbd]Ctrl + A[/kbd]).
[b]Note:[/b] The [param callback] and [param key_callback] Callables need to accept exactly one Variant parameter, the parameter passed to the Callables will be the value passed to [param tag].
[b]Note:[/b] This method is implemented on macOS and Windows.
[b]Note:[/b] On Windows, [param accelerator] and [param key_callback] are ignored.
*/
func AddIconCheckItem(rid RID.NativeMenu, icon Texture2D.Instance, label string, callback func(tag any), key_callback func(tag any), tag any, accelerator Input.Key) int { //gd:NativeMenu.add_icon_check_item
	once.Do(singleton)
	return int(int(Advanced().AddIconCheckItem(RID.Any(rid), icon, String.New(label), Callable.New(callback), Callable.New(key_callback), variant.New(tag), accelerator, int64(-1))))
}

/*
Adds a new checkable item with text [param label] and icon [param icon] to the global menu [param rid].
Returns index of the inserted item, it's not guaranteed to be the same as [param index] value.
An [param accelerator] can optionally be defined, which is a keyboard shortcut that can be pressed to trigger the menu button even if it's not currently open. The [param accelerator] is generally a combination of [enum KeyModifierMask]s and [enum Key]s using bitwise OR such as [code]KEY_MASK_CTRL | KEY_A[/code] ([kbd]Ctrl + A[/kbd]).
[b]Note:[/b] The [param callback] and [param key_callback] Callables need to accept exactly one Variant parameter, the parameter passed to the Callables will be the value passed to [param tag].
[b]Note:[/b] This method is implemented on macOS and Windows.
[b]Note:[/b] On Windows, [param accelerator] and [param key_callback] are ignored.
*/
func AddIconCheckItemOptions(rid RID.NativeMenu, icon Texture2D.Instance, label string, callback func(tag any), key_callback func(tag any), tag any, accelerator Input.Key, index int) int { //gd:NativeMenu.add_icon_check_item
	once.Do(singleton)
	return int(int(Advanced().AddIconCheckItem(RID.Any(rid), icon, String.New(label), Callable.New(callback), Callable.New(key_callback), variant.New(tag), accelerator, int64(index))))
}

/*
Adds a new radio-checkable item with text [param label] to the global menu [param rid].
Returns index of the inserted item, it's not guaranteed to be the same as [param index] value.
An [param accelerator] can optionally be defined, which is a keyboard shortcut that can be pressed to trigger the menu button even if it's not currently open. The [param accelerator] is generally a combination of [enum KeyModifierMask]s and [enum Key]s using bitwise OR such as [code]KEY_MASK_CTRL | KEY_A[/code] ([kbd]Ctrl + A[/kbd]).
[b]Note:[/b] Radio-checkable items just display a checkmark, but don't have any built-in checking behavior and must be checked/unchecked manually. See [method set_item_checked] for more info on how to control it.
[b]Note:[/b] The [param callback] and [param key_callback] Callables need to accept exactly one Variant parameter, the parameter passed to the Callables will be the value passed to [param tag].
[b]Note:[/b] This method is implemented on macOS and Windows.
[b]Note:[/b] On Windows, [param accelerator] and [param key_callback] are ignored.
*/
func AddRadioCheckItem(rid RID.NativeMenu, label string, callback func(tag any), key_callback func(tag any), tag any, accelerator Input.Key) int { //gd:NativeMenu.add_radio_check_item
	once.Do(singleton)
	return int(int(Advanced().AddRadioCheckItem(RID.Any(rid), String.New(label), Callable.New(callback), Callable.New(key_callback), variant.New(tag), accelerator, int64(-1))))
}

/*
Adds a new radio-checkable item with text [param label] to the global menu [param rid].
Returns index of the inserted item, it's not guaranteed to be the same as [param index] value.
An [param accelerator] can optionally be defined, which is a keyboard shortcut that can be pressed to trigger the menu button even if it's not currently open. The [param accelerator] is generally a combination of [enum KeyModifierMask]s and [enum Key]s using bitwise OR such as [code]KEY_MASK_CTRL | KEY_A[/code] ([kbd]Ctrl + A[/kbd]).
[b]Note:[/b] Radio-checkable items just display a checkmark, but don't have any built-in checking behavior and must be checked/unchecked manually. See [method set_item_checked] for more info on how to control it.
[b]Note:[/b] The [param callback] and [param key_callback] Callables need to accept exactly one Variant parameter, the parameter passed to the Callables will be the value passed to [param tag].
[b]Note:[/b] This method is implemented on macOS and Windows.
[b]Note:[/b] On Windows, [param accelerator] and [param key_callback] are ignored.
*/
func AddRadioCheckItemOptions(rid RID.NativeMenu, label string, callback func(tag any), key_callback func(tag any), tag any, accelerator Input.Key, index int) int { //gd:NativeMenu.add_radio_check_item
	once.Do(singleton)
	return int(int(Advanced().AddRadioCheckItem(RID.Any(rid), String.New(label), Callable.New(callback), Callable.New(key_callback), variant.New(tag), accelerator, int64(index))))
}

/*
Adds a new radio-checkable item with text [param label] and icon [param icon] to the global menu [param rid].
Returns index of the inserted item, it's not guaranteed to be the same as [param index] value.
An [param accelerator] can optionally be defined, which is a keyboard shortcut that can be pressed to trigger the menu button even if it's not currently open. The [param accelerator] is generally a combination of [enum KeyModifierMask]s and [enum Key]s using bitwise OR such as [code]KEY_MASK_CTRL | KEY_A[/code] ([kbd]Ctrl + A[/kbd]).
[b]Note:[/b] Radio-checkable items just display a checkmark, but don't have any built-in checking behavior and must be checked/unchecked manually. See [method set_item_checked] for more info on how to control it.
[b]Note:[/b] The [param callback] and [param key_callback] Callables need to accept exactly one Variant parameter, the parameter passed to the Callables will be the value passed to [param tag].
[b]Note:[/b] This method is implemented on macOS and Windows.
[b]Note:[/b] On Windows, [param accelerator] and [param key_callback] are ignored.
*/
func AddIconRadioCheckItem(rid RID.NativeMenu, icon Texture2D.Instance, label string, callback func(tag any), key_callback func(tag any), tag any, accelerator Input.Key) int { //gd:NativeMenu.add_icon_radio_check_item
	once.Do(singleton)
	return int(int(Advanced().AddIconRadioCheckItem(RID.Any(rid), icon, String.New(label), Callable.New(callback), Callable.New(key_callback), variant.New(tag), accelerator, int64(-1))))
}

/*
Adds a new radio-checkable item with text [param label] and icon [param icon] to the global menu [param rid].
Returns index of the inserted item, it's not guaranteed to be the same as [param index] value.
An [param accelerator] can optionally be defined, which is a keyboard shortcut that can be pressed to trigger the menu button even if it's not currently open. The [param accelerator] is generally a combination of [enum KeyModifierMask]s and [enum Key]s using bitwise OR such as [code]KEY_MASK_CTRL | KEY_A[/code] ([kbd]Ctrl + A[/kbd]).
[b]Note:[/b] Radio-checkable items just display a checkmark, but don't have any built-in checking behavior and must be checked/unchecked manually. See [method set_item_checked] for more info on how to control it.
[b]Note:[/b] The [param callback] and [param key_callback] Callables need to accept exactly one Variant parameter, the parameter passed to the Callables will be the value passed to [param tag].
[b]Note:[/b] This method is implemented on macOS and Windows.
[b]Note:[/b] On Windows, [param accelerator] and [param key_callback] are ignored.
*/
func AddIconRadioCheckItemOptions(rid RID.NativeMenu, icon Texture2D.Instance, label string, callback func(tag any), key_callback func(tag any), tag any, accelerator Input.Key, index int) int { //gd:NativeMenu.add_icon_radio_check_item
	once.Do(singleton)
	return int(int(Advanced().AddIconRadioCheckItem(RID.Any(rid), icon, String.New(label), Callable.New(callback), Callable.New(key_callback), variant.New(tag), accelerator, int64(index))))
}

/*
Adds a new item with text [param label] to the global menu [param rid].
Contrarily to normal binary items, multistate items can have more than two states, as defined by [param max_states]. Each press or activate of the item will increase the state by one. The default value is defined by [param default_state].
Returns index of the inserted item, it's not guaranteed to be the same as [param index] value.
An [param accelerator] can optionally be defined, which is a keyboard shortcut that can be pressed to trigger the menu button even if it's not currently open. The [param accelerator] is generally a combination of [enum KeyModifierMask]s and [enum Key]s using bitwise OR such as [code]KEY_MASK_CTRL | KEY_A[/code] ([kbd]Ctrl + A[/kbd]).
[b]Note:[/b] By default, there's no indication of the current item state, it should be changed manually.
[b]Note:[/b] The [param callback] and [param key_callback] Callables need to accept exactly one Variant parameter, the parameter passed to the Callables will be the value passed to [param tag].
[b]Note:[/b] This method is implemented on macOS and Windows.
[b]Note:[/b] On Windows, [param accelerator] and [param key_callback] are ignored.
*/
func AddMultistateItem(rid RID.NativeMenu, label string, max_states int, default_state int, callback func(tag any), key_callback func(tag any), tag any, accelerator Input.Key) int { //gd:NativeMenu.add_multistate_item
	once.Do(singleton)
	return int(int(Advanced().AddMultistateItem(RID.Any(rid), String.New(label), int64(max_states), int64(default_state), Callable.New(callback), Callable.New(key_callback), variant.New(tag), accelerator, int64(-1))))
}

/*
Adds a new item with text [param label] to the global menu [param rid].
Contrarily to normal binary items, multistate items can have more than two states, as defined by [param max_states]. Each press or activate of the item will increase the state by one. The default value is defined by [param default_state].
Returns index of the inserted item, it's not guaranteed to be the same as [param index] value.
An [param accelerator] can optionally be defined, which is a keyboard shortcut that can be pressed to trigger the menu button even if it's not currently open. The [param accelerator] is generally a combination of [enum KeyModifierMask]s and [enum Key]s using bitwise OR such as [code]KEY_MASK_CTRL | KEY_A[/code] ([kbd]Ctrl + A[/kbd]).
[b]Note:[/b] By default, there's no indication of the current item state, it should be changed manually.
[b]Note:[/b] The [param callback] and [param key_callback] Callables need to accept exactly one Variant parameter, the parameter passed to the Callables will be the value passed to [param tag].
[b]Note:[/b] This method is implemented on macOS and Windows.
[b]Note:[/b] On Windows, [param accelerator] and [param key_callback] are ignored.
*/
func AddMultistateItemOptions(rid RID.NativeMenu, label string, max_states int, default_state int, callback func(tag any), key_callback func(tag any), tag any, accelerator Input.Key, index int) int { //gd:NativeMenu.add_multistate_item
	once.Do(singleton)
	return int(int(Advanced().AddMultistateItem(RID.Any(rid), String.New(label), int64(max_states), int64(default_state), Callable.New(callback), Callable.New(key_callback), variant.New(tag), accelerator, int64(index))))
}

/*
Adds a separator between items to the global menu [param rid]. Separators also occupy an index.
Returns index of the inserted item, it's not guaranteed to be the same as [param index] value.
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
func AddSeparator(rid RID.NativeMenu) int { //gd:NativeMenu.add_separator
	once.Do(singleton)
	return int(int(Advanced().AddSeparator(RID.Any(rid), int64(-1))))
}

/*
Adds a separator between items to the global menu [param rid]. Separators also occupy an index.
Returns index of the inserted item, it's not guaranteed to be the same as [param index] value.
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
func AddSeparatorOptions(rid RID.NativeMenu, index int) int { //gd:NativeMenu.add_separator
	once.Do(singleton)
	return int(int(Advanced().AddSeparator(RID.Any(rid), int64(index))))
}

/*
Returns the index of the item with the specified [param text]. Indices are automatically assigned to each item by the engine, and cannot be set manually.
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
func FindItemIndexWithText(rid RID.NativeMenu, text string) int { //gd:NativeMenu.find_item_index_with_text
	once.Do(singleton)
	return int(int(Advanced().FindItemIndexWithText(RID.Any(rid), String.New(text))))
}

/*
Returns the index of the item with the specified [param tag]. Indices are automatically assigned to each item by the engine, and cannot be set manually.
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
func FindItemIndexWithTag(rid RID.NativeMenu, tag any) int { //gd:NativeMenu.find_item_index_with_tag
	once.Do(singleton)
	return int(int(Advanced().FindItemIndexWithTag(RID.Any(rid), variant.New(tag))))
}

/*
Returns the index of the item with the submenu specified by [param submenu_rid]. Indices are automatically assigned to each item by the engine, and cannot be set manually.
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
func FindItemIndexWithSubmenu(rid RID.NativeMenu, submenu_rid RID.NativeMenu) int { //gd:NativeMenu.find_item_index_with_submenu
	once.Do(singleton)
	return int(int(Advanced().FindItemIndexWithSubmenu(RID.Any(rid), RID.Any(submenu_rid))))
}

/*
Returns [code]true[/code] if the item at index [param idx] is checked.
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
func IsItemChecked(rid RID.NativeMenu, idx int) bool { //gd:NativeMenu.is_item_checked
	once.Do(singleton)
	return bool(Advanced().IsItemChecked(RID.Any(rid), int64(idx)))
}

/*
Returns [code]true[/code] if the item at index [param idx] is checkable in some way, i.e. if it has a checkbox or radio button.
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
func IsItemCheckable(rid RID.NativeMenu, idx int) bool { //gd:NativeMenu.is_item_checkable
	once.Do(singleton)
	return bool(Advanced().IsItemCheckable(RID.Any(rid), int64(idx)))
}

/*
Returns [code]true[/code] if the item at index [param idx] has radio button-style checkability.
[b]Note:[/b] This is purely cosmetic; you must add the logic for checking/unchecking items in radio groups.
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
func IsItemRadioCheckable(rid RID.NativeMenu, idx int) bool { //gd:NativeMenu.is_item_radio_checkable
	once.Do(singleton)
	return bool(Advanced().IsItemRadioCheckable(RID.Any(rid), int64(idx)))
}

/*
Returns the callback of the item at index [param idx].
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
func GetItemCallback(rid RID.NativeMenu, idx int) Callable.Function { //gd:NativeMenu.get_item_callback
	once.Do(singleton)
	return Callable.Function(Advanced().GetItemCallback(RID.Any(rid), int64(idx)))
}

/*
Returns the callback of the item accelerator at index [param idx].
[b]Note:[/b] This method is implemented only on macOS.
*/
func GetItemKeyCallback(rid RID.NativeMenu, idx int) Callable.Function { //gd:NativeMenu.get_item_key_callback
	once.Do(singleton)
	return Callable.Function(Advanced().GetItemKeyCallback(RID.Any(rid), int64(idx)))
}

/*
Returns the metadata of the specified item, which might be of any type. You can set it with [method set_item_tag], which provides a simple way of assigning context data to items.
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
func GetItemTag(rid RID.NativeMenu, idx int) any { //gd:NativeMenu.get_item_tag
	once.Do(singleton)
	return any(Advanced().GetItemTag(RID.Any(rid), int64(idx)).Interface())
}

/*
Returns the text of the item at index [param idx].
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
func GetItemText(rid RID.NativeMenu, idx int) string { //gd:NativeMenu.get_item_text
	once.Do(singleton)
	return string(Advanced().GetItemText(RID.Any(rid), int64(idx)).String())
}

/*
Returns the submenu ID of the item at index [param idx]. See [method add_submenu_item] for more info on how to add a submenu.
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
func GetItemSubmenu(rid RID.NativeMenu, idx int) RID.NativeMenu { //gd:NativeMenu.get_item_submenu
	once.Do(singleton)
	return RID.NativeMenu(Advanced().GetItemSubmenu(RID.Any(rid), int64(idx)))
}

/*
Returns the accelerator of the item at index [param idx]. Accelerators are special combinations of keys that activate the item, no matter which control is focused.
[b]Note:[/b] This method is implemented only on macOS.
*/
func GetItemAccelerator(rid RID.NativeMenu, idx int) Input.Key { //gd:NativeMenu.get_item_accelerator
	once.Do(singleton)
	return Input.Key(Advanced().GetItemAccelerator(RID.Any(rid), int64(idx)))
}

/*
Returns [code]true[/code] if the item at index [param idx] is disabled. When it is disabled it can't be selected, or its action invoked.
See [method set_item_disabled] for more info on how to disable an item.
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
func IsItemDisabled(rid RID.NativeMenu, idx int) bool { //gd:NativeMenu.is_item_disabled
	once.Do(singleton)
	return bool(Advanced().IsItemDisabled(RID.Any(rid), int64(idx)))
}

/*
Returns [code]true[/code] if the item at index [param idx] is hidden.
See [method set_item_hidden] for more info on how to hide an item.
[b]Note:[/b] This method is implemented only on macOS.
*/
func IsItemHidden(rid RID.NativeMenu, idx int) bool { //gd:NativeMenu.is_item_hidden
	once.Do(singleton)
	return bool(Advanced().IsItemHidden(RID.Any(rid), int64(idx)))
}

/*
Returns the tooltip associated with the specified index [param idx].
[b]Note:[/b] This method is implemented only on macOS.
*/
func GetItemTooltip(rid RID.NativeMenu, idx int) string { //gd:NativeMenu.get_item_tooltip
	once.Do(singleton)
	return string(Advanced().GetItemTooltip(RID.Any(rid), int64(idx)).String())
}

/*
Returns the state of a multistate item. See [method add_multistate_item] for details.
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
func GetItemState(rid RID.NativeMenu, idx int) int { //gd:NativeMenu.get_item_state
	once.Do(singleton)
	return int(int(Advanced().GetItemState(RID.Any(rid), int64(idx))))
}

/*
Returns number of states of a multistate item. See [method add_multistate_item] for details.
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
func GetItemMaxStates(rid RID.NativeMenu, idx int) int { //gd:NativeMenu.get_item_max_states
	once.Do(singleton)
	return int(int(Advanced().GetItemMaxStates(RID.Any(rid), int64(idx))))
}

/*
Returns the icon of the item at index [param idx].
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
func GetItemIcon(rid RID.NativeMenu, idx int) Texture2D.Instance { //gd:NativeMenu.get_item_icon
	once.Do(singleton)
	return Texture2D.Instance(Advanced().GetItemIcon(RID.Any(rid), int64(idx)))
}

/*
Returns the horizontal offset of the item at the given [param idx].
[b]Note:[/b] This method is implemented only on macOS.
*/
func GetItemIndentationLevel(rid RID.NativeMenu, idx int) int { //gd:NativeMenu.get_item_indentation_level
	once.Do(singleton)
	return int(int(Advanced().GetItemIndentationLevel(RID.Any(rid), int64(idx))))
}

/*
Sets the checkstate status of the item at index [param idx].
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
func SetItemChecked(rid RID.NativeMenu, idx int, checked bool) { //gd:NativeMenu.set_item_checked
	once.Do(singleton)
	Advanced().SetItemChecked(RID.Any(rid), int64(idx), checked)
}

/*
Sets whether the item at index [param idx] has a checkbox. If [code]false[/code], sets the type of the item to plain text.
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
func SetItemCheckable(rid RID.NativeMenu, idx int, checkable bool) { //gd:NativeMenu.set_item_checkable
	once.Do(singleton)
	Advanced().SetItemCheckable(RID.Any(rid), int64(idx), checkable)
}

/*
Sets the type of the item at the specified index [param idx] to radio button. If [code]false[/code], sets the type of the item to plain text.
[b]Note:[/b] This is purely cosmetic; you must add the logic for checking/unchecking items in radio groups.
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
func SetItemRadioCheckable(rid RID.NativeMenu, idx int, checkable bool) { //gd:NativeMenu.set_item_radio_checkable
	once.Do(singleton)
	Advanced().SetItemRadioCheckable(RID.Any(rid), int64(idx), checkable)
}

/*
Sets the callback of the item at index [param idx]. Callback is emitted when an item is pressed.
[b]Note:[/b] The [param callback] Callable needs to accept exactly one Variant parameter, the parameter passed to the Callable will be the value passed to the [code]tag[/code] parameter when the menu item was created.
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
func SetItemCallback(rid RID.NativeMenu, idx int, callback func(tag any)) { //gd:NativeMenu.set_item_callback
	once.Do(singleton)
	Advanced().SetItemCallback(RID.Any(rid), int64(idx), Callable.New(callback))
}

/*
Sets the callback of the item at index [param idx]. The callback is emitted when an item is hovered.
[b]Note:[/b] The [param callback] Callable needs to accept exactly one Variant parameter, the parameter passed to the Callable will be the value passed to the [code]tag[/code] parameter when the menu item was created.
[b]Note:[/b] This method is implemented only on macOS.
*/
func SetItemHoverCallbacks(rid RID.NativeMenu, idx int, callback func(tag any)) { //gd:NativeMenu.set_item_hover_callbacks
	once.Do(singleton)
	Advanced().SetItemHoverCallbacks(RID.Any(rid), int64(idx), Callable.New(callback))
}

/*
Sets the callback of the item at index [param idx]. Callback is emitted when its accelerator is activated.
[b]Note:[/b] The [param key_callback] Callable needs to accept exactly one Variant parameter, the parameter passed to the Callable will be the value passed to the [code]tag[/code] parameter when the menu item was created.
[b]Note:[/b] This method is implemented only on macOS.
*/
func SetItemKeyCallback(rid RID.NativeMenu, idx int, key_callback func(tag any)) { //gd:NativeMenu.set_item_key_callback
	once.Do(singleton)
	Advanced().SetItemKeyCallback(RID.Any(rid), int64(idx), Callable.New(key_callback))
}

/*
Sets the metadata of an item, which may be of any type. You can later get it with [method get_item_tag], which provides a simple way of assigning context data to items.
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
func SetItemTag(rid RID.NativeMenu, idx int, tag any) { //gd:NativeMenu.set_item_tag
	once.Do(singleton)
	Advanced().SetItemTag(RID.Any(rid), int64(idx), variant.New(tag))
}

/*
Sets the text of the item at index [param idx].
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
func SetItemText(rid RID.NativeMenu, idx int, text string) { //gd:NativeMenu.set_item_text
	once.Do(singleton)
	Advanced().SetItemText(RID.Any(rid), int64(idx), String.New(text))
}

/*
Sets the submenu RID of the item at index [param idx]. The submenu is a global menu that would be shown when the item is clicked.
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
func SetItemSubmenu(rid RID.NativeMenu, idx int, submenu_rid RID.NativeMenu) { //gd:NativeMenu.set_item_submenu
	once.Do(singleton)
	Advanced().SetItemSubmenu(RID.Any(rid), int64(idx), RID.Any(submenu_rid))
}

/*
Sets the accelerator of the item at index [param idx]. [param keycode] can be a single [enum Key], or a combination of [enum KeyModifierMask]s and [enum Key]s using bitwise OR such as [code]KEY_MASK_CTRL | KEY_A[/code] ([kbd]Ctrl + A[/kbd]).
[b]Note:[/b] This method is implemented only on macOS.
*/
func SetItemAccelerator(rid RID.NativeMenu, idx int, keycode Input.Key) { //gd:NativeMenu.set_item_accelerator
	once.Do(singleton)
	Advanced().SetItemAccelerator(RID.Any(rid), int64(idx), keycode)
}

/*
Enables/disables the item at index [param idx]. When it is disabled, it can't be selected and its action can't be invoked.
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
func SetItemDisabled(rid RID.NativeMenu, idx int, disabled bool) { //gd:NativeMenu.set_item_disabled
	once.Do(singleton)
	Advanced().SetItemDisabled(RID.Any(rid), int64(idx), disabled)
}

/*
Hides/shows the item at index [param idx]. When it is hidden, an item does not appear in a menu and its action cannot be invoked.
[b]Note:[/b] This method is implemented only on macOS.
*/
func SetItemHidden(rid RID.NativeMenu, idx int, hidden bool) { //gd:NativeMenu.set_item_hidden
	once.Do(singleton)
	Advanced().SetItemHidden(RID.Any(rid), int64(idx), hidden)
}

/*
Sets the [String] tooltip of the item at the specified index [param idx].
[b]Note:[/b] This method is implemented only on macOS.
*/
func SetItemTooltip(rid RID.NativeMenu, idx int, tooltip string) { //gd:NativeMenu.set_item_tooltip
	once.Do(singleton)
	Advanced().SetItemTooltip(RID.Any(rid), int64(idx), String.New(tooltip))
}

/*
Sets the state of a multistate item. See [method add_multistate_item] for details.
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
func SetItemState(rid RID.NativeMenu, idx int, state int) { //gd:NativeMenu.set_item_state
	once.Do(singleton)
	Advanced().SetItemState(RID.Any(rid), int64(idx), int64(state))
}

/*
Sets number of state of a multistate item. See [method add_multistate_item] for details.
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
func SetItemMaxStates(rid RID.NativeMenu, idx int, max_states int) { //gd:NativeMenu.set_item_max_states
	once.Do(singleton)
	Advanced().SetItemMaxStates(RID.Any(rid), int64(idx), int64(max_states))
}

/*
Replaces the [Texture2D] icon of the specified [param idx].
[b]Note:[/b] This method is implemented on macOS and Windows.
[b]Note:[/b] This method is not supported by macOS Dock menu items.
*/
func SetItemIcon(rid RID.NativeMenu, idx int, icon Texture2D.Instance) { //gd:NativeMenu.set_item_icon
	once.Do(singleton)
	Advanced().SetItemIcon(RID.Any(rid), int64(idx), icon)
}

/*
Sets the horizontal offset of the item at the given [param idx].
[b]Note:[/b] This method is implemented only on macOS.
*/
func SetItemIndentationLevel(rid RID.NativeMenu, idx int, level int) { //gd:NativeMenu.set_item_indentation_level
	once.Do(singleton)
	Advanced().SetItemIndentationLevel(RID.Any(rid), int64(idx), int64(level))
}

/*
Returns number of items in the global menu [param rid].
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
func GetItemCount(rid RID.NativeMenu) int { //gd:NativeMenu.get_item_count
	once.Do(singleton)
	return int(int(Advanced().GetItemCount(RID.Any(rid))))
}

/*
Return [code]true[/code] is global menu is a special system menu.
[b]Note:[/b] This method is implemented only on macOS.
*/
func IsSystemMenu(rid RID.NativeMenu) bool { //gd:NativeMenu.is_system_menu
	once.Do(singleton)
	return bool(Advanced().IsSystemMenu(RID.Any(rid)))
}

/*
Removes the item at index [param idx] from the global menu [param rid].
[b]Note:[/b] The indices of items after the removed item will be shifted by one.
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
func RemoveItem(rid RID.NativeMenu, idx int) { //gd:NativeMenu.remove_item
	once.Do(singleton)
	Advanced().RemoveItem(RID.Any(rid), int64(idx))
}

/*
Removes all items from the global menu [param rid].
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
func Clear(rid RID.NativeMenu) { //gd:NativeMenu.clear
	once.Do(singleton)
	Advanced().Clear(RID.Any(rid))
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
func Advanced() class { once.Do(singleton); return self }

type class [1]gdclass.NativeMenu

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = pointers.AsA[gdclass.NativeMenu](obj[0])
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = pointers.AsA[gdclass.NativeMenu](obj[0])
		return true
	}
	return false
}
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }
func (self *Extension[T]) AsObject() [1]gd.Object { return self.Super().AsObject() }

/*
Returns [code]true[/code] if the specified [param feature] is supported by the current [NativeMenu], [code]false[/code] otherwise.
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
//go:nosplit
func (self class) HasFeature(feature Feature) bool { //gd:NativeMenu.has_feature
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.has_feature, gdextension.SizeBool|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ feature Feature }{feature}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if a special system menu is supported.
[b]Note:[/b] This method is implemented only on macOS.
*/
//go:nosplit
func (self class) HasSystemMenu(menu_id SystemMenus) bool { //gd:NativeMenu.has_system_menu
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.has_system_menu, gdextension.SizeBool|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ menu_id SystemMenus }{menu_id}))
	var ret = r_ret
	return ret
}

/*
Returns RID of a special system menu.
[b]Note:[/b] This method is implemented only on macOS.
*/
//go:nosplit
func (self class) GetSystemMenu(menu_id SystemMenus) RID.Any { //gd:NativeMenu.get_system_menu
	var r_ret = gdextension.Call[RID.Any](gd.ObjectChecked(self.AsObject()), methods.get_system_menu, gdextension.SizeRID|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ menu_id SystemMenus }{menu_id}))
	var ret = r_ret
	return ret
}

/*
Returns readable name of a special system menu.
[b]Note:[/b] This method is implemented only on macOS.
*/
//go:nosplit
func (self class) GetSystemMenuName(menu_id SystemMenus) String.Readable { //gd:NativeMenu.get_system_menu_name
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_system_menu_name, gdextension.SizeString|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ menu_id SystemMenus }{menu_id}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Creates a new global menu object.
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
//go:nosplit
func (self class) CreateMenu() RID.Any { //gd:NativeMenu.create_menu
	var r_ret = gdextension.Call[RID.Any](gd.ObjectChecked(self.AsObject()), methods.create_menu, gdextension.SizeRID, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if [param rid] is valid global menu.
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
//go:nosplit
func (self class) HasMenu(rid RID.Any) bool { //gd:NativeMenu.has_menu
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.has_menu, gdextension.SizeBool|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ rid RID.Any }{rid}))
	var ret = r_ret
	return ret
}

/*
Frees a global menu object created by this [NativeMenu].
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
//go:nosplit
func (self class) FreeMenu(rid RID.Any) { //gd:NativeMenu.free_menu
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.free_menu, 0|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ rid RID.Any }{rid}))
}

/*
Returns global menu size.
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
//go:nosplit
func (self class) GetSize(rid RID.Any) Vector2.XY { //gd:NativeMenu.get_size
	var r_ret = gdextension.Call[Vector2.XY](gd.ObjectChecked(self.AsObject()), methods.get_size, gdextension.SizeVector2|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ rid RID.Any }{rid}))
	var ret = r_ret
	return ret
}

/*
Shows the global menu at [param position] in the screen coordinates.
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
//go:nosplit
func (self class) Popup(rid RID.Any, position Vector2i.XY) { //gd:NativeMenu.popup
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.popup, 0|(gdextension.SizeRID<<4)|(gdextension.SizeVector2i<<8), unsafe.Pointer(&struct {
		rid      RID.Any
		position Vector2i.XY
	}{rid, position}))
}

/*
Sets the menu text layout direction from right-to-left if [param is_rtl] is [code]true[/code].
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
//go:nosplit
func (self class) SetInterfaceDirection(rid RID.Any, is_rtl bool) { //gd:NativeMenu.set_interface_direction
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_interface_direction, 0|(gdextension.SizeRID<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		rid    RID.Any
		is_rtl bool
	}{rid, is_rtl}))
}

/*
Registers callable to emit after the menu is closed.
[b]Note:[/b] This method is implemented only on macOS.
*/
//go:nosplit
func (self class) SetPopupOpenCallback(rid RID.Any, callback Callable.Function) { //gd:NativeMenu.set_popup_open_callback
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_popup_open_callback, 0|(gdextension.SizeRID<<4)|(gdextension.SizeCallable<<8), unsafe.Pointer(&struct {
		rid      RID.Any
		callback gdextension.Callable
	}{rid, pointers.Get(gd.InternalCallable(callback))}))
}

/*
Returns global menu open callback.
b]Note:[/b] This method is implemented only on macOS.
*/
//go:nosplit
func (self class) GetPopupOpenCallback(rid RID.Any) Callable.Function { //gd:NativeMenu.get_popup_open_callback
	var r_ret = gdextension.Call[gdextension.Callable](gd.ObjectChecked(self.AsObject()), methods.get_popup_open_callback, gdextension.SizeCallable|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ rid RID.Any }{rid}))
	var ret = Callable.Through(gd.CallableProxy{}, pointers.Pack(pointers.New[gd.Callable](r_ret)))
	return ret
}

/*
Registers callable to emit when the menu is about to show.
[b]Note:[/b] The OS can simulate menu opening to track menu item changes and global shortcuts, in which case the corresponding close callback is not triggered. Use [method is_opened] to check if the menu is currently opened.
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
//go:nosplit
func (self class) SetPopupCloseCallback(rid RID.Any, callback Callable.Function) { //gd:NativeMenu.set_popup_close_callback
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_popup_close_callback, 0|(gdextension.SizeRID<<4)|(gdextension.SizeCallable<<8), unsafe.Pointer(&struct {
		rid      RID.Any
		callback gdextension.Callable
	}{rid, pointers.Get(gd.InternalCallable(callback))}))
}

/*
Returns global menu close callback.
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
//go:nosplit
func (self class) GetPopupCloseCallback(rid RID.Any) Callable.Function { //gd:NativeMenu.get_popup_close_callback
	var r_ret = gdextension.Call[gdextension.Callable](gd.ObjectChecked(self.AsObject()), methods.get_popup_close_callback, gdextension.SizeCallable|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ rid RID.Any }{rid}))
	var ret = Callable.Through(gd.CallableProxy{}, pointers.Pack(pointers.New[gd.Callable](r_ret)))
	return ret
}

/*
Sets the minimum width of the global menu.
[b]Note:[/b] This method is implemented only on macOS.
*/
//go:nosplit
func (self class) SetMinimumWidth(rid RID.Any, width float64) { //gd:NativeMenu.set_minimum_width
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_minimum_width, 0|(gdextension.SizeRID<<4)|(gdextension.SizeFloat<<8), unsafe.Pointer(&struct {
		rid   RID.Any
		width float64
	}{rid, width}))
}

/*
Returns global menu minimum width.
[b]Note:[/b] This method is implemented only on macOS.
*/
//go:nosplit
func (self class) GetMinimumWidth(rid RID.Any) float64 { //gd:NativeMenu.get_minimum_width
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_minimum_width, gdextension.SizeFloat|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ rid RID.Any }{rid}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if the menu is currently opened.
[b]Note:[/b] This method is implemented only on macOS.
*/
//go:nosplit
func (self class) IsOpened(rid RID.Any) bool { //gd:NativeMenu.is_opened
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_opened, gdextension.SizeBool|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ rid RID.Any }{rid}))
	var ret = r_ret
	return ret
}

/*
Adds an item that will act as a submenu of the global menu [param rid]. The [param submenu_rid] argument is the RID of the global menu that will be shown when the item is clicked.
Returns index of the inserted item, it's not guaranteed to be the same as [param index] value.
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
//go:nosplit
func (self class) AddSubmenuItem(rid RID.Any, label String.Readable, submenu_rid RID.Any, tag variant.Any, index int64) int64 { //gd:NativeMenu.add_submenu_item
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.add_submenu_item, gdextension.SizeInt|(gdextension.SizeRID<<4)|(gdextension.SizeString<<8)|(gdextension.SizeRID<<12)|(gdextension.SizeVariant<<16)|(gdextension.SizeInt<<20), unsafe.Pointer(&struct {
		rid         RID.Any
		label       gdextension.String
		submenu_rid RID.Any
		tag         gdextension.Variant
		index       int64
	}{rid, pointers.Get(gd.InternalString(label)), submenu_rid, gdextension.Variant(pointers.Get(gd.InternalVariant(tag))), index}))
	var ret = r_ret
	return ret
}

/*
Adds a new item with text [param label] to the global menu [param rid].
Returns index of the inserted item, it's not guaranteed to be the same as [param index] value.
An [param accelerator] can optionally be defined, which is a keyboard shortcut that can be pressed to trigger the menu button even if it's not currently open. The [param accelerator] is generally a combination of [enum KeyModifierMask]s and [enum Key]s using bitwise OR such as [code]KEY_MASK_CTRL | KEY_A[/code] ([kbd]Ctrl + A[/kbd]).
[b]Note:[/b] The [param callback] and [param key_callback] Callables need to accept exactly one Variant parameter, the parameter passed to the Callables will be the value passed to [param tag].
[b]Note:[/b] This method is implemented on macOS and Windows.
[b]Note:[/b] On Windows, [param accelerator] and [param key_callback] are ignored.
*/
//go:nosplit
func (self class) AddItem(rid RID.Any, label String.Readable, callback Callable.Function, key_callback Callable.Function, tag variant.Any, accelerator Input.Key, index int64) int64 { //gd:NativeMenu.add_item
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.add_item, gdextension.SizeInt|(gdextension.SizeRID<<4)|(gdextension.SizeString<<8)|(gdextension.SizeCallable<<12)|(gdextension.SizeCallable<<16)|(gdextension.SizeVariant<<20)|(gdextension.SizeInt<<24)|(gdextension.SizeInt<<28), unsafe.Pointer(&struct {
		rid          RID.Any
		label        gdextension.String
		callback     gdextension.Callable
		key_callback gdextension.Callable
		tag          gdextension.Variant
		accelerator  Input.Key
		index        int64
	}{rid, pointers.Get(gd.InternalString(label)), pointers.Get(gd.InternalCallable(callback)), pointers.Get(gd.InternalCallable(key_callback)), gdextension.Variant(pointers.Get(gd.InternalVariant(tag))), accelerator, index}))
	var ret = r_ret
	return ret
}

/*
Adds a new checkable item with text [param label] to the global menu [param rid].
Returns index of the inserted item, it's not guaranteed to be the same as [param index] value.
An [param accelerator] can optionally be defined, which is a keyboard shortcut that can be pressed to trigger the menu button even if it's not currently open. The [param accelerator] is generally a combination of [enum KeyModifierMask]s and [enum Key]s using bitwise OR such as [code]KEY_MASK_CTRL | KEY_A[/code] ([kbd]Ctrl + A[/kbd]).
[b]Note:[/b] The [param callback] and [param key_callback] Callables need to accept exactly one Variant parameter, the parameter passed to the Callables will be the value passed to [param tag].
[b]Note:[/b] This method is implemented on macOS and Windows.
[b]Note:[/b] On Windows, [param accelerator] and [param key_callback] are ignored.
*/
//go:nosplit
func (self class) AddCheckItem(rid RID.Any, label String.Readable, callback Callable.Function, key_callback Callable.Function, tag variant.Any, accelerator Input.Key, index int64) int64 { //gd:NativeMenu.add_check_item
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.add_check_item, gdextension.SizeInt|(gdextension.SizeRID<<4)|(gdextension.SizeString<<8)|(gdextension.SizeCallable<<12)|(gdextension.SizeCallable<<16)|(gdextension.SizeVariant<<20)|(gdextension.SizeInt<<24)|(gdextension.SizeInt<<28), unsafe.Pointer(&struct {
		rid          RID.Any
		label        gdextension.String
		callback     gdextension.Callable
		key_callback gdextension.Callable
		tag          gdextension.Variant
		accelerator  Input.Key
		index        int64
	}{rid, pointers.Get(gd.InternalString(label)), pointers.Get(gd.InternalCallable(callback)), pointers.Get(gd.InternalCallable(key_callback)), gdextension.Variant(pointers.Get(gd.InternalVariant(tag))), accelerator, index}))
	var ret = r_ret
	return ret
}

/*
Adds a new item with text [param label] and icon [param icon] to the global menu [param rid].
Returns index of the inserted item, it's not guaranteed to be the same as [param index] value.
An [param accelerator] can optionally be defined, which is a keyboard shortcut that can be pressed to trigger the menu button even if it's not currently open. The [param accelerator] is generally a combination of [enum KeyModifierMask]s and [enum Key]s using bitwise OR such as [code]KEY_MASK_CTRL | KEY_A[/code] ([kbd]Ctrl + A[/kbd]).
[b]Note:[/b] The [param callback] and [param key_callback] Callables need to accept exactly one Variant parameter, the parameter passed to the Callables will be the value passed to [param tag].
[b]Note:[/b] This method is implemented on macOS and Windows.
[b]Note:[/b] On Windows, [param accelerator] and [param key_callback] are ignored.
*/
//go:nosplit
func (self class) AddIconItem(rid RID.Any, icon [1]gdclass.Texture2D, label String.Readable, callback Callable.Function, key_callback Callable.Function, tag variant.Any, accelerator Input.Key, index int64) int64 { //gd:NativeMenu.add_icon_item
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.add_icon_item, gdextension.SizeInt|(gdextension.SizeRID<<4)|(gdextension.SizeObject<<8)|(gdextension.SizeString<<12)|(gdextension.SizeCallable<<16)|(gdextension.SizeCallable<<20)|(gdextension.SizeVariant<<24)|(gdextension.SizeInt<<28)|(gdextension.SizeInt<<32), unsafe.Pointer(&struct {
		rid          RID.Any
		icon         gdextension.Object
		label        gdextension.String
		callback     gdextension.Callable
		key_callback gdextension.Callable
		tag          gdextension.Variant
		accelerator  Input.Key
		index        int64
	}{rid, gdextension.Object(gd.ObjectChecked(icon[0].AsObject())), pointers.Get(gd.InternalString(label)), pointers.Get(gd.InternalCallable(callback)), pointers.Get(gd.InternalCallable(key_callback)), gdextension.Variant(pointers.Get(gd.InternalVariant(tag))), accelerator, index}))
	var ret = r_ret
	return ret
}

/*
Adds a new checkable item with text [param label] and icon [param icon] to the global menu [param rid].
Returns index of the inserted item, it's not guaranteed to be the same as [param index] value.
An [param accelerator] can optionally be defined, which is a keyboard shortcut that can be pressed to trigger the menu button even if it's not currently open. The [param accelerator] is generally a combination of [enum KeyModifierMask]s and [enum Key]s using bitwise OR such as [code]KEY_MASK_CTRL | KEY_A[/code] ([kbd]Ctrl + A[/kbd]).
[b]Note:[/b] The [param callback] and [param key_callback] Callables need to accept exactly one Variant parameter, the parameter passed to the Callables will be the value passed to [param tag].
[b]Note:[/b] This method is implemented on macOS and Windows.
[b]Note:[/b] On Windows, [param accelerator] and [param key_callback] are ignored.
*/
//go:nosplit
func (self class) AddIconCheckItem(rid RID.Any, icon [1]gdclass.Texture2D, label String.Readable, callback Callable.Function, key_callback Callable.Function, tag variant.Any, accelerator Input.Key, index int64) int64 { //gd:NativeMenu.add_icon_check_item
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.add_icon_check_item, gdextension.SizeInt|(gdextension.SizeRID<<4)|(gdextension.SizeObject<<8)|(gdextension.SizeString<<12)|(gdextension.SizeCallable<<16)|(gdextension.SizeCallable<<20)|(gdextension.SizeVariant<<24)|(gdextension.SizeInt<<28)|(gdextension.SizeInt<<32), unsafe.Pointer(&struct {
		rid          RID.Any
		icon         gdextension.Object
		label        gdextension.String
		callback     gdextension.Callable
		key_callback gdextension.Callable
		tag          gdextension.Variant
		accelerator  Input.Key
		index        int64
	}{rid, gdextension.Object(gd.ObjectChecked(icon[0].AsObject())), pointers.Get(gd.InternalString(label)), pointers.Get(gd.InternalCallable(callback)), pointers.Get(gd.InternalCallable(key_callback)), gdextension.Variant(pointers.Get(gd.InternalVariant(tag))), accelerator, index}))
	var ret = r_ret
	return ret
}

/*
Adds a new radio-checkable item with text [param label] to the global menu [param rid].
Returns index of the inserted item, it's not guaranteed to be the same as [param index] value.
An [param accelerator] can optionally be defined, which is a keyboard shortcut that can be pressed to trigger the menu button even if it's not currently open. The [param accelerator] is generally a combination of [enum KeyModifierMask]s and [enum Key]s using bitwise OR such as [code]KEY_MASK_CTRL | KEY_A[/code] ([kbd]Ctrl + A[/kbd]).
[b]Note:[/b] Radio-checkable items just display a checkmark, but don't have any built-in checking behavior and must be checked/unchecked manually. See [method set_item_checked] for more info on how to control it.
[b]Note:[/b] The [param callback] and [param key_callback] Callables need to accept exactly one Variant parameter, the parameter passed to the Callables will be the value passed to [param tag].
[b]Note:[/b] This method is implemented on macOS and Windows.
[b]Note:[/b] On Windows, [param accelerator] and [param key_callback] are ignored.
*/
//go:nosplit
func (self class) AddRadioCheckItem(rid RID.Any, label String.Readable, callback Callable.Function, key_callback Callable.Function, tag variant.Any, accelerator Input.Key, index int64) int64 { //gd:NativeMenu.add_radio_check_item
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.add_radio_check_item, gdextension.SizeInt|(gdextension.SizeRID<<4)|(gdextension.SizeString<<8)|(gdextension.SizeCallable<<12)|(gdextension.SizeCallable<<16)|(gdextension.SizeVariant<<20)|(gdextension.SizeInt<<24)|(gdextension.SizeInt<<28), unsafe.Pointer(&struct {
		rid          RID.Any
		label        gdextension.String
		callback     gdextension.Callable
		key_callback gdextension.Callable
		tag          gdextension.Variant
		accelerator  Input.Key
		index        int64
	}{rid, pointers.Get(gd.InternalString(label)), pointers.Get(gd.InternalCallable(callback)), pointers.Get(gd.InternalCallable(key_callback)), gdextension.Variant(pointers.Get(gd.InternalVariant(tag))), accelerator, index}))
	var ret = r_ret
	return ret
}

/*
Adds a new radio-checkable item with text [param label] and icon [param icon] to the global menu [param rid].
Returns index of the inserted item, it's not guaranteed to be the same as [param index] value.
An [param accelerator] can optionally be defined, which is a keyboard shortcut that can be pressed to trigger the menu button even if it's not currently open. The [param accelerator] is generally a combination of [enum KeyModifierMask]s and [enum Key]s using bitwise OR such as [code]KEY_MASK_CTRL | KEY_A[/code] ([kbd]Ctrl + A[/kbd]).
[b]Note:[/b] Radio-checkable items just display a checkmark, but don't have any built-in checking behavior and must be checked/unchecked manually. See [method set_item_checked] for more info on how to control it.
[b]Note:[/b] The [param callback] and [param key_callback] Callables need to accept exactly one Variant parameter, the parameter passed to the Callables will be the value passed to [param tag].
[b]Note:[/b] This method is implemented on macOS and Windows.
[b]Note:[/b] On Windows, [param accelerator] and [param key_callback] are ignored.
*/
//go:nosplit
func (self class) AddIconRadioCheckItem(rid RID.Any, icon [1]gdclass.Texture2D, label String.Readable, callback Callable.Function, key_callback Callable.Function, tag variant.Any, accelerator Input.Key, index int64) int64 { //gd:NativeMenu.add_icon_radio_check_item
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.add_icon_radio_check_item, gdextension.SizeInt|(gdextension.SizeRID<<4)|(gdextension.SizeObject<<8)|(gdextension.SizeString<<12)|(gdextension.SizeCallable<<16)|(gdextension.SizeCallable<<20)|(gdextension.SizeVariant<<24)|(gdextension.SizeInt<<28)|(gdextension.SizeInt<<32), unsafe.Pointer(&struct {
		rid          RID.Any
		icon         gdextension.Object
		label        gdextension.String
		callback     gdextension.Callable
		key_callback gdextension.Callable
		tag          gdextension.Variant
		accelerator  Input.Key
		index        int64
	}{rid, gdextension.Object(gd.ObjectChecked(icon[0].AsObject())), pointers.Get(gd.InternalString(label)), pointers.Get(gd.InternalCallable(callback)), pointers.Get(gd.InternalCallable(key_callback)), gdextension.Variant(pointers.Get(gd.InternalVariant(tag))), accelerator, index}))
	var ret = r_ret
	return ret
}

/*
Adds a new item with text [param label] to the global menu [param rid].
Contrarily to normal binary items, multistate items can have more than two states, as defined by [param max_states]. Each press or activate of the item will increase the state by one. The default value is defined by [param default_state].
Returns index of the inserted item, it's not guaranteed to be the same as [param index] value.
An [param accelerator] can optionally be defined, which is a keyboard shortcut that can be pressed to trigger the menu button even if it's not currently open. The [param accelerator] is generally a combination of [enum KeyModifierMask]s and [enum Key]s using bitwise OR such as [code]KEY_MASK_CTRL | KEY_A[/code] ([kbd]Ctrl + A[/kbd]).
[b]Note:[/b] By default, there's no indication of the current item state, it should be changed manually.
[b]Note:[/b] The [param callback] and [param key_callback] Callables need to accept exactly one Variant parameter, the parameter passed to the Callables will be the value passed to [param tag].
[b]Note:[/b] This method is implemented on macOS and Windows.
[b]Note:[/b] On Windows, [param accelerator] and [param key_callback] are ignored.
*/
//go:nosplit
func (self class) AddMultistateItem(rid RID.Any, label String.Readable, max_states int64, default_state int64, callback Callable.Function, key_callback Callable.Function, tag variant.Any, accelerator Input.Key, index int64) int64 { //gd:NativeMenu.add_multistate_item
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.add_multistate_item, gdextension.SizeInt|(gdextension.SizeRID<<4)|(gdextension.SizeString<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeInt<<16)|(gdextension.SizeCallable<<20)|(gdextension.SizeCallable<<24)|(gdextension.SizeVariant<<28)|(gdextension.SizeInt<<32)|(gdextension.SizeInt<<36), unsafe.Pointer(&struct {
		rid           RID.Any
		label         gdextension.String
		max_states    int64
		default_state int64
		callback      gdextension.Callable
		key_callback  gdextension.Callable
		tag           gdextension.Variant
		accelerator   Input.Key
		index         int64
	}{rid, pointers.Get(gd.InternalString(label)), max_states, default_state, pointers.Get(gd.InternalCallable(callback)), pointers.Get(gd.InternalCallable(key_callback)), gdextension.Variant(pointers.Get(gd.InternalVariant(tag))), accelerator, index}))
	var ret = r_ret
	return ret
}

/*
Adds a separator between items to the global menu [param rid]. Separators also occupy an index.
Returns index of the inserted item, it's not guaranteed to be the same as [param index] value.
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
//go:nosplit
func (self class) AddSeparator(rid RID.Any, index int64) int64 { //gd:NativeMenu.add_separator
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.add_separator, gdextension.SizeInt|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		rid   RID.Any
		index int64
	}{rid, index}))
	var ret = r_ret
	return ret
}

/*
Returns the index of the item with the specified [param text]. Indices are automatically assigned to each item by the engine, and cannot be set manually.
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
//go:nosplit
func (self class) FindItemIndexWithText(rid RID.Any, text String.Readable) int64 { //gd:NativeMenu.find_item_index_with_text
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.find_item_index_with_text, gdextension.SizeInt|(gdextension.SizeRID<<4)|(gdextension.SizeString<<8), unsafe.Pointer(&struct {
		rid  RID.Any
		text gdextension.String
	}{rid, pointers.Get(gd.InternalString(text))}))
	var ret = r_ret
	return ret
}

/*
Returns the index of the item with the specified [param tag]. Indices are automatically assigned to each item by the engine, and cannot be set manually.
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
//go:nosplit
func (self class) FindItemIndexWithTag(rid RID.Any, tag variant.Any) int64 { //gd:NativeMenu.find_item_index_with_tag
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.find_item_index_with_tag, gdextension.SizeInt|(gdextension.SizeRID<<4)|(gdextension.SizeVariant<<8), unsafe.Pointer(&struct {
		rid RID.Any
		tag gdextension.Variant
	}{rid, gdextension.Variant(pointers.Get(gd.InternalVariant(tag)))}))
	var ret = r_ret
	return ret
}

/*
Returns the index of the item with the submenu specified by [param submenu_rid]. Indices are automatically assigned to each item by the engine, and cannot be set manually.
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
//go:nosplit
func (self class) FindItemIndexWithSubmenu(rid RID.Any, submenu_rid RID.Any) int64 { //gd:NativeMenu.find_item_index_with_submenu
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.find_item_index_with_submenu, gdextension.SizeInt|(gdextension.SizeRID<<4)|(gdextension.SizeRID<<8), unsafe.Pointer(&struct {
		rid         RID.Any
		submenu_rid RID.Any
	}{rid, submenu_rid}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if the item at index [param idx] is checked.
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
//go:nosplit
func (self class) IsItemChecked(rid RID.Any, idx int64) bool { //gd:NativeMenu.is_item_checked
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_item_checked, gdextension.SizeBool|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		rid RID.Any
		idx int64
	}{rid, idx}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if the item at index [param idx] is checkable in some way, i.e. if it has a checkbox or radio button.
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
//go:nosplit
func (self class) IsItemCheckable(rid RID.Any, idx int64) bool { //gd:NativeMenu.is_item_checkable
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_item_checkable, gdextension.SizeBool|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		rid RID.Any
		idx int64
	}{rid, idx}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if the item at index [param idx] has radio button-style checkability.
[b]Note:[/b] This is purely cosmetic; you must add the logic for checking/unchecking items in radio groups.
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
//go:nosplit
func (self class) IsItemRadioCheckable(rid RID.Any, idx int64) bool { //gd:NativeMenu.is_item_radio_checkable
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_item_radio_checkable, gdextension.SizeBool|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		rid RID.Any
		idx int64
	}{rid, idx}))
	var ret = r_ret
	return ret
}

/*
Returns the callback of the item at index [param idx].
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
//go:nosplit
func (self class) GetItemCallback(rid RID.Any, idx int64) Callable.Function { //gd:NativeMenu.get_item_callback
	var r_ret = gdextension.Call[gdextension.Callable](gd.ObjectChecked(self.AsObject()), methods.get_item_callback, gdextension.SizeCallable|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		rid RID.Any
		idx int64
	}{rid, idx}))
	var ret = Callable.Through(gd.CallableProxy{}, pointers.Pack(pointers.New[gd.Callable](r_ret)))
	return ret
}

/*
Returns the callback of the item accelerator at index [param idx].
[b]Note:[/b] This method is implemented only on macOS.
*/
//go:nosplit
func (self class) GetItemKeyCallback(rid RID.Any, idx int64) Callable.Function { //gd:NativeMenu.get_item_key_callback
	var r_ret = gdextension.Call[gdextension.Callable](gd.ObjectChecked(self.AsObject()), methods.get_item_key_callback, gdextension.SizeCallable|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		rid RID.Any
		idx int64
	}{rid, idx}))
	var ret = Callable.Through(gd.CallableProxy{}, pointers.Pack(pointers.New[gd.Callable](r_ret)))
	return ret
}

/*
Returns the metadata of the specified item, which might be of any type. You can set it with [method set_item_tag], which provides a simple way of assigning context data to items.
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
//go:nosplit
func (self class) GetItemTag(rid RID.Any, idx int64) variant.Any { //gd:NativeMenu.get_item_tag
	var r_ret = gdextension.Call[gdextension.Variant](gd.ObjectChecked(self.AsObject()), methods.get_item_tag, gdextension.SizeVariant|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		rid RID.Any
		idx int64
	}{rid, idx}))
	var ret = variant.Implementation(gd.VariantProxy{}, pointers.Pack(pointers.New[gd.Variant](r_ret)))
	return ret
}

/*
Returns the text of the item at index [param idx].
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
//go:nosplit
func (self class) GetItemText(rid RID.Any, idx int64) String.Readable { //gd:NativeMenu.get_item_text
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_item_text, gdextension.SizeString|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		rid RID.Any
		idx int64
	}{rid, idx}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Returns the submenu ID of the item at index [param idx]. See [method add_submenu_item] for more info on how to add a submenu.
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
//go:nosplit
func (self class) GetItemSubmenu(rid RID.Any, idx int64) RID.Any { //gd:NativeMenu.get_item_submenu
	var r_ret = gdextension.Call[RID.Any](gd.ObjectChecked(self.AsObject()), methods.get_item_submenu, gdextension.SizeRID|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		rid RID.Any
		idx int64
	}{rid, idx}))
	var ret = r_ret
	return ret
}

/*
Returns the accelerator of the item at index [param idx]. Accelerators are special combinations of keys that activate the item, no matter which control is focused.
[b]Note:[/b] This method is implemented only on macOS.
*/
//go:nosplit
func (self class) GetItemAccelerator(rid RID.Any, idx int64) Input.Key { //gd:NativeMenu.get_item_accelerator
	var r_ret = gdextension.Call[Input.Key](gd.ObjectChecked(self.AsObject()), methods.get_item_accelerator, gdextension.SizeInt|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		rid RID.Any
		idx int64
	}{rid, idx}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if the item at index [param idx] is disabled. When it is disabled it can't be selected, or its action invoked.
See [method set_item_disabled] for more info on how to disable an item.
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
//go:nosplit
func (self class) IsItemDisabled(rid RID.Any, idx int64) bool { //gd:NativeMenu.is_item_disabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_item_disabled, gdextension.SizeBool|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		rid RID.Any
		idx int64
	}{rid, idx}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if the item at index [param idx] is hidden.
See [method set_item_hidden] for more info on how to hide an item.
[b]Note:[/b] This method is implemented only on macOS.
*/
//go:nosplit
func (self class) IsItemHidden(rid RID.Any, idx int64) bool { //gd:NativeMenu.is_item_hidden
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_item_hidden, gdextension.SizeBool|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		rid RID.Any
		idx int64
	}{rid, idx}))
	var ret = r_ret
	return ret
}

/*
Returns the tooltip associated with the specified index [param idx].
[b]Note:[/b] This method is implemented only on macOS.
*/
//go:nosplit
func (self class) GetItemTooltip(rid RID.Any, idx int64) String.Readable { //gd:NativeMenu.get_item_tooltip
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_item_tooltip, gdextension.SizeString|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		rid RID.Any
		idx int64
	}{rid, idx}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Returns the state of a multistate item. See [method add_multistate_item] for details.
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
//go:nosplit
func (self class) GetItemState(rid RID.Any, idx int64) int64 { //gd:NativeMenu.get_item_state
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_item_state, gdextension.SizeInt|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		rid RID.Any
		idx int64
	}{rid, idx}))
	var ret = r_ret
	return ret
}

/*
Returns number of states of a multistate item. See [method add_multistate_item] for details.
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
//go:nosplit
func (self class) GetItemMaxStates(rid RID.Any, idx int64) int64 { //gd:NativeMenu.get_item_max_states
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_item_max_states, gdextension.SizeInt|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		rid RID.Any
		idx int64
	}{rid, idx}))
	var ret = r_ret
	return ret
}

/*
Returns the icon of the item at index [param idx].
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
//go:nosplit
func (self class) GetItemIcon(rid RID.Any, idx int64) [1]gdclass.Texture2D { //gd:NativeMenu.get_item_icon
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_item_icon, gdextension.SizeObject|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		rid RID.Any
		idx int64
	}{rid, idx}))
	var ret = [1]gdclass.Texture2D{gd.PointerWithOwnershipTransferredToGo[gdclass.Texture2D](r_ret)}
	return ret
}

/*
Returns the horizontal offset of the item at the given [param idx].
[b]Note:[/b] This method is implemented only on macOS.
*/
//go:nosplit
func (self class) GetItemIndentationLevel(rid RID.Any, idx int64) int64 { //gd:NativeMenu.get_item_indentation_level
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_item_indentation_level, gdextension.SizeInt|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		rid RID.Any
		idx int64
	}{rid, idx}))
	var ret = r_ret
	return ret
}

/*
Sets the checkstate status of the item at index [param idx].
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
//go:nosplit
func (self class) SetItemChecked(rid RID.Any, idx int64, checked bool) { //gd:NativeMenu.set_item_checked
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_checked, 0|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeBool<<12), unsafe.Pointer(&struct {
		rid     RID.Any
		idx     int64
		checked bool
	}{rid, idx, checked}))
}

/*
Sets whether the item at index [param idx] has a checkbox. If [code]false[/code], sets the type of the item to plain text.
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
//go:nosplit
func (self class) SetItemCheckable(rid RID.Any, idx int64, checkable bool) { //gd:NativeMenu.set_item_checkable
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_checkable, 0|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeBool<<12), unsafe.Pointer(&struct {
		rid       RID.Any
		idx       int64
		checkable bool
	}{rid, idx, checkable}))
}

/*
Sets the type of the item at the specified index [param idx] to radio button. If [code]false[/code], sets the type of the item to plain text.
[b]Note:[/b] This is purely cosmetic; you must add the logic for checking/unchecking items in radio groups.
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
//go:nosplit
func (self class) SetItemRadioCheckable(rid RID.Any, idx int64, checkable bool) { //gd:NativeMenu.set_item_radio_checkable
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_radio_checkable, 0|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeBool<<12), unsafe.Pointer(&struct {
		rid       RID.Any
		idx       int64
		checkable bool
	}{rid, idx, checkable}))
}

/*
Sets the callback of the item at index [param idx]. Callback is emitted when an item is pressed.
[b]Note:[/b] The [param callback] Callable needs to accept exactly one Variant parameter, the parameter passed to the Callable will be the value passed to the [code]tag[/code] parameter when the menu item was created.
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
//go:nosplit
func (self class) SetItemCallback(rid RID.Any, idx int64, callback Callable.Function) { //gd:NativeMenu.set_item_callback
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_callback, 0|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeCallable<<12), unsafe.Pointer(&struct {
		rid      RID.Any
		idx      int64
		callback gdextension.Callable
	}{rid, idx, pointers.Get(gd.InternalCallable(callback))}))
}

/*
Sets the callback of the item at index [param idx]. The callback is emitted when an item is hovered.
[b]Note:[/b] The [param callback] Callable needs to accept exactly one Variant parameter, the parameter passed to the Callable will be the value passed to the [code]tag[/code] parameter when the menu item was created.
[b]Note:[/b] This method is implemented only on macOS.
*/
//go:nosplit
func (self class) SetItemHoverCallbacks(rid RID.Any, idx int64, callback Callable.Function) { //gd:NativeMenu.set_item_hover_callbacks
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_hover_callbacks, 0|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeCallable<<12), unsafe.Pointer(&struct {
		rid      RID.Any
		idx      int64
		callback gdextension.Callable
	}{rid, idx, pointers.Get(gd.InternalCallable(callback))}))
}

/*
Sets the callback of the item at index [param idx]. Callback is emitted when its accelerator is activated.
[b]Note:[/b] The [param key_callback] Callable needs to accept exactly one Variant parameter, the parameter passed to the Callable will be the value passed to the [code]tag[/code] parameter when the menu item was created.
[b]Note:[/b] This method is implemented only on macOS.
*/
//go:nosplit
func (self class) SetItemKeyCallback(rid RID.Any, idx int64, key_callback Callable.Function) { //gd:NativeMenu.set_item_key_callback
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_key_callback, 0|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeCallable<<12), unsafe.Pointer(&struct {
		rid          RID.Any
		idx          int64
		key_callback gdextension.Callable
	}{rid, idx, pointers.Get(gd.InternalCallable(key_callback))}))
}

/*
Sets the metadata of an item, which may be of any type. You can later get it with [method get_item_tag], which provides a simple way of assigning context data to items.
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
//go:nosplit
func (self class) SetItemTag(rid RID.Any, idx int64, tag variant.Any) { //gd:NativeMenu.set_item_tag
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_tag, 0|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeVariant<<12), unsafe.Pointer(&struct {
		rid RID.Any
		idx int64
		tag gdextension.Variant
	}{rid, idx, gdextension.Variant(pointers.Get(gd.InternalVariant(tag)))}))
}

/*
Sets the text of the item at index [param idx].
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
//go:nosplit
func (self class) SetItemText(rid RID.Any, idx int64, text String.Readable) { //gd:NativeMenu.set_item_text
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_text, 0|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeString<<12), unsafe.Pointer(&struct {
		rid  RID.Any
		idx  int64
		text gdextension.String
	}{rid, idx, pointers.Get(gd.InternalString(text))}))
}

/*
Sets the submenu RID of the item at index [param idx]. The submenu is a global menu that would be shown when the item is clicked.
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
//go:nosplit
func (self class) SetItemSubmenu(rid RID.Any, idx int64, submenu_rid RID.Any) { //gd:NativeMenu.set_item_submenu
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_submenu, 0|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeRID<<12), unsafe.Pointer(&struct {
		rid         RID.Any
		idx         int64
		submenu_rid RID.Any
	}{rid, idx, submenu_rid}))
}

/*
Sets the accelerator of the item at index [param idx]. [param keycode] can be a single [enum Key], or a combination of [enum KeyModifierMask]s and [enum Key]s using bitwise OR such as [code]KEY_MASK_CTRL | KEY_A[/code] ([kbd]Ctrl + A[/kbd]).
[b]Note:[/b] This method is implemented only on macOS.
*/
//go:nosplit
func (self class) SetItemAccelerator(rid RID.Any, idx int64, keycode Input.Key) { //gd:NativeMenu.set_item_accelerator
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_accelerator, 0|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		rid     RID.Any
		idx     int64
		keycode Input.Key
	}{rid, idx, keycode}))
}

/*
Enables/disables the item at index [param idx]. When it is disabled, it can't be selected and its action can't be invoked.
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
//go:nosplit
func (self class) SetItemDisabled(rid RID.Any, idx int64, disabled bool) { //gd:NativeMenu.set_item_disabled
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_disabled, 0|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeBool<<12), unsafe.Pointer(&struct {
		rid      RID.Any
		idx      int64
		disabled bool
	}{rid, idx, disabled}))
}

/*
Hides/shows the item at index [param idx]. When it is hidden, an item does not appear in a menu and its action cannot be invoked.
[b]Note:[/b] This method is implemented only on macOS.
*/
//go:nosplit
func (self class) SetItemHidden(rid RID.Any, idx int64, hidden bool) { //gd:NativeMenu.set_item_hidden
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_hidden, 0|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeBool<<12), unsafe.Pointer(&struct {
		rid    RID.Any
		idx    int64
		hidden bool
	}{rid, idx, hidden}))
}

/*
Sets the [String] tooltip of the item at the specified index [param idx].
[b]Note:[/b] This method is implemented only on macOS.
*/
//go:nosplit
func (self class) SetItemTooltip(rid RID.Any, idx int64, tooltip String.Readable) { //gd:NativeMenu.set_item_tooltip
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_tooltip, 0|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeString<<12), unsafe.Pointer(&struct {
		rid     RID.Any
		idx     int64
		tooltip gdextension.String
	}{rid, idx, pointers.Get(gd.InternalString(tooltip))}))
}

/*
Sets the state of a multistate item. See [method add_multistate_item] for details.
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
//go:nosplit
func (self class) SetItemState(rid RID.Any, idx int64, state int64) { //gd:NativeMenu.set_item_state
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_state, 0|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		rid   RID.Any
		idx   int64
		state int64
	}{rid, idx, state}))
}

/*
Sets number of state of a multistate item. See [method add_multistate_item] for details.
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
//go:nosplit
func (self class) SetItemMaxStates(rid RID.Any, idx int64, max_states int64) { //gd:NativeMenu.set_item_max_states
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_max_states, 0|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		rid        RID.Any
		idx        int64
		max_states int64
	}{rid, idx, max_states}))
}

/*
Replaces the [Texture2D] icon of the specified [param idx].
[b]Note:[/b] This method is implemented on macOS and Windows.
[b]Note:[/b] This method is not supported by macOS Dock menu items.
*/
//go:nosplit
func (self class) SetItemIcon(rid RID.Any, idx int64, icon [1]gdclass.Texture2D) { //gd:NativeMenu.set_item_icon
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_icon, 0|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeObject<<12), unsafe.Pointer(&struct {
		rid  RID.Any
		idx  int64
		icon gdextension.Object
	}{rid, idx, gdextension.Object(gd.ObjectChecked(icon[0].AsObject()))}))
}

/*
Sets the horizontal offset of the item at the given [param idx].
[b]Note:[/b] This method is implemented only on macOS.
*/
//go:nosplit
func (self class) SetItemIndentationLevel(rid RID.Any, idx int64, level int64) { //gd:NativeMenu.set_item_indentation_level
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_indentation_level, 0|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		rid   RID.Any
		idx   int64
		level int64
	}{rid, idx, level}))
}

/*
Returns number of items in the global menu [param rid].
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
//go:nosplit
func (self class) GetItemCount(rid RID.Any) int64 { //gd:NativeMenu.get_item_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_item_count, gdextension.SizeInt|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ rid RID.Any }{rid}))
	var ret = r_ret
	return ret
}

/*
Return [code]true[/code] is global menu is a special system menu.
[b]Note:[/b] This method is implemented only on macOS.
*/
//go:nosplit
func (self class) IsSystemMenu(rid RID.Any) bool { //gd:NativeMenu.is_system_menu
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_system_menu, gdextension.SizeBool|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ rid RID.Any }{rid}))
	var ret = r_ret
	return ret
}

/*
Removes the item at index [param idx] from the global menu [param rid].
[b]Note:[/b] The indices of items after the removed item will be shifted by one.
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
//go:nosplit
func (self class) RemoveItem(rid RID.Any, idx int64) { //gd:NativeMenu.remove_item
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.remove_item, 0|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		rid RID.Any
		idx int64
	}{rid, idx}))
}

/*
Removes all items from the global menu [param rid].
[b]Note:[/b] This method is implemented on macOS and Windows.
*/
//go:nosplit
func (self class) Clear(rid RID.Any) { //gd:NativeMenu.clear
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.clear, 0|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ rid RID.Any }{rid}))
}
func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Object.Advanced(self.AsObject()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Object.Instance(self.AsObject()), name)
	}
}
func init() {
	gdclass.Register("NativeMenu", func(ptr gd.Object) any { return Instance{pointers.AsA[gdclass.NativeMenu](ptr)} })
}

type Feature int //gd:NativeMenu.Feature

const (
	/*[NativeMenu] supports native global main menu.*/
	FeatureGlobalMenu Feature = 0
	/*[NativeMenu] supports native popup menus.*/
	FeaturePopupMenu Feature = 1
	/*[NativeMenu] supports menu open and close callbacks.*/
	FeatureOpenCloseCallback Feature = 2
	/*[NativeMenu] supports menu item hover callback.*/
	FeatureHoverCallback Feature = 3
	/*[NativeMenu] supports menu item accelerator/key callback.*/
	FeatureKeyCallback Feature = 4
)

type SystemMenus int //gd:NativeMenu.SystemMenus

const (
	/*Invalid special system menu ID.*/
	InvalidMenuId SystemMenus = 0
	/*Global main menu ID.*/
	MainMenuId SystemMenus = 1
	/*Application (first menu after "Apple" menu on macOS) menu ID.*/
	ApplicationMenuId SystemMenus = 2
	/*"Window" menu ID (on macOS this menu includes standard window control items and a list of open windows).*/
	WindowMenuId SystemMenus = 3
	/*"Help" menu ID (on macOS this menu includes help search bar).*/
	HelpMenuId SystemMenus = 4
	/*Dock icon right-click menu ID (on macOS this menu include standard application control items and a list of open windows).*/
	DockMenuId SystemMenus = 5
)
