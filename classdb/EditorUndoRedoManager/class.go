// Code generated by the generate package DO NOT EDIT

// Package EditorUndoRedoManager provides methods for working with EditorUndoRedoManager object instances.
package EditorUndoRedoManager

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/UndoRedo"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
[EditorUndoRedoManager] is a manager for [UndoRedo] objects associated with edited scenes. Each scene has its own undo history and [EditorUndoRedoManager] ensures that each action performed in the editor gets associated with a proper scene. For actions not related to scenes ([ProjectSettings] edits, external resources, etc.), a separate global history is used.
The usage is mostly the same as [UndoRedo]. You create and commit actions and the manager automatically decides under-the-hood what scenes it belongs to. The scene is deduced based on the first operation in an action, using the object from the operation. The rules are as follows:
- If the object is a [Node], use the currently edited scene;
- If the object is a built-in resource, use the scene from its path;
- If the object is external resource or anything else, use global history.
This guessing can sometimes yield false results, so you can provide a custom context object when creating an action.
[EditorUndoRedoManager] is intended to be used by Godot editor plugins. You can obtain it using [method EditorPlugin.get_undo_redo]. For non-editor uses or plugins that don't need to integrate with the editor's undo history, use [UndoRedo] instead.
The manager's API is mostly the same as in [UndoRedo], so you can refer to its documentation for more examples. The main difference is that [EditorUndoRedoManager] uses object + method name for actions, instead of [Callable].
*/
type Instance [1]gdclass.EditorUndoRedoManager

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	create_action         gdextension.MethodForClass `hash:"2107025470"`
	commit_action         gdextension.MethodForClass `hash:"3216645846"`
	is_committing_action  gdextension.MethodForClass `hash:"36873697"`
	force_fixed_history   gdextension.MethodForClass `hash:"3218959716"`
	add_do_method         gdextension.MethodForClass `hash:"1517810467"`
	add_undo_method       gdextension.MethodForClass `hash:"1517810467"`
	add_do_property       gdextension.MethodForClass `hash:"1017172818"`
	add_undo_property     gdextension.MethodForClass `hash:"1017172818"`
	add_do_reference      gdextension.MethodForClass `hash:"3975164845"`
	add_undo_reference    gdextension.MethodForClass `hash:"3975164845"`
	get_object_history_id gdextension.MethodForClass `hash:"1107568780"`
	get_history_undo_redo gdextension.MethodForClass `hash:"2417974513"`
	clear_history         gdextension.MethodForClass `hash:"2020603371"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("EditorUndoRedoManager")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, true)
	})
	gd.RegisterCleanup(func() {
		pointers.Raw[gd.StringName](sname).Free()
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

type Expanded [1]gdclass.EditorUndoRedoManager

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsEditorUndoRedoManager() Instance
}

/*
Create a new action. After this is called, do all your calls to [method add_do_method], [method add_undo_method], [method add_do_property], and [method add_undo_property], then commit the action with [method commit_action].
The way actions are merged is dictated by the [param merge_mode] argument. See [enum UndoRedo.MergeMode] for details.
If [param custom_context] object is provided, it will be used for deducing target history (instead of using the first operation).
The way undo operation are ordered in actions is dictated by [param backward_undo_ops]. When [param backward_undo_ops] is [code]false[/code] undo option are ordered in the same order they were added. Which means the first operation to be added will be the first to be undone.
*/
func (self Instance) CreateAction(name string) { //gd:EditorUndoRedoManager.create_action
	Advanced(self).CreateAction(String.New(name), 0, [1]Object.Instance{}[0], false)
}

/*
Create a new action. After this is called, do all your calls to [method add_do_method], [method add_undo_method], [method add_do_property], and [method add_undo_property], then commit the action with [method commit_action].
The way actions are merged is dictated by the [param merge_mode] argument. See [enum UndoRedo.MergeMode] for details.
If [param custom_context] object is provided, it will be used for deducing target history (instead of using the first operation).
The way undo operation are ordered in actions is dictated by [param backward_undo_ops]. When [param backward_undo_ops] is [code]false[/code] undo option are ordered in the same order they were added. Which means the first operation to be added will be the first to be undone.
*/
func (self Expanded) CreateAction(name string, merge_mode UndoRedo.MergeMode, custom_context Object.Instance, backward_undo_ops bool) { //gd:EditorUndoRedoManager.create_action
	Advanced(self).CreateAction(String.New(name), merge_mode, custom_context, backward_undo_ops)
}

/*
Commits the action. If [param execute] is [code]true[/code] (default), all "do" methods/properties are called/set when this function is called.
*/
func (self Instance) CommitAction() { //gd:EditorUndoRedoManager.commit_action
	Advanced(self).CommitAction(true)
}

/*
Commits the action. If [param execute] is [code]true[/code] (default), all "do" methods/properties are called/set when this function is called.
*/
func (self Expanded) CommitAction(execute bool) { //gd:EditorUndoRedoManager.commit_action
	Advanced(self).CommitAction(execute)
}

/*
Returns [code]true[/code] if the [EditorUndoRedoManager] is currently committing the action, i.e. running its "do" method or property change (see [method commit_action]).
*/
func (self Instance) IsCommittingAction() bool { //gd:EditorUndoRedoManager.is_committing_action
	return bool(Advanced(self).IsCommittingAction())
}

/*
Forces the next operation (e.g. [method add_do_method]) to use the action's history rather than guessing it from the object. This is sometimes needed when a history can't be correctly determined, like for a nested resource that doesn't have a path yet.
This method should only be used when absolutely necessary, otherwise it might cause invalid history state. For most of complex cases, the [code]custom_context[/code] parameter of [method create_action] is sufficient.
*/
func (self Instance) ForceFixedHistory() { //gd:EditorUndoRedoManager.force_fixed_history
	Advanced(self).ForceFixedHistory()
}

/*
Register a method that will be called when the action is committed (i.e. the "do" action).
If this is the first operation, the [param object] will be used to deduce target undo history.
*/
func (self Instance) AddDoMethod(obj Object.Instance, method string, args ...any) { //gd:EditorUndoRedoManager.add_do_method
	var converted_variants = make([]gd.Variant, len(args))
	for i, arg := range args {
		converted_variants[i] = gd.NewVariant(arg)
	}
	Advanced(self).AddDoMethod(obj, String.Name(String.New(method)), converted_variants...)
}

/*
Register a method that will be called when the action is undone (i.e. the "undo" action).
If this is the first operation, the [param object] will be used to deduce target undo history.
*/
func (self Instance) AddUndoMethod(obj Object.Instance, method string, args ...any) { //gd:EditorUndoRedoManager.add_undo_method
	var converted_variants = make([]gd.Variant, len(args))
	for i, arg := range args {
		converted_variants[i] = gd.NewVariant(arg)
	}
	Advanced(self).AddUndoMethod(obj, String.Name(String.New(method)), converted_variants...)
}

/*
Register a property value change for "do".
If this is the first operation, the [param object] will be used to deduce target undo history.
*/
func (self Instance) AddDoProperty(obj Object.Instance, property string, value any) { //gd:EditorUndoRedoManager.add_do_property
	Advanced(self).AddDoProperty(obj, String.Name(String.New(property)), variant.New(value))
}

/*
Register a property value change for "undo".
If this is the first operation, the [param object] will be used to deduce target undo history.
*/
func (self Instance) AddUndoProperty(obj Object.Instance, property string, value any) { //gd:EditorUndoRedoManager.add_undo_property
	Advanced(self).AddUndoProperty(obj, String.Name(String.New(property)), variant.New(value))
}

/*
Register a reference for "do" that will be erased if the "do" history is lost. This is useful mostly for new nodes created for the "do" call. Do not use for resources.
*/
func (self Instance) AddDoReference(obj Object.Instance) { //gd:EditorUndoRedoManager.add_do_reference
	Advanced(self).AddDoReference(obj)
}

/*
Register a reference for "undo" that will be erased if the "undo" history is lost. This is useful mostly for nodes removed with the "do" call (not the "undo" call!).
*/
func (self Instance) AddUndoReference(obj Object.Instance) { //gd:EditorUndoRedoManager.add_undo_reference
	Advanced(self).AddUndoReference(obj)
}

/*
Returns the history ID deduced from the given [param object]. It can be used with [method get_history_undo_redo].
*/
func (self Instance) GetObjectHistoryId(obj Object.Instance) int { //gd:EditorUndoRedoManager.get_object_history_id
	return int(int(Advanced(self).GetObjectHistoryId(obj)))
}

/*
Returns the [UndoRedo] object associated with the given history [param id].
[param id] above [code]0[/code] are mapped to the opened scene tabs (but it doesn't match their order). [param id] of [code]0[/code] or lower have special meaning (see [enum SpecialHistory]).
Best used with [method get_object_history_id]. This method is only provided in case you need some more advanced methods of [UndoRedo] (but keep in mind that directly operating on the [UndoRedo] object might affect editor's stability).
*/
func (self Instance) GetHistoryUndoRedo(id int) UndoRedo.Instance { //gd:EditorUndoRedoManager.get_history_undo_redo
	return UndoRedo.Instance(Advanced(self).GetHistoryUndoRedo(int64(id)))
}

/*
Clears the given undo history. You can clear history for a specific scene, global history, or for all scenes at once if [param id] is [constant INVALID_HISTORY].
If [param increase_version] is [code]true[/code], the undo history version will be increased, marking it as unsaved. Useful for operations that modify the scene, but don't support undo.
[codeblock]
var scene_root = EditorInterface.get_edited_scene_root()
var undo_redo = EditorInterface.get_editor_undo_redo()
undo_redo.clear_history(undo_redo.get_object_history_id(scene_root))
[/codeblock]
[b]Note:[/b] If you want to mark an edited scene as unsaved without clearing its history, use [method EditorInterface.mark_scene_as_unsaved] instead.
*/
func (self Instance) ClearHistory() { //gd:EditorUndoRedoManager.clear_history
	Advanced(self).ClearHistory(int64(-99), true)
}

/*
Clears the given undo history. You can clear history for a specific scene, global history, or for all scenes at once if [param id] is [constant INVALID_HISTORY].
If [param increase_version] is [code]true[/code], the undo history version will be increased, marking it as unsaved. Useful for operations that modify the scene, but don't support undo.
[codeblock]
var scene_root = EditorInterface.get_edited_scene_root()
var undo_redo = EditorInterface.get_editor_undo_redo()
undo_redo.clear_history(undo_redo.get_object_history_id(scene_root))
[/codeblock]
[b]Note:[/b] If you want to mark an edited scene as unsaved without clearing its history, use [method EditorInterface.mark_scene_as_unsaved] instead.
*/
func (self Expanded) ClearHistory(id int, increase_version bool) { //gd:EditorUndoRedoManager.clear_history
	Advanced(self).ClearHistory(int64(id), increase_version)
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.EditorUndoRedoManager

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.EditorUndoRedoManager)(unsafe.Pointer(&obj))
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.EditorUndoRedoManager)(unsafe.Pointer(&obj))
		return true
	}
	return false
}

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {

	if !gd.Linked {
		var placeholder Instance
		*(*gd.Object)(unsafe.Pointer(&placeholder)) = pointers.Add[gd.Object]([3]uint64{})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(*(*gd.Object)(unsafe.Pointer(&placeholder)), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	object := [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})}
	casted := Instance{*(*gdclass.EditorUndoRedoManager)(unsafe.Pointer(&object))}
	object[0].Notification(0, false)
	return casted
}

/*
Create a new action. After this is called, do all your calls to [method add_do_method], [method add_undo_method], [method add_do_property], and [method add_undo_property], then commit the action with [method commit_action].
The way actions are merged is dictated by the [param merge_mode] argument. See [enum UndoRedo.MergeMode] for details.
If [param custom_context] object is provided, it will be used for deducing target history (instead of using the first operation).
The way undo operation are ordered in actions is dictated by [param backward_undo_ops]. When [param backward_undo_ops] is [code]false[/code] undo option are ordered in the same order they were added. Which means the first operation to be added will be the first to be undone.
*/
//go:nosplit
func (self class) CreateAction(name String.Readable, merge_mode UndoRedo.MergeMode, custom_context [1]gd.Object, backward_undo_ops bool) { //gd:EditorUndoRedoManager.create_action
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.create_action, 0|(gdextension.SizeString<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeObject<<12)|(gdextension.SizeBool<<16), unsafe.Pointer(&struct {
		name              gdextension.String
		merge_mode        UndoRedo.MergeMode
		custom_context    gdextension.Object
		backward_undo_ops bool
	}{pointers.Get(gd.InternalString(name)), merge_mode, gdextension.Object(gd.PointerWithOwnershipTransferredToGodot(custom_context[0].AsObject()[0])), backward_undo_ops}))
}

/*
Commits the action. If [param execute] is [code]true[/code] (default), all "do" methods/properties are called/set when this function is called.
*/
//go:nosplit
func (self class) CommitAction(execute bool) { //gd:EditorUndoRedoManager.commit_action
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.commit_action, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ execute bool }{execute}))
}

/*
Returns [code]true[/code] if the [EditorUndoRedoManager] is currently committing the action, i.e. running its "do" method or property change (see [method commit_action]).
*/
//go:nosplit
func (self class) IsCommittingAction() bool { //gd:EditorUndoRedoManager.is_committing_action
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_committing_action, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Forces the next operation (e.g. [method add_do_method]) to use the action's history rather than guessing it from the object. This is sometimes needed when a history can't be correctly determined, like for a nested resource that doesn't have a path yet.
This method should only be used when absolutely necessary, otherwise it might cause invalid history state. For most of complex cases, the [code]custom_context[/code] parameter of [method create_action] is sufficient.
*/
//go:nosplit
func (self class) ForceFixedHistory() { //gd:EditorUndoRedoManager.force_fixed_history
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.force_fixed_history, 0, unsafe.Pointer(&struct{}{}))
}

/*
Register a method that will be called when the action is committed (i.e. the "do" action).
If this is the first operation, the [param object] will be used to deduce target undo history.
*/
//go:nosplit
func (self class) AddDoMethod(obj [1]gd.Object, method String.Name, args ...gd.Variant) { //gd:EditorUndoRedoManager.add_do_method
	var fixed = [...]gdextension.Variant{gdextension.Variant(pointers.Get(gd.NewVariant(obj))), gdextension.Variant(pointers.Get(gd.NewVariant(method)))}
	ret, err := methods.add_do_method.Call(gd.ObjectChecked(self.AsObject()), fixed[:]...)
	if err != nil {
		panic(err)
	}
	_ = ret
}

/*
Register a method that will be called when the action is undone (i.e. the "undo" action).
If this is the first operation, the [param object] will be used to deduce target undo history.
*/
//go:nosplit
func (self class) AddUndoMethod(obj [1]gd.Object, method String.Name, args ...gd.Variant) { //gd:EditorUndoRedoManager.add_undo_method
	var fixed = [...]gdextension.Variant{gdextension.Variant(pointers.Get(gd.NewVariant(obj))), gdextension.Variant(pointers.Get(gd.NewVariant(method)))}
	ret, err := methods.add_undo_method.Call(gd.ObjectChecked(self.AsObject()), fixed[:]...)
	if err != nil {
		panic(err)
	}
	_ = ret
}

/*
Register a property value change for "do".
If this is the first operation, the [param object] will be used to deduce target undo history.
*/
//go:nosplit
func (self class) AddDoProperty(obj [1]gd.Object, property String.Name, value variant.Any) { //gd:EditorUndoRedoManager.add_do_property
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_do_property, 0|(gdextension.SizeObject<<4)|(gdextension.SizeStringName<<8)|(gdextension.SizeVariant<<12), unsafe.Pointer(&struct {
		obj      gdextension.Object
		property gdextension.StringName
		value    gdextension.Variant
	}{gdextension.Object(gd.PointerWithOwnershipTransferredToGodot(obj[0].AsObject()[0])), pointers.Get(gd.InternalStringName(property)), gdextension.Variant(pointers.Get(gd.InternalVariant(value)))}))
}

/*
Register a property value change for "undo".
If this is the first operation, the [param object] will be used to deduce target undo history.
*/
//go:nosplit
func (self class) AddUndoProperty(obj [1]gd.Object, property String.Name, value variant.Any) { //gd:EditorUndoRedoManager.add_undo_property
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_undo_property, 0|(gdextension.SizeObject<<4)|(gdextension.SizeStringName<<8)|(gdextension.SizeVariant<<12), unsafe.Pointer(&struct {
		obj      gdextension.Object
		property gdextension.StringName
		value    gdextension.Variant
	}{gdextension.Object(gd.PointerWithOwnershipTransferredToGodot(obj[0].AsObject()[0])), pointers.Get(gd.InternalStringName(property)), gdextension.Variant(pointers.Get(gd.InternalVariant(value)))}))
}

/*
Register a reference for "do" that will be erased if the "do" history is lost. This is useful mostly for new nodes created for the "do" call. Do not use for resources.
*/
//go:nosplit
func (self class) AddDoReference(obj [1]gd.Object) { //gd:EditorUndoRedoManager.add_do_reference
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_do_reference, 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ obj gdextension.Object }{gdextension.Object(gd.PointerWithOwnershipTransferredToGodot(obj[0].AsObject()[0]))}))
}

/*
Register a reference for "undo" that will be erased if the "undo" history is lost. This is useful mostly for nodes removed with the "do" call (not the "undo" call!).
*/
//go:nosplit
func (self class) AddUndoReference(obj [1]gd.Object) { //gd:EditorUndoRedoManager.add_undo_reference
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_undo_reference, 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ obj gdextension.Object }{gdextension.Object(gd.PointerWithOwnershipTransferredToGodot(obj[0].AsObject()[0]))}))
}

/*
Returns the history ID deduced from the given [param object]. It can be used with [method get_history_undo_redo].
*/
//go:nosplit
func (self class) GetObjectHistoryId(obj [1]gd.Object) int64 { //gd:EditorUndoRedoManager.get_object_history_id
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_object_history_id, gdextension.SizeInt|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ obj gdextension.Object }{gdextension.Object(gd.ObjectChecked(obj[0].AsObject()))}))
	var ret = r_ret
	return ret
}

/*
Returns the [UndoRedo] object associated with the given history [param id].
[param id] above [code]0[/code] are mapped to the opened scene tabs (but it doesn't match their order). [param id] of [code]0[/code] or lower have special meaning (see [enum SpecialHistory]).
Best used with [method get_object_history_id]. This method is only provided in case you need some more advanced methods of [UndoRedo] (but keep in mind that directly operating on the [UndoRedo] object might affect editor's stability).
*/
//go:nosplit
func (self class) GetHistoryUndoRedo(id int64) [1]gdclass.UndoRedo { //gd:EditorUndoRedoManager.get_history_undo_redo
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_history_undo_redo, gdextension.SizeObject|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ id int64 }{id}))
	var ret = [1]gdclass.UndoRedo{gd.PointerLifetimeBoundTo[gdclass.UndoRedo](self.AsObject(), r_ret)}
	return ret
}

/*
Clears the given undo history. You can clear history for a specific scene, global history, or for all scenes at once if [param id] is [constant INVALID_HISTORY].
If [param increase_version] is [code]true[/code], the undo history version will be increased, marking it as unsaved. Useful for operations that modify the scene, but don't support undo.
[codeblock]
var scene_root = EditorInterface.get_edited_scene_root()
var undo_redo = EditorInterface.get_editor_undo_redo()
undo_redo.clear_history(undo_redo.get_object_history_id(scene_root))
[/codeblock]
[b]Note:[/b] If you want to mark an edited scene as unsaved without clearing its history, use [method EditorInterface.mark_scene_as_unsaved] instead.
*/
//go:nosplit
func (self class) ClearHistory(id int64, increase_version bool) { //gd:EditorUndoRedoManager.clear_history
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.clear_history, 0|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		id               int64
		increase_version bool
	}{id, increase_version}))
}
func (self Instance) OnHistoryChanged(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("history_changed"), gd.NewCallable(cb), 0)
}

func (self Instance) OnVersionChanged(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("version_changed"), gd.NewCallable(cb), 0)
}

func (self class) AsEditorUndoRedoManager() Advanced    { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsEditorUndoRedoManager() Instance { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsEditorUndoRedoManager() Instance {
	return self.Super().AsEditorUndoRedoManager()
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Object.Advanced(self.AsObject()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Object.Instance(self.AsObject()), name)
	}
}
func init() {
	gdclass.Register("EditorUndoRedoManager", func(ptr gd.Object) any { return *(*Instance)(unsafe.Pointer(&ptr)) })
}

type SpecialHistory int //gd:EditorUndoRedoManager.SpecialHistory

const (
	/*Global history not associated with any scene, but with external resources etc.*/
	GlobalHistory SpecialHistory = 0
	/*History associated with remote inspector. Used when live editing a running project.*/
	RemoteHistory SpecialHistory = -9
	/*Invalid "null" history. It's a special value, not associated with any object.*/
	InvalidHistory SpecialHistory = -99
)
