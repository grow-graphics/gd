// Code generated by the generate package DO NOT EDIT

// Package AcceptDialog provides methods for working with AcceptDialog object instances.
package AcceptDialog

import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/variant/Signal"
import "graphics.gd/classdb/Button"
import "graphics.gd/classdb/Label"
import "graphics.gd/classdb/LineEdit"
import "graphics.gd/classdb/Node"
import "graphics.gd/classdb/Viewport"
import "graphics.gd/classdb/Window"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Signal.Any
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
The default use of [AcceptDialog] is to allow it to only be accepted or closed, with the same result. However, the [signal confirmed] and [signal canceled] signals allow to make the two actions different, and the [method add_button] method allows to add custom buttons and actions.
*/
type Instance [1]gdclass.AcceptDialog

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	get_ok_button       gdextension.MethodForClass `hash:"1856205918"`
	get_label           gdextension.MethodForClass `hash:"566733104"`
	set_hide_on_ok      gdextension.MethodForClass `hash:"2586408642"`
	get_hide_on_ok      gdextension.MethodForClass `hash:"36873697"`
	set_close_on_escape gdextension.MethodForClass `hash:"2586408642"`
	get_close_on_escape gdextension.MethodForClass `hash:"36873697"`
	add_button          gdextension.MethodForClass `hash:"3328440682"`
	add_cancel_button   gdextension.MethodForClass `hash:"242045556"`
	remove_button       gdextension.MethodForClass `hash:"2068354942"`
	register_text_enter gdextension.MethodForClass `hash:"3714008017"`
	set_text            gdextension.MethodForClass `hash:"83702148"`
	get_text            gdextension.MethodForClass `hash:"201670096"`
	set_autowrap        gdextension.MethodForClass `hash:"2586408642"`
	has_autowrap        gdextension.MethodForClass `hash:"2240911060"`
	set_ok_button_text  gdextension.MethodForClass `hash:"83702148"`
	get_ok_button_text  gdextension.MethodForClass `hash:"201670096"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("AcceptDialog")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		gdextension.Free(gdextension.TypeStringName, &sname)
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

type Expanded [1]gdclass.AcceptDialog

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsAcceptDialog() Instance
}

/*
Returns the OK [Button] instance.
[b]Warning:[/b] This is a required internal node, removing and freeing it may cause a crash. If you wish to hide it or any of its children, use their [member CanvasItem.visible] property.
*/
func (self Instance) GetOkButton() Button.Instance { //gd:AcceptDialog.get_ok_button
	return Button.Instance(Advanced(self).GetOkButton())
}

/*
Returns the label used for built-in text.
[b]Warning:[/b] This is a required internal node, removing and freeing it may cause a crash. If you wish to hide it or any of its children, use their [member CanvasItem.visible] property.
*/
func (self Instance) GetLabel() Label.Instance { //gd:AcceptDialog.get_label
	return Label.Instance(Advanced(self).GetLabel())
}

/*
Adds a button with label [param text] and a custom [param action] to the dialog and returns the created button. [param action] will be passed to the [signal custom_action] signal when pressed.
If [code]true[/code], [param right] will place the button to the right of any sibling buttons.
You can use [method remove_button] method to remove a button created with this method from the dialog.
*/
func (self Instance) AddButton(text string) Button.Instance { //gd:AcceptDialog.add_button
	return Button.Instance(Advanced(self).AddButton(String.New(text), false, String.New("")))
}

/*
Adds a button with label [param text] and a custom [param action] to the dialog and returns the created button. [param action] will be passed to the [signal custom_action] signal when pressed.
If [code]true[/code], [param right] will place the button to the right of any sibling buttons.
You can use [method remove_button] method to remove a button created with this method from the dialog.
*/
func (self Expanded) AddButton(text string, right bool, action string) Button.Instance { //gd:AcceptDialog.add_button
	return Button.Instance(Advanced(self).AddButton(String.New(text), right, String.New(action)))
}

/*
Adds a button with label [param name] and a cancel action to the dialog and returns the created button.
You can use [method remove_button] method to remove a button created with this method from the dialog.
*/
func (self Instance) AddCancelButton(name string) Button.Instance { //gd:AcceptDialog.add_cancel_button
	return Button.Instance(Advanced(self).AddCancelButton(String.New(name)))
}

/*
Removes the [param button] from the dialog. Does NOT free the [param button]. The [param button] must be a [Button] added with [method add_button] or [method add_cancel_button] method. After removal, pressing the [param button] will no longer emit this dialog's [signal custom_action] or [signal canceled] signals.
*/
func (self Instance) RemoveButton(button Button.Instance) { //gd:AcceptDialog.remove_button
	Advanced(self).RemoveButton(button)
}

/*
Registers a [LineEdit] in the dialog. When the enter key is pressed, the dialog will be accepted.
*/
func (self Instance) RegisterTextEnter(line_edit LineEdit.Instance) { //gd:AcceptDialog.register_text_enter
	Advanced(self).RegisterTextEnter(line_edit)
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.AcceptDialog

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = pointers.AsA[gdclass.AcceptDialog](obj[0])
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = pointers.AsA[gdclass.AcceptDialog](obj[0])
		return true
	}
	return false
}
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }
func (self *Extension[T]) AsObject() [1]gd.Object { return self.Super().AsObject() }
func New() Instance {
	if !gd.Linked {
		var placeholder = Instance([1]gdclass.AcceptDialog{pointers.Add[gdclass.AcceptDialog]([3]uint64{})})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(pointers.AsA[gd.Object](placeholder[0]), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	casted := Instance([1]gdclass.AcceptDialog{pointers.New[gdclass.AcceptDialog]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})})
	casted.AsObject()[0].Notification(0, false)
	return casted
}

func (self Instance) OkButtonText() string {
	return string(class(self).GetOkButtonText().String())
}

func (self Instance) SetOkButtonText(value string) {
	class(self).SetOkButtonText(String.New(value))
}

func (self Instance) DialogText() string {
	return string(class(self).GetText().String())
}

func (self Instance) SetDialogText(value string) {
	class(self).SetText(String.New(value))
}

func (self Instance) DialogHideOnOk() bool {
	return bool(class(self).GetHideOnOk())
}

func (self Instance) SetDialogHideOnOk(value bool) {
	class(self).SetHideOnOk(value)
}

func (self Instance) DialogCloseOnEscape() bool {
	return bool(class(self).GetCloseOnEscape())
}

func (self Instance) SetDialogCloseOnEscape(value bool) {
	class(self).SetCloseOnEscape(value)
}

func (self Instance) DialogAutowrap() bool {
	return bool(class(self).HasAutowrap())
}

func (self Instance) SetDialogAutowrap(value bool) {
	class(self).SetAutowrap(value)
}

/*
Returns the OK [Button] instance.
[b]Warning:[/b] This is a required internal node, removing and freeing it may cause a crash. If you wish to hide it or any of its children, use their [member CanvasItem.visible] property.
*/
//go:nosplit
func (self class) GetOkButton() [1]gdclass.Button { //gd:AcceptDialog.get_ok_button
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_ok_button, gdextension.SizeObject, &struct{}{})
	var ret = [1]gdclass.Button{gd.PointerLifetimeBoundTo[gdclass.Button](self.AsObject(), r_ret)}
	return ret
}

/*
Returns the label used for built-in text.
[b]Warning:[/b] This is a required internal node, removing and freeing it may cause a crash. If you wish to hide it or any of its children, use their [member CanvasItem.visible] property.
*/
//go:nosplit
func (self class) GetLabel() [1]gdclass.Label { //gd:AcceptDialog.get_label
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_label, gdextension.SizeObject, &struct{}{})
	var ret = [1]gdclass.Label{gd.PointerLifetimeBoundTo[gdclass.Label](self.AsObject(), r_ret)}
	return ret
}

//go:nosplit
func (self class) SetHideOnOk(enabled bool) { //gd:AcceptDialog.set_hide_on_ok
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_hide_on_ok, 0|(gdextension.SizeBool<<4), &struct{ enabled bool }{enabled})
}

//go:nosplit
func (self class) GetHideOnOk() bool { //gd:AcceptDialog.get_hide_on_ok
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.get_hide_on_ok, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetCloseOnEscape(enabled bool) { //gd:AcceptDialog.set_close_on_escape
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_close_on_escape, 0|(gdextension.SizeBool<<4), &struct{ enabled bool }{enabled})
}

//go:nosplit
func (self class) GetCloseOnEscape() bool { //gd:AcceptDialog.get_close_on_escape
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.get_close_on_escape, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

/*
Adds a button with label [param text] and a custom [param action] to the dialog and returns the created button. [param action] will be passed to the [signal custom_action] signal when pressed.
If [code]true[/code], [param right] will place the button to the right of any sibling buttons.
You can use [method remove_button] method to remove a button created with this method from the dialog.
*/
//go:nosplit
func (self class) AddButton(text String.Readable, right bool, action String.Readable) [1]gdclass.Button { //gd:AcceptDialog.add_button
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.add_button, gdextension.SizeObject|(gdextension.SizeString<<4)|(gdextension.SizeBool<<8)|(gdextension.SizeString<<12), &struct {
		text   gdextension.String
		right  bool
		action gdextension.String
	}{pointers.Get(gd.InternalString(text)), right, pointers.Get(gd.InternalString(action))})
	var ret = [1]gdclass.Button{gd.PointerLifetimeBoundTo[gdclass.Button](self.AsObject(), r_ret)}
	return ret
}

/*
Adds a button with label [param name] and a cancel action to the dialog and returns the created button.
You can use [method remove_button] method to remove a button created with this method from the dialog.
*/
//go:nosplit
func (self class) AddCancelButton(name String.Readable) [1]gdclass.Button { //gd:AcceptDialog.add_cancel_button
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.add_cancel_button, gdextension.SizeObject|(gdextension.SizeString<<4), &struct{ name gdextension.String }{pointers.Get(gd.InternalString(name))})
	var ret = [1]gdclass.Button{gd.PointerLifetimeBoundTo[gdclass.Button](self.AsObject(), r_ret)}
	return ret
}

/*
Removes the [param button] from the dialog. Does NOT free the [param button]. The [param button] must be a [Button] added with [method add_button] or [method add_cancel_button] method. After removal, pressing the [param button] will no longer emit this dialog's [signal custom_action] or [signal canceled] signals.
*/
//go:nosplit
func (self class) RemoveButton(button [1]gdclass.Button) { //gd:AcceptDialog.remove_button
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.remove_button, 0|(gdextension.SizeObject<<4), &struct{ button gdextension.Object }{gdextension.Object(gd.ObjectChecked(button[0].AsObject()))})
}

/*
Registers a [LineEdit] in the dialog. When the enter key is pressed, the dialog will be accepted.
*/
//go:nosplit
func (self class) RegisterTextEnter(line_edit [1]gdclass.LineEdit) { //gd:AcceptDialog.register_text_enter
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.register_text_enter, 0|(gdextension.SizeObject<<4), &struct{ line_edit gdextension.Object }{gdextension.Object(gd.ObjectChecked(line_edit[0].AsObject()))})
}

//go:nosplit
func (self class) SetText(text String.Readable) { //gd:AcceptDialog.set_text
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_text, 0|(gdextension.SizeString<<4), &struct{ text gdextension.String }{pointers.Get(gd.InternalString(text))})
}

//go:nosplit
func (self class) GetText() String.Readable { //gd:AcceptDialog.get_text
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_text, gdextension.SizeString, &struct{}{})
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

//go:nosplit
func (self class) SetAutowrap(autowrap bool) { //gd:AcceptDialog.set_autowrap
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_autowrap, 0|(gdextension.SizeBool<<4), &struct{ autowrap bool }{autowrap})
}

//go:nosplit
func (self class) HasAutowrap() bool { //gd:AcceptDialog.has_autowrap
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.has_autowrap, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetOkButtonText(text String.Readable) { //gd:AcceptDialog.set_ok_button_text
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_ok_button_text, 0|(gdextension.SizeString<<4), &struct{ text gdextension.String }{pointers.Get(gd.InternalString(text))})
}

//go:nosplit
func (self class) GetOkButtonText() String.Readable { //gd:AcceptDialog.get_ok_button_text
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_ok_button_text, gdextension.SizeString, &struct{}{})
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}
func (self Instance) OnConfirmed(cb func(), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("confirmed"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) Confirmed() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`Confirmed`))))
}

func (self Instance) OnCanceled(cb func(), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("canceled"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) Canceled() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`Canceled`))))
}

func (self Instance) OnCustomAction(cb func(action string), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("custom_action"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) CustomAction() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`CustomAction`))))
}

func (self class) AsAcceptDialog() Advanced {
	return Advanced{pointers.AsA[gdclass.AcceptDialog](self[0])}
}
func (self Instance) AsAcceptDialog() Instance {
	return Instance{pointers.AsA[gdclass.AcceptDialog](self[0])}
}
func (self *Extension[T]) AsAcceptDialog() Instance { return self.Super().AsAcceptDialog() }
func (self class) AsWindow() Window.Advanced {
	return Window.Advanced{pointers.AsA[gdclass.Window](self[0])}
}
func (self *Extension[T]) AsWindow() Window.Instance { return self.Super().AsWindow() }
func (self Instance) AsWindow() Window.Instance {
	return Window.Instance{pointers.AsA[gdclass.Window](self[0])}
}
func (self class) AsViewport() Viewport.Advanced {
	return Viewport.Advanced{pointers.AsA[gdclass.Viewport](self[0])}
}
func (self *Extension[T]) AsViewport() Viewport.Instance { return self.Super().AsViewport() }
func (self Instance) AsViewport() Viewport.Instance {
	return Viewport.Instance{pointers.AsA[gdclass.Viewport](self[0])}
}
func (self class) AsNode() Node.Advanced         { return Node.Advanced{pointers.AsA[gdclass.Node](self[0])} }
func (self *Extension[T]) AsNode() Node.Instance { return self.Super().AsNode() }
func (self Instance) AsNode() Node.Instance {
	return Node.Instance{pointers.AsA[gdclass.Node](self[0])}
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Window.Advanced(self.AsWindow()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Window.Instance(self.AsWindow()), name)
	}
}
func init() {
	gdclass.Register("AcceptDialog", func(ptr gd.Object) any { return Instance{pointers.AsA[gdclass.AcceptDialog](ptr)} })
}
