// Code generated by the generate package DO NOT EDIT

// Package TranslationServer provides methods for working with TranslationServer object instances.
package TranslationServer

import "unsafe"
import "sync"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/Translation"
import "graphics.gd/classdb/TranslationDomain"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
The translation server is the API backend that manages all language translations.
Translations are stored in [TranslationDomain]s, which can be accessed by name. The most commonly used translation domain is the main translation domain. It always exists and can be accessed using an empty [StringName]. The translation server provides wrapper methods for accessing the main translation domain directly, without having to fetch the translation domain first. Custom translation domains are mainly for advanced usages like editor plugins. Names starting with [code]godot.[/code] are reserved for engine internals.
*/
type Instance [1]gdclass.TranslationServer

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	set_locale                     gdextension.MethodForClass `hash:"83702148"`
	get_locale                     gdextension.MethodForClass `hash:"201670096"`
	get_tool_locale                gdextension.MethodForClass `hash:"2841200299"`
	compare_locales                gdextension.MethodForClass `hash:"2878152881"`
	standardize_locale             gdextension.MethodForClass `hash:"4216441673"`
	get_all_languages              gdextension.MethodForClass `hash:"1139954409"`
	get_language_name              gdextension.MethodForClass `hash:"3135753539"`
	get_all_scripts                gdextension.MethodForClass `hash:"1139954409"`
	get_script_name                gdextension.MethodForClass `hash:"3135753539"`
	get_all_countries              gdextension.MethodForClass `hash:"1139954409"`
	get_country_name               gdextension.MethodForClass `hash:"3135753539"`
	get_locale_name                gdextension.MethodForClass `hash:"3135753539"`
	translate                      gdextension.MethodForClass `hash:"1829228469"`
	translate_plural               gdextension.MethodForClass `hash:"229954002"`
	add_translation                gdextension.MethodForClass `hash:"1466479800"`
	remove_translation             gdextension.MethodForClass `hash:"1466479800"`
	get_translation_object         gdextension.MethodForClass `hash:"2065240175"`
	has_domain                     gdextension.MethodForClass `hash:"2619796661"`
	get_or_add_domain              gdextension.MethodForClass `hash:"397200075"`
	remove_domain                  gdextension.MethodForClass `hash:"3304788590"`
	clear                          gdextension.MethodForClass `hash:"3218959716"`
	get_loaded_locales             gdextension.MethodForClass `hash:"1139954409"`
	is_pseudolocalization_enabled  gdextension.MethodForClass `hash:"36873697"`
	set_pseudolocalization_enabled gdextension.MethodForClass `hash:"2586408642"`
	reload_pseudolocalization      gdextension.MethodForClass `hash:"3218959716"`
	pseudolocalize                 gdextension.MethodForClass `hash:"1965194235"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("TranslationServer")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		pointers.Raw[gd.StringName](sname).Free()
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

var self [1]gdclass.TranslationServer
var once sync.Once

func singleton() {
	self[0] = pointers.Raw[gdclass.TranslationServer]([3]uint64{uint64(gdextension.Host.Objects.Global(sname))})
}

/*
Sets the locale of the project. The [param locale] string will be standardized to match known locales (e.g. [code]en-US[/code] would be matched to [code]en_US[/code]).
If translations have been loaded beforehand for the new locale, they will be applied.
*/
func SetLocale(locale string) { //gd:TranslationServer.set_locale
	once.Do(singleton)
	Advanced().SetLocale(String.New(locale))
}

/*
Returns the current locale of the project.
See also [method OS.get_locale] and [method OS.get_locale_language] to query the locale of the user system.
*/
func GetLocale() string { //gd:TranslationServer.get_locale
	once.Do(singleton)
	return string(Advanced().GetLocale().String())
}

/*
Returns the current locale of the editor.
[b]Note:[/b] When called from an exported project returns the same value as [method get_locale].
*/
func GetToolLocale() string { //gd:TranslationServer.get_tool_locale
	once.Do(singleton)
	return string(Advanced().GetToolLocale().String())
}

/*
Compares two locales and returns a similarity score between [code]0[/code] (no match) and [code]10[/code] (full match).
*/
func CompareLocales(locale_a string, locale_b string) int { //gd:TranslationServer.compare_locales
	once.Do(singleton)
	return int(int(Advanced().CompareLocales(String.New(locale_a), String.New(locale_b))))
}

/*
Returns a [param locale] string standardized to match known locales (e.g. [code]en-US[/code] would be matched to [code]en_US[/code]). If [param add_defaults] is [code]true[/code], the locale may have a default script or country added.
*/
func StandardizeLocale(locale string, add_defaults bool) string { //gd:TranslationServer.standardize_locale
	once.Do(singleton)
	return string(Advanced().StandardizeLocale(String.New(locale), add_defaults).String())
}

/*
Returns a [param locale] string standardized to match known locales (e.g. [code]en-US[/code] would be matched to [code]en_US[/code]). If [param add_defaults] is [code]true[/code], the locale may have a default script or country added.
*/
func StandardizeLocaleOptions(locale string, add_defaults bool) string { //gd:TranslationServer.standardize_locale
	once.Do(singleton)
	return string(Advanced().StandardizeLocale(String.New(locale), add_defaults).String())
}

/*
Returns array of known language codes.
*/
func GetAllLanguages() []string { //gd:TranslationServer.get_all_languages
	once.Do(singleton)
	return []string(Advanced().GetAllLanguages().Strings())
}

/*
Returns a readable language name for the [param language] code.
*/
func GetLanguageName(language string) string { //gd:TranslationServer.get_language_name
	once.Do(singleton)
	return string(Advanced().GetLanguageName(String.New(language)).String())
}

/*
Returns an array of known script codes.
*/
func GetAllScripts() []string { //gd:TranslationServer.get_all_scripts
	once.Do(singleton)
	return []string(Advanced().GetAllScripts().Strings())
}

/*
Returns a readable script name for the [param script] code.
*/
func GetScriptName(script string) string { //gd:TranslationServer.get_script_name
	once.Do(singleton)
	return string(Advanced().GetScriptName(String.New(script)).String())
}

/*
Returns an array of known country codes.
*/
func GetAllCountries() []string { //gd:TranslationServer.get_all_countries
	once.Do(singleton)
	return []string(Advanced().GetAllCountries().Strings())
}

/*
Returns a readable country name for the [param country] code.
*/
func GetCountryName(country string) string { //gd:TranslationServer.get_country_name
	once.Do(singleton)
	return string(Advanced().GetCountryName(String.New(country)).String())
}

/*
Returns a locale's language and its variant (e.g. [code]"en_US"[/code] would return [code]"English (United States)"[/code]).
*/
func GetLocaleName(locale string) string { //gd:TranslationServer.get_locale_name
	once.Do(singleton)
	return string(Advanced().GetLocaleName(String.New(locale)).String())
}

/*
Returns the current locale's translation for the given message and context.
[b]Note:[/b] This method always uses the main translation domain.
*/
func Translate(message string, context string) string { //gd:TranslationServer.translate
	once.Do(singleton)
	return string(Advanced().Translate(String.Name(String.New(message)), String.Name(String.New(context))).String())
}

/*
Returns the current locale's translation for the given message and context.
[b]Note:[/b] This method always uses the main translation domain.
*/
func TranslateOptions(message string, context string) string { //gd:TranslationServer.translate
	once.Do(singleton)
	return string(Advanced().Translate(String.Name(String.New(message)), String.Name(String.New(context))).String())
}

/*
Returns the current locale's translation for the given message, plural message and context.
The number [param n] is the number or quantity of the plural object. It will be used to guide the translation system to fetch the correct plural form for the selected language.
[b]Note:[/b] This method always uses the main translation domain.
*/
func TranslatePlural(message string, plural_message string, n int, context string) string { //gd:TranslationServer.translate_plural
	once.Do(singleton)
	return string(Advanced().TranslatePlural(String.Name(String.New(message)), String.Name(String.New(plural_message)), int64(n), String.Name(String.New(context))).String())
}

/*
Returns the current locale's translation for the given message, plural message and context.
The number [param n] is the number or quantity of the plural object. It will be used to guide the translation system to fetch the correct plural form for the selected language.
[b]Note:[/b] This method always uses the main translation domain.
*/
func TranslatePluralOptions(message string, plural_message string, n int, context string) string { //gd:TranslationServer.translate_plural
	once.Do(singleton)
	return string(Advanced().TranslatePlural(String.Name(String.New(message)), String.Name(String.New(plural_message)), int64(n), String.Name(String.New(context))).String())
}

/*
Adds a translation to the main translation domain.
*/
func AddTranslation(translation Translation.Instance) { //gd:TranslationServer.add_translation
	once.Do(singleton)
	Advanced().AddTranslation(translation)
}

/*
Removes the given translation from the main translation domain.
*/
func RemoveTranslation(translation Translation.Instance) { //gd:TranslationServer.remove_translation
	once.Do(singleton)
	Advanced().RemoveTranslation(translation)
}

/*
Returns the [Translation] instance that best matches [param locale] in the main translation domain. Returns [code]null[/code] if there are no matches.
*/
func GetTranslationObject(locale string) Translation.Instance { //gd:TranslationServer.get_translation_object
	once.Do(singleton)
	return Translation.Instance(Advanced().GetTranslationObject(String.New(locale)))
}

/*
Returns [code]true[/code] if a translation domain with the specified name exists.
*/
func HasDomain(domain string) bool { //gd:TranslationServer.has_domain
	once.Do(singleton)
	return bool(Advanced().HasDomain(String.Name(String.New(domain))))
}

/*
Returns the translation domain with the specified name. An empty translation domain will be created and added if it does not exist.
*/
func GetOrAddDomain(domain string) TranslationDomain.Instance { //gd:TranslationServer.get_or_add_domain
	once.Do(singleton)
	return TranslationDomain.Instance(Advanced().GetOrAddDomain(String.Name(String.New(domain))))
}

/*
Removes the translation domain with the specified name.
[b]Note:[/b] Trying to remove the main translation domain is an error.
*/
func RemoveDomain(domain string) { //gd:TranslationServer.remove_domain
	once.Do(singleton)
	Advanced().RemoveDomain(String.Name(String.New(domain)))
}

/*
Removes all translations from the main translation domain.
*/
func Clear() { //gd:TranslationServer.clear
	once.Do(singleton)
	Advanced().Clear()
}

/*
Returns an array of all loaded locales of the project.
*/
func GetLoadedLocales() []string { //gd:TranslationServer.get_loaded_locales
	once.Do(singleton)
	return []string(Advanced().GetLoadedLocales().Strings())
}

/*
Reparses the pseudolocalization options and reloads the translation for the main translation domain.
*/
func ReloadPseudolocalization() { //gd:TranslationServer.reload_pseudolocalization
	once.Do(singleton)
	Advanced().ReloadPseudolocalization()
}

/*
Returns the pseudolocalized string based on the [param message] passed in.
[b]Note:[/b] This method always uses the main translation domain.
*/
func Pseudolocalize(message string) string { //gd:TranslationServer.pseudolocalize
	once.Do(singleton)
	return string(Advanced().Pseudolocalize(String.Name(String.New(message))).String())
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
func Advanced() class { once.Do(singleton); return self }

type class [1]gdclass.TranslationServer

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.TranslationServer)(unsafe.Pointer(&obj))
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.TranslationServer)(unsafe.Pointer(&obj))
		return true
	}
	return false
}

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }

func PseudolocalizationEnabled() bool {
	once.Do(singleton)
	return bool(class(self).IsPseudolocalizationEnabled())
}

func SetPseudolocalizationEnabled(value bool) {
	once.Do(singleton)
	class(self).SetPseudolocalizationEnabled(value)
}

/*
Sets the locale of the project. The [param locale] string will be standardized to match known locales (e.g. [code]en-US[/code] would be matched to [code]en_US[/code]).
If translations have been loaded beforehand for the new locale, they will be applied.
*/
//go:nosplit
func (self class) SetLocale(locale String.Readable) { //gd:TranslationServer.set_locale
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_locale, 0|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ locale gdextension.String }{pointers.Get(gd.InternalString(locale))}))
}

/*
Returns the current locale of the project.
See also [method OS.get_locale] and [method OS.get_locale_language] to query the locale of the user system.
*/
//go:nosplit
func (self class) GetLocale() String.Readable { //gd:TranslationServer.get_locale
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_locale, gdextension.SizeString, unsafe.Pointer(&struct{}{}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Returns the current locale of the editor.
[b]Note:[/b] When called from an exported project returns the same value as [method get_locale].
*/
//go:nosplit
func (self class) GetToolLocale() String.Readable { //gd:TranslationServer.get_tool_locale
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_tool_locale, gdextension.SizeString, unsafe.Pointer(&struct{}{}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Compares two locales and returns a similarity score between [code]0[/code] (no match) and [code]10[/code] (full match).
*/
//go:nosplit
func (self class) CompareLocales(locale_a String.Readable, locale_b String.Readable) int64 { //gd:TranslationServer.compare_locales
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.compare_locales, gdextension.SizeInt|(gdextension.SizeString<<4)|(gdextension.SizeString<<8), unsafe.Pointer(&struct {
		locale_a gdextension.String
		locale_b gdextension.String
	}{pointers.Get(gd.InternalString(locale_a)), pointers.Get(gd.InternalString(locale_b))}))
	var ret = r_ret
	return ret
}

/*
Returns a [param locale] string standardized to match known locales (e.g. [code]en-US[/code] would be matched to [code]en_US[/code]). If [param add_defaults] is [code]true[/code], the locale may have a default script or country added.
*/
//go:nosplit
func (self class) StandardizeLocale(locale String.Readable, add_defaults bool) String.Readable { //gd:TranslationServer.standardize_locale
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.standardize_locale, gdextension.SizeString|(gdextension.SizeString<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		locale       gdextension.String
		add_defaults bool
	}{pointers.Get(gd.InternalString(locale)), add_defaults}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Returns array of known language codes.
*/
//go:nosplit
func (self class) GetAllLanguages() Packed.Strings { //gd:TranslationServer.get_all_languages
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.get_all_languages, gdextension.SizePackedArray, unsafe.Pointer(&struct{}{}))
	var ret = Packed.Strings(Array.Through(gd.PackedStringArrayProxy{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

/*
Returns a readable language name for the [param language] code.
*/
//go:nosplit
func (self class) GetLanguageName(language String.Readable) String.Readable { //gd:TranslationServer.get_language_name
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_language_name, gdextension.SizeString|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ language gdextension.String }{pointers.Get(gd.InternalString(language))}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Returns an array of known script codes.
*/
//go:nosplit
func (self class) GetAllScripts() Packed.Strings { //gd:TranslationServer.get_all_scripts
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.get_all_scripts, gdextension.SizePackedArray, unsafe.Pointer(&struct{}{}))
	var ret = Packed.Strings(Array.Through(gd.PackedStringArrayProxy{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

/*
Returns a readable script name for the [param script] code.
*/
//go:nosplit
func (self class) GetScriptName(script String.Readable) String.Readable { //gd:TranslationServer.get_script_name
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_script_name, gdextension.SizeString|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ script gdextension.String }{pointers.Get(gd.InternalString(script))}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Returns an array of known country codes.
*/
//go:nosplit
func (self class) GetAllCountries() Packed.Strings { //gd:TranslationServer.get_all_countries
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.get_all_countries, gdextension.SizePackedArray, unsafe.Pointer(&struct{}{}))
	var ret = Packed.Strings(Array.Through(gd.PackedStringArrayProxy{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

/*
Returns a readable country name for the [param country] code.
*/
//go:nosplit
func (self class) GetCountryName(country String.Readable) String.Readable { //gd:TranslationServer.get_country_name
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_country_name, gdextension.SizeString|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ country gdextension.String }{pointers.Get(gd.InternalString(country))}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Returns a locale's language and its variant (e.g. [code]"en_US"[/code] would return [code]"English (United States)"[/code]).
*/
//go:nosplit
func (self class) GetLocaleName(locale String.Readable) String.Readable { //gd:TranslationServer.get_locale_name
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_locale_name, gdextension.SizeString|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ locale gdextension.String }{pointers.Get(gd.InternalString(locale))}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Returns the current locale's translation for the given message and context.
[b]Note:[/b] This method always uses the main translation domain.
*/
//go:nosplit
func (self class) Translate(message String.Name, context String.Name) String.Name { //gd:TranslationServer.translate
	var r_ret = gdextension.Call[gdextension.StringName](gd.ObjectChecked(self.AsObject()), methods.translate, gdextension.SizeStringName|(gdextension.SizeStringName<<4)|(gdextension.SizeStringName<<8), unsafe.Pointer(&struct {
		message gdextension.StringName
		context gdextension.StringName
	}{pointers.Get(gd.InternalStringName(message)), pointers.Get(gd.InternalStringName(context))}))
	var ret = String.Name(String.Via(gd.StringNameProxy{}, pointers.Pack(pointers.New[gd.StringName](r_ret))))
	return ret
}

/*
Returns the current locale's translation for the given message, plural message and context.
The number [param n] is the number or quantity of the plural object. It will be used to guide the translation system to fetch the correct plural form for the selected language.
[b]Note:[/b] This method always uses the main translation domain.
*/
//go:nosplit
func (self class) TranslatePlural(message String.Name, plural_message String.Name, n int64, context String.Name) String.Name { //gd:TranslationServer.translate_plural
	var r_ret = gdextension.Call[gdextension.StringName](gd.ObjectChecked(self.AsObject()), methods.translate_plural, gdextension.SizeStringName|(gdextension.SizeStringName<<4)|(gdextension.SizeStringName<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeStringName<<16), unsafe.Pointer(&struct {
		message        gdextension.StringName
		plural_message gdextension.StringName
		n              int64
		context        gdextension.StringName
	}{pointers.Get(gd.InternalStringName(message)), pointers.Get(gd.InternalStringName(plural_message)), n, pointers.Get(gd.InternalStringName(context))}))
	var ret = String.Name(String.Via(gd.StringNameProxy{}, pointers.Pack(pointers.New[gd.StringName](r_ret))))
	return ret
}

/*
Adds a translation to the main translation domain.
*/
//go:nosplit
func (self class) AddTranslation(translation [1]gdclass.Translation) { //gd:TranslationServer.add_translation
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_translation, 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ translation gdextension.Object }{gdextension.Object(gd.ObjectChecked(translation[0].AsObject()))}))
}

/*
Removes the given translation from the main translation domain.
*/
//go:nosplit
func (self class) RemoveTranslation(translation [1]gdclass.Translation) { //gd:TranslationServer.remove_translation
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.remove_translation, 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ translation gdextension.Object }{gdextension.Object(gd.ObjectChecked(translation[0].AsObject()))}))
}

/*
Returns the [Translation] instance that best matches [param locale] in the main translation domain. Returns [code]null[/code] if there are no matches.
*/
//go:nosplit
func (self class) GetTranslationObject(locale String.Readable) [1]gdclass.Translation { //gd:TranslationServer.get_translation_object
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_translation_object, gdextension.SizeObject|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ locale gdextension.String }{pointers.Get(gd.InternalString(locale))}))
	var ret = [1]gdclass.Translation{gd.PointerWithOwnershipTransferredToGo[gdclass.Translation](r_ret)}
	return ret
}

/*
Returns [code]true[/code] if a translation domain with the specified name exists.
*/
//go:nosplit
func (self class) HasDomain(domain String.Name) bool { //gd:TranslationServer.has_domain
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.has_domain, gdextension.SizeBool|(gdextension.SizeStringName<<4), unsafe.Pointer(&struct{ domain gdextension.StringName }{pointers.Get(gd.InternalStringName(domain))}))
	var ret = r_ret
	return ret
}

/*
Returns the translation domain with the specified name. An empty translation domain will be created and added if it does not exist.
*/
//go:nosplit
func (self class) GetOrAddDomain(domain String.Name) [1]gdclass.TranslationDomain { //gd:TranslationServer.get_or_add_domain
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_or_add_domain, gdextension.SizeObject|(gdextension.SizeStringName<<4), unsafe.Pointer(&struct{ domain gdextension.StringName }{pointers.Get(gd.InternalStringName(domain))}))
	var ret = [1]gdclass.TranslationDomain{gd.PointerWithOwnershipTransferredToGo[gdclass.TranslationDomain](r_ret)}
	return ret
}

/*
Removes the translation domain with the specified name.
[b]Note:[/b] Trying to remove the main translation domain is an error.
*/
//go:nosplit
func (self class) RemoveDomain(domain String.Name) { //gd:TranslationServer.remove_domain
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.remove_domain, 0|(gdextension.SizeStringName<<4), unsafe.Pointer(&struct{ domain gdextension.StringName }{pointers.Get(gd.InternalStringName(domain))}))
}

/*
Removes all translations from the main translation domain.
*/
//go:nosplit
func (self class) Clear() { //gd:TranslationServer.clear
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.clear, 0, unsafe.Pointer(&struct{}{}))
}

/*
Returns an array of all loaded locales of the project.
*/
//go:nosplit
func (self class) GetLoadedLocales() Packed.Strings { //gd:TranslationServer.get_loaded_locales
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.get_loaded_locales, gdextension.SizePackedArray, unsafe.Pointer(&struct{}{}))
	var ret = Packed.Strings(Array.Through(gd.PackedStringArrayProxy{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

//go:nosplit
func (self class) IsPseudolocalizationEnabled() bool { //gd:TranslationServer.is_pseudolocalization_enabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_pseudolocalization_enabled, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetPseudolocalizationEnabled(enabled bool) { //gd:TranslationServer.set_pseudolocalization_enabled
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_pseudolocalization_enabled, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enabled bool }{enabled}))
}

/*
Reparses the pseudolocalization options and reloads the translation for the main translation domain.
*/
//go:nosplit
func (self class) ReloadPseudolocalization() { //gd:TranslationServer.reload_pseudolocalization
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.reload_pseudolocalization, 0, unsafe.Pointer(&struct{}{}))
}

/*
Returns the pseudolocalized string based on the [param message] passed in.
[b]Note:[/b] This method always uses the main translation domain.
*/
//go:nosplit
func (self class) Pseudolocalize(message String.Name) String.Name { //gd:TranslationServer.pseudolocalize
	var r_ret = gdextension.Call[gdextension.StringName](gd.ObjectChecked(self.AsObject()), methods.pseudolocalize, gdextension.SizeStringName|(gdextension.SizeStringName<<4), unsafe.Pointer(&struct{ message gdextension.StringName }{pointers.Get(gd.InternalStringName(message))}))
	var ret = String.Name(String.Via(gd.StringNameProxy{}, pointers.Pack(pointers.New[gd.StringName](r_ret))))
	return ret
}
func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Object.Advanced(self.AsObject()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Object.Instance(self.AsObject()), name)
	}
}
func init() {
	gdclass.Register("TranslationServer", func(ptr gd.Object) any { return *(*Instance)(unsafe.Pointer(&ptr)) })
}
