// Code generated by the generate package DO NOT EDIT

// Package VisualShader provides methods for working with VisualShader object instances.
package VisualShader

import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/variant/Signal"
import "graphics.gd/classdb/Resource"
import "graphics.gd/classdb/Shader"
import "graphics.gd/classdb/VisualShaderNode"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"
import "graphics.gd/variant/Vector2"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Signal.Any
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
This class provides a graph-like visual editor for creating a [Shader]. Although [VisualShader]s do not require coding, they share the same logic with script shaders. They use [VisualShaderNode]s that can be connected to each other to control the flow of the shader. The visual shader graph is converted to a script shader behind the scenes.
*/
type Instance [1]gdclass.VisualShader

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	set_mode               gdextension.MethodForClass `hash:"3978014962"`
	add_node               gdextension.MethodForClass `hash:"1560769431"`
	get_node               gdextension.MethodForClass `hash:"3784670312"`
	set_node_position      gdextension.MethodForClass `hash:"2726660721"`
	get_node_position      gdextension.MethodForClass `hash:"2175036082"`
	get_node_list          gdextension.MethodForClass `hash:"2370592410"`
	get_valid_node_id      gdextension.MethodForClass `hash:"629467342"`
	remove_node            gdextension.MethodForClass `hash:"844050912"`
	replace_node           gdextension.MethodForClass `hash:"3144735253"`
	is_node_connection     gdextension.MethodForClass `hash:"3922381898"`
	can_connect_nodes      gdextension.MethodForClass `hash:"3922381898"`
	connect_nodes          gdextension.MethodForClass `hash:"3081049573"`
	disconnect_nodes       gdextension.MethodForClass `hash:"2268060358"`
	connect_nodes_forced   gdextension.MethodForClass `hash:"2268060358"`
	get_node_connections   gdextension.MethodForClass `hash:"1441964831"`
	set_graph_offset       gdextension.MethodForClass `hash:"743155724"`
	get_graph_offset       gdextension.MethodForClass `hash:"3341600327"`
	attach_node_to_frame   gdextension.MethodForClass `hash:"2479945279"`
	detach_node_from_frame gdextension.MethodForClass `hash:"844050912"`
	add_varying            gdextension.MethodForClass `hash:"2084110726"`
	remove_varying         gdextension.MethodForClass `hash:"83702148"`
	has_varying            gdextension.MethodForClass `hash:"3927539163"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("VisualShader")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		gdextension.Free(gdextension.TypeStringName, &sname)
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsVisualShader() Instance
}

/*
Sets the mode of this shader.
*/
func (self Instance) SetMode(mode Shader.Mode) { //gd:VisualShader.set_mode
	Advanced(self).SetMode(mode)
}

/*
Adds the specified [param node] to the shader.
*/
func (self Instance) AddNode(atype Type, node VisualShaderNode.Instance, position Vector2.XY, id int) { //gd:VisualShader.add_node
	Advanced(self).AddNode(atype, node, Vector2.XY(position), int64(id))
}

/*
Returns the shader node instance with specified [param type] and [param id].
*/
func (self Instance) GetNode(atype Type, id int) VisualShaderNode.Instance { //gd:VisualShader.get_node
	return VisualShaderNode.Instance(Advanced(self).GetNode(atype, int64(id)))
}

/*
Sets the position of the specified node.
*/
func (self Instance) SetNodePosition(atype Type, id int, position Vector2.XY) { //gd:VisualShader.set_node_position
	Advanced(self).SetNodePosition(atype, int64(id), Vector2.XY(position))
}

/*
Returns the position of the specified node within the shader graph.
*/
func (self Instance) GetNodePosition(atype Type, id int) Vector2.XY { //gd:VisualShader.get_node_position
	return Vector2.XY(Advanced(self).GetNodePosition(atype, int64(id)))
}

/*
Returns the list of all nodes in the shader with the specified type.
*/
func (self Instance) GetNodeList(atype Type) []int32 { //gd:VisualShader.get_node_list
	return []int32(slices.Collect(Advanced(self).GetNodeList(atype).Values()))
}

/*
Returns next valid node ID that can be added to the shader graph.
*/
func (self Instance) GetValidNodeId(atype Type) NodeID { //gd:VisualShader.get_valid_node_id
	return NodeID(int(Advanced(self).GetValidNodeId(atype)))
}

/*
Removes the specified node from the shader.
*/
func (self Instance) RemoveNode(atype Type, id int) { //gd:VisualShader.remove_node
	Advanced(self).RemoveNode(atype, int64(id))
}

/*
Replaces the specified node with a node of new class type.
*/
func (self Instance) ReplaceNode(atype Type, id int, new_class string) { //gd:VisualShader.replace_node
	Advanced(self).ReplaceNode(atype, int64(id), String.Name(String.New(new_class)))
}

/*
Returns [code]true[/code] if the specified node and port connection exist.
*/
func (self Instance) IsNodeConnection(atype Type, from_node NodeID, from_port int, to_node NodeID, to_port int) bool { //gd:VisualShader.is_node_connection
	return bool(Advanced(self).IsNodeConnection(atype, int64(from_node), int64(from_port), int64(to_node), int64(to_port)))
}

/*
Returns [code]true[/code] if the specified nodes and ports can be connected together.
*/
func (self Instance) CanConnectNodes(atype Type, from_node NodeID, from_port int, to_node NodeID, to_port int) bool { //gd:VisualShader.can_connect_nodes
	return bool(Advanced(self).CanConnectNodes(atype, int64(from_node), int64(from_port), int64(to_node), int64(to_port)))
}

/*
Connects the specified nodes and ports.
*/
func (self Instance) ConnectNodes(atype Type, from_node NodeID, from_port int, to_node NodeID, to_port int) error { //gd:VisualShader.connect_nodes
	return error(gd.ToError(Advanced(self).ConnectNodes(atype, int64(from_node), int64(from_port), int64(to_node), int64(to_port))))
}

/*
Connects the specified nodes and ports.
*/
func (self Instance) DisconnectNodes(atype Type, from_node NodeID, from_port int, to_node NodeID, to_port int) { //gd:VisualShader.disconnect_nodes
	Advanced(self).DisconnectNodes(atype, int64(from_node), int64(from_port), int64(to_node), int64(to_port))
}

/*
Connects the specified nodes and ports, even if they can't be connected. Such connection is invalid and will not function properly.
*/
func (self Instance) ConnectNodesForced(atype Type, from_node NodeID, from_port int, to_node NodeID, to_port int) { //gd:VisualShader.connect_nodes_forced
	Advanced(self).ConnectNodesForced(atype, int64(from_node), int64(from_port), int64(to_node), int64(to_port))
}

/*
Returns the list of connected nodes with the specified type.
*/
func (self Instance) GetNodeConnections(atype Type) []map[string]interface{} { //gd:VisualShader.get_node_connections
	return []map[string]interface{}(gd.ArrayAs[[]map[string]interface{}](gd.InternalArray(Advanced(self).GetNodeConnections(atype))))
}

/*
Attaches the given node to the given frame.
*/
func (self Instance) AttachNodeToFrame(atype Type, id int, frame_ int) { //gd:VisualShader.attach_node_to_frame
	Advanced(self).AttachNodeToFrame(atype, int64(id), int64(frame_))
}

/*
Detaches the given node from the frame it is attached to.
*/
func (self Instance) DetachNodeFromFrame(atype Type, id int) { //gd:VisualShader.detach_node_from_frame
	Advanced(self).DetachNodeFromFrame(atype, int64(id))
}

/*
Adds a new varying value node to the shader.
*/
func (self Instance) AddVarying(name string, mode VaryingMode, atype VaryingType) { //gd:VisualShader.add_varying
	Advanced(self).AddVarying(String.New(name), mode, atype)
}

/*
Removes a varying value node with the given [param name]. Prints an error if a node with this name is not found.
*/
func (self Instance) RemoveVarying(name string) { //gd:VisualShader.remove_varying
	Advanced(self).RemoveVarying(String.New(name))
}

/*
Returns [code]true[/code] if the shader has a varying with the given [param name].
*/
func (self Instance) HasVarying(name string) bool { //gd:VisualShader.has_varying
	return bool(Advanced(self).HasVarying(String.New(name)))
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.VisualShader

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = pointers.AsA[gdclass.VisualShader](obj[0])
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = pointers.AsA[gdclass.VisualShader](obj[0])
		return true
	}
	return false
}
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }
func (self *Extension[T]) AsObject() [1]gd.Object { return self.Super().AsObject() }
func New() Instance {
	if !gd.Linked {
		var placeholder = Instance([1]gdclass.VisualShader{pointers.Add[gdclass.VisualShader]([3]uint64{})})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(pointers.AsA[gd.Object](placeholder[0]), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	casted := Instance([1]gdclass.VisualShader{pointers.New[gdclass.VisualShader]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})})
	casted.AsRefCounted()[0].InitRef()
	casted.AsObject()[0].Notification(0, false)
	return casted
}

func (self Instance) GraphOffset() Vector2.XY {
	return Vector2.XY(class(self).GetGraphOffset())
}

func (self Instance) SetGraphOffset(value Vector2.XY) {
	class(self).SetGraphOffset(Vector2.XY(value))
}

/*
Sets the mode of this shader.
*/
//go:nosplit
func (self class) SetMode(mode Shader.Mode) { //gd:VisualShader.set_mode
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_mode, 0|(gdextension.SizeInt<<4), &struct{ mode Shader.Mode }{mode})
}

/*
Adds the specified [param node] to the shader.
*/
//go:nosplit
func (self class) AddNode(atype Type, node [1]gdclass.VisualShaderNode, position Vector2.XY, id int64) { //gd:VisualShader.add_node
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_node, 0|(gdextension.SizeInt<<4)|(gdextension.SizeObject<<8)|(gdextension.SizeVector2<<12)|(gdextension.SizeInt<<16), &struct {
		atype    Type
		node     gdextension.Object
		position Vector2.XY
		id       int64
	}{atype, gdextension.Object(gd.ObjectChecked(node[0].AsObject())), position, id})
}

/*
Returns the shader node instance with specified [param type] and [param id].
*/
//go:nosplit
func (self class) GetNode(atype Type, id int64) [1]gdclass.VisualShaderNode { //gd:VisualShader.get_node
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_node, gdextension.SizeObject|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), &struct {
		atype Type
		id    int64
	}{atype, id})
	var ret = [1]gdclass.VisualShaderNode{gd.PointerWithOwnershipTransferredToGo[gdclass.VisualShaderNode](r_ret)}
	return ret
}

/*
Sets the position of the specified node.
*/
//go:nosplit
func (self class) SetNodePosition(atype Type, id int64, position Vector2.XY) { //gd:VisualShader.set_node_position
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_node_position, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeVector2<<12), &struct {
		atype    Type
		id       int64
		position Vector2.XY
	}{atype, id, position})
}

/*
Returns the position of the specified node within the shader graph.
*/
//go:nosplit
func (self class) GetNodePosition(atype Type, id int64) Vector2.XY { //gd:VisualShader.get_node_position
	var r_ret = gdextension.Call[Vector2.XY](gd.ObjectChecked(self.AsObject()), methods.get_node_position, gdextension.SizeVector2|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), &struct {
		atype Type
		id    int64
	}{atype, id})
	var ret = r_ret
	return ret
}

/*
Returns the list of all nodes in the shader with the specified type.
*/
//go:nosplit
func (self class) GetNodeList(atype Type) Packed.Array[int32] { //gd:VisualShader.get_node_list
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.get_node_list, gdextension.SizePackedArray|(gdextension.SizeInt<<4), &struct{ atype Type }{atype})
	var ret = Packed.Array[int32](Array.Through(gd.PackedProxy[gd.PackedInt32Array, int32]{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

/*
Returns next valid node ID that can be added to the shader graph.
*/
//go:nosplit
func (self class) GetValidNodeId(atype Type) int64 { //gd:VisualShader.get_valid_node_id
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_valid_node_id, gdextension.SizeInt|(gdextension.SizeInt<<4), &struct{ atype Type }{atype})
	var ret = r_ret
	return ret
}

/*
Removes the specified node from the shader.
*/
//go:nosplit
func (self class) RemoveNode(atype Type, id int64) { //gd:VisualShader.remove_node
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.remove_node, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), &struct {
		atype Type
		id    int64
	}{atype, id})
}

/*
Replaces the specified node with a node of new class type.
*/
//go:nosplit
func (self class) ReplaceNode(atype Type, id int64, new_class String.Name) { //gd:VisualShader.replace_node
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.replace_node, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeStringName<<12), &struct {
		atype     Type
		id        int64
		new_class gdextension.StringName
	}{atype, id, pointers.Get(gd.InternalStringName(new_class))})
}

/*
Returns [code]true[/code] if the specified node and port connection exist.
*/
//go:nosplit
func (self class) IsNodeConnection(atype Type, from_node int64, from_port int64, to_node int64, to_port int64) bool { //gd:VisualShader.is_node_connection
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_node_connection, gdextension.SizeBool|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeInt<<16)|(gdextension.SizeInt<<20), &struct {
		atype     Type
		from_node int64
		from_port int64
		to_node   int64
		to_port   int64
	}{atype, from_node, from_port, to_node, to_port})
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if the specified nodes and ports can be connected together.
*/
//go:nosplit
func (self class) CanConnectNodes(atype Type, from_node int64, from_port int64, to_node int64, to_port int64) bool { //gd:VisualShader.can_connect_nodes
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.can_connect_nodes, gdextension.SizeBool|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeInt<<16)|(gdextension.SizeInt<<20), &struct {
		atype     Type
		from_node int64
		from_port int64
		to_node   int64
		to_port   int64
	}{atype, from_node, from_port, to_node, to_port})
	var ret = r_ret
	return ret
}

/*
Connects the specified nodes and ports.
*/
//go:nosplit
func (self class) ConnectNodes(atype Type, from_node int64, from_port int64, to_node int64, to_port int64) Error.Code { //gd:VisualShader.connect_nodes
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.connect_nodes, gdextension.SizeInt|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeInt<<16)|(gdextension.SizeInt<<20), &struct {
		atype     Type
		from_node int64
		from_port int64
		to_node   int64
		to_port   int64
	}{atype, from_node, from_port, to_node, to_port})
	var ret = Error.Code(r_ret)
	return ret
}

/*
Connects the specified nodes and ports.
*/
//go:nosplit
func (self class) DisconnectNodes(atype Type, from_node int64, from_port int64, to_node int64, to_port int64) { //gd:VisualShader.disconnect_nodes
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.disconnect_nodes, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeInt<<16)|(gdextension.SizeInt<<20), &struct {
		atype     Type
		from_node int64
		from_port int64
		to_node   int64
		to_port   int64
	}{atype, from_node, from_port, to_node, to_port})
}

/*
Connects the specified nodes and ports, even if they can't be connected. Such connection is invalid and will not function properly.
*/
//go:nosplit
func (self class) ConnectNodesForced(atype Type, from_node int64, from_port int64, to_node int64, to_port int64) { //gd:VisualShader.connect_nodes_forced
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.connect_nodes_forced, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeInt<<16)|(gdextension.SizeInt<<20), &struct {
		atype     Type
		from_node int64
		from_port int64
		to_node   int64
		to_port   int64
	}{atype, from_node, from_port, to_node, to_port})
}

/*
Returns the list of connected nodes with the specified type.
*/
//go:nosplit
func (self class) GetNodeConnections(atype Type) Array.Contains[Dictionary.Any] { //gd:VisualShader.get_node_connections
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), methods.get_node_connections, gdextension.SizeArray|(gdextension.SizeInt<<4), &struct{ atype Type }{atype})
	var ret = Array.Through(gd.ArrayProxy[Dictionary.Any]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

//go:nosplit
func (self class) SetGraphOffset(offset Vector2.XY) { //gd:VisualShader.set_graph_offset
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_graph_offset, 0|(gdextension.SizeVector2<<4), &struct{ offset Vector2.XY }{offset})
}

//go:nosplit
func (self class) GetGraphOffset() Vector2.XY { //gd:VisualShader.get_graph_offset
	var r_ret = gdextension.Call[Vector2.XY](gd.ObjectChecked(self.AsObject()), methods.get_graph_offset, gdextension.SizeVector2, &struct{}{})
	var ret = r_ret
	return ret
}

/*
Attaches the given node to the given frame.
*/
//go:nosplit
func (self class) AttachNodeToFrame(atype Type, id int64, frame_ int64) { //gd:VisualShader.attach_node_to_frame
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.attach_node_to_frame, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeInt<<12), &struct {
		atype  Type
		id     int64
		frame_ int64
	}{atype, id, frame_})
}

/*
Detaches the given node from the frame it is attached to.
*/
//go:nosplit
func (self class) DetachNodeFromFrame(atype Type, id int64) { //gd:VisualShader.detach_node_from_frame
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.detach_node_from_frame, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), &struct {
		atype Type
		id    int64
	}{atype, id})
}

/*
Adds a new varying value node to the shader.
*/
//go:nosplit
func (self class) AddVarying(name String.Readable, mode VaryingMode, atype VaryingType) { //gd:VisualShader.add_varying
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_varying, 0|(gdextension.SizeString<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeInt<<12), &struct {
		name  gdextension.String
		mode  VaryingMode
		atype VaryingType
	}{pointers.Get(gd.InternalString(name)), mode, atype})
}

/*
Removes a varying value node with the given [param name]. Prints an error if a node with this name is not found.
*/
//go:nosplit
func (self class) RemoveVarying(name String.Readable) { //gd:VisualShader.remove_varying
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.remove_varying, 0|(gdextension.SizeString<<4), &struct{ name gdextension.String }{pointers.Get(gd.InternalString(name))})
}

/*
Returns [code]true[/code] if the shader has a varying with the given [param name].
*/
//go:nosplit
func (self class) HasVarying(name String.Readable) bool { //gd:VisualShader.has_varying
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.has_varying, gdextension.SizeBool|(gdextension.SizeString<<4), &struct{ name gdextension.String }{pointers.Get(gd.InternalString(name))})
	var ret = r_ret
	return ret
}
func (self class) AsVisualShader() Advanced {
	return Advanced{pointers.AsA[gdclass.VisualShader](self[0])}
}
func (self Instance) AsVisualShader() Instance {
	return Instance{pointers.AsA[gdclass.VisualShader](self[0])}
}
func (self *Extension[T]) AsVisualShader() Instance { return self.Super().AsVisualShader() }
func (self class) AsShader() Shader.Advanced {
	return Shader.Advanced{pointers.AsA[gdclass.Shader](self[0])}
}
func (self *Extension[T]) AsShader() Shader.Instance { return self.Super().AsShader() }
func (self Instance) AsShader() Shader.Instance {
	return Shader.Instance{pointers.AsA[gdclass.Shader](self[0])}
}
func (self class) AsResource() Resource.Advanced {
	return Resource.Advanced{pointers.AsA[gdclass.Resource](self[0])}
}
func (self *Extension[T]) AsResource() Resource.Instance { return self.Super().AsResource() }
func (self Instance) AsResource() Resource.Instance {
	return Resource.Instance{pointers.AsA[gdclass.Resource](self[0])}
}
func (self class) AsRefCounted() [1]gd.RefCounted {
	return [1]gd.RefCounted{gd.RefCounted(pointers.AsA[gd.Object](self[0]))}
}
func (self *Extension[T]) AsRefCounted() [1]gd.RefCounted { return self.Super().AsRefCounted() }
func (self Instance) AsRefCounted() [1]gd.RefCounted {
	return [1]gd.RefCounted{gd.RefCounted(pointers.AsA[gd.Object](self[0]))}
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Shader.Advanced(self.AsShader()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Shader.Instance(self.AsShader()), name)
	}
}
func init() {
	gdclass.Register("VisualShader", func(ptr gd.Object) any { return Instance{pointers.AsA[gdclass.VisualShader](ptr)} })
}

type Type int //gd:VisualShader.Type

const (
	/*A vertex shader, operating on vertices.*/
	TypeVertex Type = 0
	/*A fragment shader, operating on fragments (pixels).*/
	TypeFragment Type = 1
	/*A shader for light calculations.*/
	TypeLight Type = 2
	/*A function for the "start" stage of particle shader.*/
	TypeStart Type = 3
	/*A function for the "process" stage of particle shader.*/
	TypeProcess Type = 4
	/*A function for the "collide" stage (particle collision handler) of particle shader.*/
	TypeCollide Type = 5
	/*A function for the "start" stage of particle shader, with customized output.*/
	TypeStartCustom Type = 6
	/*A function for the "process" stage of particle shader, with customized output.*/
	TypeProcessCustom Type = 7
	/*A shader for 3D environment's sky.*/
	TypeSky Type = 8
	/*A compute shader that runs for each froxel of the volumetric fog map.*/
	TypeFog Type = 9
	/*Represents the size of the [enum Type] enum.*/
	TypeMax Type = 10
)

type VaryingMode int //gd:VisualShader.VaryingMode

const (
	/*Varying is passed from [code]Vertex[/code] function to [code]Fragment[/code] and [code]Light[/code] functions.*/
	VaryingModeVertexToFragLight VaryingMode = 0
	/*Varying is passed from [code]Fragment[/code] function to [code]Light[/code] function.*/
	VaryingModeFragToLight VaryingMode = 1
	/*Represents the size of the [enum VaryingMode] enum.*/
	VaryingModeMax VaryingMode = 2
)

type VaryingType int //gd:VisualShader.VaryingType

const (
	/*Varying is of type [float].*/
	VaryingTypeFloat VaryingType = 0
	/*Varying is of type [int].*/
	VaryingTypeInt VaryingType = 1
	/*Varying is of type unsigned [int].*/
	VaryingTypeUint VaryingType = 2
	/*Varying is of type [Vector2].*/
	VaryingTypeVector2d VaryingType = 3
	/*Varying is of type [Vector3].*/
	VaryingTypeVector3d VaryingType = 4
	/*Varying is of type [Vector4].*/
	VaryingTypeVector4d VaryingType = 5
	/*Varying is of type [bool].*/
	VaryingTypeBoolean VaryingType = 6
	/*Varying is of type [Transform3D].*/
	VaryingTypeTransform VaryingType = 7
	/*Represents the size of the [enum VaryingType] enum.*/
	VaryingTypeMax VaryingType = 8
)

type NodeID int

const NodeIdInvalid NodeID = -1 //gd:VisualShader.NODE_ID_INVALID
const NodeIdOutput NodeID = 0   //gd:VisualShader.NODE_ID_OUTPUT
