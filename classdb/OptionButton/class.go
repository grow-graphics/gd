// Code generated by the generate package DO NOT EDIT

// Package OptionButton provides methods for working with OptionButton object instances.
package OptionButton

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/BaseButton"
import "graphics.gd/classdb/Button"
import "graphics.gd/classdb/CanvasItem"
import "graphics.gd/classdb/Control"
import "graphics.gd/classdb/Node"
import "graphics.gd/classdb/PopupMenu"
import "graphics.gd/classdb/Texture2D"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
[OptionButton] is a type of button that brings up a dropdown with selectable items when pressed. The item selected becomes the "current" item and is displayed as the button text.
See also [BaseButton] which contains common properties and methods associated with this node.
[b]Note:[/b] The ID values used for items are limited to 32 bits, not full 64 bits of [int]. This has a range of [code]-2^32[/code] to [code]2^32 - 1[/code], i.e. [code]-2147483648[/code] to [code]2147483647[/code].
[b]Note:[/b] The [member Button.text] and [member Button.icon] properties are set automatically based on the selected item. They shouldn't be changed manually.
*/
type Instance [1]gdclass.OptionButton

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	add_item                gdextension.MethodForClass `hash:"2697778442"`
	add_icon_item           gdextension.MethodForClass `hash:"3781678508"`
	set_item_text           gdextension.MethodForClass `hash:"501894301"`
	set_item_icon           gdextension.MethodForClass `hash:"666127730"`
	set_item_disabled       gdextension.MethodForClass `hash:"300928843"`
	set_item_id             gdextension.MethodForClass `hash:"3937882851"`
	set_item_metadata       gdextension.MethodForClass `hash:"2152698145"`
	set_item_tooltip        gdextension.MethodForClass `hash:"501894301"`
	get_item_text           gdextension.MethodForClass `hash:"844755477"`
	get_item_icon           gdextension.MethodForClass `hash:"3536238170"`
	get_item_id             gdextension.MethodForClass `hash:"923996154"`
	get_item_index          gdextension.MethodForClass `hash:"923996154"`
	get_item_metadata       gdextension.MethodForClass `hash:"4227898402"`
	get_item_tooltip        gdextension.MethodForClass `hash:"844755477"`
	is_item_disabled        gdextension.MethodForClass `hash:"1116898809"`
	is_item_separator       gdextension.MethodForClass `hash:"1116898809"`
	add_separator           gdextension.MethodForClass `hash:"3005725572"`
	clear                   gdextension.MethodForClass `hash:"3218959716"`
	select_                 gdextension.MethodForClass `hash:"1286410249"`
	get_selected            gdextension.MethodForClass `hash:"3905245786"`
	get_selected_id         gdextension.MethodForClass `hash:"3905245786"`
	get_selected_metadata   gdextension.MethodForClass `hash:"1214101251"`
	remove_item             gdextension.MethodForClass `hash:"1286410249"`
	get_popup               gdextension.MethodForClass `hash:"229722558"`
	show_popup              gdextension.MethodForClass `hash:"3218959716"`
	set_item_count          gdextension.MethodForClass `hash:"1286410249"`
	get_item_count          gdextension.MethodForClass `hash:"3905245786"`
	has_selectable_items    gdextension.MethodForClass `hash:"36873697"`
	get_selectable_item     gdextension.MethodForClass `hash:"894402480"`
	set_fit_to_longest_item gdextension.MethodForClass `hash:"2586408642"`
	is_fit_to_longest_item  gdextension.MethodForClass `hash:"36873697"`
	set_allow_reselect      gdextension.MethodForClass `hash:"2586408642"`
	get_allow_reselect      gdextension.MethodForClass `hash:"36873697"`
	set_disable_shortcuts   gdextension.MethodForClass `hash:"2586408642"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("OptionButton")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		pointers.Raw[gd.StringName](sname).Free()
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

type Expanded [1]gdclass.OptionButton

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsOptionButton() Instance
}

/*
Adds an item, with text [param label] and (optionally) [param id]. If no [param id] is passed, the item index will be used as the item's ID. New items are appended at the end.
*/
func (self Instance) AddItem(label string) { //gd:OptionButton.add_item
	Advanced(self).AddItem(String.New(label), int64(-1))
}

/*
Adds an item, with text [param label] and (optionally) [param id]. If no [param id] is passed, the item index will be used as the item's ID. New items are appended at the end.
*/
func (self Expanded) AddItem(label string, id int) { //gd:OptionButton.add_item
	Advanced(self).AddItem(String.New(label), int64(id))
}

/*
Adds an item, with a [param texture] icon, text [param label] and (optionally) [param id]. If no [param id] is passed, the item index will be used as the item's ID. New items are appended at the end.
*/
func (self Instance) AddIconItem(texture Texture2D.Instance, label string) { //gd:OptionButton.add_icon_item
	Advanced(self).AddIconItem(texture, String.New(label), int64(-1))
}

/*
Adds an item, with a [param texture] icon, text [param label] and (optionally) [param id]. If no [param id] is passed, the item index will be used as the item's ID. New items are appended at the end.
*/
func (self Expanded) AddIconItem(texture Texture2D.Instance, label string, id int) { //gd:OptionButton.add_icon_item
	Advanced(self).AddIconItem(texture, String.New(label), int64(id))
}

/*
Sets the text of the item at index [param idx].
*/
func (self Instance) SetItemText(idx int, text string) { //gd:OptionButton.set_item_text
	Advanced(self).SetItemText(int64(idx), String.New(text))
}

/*
Sets the icon of the item at index [param idx].
*/
func (self Instance) SetItemIcon(idx int, texture Texture2D.Instance) { //gd:OptionButton.set_item_icon
	Advanced(self).SetItemIcon(int64(idx), texture)
}

/*
Sets whether the item at index [param idx] is disabled.
Disabled items are drawn differently in the dropdown and are not selectable by the user. If the current selected item is set as disabled, it will remain selected.
*/
func (self Instance) SetItemDisabled(idx int, disabled bool) { //gd:OptionButton.set_item_disabled
	Advanced(self).SetItemDisabled(int64(idx), disabled)
}

/*
Sets the ID of the item at index [param idx].
*/
func (self Instance) SetItemId(idx int, id int) { //gd:OptionButton.set_item_id
	Advanced(self).SetItemId(int64(idx), int64(id))
}

/*
Sets the metadata of an item. Metadata may be of any type and can be used to store extra information about an item, such as an external string ID.
*/
func (self Instance) SetItemMetadata(idx int, metadata any) { //gd:OptionButton.set_item_metadata
	Advanced(self).SetItemMetadata(int64(idx), variant.New(metadata))
}

/*
Sets the tooltip of the item at index [param idx].
*/
func (self Instance) SetItemTooltip(idx int, tooltip string) { //gd:OptionButton.set_item_tooltip
	Advanced(self).SetItemTooltip(int64(idx), String.New(tooltip))
}

/*
Returns the text of the item at index [param idx].
*/
func (self Instance) GetItemText(idx int) string { //gd:OptionButton.get_item_text
	return string(Advanced(self).GetItemText(int64(idx)).String())
}

/*
Returns the icon of the item at index [param idx].
*/
func (self Instance) GetItemIcon(idx int) Texture2D.Instance { //gd:OptionButton.get_item_icon
	return Texture2D.Instance(Advanced(self).GetItemIcon(int64(idx)))
}

/*
Returns the ID of the item at index [param idx].
*/
func (self Instance) GetItemId(idx int) int { //gd:OptionButton.get_item_id
	return int(int(Advanced(self).GetItemId(int64(idx))))
}

/*
Returns the index of the item with the given [param id].
*/
func (self Instance) GetItemIndex(id int) int { //gd:OptionButton.get_item_index
	return int(int(Advanced(self).GetItemIndex(int64(id))))
}

/*
Retrieves the metadata of an item. Metadata may be any type and can be used to store extra information about an item, such as an external string ID.
*/
func (self Instance) GetItemMetadata(idx int) any { //gd:OptionButton.get_item_metadata
	return any(Advanced(self).GetItemMetadata(int64(idx)).Interface())
}

/*
Returns the tooltip of the item at index [param idx].
*/
func (self Instance) GetItemTooltip(idx int) string { //gd:OptionButton.get_item_tooltip
	return string(Advanced(self).GetItemTooltip(int64(idx)).String())
}

/*
Returns [code]true[/code] if the item at index [param idx] is disabled.
*/
func (self Instance) IsItemDisabled(idx int) bool { //gd:OptionButton.is_item_disabled
	return bool(Advanced(self).IsItemDisabled(int64(idx)))
}

/*
Returns [code]true[/code] if the item at index [param idx] is marked as a separator.
*/
func (self Instance) IsItemSeparator(idx int) bool { //gd:OptionButton.is_item_separator
	return bool(Advanced(self).IsItemSeparator(int64(idx)))
}

/*
Adds a separator to the list of items. Separators help to group items, and can optionally be given a [param text] header. A separator also gets an index assigned, and is appended at the end of the item list.
*/
func (self Instance) AddSeparator() { //gd:OptionButton.add_separator
	Advanced(self).AddSeparator(String.New(""))
}

/*
Adds a separator to the list of items. Separators help to group items, and can optionally be given a [param text] header. A separator also gets an index assigned, and is appended at the end of the item list.
*/
func (self Expanded) AddSeparator(text string) { //gd:OptionButton.add_separator
	Advanced(self).AddSeparator(String.New(text))
}

/*
Clears all the items in the [OptionButton].
*/
func (self Instance) Clear() { //gd:OptionButton.clear
	Advanced(self).Clear()
}

/*
Selects an item by index and makes it the current item. This will work even if the item is disabled.
Passing [code]-1[/code] as the index deselects any currently selected item.
*/
func (self Instance) Select(idx int) { //gd:OptionButton.select
	Advanced(self).Select(int64(idx))
}

/*
Returns the ID of the selected item, or [code]-1[/code] if no item is selected.
*/
func (self Instance) GetSelectedId() int { //gd:OptionButton.get_selected_id
	return int(int(Advanced(self).GetSelectedId()))
}

/*
Gets the metadata of the selected item. Metadata for items can be set using [method set_item_metadata].
*/
func (self Instance) GetSelectedMetadata() any { //gd:OptionButton.get_selected_metadata
	return any(Advanced(self).GetSelectedMetadata().Interface())
}

/*
Removes the item at index [param idx].
*/
func (self Instance) RemoveItem(idx int) { //gd:OptionButton.remove_item
	Advanced(self).RemoveItem(int64(idx))
}

/*
Returns the [PopupMenu] contained in this button.
[b]Warning:[/b] This is a required internal node, removing and freeing it may cause a crash. If you wish to hide it or any of its children, use their [member Window.visible] property.
*/
func (self Instance) GetPopup() PopupMenu.Instance { //gd:OptionButton.get_popup
	return PopupMenu.Instance(Advanced(self).GetPopup())
}

/*
Adjusts popup position and sizing for the [OptionButton], then shows the [PopupMenu]. Prefer this over using [code]get_popup().popup()[/code].
*/
func (self Instance) ShowPopup() { //gd:OptionButton.show_popup
	Advanced(self).ShowPopup()
}

/*
Returns [code]true[/code] if this button contains at least one item which is not disabled, or marked as a separator.
*/
func (self Instance) HasSelectableItems() bool { //gd:OptionButton.has_selectable_items
	return bool(Advanced(self).HasSelectableItems())
}

/*
Returns the index of the first item which is not disabled, or marked as a separator. If [param from_last] is [code]true[/code], the items will be searched in reverse order.
Returns [code]-1[/code] if no item is found.
*/
func (self Instance) GetSelectableItem() int { //gd:OptionButton.get_selectable_item
	return int(int(Advanced(self).GetSelectableItem(false)))
}

/*
Returns the index of the first item which is not disabled, or marked as a separator. If [param from_last] is [code]true[/code], the items will be searched in reverse order.
Returns [code]-1[/code] if no item is found.
*/
func (self Expanded) GetSelectableItem(from_last bool) int { //gd:OptionButton.get_selectable_item
	return int(int(Advanced(self).GetSelectableItem(from_last)))
}

/*
If [code]true[/code], shortcuts are disabled and cannot be used to trigger the button.
*/
func (self Instance) SetDisableShortcuts(disabled bool) { //gd:OptionButton.set_disable_shortcuts
	Advanced(self).SetDisableShortcuts(disabled)
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.OptionButton

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.OptionButton)(unsafe.Pointer(&obj))
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.OptionButton)(unsafe.Pointer(&obj))
		return true
	}
	return false
}

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {
	object := [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})}
	casted := Instance{*(*gdclass.OptionButton)(unsafe.Pointer(&object))}
	object[0].Notification(0, false)
	return casted
}

func (self Instance) Selected() int {
	return int(int(class(self).GetSelected()))
}

func (self Instance) FitToLongestItem() bool {
	return bool(class(self).IsFitToLongestItem())
}

func (self Instance) SetFitToLongestItem(value bool) {
	class(self).SetFitToLongestItem(value)
}

func (self Instance) AllowReselect() bool {
	return bool(class(self).GetAllowReselect())
}

func (self Instance) SetAllowReselect(value bool) {
	class(self).SetAllowReselect(value)
}

func (self Instance) ItemCount() int {
	return int(int(class(self).GetItemCount()))
}

func (self Instance) SetItemCount(value int) {
	class(self).SetItemCount(int64(value))
}

/*
Adds an item, with text [param label] and (optionally) [param id]. If no [param id] is passed, the item index will be used as the item's ID. New items are appended at the end.
*/
//go:nosplit
func (self class) AddItem(label String.Readable, id int64) { //gd:OptionButton.add_item
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_item, 0|(gdextension.SizeString<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		label gdextension.String
		id    int64
	}{pointers.Get(gd.InternalString(label)), id}))
}

/*
Adds an item, with a [param texture] icon, text [param label] and (optionally) [param id]. If no [param id] is passed, the item index will be used as the item's ID. New items are appended at the end.
*/
//go:nosplit
func (self class) AddIconItem(texture [1]gdclass.Texture2D, label String.Readable, id int64) { //gd:OptionButton.add_icon_item
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_icon_item, 0|(gdextension.SizeObject<<4)|(gdextension.SizeString<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		texture gdextension.Object
		label   gdextension.String
		id      int64
	}{gdextension.Object(gd.ObjectChecked(texture[0].AsObject())), pointers.Get(gd.InternalString(label)), id}))
}

/*
Sets the text of the item at index [param idx].
*/
//go:nosplit
func (self class) SetItemText(idx int64, text String.Readable) { //gd:OptionButton.set_item_text
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_text, 0|(gdextension.SizeInt<<4)|(gdextension.SizeString<<8), unsafe.Pointer(&struct {
		idx  int64
		text gdextension.String
	}{idx, pointers.Get(gd.InternalString(text))}))
}

/*
Sets the icon of the item at index [param idx].
*/
//go:nosplit
func (self class) SetItemIcon(idx int64, texture [1]gdclass.Texture2D) { //gd:OptionButton.set_item_icon
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_icon, 0|(gdextension.SizeInt<<4)|(gdextension.SizeObject<<8), unsafe.Pointer(&struct {
		idx     int64
		texture gdextension.Object
	}{idx, gdextension.Object(gd.ObjectChecked(texture[0].AsObject()))}))
}

/*
Sets whether the item at index [param idx] is disabled.
Disabled items are drawn differently in the dropdown and are not selectable by the user. If the current selected item is set as disabled, it will remain selected.
*/
//go:nosplit
func (self class) SetItemDisabled(idx int64, disabled bool) { //gd:OptionButton.set_item_disabled
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_disabled, 0|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		idx      int64
		disabled bool
	}{idx, disabled}))
}

/*
Sets the ID of the item at index [param idx].
*/
//go:nosplit
func (self class) SetItemId(idx int64, id int64) { //gd:OptionButton.set_item_id
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_id, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		idx int64
		id  int64
	}{idx, id}))
}

/*
Sets the metadata of an item. Metadata may be of any type and can be used to store extra information about an item, such as an external string ID.
*/
//go:nosplit
func (self class) SetItemMetadata(idx int64, metadata variant.Any) { //gd:OptionButton.set_item_metadata
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_metadata, 0|(gdextension.SizeInt<<4)|(gdextension.SizeVariant<<8), unsafe.Pointer(&struct {
		idx      int64
		metadata gdextension.Variant
	}{idx, gdextension.Variant(pointers.Get(gd.InternalVariant(metadata)))}))
}

/*
Sets the tooltip of the item at index [param idx].
*/
//go:nosplit
func (self class) SetItemTooltip(idx int64, tooltip String.Readable) { //gd:OptionButton.set_item_tooltip
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_tooltip, 0|(gdextension.SizeInt<<4)|(gdextension.SizeString<<8), unsafe.Pointer(&struct {
		idx     int64
		tooltip gdextension.String
	}{idx, pointers.Get(gd.InternalString(tooltip))}))
}

/*
Returns the text of the item at index [param idx].
*/
//go:nosplit
func (self class) GetItemText(idx int64) String.Readable { //gd:OptionButton.get_item_text
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_item_text, gdextension.SizeString|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ idx int64 }{idx}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Returns the icon of the item at index [param idx].
*/
//go:nosplit
func (self class) GetItemIcon(idx int64) [1]gdclass.Texture2D { //gd:OptionButton.get_item_icon
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_item_icon, gdextension.SizeObject|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ idx int64 }{idx}))
	var ret = [1]gdclass.Texture2D{gd.PointerWithOwnershipTransferredToGo[gdclass.Texture2D](r_ret)}
	return ret
}

/*
Returns the ID of the item at index [param idx].
*/
//go:nosplit
func (self class) GetItemId(idx int64) int64 { //gd:OptionButton.get_item_id
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_item_id, gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ idx int64 }{idx}))
	var ret = r_ret
	return ret
}

/*
Returns the index of the item with the given [param id].
*/
//go:nosplit
func (self class) GetItemIndex(id int64) int64 { //gd:OptionButton.get_item_index
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_item_index, gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ id int64 }{id}))
	var ret = r_ret
	return ret
}

/*
Retrieves the metadata of an item. Metadata may be any type and can be used to store extra information about an item, such as an external string ID.
*/
//go:nosplit
func (self class) GetItemMetadata(idx int64) variant.Any { //gd:OptionButton.get_item_metadata
	var r_ret = gdextension.Call[gdextension.Variant](gd.ObjectChecked(self.AsObject()), methods.get_item_metadata, gdextension.SizeVariant|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ idx int64 }{idx}))
	var ret = variant.Implementation(gd.VariantProxy{}, pointers.Pack(pointers.New[gd.Variant](r_ret)))
	return ret
}

/*
Returns the tooltip of the item at index [param idx].
*/
//go:nosplit
func (self class) GetItemTooltip(idx int64) String.Readable { //gd:OptionButton.get_item_tooltip
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_item_tooltip, gdextension.SizeString|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ idx int64 }{idx}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Returns [code]true[/code] if the item at index [param idx] is disabled.
*/
//go:nosplit
func (self class) IsItemDisabled(idx int64) bool { //gd:OptionButton.is_item_disabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_item_disabled, gdextension.SizeBool|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ idx int64 }{idx}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if the item at index [param idx] is marked as a separator.
*/
//go:nosplit
func (self class) IsItemSeparator(idx int64) bool { //gd:OptionButton.is_item_separator
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_item_separator, gdextension.SizeBool|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ idx int64 }{idx}))
	var ret = r_ret
	return ret
}

/*
Adds a separator to the list of items. Separators help to group items, and can optionally be given a [param text] header. A separator also gets an index assigned, and is appended at the end of the item list.
*/
//go:nosplit
func (self class) AddSeparator(text String.Readable) { //gd:OptionButton.add_separator
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_separator, 0|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ text gdextension.String }{pointers.Get(gd.InternalString(text))}))
}

/*
Clears all the items in the [OptionButton].
*/
//go:nosplit
func (self class) Clear() { //gd:OptionButton.clear
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.clear, 0, unsafe.Pointer(&struct{}{}))
}

/*
Selects an item by index and makes it the current item. This will work even if the item is disabled.
Passing [code]-1[/code] as the index deselects any currently selected item.
*/
//go:nosplit
func (self class) Select(idx int64) { //gd:OptionButton.select_
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.select_, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ idx int64 }{idx}))
}

//go:nosplit
func (self class) GetSelected() int64 { //gd:OptionButton.get_selected
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_selected, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the ID of the selected item, or [code]-1[/code] if no item is selected.
*/
//go:nosplit
func (self class) GetSelectedId() int64 { //gd:OptionButton.get_selected_id
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_selected_id, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Gets the metadata of the selected item. Metadata for items can be set using [method set_item_metadata].
*/
//go:nosplit
func (self class) GetSelectedMetadata() variant.Any { //gd:OptionButton.get_selected_metadata
	var r_ret = gdextension.Call[gdextension.Variant](gd.ObjectChecked(self.AsObject()), methods.get_selected_metadata, gdextension.SizeVariant, unsafe.Pointer(&struct{}{}))
	var ret = variant.Implementation(gd.VariantProxy{}, pointers.Pack(pointers.New[gd.Variant](r_ret)))
	return ret
}

/*
Removes the item at index [param idx].
*/
//go:nosplit
func (self class) RemoveItem(idx int64) { //gd:OptionButton.remove_item
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.remove_item, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ idx int64 }{idx}))
}

/*
Returns the [PopupMenu] contained in this button.
[b]Warning:[/b] This is a required internal node, removing and freeing it may cause a crash. If you wish to hide it or any of its children, use their [member Window.visible] property.
*/
//go:nosplit
func (self class) GetPopup() [1]gdclass.PopupMenu { //gd:OptionButton.get_popup
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_popup, gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.PopupMenu{gd.PointerLifetimeBoundTo[gdclass.PopupMenu](self.AsObject(), r_ret)}
	return ret
}

/*
Adjusts popup position and sizing for the [OptionButton], then shows the [PopupMenu]. Prefer this over using [code]get_popup().popup()[/code].
*/
//go:nosplit
func (self class) ShowPopup() { //gd:OptionButton.show_popup
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.show_popup, 0, unsafe.Pointer(&struct{}{}))
}

//go:nosplit
func (self class) SetItemCount(count int64) { //gd:OptionButton.set_item_count
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_count, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ count int64 }{count}))
}

//go:nosplit
func (self class) GetItemCount() int64 { //gd:OptionButton.get_item_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_item_count, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if this button contains at least one item which is not disabled, or marked as a separator.
*/
//go:nosplit
func (self class) HasSelectableItems() bool { //gd:OptionButton.has_selectable_items
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.has_selectable_items, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the index of the first item which is not disabled, or marked as a separator. If [param from_last] is [code]true[/code], the items will be searched in reverse order.
Returns [code]-1[/code] if no item is found.
*/
//go:nosplit
func (self class) GetSelectableItem(from_last bool) int64 { //gd:OptionButton.get_selectable_item
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_selectable_item, gdextension.SizeInt|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ from_last bool }{from_last}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetFitToLongestItem(fit bool) { //gd:OptionButton.set_fit_to_longest_item
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_fit_to_longest_item, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ fit bool }{fit}))
}

//go:nosplit
func (self class) IsFitToLongestItem() bool { //gd:OptionButton.is_fit_to_longest_item
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_fit_to_longest_item, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetAllowReselect(allow bool) { //gd:OptionButton.set_allow_reselect
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_allow_reselect, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ allow bool }{allow}))
}

//go:nosplit
func (self class) GetAllowReselect() bool { //gd:OptionButton.get_allow_reselect
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.get_allow_reselect, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
If [code]true[/code], shortcuts are disabled and cannot be used to trigger the button.
*/
//go:nosplit
func (self class) SetDisableShortcuts(disabled bool) { //gd:OptionButton.set_disable_shortcuts
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_disable_shortcuts, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ disabled bool }{disabled}))
}
func (self Instance) OnItemSelected(cb func(index int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("item_selected"), gd.NewCallable(cb), 0)
}

func (self Instance) OnItemFocused(cb func(index int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("item_focused"), gd.NewCallable(cb), 0)
}

func (self class) AsOptionButton() Advanced          { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsOptionButton() Instance       { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsOptionButton() Instance  { return self.Super().AsOptionButton() }
func (self class) AsButton() Button.Advanced         { return *((*Button.Advanced)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsButton() Button.Instance { return self.Super().AsButton() }
func (self Instance) AsButton() Button.Instance      { return *((*Button.Instance)(unsafe.Pointer(&self))) }
func (self class) AsBaseButton() BaseButton.Advanced {
	return *((*BaseButton.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsBaseButton() BaseButton.Instance { return self.Super().AsBaseButton() }
func (self Instance) AsBaseButton() BaseButton.Instance {
	return *((*BaseButton.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsControl() Control.Advanced         { return *((*Control.Advanced)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsControl() Control.Instance { return self.Super().AsControl() }
func (self Instance) AsControl() Control.Instance {
	return *((*Control.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsCanvasItem() CanvasItem.Advanced {
	return *((*CanvasItem.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsCanvasItem() CanvasItem.Instance { return self.Super().AsCanvasItem() }
func (self Instance) AsCanvasItem() CanvasItem.Instance {
	return *((*CanvasItem.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsNode() Node.Advanced         { return *((*Node.Advanced)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsNode() Node.Instance { return self.Super().AsNode() }
func (self Instance) AsNode() Node.Instance      { return *((*Node.Instance)(unsafe.Pointer(&self))) }

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Button.Advanced(self.AsButton()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Button.Instance(self.AsButton()), name)
	}
}
func init() {
	gdclass.Register("OptionButton", func(ptr gd.Object) any { return *(*Instance)(unsafe.Pointer(&ptr)) })
}
