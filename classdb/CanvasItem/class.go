// Code generated by the generate package DO NOT EDIT

// Package CanvasItem provides methods for working with CanvasItem object instances.
package CanvasItem

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/CanvasLayer"
import "graphics.gd/classdb/Font"
import "graphics.gd/classdb/GUI"
import "graphics.gd/classdb/InputEvent"
import "graphics.gd/classdb/Material"
import "graphics.gd/classdb/Mesh"
import "graphics.gd/classdb/MultiMesh"
import "graphics.gd/classdb/Node"
import "graphics.gd/classdb/TextServer"
import "graphics.gd/classdb/Texture2D"
import "graphics.gd/classdb/World2D"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Color"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/Rect2"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"
import "graphics.gd/variant/Transform2D"
import "graphics.gd/variant/Vector2"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
Abstract base class for everything in 2D space. Canvas items are laid out in a tree; children inherit and extend their parent's transform. [CanvasItem] is extended by [Control] for GUI-related nodes, and by [Node2D] for 2D game objects.
Any [CanvasItem] can draw. For this, [method queue_redraw] is called by the engine, then [constant NOTIFICATION_DRAW] will be received on idle time to request a redraw. Because of this, canvas items don't need to be redrawn on every frame, improving the performance significantly. Several functions for drawing on the [CanvasItem] are provided (see [code]draw_*[/code] functions). However, they can only be used inside [method _draw], its corresponding [method Object._notification] or methods connected to the [signal draw] signal.
Canvas items are drawn in tree order on their canvas layer. By default, children are on top of their parents, so a root [CanvasItem] will be drawn behind everything. This behavior can be changed on a per-item basis.
A [CanvasItem] can be hidden, which will also hide its children. By adjusting various other properties of a [CanvasItem], you can also modulate its color (via [member modulate] or [member self_modulate]), change its Z-index, blend mode, and more.
Note that properties like transform, modulation, and visibility are only propagated to [i]direct[/i] [CanvasItem] child nodes. If there is a non-[CanvasItem] node in between, like [Node] or [AnimationPlayer], the [CanvasItem] nodes below will have an independent position and [member modulate] chain. See also [member top_level].

	See [Interface] for methods that can be overridden by a [Class] that extends it.
*/
type Instance [1]gdclass.CanvasItem

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	get_canvas_item                         gdextension.MethodForClass `hash:"2944877500"`
	set_visible                             gdextension.MethodForClass `hash:"2586408642"`
	is_visible                              gdextension.MethodForClass `hash:"36873697"`
	is_visible_in_tree                      gdextension.MethodForClass `hash:"36873697"`
	show                                    gdextension.MethodForClass `hash:"3218959716"`
	hide                                    gdextension.MethodForClass `hash:"3218959716"`
	queue_redraw                            gdextension.MethodForClass `hash:"3218959716"`
	move_to_front                           gdextension.MethodForClass `hash:"3218959716"`
	set_as_top_level                        gdextension.MethodForClass `hash:"2586408642"`
	is_set_as_top_level                     gdextension.MethodForClass `hash:"36873697"`
	set_light_mask                          gdextension.MethodForClass `hash:"1286410249"`
	get_light_mask                          gdextension.MethodForClass `hash:"3905245786"`
	set_modulate                            gdextension.MethodForClass `hash:"2920490490"`
	get_modulate                            gdextension.MethodForClass `hash:"3444240500"`
	set_self_modulate                       gdextension.MethodForClass `hash:"2920490490"`
	get_self_modulate                       gdextension.MethodForClass `hash:"3444240500"`
	set_z_index                             gdextension.MethodForClass `hash:"1286410249"`
	get_z_index                             gdextension.MethodForClass `hash:"3905245786"`
	set_z_as_relative                       gdextension.MethodForClass `hash:"2586408642"`
	is_z_relative                           gdextension.MethodForClass `hash:"36873697"`
	set_y_sort_enabled                      gdextension.MethodForClass `hash:"2586408642"`
	is_y_sort_enabled                       gdextension.MethodForClass `hash:"36873697"`
	set_draw_behind_parent                  gdextension.MethodForClass `hash:"2586408642"`
	is_draw_behind_parent_enabled           gdextension.MethodForClass `hash:"36873697"`
	draw_line                               gdextension.MethodForClass `hash:"1562330099"`
	draw_dashed_line                        gdextension.MethodForClass `hash:"3653831622"`
	draw_polyline                           gdextension.MethodForClass `hash:"3797364428"`
	draw_polyline_colors                    gdextension.MethodForClass `hash:"2311979562"`
	draw_arc                                gdextension.MethodForClass `hash:"4140652635"`
	draw_multiline                          gdextension.MethodForClass `hash:"3797364428"`
	draw_multiline_colors                   gdextension.MethodForClass `hash:"2311979562"`
	draw_rect                               gdextension.MethodForClass `hash:"2773573813"`
	draw_circle                             gdextension.MethodForClass `hash:"3153026596"`
	draw_texture                            gdextension.MethodForClass `hash:"520200117"`
	draw_texture_rect                       gdextension.MethodForClass `hash:"3832805018"`
	draw_texture_rect_region                gdextension.MethodForClass `hash:"3883821411"`
	draw_msdf_texture_rect_region           gdextension.MethodForClass `hash:"4219163252"`
	draw_lcd_texture_rect_region            gdextension.MethodForClass `hash:"3212350954"`
	draw_style_box                          gdextension.MethodForClass `hash:"388176283"`
	draw_primitive                          gdextension.MethodForClass `hash:"3288481815"`
	draw_polygon                            gdextension.MethodForClass `hash:"974537912"`
	draw_colored_polygon                    gdextension.MethodForClass `hash:"15245644"`
	draw_string                             gdextension.MethodForClass `hash:"728290553"`
	draw_multiline_string                   gdextension.MethodForClass `hash:"1927038192"`
	draw_string_outline                     gdextension.MethodForClass `hash:"340562381"`
	draw_multiline_string_outline           gdextension.MethodForClass `hash:"1912318525"`
	draw_char                               gdextension.MethodForClass `hash:"3339793283"`
	draw_char_outline                       gdextension.MethodForClass `hash:"3302344391"`
	draw_mesh                               gdextension.MethodForClass `hash:"153818295"`
	draw_multimesh                          gdextension.MethodForClass `hash:"937992368"`
	draw_set_transform                      gdextension.MethodForClass `hash:"288975085"`
	draw_set_transform_matrix               gdextension.MethodForClass `hash:"2761652528"`
	draw_animation_slice                    gdextension.MethodForClass `hash:"3112831842"`
	draw_end_animation                      gdextension.MethodForClass `hash:"3218959716"`
	get_transform                           gdextension.MethodForClass `hash:"3814499831"`
	get_global_transform                    gdextension.MethodForClass `hash:"3814499831"`
	get_global_transform_with_canvas        gdextension.MethodForClass `hash:"3814499831"`
	get_viewport_transform                  gdextension.MethodForClass `hash:"3814499831"`
	get_viewport_rect                       gdextension.MethodForClass `hash:"1639390495"`
	get_canvas_transform                    gdextension.MethodForClass `hash:"3814499831"`
	get_screen_transform                    gdextension.MethodForClass `hash:"3814499831"`
	get_local_mouse_position                gdextension.MethodForClass `hash:"3341600327"`
	get_global_mouse_position               gdextension.MethodForClass `hash:"3341600327"`
	get_canvas                              gdextension.MethodForClass `hash:"2944877500"`
	get_canvas_layer_node                   gdextension.MethodForClass `hash:"2602762519"`
	get_world_2d                            gdextension.MethodForClass `hash:"2339128592"`
	set_material                            gdextension.MethodForClass `hash:"2757459619"`
	get_material                            gdextension.MethodForClass `hash:"5934680"`
	set_instance_shader_parameter           gdextension.MethodForClass `hash:"3776071444"`
	get_instance_shader_parameter           gdextension.MethodForClass `hash:"2760726917"`
	set_use_parent_material                 gdextension.MethodForClass `hash:"2586408642"`
	get_use_parent_material                 gdextension.MethodForClass `hash:"36873697"`
	set_notify_local_transform              gdextension.MethodForClass `hash:"2586408642"`
	is_local_transform_notification_enabled gdextension.MethodForClass `hash:"36873697"`
	set_notify_transform                    gdextension.MethodForClass `hash:"2586408642"`
	is_transform_notification_enabled       gdextension.MethodForClass `hash:"36873697"`
	force_update_transform                  gdextension.MethodForClass `hash:"3218959716"`
	make_canvas_position_local              gdextension.MethodForClass `hash:"2656412154"`
	make_input_local                        gdextension.MethodForClass `hash:"811130057"`
	set_visibility_layer                    gdextension.MethodForClass `hash:"1286410249"`
	get_visibility_layer                    gdextension.MethodForClass `hash:"3905245786"`
	set_visibility_layer_bit                gdextension.MethodForClass `hash:"300928843"`
	get_visibility_layer_bit                gdextension.MethodForClass `hash:"1116898809"`
	set_texture_filter                      gdextension.MethodForClass `hash:"1037999706"`
	get_texture_filter                      gdextension.MethodForClass `hash:"121960042"`
	set_texture_repeat                      gdextension.MethodForClass `hash:"1716472974"`
	get_texture_repeat                      gdextension.MethodForClass `hash:"2667158319"`
	set_clip_children_mode                  gdextension.MethodForClass `hash:"1319393776"`
	get_clip_children_mode                  gdextension.MethodForClass `hash:"3581808349"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("CanvasItem")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		pointers.Raw[gd.StringName](sname).Free()
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

type Expanded [1]gdclass.CanvasItem

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsCanvasItem() Instance
}
type Interface interface {
	//Called when [CanvasItem] has been requested to redraw (after [method queue_redraw] is called, either manually or by the engine).
	//Corresponds to the [constant NOTIFICATION_DRAW] notification in [method Object._notification].
	Draw()
}

// Implementation implements [Interface] with empty methods.
type Implementation = implementation

type implementation struct{}

func (self implementation) Draw() { return }

/*
Called when [CanvasItem] has been requested to redraw (after [method queue_redraw] is called, either manually or by the engine).
Corresponds to the [constant NOTIFICATION_DRAW] notification in [method Object._notification].
*/
func (Instance) _draw(impl func(ptr unsafe.Pointer)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self)
	}
}

/*
Returns the canvas item RID used by [RenderingServer] for this item.
*/
func (self Instance) GetCanvasItem() RID.CanvasItem { //gd:CanvasItem.get_canvas_item
	return RID.CanvasItem(Advanced(self).GetCanvasItem())
}

/*
Returns [code]true[/code] if the node is present in the [SceneTree], its [member visible] property is [code]true[/code] and all its ancestors are also visible. If any ancestor is hidden, this node will not be visible in the scene tree, and is therefore not drawn (see [method _draw]).
Visibility is checked only in parent nodes that inherit from [CanvasItem], [CanvasLayer], and [Window]. If the parent is of any other type (such as [Node], [AnimationPlayer], or [Node3D]), it is assumed to be visible.
[b]Note:[/b] This method does not take [member visibility_layer] into account, so even if this method returns [code]true[/code], the node might end up not being rendered.
*/
func (self Instance) IsVisibleInTree() bool { //gd:CanvasItem.is_visible_in_tree
	return bool(Advanced(self).IsVisibleInTree())
}

/*
Show the [CanvasItem] if it's currently hidden. This is equivalent to setting [member visible] to [code]true[/code]. For controls that inherit [Popup], the correct way to make them visible is to call one of the multiple [code]popup*()[/code] functions instead.
*/
func (self Instance) Show() { //gd:CanvasItem.show
	Advanced(self).Show()
}

/*
Hide the [CanvasItem] if it's currently visible. This is equivalent to setting [member visible] to [code]false[/code].
*/
func (self Instance) Hide() { //gd:CanvasItem.hide
	Advanced(self).Hide()
}

/*
Queues the [CanvasItem] to redraw. During idle time, if [CanvasItem] is visible, [constant NOTIFICATION_DRAW] is sent and [method _draw] is called. This only occurs [b]once[/b] per frame, even if this method has been called multiple times.
*/
func (self Instance) QueueRedraw() { //gd:CanvasItem.queue_redraw
	Advanced(self).QueueRedraw()
}

/*
Moves this node to display on top of its siblings.
Internally, the node is moved to the bottom of parent's child list. The method has no effect on nodes without a parent.
*/
func (self Instance) MoveToFront() { //gd:CanvasItem.move_to_front
	Advanced(self).MoveToFront()
}

/*
Draws a line from a 2D point to another, with a given color and width. It can be optionally antialiased. See also [method draw_dashed_line], [method draw_multiline], and [method draw_polyline].
If [param width] is negative, then a two-point primitive will be drawn instead of a four-point one. This means that when the CanvasItem is scaled, the line will remain thin. If this behavior is not desired, then pass a positive [param width] like [code]1.0[/code].
*/
func (self Instance) DrawLine(from Vector2.XY, to Vector2.XY, color Color.RGBA) { //gd:CanvasItem.draw_line
	Advanced(self).DrawLine(Vector2.XY(from), Vector2.XY(to), Color.RGBA(color), float64(-1.0), false)
}

/*
Draws a line from a 2D point to another, with a given color and width. It can be optionally antialiased. See also [method draw_dashed_line], [method draw_multiline], and [method draw_polyline].
If [param width] is negative, then a two-point primitive will be drawn instead of a four-point one. This means that when the CanvasItem is scaled, the line will remain thin. If this behavior is not desired, then pass a positive [param width] like [code]1.0[/code].
*/
func (self Expanded) DrawLine(from Vector2.XY, to Vector2.XY, color Color.RGBA, width Float.X, antialiased bool) { //gd:CanvasItem.draw_line
	Advanced(self).DrawLine(Vector2.XY(from), Vector2.XY(to), Color.RGBA(color), float64(width), antialiased)
}

/*
Draws a dashed line from a 2D point to another, with a given color and width. See also [method draw_line], [method draw_multiline], and [method draw_polyline].
If [param width] is negative, then a two-point primitives will be drawn instead of a four-point ones. This means that when the CanvasItem is scaled, the line parts will remain thin. If this behavior is not desired, then pass a positive [param width] like [code]1.0[/code].
[param dash] is the length of each dash in pixels, with the gap between each dash being the same length. If [param aligned] is [code]true[/code], the length of the first and last dashes may be shortened or lengthened to allow the line to begin and end at the precise points defined by [param from] and [param to]. Both ends are always symmetrical when [param aligned] is [code]true[/code]. If [param aligned] is [code]false[/code], all dashes will have the same length, but the line may appear incomplete at the end due to the dash length not dividing evenly into the line length. Only full dashes are drawn when [param aligned] is [code]false[/code].
If [param antialiased] is [code]true[/code], half transparent "feathers" will be attached to the boundary, making outlines smooth.
[b]Note:[/b] [param antialiased] is only effective if [param width] is greater than [code]0.0[/code].
*/
func (self Instance) DrawDashedLine(from Vector2.XY, to Vector2.XY, color Color.RGBA) { //gd:CanvasItem.draw_dashed_line
	Advanced(self).DrawDashedLine(Vector2.XY(from), Vector2.XY(to), Color.RGBA(color), float64(-1.0), float64(2.0), true, false)
}

/*
Draws a dashed line from a 2D point to another, with a given color and width. See also [method draw_line], [method draw_multiline], and [method draw_polyline].
If [param width] is negative, then a two-point primitives will be drawn instead of a four-point ones. This means that when the CanvasItem is scaled, the line parts will remain thin. If this behavior is not desired, then pass a positive [param width] like [code]1.0[/code].
[param dash] is the length of each dash in pixels, with the gap between each dash being the same length. If [param aligned] is [code]true[/code], the length of the first and last dashes may be shortened or lengthened to allow the line to begin and end at the precise points defined by [param from] and [param to]. Both ends are always symmetrical when [param aligned] is [code]true[/code]. If [param aligned] is [code]false[/code], all dashes will have the same length, but the line may appear incomplete at the end due to the dash length not dividing evenly into the line length. Only full dashes are drawn when [param aligned] is [code]false[/code].
If [param antialiased] is [code]true[/code], half transparent "feathers" will be attached to the boundary, making outlines smooth.
[b]Note:[/b] [param antialiased] is only effective if [param width] is greater than [code]0.0[/code].
*/
func (self Expanded) DrawDashedLine(from Vector2.XY, to Vector2.XY, color Color.RGBA, width Float.X, dash Float.X, aligned bool, antialiased bool) { //gd:CanvasItem.draw_dashed_line
	Advanced(self).DrawDashedLine(Vector2.XY(from), Vector2.XY(to), Color.RGBA(color), float64(width), float64(dash), aligned, antialiased)
}

/*
Draws interconnected line segments with a uniform [param color] and [param width] and optional antialiasing (supported only for positive [param width]). When drawing large amounts of lines, this is faster than using individual [method draw_line] calls. To draw disconnected lines, use [method draw_multiline] instead. See also [method draw_polygon].
If [param width] is negative, it will be ignored and the polyline will be drawn using [constant RenderingServer.PRIMITIVE_LINE_STRIP]. This means that when the CanvasItem is scaled, the polyline will remain thin. If this behavior is not desired, then pass a positive [param width] like [code]1.0[/code].
*/
func (self Instance) DrawPolyline(points []Vector2.XY, color Color.RGBA) { //gd:CanvasItem.draw_polyline
	Advanced(self).DrawPolyline(Packed.New(points...), Color.RGBA(color), float64(-1.0), false)
}

/*
Draws interconnected line segments with a uniform [param color] and [param width] and optional antialiasing (supported only for positive [param width]). When drawing large amounts of lines, this is faster than using individual [method draw_line] calls. To draw disconnected lines, use [method draw_multiline] instead. See also [method draw_polygon].
If [param width] is negative, it will be ignored and the polyline will be drawn using [constant RenderingServer.PRIMITIVE_LINE_STRIP]. This means that when the CanvasItem is scaled, the polyline will remain thin. If this behavior is not desired, then pass a positive [param width] like [code]1.0[/code].
*/
func (self Expanded) DrawPolyline(points []Vector2.XY, color Color.RGBA, width Float.X, antialiased bool) { //gd:CanvasItem.draw_polyline
	Advanced(self).DrawPolyline(Packed.New(points...), Color.RGBA(color), float64(width), antialiased)
}

/*
Draws interconnected line segments with a uniform [param width], point-by-point coloring, and optional antialiasing (supported only for positive [param width]). Colors assigned to line points match by index between [param points] and [param colors], i.e. each line segment is filled with a gradient between the colors of the endpoints. When drawing large amounts of lines, this is faster than using individual [method draw_line] calls. To draw disconnected lines, use [method draw_multiline_colors] instead. See also [method draw_polygon].
If [param width] is negative, it will be ignored and the polyline will be drawn using [constant RenderingServer.PRIMITIVE_LINE_STRIP]. This means that when the CanvasItem is scaled, the polyline will remain thin. If this behavior is not desired, then pass a positive [param width] like [code]1.0[/code].
*/
func (self Instance) DrawPolylineColors(points []Vector2.XY, colors []Color.RGBA) { //gd:CanvasItem.draw_polyline_colors
	Advanced(self).DrawPolylineColors(Packed.New(points...), Packed.New(colors...), float64(-1.0), false)
}

/*
Draws interconnected line segments with a uniform [param width], point-by-point coloring, and optional antialiasing (supported only for positive [param width]). Colors assigned to line points match by index between [param points] and [param colors], i.e. each line segment is filled with a gradient between the colors of the endpoints. When drawing large amounts of lines, this is faster than using individual [method draw_line] calls. To draw disconnected lines, use [method draw_multiline_colors] instead. See also [method draw_polygon].
If [param width] is negative, it will be ignored and the polyline will be drawn using [constant RenderingServer.PRIMITIVE_LINE_STRIP]. This means that when the CanvasItem is scaled, the polyline will remain thin. If this behavior is not desired, then pass a positive [param width] like [code]1.0[/code].
*/
func (self Expanded) DrawPolylineColors(points []Vector2.XY, colors []Color.RGBA, width Float.X, antialiased bool) { //gd:CanvasItem.draw_polyline_colors
	Advanced(self).DrawPolylineColors(Packed.New(points...), Packed.New(colors...), float64(width), antialiased)
}

/*
Draws an unfilled arc between the given angles with a uniform [param color] and [param width] and optional antialiasing (supported only for positive [param width]). The larger the value of [param point_count], the smoother the curve. See also [method draw_circle].
If [param width] is negative, it will be ignored and the arc will be drawn using [constant RenderingServer.PRIMITIVE_LINE_STRIP]. This means that when the CanvasItem is scaled, the arc will remain thin. If this behavior is not desired, then pass a positive [param width] like [code]1.0[/code].
The arc is drawn from [param start_angle] towards the value of [param end_angle] so in clockwise direction if [code]start_angle < end_angle[/code] and counter-clockwise otherwise. Passing the same angles but in reversed order will produce the same arc. If absolute difference of [param start_angle] and [param end_angle] is greater than [constant @GDScript.TAU] radians, then a full circle arc is drawn (i.e. arc will not overlap itself).
*/
func (self Instance) DrawArc(center Vector2.XY, radius Float.X, start_angle Angle.Radians, end_angle Angle.Radians, point_count int, color Color.RGBA) { //gd:CanvasItem.draw_arc
	Advanced(self).DrawArc(Vector2.XY(center), float64(radius), float64(start_angle), float64(end_angle), int64(point_count), Color.RGBA(color), float64(-1.0), false)
}

/*
Draws an unfilled arc between the given angles with a uniform [param color] and [param width] and optional antialiasing (supported only for positive [param width]). The larger the value of [param point_count], the smoother the curve. See also [method draw_circle].
If [param width] is negative, it will be ignored and the arc will be drawn using [constant RenderingServer.PRIMITIVE_LINE_STRIP]. This means that when the CanvasItem is scaled, the arc will remain thin. If this behavior is not desired, then pass a positive [param width] like [code]1.0[/code].
The arc is drawn from [param start_angle] towards the value of [param end_angle] so in clockwise direction if [code]start_angle < end_angle[/code] and counter-clockwise otherwise. Passing the same angles but in reversed order will produce the same arc. If absolute difference of [param start_angle] and [param end_angle] is greater than [constant @GDScript.TAU] radians, then a full circle arc is drawn (i.e. arc will not overlap itself).
*/
func (self Expanded) DrawArc(center Vector2.XY, radius Float.X, start_angle Angle.Radians, end_angle Angle.Radians, point_count int, color Color.RGBA, width Float.X, antialiased bool) { //gd:CanvasItem.draw_arc
	Advanced(self).DrawArc(Vector2.XY(center), float64(radius), float64(start_angle), float64(end_angle), int64(point_count), Color.RGBA(color), float64(width), antialiased)
}

/*
Draws multiple disconnected lines with a uniform [param width] and [param color]. Each line is defined by two consecutive points from [param points] array, i.e. i-th segment consists of [code]points[2 * i][/code], [code]points[2 * i + 1][/code] endpoints. When drawing large amounts of lines, this is faster than using individual [method draw_line] calls. To draw interconnected lines, use [method draw_polyline] instead.
If [param width] is negative, then two-point primitives will be drawn instead of a four-point ones. This means that when the CanvasItem is scaled, the lines will remain thin. If this behavior is not desired, then pass a positive [param width] like [code]1.0[/code].
[b]Note:[/b] [param antialiased] is only effective if [param width] is greater than [code]0.0[/code].
*/
func (self Instance) DrawMultiline(points []Vector2.XY, color Color.RGBA) { //gd:CanvasItem.draw_multiline
	Advanced(self).DrawMultiline(Packed.New(points...), Color.RGBA(color), float64(-1.0), false)
}

/*
Draws multiple disconnected lines with a uniform [param width] and [param color]. Each line is defined by two consecutive points from [param points] array, i.e. i-th segment consists of [code]points[2 * i][/code], [code]points[2 * i + 1][/code] endpoints. When drawing large amounts of lines, this is faster than using individual [method draw_line] calls. To draw interconnected lines, use [method draw_polyline] instead.
If [param width] is negative, then two-point primitives will be drawn instead of a four-point ones. This means that when the CanvasItem is scaled, the lines will remain thin. If this behavior is not desired, then pass a positive [param width] like [code]1.0[/code].
[b]Note:[/b] [param antialiased] is only effective if [param width] is greater than [code]0.0[/code].
*/
func (self Expanded) DrawMultiline(points []Vector2.XY, color Color.RGBA, width Float.X, antialiased bool) { //gd:CanvasItem.draw_multiline
	Advanced(self).DrawMultiline(Packed.New(points...), Color.RGBA(color), float64(width), antialiased)
}

/*
Draws multiple disconnected lines with a uniform [param width] and segment-by-segment coloring. Each segment is defined by two consecutive points from [param points] array and a corresponding color from [param colors] array, i.e. i-th segment consists of [code]points[2 * i][/code], [code]points[2 * i + 1][/code] endpoints and has [code]colors[i][/code] color. When drawing large amounts of lines, this is faster than using individual [method draw_line] calls. To draw interconnected lines, use [method draw_polyline_colors] instead.
If [param width] is negative, then two-point primitives will be drawn instead of a four-point ones. This means that when the CanvasItem is scaled, the lines will remain thin. If this behavior is not desired, then pass a positive [param width] like [code]1.0[/code].
[b]Note:[/b] [param antialiased] is only effective if [param width] is greater than [code]0.0[/code].
*/
func (self Instance) DrawMultilineColors(points []Vector2.XY, colors []Color.RGBA) { //gd:CanvasItem.draw_multiline_colors
	Advanced(self).DrawMultilineColors(Packed.New(points...), Packed.New(colors...), float64(-1.0), false)
}

/*
Draws multiple disconnected lines with a uniform [param width] and segment-by-segment coloring. Each segment is defined by two consecutive points from [param points] array and a corresponding color from [param colors] array, i.e. i-th segment consists of [code]points[2 * i][/code], [code]points[2 * i + 1][/code] endpoints and has [code]colors[i][/code] color. When drawing large amounts of lines, this is faster than using individual [method draw_line] calls. To draw interconnected lines, use [method draw_polyline_colors] instead.
If [param width] is negative, then two-point primitives will be drawn instead of a four-point ones. This means that when the CanvasItem is scaled, the lines will remain thin. If this behavior is not desired, then pass a positive [param width] like [code]1.0[/code].
[b]Note:[/b] [param antialiased] is only effective if [param width] is greater than [code]0.0[/code].
*/
func (self Expanded) DrawMultilineColors(points []Vector2.XY, colors []Color.RGBA, width Float.X, antialiased bool) { //gd:CanvasItem.draw_multiline_colors
	Advanced(self).DrawMultilineColors(Packed.New(points...), Packed.New(colors...), float64(width), antialiased)
}

/*
Draws a rectangle. If [param filled] is [code]true[/code], the rectangle will be filled with the [param color] specified. If [param filled] is [code]false[/code], the rectangle will be drawn as a stroke with the [param color] and [param width] specified. See also [method draw_texture_rect].
If [param width] is negative, then two-point primitives will be drawn instead of a four-point ones. This means that when the CanvasItem is scaled, the lines will remain thin. If this behavior is not desired, then pass a positive [param width] like [code]1.0[/code].
If [param antialiased] is [code]true[/code], half transparent "feathers" will be attached to the boundary, making outlines smooth.
[b]Note:[/b] [param width] is only effective if [param filled] is [code]false[/code].
[b]Note:[/b] Unfilled rectangles drawn with a negative [param width] may not display perfectly. For example, corners may be missing or brighter due to overlapping lines (for a translucent [param color]).
*/
func (self Instance) DrawRect(rect Rect2.PositionSize, color Color.RGBA) { //gd:CanvasItem.draw_rect
	Advanced(self).DrawRect(Rect2.PositionSize(rect), Color.RGBA(color), true, float64(-1.0), false)
}

/*
Draws a rectangle. If [param filled] is [code]true[/code], the rectangle will be filled with the [param color] specified. If [param filled] is [code]false[/code], the rectangle will be drawn as a stroke with the [param color] and [param width] specified. See also [method draw_texture_rect].
If [param width] is negative, then two-point primitives will be drawn instead of a four-point ones. This means that when the CanvasItem is scaled, the lines will remain thin. If this behavior is not desired, then pass a positive [param width] like [code]1.0[/code].
If [param antialiased] is [code]true[/code], half transparent "feathers" will be attached to the boundary, making outlines smooth.
[b]Note:[/b] [param width] is only effective if [param filled] is [code]false[/code].
[b]Note:[/b] Unfilled rectangles drawn with a negative [param width] may not display perfectly. For example, corners may be missing or brighter due to overlapping lines (for a translucent [param color]).
*/
func (self Expanded) DrawRect(rect Rect2.PositionSize, color Color.RGBA, filled bool, width Float.X, antialiased bool) { //gd:CanvasItem.draw_rect
	Advanced(self).DrawRect(Rect2.PositionSize(rect), Color.RGBA(color), filled, float64(width), antialiased)
}

/*
Draws a circle. See also [method draw_arc], [method draw_polyline], and [method draw_polygon].
If [param filled] is [code]true[/code], the circle will be filled with the [param color] specified. If [param filled] is [code]false[/code], the circle will be drawn as a stroke with the [param color] and [param width] specified.
If [param width] is negative, then two-point primitives will be drawn instead of a four-point ones. This means that when the CanvasItem is scaled, the lines will remain thin. If this behavior is not desired, then pass a positive [param width] like [code]1.0[/code].
If [param antialiased] is [code]true[/code], half transparent "feathers" will be attached to the boundary, making outlines smooth.
[b]Note:[/b] [param width] is only effective if [param filled] is [code]false[/code].
*/
func (self Instance) DrawCircle(position Vector2.XY, radius Float.X, color Color.RGBA) { //gd:CanvasItem.draw_circle
	Advanced(self).DrawCircle(Vector2.XY(position), float64(radius), Color.RGBA(color), true, float64(-1.0), false)
}

/*
Draws a circle. See also [method draw_arc], [method draw_polyline], and [method draw_polygon].
If [param filled] is [code]true[/code], the circle will be filled with the [param color] specified. If [param filled] is [code]false[/code], the circle will be drawn as a stroke with the [param color] and [param width] specified.
If [param width] is negative, then two-point primitives will be drawn instead of a four-point ones. This means that when the CanvasItem is scaled, the lines will remain thin. If this behavior is not desired, then pass a positive [param width] like [code]1.0[/code].
If [param antialiased] is [code]true[/code], half transparent "feathers" will be attached to the boundary, making outlines smooth.
[b]Note:[/b] [param width] is only effective if [param filled] is [code]false[/code].
*/
func (self Expanded) DrawCircle(position Vector2.XY, radius Float.X, color Color.RGBA, filled bool, width Float.X, antialiased bool) { //gd:CanvasItem.draw_circle
	Advanced(self).DrawCircle(Vector2.XY(position), float64(radius), Color.RGBA(color), filled, float64(width), antialiased)
}

/*
Draws a texture at a given position.
*/
func (self Instance) DrawTexture(texture Texture2D.Instance, position Vector2.XY) { //gd:CanvasItem.draw_texture
	Advanced(self).DrawTexture(texture, Vector2.XY(position), Color.RGBA(gd.Color{1, 1, 1, 1}))
}

/*
Draws a texture at a given position.
*/
func (self Expanded) DrawTexture(texture Texture2D.Instance, position Vector2.XY, modulate Color.RGBA) { //gd:CanvasItem.draw_texture
	Advanced(self).DrawTexture(texture, Vector2.XY(position), Color.RGBA(modulate))
}

/*
Draws a textured rectangle at a given position, optionally modulated by a color. If [param transpose] is [code]true[/code], the texture will have its X and Y coordinates swapped. See also [method draw_rect] and [method draw_texture_rect_region].
*/
func (self Instance) DrawTextureRect(texture Texture2D.Instance, rect Rect2.PositionSize, tile bool) { //gd:CanvasItem.draw_texture_rect
	Advanced(self).DrawTextureRect(texture, Rect2.PositionSize(rect), tile, Color.RGBA(gd.Color{1, 1, 1, 1}), false)
}

/*
Draws a textured rectangle at a given position, optionally modulated by a color. If [param transpose] is [code]true[/code], the texture will have its X and Y coordinates swapped. See also [method draw_rect] and [method draw_texture_rect_region].
*/
func (self Expanded) DrawTextureRect(texture Texture2D.Instance, rect Rect2.PositionSize, tile bool, modulate Color.RGBA, transpose bool) { //gd:CanvasItem.draw_texture_rect
	Advanced(self).DrawTextureRect(texture, Rect2.PositionSize(rect), tile, Color.RGBA(modulate), transpose)
}

/*
Draws a textured rectangle from a texture's region (specified by [param src_rect]) at a given position, optionally modulated by a color. If [param transpose] is [code]true[/code], the texture will have its X and Y coordinates swapped. See also [method draw_texture_rect].
*/
func (self Instance) DrawTextureRectRegion(texture Texture2D.Instance, rect Rect2.PositionSize, src_rect Rect2.PositionSize) { //gd:CanvasItem.draw_texture_rect_region
	Advanced(self).DrawTextureRectRegion(texture, Rect2.PositionSize(rect), Rect2.PositionSize(src_rect), Color.RGBA(gd.Color{1, 1, 1, 1}), false, true)
}

/*
Draws a textured rectangle from a texture's region (specified by [param src_rect]) at a given position, optionally modulated by a color. If [param transpose] is [code]true[/code], the texture will have its X and Y coordinates swapped. See also [method draw_texture_rect].
*/
func (self Expanded) DrawTextureRectRegion(texture Texture2D.Instance, rect Rect2.PositionSize, src_rect Rect2.PositionSize, modulate Color.RGBA, transpose bool, clip_uv bool) { //gd:CanvasItem.draw_texture_rect_region
	Advanced(self).DrawTextureRectRegion(texture, Rect2.PositionSize(rect), Rect2.PositionSize(src_rect), Color.RGBA(modulate), transpose, clip_uv)
}

/*
Draws a textured rectangle region of the multi-channel signed distance field texture at a given position, optionally modulated by a color. See [member FontFile.multichannel_signed_distance_field] for more information and caveats about MSDF font rendering.
If [param outline] is positive, each alpha channel value of pixel in region is set to maximum value of true distance in the [param outline] radius.
Value of the [param pixel_range] should the same that was used during distance field texture generation.
*/
func (self Instance) DrawMsdfTextureRectRegion(texture Texture2D.Instance, rect Rect2.PositionSize, src_rect Rect2.PositionSize) { //gd:CanvasItem.draw_msdf_texture_rect_region
	Advanced(self).DrawMsdfTextureRectRegion(texture, Rect2.PositionSize(rect), Rect2.PositionSize(src_rect), Color.RGBA(gd.Color{1, 1, 1, 1}), float64(0.0), float64(4.0), float64(1.0))
}

/*
Draws a textured rectangle region of the multi-channel signed distance field texture at a given position, optionally modulated by a color. See [member FontFile.multichannel_signed_distance_field] for more information and caveats about MSDF font rendering.
If [param outline] is positive, each alpha channel value of pixel in region is set to maximum value of true distance in the [param outline] radius.
Value of the [param pixel_range] should the same that was used during distance field texture generation.
*/
func (self Expanded) DrawMsdfTextureRectRegion(texture Texture2D.Instance, rect Rect2.PositionSize, src_rect Rect2.PositionSize, modulate Color.RGBA, outline Float.X, pixel_range Float.X, scale Float.X) { //gd:CanvasItem.draw_msdf_texture_rect_region
	Advanced(self).DrawMsdfTextureRectRegion(texture, Rect2.PositionSize(rect), Rect2.PositionSize(src_rect), Color.RGBA(modulate), float64(outline), float64(pixel_range), float64(scale))
}

/*
Draws a textured rectangle region of the font texture with LCD subpixel anti-aliasing at a given position, optionally modulated by a color.
Texture is drawn using the following blend operation, blend mode of the [CanvasItemMaterial] is ignored:
[codeblock]
dst.r = texture.r * modulate.r * modulate.a + dst.r * (1.0 - texture.r * modulate.a);
dst.g = texture.g * modulate.g * modulate.a + dst.g * (1.0 - texture.g * modulate.a);
dst.b = texture.b * modulate.b * modulate.a + dst.b * (1.0 - texture.b * modulate.a);
dst.a = modulate.a + dst.a * (1.0 - modulate.a);
[/codeblock]
*/
func (self Instance) DrawLcdTextureRectRegion(texture Texture2D.Instance, rect Rect2.PositionSize, src_rect Rect2.PositionSize) { //gd:CanvasItem.draw_lcd_texture_rect_region
	Advanced(self).DrawLcdTextureRectRegion(texture, Rect2.PositionSize(rect), Rect2.PositionSize(src_rect), Color.RGBA(gd.Color{1, 1, 1, 1}))
}

/*
Draws a textured rectangle region of the font texture with LCD subpixel anti-aliasing at a given position, optionally modulated by a color.
Texture is drawn using the following blend operation, blend mode of the [CanvasItemMaterial] is ignored:
[codeblock]
dst.r = texture.r * modulate.r * modulate.a + dst.r * (1.0 - texture.r * modulate.a);
dst.g = texture.g * modulate.g * modulate.a + dst.g * (1.0 - texture.g * modulate.a);
dst.b = texture.b * modulate.b * modulate.a + dst.b * (1.0 - texture.b * modulate.a);
dst.a = modulate.a + dst.a * (1.0 - modulate.a);
[/codeblock]
*/
func (self Expanded) DrawLcdTextureRectRegion(texture Texture2D.Instance, rect Rect2.PositionSize, src_rect Rect2.PositionSize, modulate Color.RGBA) { //gd:CanvasItem.draw_lcd_texture_rect_region
	Advanced(self).DrawLcdTextureRectRegion(texture, Rect2.PositionSize(rect), Rect2.PositionSize(src_rect), Color.RGBA(modulate))
}

/*
Draws a custom primitive. 1 point for a point, 2 points for a line, 3 points for a triangle, and 4 points for a quad. If 0 points or more than 4 points are specified, nothing will be drawn and an error message will be printed. See also [method draw_line], [method draw_polyline], [method draw_polygon], and [method draw_rect].
*/
func (self Instance) DrawPrimitive(points []Vector2.XY, colors []Color.RGBA, uvs []Vector2.XY) { //gd:CanvasItem.draw_primitive
	Advanced(self).DrawPrimitive(Packed.New(points...), Packed.New(colors...), Packed.New(uvs...), [1]Texture2D.Instance{}[0])
}

/*
Draws a custom primitive. 1 point for a point, 2 points for a line, 3 points for a triangle, and 4 points for a quad. If 0 points or more than 4 points are specified, nothing will be drawn and an error message will be printed. See also [method draw_line], [method draw_polyline], [method draw_polygon], and [method draw_rect].
*/
func (self Expanded) DrawPrimitive(points []Vector2.XY, colors []Color.RGBA, uvs []Vector2.XY, texture Texture2D.Instance) { //gd:CanvasItem.draw_primitive
	Advanced(self).DrawPrimitive(Packed.New(points...), Packed.New(colors...), Packed.New(uvs...), texture)
}

/*
Draws a solid polygon of any number of points, convex or concave. Unlike [method draw_colored_polygon], each point's color can be changed individually. See also [method draw_polyline] and [method draw_polyline_colors]. If you need more flexibility (such as being able to use bones), use [method RenderingServer.canvas_item_add_triangle_array] instead.
[b]Note:[/b] If you frequently redraw the same polygon with a large number of vertices, consider pre-calculating the triangulation with [method Geometry2D.triangulate_polygon] and using [method draw_mesh], [method draw_multimesh], or [method RenderingServer.canvas_item_add_triangle_array].
*/
func (self Instance) DrawPolygon(points []Vector2.XY, colors []Color.RGBA) { //gd:CanvasItem.draw_polygon
	Advanced(self).DrawPolygon(Packed.New(points...), Packed.New(colors...), Packed.New[Vector2.XY](), [1]Texture2D.Instance{}[0])
}

/*
Draws a solid polygon of any number of points, convex or concave. Unlike [method draw_colored_polygon], each point's color can be changed individually. See also [method draw_polyline] and [method draw_polyline_colors]. If you need more flexibility (such as being able to use bones), use [method RenderingServer.canvas_item_add_triangle_array] instead.
[b]Note:[/b] If you frequently redraw the same polygon with a large number of vertices, consider pre-calculating the triangulation with [method Geometry2D.triangulate_polygon] and using [method draw_mesh], [method draw_multimesh], or [method RenderingServer.canvas_item_add_triangle_array].
*/
func (self Expanded) DrawPolygon(points []Vector2.XY, colors []Color.RGBA, uvs []Vector2.XY, texture Texture2D.Instance) { //gd:CanvasItem.draw_polygon
	Advanced(self).DrawPolygon(Packed.New(points...), Packed.New(colors...), Packed.New(uvs...), texture)
}

/*
Draws a colored polygon of any number of points, convex or concave. Unlike [method draw_polygon], a single color must be specified for the whole polygon.
[b]Note:[/b] If you frequently redraw the same polygon with a large number of vertices, consider pre-calculating the triangulation with [method Geometry2D.triangulate_polygon] and using [method draw_mesh], [method draw_multimesh], or [method RenderingServer.canvas_item_add_triangle_array].
*/
func (self Instance) DrawColoredPolygon(points []Vector2.XY, color Color.RGBA) { //gd:CanvasItem.draw_colored_polygon
	Advanced(self).DrawColoredPolygon(Packed.New(points...), Color.RGBA(color), Packed.New[Vector2.XY](), [1]Texture2D.Instance{}[0])
}

/*
Draws a colored polygon of any number of points, convex or concave. Unlike [method draw_polygon], a single color must be specified for the whole polygon.
[b]Note:[/b] If you frequently redraw the same polygon with a large number of vertices, consider pre-calculating the triangulation with [method Geometry2D.triangulate_polygon] and using [method draw_mesh], [method draw_multimesh], or [method RenderingServer.canvas_item_add_triangle_array].
*/
func (self Expanded) DrawColoredPolygon(points []Vector2.XY, color Color.RGBA, uvs []Vector2.XY, texture Texture2D.Instance) { //gd:CanvasItem.draw_colored_polygon
	Advanced(self).DrawColoredPolygon(Packed.New(points...), Color.RGBA(color), Packed.New(uvs...), texture)
}

/*
Draws [param text] using the specified [param font] at the [param pos] (bottom-left corner using the baseline of the font). The text will have its color multiplied by [param modulate]. If [param width] is greater than or equal to 0, the text will be clipped if it exceeds the specified width.
[b]Example:[/b] Draw "Hello world", using the project's default font:
[codeblocks]
[gdscript]
# If using this method in a script that redraws constantly, move the
# `default_font` declaration to a member variable assigned in `_ready()`
# so the Control is only created once.
var default_font = ThemeDB.fallback_font
var default_font_size = ThemeDB.fallback_font_size
draw_string(default_font, Vector2(64, 64), "Hello world", HORIZONTAL_ALIGNMENT_LEFT, -1, default_font_size)
[/gdscript]
[csharp]
// If using this method in a script that redraws constantly, move the
// `default_font` declaration to a member variable assigned in `_Ready()`
// so the Control is only created once.
Font defaultFont = ThemeDB.FallbackFont;
int defaultFontSize = ThemeDB.FallbackFontSize;
DrawString(defaultFont, new Vector2(64, 64), "Hello world", HORIZONTAL_ALIGNMENT_LEFT, -1, defaultFontSize);
[/csharp]
[/codeblocks]
See also [method Font.draw_string].
*/
func (self Instance) DrawString(font Font.Instance, pos Vector2.XY, text string) { //gd:CanvasItem.draw_string
	Advanced(self).DrawString(font, Vector2.XY(pos), String.New(text), 0, float64(-1), int64(16), Color.RGBA(gd.Color{1, 1, 1, 1}), 3, 0, 0)
}

/*
Draws [param text] using the specified [param font] at the [param pos] (bottom-left corner using the baseline of the font). The text will have its color multiplied by [param modulate]. If [param width] is greater than or equal to 0, the text will be clipped if it exceeds the specified width.
[b]Example:[/b] Draw "Hello world", using the project's default font:
[codeblocks]
[gdscript]
# If using this method in a script that redraws constantly, move the
# `default_font` declaration to a member variable assigned in `_ready()`
# so the Control is only created once.
var default_font = ThemeDB.fallback_font
var default_font_size = ThemeDB.fallback_font_size
draw_string(default_font, Vector2(64, 64), "Hello world", HORIZONTAL_ALIGNMENT_LEFT, -1, default_font_size)
[/gdscript]
[csharp]
// If using this method in a script that redraws constantly, move the
// `default_font` declaration to a member variable assigned in `_Ready()`
// so the Control is only created once.
Font defaultFont = ThemeDB.FallbackFont;
int defaultFontSize = ThemeDB.FallbackFontSize;
DrawString(defaultFont, new Vector2(64, 64), "Hello world", HORIZONTAL_ALIGNMENT_LEFT, -1, defaultFontSize);
[/csharp]
[/codeblocks]
See also [method Font.draw_string].
*/
func (self Expanded) DrawString(font Font.Instance, pos Vector2.XY, text string, alignment GUI.HorizontalAlignment, width Float.X, font_size int, modulate Color.RGBA, justification_flags TextServer.JustificationFlag, direction TextServer.Direction, orientation TextServer.Orientation) { //gd:CanvasItem.draw_string
	Advanced(self).DrawString(font, Vector2.XY(pos), String.New(text), alignment, float64(width), int64(font_size), Color.RGBA(modulate), justification_flags, direction, orientation)
}

/*
Breaks [param text] into lines and draws it using the specified [param font] at the [param pos] (top-left corner). The text will have its color multiplied by [param modulate]. If [param width] is greater than or equal to 0, the text will be clipped if it exceeds the specified width.
*/
func (self Instance) DrawMultilineString(font Font.Instance, pos Vector2.XY, text string) { //gd:CanvasItem.draw_multiline_string
	Advanced(self).DrawMultilineString(font, Vector2.XY(pos), String.New(text), 0, float64(-1), int64(16), int64(-1), Color.RGBA(gd.Color{1, 1, 1, 1}), 3, 3, 0, 0)
}

/*
Breaks [param text] into lines and draws it using the specified [param font] at the [param pos] (top-left corner). The text will have its color multiplied by [param modulate]. If [param width] is greater than or equal to 0, the text will be clipped if it exceeds the specified width.
*/
func (self Expanded) DrawMultilineString(font Font.Instance, pos Vector2.XY, text string, alignment GUI.HorizontalAlignment, width Float.X, font_size int, max_lines int, modulate Color.RGBA, brk_flags TextServer.LineBreakFlag, justification_flags TextServer.JustificationFlag, direction TextServer.Direction, orientation TextServer.Orientation) { //gd:CanvasItem.draw_multiline_string
	Advanced(self).DrawMultilineString(font, Vector2.XY(pos), String.New(text), alignment, float64(width), int64(font_size), int64(max_lines), Color.RGBA(modulate), brk_flags, justification_flags, direction, orientation)
}

/*
Draws [param text] outline using the specified [param font] at the [param pos] (bottom-left corner using the baseline of the font). The text will have its color multiplied by [param modulate]. If [param width] is greater than or equal to 0, the text will be clipped if it exceeds the specified width.
*/
func (self Instance) DrawStringOutline(font Font.Instance, pos Vector2.XY, text string) { //gd:CanvasItem.draw_string_outline
	Advanced(self).DrawStringOutline(font, Vector2.XY(pos), String.New(text), 0, float64(-1), int64(16), int64(1), Color.RGBA(gd.Color{1, 1, 1, 1}), 3, 0, 0)
}

/*
Draws [param text] outline using the specified [param font] at the [param pos] (bottom-left corner using the baseline of the font). The text will have its color multiplied by [param modulate]. If [param width] is greater than or equal to 0, the text will be clipped if it exceeds the specified width.
*/
func (self Expanded) DrawStringOutline(font Font.Instance, pos Vector2.XY, text string, alignment GUI.HorizontalAlignment, width Float.X, font_size int, size int, modulate Color.RGBA, justification_flags TextServer.JustificationFlag, direction TextServer.Direction, orientation TextServer.Orientation) { //gd:CanvasItem.draw_string_outline
	Advanced(self).DrawStringOutline(font, Vector2.XY(pos), String.New(text), alignment, float64(width), int64(font_size), int64(size), Color.RGBA(modulate), justification_flags, direction, orientation)
}

/*
Breaks [param text] to the lines and draws text outline using the specified [param font] at the [param pos] (top-left corner). The text will have its color multiplied by [param modulate]. If [param width] is greater than or equal to 0, the text will be clipped if it exceeds the specified width.
*/
func (self Instance) DrawMultilineStringOutline(font Font.Instance, pos Vector2.XY, text string) { //gd:CanvasItem.draw_multiline_string_outline
	Advanced(self).DrawMultilineStringOutline(font, Vector2.XY(pos), String.New(text), 0, float64(-1), int64(16), int64(-1), int64(1), Color.RGBA(gd.Color{1, 1, 1, 1}), 3, 3, 0, 0)
}

/*
Breaks [param text] to the lines and draws text outline using the specified [param font] at the [param pos] (top-left corner). The text will have its color multiplied by [param modulate]. If [param width] is greater than or equal to 0, the text will be clipped if it exceeds the specified width.
*/
func (self Expanded) DrawMultilineStringOutline(font Font.Instance, pos Vector2.XY, text string, alignment GUI.HorizontalAlignment, width Float.X, font_size int, max_lines int, size int, modulate Color.RGBA, brk_flags TextServer.LineBreakFlag, justification_flags TextServer.JustificationFlag, direction TextServer.Direction, orientation TextServer.Orientation) { //gd:CanvasItem.draw_multiline_string_outline
	Advanced(self).DrawMultilineStringOutline(font, Vector2.XY(pos), String.New(text), alignment, float64(width), int64(font_size), int64(max_lines), int64(size), Color.RGBA(modulate), brk_flags, justification_flags, direction, orientation)
}

/*
Draws a string first character using a custom font.
*/
func (self Instance) DrawChar(font Font.Instance, pos Vector2.XY, char string) { //gd:CanvasItem.draw_char
	Advanced(self).DrawChar(font, Vector2.XY(pos), String.New(char), int64(16), Color.RGBA(gd.Color{1, 1, 1, 1}))
}

/*
Draws a string first character using a custom font.
*/
func (self Expanded) DrawChar(font Font.Instance, pos Vector2.XY, char string, font_size int, modulate Color.RGBA) { //gd:CanvasItem.draw_char
	Advanced(self).DrawChar(font, Vector2.XY(pos), String.New(char), int64(font_size), Color.RGBA(modulate))
}

/*
Draws a string first character outline using a custom font.
*/
func (self Instance) DrawCharOutline(font Font.Instance, pos Vector2.XY, char string) { //gd:CanvasItem.draw_char_outline
	Advanced(self).DrawCharOutline(font, Vector2.XY(pos), String.New(char), int64(16), int64(-1), Color.RGBA(gd.Color{1, 1, 1, 1}))
}

/*
Draws a string first character outline using a custom font.
*/
func (self Expanded) DrawCharOutline(font Font.Instance, pos Vector2.XY, char string, font_size int, size int, modulate Color.RGBA) { //gd:CanvasItem.draw_char_outline
	Advanced(self).DrawCharOutline(font, Vector2.XY(pos), String.New(char), int64(font_size), int64(size), Color.RGBA(modulate))
}

/*
Draws a [Mesh] in 2D, using the provided texture. See [MeshInstance2D] for related documentation.
*/
func (self Instance) DrawMesh(mesh Mesh.Instance, texture Texture2D.Instance) { //gd:CanvasItem.draw_mesh
	Advanced(self).DrawMesh(mesh, texture, Transform2D.OriginXY(gd.NewTransform2D(1, 0, 0, 1, 0, 0)), Color.RGBA(gd.Color{1, 1, 1, 1}))
}

/*
Draws a [Mesh] in 2D, using the provided texture. See [MeshInstance2D] for related documentation.
*/
func (self Expanded) DrawMesh(mesh Mesh.Instance, texture Texture2D.Instance, transform Transform2D.OriginXY, modulate Color.RGBA) { //gd:CanvasItem.draw_mesh
	Advanced(self).DrawMesh(mesh, texture, Transform2D.OriginXY(transform), Color.RGBA(modulate))
}

/*
Draws a [MultiMesh] in 2D with the provided texture. See [MultiMeshInstance2D] for related documentation.
*/
func (self Instance) DrawMultimesh(multimesh MultiMesh.Instance, texture Texture2D.Instance) { //gd:CanvasItem.draw_multimesh
	Advanced(self).DrawMultimesh(multimesh, texture)
}

/*
Sets a custom transform for drawing via components. Anything drawn afterwards will be transformed by this.
[b]Note:[/b] [member FontFile.oversampling] does [i]not[/i] take [param scale] into account. This means that scaling up/down will cause bitmap fonts and rasterized (non-MSDF) dynamic fonts to appear blurry or pixelated. To ensure text remains crisp regardless of scale, you can enable MSDF font rendering by enabling [member ProjectSettings.gui/theme/default_font_multichannel_signed_distance_field] (applies to the default project font only), or enabling [b]Multichannel Signed Distance Field[/b] in the import options of a DynamicFont for custom fonts. On system fonts, [member SystemFont.multichannel_signed_distance_field] can be enabled in the inspector.
*/
func (self Instance) DrawSetTransform(position Vector2.XY) { //gd:CanvasItem.draw_set_transform
	Advanced(self).DrawSetTransform(Vector2.XY(position), float64(0.0), Vector2.XY(gd.Vector2{1, 1}))
}

/*
Sets a custom transform for drawing via components. Anything drawn afterwards will be transformed by this.
[b]Note:[/b] [member FontFile.oversampling] does [i]not[/i] take [param scale] into account. This means that scaling up/down will cause bitmap fonts and rasterized (non-MSDF) dynamic fonts to appear blurry or pixelated. To ensure text remains crisp regardless of scale, you can enable MSDF font rendering by enabling [member ProjectSettings.gui/theme/default_font_multichannel_signed_distance_field] (applies to the default project font only), or enabling [b]Multichannel Signed Distance Field[/b] in the import options of a DynamicFont for custom fonts. On system fonts, [member SystemFont.multichannel_signed_distance_field] can be enabled in the inspector.
*/
func (self Expanded) DrawSetTransform(position Vector2.XY, rotation Angle.Radians, scale Vector2.XY) { //gd:CanvasItem.draw_set_transform
	Advanced(self).DrawSetTransform(Vector2.XY(position), float64(rotation), Vector2.XY(scale))
}

/*
Sets a custom transform for drawing via matrix. Anything drawn afterwards will be transformed by this.
*/
func (self Instance) DrawSetTransformMatrix(xform Transform2D.OriginXY) { //gd:CanvasItem.draw_set_transform_matrix
	Advanced(self).DrawSetTransformMatrix(Transform2D.OriginXY(xform))
}

/*
Subsequent drawing commands will be ignored unless they fall within the specified animation slice. This is a faster way to implement animations that loop on background rather than redrawing constantly.
*/
func (self Instance) DrawAnimationSlice(animation_length Float.X, slice_begin Float.X, slice_end Float.X) { //gd:CanvasItem.draw_animation_slice
	Advanced(self).DrawAnimationSlice(float64(animation_length), float64(slice_begin), float64(slice_end), float64(0.0))
}

/*
Subsequent drawing commands will be ignored unless they fall within the specified animation slice. This is a faster way to implement animations that loop on background rather than redrawing constantly.
*/
func (self Expanded) DrawAnimationSlice(animation_length Float.X, slice_begin Float.X, slice_end Float.X, offset Float.X) { //gd:CanvasItem.draw_animation_slice
	Advanced(self).DrawAnimationSlice(float64(animation_length), float64(slice_begin), float64(slice_end), float64(offset))
}

/*
After submitting all animations slices via [method draw_animation_slice], this function can be used to revert drawing to its default state (all subsequent drawing commands will be visible). If you don't care about this particular use case, usage of this function after submitting the slices is not required.
*/
func (self Instance) DrawEndAnimation() { //gd:CanvasItem.draw_end_animation
	Advanced(self).DrawEndAnimation()
}

/*
Returns the transform matrix of this item.
*/
func (self Instance) GetTransform() Transform2D.OriginXY { //gd:CanvasItem.get_transform
	return Transform2D.OriginXY(Advanced(self).GetTransform())
}

/*
Returns the global transform matrix of this item, i.e. the combined transform up to the topmost [CanvasItem] node. The topmost item is a [CanvasItem] that either has no parent, has non-[CanvasItem] parent or it has [member top_level] enabled.
*/
func (self Instance) GetGlobalTransform() Transform2D.OriginXY { //gd:CanvasItem.get_global_transform
	return Transform2D.OriginXY(Advanced(self).GetGlobalTransform())
}

/*
Returns the transform from the local coordinate system of this [CanvasItem] to the [Viewport]s coordinate system.
*/
func (self Instance) GetGlobalTransformWithCanvas() Transform2D.OriginXY { //gd:CanvasItem.get_global_transform_with_canvas
	return Transform2D.OriginXY(Advanced(self).GetGlobalTransformWithCanvas())
}

/*
Returns the transform from the coordinate system of the canvas, this item is in, to the [Viewport]s embedders coordinate system.
*/
func (self Instance) GetViewportTransform() Transform2D.OriginXY { //gd:CanvasItem.get_viewport_transform
	return Transform2D.OriginXY(Advanced(self).GetViewportTransform())
}

/*
Returns the viewport's boundaries as a [Rect2].
*/
func (self Instance) GetViewportRect() Rect2.PositionSize { //gd:CanvasItem.get_viewport_rect
	return Rect2.PositionSize(Advanced(self).GetViewportRect())
}

/*
Returns the transform from the coordinate system of the canvas, this item is in, to the [Viewport]s coordinate system.
*/
func (self Instance) GetCanvasTransform() Transform2D.OriginXY { //gd:CanvasItem.get_canvas_transform
	return Transform2D.OriginXY(Advanced(self).GetCanvasTransform())
}

/*
Returns the transform of this [CanvasItem] in global screen coordinates (i.e. taking window position into account). Mostly useful for editor plugins.
Equals to [method get_global_transform] if the window is embedded (see [member Viewport.gui_embed_subwindows]).
*/
func (self Instance) GetScreenTransform() Transform2D.OriginXY { //gd:CanvasItem.get_screen_transform
	return Transform2D.OriginXY(Advanced(self).GetScreenTransform())
}

/*
Returns the mouse's position in this [CanvasItem] using the local coordinate system of this [CanvasItem].
*/
func (self Instance) GetLocalMousePosition() Vector2.XY { //gd:CanvasItem.get_local_mouse_position
	return Vector2.XY(Advanced(self).GetLocalMousePosition())
}

/*
Returns the mouse's position in the [CanvasLayer] that this [CanvasItem] is in using the coordinate system of the [CanvasLayer].
[b]Note:[/b] For screen-space coordinates (e.g. when using a non-embedded [Popup]), you can use [method DisplayServer.mouse_get_position].
*/
func (self Instance) GetGlobalMousePosition() Vector2.XY { //gd:CanvasItem.get_global_mouse_position
	return Vector2.XY(Advanced(self).GetGlobalMousePosition())
}

/*
Returns the [RID] of the [World2D] canvas where this item is in.
*/
func (self Instance) GetCanvas() RID.Canvas { //gd:CanvasItem.get_canvas
	return RID.Canvas(Advanced(self).GetCanvas())
}

/*
Returns the [CanvasLayer] that contains this node, or [code]null[/code] if the node is not in any [CanvasLayer].
*/
func (self Instance) GetCanvasLayerNode() CanvasLayer.Instance { //gd:CanvasItem.get_canvas_layer_node
	return CanvasLayer.Instance(Advanced(self).GetCanvasLayerNode())
}

/*
Returns the [World2D] where this item is in.
*/
func (self Instance) GetWorld2d() World2D.Instance { //gd:CanvasItem.get_world_2d
	return World2D.Instance(Advanced(self).GetWorld2d())
}

/*
Set the value of a shader uniform for this instance only ([url=$DOCS_URL/tutorials/shaders/shader_reference/shading_language.html#per-instance-uniforms]per-instance uniform[/url]). See also [method ShaderMaterial.set_shader_parameter] to assign a uniform on all instances using the same [ShaderMaterial].
[b]Note:[/b] For a shader uniform to be assignable on a per-instance basis, it [i]must[/i] be defined with [code]instance uniform ...[/code] rather than [code]uniform ...[/code] in the shader code.
[b]Note:[/b] [param name] is case-sensitive and must match the name of the uniform in the code exactly (not the capitalized name in the inspector).
*/
func (self Instance) SetInstanceShaderParameter(name string, value any) { //gd:CanvasItem.set_instance_shader_parameter
	Advanced(self).SetInstanceShaderParameter(String.Name(String.New(name)), variant.New(value))
}

/*
Get the value of a shader parameter as set on this instance.
*/
func (self Instance) GetInstanceShaderParameter(name string) any { //gd:CanvasItem.get_instance_shader_parameter
	return any(Advanced(self).GetInstanceShaderParameter(String.Name(String.New(name))).Interface())
}

/*
If [param enable] is [code]true[/code], this node will receive [constant NOTIFICATION_LOCAL_TRANSFORM_CHANGED] when its local transform changes.
*/
func (self Instance) SetNotifyLocalTransform(enable bool) { //gd:CanvasItem.set_notify_local_transform
	Advanced(self).SetNotifyLocalTransform(enable)
}

/*
Returns [code]true[/code] if local transform notifications are communicated to children.
*/
func (self Instance) IsLocalTransformNotificationEnabled() bool { //gd:CanvasItem.is_local_transform_notification_enabled
	return bool(Advanced(self).IsLocalTransformNotificationEnabled())
}

/*
If [param enable] is [code]true[/code], this node will receive [constant NOTIFICATION_TRANSFORM_CHANGED] when its global transform changes.
*/
func (self Instance) SetNotifyTransform(enable bool) { //gd:CanvasItem.set_notify_transform
	Advanced(self).SetNotifyTransform(enable)
}

/*
Returns [code]true[/code] if global transform notifications are communicated to children.
*/
func (self Instance) IsTransformNotificationEnabled() bool { //gd:CanvasItem.is_transform_notification_enabled
	return bool(Advanced(self).IsTransformNotificationEnabled())
}

/*
Forces the transform to update. Transform changes in physics are not instant for performance reasons. Transforms are accumulated and then set. Use this if you need an up-to-date transform when doing physics operations.
*/
func (self Instance) ForceUpdateTransform() { //gd:CanvasItem.force_update_transform
	Advanced(self).ForceUpdateTransform()
}

/*
Transforms [param viewport_point] from the viewport's coordinates to this node's local coordinates.
For the opposite operation, use [method get_global_transform_with_canvas].
[codeblock]
var viewport_point = get_global_transform_with_canvas() * local_point
[/codeblock]
*/
func (self Instance) MakeCanvasPositionLocal(viewport_point Vector2.XY) Vector2.XY { //gd:CanvasItem.make_canvas_position_local
	return Vector2.XY(Advanced(self).MakeCanvasPositionLocal(Vector2.XY(viewport_point)))
}

/*
Transformations issued by [param event]'s inputs are applied in local space instead of global space.
*/
func (self Instance) MakeInputLocal(event InputEvent.Instance) InputEvent.Instance { //gd:CanvasItem.make_input_local
	return InputEvent.Instance(Advanced(self).MakeInputLocal(event))
}

/*
Set/clear individual bits on the rendering visibility layer. This simplifies editing this [CanvasItem]'s visibility layer.
*/
func (self Instance) SetVisibilityLayerBit(layer int, enabled bool) { //gd:CanvasItem.set_visibility_layer_bit
	Advanced(self).SetVisibilityLayerBit(int64(layer), enabled)
}

/*
Returns an individual bit on the rendering visibility layer.
*/
func (self Instance) GetVisibilityLayerBit(layer int) bool { //gd:CanvasItem.get_visibility_layer_bit
	return bool(Advanced(self).GetVisibilityLayerBit(int64(layer)))
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.CanvasItem

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.CanvasItem)(unsafe.Pointer(&obj))
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.CanvasItem)(unsafe.Pointer(&obj))
		return true
	}
	return false
}

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {

	if !gd.Linked {
		var placeholder Instance
		*(*gd.Object)(unsafe.Pointer(&placeholder)) = pointers.Add[gd.Object]([3]uint64{})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(*(*gd.Object)(unsafe.Pointer(&placeholder)), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	object := [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})}
	casted := Instance{*(*gdclass.CanvasItem)(unsafe.Pointer(&object))}
	object[0].Notification(0, false)
	return casted
}

func (self Instance) Visible() bool {
	return bool(class(self).IsVisible())
}

func (self Instance) SetVisible(value bool) {
	class(self).SetVisible(value)
}

func (self Instance) Modulate() Color.RGBA {
	return Color.RGBA(class(self).GetModulate())
}

func (self Instance) SetModulate(value Color.RGBA) {
	class(self).SetModulate(Color.RGBA(value))
}

func (self Instance) SelfModulate() Color.RGBA {
	return Color.RGBA(class(self).GetSelfModulate())
}

func (self Instance) SetSelfModulate(value Color.RGBA) {
	class(self).SetSelfModulate(Color.RGBA(value))
}

func (self Instance) ShowBehindParent() bool {
	return bool(class(self).IsDrawBehindParentEnabled())
}

func (self Instance) SetShowBehindParent(value bool) {
	class(self).SetDrawBehindParent(value)
}

func (self Instance) TopLevel() bool {
	return bool(class(self).IsSetAsTopLevel())
}

func (self Instance) SetTopLevel(value bool) {
	class(self).SetAsTopLevel(value)
}

func (self Instance) ClipChildren() ClipChildrenMode {
	return ClipChildrenMode(class(self).GetClipChildrenMode())
}

func (self Instance) SetClipChildren(value ClipChildrenMode) {
	class(self).SetClipChildrenMode(value)
}

func (self Instance) LightMask() int {
	return int(int(class(self).GetLightMask()))
}

func (self Instance) SetLightMask(value int) {
	class(self).SetLightMask(int64(value))
}

func (self Instance) VisibilityLayer() int {
	return int(int(class(self).GetVisibilityLayer()))
}

func (self Instance) SetVisibilityLayer(value int) {
	class(self).SetVisibilityLayer(int64(value))
}

func (self Instance) ZIndex() int {
	return int(int(class(self).GetZIndex()))
}

func (self Instance) SetZIndex(value int) {
	class(self).SetZIndex(int64(value))
}

func (self Instance) ZAsRelative() bool {
	return bool(class(self).IsZRelative())
}

func (self Instance) SetZAsRelative(value bool) {
	class(self).SetZAsRelative(value)
}

func (self Instance) YSortEnabled() bool {
	return bool(class(self).IsYSortEnabled())
}

func (self Instance) SetYSortEnabled(value bool) {
	class(self).SetYSortEnabled(value)
}

func (self Instance) TextureFilter() TextureFilter {
	return TextureFilter(class(self).GetTextureFilter())
}

func (self Instance) SetTextureFilter(value TextureFilter) {
	class(self).SetTextureFilter(value)
}

func (self Instance) TextureRepeat() TextureRepeat {
	return TextureRepeat(class(self).GetTextureRepeat())
}

func (self Instance) SetTextureRepeat(value TextureRepeat) {
	class(self).SetTextureRepeat(value)
}

func (self Instance) Material() Material.Instance {
	return Material.Instance(class(self).GetMaterial())
}

func (self Instance) SetMaterial(value Material.Instance) {
	class(self).SetMaterial(value)
}

func (self Instance) UseParentMaterial() bool {
	return bool(class(self).GetUseParentMaterial())
}

func (self Instance) SetUseParentMaterial(value bool) {
	class(self).SetUseParentMaterial(value)
}

/*
Called when [CanvasItem] has been requested to redraw (after [method queue_redraw] is called, either manually or by the engine).
Corresponds to the [constant NOTIFICATION_DRAW] notification in [method Object._notification].
*/
func (class) _draw(impl func(ptr unsafe.Pointer)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self)
	}
}

/*
Returns the canvas item RID used by [RenderingServer] for this item.
*/
//go:nosplit
func (self class) GetCanvasItem() RID.Any { //gd:CanvasItem.get_canvas_item
	var r_ret = gdextension.Call[RID.Any](gd.ObjectChecked(self.AsObject()), methods.get_canvas_item, gdextension.SizeRID, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetVisible(visible bool) { //gd:CanvasItem.set_visible
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_visible, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ visible bool }{visible}))
}

//go:nosplit
func (self class) IsVisible() bool { //gd:CanvasItem.is_visible
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_visible, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if the node is present in the [SceneTree], its [member visible] property is [code]true[/code] and all its ancestors are also visible. If any ancestor is hidden, this node will not be visible in the scene tree, and is therefore not drawn (see [method _draw]).
Visibility is checked only in parent nodes that inherit from [CanvasItem], [CanvasLayer], and [Window]. If the parent is of any other type (such as [Node], [AnimationPlayer], or [Node3D]), it is assumed to be visible.
[b]Note:[/b] This method does not take [member visibility_layer] into account, so even if this method returns [code]true[/code], the node might end up not being rendered.
*/
//go:nosplit
func (self class) IsVisibleInTree() bool { //gd:CanvasItem.is_visible_in_tree
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_visible_in_tree, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Show the [CanvasItem] if it's currently hidden. This is equivalent to setting [member visible] to [code]true[/code]. For controls that inherit [Popup], the correct way to make them visible is to call one of the multiple [code]popup*()[/code] functions instead.
*/
//go:nosplit
func (self class) Show() { //gd:CanvasItem.show
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.show, 0, unsafe.Pointer(&struct{}{}))
}

/*
Hide the [CanvasItem] if it's currently visible. This is equivalent to setting [member visible] to [code]false[/code].
*/
//go:nosplit
func (self class) Hide() { //gd:CanvasItem.hide
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.hide, 0, unsafe.Pointer(&struct{}{}))
}

/*
Queues the [CanvasItem] to redraw. During idle time, if [CanvasItem] is visible, [constant NOTIFICATION_DRAW] is sent and [method _draw] is called. This only occurs [b]once[/b] per frame, even if this method has been called multiple times.
*/
//go:nosplit
func (self class) QueueRedraw() { //gd:CanvasItem.queue_redraw
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.queue_redraw, 0, unsafe.Pointer(&struct{}{}))
}

/*
Moves this node to display on top of its siblings.
Internally, the node is moved to the bottom of parent's child list. The method has no effect on nodes without a parent.
*/
//go:nosplit
func (self class) MoveToFront() { //gd:CanvasItem.move_to_front
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.move_to_front, 0, unsafe.Pointer(&struct{}{}))
}

//go:nosplit
func (self class) SetAsTopLevel(enable bool) { //gd:CanvasItem.set_as_top_level
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_as_top_level, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

//go:nosplit
func (self class) IsSetAsTopLevel() bool { //gd:CanvasItem.is_set_as_top_level
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_set_as_top_level, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetLightMask(light_mask int64) { //gd:CanvasItem.set_light_mask
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_light_mask, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ light_mask int64 }{light_mask}))
}

//go:nosplit
func (self class) GetLightMask() int64 { //gd:CanvasItem.get_light_mask
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_light_mask, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetModulate(modulate Color.RGBA) { //gd:CanvasItem.set_modulate
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_modulate, 0|(gdextension.SizeColor<<4), unsafe.Pointer(&struct{ modulate Color.RGBA }{modulate}))
}

//go:nosplit
func (self class) GetModulate() Color.RGBA { //gd:CanvasItem.get_modulate
	var r_ret = gdextension.Call[Color.RGBA](gd.ObjectChecked(self.AsObject()), methods.get_modulate, gdextension.SizeColor, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetSelfModulate(self_modulate Color.RGBA) { //gd:CanvasItem.set_self_modulate
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_self_modulate, 0|(gdextension.SizeColor<<4), unsafe.Pointer(&struct{ self_modulate Color.RGBA }{self_modulate}))
}

//go:nosplit
func (self class) GetSelfModulate() Color.RGBA { //gd:CanvasItem.get_self_modulate
	var r_ret = gdextension.Call[Color.RGBA](gd.ObjectChecked(self.AsObject()), methods.get_self_modulate, gdextension.SizeColor, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetZIndex(z_index int64) { //gd:CanvasItem.set_z_index
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_z_index, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ z_index int64 }{z_index}))
}

//go:nosplit
func (self class) GetZIndex() int64 { //gd:CanvasItem.get_z_index
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_z_index, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetZAsRelative(enable bool) { //gd:CanvasItem.set_z_as_relative
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_z_as_relative, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

//go:nosplit
func (self class) IsZRelative() bool { //gd:CanvasItem.is_z_relative
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_z_relative, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetYSortEnabled(enabled bool) { //gd:CanvasItem.set_y_sort_enabled
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_y_sort_enabled, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enabled bool }{enabled}))
}

//go:nosplit
func (self class) IsYSortEnabled() bool { //gd:CanvasItem.is_y_sort_enabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_y_sort_enabled, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetDrawBehindParent(enable bool) { //gd:CanvasItem.set_draw_behind_parent
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_draw_behind_parent, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

//go:nosplit
func (self class) IsDrawBehindParentEnabled() bool { //gd:CanvasItem.is_draw_behind_parent_enabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_draw_behind_parent_enabled, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Draws a line from a 2D point to another, with a given color and width. It can be optionally antialiased. See also [method draw_dashed_line], [method draw_multiline], and [method draw_polyline].
If [param width] is negative, then a two-point primitive will be drawn instead of a four-point one. This means that when the CanvasItem is scaled, the line will remain thin. If this behavior is not desired, then pass a positive [param width] like [code]1.0[/code].
*/
//go:nosplit
func (self class) DrawLine(from Vector2.XY, to Vector2.XY, color Color.RGBA, width float64, antialiased bool) { //gd:CanvasItem.draw_line
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.draw_line, 0|(gdextension.SizeVector2<<4)|(gdextension.SizeVector2<<8)|(gdextension.SizeColor<<12)|(gdextension.SizeFloat<<16)|(gdextension.SizeBool<<20), unsafe.Pointer(&struct {
		from        Vector2.XY
		to          Vector2.XY
		color       Color.RGBA
		width       float64
		antialiased bool
	}{from, to, color, width, antialiased}))
}

/*
Draws a dashed line from a 2D point to another, with a given color and width. See also [method draw_line], [method draw_multiline], and [method draw_polyline].
If [param width] is negative, then a two-point primitives will be drawn instead of a four-point ones. This means that when the CanvasItem is scaled, the line parts will remain thin. If this behavior is not desired, then pass a positive [param width] like [code]1.0[/code].
[param dash] is the length of each dash in pixels, with the gap between each dash being the same length. If [param aligned] is [code]true[/code], the length of the first and last dashes may be shortened or lengthened to allow the line to begin and end at the precise points defined by [param from] and [param to]. Both ends are always symmetrical when [param aligned] is [code]true[/code]. If [param aligned] is [code]false[/code], all dashes will have the same length, but the line may appear incomplete at the end due to the dash length not dividing evenly into the line length. Only full dashes are drawn when [param aligned] is [code]false[/code].
If [param antialiased] is [code]true[/code], half transparent "feathers" will be attached to the boundary, making outlines smooth.
[b]Note:[/b] [param antialiased] is only effective if [param width] is greater than [code]0.0[/code].
*/
//go:nosplit
func (self class) DrawDashedLine(from Vector2.XY, to Vector2.XY, color Color.RGBA, width float64, dash float64, aligned bool, antialiased bool) { //gd:CanvasItem.draw_dashed_line
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.draw_dashed_line, 0|(gdextension.SizeVector2<<4)|(gdextension.SizeVector2<<8)|(gdextension.SizeColor<<12)|(gdextension.SizeFloat<<16)|(gdextension.SizeFloat<<20)|(gdextension.SizeBool<<24)|(gdextension.SizeBool<<28), unsafe.Pointer(&struct {
		from        Vector2.XY
		to          Vector2.XY
		color       Color.RGBA
		width       float64
		dash        float64
		aligned     bool
		antialiased bool
	}{from, to, color, width, dash, aligned, antialiased}))
}

/*
Draws interconnected line segments with a uniform [param color] and [param width] and optional antialiasing (supported only for positive [param width]). When drawing large amounts of lines, this is faster than using individual [method draw_line] calls. To draw disconnected lines, use [method draw_multiline] instead. See also [method draw_polygon].
If [param width] is negative, it will be ignored and the polyline will be drawn using [constant RenderingServer.PRIMITIVE_LINE_STRIP]. This means that when the CanvasItem is scaled, the polyline will remain thin. If this behavior is not desired, then pass a positive [param width] like [code]1.0[/code].
*/
//go:nosplit
func (self class) DrawPolyline(points Packed.Array[Vector2.XY], color Color.RGBA, width float64, antialiased bool) { //gd:CanvasItem.draw_polyline
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.draw_polyline, 0|(gdextension.SizePackedArray<<4)|(gdextension.SizeColor<<8)|(gdextension.SizeFloat<<12)|(gdextension.SizeBool<<16), unsafe.Pointer(&struct {
		points      gdextension.PackedArray[Vector2.XY]
		color       Color.RGBA
		width       float64
		antialiased bool
	}{pointers.Get(gd.InternalPacked[gd.PackedVector2Array, Vector2.XY](points)), color, width, antialiased}))
}

/*
Draws interconnected line segments with a uniform [param width], point-by-point coloring, and optional antialiasing (supported only for positive [param width]). Colors assigned to line points match by index between [param points] and [param colors], i.e. each line segment is filled with a gradient between the colors of the endpoints. When drawing large amounts of lines, this is faster than using individual [method draw_line] calls. To draw disconnected lines, use [method draw_multiline_colors] instead. See also [method draw_polygon].
If [param width] is negative, it will be ignored and the polyline will be drawn using [constant RenderingServer.PRIMITIVE_LINE_STRIP]. This means that when the CanvasItem is scaled, the polyline will remain thin. If this behavior is not desired, then pass a positive [param width] like [code]1.0[/code].
*/
//go:nosplit
func (self class) DrawPolylineColors(points Packed.Array[Vector2.XY], colors Packed.Array[Color.RGBA], width float64, antialiased bool) { //gd:CanvasItem.draw_polyline_colors
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.draw_polyline_colors, 0|(gdextension.SizePackedArray<<4)|(gdextension.SizePackedArray<<8)|(gdextension.SizeFloat<<12)|(gdextension.SizeBool<<16), unsafe.Pointer(&struct {
		points      gdextension.PackedArray[Vector2.XY]
		colors      gdextension.PackedArray[Color.RGBA]
		width       float64
		antialiased bool
	}{pointers.Get(gd.InternalPacked[gd.PackedVector2Array, Vector2.XY](points)), pointers.Get(gd.InternalPacked[gd.PackedColorArray, Color.RGBA](colors)), width, antialiased}))
}

/*
Draws an unfilled arc between the given angles with a uniform [param color] and [param width] and optional antialiasing (supported only for positive [param width]). The larger the value of [param point_count], the smoother the curve. See also [method draw_circle].
If [param width] is negative, it will be ignored and the arc will be drawn using [constant RenderingServer.PRIMITIVE_LINE_STRIP]. This means that when the CanvasItem is scaled, the arc will remain thin. If this behavior is not desired, then pass a positive [param width] like [code]1.0[/code].
The arc is drawn from [param start_angle] towards the value of [param end_angle] so in clockwise direction if [code]start_angle < end_angle[/code] and counter-clockwise otherwise. Passing the same angles but in reversed order will produce the same arc. If absolute difference of [param start_angle] and [param end_angle] is greater than [constant @GDScript.TAU] radians, then a full circle arc is drawn (i.e. arc will not overlap itself).
*/
//go:nosplit
func (self class) DrawArc(center Vector2.XY, radius float64, start_angle float64, end_angle float64, point_count int64, color Color.RGBA, width float64, antialiased bool) { //gd:CanvasItem.draw_arc
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.draw_arc, 0|(gdextension.SizeVector2<<4)|(gdextension.SizeFloat<<8)|(gdextension.SizeFloat<<12)|(gdextension.SizeFloat<<16)|(gdextension.SizeInt<<20)|(gdextension.SizeColor<<24)|(gdextension.SizeFloat<<28)|(gdextension.SizeBool<<32), unsafe.Pointer(&struct {
		center      Vector2.XY
		radius      float64
		start_angle float64
		end_angle   float64
		point_count int64
		color       Color.RGBA
		width       float64
		antialiased bool
	}{center, radius, start_angle, end_angle, point_count, color, width, antialiased}))
}

/*
Draws multiple disconnected lines with a uniform [param width] and [param color]. Each line is defined by two consecutive points from [param points] array, i.e. i-th segment consists of [code]points[2 * i][/code], [code]points[2 * i + 1][/code] endpoints. When drawing large amounts of lines, this is faster than using individual [method draw_line] calls. To draw interconnected lines, use [method draw_polyline] instead.
If [param width] is negative, then two-point primitives will be drawn instead of a four-point ones. This means that when the CanvasItem is scaled, the lines will remain thin. If this behavior is not desired, then pass a positive [param width] like [code]1.0[/code].
[b]Note:[/b] [param antialiased] is only effective if [param width] is greater than [code]0.0[/code].
*/
//go:nosplit
func (self class) DrawMultiline(points Packed.Array[Vector2.XY], color Color.RGBA, width float64, antialiased bool) { //gd:CanvasItem.draw_multiline
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.draw_multiline, 0|(gdextension.SizePackedArray<<4)|(gdextension.SizeColor<<8)|(gdextension.SizeFloat<<12)|(gdextension.SizeBool<<16), unsafe.Pointer(&struct {
		points      gdextension.PackedArray[Vector2.XY]
		color       Color.RGBA
		width       float64
		antialiased bool
	}{pointers.Get(gd.InternalPacked[gd.PackedVector2Array, Vector2.XY](points)), color, width, antialiased}))
}

/*
Draws multiple disconnected lines with a uniform [param width] and segment-by-segment coloring. Each segment is defined by two consecutive points from [param points] array and a corresponding color from [param colors] array, i.e. i-th segment consists of [code]points[2 * i][/code], [code]points[2 * i + 1][/code] endpoints and has [code]colors[i][/code] color. When drawing large amounts of lines, this is faster than using individual [method draw_line] calls. To draw interconnected lines, use [method draw_polyline_colors] instead.
If [param width] is negative, then two-point primitives will be drawn instead of a four-point ones. This means that when the CanvasItem is scaled, the lines will remain thin. If this behavior is not desired, then pass a positive [param width] like [code]1.0[/code].
[b]Note:[/b] [param antialiased] is only effective if [param width] is greater than [code]0.0[/code].
*/
//go:nosplit
func (self class) DrawMultilineColors(points Packed.Array[Vector2.XY], colors Packed.Array[Color.RGBA], width float64, antialiased bool) { //gd:CanvasItem.draw_multiline_colors
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.draw_multiline_colors, 0|(gdextension.SizePackedArray<<4)|(gdextension.SizePackedArray<<8)|(gdextension.SizeFloat<<12)|(gdextension.SizeBool<<16), unsafe.Pointer(&struct {
		points      gdextension.PackedArray[Vector2.XY]
		colors      gdextension.PackedArray[Color.RGBA]
		width       float64
		antialiased bool
	}{pointers.Get(gd.InternalPacked[gd.PackedVector2Array, Vector2.XY](points)), pointers.Get(gd.InternalPacked[gd.PackedColorArray, Color.RGBA](colors)), width, antialiased}))
}

/*
Draws a rectangle. If [param filled] is [code]true[/code], the rectangle will be filled with the [param color] specified. If [param filled] is [code]false[/code], the rectangle will be drawn as a stroke with the [param color] and [param width] specified. See also [method draw_texture_rect].
If [param width] is negative, then two-point primitives will be drawn instead of a four-point ones. This means that when the CanvasItem is scaled, the lines will remain thin. If this behavior is not desired, then pass a positive [param width] like [code]1.0[/code].
If [param antialiased] is [code]true[/code], half transparent "feathers" will be attached to the boundary, making outlines smooth.
[b]Note:[/b] [param width] is only effective if [param filled] is [code]false[/code].
[b]Note:[/b] Unfilled rectangles drawn with a negative [param width] may not display perfectly. For example, corners may be missing or brighter due to overlapping lines (for a translucent [param color]).
*/
//go:nosplit
func (self class) DrawRect(rect Rect2.PositionSize, color Color.RGBA, filled bool, width float64, antialiased bool) { //gd:CanvasItem.draw_rect
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.draw_rect, 0|(gdextension.SizeRect2<<4)|(gdextension.SizeColor<<8)|(gdextension.SizeBool<<12)|(gdextension.SizeFloat<<16)|(gdextension.SizeBool<<20), unsafe.Pointer(&struct {
		rect        Rect2.PositionSize
		color       Color.RGBA
		filled      bool
		width       float64
		antialiased bool
	}{rect, color, filled, width, antialiased}))
}

/*
Draws a circle. See also [method draw_arc], [method draw_polyline], and [method draw_polygon].
If [param filled] is [code]true[/code], the circle will be filled with the [param color] specified. If [param filled] is [code]false[/code], the circle will be drawn as a stroke with the [param color] and [param width] specified.
If [param width] is negative, then two-point primitives will be drawn instead of a four-point ones. This means that when the CanvasItem is scaled, the lines will remain thin. If this behavior is not desired, then pass a positive [param width] like [code]1.0[/code].
If [param antialiased] is [code]true[/code], half transparent "feathers" will be attached to the boundary, making outlines smooth.
[b]Note:[/b] [param width] is only effective if [param filled] is [code]false[/code].
*/
//go:nosplit
func (self class) DrawCircle(position Vector2.XY, radius float64, color Color.RGBA, filled bool, width float64, antialiased bool) { //gd:CanvasItem.draw_circle
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.draw_circle, 0|(gdextension.SizeVector2<<4)|(gdextension.SizeFloat<<8)|(gdextension.SizeColor<<12)|(gdextension.SizeBool<<16)|(gdextension.SizeFloat<<20)|(gdextension.SizeBool<<24), unsafe.Pointer(&struct {
		position    Vector2.XY
		radius      float64
		color       Color.RGBA
		filled      bool
		width       float64
		antialiased bool
	}{position, radius, color, filled, width, antialiased}))
}

/*
Draws a texture at a given position.
*/
//go:nosplit
func (self class) DrawTexture(texture [1]gdclass.Texture2D, position Vector2.XY, modulate Color.RGBA) { //gd:CanvasItem.draw_texture
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.draw_texture, 0|(gdextension.SizeObject<<4)|(gdextension.SizeVector2<<8)|(gdextension.SizeColor<<12), unsafe.Pointer(&struct {
		texture  gdextension.Object
		position Vector2.XY
		modulate Color.RGBA
	}{gdextension.Object(gd.ObjectChecked(texture[0].AsObject())), position, modulate}))
}

/*
Draws a textured rectangle at a given position, optionally modulated by a color. If [param transpose] is [code]true[/code], the texture will have its X and Y coordinates swapped. See also [method draw_rect] and [method draw_texture_rect_region].
*/
//go:nosplit
func (self class) DrawTextureRect(texture [1]gdclass.Texture2D, rect Rect2.PositionSize, tile bool, modulate Color.RGBA, transpose bool) { //gd:CanvasItem.draw_texture_rect
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.draw_texture_rect, 0|(gdextension.SizeObject<<4)|(gdextension.SizeRect2<<8)|(gdextension.SizeBool<<12)|(gdextension.SizeColor<<16)|(gdextension.SizeBool<<20), unsafe.Pointer(&struct {
		texture   gdextension.Object
		rect      Rect2.PositionSize
		tile      bool
		modulate  Color.RGBA
		transpose bool
	}{gdextension.Object(gd.ObjectChecked(texture[0].AsObject())), rect, tile, modulate, transpose}))
}

/*
Draws a textured rectangle from a texture's region (specified by [param src_rect]) at a given position, optionally modulated by a color. If [param transpose] is [code]true[/code], the texture will have its X and Y coordinates swapped. See also [method draw_texture_rect].
*/
//go:nosplit
func (self class) DrawTextureRectRegion(texture [1]gdclass.Texture2D, rect Rect2.PositionSize, src_rect Rect2.PositionSize, modulate Color.RGBA, transpose bool, clip_uv bool) { //gd:CanvasItem.draw_texture_rect_region
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.draw_texture_rect_region, 0|(gdextension.SizeObject<<4)|(gdextension.SizeRect2<<8)|(gdextension.SizeRect2<<12)|(gdextension.SizeColor<<16)|(gdextension.SizeBool<<20)|(gdextension.SizeBool<<24), unsafe.Pointer(&struct {
		texture   gdextension.Object
		rect      Rect2.PositionSize
		src_rect  Rect2.PositionSize
		modulate  Color.RGBA
		transpose bool
		clip_uv   bool
	}{gdextension.Object(gd.ObjectChecked(texture[0].AsObject())), rect, src_rect, modulate, transpose, clip_uv}))
}

/*
Draws a textured rectangle region of the multi-channel signed distance field texture at a given position, optionally modulated by a color. See [member FontFile.multichannel_signed_distance_field] for more information and caveats about MSDF font rendering.
If [param outline] is positive, each alpha channel value of pixel in region is set to maximum value of true distance in the [param outline] radius.
Value of the [param pixel_range] should the same that was used during distance field texture generation.
*/
//go:nosplit
func (self class) DrawMsdfTextureRectRegion(texture [1]gdclass.Texture2D, rect Rect2.PositionSize, src_rect Rect2.PositionSize, modulate Color.RGBA, outline float64, pixel_range float64, scale float64) { //gd:CanvasItem.draw_msdf_texture_rect_region
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.draw_msdf_texture_rect_region, 0|(gdextension.SizeObject<<4)|(gdextension.SizeRect2<<8)|(gdextension.SizeRect2<<12)|(gdextension.SizeColor<<16)|(gdextension.SizeFloat<<20)|(gdextension.SizeFloat<<24)|(gdextension.SizeFloat<<28), unsafe.Pointer(&struct {
		texture     gdextension.Object
		rect        Rect2.PositionSize
		src_rect    Rect2.PositionSize
		modulate    Color.RGBA
		outline     float64
		pixel_range float64
		scale       float64
	}{gdextension.Object(gd.ObjectChecked(texture[0].AsObject())), rect, src_rect, modulate, outline, pixel_range, scale}))
}

/*
Draws a textured rectangle region of the font texture with LCD subpixel anti-aliasing at a given position, optionally modulated by a color.
Texture is drawn using the following blend operation, blend mode of the [CanvasItemMaterial] is ignored:
[codeblock]
dst.r = texture.r * modulate.r * modulate.a + dst.r * (1.0 - texture.r * modulate.a);
dst.g = texture.g * modulate.g * modulate.a + dst.g * (1.0 - texture.g * modulate.a);
dst.b = texture.b * modulate.b * modulate.a + dst.b * (1.0 - texture.b * modulate.a);
dst.a = modulate.a + dst.a * (1.0 - modulate.a);
[/codeblock]
*/
//go:nosplit
func (self class) DrawLcdTextureRectRegion(texture [1]gdclass.Texture2D, rect Rect2.PositionSize, src_rect Rect2.PositionSize, modulate Color.RGBA) { //gd:CanvasItem.draw_lcd_texture_rect_region
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.draw_lcd_texture_rect_region, 0|(gdextension.SizeObject<<4)|(gdextension.SizeRect2<<8)|(gdextension.SizeRect2<<12)|(gdextension.SizeColor<<16), unsafe.Pointer(&struct {
		texture  gdextension.Object
		rect     Rect2.PositionSize
		src_rect Rect2.PositionSize
		modulate Color.RGBA
	}{gdextension.Object(gd.ObjectChecked(texture[0].AsObject())), rect, src_rect, modulate}))
}

/*
Draws a styled rectangle.
*/
//go:nosplit
func (self class) DrawStyleBox(style_box [1]gdclass.StyleBox, rect Rect2.PositionSize) { //gd:CanvasItem.draw_style_box
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.draw_style_box, 0|(gdextension.SizeObject<<4)|(gdextension.SizeRect2<<8), unsafe.Pointer(&struct {
		style_box gdextension.Object
		rect      Rect2.PositionSize
	}{gdextension.Object(gd.ObjectChecked(style_box[0].AsObject())), rect}))
}

/*
Draws a custom primitive. 1 point for a point, 2 points for a line, 3 points for a triangle, and 4 points for a quad. If 0 points or more than 4 points are specified, nothing will be drawn and an error message will be printed. See also [method draw_line], [method draw_polyline], [method draw_polygon], and [method draw_rect].
*/
//go:nosplit
func (self class) DrawPrimitive(points Packed.Array[Vector2.XY], colors Packed.Array[Color.RGBA], uvs Packed.Array[Vector2.XY], texture [1]gdclass.Texture2D) { //gd:CanvasItem.draw_primitive
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.draw_primitive, 0|(gdextension.SizePackedArray<<4)|(gdextension.SizePackedArray<<8)|(gdextension.SizePackedArray<<12)|(gdextension.SizeObject<<16), unsafe.Pointer(&struct {
		points  gdextension.PackedArray[Vector2.XY]
		colors  gdextension.PackedArray[Color.RGBA]
		uvs     gdextension.PackedArray[Vector2.XY]
		texture gdextension.Object
	}{pointers.Get(gd.InternalPacked[gd.PackedVector2Array, Vector2.XY](points)), pointers.Get(gd.InternalPacked[gd.PackedColorArray, Color.RGBA](colors)), pointers.Get(gd.InternalPacked[gd.PackedVector2Array, Vector2.XY](uvs)), gdextension.Object(gd.ObjectChecked(texture[0].AsObject()))}))
}

/*
Draws a solid polygon of any number of points, convex or concave. Unlike [method draw_colored_polygon], each point's color can be changed individually. See also [method draw_polyline] and [method draw_polyline_colors]. If you need more flexibility (such as being able to use bones), use [method RenderingServer.canvas_item_add_triangle_array] instead.
[b]Note:[/b] If you frequently redraw the same polygon with a large number of vertices, consider pre-calculating the triangulation with [method Geometry2D.triangulate_polygon] and using [method draw_mesh], [method draw_multimesh], or [method RenderingServer.canvas_item_add_triangle_array].
*/
//go:nosplit
func (self class) DrawPolygon(points Packed.Array[Vector2.XY], colors Packed.Array[Color.RGBA], uvs Packed.Array[Vector2.XY], texture [1]gdclass.Texture2D) { //gd:CanvasItem.draw_polygon
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.draw_polygon, 0|(gdextension.SizePackedArray<<4)|(gdextension.SizePackedArray<<8)|(gdextension.SizePackedArray<<12)|(gdextension.SizeObject<<16), unsafe.Pointer(&struct {
		points  gdextension.PackedArray[Vector2.XY]
		colors  gdextension.PackedArray[Color.RGBA]
		uvs     gdextension.PackedArray[Vector2.XY]
		texture gdextension.Object
	}{pointers.Get(gd.InternalPacked[gd.PackedVector2Array, Vector2.XY](points)), pointers.Get(gd.InternalPacked[gd.PackedColorArray, Color.RGBA](colors)), pointers.Get(gd.InternalPacked[gd.PackedVector2Array, Vector2.XY](uvs)), gdextension.Object(gd.ObjectChecked(texture[0].AsObject()))}))
}

/*
Draws a colored polygon of any number of points, convex or concave. Unlike [method draw_polygon], a single color must be specified for the whole polygon.
[b]Note:[/b] If you frequently redraw the same polygon with a large number of vertices, consider pre-calculating the triangulation with [method Geometry2D.triangulate_polygon] and using [method draw_mesh], [method draw_multimesh], or [method RenderingServer.canvas_item_add_triangle_array].
*/
//go:nosplit
func (self class) DrawColoredPolygon(points Packed.Array[Vector2.XY], color Color.RGBA, uvs Packed.Array[Vector2.XY], texture [1]gdclass.Texture2D) { //gd:CanvasItem.draw_colored_polygon
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.draw_colored_polygon, 0|(gdextension.SizePackedArray<<4)|(gdextension.SizeColor<<8)|(gdextension.SizePackedArray<<12)|(gdextension.SizeObject<<16), unsafe.Pointer(&struct {
		points  gdextension.PackedArray[Vector2.XY]
		color   Color.RGBA
		uvs     gdextension.PackedArray[Vector2.XY]
		texture gdextension.Object
	}{pointers.Get(gd.InternalPacked[gd.PackedVector2Array, Vector2.XY](points)), color, pointers.Get(gd.InternalPacked[gd.PackedVector2Array, Vector2.XY](uvs)), gdextension.Object(gd.ObjectChecked(texture[0].AsObject()))}))
}

/*
Draws [param text] using the specified [param font] at the [param pos] (bottom-left corner using the baseline of the font). The text will have its color multiplied by [param modulate]. If [param width] is greater than or equal to 0, the text will be clipped if it exceeds the specified width.
[b]Example:[/b] Draw "Hello world", using the project's default font:
[codeblocks]
[gdscript]
# If using this method in a script that redraws constantly, move the
# `default_font` declaration to a member variable assigned in `_ready()`
# so the Control is only created once.
var default_font = ThemeDB.fallback_font
var default_font_size = ThemeDB.fallback_font_size
draw_string(default_font, Vector2(64, 64), "Hello world", HORIZONTAL_ALIGNMENT_LEFT, -1, default_font_size)
[/gdscript]
[csharp]
// If using this method in a script that redraws constantly, move the
// `default_font` declaration to a member variable assigned in `_Ready()`
// so the Control is only created once.
Font defaultFont = ThemeDB.FallbackFont;
int defaultFontSize = ThemeDB.FallbackFontSize;
DrawString(defaultFont, new Vector2(64, 64), "Hello world", HORIZONTAL_ALIGNMENT_LEFT, -1, defaultFontSize);
[/csharp]
[/codeblocks]
See also [method Font.draw_string].
*/
//go:nosplit
func (self class) DrawString(font [1]gdclass.Font, pos Vector2.XY, text String.Readable, alignment GUI.HorizontalAlignment, width float64, font_size int64, modulate Color.RGBA, justification_flags TextServer.JustificationFlag, direction TextServer.Direction, orientation TextServer.Orientation) { //gd:CanvasItem.draw_string
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.draw_string, 0|(gdextension.SizeObject<<4)|(gdextension.SizeVector2<<8)|(gdextension.SizeString<<12)|(gdextension.SizeInt<<16)|(gdextension.SizeFloat<<20)|(gdextension.SizeInt<<24)|(gdextension.SizeColor<<28)|(gdextension.SizeInt<<32)|(gdextension.SizeInt<<36)|(gdextension.SizeInt<<40), unsafe.Pointer(&struct {
		font                gdextension.Object
		pos                 Vector2.XY
		text                gdextension.String
		alignment           GUI.HorizontalAlignment
		width               float64
		font_size           int64
		modulate            Color.RGBA
		justification_flags TextServer.JustificationFlag
		direction           TextServer.Direction
		orientation         TextServer.Orientation
	}{gdextension.Object(gd.ObjectChecked(font[0].AsObject())), pos, pointers.Get(gd.InternalString(text)), alignment, width, font_size, modulate, justification_flags, direction, orientation}))
}

/*
Breaks [param text] into lines and draws it using the specified [param font] at the [param pos] (top-left corner). The text will have its color multiplied by [param modulate]. If [param width] is greater than or equal to 0, the text will be clipped if it exceeds the specified width.
*/
//go:nosplit
func (self class) DrawMultilineString(font [1]gdclass.Font, pos Vector2.XY, text String.Readable, alignment GUI.HorizontalAlignment, width float64, font_size int64, max_lines int64, modulate Color.RGBA, brk_flags TextServer.LineBreakFlag, justification_flags TextServer.JustificationFlag, direction TextServer.Direction, orientation TextServer.Orientation) { //gd:CanvasItem.draw_multiline_string
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.draw_multiline_string, 0|(gdextension.SizeObject<<4)|(gdextension.SizeVector2<<8)|(gdextension.SizeString<<12)|(gdextension.SizeInt<<16)|(gdextension.SizeFloat<<20)|(gdextension.SizeInt<<24)|(gdextension.SizeInt<<28)|(gdextension.SizeColor<<32)|(gdextension.SizeInt<<36)|(gdextension.SizeInt<<40)|(gdextension.SizeInt<<44)|(gdextension.SizeInt<<48), unsafe.Pointer(&struct {
		font                gdextension.Object
		pos                 Vector2.XY
		text                gdextension.String
		alignment           GUI.HorizontalAlignment
		width               float64
		font_size           int64
		max_lines           int64
		modulate            Color.RGBA
		brk_flags           TextServer.LineBreakFlag
		justification_flags TextServer.JustificationFlag
		direction           TextServer.Direction
		orientation         TextServer.Orientation
	}{gdextension.Object(gd.ObjectChecked(font[0].AsObject())), pos, pointers.Get(gd.InternalString(text)), alignment, width, font_size, max_lines, modulate, brk_flags, justification_flags, direction, orientation}))
}

/*
Draws [param text] outline using the specified [param font] at the [param pos] (bottom-left corner using the baseline of the font). The text will have its color multiplied by [param modulate]. If [param width] is greater than or equal to 0, the text will be clipped if it exceeds the specified width.
*/
//go:nosplit
func (self class) DrawStringOutline(font [1]gdclass.Font, pos Vector2.XY, text String.Readable, alignment GUI.HorizontalAlignment, width float64, font_size int64, size int64, modulate Color.RGBA, justification_flags TextServer.JustificationFlag, direction TextServer.Direction, orientation TextServer.Orientation) { //gd:CanvasItem.draw_string_outline
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.draw_string_outline, 0|(gdextension.SizeObject<<4)|(gdextension.SizeVector2<<8)|(gdextension.SizeString<<12)|(gdextension.SizeInt<<16)|(gdextension.SizeFloat<<20)|(gdextension.SizeInt<<24)|(gdextension.SizeInt<<28)|(gdextension.SizeColor<<32)|(gdextension.SizeInt<<36)|(gdextension.SizeInt<<40)|(gdextension.SizeInt<<44), unsafe.Pointer(&struct {
		font                gdextension.Object
		pos                 Vector2.XY
		text                gdextension.String
		alignment           GUI.HorizontalAlignment
		width               float64
		font_size           int64
		size                int64
		modulate            Color.RGBA
		justification_flags TextServer.JustificationFlag
		direction           TextServer.Direction
		orientation         TextServer.Orientation
	}{gdextension.Object(gd.ObjectChecked(font[0].AsObject())), pos, pointers.Get(gd.InternalString(text)), alignment, width, font_size, size, modulate, justification_flags, direction, orientation}))
}

/*
Breaks [param text] to the lines and draws text outline using the specified [param font] at the [param pos] (top-left corner). The text will have its color multiplied by [param modulate]. If [param width] is greater than or equal to 0, the text will be clipped if it exceeds the specified width.
*/
//go:nosplit
func (self class) DrawMultilineStringOutline(font [1]gdclass.Font, pos Vector2.XY, text String.Readable, alignment GUI.HorizontalAlignment, width float64, font_size int64, max_lines int64, size int64, modulate Color.RGBA, brk_flags TextServer.LineBreakFlag, justification_flags TextServer.JustificationFlag, direction TextServer.Direction, orientation TextServer.Orientation) { //gd:CanvasItem.draw_multiline_string_outline
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.draw_multiline_string_outline, 0|(gdextension.SizeObject<<4)|(gdextension.SizeVector2<<8)|(gdextension.SizeString<<12)|(gdextension.SizeInt<<16)|(gdextension.SizeFloat<<20)|(gdextension.SizeInt<<24)|(gdextension.SizeInt<<28)|(gdextension.SizeInt<<32)|(gdextension.SizeColor<<36)|(gdextension.SizeInt<<40)|(gdextension.SizeInt<<44)|(gdextension.SizeInt<<48)|(gdextension.SizeInt<<52), unsafe.Pointer(&struct {
		font                gdextension.Object
		pos                 Vector2.XY
		text                gdextension.String
		alignment           GUI.HorizontalAlignment
		width               float64
		font_size           int64
		max_lines           int64
		size                int64
		modulate            Color.RGBA
		brk_flags           TextServer.LineBreakFlag
		justification_flags TextServer.JustificationFlag
		direction           TextServer.Direction
		orientation         TextServer.Orientation
	}{gdextension.Object(gd.ObjectChecked(font[0].AsObject())), pos, pointers.Get(gd.InternalString(text)), alignment, width, font_size, max_lines, size, modulate, brk_flags, justification_flags, direction, orientation}))
}

/*
Draws a string first character using a custom font.
*/
//go:nosplit
func (self class) DrawChar(font [1]gdclass.Font, pos Vector2.XY, char String.Readable, font_size int64, modulate Color.RGBA) { //gd:CanvasItem.draw_char
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.draw_char, 0|(gdextension.SizeObject<<4)|(gdextension.SizeVector2<<8)|(gdextension.SizeString<<12)|(gdextension.SizeInt<<16)|(gdextension.SizeColor<<20), unsafe.Pointer(&struct {
		font      gdextension.Object
		pos       Vector2.XY
		char      gdextension.String
		font_size int64
		modulate  Color.RGBA
	}{gdextension.Object(gd.ObjectChecked(font[0].AsObject())), pos, pointers.Get(gd.InternalString(char)), font_size, modulate}))
}

/*
Draws a string first character outline using a custom font.
*/
//go:nosplit
func (self class) DrawCharOutline(font [1]gdclass.Font, pos Vector2.XY, char String.Readable, font_size int64, size int64, modulate Color.RGBA) { //gd:CanvasItem.draw_char_outline
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.draw_char_outline, 0|(gdextension.SizeObject<<4)|(gdextension.SizeVector2<<8)|(gdextension.SizeString<<12)|(gdextension.SizeInt<<16)|(gdextension.SizeInt<<20)|(gdextension.SizeColor<<24), unsafe.Pointer(&struct {
		font      gdextension.Object
		pos       Vector2.XY
		char      gdextension.String
		font_size int64
		size      int64
		modulate  Color.RGBA
	}{gdextension.Object(gd.ObjectChecked(font[0].AsObject())), pos, pointers.Get(gd.InternalString(char)), font_size, size, modulate}))
}

/*
Draws a [Mesh] in 2D, using the provided texture. See [MeshInstance2D] for related documentation.
*/
//go:nosplit
func (self class) DrawMesh(mesh [1]gdclass.Mesh, texture [1]gdclass.Texture2D, transform Transform2D.OriginXY, modulate Color.RGBA) { //gd:CanvasItem.draw_mesh
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.draw_mesh, 0|(gdextension.SizeObject<<4)|(gdextension.SizeObject<<8)|(gdextension.SizeTransform2D<<12)|(gdextension.SizeColor<<16), unsafe.Pointer(&struct {
		mesh      gdextension.Object
		texture   gdextension.Object
		transform Transform2D.OriginXY
		modulate  Color.RGBA
	}{gdextension.Object(gd.ObjectChecked(mesh[0].AsObject())), gdextension.Object(gd.ObjectChecked(texture[0].AsObject())), transform, modulate}))
}

/*
Draws a [MultiMesh] in 2D with the provided texture. See [MultiMeshInstance2D] for related documentation.
*/
//go:nosplit
func (self class) DrawMultimesh(multimesh [1]gdclass.MultiMesh, texture [1]gdclass.Texture2D) { //gd:CanvasItem.draw_multimesh
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.draw_multimesh, 0|(gdextension.SizeObject<<4)|(gdextension.SizeObject<<8), unsafe.Pointer(&struct {
		multimesh gdextension.Object
		texture   gdextension.Object
	}{gdextension.Object(gd.ObjectChecked(multimesh[0].AsObject())), gdextension.Object(gd.ObjectChecked(texture[0].AsObject()))}))
}

/*
Sets a custom transform for drawing via components. Anything drawn afterwards will be transformed by this.
[b]Note:[/b] [member FontFile.oversampling] does [i]not[/i] take [param scale] into account. This means that scaling up/down will cause bitmap fonts and rasterized (non-MSDF) dynamic fonts to appear blurry or pixelated. To ensure text remains crisp regardless of scale, you can enable MSDF font rendering by enabling [member ProjectSettings.gui/theme/default_font_multichannel_signed_distance_field] (applies to the default project font only), or enabling [b]Multichannel Signed Distance Field[/b] in the import options of a DynamicFont for custom fonts. On system fonts, [member SystemFont.multichannel_signed_distance_field] can be enabled in the inspector.
*/
//go:nosplit
func (self class) DrawSetTransform(position Vector2.XY, rotation float64, scale Vector2.XY) { //gd:CanvasItem.draw_set_transform
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.draw_set_transform, 0|(gdextension.SizeVector2<<4)|(gdextension.SizeFloat<<8)|(gdextension.SizeVector2<<12), unsafe.Pointer(&struct {
		position Vector2.XY
		rotation float64
		scale    Vector2.XY
	}{position, rotation, scale}))
}

/*
Sets a custom transform for drawing via matrix. Anything drawn afterwards will be transformed by this.
*/
//go:nosplit
func (self class) DrawSetTransformMatrix(xform Transform2D.OriginXY) { //gd:CanvasItem.draw_set_transform_matrix
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.draw_set_transform_matrix, 0|(gdextension.SizeTransform2D<<4), unsafe.Pointer(&struct{ xform Transform2D.OriginXY }{xform}))
}

/*
Subsequent drawing commands will be ignored unless they fall within the specified animation slice. This is a faster way to implement animations that loop on background rather than redrawing constantly.
*/
//go:nosplit
func (self class) DrawAnimationSlice(animation_length float64, slice_begin float64, slice_end float64, offset float64) { //gd:CanvasItem.draw_animation_slice
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.draw_animation_slice, 0|(gdextension.SizeFloat<<4)|(gdextension.SizeFloat<<8)|(gdextension.SizeFloat<<12)|(gdextension.SizeFloat<<16), unsafe.Pointer(&struct {
		animation_length float64
		slice_begin      float64
		slice_end        float64
		offset           float64
	}{animation_length, slice_begin, slice_end, offset}))
}

/*
After submitting all animations slices via [method draw_animation_slice], this function can be used to revert drawing to its default state (all subsequent drawing commands will be visible). If you don't care about this particular use case, usage of this function after submitting the slices is not required.
*/
//go:nosplit
func (self class) DrawEndAnimation() { //gd:CanvasItem.draw_end_animation
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.draw_end_animation, 0, unsafe.Pointer(&struct{}{}))
}

/*
Returns the transform matrix of this item.
*/
//go:nosplit
func (self class) GetTransform() Transform2D.OriginXY { //gd:CanvasItem.get_transform
	var r_ret = gdextension.Call[Transform2D.OriginXY](gd.ObjectChecked(self.AsObject()), methods.get_transform, gdextension.SizeTransform2D, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the global transform matrix of this item, i.e. the combined transform up to the topmost [CanvasItem] node. The topmost item is a [CanvasItem] that either has no parent, has non-[CanvasItem] parent or it has [member top_level] enabled.
*/
//go:nosplit
func (self class) GetGlobalTransform() Transform2D.OriginXY { //gd:CanvasItem.get_global_transform
	var r_ret = gdextension.Call[Transform2D.OriginXY](gd.ObjectChecked(self.AsObject()), methods.get_global_transform, gdextension.SizeTransform2D, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the transform from the local coordinate system of this [CanvasItem] to the [Viewport]s coordinate system.
*/
//go:nosplit
func (self class) GetGlobalTransformWithCanvas() Transform2D.OriginXY { //gd:CanvasItem.get_global_transform_with_canvas
	var r_ret = gdextension.Call[Transform2D.OriginXY](gd.ObjectChecked(self.AsObject()), methods.get_global_transform_with_canvas, gdextension.SizeTransform2D, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the transform from the coordinate system of the canvas, this item is in, to the [Viewport]s embedders coordinate system.
*/
//go:nosplit
func (self class) GetViewportTransform() Transform2D.OriginXY { //gd:CanvasItem.get_viewport_transform
	var r_ret = gdextension.Call[Transform2D.OriginXY](gd.ObjectChecked(self.AsObject()), methods.get_viewport_transform, gdextension.SizeTransform2D, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the viewport's boundaries as a [Rect2].
*/
//go:nosplit
func (self class) GetViewportRect() Rect2.PositionSize { //gd:CanvasItem.get_viewport_rect
	var r_ret = gdextension.Call[Rect2.PositionSize](gd.ObjectChecked(self.AsObject()), methods.get_viewport_rect, gdextension.SizeRect2, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the transform from the coordinate system of the canvas, this item is in, to the [Viewport]s coordinate system.
*/
//go:nosplit
func (self class) GetCanvasTransform() Transform2D.OriginXY { //gd:CanvasItem.get_canvas_transform
	var r_ret = gdextension.Call[Transform2D.OriginXY](gd.ObjectChecked(self.AsObject()), methods.get_canvas_transform, gdextension.SizeTransform2D, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the transform of this [CanvasItem] in global screen coordinates (i.e. taking window position into account). Mostly useful for editor plugins.
Equals to [method get_global_transform] if the window is embedded (see [member Viewport.gui_embed_subwindows]).
*/
//go:nosplit
func (self class) GetScreenTransform() Transform2D.OriginXY { //gd:CanvasItem.get_screen_transform
	var r_ret = gdextension.Call[Transform2D.OriginXY](gd.ObjectChecked(self.AsObject()), methods.get_screen_transform, gdextension.SizeTransform2D, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the mouse's position in this [CanvasItem] using the local coordinate system of this [CanvasItem].
*/
//go:nosplit
func (self class) GetLocalMousePosition() Vector2.XY { //gd:CanvasItem.get_local_mouse_position
	var r_ret = gdextension.Call[Vector2.XY](gd.ObjectChecked(self.AsObject()), methods.get_local_mouse_position, gdextension.SizeVector2, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the mouse's position in the [CanvasLayer] that this [CanvasItem] is in using the coordinate system of the [CanvasLayer].
[b]Note:[/b] For screen-space coordinates (e.g. when using a non-embedded [Popup]), you can use [method DisplayServer.mouse_get_position].
*/
//go:nosplit
func (self class) GetGlobalMousePosition() Vector2.XY { //gd:CanvasItem.get_global_mouse_position
	var r_ret = gdextension.Call[Vector2.XY](gd.ObjectChecked(self.AsObject()), methods.get_global_mouse_position, gdextension.SizeVector2, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the [RID] of the [World2D] canvas where this item is in.
*/
//go:nosplit
func (self class) GetCanvas() RID.Any { //gd:CanvasItem.get_canvas
	var r_ret = gdextension.Call[RID.Any](gd.ObjectChecked(self.AsObject()), methods.get_canvas, gdextension.SizeRID, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the [CanvasLayer] that contains this node, or [code]null[/code] if the node is not in any [CanvasLayer].
*/
//go:nosplit
func (self class) GetCanvasLayerNode() [1]gdclass.CanvasLayer { //gd:CanvasItem.get_canvas_layer_node
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_canvas_layer_node, gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.CanvasLayer{gd.PointerLifetimeBoundTo[gdclass.CanvasLayer](self.AsObject(), r_ret)}
	return ret
}

/*
Returns the [World2D] where this item is in.
*/
//go:nosplit
func (self class) GetWorld2d() [1]gdclass.World2D { //gd:CanvasItem.get_world_2d
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_world_2d, gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.World2D{gd.PointerWithOwnershipTransferredToGo[gdclass.World2D](r_ret)}
	return ret
}

//go:nosplit
func (self class) SetMaterial(material [1]gdclass.Material) { //gd:CanvasItem.set_material
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_material, 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ material gdextension.Object }{gdextension.Object(gd.ObjectChecked(material[0].AsObject()))}))
}

//go:nosplit
func (self class) GetMaterial() [1]gdclass.Material { //gd:CanvasItem.get_material
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_material, gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.Material{gd.PointerWithOwnershipTransferredToGo[gdclass.Material](r_ret)}
	return ret
}

/*
Set the value of a shader uniform for this instance only ([url=$DOCS_URL/tutorials/shaders/shader_reference/shading_language.html#per-instance-uniforms]per-instance uniform[/url]). See also [method ShaderMaterial.set_shader_parameter] to assign a uniform on all instances using the same [ShaderMaterial].
[b]Note:[/b] For a shader uniform to be assignable on a per-instance basis, it [i]must[/i] be defined with [code]instance uniform ...[/code] rather than [code]uniform ...[/code] in the shader code.
[b]Note:[/b] [param name] is case-sensitive and must match the name of the uniform in the code exactly (not the capitalized name in the inspector).
*/
//go:nosplit
func (self class) SetInstanceShaderParameter(name String.Name, value variant.Any) { //gd:CanvasItem.set_instance_shader_parameter
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_instance_shader_parameter, 0|(gdextension.SizeStringName<<4)|(gdextension.SizeVariant<<8), unsafe.Pointer(&struct {
		name  gdextension.StringName
		value gdextension.Variant
	}{pointers.Get(gd.InternalStringName(name)), gdextension.Variant(pointers.Get(gd.InternalVariant(value)))}))
}

/*
Get the value of a shader parameter as set on this instance.
*/
//go:nosplit
func (self class) GetInstanceShaderParameter(name String.Name) variant.Any { //gd:CanvasItem.get_instance_shader_parameter
	var r_ret = gdextension.Call[gdextension.Variant](gd.ObjectChecked(self.AsObject()), methods.get_instance_shader_parameter, gdextension.SizeVariant|(gdextension.SizeStringName<<4), unsafe.Pointer(&struct{ name gdextension.StringName }{pointers.Get(gd.InternalStringName(name))}))
	var ret = variant.Implementation(gd.VariantProxy{}, pointers.Pack(pointers.New[gd.Variant](r_ret)))
	return ret
}

//go:nosplit
func (self class) SetUseParentMaterial(enable bool) { //gd:CanvasItem.set_use_parent_material
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_use_parent_material, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

//go:nosplit
func (self class) GetUseParentMaterial() bool { //gd:CanvasItem.get_use_parent_material
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.get_use_parent_material, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
If [param enable] is [code]true[/code], this node will receive [constant NOTIFICATION_LOCAL_TRANSFORM_CHANGED] when its local transform changes.
*/
//go:nosplit
func (self class) SetNotifyLocalTransform(enable bool) { //gd:CanvasItem.set_notify_local_transform
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_notify_local_transform, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

/*
Returns [code]true[/code] if local transform notifications are communicated to children.
*/
//go:nosplit
func (self class) IsLocalTransformNotificationEnabled() bool { //gd:CanvasItem.is_local_transform_notification_enabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_local_transform_notification_enabled, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
If [param enable] is [code]true[/code], this node will receive [constant NOTIFICATION_TRANSFORM_CHANGED] when its global transform changes.
*/
//go:nosplit
func (self class) SetNotifyTransform(enable bool) { //gd:CanvasItem.set_notify_transform
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_notify_transform, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

/*
Returns [code]true[/code] if global transform notifications are communicated to children.
*/
//go:nosplit
func (self class) IsTransformNotificationEnabled() bool { //gd:CanvasItem.is_transform_notification_enabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_transform_notification_enabled, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Forces the transform to update. Transform changes in physics are not instant for performance reasons. Transforms are accumulated and then set. Use this if you need an up-to-date transform when doing physics operations.
*/
//go:nosplit
func (self class) ForceUpdateTransform() { //gd:CanvasItem.force_update_transform
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.force_update_transform, 0, unsafe.Pointer(&struct{}{}))
}

/*
Transforms [param viewport_point] from the viewport's coordinates to this node's local coordinates.
For the opposite operation, use [method get_global_transform_with_canvas].
[codeblock]
var viewport_point = get_global_transform_with_canvas() * local_point
[/codeblock]
*/
//go:nosplit
func (self class) MakeCanvasPositionLocal(viewport_point Vector2.XY) Vector2.XY { //gd:CanvasItem.make_canvas_position_local
	var r_ret = gdextension.Call[Vector2.XY](gd.ObjectChecked(self.AsObject()), methods.make_canvas_position_local, gdextension.SizeVector2|(gdextension.SizeVector2<<4), unsafe.Pointer(&struct{ viewport_point Vector2.XY }{viewport_point}))
	var ret = r_ret
	return ret
}

/*
Transformations issued by [param event]'s inputs are applied in local space instead of global space.
*/
//go:nosplit
func (self class) MakeInputLocal(event [1]gdclass.InputEvent) [1]gdclass.InputEvent { //gd:CanvasItem.make_input_local
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.make_input_local, gdextension.SizeObject|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ event gdextension.Object }{gdextension.Object(gd.ObjectChecked(event[0].AsObject()))}))
	var ret = [1]gdclass.InputEvent{gd.PointerWithOwnershipTransferredToGo[gdclass.InputEvent](r_ret)}
	return ret
}

//go:nosplit
func (self class) SetVisibilityLayer(layer int64) { //gd:CanvasItem.set_visibility_layer
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_visibility_layer, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ layer int64 }{layer}))
}

//go:nosplit
func (self class) GetVisibilityLayer() int64 { //gd:CanvasItem.get_visibility_layer
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_visibility_layer, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Set/clear individual bits on the rendering visibility layer. This simplifies editing this [CanvasItem]'s visibility layer.
*/
//go:nosplit
func (self class) SetVisibilityLayerBit(layer int64, enabled bool) { //gd:CanvasItem.set_visibility_layer_bit
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_visibility_layer_bit, 0|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		layer   int64
		enabled bool
	}{layer, enabled}))
}

/*
Returns an individual bit on the rendering visibility layer.
*/
//go:nosplit
func (self class) GetVisibilityLayerBit(layer int64) bool { //gd:CanvasItem.get_visibility_layer_bit
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.get_visibility_layer_bit, gdextension.SizeBool|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ layer int64 }{layer}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetTextureFilter(mode TextureFilter) { //gd:CanvasItem.set_texture_filter
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_texture_filter, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ mode TextureFilter }{mode}))
}

//go:nosplit
func (self class) GetTextureFilter() TextureFilter { //gd:CanvasItem.get_texture_filter
	var r_ret = gdextension.Call[TextureFilter](gd.ObjectChecked(self.AsObject()), methods.get_texture_filter, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetTextureRepeat(mode TextureRepeat) { //gd:CanvasItem.set_texture_repeat
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_texture_repeat, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ mode TextureRepeat }{mode}))
}

//go:nosplit
func (self class) GetTextureRepeat() TextureRepeat { //gd:CanvasItem.get_texture_repeat
	var r_ret = gdextension.Call[TextureRepeat](gd.ObjectChecked(self.AsObject()), methods.get_texture_repeat, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetClipChildrenMode(mode ClipChildrenMode) { //gd:CanvasItem.set_clip_children_mode
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_clip_children_mode, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ mode ClipChildrenMode }{mode}))
}

//go:nosplit
func (self class) GetClipChildrenMode() ClipChildrenMode { //gd:CanvasItem.get_clip_children_mode
	var r_ret = gdextension.Call[ClipChildrenMode](gd.ObjectChecked(self.AsObject()), methods.get_clip_children_mode, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}
func (self Instance) OnDraw(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("draw"), gd.NewCallable(cb), 0)
}

func (self Instance) OnVisibilityChanged(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("visibility_changed"), gd.NewCallable(cb), 0)
}

func (self Instance) OnHidden(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("hidden"), gd.NewCallable(cb), 0)
}

func (self Instance) OnItemRectChanged(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("item_rect_changed"), gd.NewCallable(cb), 0)
}

func (self class) AsCanvasItem() Advanced         { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsCanvasItem() Instance      { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsCanvasItem() Instance { return self.Super().AsCanvasItem() }
func (self class) AsNode() Node.Advanced          { return *((*Node.Advanced)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsNode() Node.Instance  { return self.Super().AsNode() }
func (self Instance) AsNode() Node.Instance       { return *((*Node.Instance)(unsafe.Pointer(&self))) }

func (self class) Virtual(name string) reflect.Value {
	switch name {
	case "_draw":
		return reflect.ValueOf(self._draw)
	default:
		return gd.VirtualByName(Node.Advanced(self.AsNode()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	case "_draw":
		return reflect.ValueOf(self._draw)
	default:
		return gd.VirtualByName(Node.Instance(self.AsNode()), name)
	}
}
func init() {
	gdclass.Register("CanvasItem", func(ptr gd.Object) any { return *(*Instance)(unsafe.Pointer(&ptr)) })
}

type TextureFilter int //gd:CanvasItem.TextureFilter

const (
	/*The [CanvasItem] will inherit the filter from its parent.*/
	TextureFilterParentNode TextureFilter = 0
	/*The texture filter reads from the nearest pixel only. This makes the texture look pixelated from up close, and grainy from a distance (due to mipmaps not being sampled).*/
	TextureFilterNearest TextureFilter = 1
	/*The texture filter blends between the nearest 4 pixels. This makes the texture look smooth from up close, and grainy from a distance (due to mipmaps not being sampled).*/
	TextureFilterLinear TextureFilter = 2
	/*The texture filter reads from the nearest pixel and blends between the nearest 2 mipmaps (or uses the nearest mipmap if [member ProjectSettings.rendering/textures/default_filters/use_nearest_mipmap_filter] is [code]true[/code]). This makes the texture look pixelated from up close, and smooth from a distance.
	  Use this for non-pixel art textures that may be viewed at a low scale (e.g. due to [Camera2D] zoom or sprite scaling), as mipmaps are important to smooth out pixels that are smaller than on-screen pixels.*/
	TextureFilterNearestWithMipmaps TextureFilter = 3
	/*The texture filter blends between the nearest 4 pixels and between the nearest 2 mipmaps (or uses the nearest mipmap if [member ProjectSettings.rendering/textures/default_filters/use_nearest_mipmap_filter] is [code]true[/code]). This makes the texture look smooth from up close, and smooth from a distance.
	  Use this for non-pixel art textures that may be viewed at a low scale (e.g. due to [Camera2D] zoom or sprite scaling), as mipmaps are important to smooth out pixels that are smaller than on-screen pixels.*/
	TextureFilterLinearWithMipmaps TextureFilter = 4
	/*The texture filter reads from the nearest pixel and blends between 2 mipmaps (or uses the nearest mipmap if [member ProjectSettings.rendering/textures/default_filters/use_nearest_mipmap_filter] is [code]true[/code]) based on the angle between the surface and the camera view. This makes the texture look pixelated from up close, and smooth from a distance. Anisotropic filtering improves texture quality on surfaces that are almost in line with the camera, but is slightly slower. The anisotropic filtering level can be changed by adjusting [member ProjectSettings.rendering/textures/default_filters/anisotropic_filtering_level].
	  [b]Note:[/b] This texture filter is rarely useful in 2D projects. [constant TEXTURE_FILTER_NEAREST_WITH_MIPMAPS] is usually more appropriate in this case.*/
	TextureFilterNearestWithMipmapsAnisotropic TextureFilter = 5
	/*The texture filter blends between the nearest 4 pixels and blends between 2 mipmaps (or uses the nearest mipmap if [member ProjectSettings.rendering/textures/default_filters/use_nearest_mipmap_filter] is [code]true[/code]) based on the angle between the surface and the camera view. This makes the texture look smooth from up close, and smooth from a distance. Anisotropic filtering improves texture quality on surfaces that are almost in line with the camera, but is slightly slower. The anisotropic filtering level can be changed by adjusting [member ProjectSettings.rendering/textures/default_filters/anisotropic_filtering_level].
	  [b]Note:[/b] This texture filter is rarely useful in 2D projects. [constant TEXTURE_FILTER_LINEAR_WITH_MIPMAPS] is usually more appropriate in this case.*/
	TextureFilterLinearWithMipmapsAnisotropic TextureFilter = 6
	/*Represents the size of the [enum TextureFilter] enum.*/
	TextureFilterMax TextureFilter = 7
)

type TextureRepeat int //gd:CanvasItem.TextureRepeat

const (
	/*The [CanvasItem] will inherit the filter from its parent.*/
	TextureRepeatParentNode TextureRepeat = 0
	/*Texture will not repeat.*/
	TextureRepeatDisabled TextureRepeat = 1
	/*Texture will repeat normally.*/
	TextureRepeatEnabled TextureRepeat = 2
	/*Texture will repeat in a 2×2 tiled mode, where elements at even positions are mirrored.*/
	TextureRepeatMirror TextureRepeat = 3
	/*Represents the size of the [enum TextureRepeat] enum.*/
	TextureRepeatMax TextureRepeat = 4
)

type ClipChildrenMode int //gd:CanvasItem.ClipChildrenMode

const (
	/*Child draws over parent and is not clipped.*/
	ClipChildrenDisabled ClipChildrenMode = 0
	/*Parent is used for the purposes of clipping only. Child is clipped to the parent's visible area, parent is not drawn.*/
	ClipChildrenOnly ClipChildrenMode = 1
	/*Parent is used for clipping child, but parent is also drawn underneath child as normal before clipping child to its visible area.*/
	ClipChildrenAndDraw ClipChildrenMode = 2
	/*Represents the size of the [enum ClipChildrenMode] enum.*/
	ClipChildrenMax ClipChildrenMode = 3
)
const NotificationTransformChanged Object.Notification = 2000    //gd:CanvasItem.NOTIFICATION_TRANSFORM_CHANGED
const NotificationLocalTransformChanged Object.Notification = 35 //gd:CanvasItem.NOTIFICATION_LOCAL_TRANSFORM_CHANGED
const NotificationDraw Object.Notification = 30                  //gd:CanvasItem.NOTIFICATION_DRAW
const NotificationVisibilityChanged Object.Notification = 31     //gd:CanvasItem.NOTIFICATION_VISIBILITY_CHANGED
const NotificationEnterCanvas Object.Notification = 32           //gd:CanvasItem.NOTIFICATION_ENTER_CANVAS
const NotificationExitCanvas Object.Notification = 33            //gd:CanvasItem.NOTIFICATION_EXIT_CANVAS
const NotificationWorld2dChanged Object.Notification = 36        //gd:CanvasItem.NOTIFICATION_WORLD_2D_CHANGED
