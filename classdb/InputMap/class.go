// Code generated by the generate package DO NOT EDIT

// Package InputMap provides methods for working with InputMap object instances.
package InputMap

import "unsafe"
import "sync"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdunsafe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/InputEvent"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = gdunsafe.Use{}
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
Manages all [InputEventAction] which can be created/modified from the project settings menu [b]Project > Project Settings > Input Map[/b] or in code with [method add_action] and [method action_add_event]. See [method Node._input].
*/
type Instance [1]gdclass.InputMap

func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

var self [1]gdclass.InputMap
var once sync.Once

func singleton() {
	obj := gd.Global.Object.GetSingleton(gd.Global.Singletons.InputMap)
	self = *(*[1]gdclass.InputMap)(unsafe.Pointer(&obj))
}

/*
Returns [code]true[/code] if the [InputMap] has a registered action with the given name.
*/
func HasAction(action string) bool { //gd:InputMap.has_action
	once.Do(singleton)
	return bool(Advanced().HasAction(String.Name(String.New(action))))
}

/*
Returns an array of all actions in the [InputMap].
*/
func GetActions() []string { //gd:InputMap.get_actions
	once.Do(singleton)
	return []string(gd.ArrayAs[[]string](gd.InternalArray(Advanced().GetActions())))
}

/*
Adds an empty action to the [InputMap] with a configurable [param deadzone].
An [InputEvent] can then be added to this action with [method action_add_event].
*/
func AddAction(action string) { //gd:InputMap.add_action
	once.Do(singleton)
	Advanced().AddAction(String.Name(String.New(action)), float64(0.2))
}

/*
Adds an empty action to the [InputMap] with a configurable [param deadzone].
An [InputEvent] can then be added to this action with [method action_add_event].
*/
func AddActionOptions(action string, deadzone Float.X) { //gd:InputMap.add_action
	once.Do(singleton)
	Advanced().AddAction(String.Name(String.New(action)), float64(deadzone))
}

/*
Removes an action from the [InputMap].
*/
func EraseAction(action string) { //gd:InputMap.erase_action
	once.Do(singleton)
	Advanced().EraseAction(String.Name(String.New(action)))
}

/*
Sets a deadzone value for the action.
*/
func ActionSetDeadzone(action string, deadzone Float.X) { //gd:InputMap.action_set_deadzone
	once.Do(singleton)
	Advanced().ActionSetDeadzone(String.Name(String.New(action)), float64(deadzone))
}

/*
Returns a deadzone value for the action.
*/
func ActionGetDeadzone(action string) Float.X { //gd:InputMap.action_get_deadzone
	once.Do(singleton)
	return Float.X(Float.X(Advanced().ActionGetDeadzone(String.Name(String.New(action)))))
}

/*
Adds an [InputEvent] to an action. This [InputEvent] will trigger the action.
*/
func ActionAddEvent(action string, event InputEvent.Instance) { //gd:InputMap.action_add_event
	once.Do(singleton)
	Advanced().ActionAddEvent(String.Name(String.New(action)), event)
}

/*
Returns [code]true[/code] if the action has the given [InputEvent] associated with it.
*/
func ActionHasEvent(action string, event InputEvent.Instance) bool { //gd:InputMap.action_has_event
	once.Do(singleton)
	return bool(Advanced().ActionHasEvent(String.Name(String.New(action)), event))
}

/*
Removes an [InputEvent] from an action.
*/
func ActionEraseEvent(action string, event InputEvent.Instance) { //gd:InputMap.action_erase_event
	once.Do(singleton)
	Advanced().ActionEraseEvent(String.Name(String.New(action)), event)
}

/*
Removes all events from an action.
*/
func ActionEraseEvents(action string) { //gd:InputMap.action_erase_events
	once.Do(singleton)
	Advanced().ActionEraseEvents(String.Name(String.New(action)))
}

/*
Returns an array of [InputEvent]s associated with a given action.
[b]Note:[/b] When used in the editor (e.g. a tool script or [EditorPlugin]), this method will return events for the editor action. If you want to access your project's input binds from the editor, read the [code]input/*[/code] settings from [ProjectSettings].
*/
func ActionGetEvents(action string) []InputEvent.Instance { //gd:InputMap.action_get_events
	once.Do(singleton)
	return []InputEvent.Instance(gd.ArrayAs[[]InputEvent.Instance](gd.InternalArray(Advanced().ActionGetEvents(String.Name(String.New(action))))))
}

/*
Returns [code]true[/code] if the given event is part of an existing action. This method ignores keyboard modifiers if the given [InputEvent] is not pressed (for proper release detection). See [method action_has_event] if you don't want this behavior.
If [param exact_match] is [code]false[/code], it ignores additional input modifiers for [InputEventKey] and [InputEventMouseButton] events, and the direction for [InputEventJoypadMotion] events.
*/
func EventIsAction(event InputEvent.Instance, action string, exact_match bool) bool { //gd:InputMap.event_is_action
	once.Do(singleton)
	return bool(Advanced().EventIsAction(event, String.Name(String.New(action)), exact_match))
}

/*
Returns [code]true[/code] if the given event is part of an existing action. This method ignores keyboard modifiers if the given [InputEvent] is not pressed (for proper release detection). See [method action_has_event] if you don't want this behavior.
If [param exact_match] is [code]false[/code], it ignores additional input modifiers for [InputEventKey] and [InputEventMouseButton] events, and the direction for [InputEventJoypadMotion] events.
*/
func EventIsActionOptions(event InputEvent.Instance, action string, exact_match bool) bool { //gd:InputMap.event_is_action
	once.Do(singleton)
	return bool(Advanced().EventIsAction(event, String.Name(String.New(action)), exact_match))
}

/*
Clears all [InputEventAction] in the [InputMap] and load it anew from [ProjectSettings].
*/
func LoadFromProjectSettings() { //gd:InputMap.load_from_project_settings
	once.Do(singleton)
	Advanced().LoadFromProjectSettings()
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
func Advanced() class { once.Do(singleton); return self }

type class [1]gdclass.InputMap

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }

/*
Returns [code]true[/code] if the [InputMap] has a registered action with the given name.
*/
//go:nosplit
func (self class) HasAction(action String.Name) bool { //gd:InputMap.has_action
	var r_ret = gdunsafe.Call[bool](self.AsObject(), gd.Global.Methods.InputMap.Bind_has_action, gdextension.SizeBool|(gdextension.SizeStringName<<4), unsafe.Pointer(&struct{ action gdextension.StringName }{gdextension.StringName(pointers.Get(gd.InternalStringName(action))[0])}))
	var ret = r_ret
	return ret
}

/*
Returns an array of all actions in the [InputMap].
*/
//go:nosplit
func (self class) GetActions() Array.Contains[String.Name] { //gd:InputMap.get_actions
	var r_ret = gdunsafe.Call[[1]gd.EnginePointer](self.AsObject(), gd.Global.Methods.InputMap.Bind_get_actions, gdextension.SizeArray, unsafe.Pointer(&struct{}{}))
	var ret = Array.Through(gd.ArrayProxy[String.Name]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

/*
Adds an empty action to the [InputMap] with a configurable [param deadzone].
An [InputEvent] can then be added to this action with [method action_add_event].
*/
//go:nosplit
func (self class) AddAction(action String.Name, deadzone float64) { //gd:InputMap.add_action
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.InputMap.Bind_add_action, 0|(gdextension.SizeStringName<<4)|(gdextension.SizeFloat<<8), unsafe.Pointer(&struct {
		action   gdextension.StringName
		deadzone float64
	}{gdextension.StringName(pointers.Get(gd.InternalStringName(action))[0]), deadzone}))
}

/*
Removes an action from the [InputMap].
*/
//go:nosplit
func (self class) EraseAction(action String.Name) { //gd:InputMap.erase_action
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.InputMap.Bind_erase_action, 0|(gdextension.SizeStringName<<4), unsafe.Pointer(&struct{ action gdextension.StringName }{gdextension.StringName(pointers.Get(gd.InternalStringName(action))[0])}))
}

/*
Sets a deadzone value for the action.
*/
//go:nosplit
func (self class) ActionSetDeadzone(action String.Name, deadzone float64) { //gd:InputMap.action_set_deadzone
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.InputMap.Bind_action_set_deadzone, 0|(gdextension.SizeStringName<<4)|(gdextension.SizeFloat<<8), unsafe.Pointer(&struct {
		action   gdextension.StringName
		deadzone float64
	}{gdextension.StringName(pointers.Get(gd.InternalStringName(action))[0]), deadzone}))
}

/*
Returns a deadzone value for the action.
*/
//go:nosplit
func (self class) ActionGetDeadzone(action String.Name) float64 { //gd:InputMap.action_get_deadzone
	var r_ret = gdunsafe.Call[float64](self.AsObject(), gd.Global.Methods.InputMap.Bind_action_get_deadzone, gdextension.SizeFloat|(gdextension.SizeStringName<<4), unsafe.Pointer(&struct{ action gdextension.StringName }{gdextension.StringName(pointers.Get(gd.InternalStringName(action))[0])}))
	var ret = r_ret
	return ret
}

/*
Adds an [InputEvent] to an action. This [InputEvent] will trigger the action.
*/
//go:nosplit
func (self class) ActionAddEvent(action String.Name, event [1]gdclass.InputEvent) { //gd:InputMap.action_add_event
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.InputMap.Bind_action_add_event, 0|(gdextension.SizeStringName<<4)|(gdextension.SizeObject<<8), unsafe.Pointer(&struct {
		action gdextension.StringName
		event  gdextension.Object
	}{gdextension.StringName(pointers.Get(gd.InternalStringName(action))[0]), gdextension.Object(pointers.Get(event[0])[0])}))
}

/*
Returns [code]true[/code] if the action has the given [InputEvent] associated with it.
*/
//go:nosplit
func (self class) ActionHasEvent(action String.Name, event [1]gdclass.InputEvent) bool { //gd:InputMap.action_has_event
	var r_ret = gdunsafe.Call[bool](self.AsObject(), gd.Global.Methods.InputMap.Bind_action_has_event, gdextension.SizeBool|(gdextension.SizeStringName<<4)|(gdextension.SizeObject<<8), unsafe.Pointer(&struct {
		action gdextension.StringName
		event  gdextension.Object
	}{gdextension.StringName(pointers.Get(gd.InternalStringName(action))[0]), gdextension.Object(pointers.Get(event[0])[0])}))
	var ret = r_ret
	return ret
}

/*
Removes an [InputEvent] from an action.
*/
//go:nosplit
func (self class) ActionEraseEvent(action String.Name, event [1]gdclass.InputEvent) { //gd:InputMap.action_erase_event
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.InputMap.Bind_action_erase_event, 0|(gdextension.SizeStringName<<4)|(gdextension.SizeObject<<8), unsafe.Pointer(&struct {
		action gdextension.StringName
		event  gdextension.Object
	}{gdextension.StringName(pointers.Get(gd.InternalStringName(action))[0]), gdextension.Object(pointers.Get(event[0])[0])}))
}

/*
Removes all events from an action.
*/
//go:nosplit
func (self class) ActionEraseEvents(action String.Name) { //gd:InputMap.action_erase_events
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.InputMap.Bind_action_erase_events, 0|(gdextension.SizeStringName<<4), unsafe.Pointer(&struct{ action gdextension.StringName }{gdextension.StringName(pointers.Get(gd.InternalStringName(action))[0])}))
}

/*
Returns an array of [InputEvent]s associated with a given action.
[b]Note:[/b] When used in the editor (e.g. a tool script or [EditorPlugin]), this method will return events for the editor action. If you want to access your project's input binds from the editor, read the [code]input/*[/code] settings from [ProjectSettings].
*/
//go:nosplit
func (self class) ActionGetEvents(action String.Name) Array.Contains[[1]gdclass.InputEvent] { //gd:InputMap.action_get_events
	var r_ret = gdunsafe.Call[[1]gd.EnginePointer](self.AsObject(), gd.Global.Methods.InputMap.Bind_action_get_events, gdextension.SizeArray|(gdextension.SizeStringName<<4), unsafe.Pointer(&struct{ action gdextension.StringName }{gdextension.StringName(pointers.Get(gd.InternalStringName(action))[0])}))
	var ret = Array.Through(gd.ArrayProxy[[1]gdclass.InputEvent]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

/*
Returns [code]true[/code] if the given event is part of an existing action. This method ignores keyboard modifiers if the given [InputEvent] is not pressed (for proper release detection). See [method action_has_event] if you don't want this behavior.
If [param exact_match] is [code]false[/code], it ignores additional input modifiers for [InputEventKey] and [InputEventMouseButton] events, and the direction for [InputEventJoypadMotion] events.
*/
//go:nosplit
func (self class) EventIsAction(event [1]gdclass.InputEvent, action String.Name, exact_match bool) bool { //gd:InputMap.event_is_action
	var r_ret = gdunsafe.Call[bool](self.AsObject(), gd.Global.Methods.InputMap.Bind_event_is_action, gdextension.SizeBool|(gdextension.SizeObject<<4)|(gdextension.SizeStringName<<8)|(gdextension.SizeBool<<12), unsafe.Pointer(&struct {
		event       gdextension.Object
		action      gdextension.StringName
		exact_match bool
	}{gdextension.Object(pointers.Get(event[0])[0]), gdextension.StringName(pointers.Get(gd.InternalStringName(action))[0]), exact_match}))
	var ret = r_ret
	return ret
}

/*
Clears all [InputEventAction] in the [InputMap] and load it anew from [ProjectSettings].
*/
//go:nosplit
func (self class) LoadFromProjectSettings() { //gd:InputMap.load_from_project_settings
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.InputMap.Bind_load_from_project_settings, 0, unsafe.Pointer(&struct{}{}))
}
func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Object.Advanced(self.AsObject()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Object.Instance(self.AsObject()), name)
	}
}
func init() {
	gdclass.Register("InputMap", func(ptr gd.Object) any { return [1]gdclass.InputMap{*(*gdclass.InputMap)(unsafe.Pointer(&ptr))} })
}
