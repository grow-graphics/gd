// Code generated by the generate package DO NOT EDIT

// Package WebSocketPeer provides methods for working with WebSocketPeer object instances.
package WebSocketPeer

import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/variant/Signal"
import "graphics.gd/classdb/PacketPeer"
import "graphics.gd/classdb/StreamPeer"
import "graphics.gd/classdb/TLSOptions"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Signal.Any
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
This class represents WebSocket connection, and can be used as a WebSocket client (RFC 6455-compliant) or as a remote peer of a WebSocket server.
You can send WebSocket binary frames using [method PacketPeer.put_packet], and WebSocket text frames using [method send] (prefer text frames when interacting with text-based API). You can check the frame type of the last packet via [method was_string_packet].
To start a WebSocket client, first call [method connect_to_url], then regularly call [method poll] (e.g. during [Node] process). You can query the socket state via [method get_ready_state], get the number of pending packets using [method PacketPeer.get_available_packet_count], and retrieve them via [method PacketPeer.get_packet].
[codeblocks]
[gdscript]
extends Node

var socket = WebSocketPeer.new()

func _ready():

	socket.connect_to_url("wss://example.com")

func _process(delta):

	socket.poll()
	var state = socket.get_ready_state()
	if state == WebSocketPeer.STATE_OPEN:
	    while socket.get_available_packet_count():
	        print("Packet: ", socket.get_packet())
	elif state == WebSocketPeer.STATE_CLOSING:
	    # Keep polling to achieve proper close.
	    pass
	elif state == WebSocketPeer.STATE_CLOSED:
	    var code = socket.get_close_code()
	    var reason = socket.get_close_reason()
	    print("WebSocket closed with code: %d, reason %s. Clean: %s" % [code, reason, code != -1])
	    set_process(false) # Stop processing.

[/gdscript]
[/codeblocks]
To use the peer as part of a WebSocket server refer to [method accept_stream] and the online tutorial.
*/
type Instance [1]gdclass.WebSocketPeer

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	connect_to_url                       gdextension.MethodForClass `hash:"1966198364"`
	accept_stream                        gdextension.MethodForClass `hash:"255125695"`
	send                                 gdextension.MethodForClass `hash:"2780360567"`
	send_text                            gdextension.MethodForClass `hash:"166001499"`
	was_string_packet                    gdextension.MethodForClass `hash:"36873697"`
	poll                                 gdextension.MethodForClass `hash:"3218959716"`
	close                                gdextension.MethodForClass `hash:"1047156615"`
	get_connected_host                   gdextension.MethodForClass `hash:"201670096"`
	get_connected_port                   gdextension.MethodForClass `hash:"3905245786"`
	get_selected_protocol                gdextension.MethodForClass `hash:"201670096"`
	get_requested_url                    gdextension.MethodForClass `hash:"201670096"`
	set_no_delay                         gdextension.MethodForClass `hash:"2586408642"`
	get_current_outbound_buffered_amount gdextension.MethodForClass `hash:"3905245786"`
	get_ready_state                      gdextension.MethodForClass `hash:"346482985"`
	get_close_code                       gdextension.MethodForClass `hash:"3905245786"`
	get_close_reason                     gdextension.MethodForClass `hash:"201670096"`
	get_supported_protocols              gdextension.MethodForClass `hash:"1139954409"`
	set_supported_protocols              gdextension.MethodForClass `hash:"4015028928"`
	get_handshake_headers                gdextension.MethodForClass `hash:"1139954409"`
	set_handshake_headers                gdextension.MethodForClass `hash:"4015028928"`
	get_inbound_buffer_size              gdextension.MethodForClass `hash:"3905245786"`
	set_inbound_buffer_size              gdextension.MethodForClass `hash:"1286410249"`
	get_outbound_buffer_size             gdextension.MethodForClass `hash:"3905245786"`
	set_outbound_buffer_size             gdextension.MethodForClass `hash:"1286410249"`
	set_max_queued_packets               gdextension.MethodForClass `hash:"1286410249"`
	get_max_queued_packets               gdextension.MethodForClass `hash:"3905245786"`
	set_heartbeat_interval               gdextension.MethodForClass `hash:"373806689"`
	get_heartbeat_interval               gdextension.MethodForClass `hash:"1740695150"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("WebSocketPeer")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		gdextension.Free(gdextension.TypeStringName, &sname)
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

type Expanded [1]gdclass.WebSocketPeer

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsWebSocketPeer() Instance
}

/*
Connects to the given URL. TLS certificates will be verified against the hostname when connecting using the [code]wss://[/code] protocol. You can pass the optional [param tls_client_options] parameter to customize the trusted certification authorities, or disable the common name verification. See [method TLSOptions.client] and [method TLSOptions.client_unsafe].
[b]Note:[/b] This method is non-blocking, and will return [constant OK] before the connection is established as long as the provided parameters are valid and the peer is not in an invalid state (e.g. already connected). Regularly call [method poll] (e.g. during [Node] process) and check the result of [method get_ready_state] to know whether the connection succeeds or fails.
[b]Note:[/b] To avoid mixed content warnings or errors in Web, you may have to use a [param url] that starts with [code]wss://[/code] (secure) instead of [code]ws://[/code]. When doing so, make sure to use the fully qualified domain name that matches the one defined in the server's TLS certificate. Do not connect directly via the IP address for [code]wss://[/code] connections, as it won't match with the TLS certificate.
*/
func (self Instance) ConnectToUrl(url string) error { //gd:WebSocketPeer.connect_to_url
	return error(gd.ToError(Advanced(self).ConnectToUrl(String.New(url), [1]TLSOptions.Instance{}[0])))
}

/*
Connects to the given URL. TLS certificates will be verified against the hostname when connecting using the [code]wss://[/code] protocol. You can pass the optional [param tls_client_options] parameter to customize the trusted certification authorities, or disable the common name verification. See [method TLSOptions.client] and [method TLSOptions.client_unsafe].
[b]Note:[/b] This method is non-blocking, and will return [constant OK] before the connection is established as long as the provided parameters are valid and the peer is not in an invalid state (e.g. already connected). Regularly call [method poll] (e.g. during [Node] process) and check the result of [method get_ready_state] to know whether the connection succeeds or fails.
[b]Note:[/b] To avoid mixed content warnings or errors in Web, you may have to use a [param url] that starts with [code]wss://[/code] (secure) instead of [code]ws://[/code]. When doing so, make sure to use the fully qualified domain name that matches the one defined in the server's TLS certificate. Do not connect directly via the IP address for [code]wss://[/code] connections, as it won't match with the TLS certificate.
*/
func (self Expanded) ConnectToUrl(url string, tls_client_options TLSOptions.Instance) error { //gd:WebSocketPeer.connect_to_url
	return error(gd.ToError(Advanced(self).ConnectToUrl(String.New(url), tls_client_options)))
}

/*
Accepts a peer connection performing the HTTP handshake as a WebSocket server. The [param stream] must be a valid TCP stream retrieved via [method TCPServer.take_connection], or a TLS stream accepted via [method StreamPeerTLS.accept_stream].
[b]Note:[/b] Not supported in Web exports due to browsers' restrictions.
*/
func (self Instance) AcceptStream(stream StreamPeer.Instance) error { //gd:WebSocketPeer.accept_stream
	return error(gd.ToError(Advanced(self).AcceptStream(stream)))
}

/*
Sends the given [param message] using the desired [param write_mode]. When sending a [String], prefer using [method send_text].
*/
func (self Instance) Send(message []byte) error { //gd:WebSocketPeer.send
	return error(gd.ToError(Advanced(self).Send(Packed.Bytes(Packed.New(message...)), 1)))
}

/*
Sends the given [param message] using the desired [param write_mode]. When sending a [String], prefer using [method send_text].
*/
func (self Expanded) Send(message []byte, write_mode WriteMode) error { //gd:WebSocketPeer.send
	return error(gd.ToError(Advanced(self).Send(Packed.Bytes(Packed.New(message...)), write_mode)))
}

/*
Sends the given [param message] using WebSocket text mode. Prefer this method over [method PacketPeer.put_packet] when interacting with third-party text-based API (e.g. when using [JSON] formatted messages).
*/
func (self Instance) SendText(message string) error { //gd:WebSocketPeer.send_text
	return error(gd.ToError(Advanced(self).SendText(String.New(message))))
}

/*
Returns [code]true[/code] if the last received packet was sent as a text payload. See [enum WriteMode].
*/
func (self Instance) WasStringPacket() bool { //gd:WebSocketPeer.was_string_packet
	return bool(Advanced(self).WasStringPacket())
}

/*
Updates the connection state and receive incoming packets. Call this function regularly to keep it in a clean state.
*/
func (self Instance) Poll() { //gd:WebSocketPeer.poll
	Advanced(self).Poll()
}

/*
Closes this WebSocket connection. [param code] is the status code for the closure (see RFC 6455 section 7.4 for a list of valid status codes). [param reason] is the human readable reason for closing the connection (can be any UTF-8 string that's smaller than 123 bytes). If [param code] is negative, the connection will be closed immediately without notifying the remote peer.
[b]Note:[/b] To achieve a clean close, you will need to keep polling until [constant STATE_CLOSED] is reached.
[b]Note:[/b] The Web export might not support all status codes. Please refer to browser-specific documentation for more details.
*/
func (self Instance) Close() { //gd:WebSocketPeer.close
	Advanced(self).Close(int64(1000), String.New(""))
}

/*
Closes this WebSocket connection. [param code] is the status code for the closure (see RFC 6455 section 7.4 for a list of valid status codes). [param reason] is the human readable reason for closing the connection (can be any UTF-8 string that's smaller than 123 bytes). If [param code] is negative, the connection will be closed immediately without notifying the remote peer.
[b]Note:[/b] To achieve a clean close, you will need to keep polling until [constant STATE_CLOSED] is reached.
[b]Note:[/b] The Web export might not support all status codes. Please refer to browser-specific documentation for more details.
*/
func (self Expanded) Close(code int, reason string) { //gd:WebSocketPeer.close
	Advanced(self).Close(int64(code), String.New(reason))
}

/*
Returns the IP address of the connected peer.
[b]Note:[/b] Not available in the Web export.
*/
func (self Instance) GetConnectedHost() string { //gd:WebSocketPeer.get_connected_host
	return string(Advanced(self).GetConnectedHost().String())
}

/*
Returns the remote port of the connected peer.
[b]Note:[/b] Not available in the Web export.
*/
func (self Instance) GetConnectedPort() int { //gd:WebSocketPeer.get_connected_port
	return int(int(Advanced(self).GetConnectedPort()))
}

/*
Returns the selected WebSocket sub-protocol for this connection or an empty string if the sub-protocol has not been selected yet.
*/
func (self Instance) GetSelectedProtocol() string { //gd:WebSocketPeer.get_selected_protocol
	return string(Advanced(self).GetSelectedProtocol().String())
}

/*
Returns the URL requested by this peer. The URL is derived from the [code]url[/code] passed to [method connect_to_url] or from the HTTP headers when acting as server (i.e. when using [method accept_stream]).
*/
func (self Instance) GetRequestedUrl() string { //gd:WebSocketPeer.get_requested_url
	return string(Advanced(self).GetRequestedUrl().String())
}

/*
Disable Nagle's algorithm on the underlying TCP socket (default). See [method StreamPeerTCP.set_no_delay] for more information.
[b]Note:[/b] Not available in the Web export.
*/
func (self Instance) SetNoDelay(enabled bool) { //gd:WebSocketPeer.set_no_delay
	Advanced(self).SetNoDelay(enabled)
}

/*
Returns the current amount of data in the outbound websocket buffer. [b]Note:[/b] Web exports use WebSocket.bufferedAmount, while other platforms use an internal buffer.
*/
func (self Instance) GetCurrentOutboundBufferedAmount() int { //gd:WebSocketPeer.get_current_outbound_buffered_amount
	return int(int(Advanced(self).GetCurrentOutboundBufferedAmount()))
}

/*
Returns the ready state of the connection. See [enum State].
*/
func (self Instance) GetReadyState() State { //gd:WebSocketPeer.get_ready_state
	return State(Advanced(self).GetReadyState())
}

/*
Returns the received WebSocket close frame status code, or [code]-1[/code] when the connection was not cleanly closed. Only call this method when [method get_ready_state] returns [constant STATE_CLOSED].
*/
func (self Instance) GetCloseCode() int { //gd:WebSocketPeer.get_close_code
	return int(int(Advanced(self).GetCloseCode()))
}

/*
Returns the received WebSocket close frame status reason string. Only call this method when [method get_ready_state] returns [constant STATE_CLOSED].
*/
func (self Instance) GetCloseReason() string { //gd:WebSocketPeer.get_close_reason
	return string(Advanced(self).GetCloseReason().String())
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.WebSocketPeer

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = pointers.AsA[gdclass.WebSocketPeer](obj[0])
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = pointers.AsA[gdclass.WebSocketPeer](obj[0])
		return true
	}
	return false
}
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }
func (self *Extension[T]) AsObject() [1]gd.Object { return self.Super().AsObject() }
func New() Instance {
	if !gd.Linked {
		var placeholder = Instance([1]gdclass.WebSocketPeer{pointers.Add[gdclass.WebSocketPeer]([3]uint64{})})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(pointers.AsA[gd.Object](placeholder[0]), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	casted := Instance([1]gdclass.WebSocketPeer{pointers.New[gdclass.WebSocketPeer]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})})
	casted.AsRefCounted()[0].InitRef()
	casted.AsObject()[0].Notification(0, false)
	return casted
}

func (self Instance) SupportedProtocols() []string {
	return []string(class(self).GetSupportedProtocols().Strings())
}

func (self Instance) SetSupportedProtocols(value []string) {
	class(self).SetSupportedProtocols(Packed.MakeStrings(value...))
}

func (self Instance) HandshakeHeaders() []string {
	return []string(class(self).GetHandshakeHeaders().Strings())
}

func (self Instance) SetHandshakeHeaders(value []string) {
	class(self).SetHandshakeHeaders(Packed.MakeStrings(value...))
}

func (self Instance) InboundBufferSize() int {
	return int(int(class(self).GetInboundBufferSize()))
}

func (self Instance) SetInboundBufferSize(value int) {
	class(self).SetInboundBufferSize(int64(value))
}

func (self Instance) OutboundBufferSize() int {
	return int(int(class(self).GetOutboundBufferSize()))
}

func (self Instance) SetOutboundBufferSize(value int) {
	class(self).SetOutboundBufferSize(int64(value))
}

func (self Instance) MaxQueuedPackets() int {
	return int(int(class(self).GetMaxQueuedPackets()))
}

func (self Instance) SetMaxQueuedPackets(value int) {
	class(self).SetMaxQueuedPackets(int64(value))
}

func (self Instance) HeartbeatInterval() Float.X {
	return Float.X(Float.X(class(self).GetHeartbeatInterval()))
}

func (self Instance) SetHeartbeatInterval(value Float.X) {
	class(self).SetHeartbeatInterval(float64(value))
}

/*
Connects to the given URL. TLS certificates will be verified against the hostname when connecting using the [code]wss://[/code] protocol. You can pass the optional [param tls_client_options] parameter to customize the trusted certification authorities, or disable the common name verification. See [method TLSOptions.client] and [method TLSOptions.client_unsafe].
[b]Note:[/b] This method is non-blocking, and will return [constant OK] before the connection is established as long as the provided parameters are valid and the peer is not in an invalid state (e.g. already connected). Regularly call [method poll] (e.g. during [Node] process) and check the result of [method get_ready_state] to know whether the connection succeeds or fails.
[b]Note:[/b] To avoid mixed content warnings or errors in Web, you may have to use a [param url] that starts with [code]wss://[/code] (secure) instead of [code]ws://[/code]. When doing so, make sure to use the fully qualified domain name that matches the one defined in the server's TLS certificate. Do not connect directly via the IP address for [code]wss://[/code] connections, as it won't match with the TLS certificate.
*/
//go:nosplit
func (self class) ConnectToUrl(url String.Readable, tls_client_options [1]gdclass.TLSOptions) Error.Code { //gd:WebSocketPeer.connect_to_url
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.connect_to_url, gdextension.SizeInt|(gdextension.SizeString<<4)|(gdextension.SizeObject<<8), &struct {
		url                gdextension.String
		tls_client_options gdextension.Object
	}{pointers.Get(gd.InternalString(url)), gdextension.Object(gd.ObjectChecked(tls_client_options[0].AsObject()))})
	var ret = Error.Code(r_ret)
	return ret
}

/*
Accepts a peer connection performing the HTTP handshake as a WebSocket server. The [param stream] must be a valid TCP stream retrieved via [method TCPServer.take_connection], or a TLS stream accepted via [method StreamPeerTLS.accept_stream].
[b]Note:[/b] Not supported in Web exports due to browsers' restrictions.
*/
//go:nosplit
func (self class) AcceptStream(stream [1]gdclass.StreamPeer) Error.Code { //gd:WebSocketPeer.accept_stream
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.accept_stream, gdextension.SizeInt|(gdextension.SizeObject<<4), &struct{ stream gdextension.Object }{gdextension.Object(gd.ObjectChecked(stream[0].AsObject()))})
	var ret = Error.Code(r_ret)
	return ret
}

/*
Sends the given [param message] using the desired [param write_mode]. When sending a [String], prefer using [method send_text].
*/
//go:nosplit
func (self class) Send(message Packed.Bytes, write_mode WriteMode) Error.Code { //gd:WebSocketPeer.send
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.send, gdextension.SizeInt|(gdextension.SizePackedArray<<4)|(gdextension.SizeInt<<8), &struct {
		message    gdextension.PackedArray[byte]
		write_mode WriteMode
	}{pointers.Get(gd.InternalPacked[gd.PackedByteArray, byte](Packed.Array[byte](message))), write_mode})
	var ret = Error.Code(r_ret)
	return ret
}

/*
Sends the given [param message] using WebSocket text mode. Prefer this method over [method PacketPeer.put_packet] when interacting with third-party text-based API (e.g. when using [JSON] formatted messages).
*/
//go:nosplit
func (self class) SendText(message String.Readable) Error.Code { //gd:WebSocketPeer.send_text
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.send_text, gdextension.SizeInt|(gdextension.SizeString<<4), &struct{ message gdextension.String }{pointers.Get(gd.InternalString(message))})
	var ret = Error.Code(r_ret)
	return ret
}

/*
Returns [code]true[/code] if the last received packet was sent as a text payload. See [enum WriteMode].
*/
//go:nosplit
func (self class) WasStringPacket() bool { //gd:WebSocketPeer.was_string_packet
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.was_string_packet, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

/*
Updates the connection state and receive incoming packets. Call this function regularly to keep it in a clean state.
*/
//go:nosplit
func (self class) Poll() { //gd:WebSocketPeer.poll
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.poll, 0, &struct{}{})
}

/*
Closes this WebSocket connection. [param code] is the status code for the closure (see RFC 6455 section 7.4 for a list of valid status codes). [param reason] is the human readable reason for closing the connection (can be any UTF-8 string that's smaller than 123 bytes). If [param code] is negative, the connection will be closed immediately without notifying the remote peer.
[b]Note:[/b] To achieve a clean close, you will need to keep polling until [constant STATE_CLOSED] is reached.
[b]Note:[/b] The Web export might not support all status codes. Please refer to browser-specific documentation for more details.
*/
//go:nosplit
func (self class) Close(code int64, reason String.Readable) { //gd:WebSocketPeer.close
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.close, 0|(gdextension.SizeInt<<4)|(gdextension.SizeString<<8), &struct {
		code   int64
		reason gdextension.String
	}{code, pointers.Get(gd.InternalString(reason))})
}

/*
Returns the IP address of the connected peer.
[b]Note:[/b] Not available in the Web export.
*/
//go:nosplit
func (self class) GetConnectedHost() String.Readable { //gd:WebSocketPeer.get_connected_host
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_connected_host, gdextension.SizeString, &struct{}{})
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Returns the remote port of the connected peer.
[b]Note:[/b] Not available in the Web export.
*/
//go:nosplit
func (self class) GetConnectedPort() int64 { //gd:WebSocketPeer.get_connected_port
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_connected_port, gdextension.SizeInt, &struct{}{})
	var ret = r_ret
	return ret
}

/*
Returns the selected WebSocket sub-protocol for this connection or an empty string if the sub-protocol has not been selected yet.
*/
//go:nosplit
func (self class) GetSelectedProtocol() String.Readable { //gd:WebSocketPeer.get_selected_protocol
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_selected_protocol, gdextension.SizeString, &struct{}{})
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Returns the URL requested by this peer. The URL is derived from the [code]url[/code] passed to [method connect_to_url] or from the HTTP headers when acting as server (i.e. when using [method accept_stream]).
*/
//go:nosplit
func (self class) GetRequestedUrl() String.Readable { //gd:WebSocketPeer.get_requested_url
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_requested_url, gdextension.SizeString, &struct{}{})
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Disable Nagle's algorithm on the underlying TCP socket (default). See [method StreamPeerTCP.set_no_delay] for more information.
[b]Note:[/b] Not available in the Web export.
*/
//go:nosplit
func (self class) SetNoDelay(enabled bool) { //gd:WebSocketPeer.set_no_delay
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_no_delay, 0|(gdextension.SizeBool<<4), &struct{ enabled bool }{enabled})
}

/*
Returns the current amount of data in the outbound websocket buffer. [b]Note:[/b] Web exports use WebSocket.bufferedAmount, while other platforms use an internal buffer.
*/
//go:nosplit
func (self class) GetCurrentOutboundBufferedAmount() int64 { //gd:WebSocketPeer.get_current_outbound_buffered_amount
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_current_outbound_buffered_amount, gdextension.SizeInt, &struct{}{})
	var ret = r_ret
	return ret
}

/*
Returns the ready state of the connection. See [enum State].
*/
//go:nosplit
func (self class) GetReadyState() State { //gd:WebSocketPeer.get_ready_state
	var r_ret = gdextension.Call[State](gd.ObjectChecked(self.AsObject()), methods.get_ready_state, gdextension.SizeInt, &struct{}{})
	var ret = r_ret
	return ret
}

/*
Returns the received WebSocket close frame status code, or [code]-1[/code] when the connection was not cleanly closed. Only call this method when [method get_ready_state] returns [constant STATE_CLOSED].
*/
//go:nosplit
func (self class) GetCloseCode() int64 { //gd:WebSocketPeer.get_close_code
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_close_code, gdextension.SizeInt, &struct{}{})
	var ret = r_ret
	return ret
}

/*
Returns the received WebSocket close frame status reason string. Only call this method when [method get_ready_state] returns [constant STATE_CLOSED].
*/
//go:nosplit
func (self class) GetCloseReason() String.Readable { //gd:WebSocketPeer.get_close_reason
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_close_reason, gdextension.SizeString, &struct{}{})
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

//go:nosplit
func (self class) GetSupportedProtocols() Packed.Strings { //gd:WebSocketPeer.get_supported_protocols
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.get_supported_protocols, gdextension.SizePackedArray, &struct{}{})
	var ret = Packed.Strings(Array.Through(gd.PackedStringArrayProxy{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

//go:nosplit
func (self class) SetSupportedProtocols(protocols Packed.Strings) { //gd:WebSocketPeer.set_supported_protocols
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_supported_protocols, 0|(gdextension.SizePackedArray<<4), &struct {
		protocols gdextension.PackedArray[gdextension.String]
	}{pointers.Get(gd.InternalPackedStrings(protocols))})
}

//go:nosplit
func (self class) GetHandshakeHeaders() Packed.Strings { //gd:WebSocketPeer.get_handshake_headers
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.get_handshake_headers, gdextension.SizePackedArray, &struct{}{})
	var ret = Packed.Strings(Array.Through(gd.PackedStringArrayProxy{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

//go:nosplit
func (self class) SetHandshakeHeaders(protocols Packed.Strings) { //gd:WebSocketPeer.set_handshake_headers
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_handshake_headers, 0|(gdextension.SizePackedArray<<4), &struct {
		protocols gdextension.PackedArray[gdextension.String]
	}{pointers.Get(gd.InternalPackedStrings(protocols))})
}

//go:nosplit
func (self class) GetInboundBufferSize() int64 { //gd:WebSocketPeer.get_inbound_buffer_size
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_inbound_buffer_size, gdextension.SizeInt, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetInboundBufferSize(buffer_size int64) { //gd:WebSocketPeer.set_inbound_buffer_size
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_inbound_buffer_size, 0|(gdextension.SizeInt<<4), &struct{ buffer_size int64 }{buffer_size})
}

//go:nosplit
func (self class) GetOutboundBufferSize() int64 { //gd:WebSocketPeer.get_outbound_buffer_size
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_outbound_buffer_size, gdextension.SizeInt, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetOutboundBufferSize(buffer_size int64) { //gd:WebSocketPeer.set_outbound_buffer_size
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_outbound_buffer_size, 0|(gdextension.SizeInt<<4), &struct{ buffer_size int64 }{buffer_size})
}

//go:nosplit
func (self class) SetMaxQueuedPackets(buffer_size int64) { //gd:WebSocketPeer.set_max_queued_packets
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_max_queued_packets, 0|(gdextension.SizeInt<<4), &struct{ buffer_size int64 }{buffer_size})
}

//go:nosplit
func (self class) GetMaxQueuedPackets() int64 { //gd:WebSocketPeer.get_max_queued_packets
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_max_queued_packets, gdextension.SizeInt, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetHeartbeatInterval(interval float64) { //gd:WebSocketPeer.set_heartbeat_interval
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_heartbeat_interval, 0|(gdextension.SizeFloat<<4), &struct{ interval float64 }{interval})
}

//go:nosplit
func (self class) GetHeartbeatInterval() float64 { //gd:WebSocketPeer.get_heartbeat_interval
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_heartbeat_interval, gdextension.SizeFloat, &struct{}{})
	var ret = r_ret
	return ret
}
func (self class) AsWebSocketPeer() Advanced {
	return Advanced{pointers.AsA[gdclass.WebSocketPeer](self[0])}
}
func (self Instance) AsWebSocketPeer() Instance {
	return Instance{pointers.AsA[gdclass.WebSocketPeer](self[0])}
}
func (self *Extension[T]) AsWebSocketPeer() Instance { return self.Super().AsWebSocketPeer() }
func (self class) AsPacketPeer() PacketPeer.Advanced {
	return PacketPeer.Advanced{pointers.AsA[gdclass.PacketPeer](self[0])}
}
func (self *Extension[T]) AsPacketPeer() PacketPeer.Instance { return self.Super().AsPacketPeer() }
func (self Instance) AsPacketPeer() PacketPeer.Instance {
	return PacketPeer.Instance{pointers.AsA[gdclass.PacketPeer](self[0])}
}
func (self class) AsRefCounted() [1]gd.RefCounted {
	return [1]gd.RefCounted{gd.RefCounted(pointers.AsA[gd.Object](self[0]))}
}
func (self *Extension[T]) AsRefCounted() [1]gd.RefCounted { return self.Super().AsRefCounted() }
func (self Instance) AsRefCounted() [1]gd.RefCounted {
	return [1]gd.RefCounted{gd.RefCounted(pointers.AsA[gd.Object](self[0]))}
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(PacketPeer.Advanced(self.AsPacketPeer()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(PacketPeer.Instance(self.AsPacketPeer()), name)
	}
}
func init() {
	gdclass.Register("WebSocketPeer", func(ptr gd.Object) any { return Instance{pointers.AsA[gdclass.WebSocketPeer](ptr)} })
}

type WriteMode int //gd:WebSocketPeer.WriteMode

const (
	/*Specifies that WebSockets messages should be transferred as text payload (only valid UTF-8 is allowed).*/
	WriteModeText WriteMode = 0
	/*Specifies that WebSockets messages should be transferred as binary payload (any byte combination is allowed).*/
	WriteModeBinary WriteMode = 1
)

type State int //gd:WebSocketPeer.State

const (
	/*Socket has been created. The connection is not yet open.*/
	StateConnecting State = 0
	/*The connection is open and ready to communicate.*/
	StateOpen State = 1
	/*The connection is in the process of closing. This means a close request has been sent to the remote peer but confirmation has not been received.*/
	StateClosing State = 2
	/*The connection is closed or couldn't be opened.*/
	StateClosed State = 3
)
