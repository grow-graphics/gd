// Code generated by the generate package DO NOT EDIT

// Package XRServer provides methods for working with XRServer object instances.
package XRServer

import "unsafe"
import "sync"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/classdb/XRInterface"
import "graphics.gd/classdb/XRTracker"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"
import "graphics.gd/variant/Transform3D"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
The AR/VR server is the heart of our Advanced and Virtual Reality solution and handles all the processing.
*/
type Instance [1]gdclass.XRServer

func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

var self [1]gdclass.XRServer
var once sync.Once

func singleton() {
	obj := gd.Global.Object.GetSingleton(gd.Global.Singletons.XRServer)
	self = *(*[1]gdclass.XRServer)(unsafe.Pointer(&obj))
}

/*
Returns the reference frame transform. Mostly used internally and exposed for GDExtension build interfaces.
*/
func GetReferenceFrame() Transform3D.BasisOrigin { //gd:XRServer.get_reference_frame
	once.Do(singleton)
	return Transform3D.BasisOrigin(Advanced().GetReferenceFrame())
}

/*
Clears the reference frame that was set by previous calls to [method center_on_hmd].
*/
func ClearReferenceFrame() { //gd:XRServer.clear_reference_frame
	once.Do(singleton)
	Advanced().ClearReferenceFrame()
}

/*
This is an important function to understand correctly. AR and VR platforms all handle positioning slightly differently.
For platforms that do not offer spatial tracking, our origin point (0, 0, 0) is the location of our HMD, but you have little control over the direction the player is facing in the real world.
For platforms that do offer spatial tracking, our origin point depends very much on the system. For OpenVR, our origin point is usually the center of the tracking space, on the ground. For other platforms, it's often the location of the tracking camera.
This method allows you to center your tracker on the location of the HMD. It will take the current location of the HMD and use that to adjust all your tracking data; in essence, realigning the real world to your player's current position in the game world.
For this method to produce usable results, tracking information must be available. This often takes a few frames after starting your game.
You should call this method after a few seconds have passed. For example, when the user requests a realignment of the display holding a designated button on a controller for a short period of time, or when implementing a teleport mechanism.
*/
func CenterOnHmd(rotation_mode RotationMode, keep_height bool) { //gd:XRServer.center_on_hmd
	once.Do(singleton)
	Advanced().CenterOnHmd(rotation_mode, keep_height)
}

/*
Returns the primary interface's transformation.
*/
func GetHmdTransform() Transform3D.BasisOrigin { //gd:XRServer.get_hmd_transform
	once.Do(singleton)
	return Transform3D.BasisOrigin(Advanced().GetHmdTransform())
}

/*
Registers an [XRInterface] object.
*/
func AddInterface(intf XRInterface.Instance) { //gd:XRServer.add_interface
	once.Do(singleton)
	Advanced().AddInterface(intf)
}

/*
Returns the number of interfaces currently registered with the AR/VR server. If your project supports multiple AR/VR platforms, you can look through the available interface, and either present the user with a selection or simply try to initialize each interface and use the first one that returns [code]true[/code].
*/
func GetInterfaceCount() int { //gd:XRServer.get_interface_count
	once.Do(singleton)
	return int(int(Advanced().GetInterfaceCount()))
}

/*
Removes this [param interface].
*/
func RemoveInterface(intf XRInterface.Instance) { //gd:XRServer.remove_interface
	once.Do(singleton)
	Advanced().RemoveInterface(intf)
}

/*
Returns the interface registered at the given [param idx] index in the list of interfaces.
*/
func GetInterface(idx int) XRInterface.Instance { //gd:XRServer.get_interface
	once.Do(singleton)
	return XRInterface.Instance(Advanced().GetInterface(int64(idx)))
}

/*
Returns a list of available interfaces the ID and name of each interface.
*/
func GetInterfaces() []map[int]string { //gd:XRServer.get_interfaces
	once.Do(singleton)
	return []map[int]string(gd.ArrayAs[[]map[int]string](gd.InternalArray(Advanced().GetInterfaces())))
}

/*
Finds an interface by its [param name]. For example, if your project uses capabilities of an AR/VR platform, you can find the interface for that platform by name and initialize it.
*/
func FindInterface(name string) XRInterface.Instance { //gd:XRServer.find_interface
	once.Do(singleton)
	return XRInterface.Instance(Advanced().FindInterface(String.New(name)))
}

/*
Registers a new [XRTracker] that tracks a physical object.
*/
func AddTracker(tracker XRTracker.Instance) { //gd:XRServer.add_tracker
	once.Do(singleton)
	Advanced().AddTracker(tracker)
}

/*
Removes this [param tracker].
*/
func RemoveTracker(tracker XRTracker.Instance) { //gd:XRServer.remove_tracker
	once.Do(singleton)
	Advanced().RemoveTracker(tracker)
}

/*
Returns a dictionary of trackers for [param tracker_types].
*/
func GetTrackers(tracker_types int) map[interface{}]interface{} { //gd:XRServer.get_trackers
	once.Do(singleton)
	return map[interface{}]interface{}(gd.DictionaryAs[map[interface{}]interface{}](Advanced().GetTrackers(int64(tracker_types))))
}

/*
Returns the positional tracker with the given [param tracker_name].
*/
func GetTracker(tracker_name string) XRTracker.Instance { //gd:XRServer.get_tracker
	once.Do(singleton)
	return XRTracker.Instance(Advanced().GetTracker(String.Name(String.New(tracker_name))))
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
func Advanced() class { once.Do(singleton); return self }

type class [1]gdclass.XRServer

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }

func WorldScale() Float.X {
	once.Do(singleton)
	return Float.X(Float.X(class(self).GetWorldScale()))
}

func SetWorldScale(value Float.X) {
	once.Do(singleton)
	class(self).SetWorldScale(float64(value))
}

func WorldOrigin() Transform3D.BasisOrigin {
	once.Do(singleton)
	return Transform3D.BasisOrigin(class(self).GetWorldOrigin())
}

func SetWorldOrigin(value Transform3D.BasisOrigin) {
	once.Do(singleton)
	class(self).SetWorldOrigin(Transform3D.BasisOrigin(value))
}

func CameraLockedToOrigin() bool {
	once.Do(singleton)
	return bool(class(self).IsCameraLockedToOrigin())
}

func SetCameraLockedToOrigin(value bool) {
	once.Do(singleton)
	class(self).SetCameraLockedToOrigin(value)
}

func PrimaryInterface() XRInterface.Instance {
	once.Do(singleton)
	return XRInterface.Instance(class(self).GetPrimaryInterface())
}

func SetPrimaryInterface(value XRInterface.Instance) {
	once.Do(singleton)
	class(self).SetPrimaryInterface(value)
}

//go:nosplit
func (self class) GetWorldScale() float64 { //gd:XRServer.get_world_scale
	var frame = callframe.New()
	var r_ret = callframe.Ret[float64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.XRServer.Bind_get_world_scale, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

//go:nosplit
func (self class) SetWorldScale(scale float64) { //gd:XRServer.set_world_scale
	var frame = callframe.New()
	callframe.Arg(frame, scale)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.XRServer.Bind_set_world_scale, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) GetWorldOrigin() Transform3D.BasisOrigin { //gd:XRServer.get_world_origin
	var frame = callframe.New()
	var r_ret = callframe.Ret[Transform3D.BasisOrigin](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.XRServer.Bind_get_world_origin, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = gd.Transposed(r_ret.Get())
	frame.Free()
	return ret
}

//go:nosplit
func (self class) SetWorldOrigin(world_origin Transform3D.BasisOrigin) { //gd:XRServer.set_world_origin
	var frame = callframe.New()
	callframe.Arg(frame, gd.Transposed(world_origin))
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.XRServer.Bind_set_world_origin, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Returns the reference frame transform. Mostly used internally and exposed for GDExtension build interfaces.
*/
//go:nosplit
func (self class) GetReferenceFrame() Transform3D.BasisOrigin { //gd:XRServer.get_reference_frame
	var frame = callframe.New()
	var r_ret = callframe.Ret[Transform3D.BasisOrigin](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.XRServer.Bind_get_reference_frame, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = gd.Transposed(r_ret.Get())
	frame.Free()
	return ret
}

/*
Clears the reference frame that was set by previous calls to [method center_on_hmd].
*/
//go:nosplit
func (self class) ClearReferenceFrame() { //gd:XRServer.clear_reference_frame
	var frame = callframe.New()
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.XRServer.Bind_clear_reference_frame, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
This is an important function to understand correctly. AR and VR platforms all handle positioning slightly differently.
For platforms that do not offer spatial tracking, our origin point (0, 0, 0) is the location of our HMD, but you have little control over the direction the player is facing in the real world.
For platforms that do offer spatial tracking, our origin point depends very much on the system. For OpenVR, our origin point is usually the center of the tracking space, on the ground. For other platforms, it's often the location of the tracking camera.
This method allows you to center your tracker on the location of the HMD. It will take the current location of the HMD and use that to adjust all your tracking data; in essence, realigning the real world to your player's current position in the game world.
For this method to produce usable results, tracking information must be available. This often takes a few frames after starting your game.
You should call this method after a few seconds have passed. For example, when the user requests a realignment of the display holding a designated button on a controller for a short period of time, or when implementing a teleport mechanism.
*/
//go:nosplit
func (self class) CenterOnHmd(rotation_mode RotationMode, keep_height bool) { //gd:XRServer.center_on_hmd
	var frame = callframe.New()
	callframe.Arg(frame, rotation_mode)
	callframe.Arg(frame, keep_height)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.XRServer.Bind_center_on_hmd, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Returns the primary interface's transformation.
*/
//go:nosplit
func (self class) GetHmdTransform() Transform3D.BasisOrigin { //gd:XRServer.get_hmd_transform
	var frame = callframe.New()
	var r_ret = callframe.Ret[Transform3D.BasisOrigin](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.XRServer.Bind_get_hmd_transform, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = gd.Transposed(r_ret.Get())
	frame.Free()
	return ret
}

//go:nosplit
func (self class) SetCameraLockedToOrigin(enabled bool) { //gd:XRServer.set_camera_locked_to_origin
	var frame = callframe.New()
	callframe.Arg(frame, enabled)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.XRServer.Bind_set_camera_locked_to_origin, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) IsCameraLockedToOrigin() bool { //gd:XRServer.is_camera_locked_to_origin
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.XRServer.Bind_is_camera_locked_to_origin, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Registers an [XRInterface] object.
*/
//go:nosplit
func (self class) AddInterface(intf [1]gdclass.XRInterface) { //gd:XRServer.add_interface
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(intf[0])[0])
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.XRServer.Bind_add_interface, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Returns the number of interfaces currently registered with the AR/VR server. If your project supports multiple AR/VR platforms, you can look through the available interface, and either present the user with a selection or simply try to initialize each interface and use the first one that returns [code]true[/code].
*/
//go:nosplit
func (self class) GetInterfaceCount() int64 { //gd:XRServer.get_interface_count
	var frame = callframe.New()
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.XRServer.Bind_get_interface_count, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Removes this [param interface].
*/
//go:nosplit
func (self class) RemoveInterface(intf [1]gdclass.XRInterface) { //gd:XRServer.remove_interface
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(intf[0])[0])
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.XRServer.Bind_remove_interface, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Returns the interface registered at the given [param idx] index in the list of interfaces.
*/
//go:nosplit
func (self class) GetInterface(idx int64) [1]gdclass.XRInterface { //gd:XRServer.get_interface
	var frame = callframe.New()
	callframe.Arg(frame, idx)
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.XRServer.Bind_get_interface, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.XRInterface{gd.PointerWithOwnershipTransferredToGo[gdclass.XRInterface](r_ret.Get())}
	frame.Free()
	return ret
}

/*
Returns a list of available interfaces the ID and name of each interface.
*/
//go:nosplit
func (self class) GetInterfaces() Array.Contains[Dictionary.Any] { //gd:XRServer.get_interfaces
	var frame = callframe.New()
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.XRServer.Bind_get_interfaces, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Array.Through(gd.ArrayProxy[Dictionary.Any]{}, pointers.Pack(pointers.New[gd.Array](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Finds an interface by its [param name]. For example, if your project uses capabilities of an AR/VR platform, you can find the interface for that platform by name and initialize it.
*/
//go:nosplit
func (self class) FindInterface(name String.Readable) [1]gdclass.XRInterface { //gd:XRServer.find_interface
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(name)))
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.XRServer.Bind_find_interface, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.XRInterface{gd.PointerWithOwnershipTransferredToGo[gdclass.XRInterface](r_ret.Get())}
	frame.Free()
	return ret
}

/*
Registers a new [XRTracker] that tracks a physical object.
*/
//go:nosplit
func (self class) AddTracker(tracker [1]gdclass.XRTracker) { //gd:XRServer.add_tracker
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(tracker[0])[0])
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.XRServer.Bind_add_tracker, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Removes this [param tracker].
*/
//go:nosplit
func (self class) RemoveTracker(tracker [1]gdclass.XRTracker) { //gd:XRServer.remove_tracker
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(tracker[0])[0])
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.XRServer.Bind_remove_tracker, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Returns a dictionary of trackers for [param tracker_types].
*/
//go:nosplit
func (self class) GetTrackers(tracker_types int64) Dictionary.Any { //gd:XRServer.get_trackers
	var frame = callframe.New()
	callframe.Arg(frame, tracker_types)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.XRServer.Bind_get_trackers, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Returns the positional tracker with the given [param tracker_name].
*/
//go:nosplit
func (self class) GetTracker(tracker_name String.Name) [1]gdclass.XRTracker { //gd:XRServer.get_tracker
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalStringName(tracker_name)))
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.XRServer.Bind_get_tracker, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.XRTracker{gd.PointerWithOwnershipTransferredToGo[gdclass.XRTracker](r_ret.Get())}
	frame.Free()
	return ret
}

//go:nosplit
func (self class) GetPrimaryInterface() [1]gdclass.XRInterface { //gd:XRServer.get_primary_interface
	var frame = callframe.New()
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.XRServer.Bind_get_primary_interface, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.XRInterface{gd.PointerWithOwnershipTransferredToGo[gdclass.XRInterface](r_ret.Get())}
	frame.Free()
	return ret
}

//go:nosplit
func (self class) SetPrimaryInterface(intf [1]gdclass.XRInterface) { //gd:XRServer.set_primary_interface
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(intf[0])[0])
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.XRServer.Bind_set_primary_interface, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}
func OnReferenceFrameChanged(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("reference_frame_changed"), gd.NewCallable(cb), 0)
}

func OnInterfaceAdded(cb func(interface_name string)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("interface_added"), gd.NewCallable(cb), 0)
}

func OnInterfaceRemoved(cb func(interface_name string)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("interface_removed"), gd.NewCallable(cb), 0)
}

func OnTrackerAdded(cb func(tracker_name string, atype int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("tracker_added"), gd.NewCallable(cb), 0)
}

func OnTrackerUpdated(cb func(tracker_name string, atype int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("tracker_updated"), gd.NewCallable(cb), 0)
}

func OnTrackerRemoved(cb func(tracker_name string, atype int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("tracker_removed"), gd.NewCallable(cb), 0)
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Object.Advanced(self.AsObject()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Object.Instance(self.AsObject()), name)
	}
}
func init() {
	gdclass.Register("XRServer", func(ptr gd.Object) any { return [1]gdclass.XRServer{*(*gdclass.XRServer)(unsafe.Pointer(&ptr))} })
}

type RotationMode int //gd:XRServer.RotationMode

const (
	/*Fully reset the orientation of the HMD. Regardless of what direction the user is looking to in the real world. The user will look dead ahead in the virtual world.*/
	ResetFullRotation RotationMode = 0
	/*Resets the orientation but keeps the tilt of the device. So if we're looking down, we keep looking down but heading will be reset.*/
	ResetButKeepTilt RotationMode = 1
	/*Does not reset the orientation of the HMD, only the position of the player gets centered.*/
	DontResetRotation RotationMode = 2
)
