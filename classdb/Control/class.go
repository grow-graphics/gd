// Code generated by the generate package DO NOT EDIT

// Package Control provides methods for working with Control object instances.
package Control

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/classdb/CanvasItem"
import "graphics.gd/classdb/Font"
import "graphics.gd/classdb/InputEvent"
import "graphics.gd/classdb/Node"
import "graphics.gd/classdb/StyleBox"
import "graphics.gd/classdb/Texture2D"
import "graphics.gd/classdb/Theme"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Color"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/Rect2"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"
import "graphics.gd/variant/Vector2"
import "graphics.gd/variant/Vector3i"

var _ Object.ID
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
Base class for all UI-related nodes. [Control] features a bounding rectangle that defines its extents, an anchor position relative to its parent control or the current viewport, and offsets relative to the anchor. The offsets update automatically when the node, any of its parents, or the screen size change.
For more information on Godot's UI system, anchors, offsets, and containers, see the related tutorials in the manual. To build flexible UIs, you'll need a mix of UI elements that inherit from [Control] and [Container] nodes.
[b]Note:[/b] Since both [Node2D] and [Control] inherit from [CanvasItem], they share several concepts from the class such as the [member CanvasItem.z_index] and [member CanvasItem.visible] properties.
[b]User Interface nodes and input[/b]
Godot propagates input events via viewports. Each [Viewport] is responsible for propagating [InputEvent]s to their child nodes. As the [member SceneTree.root] is a [Window], this already happens automatically for all UI elements in your game.
Input events are propagated through the [SceneTree] from the root node to all child nodes by calling [method Node._input]. For UI elements specifically, it makes more sense to override the virtual method [method _gui_input], which filters out unrelated input events, such as by checking z-order, [member mouse_filter], focus, or if the event was inside of the control's bounding box.
Call [method accept_event] so no other node receives the event. Once you accept an input, it becomes handled so [method Node._unhandled_input] will not process it.
Only one [Control] node can be in focus. Only the node in focus will receive events. To get the focus, call [method grab_focus]. [Control] nodes lose focus when another node grabs it, or if you hide the node in focus.
Sets [member mouse_filter] to [constant MOUSE_FILTER_IGNORE] to tell a [Control] node to ignore mouse or touch events. You'll need it if you place an icon on top of a button.
[Theme] resources change the control's appearance. The [member theme] of a [Control] node affects all of its direct and indirect children (as long as a chain of controls is uninterrupted). To override some of the theme items, call one of the [code]add_theme_*_override[/code] methods, like [method add_theme_font_override]. You can also override theme items in the Inspector.
[b]Note:[/b] Theme items are [i]not[/i] [Object] properties. This means you can't access their values using [method Object.get] and [method Object.set]. Instead, use the [code]get_theme_*[/code] and [code]add_theme_*_override[/code] methods provided by this class.

	See [Interface] for methods that can be overridden by a [Class] that extends it.
*/
type Instance [1]gdclass.Control

func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

type Expanded [1]gdclass.Control

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsControl() Instance
}
type Interface interface {
	//Virtual method to be implemented by the user. Returns whether the given [param point] is inside this control.
	//If not overridden, default behavior is checking if the point is within control's Rect.
	//[b]Note:[/b] If you want to check if a point is inside the control, you can use [code]Rect2(Vector2.ZERO, size).has_point(point)[/code].
	HasPoint(point Vector2.XY) bool
	//User defined BiDi algorithm override function.
	//Returns an [Array] of [Vector3i] text ranges and text base directions, in the left-to-right order. Ranges should cover full source [param text] without overlaps. BiDi algorithm will be used on each range separately.
	StructuredTextParser(args []any, text string) []Vector3i.XYZ
	//Virtual method to be implemented by the user. Returns the minimum size for this control. Alternative to [member custom_minimum_size] for controlling minimum size via code. The actual minimum size will be the max value of these two (in each axis separately).
	//If not overridden, defaults to [constant Vector2.ZERO].
	//[b]Note:[/b] This method will not be called when the script is attached to a [Control] node that already overrides its minimum size (e.g. [Label], [Button], [PanelContainer] etc.). It can only be used with most basic GUI nodes, like [Control], [Container], [Panel] etc.
	GetMinimumSize() Vector2.XY
	//Virtual method to be implemented by the user. Returns the tooltip text for the position [param at_position] in control's local coordinates, which will typically appear when the cursor is resting over this control. See [method get_tooltip].
	//[b]Note:[/b] If this method returns an empty [String] and [method _make_custom_tooltip] is not overridden, no tooltip is displayed.
	GetTooltip(at_position Vector2.XY) string
	//Godot calls this method to get data that can be dragged and dropped onto controls that expect drop data. Returns [code]null[/code] if there is no data to drag. Controls that want to receive drop data should implement [method _can_drop_data] and [method _drop_data]. [param at_position] is local to this control. Drag may be forced with [method force_drag].
	//A preview that will follow the mouse that should represent the data can be set with [method set_drag_preview]. A good time to set the preview is in this method.
	//[codeblocks]
	//[gdscript]
	//func _get_drag_data(position):
	//    var mydata = make_data() # This is your custom method generating the drag data.
	//    set_drag_preview(make_preview(mydata)) # This is your custom method generating the preview of the drag data.
	//    return mydata
	//[/gdscript]
	//[csharp]
	//public override Variant _GetDragData(Vector2 atPosition)
	//{
	//    var myData = MakeData(); // This is your custom method generating the drag data.
	//    SetDragPreview(MakePreview(myData)); // This is your custom method generating the preview of the drag data.
	//    return myData;
	//}
	//[/csharp]
	//[/codeblocks]
	GetDragData(at_position Vector2.XY) any
	//Godot calls this method to test if [param data] from a control's [method _get_drag_data] can be dropped at [param at_position]. [param at_position] is local to this control.
	//This method should only be used to test the data. Process the data in [method _drop_data].
	//[codeblocks]
	//[gdscript]
	//func _can_drop_data(position, data):
	//    # Check position if it is relevant to you
	//    # Otherwise, just check data
	//    return typeof(data) == TYPE_DICTIONARY and data.has("expected")
	//[/gdscript]
	//[csharp]
	//public override bool _CanDropData(Vector2 atPosition, Variant data)
	//{
	//    // Check position if it is relevant to you
	//    // Otherwise, just check data
	//    return data.VariantType == Variant.Type.Dictionary && data.AsGodotDictionary().ContainsKey("expected");
	//}
	//[/csharp]
	//[/codeblocks]
	CanDropData(at_position Vector2.XY, data any) bool
	//Godot calls this method to pass you the [param data] from a control's [method _get_drag_data] result. Godot first calls [method _can_drop_data] to test if [param data] is allowed to drop at [param at_position] where [param at_position] is local to this control.
	//[codeblocks]
	//[gdscript]
	//func _can_drop_data(position, data):
	//    return typeof(data) == TYPE_DICTIONARY and data.has("color")
	//
	//func _drop_data(position, data):
	//    var color = data["color"]
	//[/gdscript]
	//[csharp]
	//public override bool _CanDropData(Vector2 atPosition, Variant data)
	//{
	//    return data.VariantType == Variant.Type.Dictionary && data.AsGodotDictionary().ContainsKey("color");
	//}
	//
	//public override void _DropData(Vector2 atPosition, Variant data)
	//{
	//    Color color = data.AsGodotDictionary()["color"].AsColor();
	//}
	//[/csharp]
	//[/codeblocks]
	DropData(at_position Vector2.XY, data any)
	//Virtual method to be implemented by the user. Returns a [Control] node that should be used as a tooltip instead of the default one. [param for_text] is the return value of [method get_tooltip].
	//The returned node must be of type [Control] or Control-derived. It can have child nodes of any type. It is freed when the tooltip disappears, so make sure you always provide a new instance (if you want to use a pre-existing node from your scene tree, you can duplicate it and pass the duplicated instance). When [code]null[/code] or a non-Control node is returned, the default tooltip will be used instead.
	//The returned node will be added as child to a [PopupPanel], so you should only provide the contents of that panel. That [PopupPanel] can be themed using [method Theme.set_stylebox] for the type [code]"TooltipPanel"[/code] (see [member tooltip_text] for an example).
	//[b]Note:[/b] The tooltip is shrunk to minimal size. If you want to ensure it's fully visible, you might want to set its [member custom_minimum_size] to some non-zero value.
	//[b]Note:[/b] The node (and any relevant children) should have their [member CanvasItem.visible] set to [code]true[/code] when returned, otherwise, the viewport that instantiates it will not be able to calculate its minimum size reliably.
	//[b]Note:[/b] If overridden, this method is called even if [method get_tooltip] returns an empty string. When this happens with the default tooltip, it is not displayed. To copy this behavior, return [code]null[/code] in this method when [param for_text] is empty.
	//[b]Example:[/b] Use a constructed node as a tooltip:
	//[codeblocks]
	//[gdscript]
	//func _make_custom_tooltip(for_text):
	//    var label = Label.new()
	//    label.text = for_text
	//    return label
	//[/gdscript]
	//[csharp]
	//public override Control _MakeCustomTooltip(string forText)
	//{
	//    var label = new Label();
	//    label.Text = forText;
	//    return label;
	//}
	//[/csharp]
	//[/codeblocks]
	//[b]Example:[/b] Usa a scene instance as a tooltip:
	//[codeblocks]
	//[gdscript]
	//func _make_custom_tooltip(for_text):
	//    var tooltip = preload("res://some_tooltip_scene.tscn").instantiate()
	//    tooltip.get_node("Label").text = for_text
	//    return tooltip
	//[/gdscript]
	//[csharp]
	//public override Control _MakeCustomTooltip(string forText)
	//{
	//    Node tooltip = ResourceLoader.Load<PackedScene>("res://some_tooltip_scene.tscn").Instantiate();
	//    tooltip.GetNode<Label>("Label").Text = forText;
	//    return tooltip;
	//}
	//[/csharp]
	//[/codeblocks]
	MakeCustomTooltip(for_text string) Object.Instance
	//Virtual method to be implemented by the user. Override this method to handle and accept inputs on UI elements. See also [method accept_event].
	//[b]Example:[/b] Click on the control to print a message:
	//[codeblocks]
	//[gdscript]
	//func _gui_input(event):
	//    if event is InputEventMouseButton:
	//        if event.button_index == MOUSE_BUTTON_LEFT and event.pressed:
	//            print("I've been clicked D:")
	//[/gdscript]
	//[csharp]
	//public override void _GuiInput(InputEvent @event)
	//{
	//    if (@event is InputEventMouseButton mb)
	//    {
	//        if (mb.ButtonIndex == MouseButton.Left && mb.Pressed)
	//        {
	//            GD.Print("I've been clicked D:");
	//        }
	//    }
	//}
	//[/csharp]
	//[/codeblocks]
	//If the [param event] inherits [InputEventMouse], this method will [b]not[/b] be called when:
	//- the control's [member mouse_filter] is set to [constant MOUSE_FILTER_IGNORE];
	//- the control is obstructed by another control on top, that doesn't have [member mouse_filter] set to [constant MOUSE_FILTER_IGNORE];
	//- the control's parent has [member mouse_filter] set to [constant MOUSE_FILTER_STOP] or has accepted the event;
	//- the control's parent has [member clip_contents] enabled and the [param event]'s position is outside the parent's rectangle;
	//- the [param event]'s position is outside the control (see [method _has_point]).
	//[b]Note:[/b] The [param event]'s position is relative to this control's origin.
	GuiInput(event InputEvent.Instance)
}

// Implementation implements [Interface] with empty methods.
type Implementation = implementation

type implementation struct{}

func (self implementation) HasPoint(point Vector2.XY) (_ bool)                              { return }
func (self implementation) StructuredTextParser(args []any, text string) (_ []Vector3i.XYZ) { return }
func (self implementation) GetMinimumSize() (_ Vector2.XY)                                  { return }
func (self implementation) GetTooltip(at_position Vector2.XY) (_ string)                    { return }
func (self implementation) GetDragData(at_position Vector2.XY) (_ any)                      { return }
func (self implementation) CanDropData(at_position Vector2.XY, data any) (_ bool)           { return }
func (self implementation) DropData(at_position Vector2.XY, data any)                       { return }
func (self implementation) MakeCustomTooltip(for_text string) (_ Object.Instance)           { return }
func (self implementation) GuiInput(event InputEvent.Instance)                              { return }

/*
Virtual method to be implemented by the user. Returns whether the given [param point] is inside this control.
If not overridden, default behavior is checking if the point is within control's Rect.
[b]Note:[/b] If you want to check if a point is inside the control, you can use [code]Rect2(Vector2.ZERO, size).has_point(point)[/code].
*/
func (Instance) _has_point(impl func(ptr unsafe.Pointer, point Vector2.XY) bool) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var point = gd.UnsafeGet[Vector2.XY](p_args, 0)
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self, point)
		gd.UnsafeSet(p_back, ret)
	}
}

/*
User defined BiDi algorithm override function.
Returns an [Array] of [Vector3i] text ranges and text base directions, in the left-to-right order. Ranges should cover full source [param text] without overlaps. BiDi algorithm will be used on each range separately.
*/
func (Instance) _structured_text_parser(impl func(ptr unsafe.Pointer, args []any, text string) []Vector3i.XYZ) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var args = Array.Through(gd.ArrayProxy[variant.Any]{}, pointers.Pack(pointers.New[gd.Array](gd.UnsafeGet[[1]gd.EnginePointer](p_args, 0))))
		defer pointers.End(gd.InternalArray(args))
		var text = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](gd.UnsafeGet[[1]gd.EnginePointer](p_args, 1))))
		defer pointers.End(gd.InternalString(text))
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self, gd.ArrayAs[[]any](gd.InternalArray(args)), text.String())
		ptr, ok := pointers.End(gd.InternalArray(gd.ArrayFromSlice[Array.Contains[Vector3i.XYZ]](ret)))

		if !ok {
			return
		}
		gd.UnsafeSet(p_back, ptr)
	}
}

/*
Virtual method to be implemented by the user. Returns the minimum size for this control. Alternative to [member custom_minimum_size] for controlling minimum size via code. The actual minimum size will be the max value of these two (in each axis separately).
If not overridden, defaults to [constant Vector2.ZERO].
[b]Note:[/b] This method will not be called when the script is attached to a [Control] node that already overrides its minimum size (e.g. [Label], [Button], [PanelContainer] etc.). It can only be used with most basic GUI nodes, like [Control], [Container], [Panel] etc.
*/
func (Instance) _get_minimum_size(impl func(ptr unsafe.Pointer) Vector2.XY) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		gd.UnsafeSet(p_back, Vector2.XY(ret))
	}
}

/*
Virtual method to be implemented by the user. Returns the tooltip text for the position [param at_position] in control's local coordinates, which will typically appear when the cursor is resting over this control. See [method get_tooltip].
[b]Note:[/b] If this method returns an empty [String] and [method _make_custom_tooltip] is not overridden, no tooltip is displayed.
*/
func (Instance) _get_tooltip(impl func(ptr unsafe.Pointer, at_position Vector2.XY) string) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var at_position = gd.UnsafeGet[Vector2.XY](p_args, 0)
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self, at_position)
		ptr, ok := pointers.End(gd.InternalString(String.New(ret)))

		if !ok {
			return
		}
		gd.UnsafeSet(p_back, ptr)
	}
}

/*
Godot calls this method to get data that can be dragged and dropped onto controls that expect drop data. Returns [code]null[/code] if there is no data to drag. Controls that want to receive drop data should implement [method _can_drop_data] and [method _drop_data]. [param at_position] is local to this control. Drag may be forced with [method force_drag].
A preview that will follow the mouse that should represent the data can be set with [method set_drag_preview]. A good time to set the preview is in this method.
[codeblocks]
[gdscript]
func _get_drag_data(position):

	var mydata = make_data() # This is your custom method generating the drag data.
	set_drag_preview(make_preview(mydata)) # This is your custom method generating the preview of the drag data.
	return mydata

[/gdscript]
[csharp]
public override Variant _GetDragData(Vector2 atPosition)

	{
	    var myData = MakeData(); // This is your custom method generating the drag data.
	    SetDragPreview(MakePreview(myData)); // This is your custom method generating the preview of the drag data.
	    return myData;
	}

[/csharp]
[/codeblocks]
*/
func (Instance) _get_drag_data(impl func(ptr unsafe.Pointer, at_position Vector2.XY) any) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var at_position = gd.UnsafeGet[Vector2.XY](p_args, 0)
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self, at_position)
		ptr, ok := pointers.End(gd.InternalVariant(variant.New(ret)))

		if !ok {
			return
		}
		gd.UnsafeSet(p_back, ptr)
	}
}

/*
Godot calls this method to test if [param data] from a control's [method _get_drag_data] can be dropped at [param at_position]. [param at_position] is local to this control.
This method should only be used to test the data. Process the data in [method _drop_data].
[codeblocks]
[gdscript]
func _can_drop_data(position, data):

	# Check position if it is relevant to you
	# Otherwise, just check data
	return typeof(data) == TYPE_DICTIONARY and data.has("expected")

[/gdscript]
[csharp]
public override bool _CanDropData(Vector2 atPosition, Variant data)

	{
	    // Check position if it is relevant to you
	    // Otherwise, just check data
	    return data.VariantType == Variant.Type.Dictionary && data.AsGodotDictionary().ContainsKey("expected");
	}

[/csharp]
[/codeblocks]
*/
func (Instance) _can_drop_data(impl func(ptr unsafe.Pointer, at_position Vector2.XY, data any) bool) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var at_position = gd.UnsafeGet[Vector2.XY](p_args, 0)
		var data = variant.Implementation(gd.VariantProxy{}, pointers.Pack(pointers.New[gd.Variant](gd.UnsafeGet[[3]uint64](p_args, 1))))
		defer pointers.End(gd.InternalVariant(data))
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self, at_position, data.Interface())
		gd.UnsafeSet(p_back, ret)
	}
}

/*
Godot calls this method to pass you the [param data] from a control's [method _get_drag_data] result. Godot first calls [method _can_drop_data] to test if [param data] is allowed to drop at [param at_position] where [param at_position] is local to this control.
[codeblocks]
[gdscript]
func _can_drop_data(position, data):

	return typeof(data) == TYPE_DICTIONARY and data.has("color")

func _drop_data(position, data):

	var color = data["color"]

[/gdscript]
[csharp]
public override bool _CanDropData(Vector2 atPosition, Variant data)

	{
	    return data.VariantType == Variant.Type.Dictionary && data.AsGodotDictionary().ContainsKey("color");
	}

public override void _DropData(Vector2 atPosition, Variant data)

	{
	    Color color = data.AsGodotDictionary()["color"].AsColor();
	}

[/csharp]
[/codeblocks]
*/
func (Instance) _drop_data(impl func(ptr unsafe.Pointer, at_position Vector2.XY, data any)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var at_position = gd.UnsafeGet[Vector2.XY](p_args, 0)
		var data = variant.Implementation(gd.VariantProxy{}, pointers.Pack(pointers.New[gd.Variant](gd.UnsafeGet[[3]uint64](p_args, 1))))
		defer pointers.End(gd.InternalVariant(data))
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, at_position, data.Interface())
	}
}

/*
Virtual method to be implemented by the user. Returns a [Control] node that should be used as a tooltip instead of the default one. [param for_text] is the return value of [method get_tooltip].
The returned node must be of type [Control] or Control-derived. It can have child nodes of any type. It is freed when the tooltip disappears, so make sure you always provide a new instance (if you want to use a pre-existing node from your scene tree, you can duplicate it and pass the duplicated instance). When [code]null[/code] or a non-Control node is returned, the default tooltip will be used instead.
The returned node will be added as child to a [PopupPanel], so you should only provide the contents of that panel. That [PopupPanel] can be themed using [method Theme.set_stylebox] for the type [code]"TooltipPanel"[/code] (see [member tooltip_text] for an example).
[b]Note:[/b] The tooltip is shrunk to minimal size. If you want to ensure it's fully visible, you might want to set its [member custom_minimum_size] to some non-zero value.
[b]Note:[/b] The node (and any relevant children) should have their [member CanvasItem.visible] set to [code]true[/code] when returned, otherwise, the viewport that instantiates it will not be able to calculate its minimum size reliably.
[b]Note:[/b] If overridden, this method is called even if [method get_tooltip] returns an empty string. When this happens with the default tooltip, it is not displayed. To copy this behavior, return [code]null[/code] in this method when [param for_text] is empty.
[b]Example:[/b] Use a constructed node as a tooltip:
[codeblocks]
[gdscript]
func _make_custom_tooltip(for_text):

	var label = Label.new()
	label.text = for_text
	return label

[/gdscript]
[csharp]
public override Control _MakeCustomTooltip(string forText)

	{
	    var label = new Label();
	    label.Text = forText;
	    return label;
	}

[/csharp]
[/codeblocks]
[b]Example:[/b] Usa a scene instance as a tooltip:
[codeblocks]
[gdscript]
func _make_custom_tooltip(for_text):

	var tooltip = preload("res://some_tooltip_scene.tscn").instantiate()
	tooltip.get_node("Label").text = for_text
	return tooltip

[/gdscript]
[csharp]
public override Control _MakeCustomTooltip(string forText)

	{
	    Node tooltip = ResourceLoader.Load<PackedScene>("res://some_tooltip_scene.tscn").Instantiate();
	    tooltip.GetNode<Label>("Label").Text = forText;
	    return tooltip;
	}

[/csharp]
[/codeblocks]
*/
func (Instance) _make_custom_tooltip(impl func(ptr unsafe.Pointer, for_text string) Object.Instance) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var for_text = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](gd.UnsafeGet[[1]gd.EnginePointer](p_args, 0))))
		defer pointers.End(gd.InternalString(for_text))
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self, for_text.String())
		ptr, ok := pointers.End(ret[0])

		if !ok {
			return
		}
		gd.UnsafeSet(p_back, ptr)
	}
}

/*
Virtual method to be implemented by the user. Override this method to handle and accept inputs on UI elements. See also [method accept_event].
[b]Example:[/b] Click on the control to print a message:
[codeblocks]
[gdscript]
func _gui_input(event):

	if event is InputEventMouseButton:
	    if event.button_index == MOUSE_BUTTON_LEFT and event.pressed:
	        print("I've been clicked D:")

[/gdscript]
[csharp]
public override void _GuiInput(InputEvent @event)

	{
	    if (@event is InputEventMouseButton mb)
	    {
	        if (mb.ButtonIndex == MouseButton.Left && mb.Pressed)
	        {
	            GD.Print("I've been clicked D:");
	        }
	    }
	}

[/csharp]
[/codeblocks]
If the [param event] inherits [InputEventMouse], this method will [b]not[/b] be called when:
- the control's [member mouse_filter] is set to [constant MOUSE_FILTER_IGNORE];
- the control is obstructed by another control on top, that doesn't have [member mouse_filter] set to [constant MOUSE_FILTER_IGNORE];
- the control's parent has [member mouse_filter] set to [constant MOUSE_FILTER_STOP] or has accepted the event;
- the control's parent has [member clip_contents] enabled and the [param event]'s position is outside the parent's rectangle;
- the [param event]'s position is outside the control (see [method _has_point]).
[b]Note:[/b] The [param event]'s position is relative to this control's origin.
*/
func (Instance) _gui_input(impl func(ptr unsafe.Pointer, event InputEvent.Instance)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var event = [1]gdclass.InputEvent{pointers.New[gdclass.InputEvent]([3]uint64{uint64(gd.UnsafeGet[gd.EnginePointer](p_args, 0))})}

		defer pointers.End(event[0])
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, event)
	}
}

/*
Marks an input event as handled. Once you accept an input event, it stops propagating, even to nodes listening to [method Node._unhandled_input] or [method Node._unhandled_key_input].
[b]Note:[/b] This does not affect the methods in [Input], only the way events are propagated.
*/
func (self Instance) AcceptEvent() { //gd:Control.accept_event
	Advanced(self).AcceptEvent()
}

/*
Returns the minimum size for this control. See [member custom_minimum_size].
*/
func (self Instance) GetMinimumSize() Vector2.XY { //gd:Control.get_minimum_size
	return Vector2.XY(Advanced(self).GetMinimumSize())
}

/*
Returns combined minimum size from [member custom_minimum_size] and [method get_minimum_size].
*/
func (self Instance) GetCombinedMinimumSize() Vector2.XY { //gd:Control.get_combined_minimum_size
	return Vector2.XY(Advanced(self).GetCombinedMinimumSize())
}

/*
Sets the anchors to a [param preset] from [enum Control.LayoutPreset] enum. This is the code equivalent to using the Layout menu in the 2D editor.
If [param keep_offsets] is [code]true[/code], control's position will also be updated.
*/
func (self Instance) SetAnchorsPreset(preset gdclass.ControlLayoutPreset) { //gd:Control.set_anchors_preset
	Advanced(self).SetAnchorsPreset(preset, false)
}

/*
Sets the anchors to a [param preset] from [enum Control.LayoutPreset] enum. This is the code equivalent to using the Layout menu in the 2D editor.
If [param keep_offsets] is [code]true[/code], control's position will also be updated.
*/
func (self Expanded) SetAnchorsPreset(preset gdclass.ControlLayoutPreset, keep_offsets bool) { //gd:Control.set_anchors_preset
	Advanced(self).SetAnchorsPreset(preset, keep_offsets)
}

/*
Sets the offsets to a [param preset] from [enum Control.LayoutPreset] enum. This is the code equivalent to using the Layout menu in the 2D editor.
Use parameter [param resize_mode] with constants from [enum Control.LayoutPresetMode] to better determine the resulting size of the [Control]. Constant size will be ignored if used with presets that change size, e.g. [constant PRESET_LEFT_WIDE].
Use parameter [param margin] to determine the gap between the [Control] and the edges.
*/
func (self Instance) SetOffsetsPreset(preset gdclass.ControlLayoutPreset) { //gd:Control.set_offsets_preset
	Advanced(self).SetOffsetsPreset(preset, 0, int64(0))
}

/*
Sets the offsets to a [param preset] from [enum Control.LayoutPreset] enum. This is the code equivalent to using the Layout menu in the 2D editor.
Use parameter [param resize_mode] with constants from [enum Control.LayoutPresetMode] to better determine the resulting size of the [Control]. Constant size will be ignored if used with presets that change size, e.g. [constant PRESET_LEFT_WIDE].
Use parameter [param margin] to determine the gap between the [Control] and the edges.
*/
func (self Expanded) SetOffsetsPreset(preset gdclass.ControlLayoutPreset, resize_mode gdclass.ControlLayoutPresetMode, margin int) { //gd:Control.set_offsets_preset
	Advanced(self).SetOffsetsPreset(preset, resize_mode, int64(margin))
}

/*
Sets both anchor preset and offset preset. See [method set_anchors_preset] and [method set_offsets_preset].
*/
func (self Instance) SetAnchorsAndOffsetsPreset(preset gdclass.ControlLayoutPreset) { //gd:Control.set_anchors_and_offsets_preset
	Advanced(self).SetAnchorsAndOffsetsPreset(preset, 0, int64(0))
}

/*
Sets both anchor preset and offset preset. See [method set_anchors_preset] and [method set_offsets_preset].
*/
func (self Expanded) SetAnchorsAndOffsetsPreset(preset gdclass.ControlLayoutPreset, resize_mode gdclass.ControlLayoutPresetMode, margin int) { //gd:Control.set_anchors_and_offsets_preset
	Advanced(self).SetAnchorsAndOffsetsPreset(preset, resize_mode, int64(margin))
}

/*
Sets the anchor for the specified [enum Side] to [param anchor]. A setter method for [member anchor_bottom], [member anchor_left], [member anchor_right] and [member anchor_top].
If [param keep_offset] is [code]true[/code], offsets aren't updated after this operation.
If [param push_opposite_anchor] is [code]true[/code] and the opposite anchor overlaps this anchor, the opposite one will have its value overridden. For example, when setting left anchor to 1 and the right anchor has value of 0.5, the right anchor will also get value of 1. If [param push_opposite_anchor] was [code]false[/code], the left anchor would get value 0.5.
*/
func (self Instance) SetAnchor(side Side, anchor Float.X) { //gd:Control.set_anchor
	Advanced(self).SetAnchor(side, float64(anchor), false, true)
}

/*
Sets the anchor for the specified [enum Side] to [param anchor]. A setter method for [member anchor_bottom], [member anchor_left], [member anchor_right] and [member anchor_top].
If [param keep_offset] is [code]true[/code], offsets aren't updated after this operation.
If [param push_opposite_anchor] is [code]true[/code] and the opposite anchor overlaps this anchor, the opposite one will have its value overridden. For example, when setting left anchor to 1 and the right anchor has value of 0.5, the right anchor will also get value of 1. If [param push_opposite_anchor] was [code]false[/code], the left anchor would get value 0.5.
*/
func (self Expanded) SetAnchor(side Side, anchor Float.X, keep_offset bool, push_opposite_anchor bool) { //gd:Control.set_anchor
	Advanced(self).SetAnchor(side, float64(anchor), keep_offset, push_opposite_anchor)
}

/*
Works the same as [method set_anchor], but instead of [code]keep_offset[/code] argument and automatic update of offset, it allows to set the offset yourself (see [method set_offset]).
*/
func (self Instance) SetAnchorAndOffset(side Side, anchor Float.X, offset Float.X) { //gd:Control.set_anchor_and_offset
	Advanced(self).SetAnchorAndOffset(side, float64(anchor), float64(offset), false)
}

/*
Works the same as [method set_anchor], but instead of [code]keep_offset[/code] argument and automatic update of offset, it allows to set the offset yourself (see [method set_offset]).
*/
func (self Expanded) SetAnchorAndOffset(side Side, anchor Float.X, offset Float.X, push_opposite_anchor bool) { //gd:Control.set_anchor_and_offset
	Advanced(self).SetAnchorAndOffset(side, float64(anchor), float64(offset), push_opposite_anchor)
}

/*
Sets [member offset_left] and [member offset_top] at the same time. Equivalent of changing [member position].
*/
func (self Instance) SetBegin(position Vector2.XY) { //gd:Control.set_begin
	Advanced(self).SetBegin(Vector2.XY(position))
}

/*
Sets [member offset_right] and [member offset_bottom] at the same time.
*/
func (self Instance) SetEnd(position Vector2.XY) { //gd:Control.set_end
	Advanced(self).SetEnd(Vector2.XY(position))
}

/*
Sets the [member position] to given [param position].
If [param keep_offsets] is [code]true[/code], control's anchors will be updated instead of offsets.
*/
func (self Instance) SetPosition(position Vector2.XY) { //gd:Control.set_position
	Advanced(self).SetPosition(Vector2.XY(position), false)
}

/*
Sets the [member position] to given [param position].
If [param keep_offsets] is [code]true[/code], control's anchors will be updated instead of offsets.
*/
func (self Expanded) SetPosition(position Vector2.XY, keep_offsets bool) { //gd:Control.set_position
	Advanced(self).SetPosition(Vector2.XY(position), keep_offsets)
}

/*
Sets the size (see [member size]).
If [param keep_offsets] is [code]true[/code], control's anchors will be updated instead of offsets.
*/
func (self Instance) SetSize(size Vector2.XY) { //gd:Control.set_size
	Advanced(self).SetSize(Vector2.XY(size), false)
}

/*
Sets the size (see [member size]).
If [param keep_offsets] is [code]true[/code], control's anchors will be updated instead of offsets.
*/
func (self Expanded) SetSize(size Vector2.XY, keep_offsets bool) { //gd:Control.set_size
	Advanced(self).SetSize(Vector2.XY(size), keep_offsets)
}

/*
Resets the size to [method get_combined_minimum_size]. This is equivalent to calling [code]set_size(Vector2())[/code] (or any size below the minimum).
*/
func (self Instance) ResetSize() { //gd:Control.reset_size
	Advanced(self).ResetSize()
}

/*
Sets the [member global_position] to given [param position].
If [param keep_offsets] is [code]true[/code], control's anchors will be updated instead of offsets.
*/
func (self Instance) SetGlobalPosition(position Vector2.XY) { //gd:Control.set_global_position
	Advanced(self).SetGlobalPosition(Vector2.XY(position), false)
}

/*
Sets the [member global_position] to given [param position].
If [param keep_offsets] is [code]true[/code], control's anchors will be updated instead of offsets.
*/
func (self Expanded) SetGlobalPosition(position Vector2.XY, keep_offsets bool) { //gd:Control.set_global_position
	Advanced(self).SetGlobalPosition(Vector2.XY(position), keep_offsets)
}

/*
Returns [member offset_left] and [member offset_top]. See also [member position].
*/
func (self Instance) GetBegin() Vector2.XY { //gd:Control.get_begin
	return Vector2.XY(Advanced(self).GetBegin())
}

/*
Returns [member offset_right] and [member offset_bottom].
*/
func (self Instance) GetEnd() Vector2.XY { //gd:Control.get_end
	return Vector2.XY(Advanced(self).GetEnd())
}

/*
Returns the width/height occupied in the parent control.
*/
func (self Instance) GetParentAreaSize() Vector2.XY { //gd:Control.get_parent_area_size
	return Vector2.XY(Advanced(self).GetParentAreaSize())
}

/*
Returns the position of this [Control] in global screen coordinates (i.e. taking window position into account). Mostly useful for editor plugins.
Equals to [member global_position] if the window is embedded (see [member Viewport.gui_embed_subwindows]).
[b]Example:[/b] Show a popup at the mouse position:
[codeblock]
popup_menu.position = get_screen_position() + get_local_mouse_position()
popup_menu.reset_size()
popup_menu.popup()
[/codeblock]
*/
func (self Instance) GetScreenPosition() Vector2.XY { //gd:Control.get_screen_position
	return Vector2.XY(Advanced(self).GetScreenPosition())
}

/*
Returns the position and size of the control in the coordinate system of the containing node. See [member position], [member scale] and [member size].
[b]Note:[/b] If [member rotation] is not the default rotation, the resulting size is not meaningful.
[b]Note:[/b] Setting [member Viewport.gui_snap_controls_to_pixels] to [code]true[/code] can lead to rounding inaccuracies between the displayed control and the returned [Rect2].
*/
func (self Instance) GetRect() Rect2.PositionSize { //gd:Control.get_rect
	return Rect2.PositionSize(Advanced(self).GetRect())
}

/*
Returns the position and size of the control relative to the containing canvas. See [member global_position] and [member size].
[b]Note:[/b] If the node itself or any parent [CanvasItem] between the node and the canvas have a non default rotation or skew, the resulting size is likely not meaningful.
[b]Note:[/b] Setting [member Viewport.gui_snap_controls_to_pixels] to [code]true[/code] can lead to rounding inaccuracies between the displayed control and the returned [Rect2].
*/
func (self Instance) GetGlobalRect() Rect2.PositionSize { //gd:Control.get_global_rect
	return Rect2.PositionSize(Advanced(self).GetGlobalRect())
}

/*
Returns [code]true[/code] if this is the current focused control. See [member focus_mode].
*/
func (self Instance) HasFocus() bool { //gd:Control.has_focus
	return bool(Advanced(self).HasFocus())
}

/*
Steal the focus from another control and become the focused control (see [member focus_mode]).
[b]Note:[/b] Using this method together with [method Callable.call_deferred] makes it more reliable, especially when called inside [method Node._ready].
*/
func (self Instance) GrabFocus() { //gd:Control.grab_focus
	Advanced(self).GrabFocus()
}

/*
Give up the focus. No other control will be able to receive input.
*/
func (self Instance) ReleaseFocus() { //gd:Control.release_focus
	Advanced(self).ReleaseFocus()
}

/*
Finds the previous (above in the tree) [Control] that can receive the focus.
*/
func (self Instance) FindPrevValidFocus() Instance { //gd:Control.find_prev_valid_focus
	return Instance(Advanced(self).FindPrevValidFocus())
}

/*
Finds the next (below in the tree) [Control] that can receive the focus.
*/
func (self Instance) FindNextValidFocus() Instance { //gd:Control.find_next_valid_focus
	return Instance(Advanced(self).FindNextValidFocus())
}

/*
Finds the next [Control] that can receive the focus on the specified [enum Side].
[b]Note:[/b] This is different from [method get_focus_neighbor], which returns the path of a specified focus neighbor.
*/
func (self Instance) FindValidFocusNeighbor(side Side) Instance { //gd:Control.find_valid_focus_neighbor
	return Instance(Advanced(self).FindValidFocusNeighbor(side))
}

/*
Prevents [code]*_theme_*_override[/code] methods from emitting [constant NOTIFICATION_THEME_CHANGED] until [method end_bulk_theme_override] is called.
*/
func (self Instance) BeginBulkThemeOverride() { //gd:Control.begin_bulk_theme_override
	Advanced(self).BeginBulkThemeOverride()
}

/*
Ends a bulk theme override update. See [method begin_bulk_theme_override].
*/
func (self Instance) EndBulkThemeOverride() { //gd:Control.end_bulk_theme_override
	Advanced(self).EndBulkThemeOverride()
}

/*
Creates a local override for a theme icon with the specified [param name]. Local overrides always take precedence when fetching theme items for the control. An override can be removed with [method remove_theme_icon_override].
See also [method get_theme_icon].
*/
func (self Instance) AddThemeIconOverride(name string, texture Texture2D.Instance) { //gd:Control.add_theme_icon_override
	Advanced(self).AddThemeIconOverride(String.Name(String.New(name)), texture)
}

/*
Creates a local override for a theme [StyleBox] with the specified [param name]. Local overrides always take precedence when fetching theme items for the control. An override can be removed with [method remove_theme_stylebox_override].
See also [method get_theme_stylebox].
[b]Example:[/b] Modify a property in a [StyleBox] by duplicating it:
[codeblocks]
[gdscript]
# The snippet below assumes the child node "MyButton" has a StyleBoxFlat assigned.
# Resources are shared across instances, so we need to duplicate it
# to avoid modifying the appearance of all other buttons.
var new_stylebox_normal = $MyButton.get_theme_stylebox("normal").duplicate()
new_stylebox_normal.border_width_top = 3
new_stylebox_normal.border_color = Color(0, 1, 0.5)
$MyButton.add_theme_stylebox_override("normal", new_stylebox_normal)
# Remove the stylebox override.
$MyButton.remove_theme_stylebox_override("normal")
[/gdscript]
[csharp]
// The snippet below assumes the child node "MyButton" has a StyleBoxFlat assigned.
// Resources are shared across instances, so we need to duplicate it
// to avoid modifying the appearance of all other buttons.
StyleBoxFlat newStyleboxNormal = GetNode<Button>("MyButton").GetThemeStylebox("normal").Duplicate() as StyleBoxFlat;
newStyleboxNormal.BorderWidthTop = 3;
newStyleboxNormal.BorderColor = new Color(0, 1, 0.5f);
GetNode<Button>("MyButton").AddThemeStyleboxOverride("normal", newStyleboxNormal);
// Remove the stylebox override.
GetNode<Button>("MyButton").RemoveThemeStyleboxOverride("normal");
[/csharp]
[/codeblocks]
*/
func (self Instance) AddThemeStyleboxOverride(name string, stylebox StyleBox.Instance) { //gd:Control.add_theme_stylebox_override
	Advanced(self).AddThemeStyleboxOverride(String.Name(String.New(name)), stylebox)
}

/*
Creates a local override for a theme [Font] with the specified [param name]. Local overrides always take precedence when fetching theme items for the control. An override can be removed with [method remove_theme_font_override].
See also [method get_theme_font].
*/
func (self Instance) AddThemeFontOverride(name string, font Font.Instance) { //gd:Control.add_theme_font_override
	Advanced(self).AddThemeFontOverride(String.Name(String.New(name)), font)
}

/*
Creates a local override for a theme font size with the specified [param name]. Local overrides always take precedence when fetching theme items for the control. An override can be removed with [method remove_theme_font_size_override].
See also [method get_theme_font_size].
*/
func (self Instance) AddThemeFontSizeOverride(name string, font_size int) { //gd:Control.add_theme_font_size_override
	Advanced(self).AddThemeFontSizeOverride(String.Name(String.New(name)), int64(font_size))
}

/*
Creates a local override for a theme [Color] with the specified [param name]. Local overrides always take precedence when fetching theme items for the control. An override can be removed with [method remove_theme_color_override].
See also [method get_theme_color].
[b]Example:[/b] Override a [Label]'s color and reset it later:
[codeblocks]
[gdscript]
# Given the child Label node "MyLabel", override its font color with a custom value.
$MyLabel.add_theme_color_override("font_color", Color(1, 0.5, 0))
# Reset the font color of the child label.
$MyLabel.remove_theme_color_override("font_color")
# Alternatively it can be overridden with the default value from the Label type.
$MyLabel.add_theme_color_override("font_color", get_theme_color("font_color", "Label"))
[/gdscript]
[csharp]
// Given the child Label node "MyLabel", override its font color with a custom value.
GetNode<Label>("MyLabel").AddThemeColorOverride("font_color", new Color(1, 0.5f, 0));
// Reset the font color of the child label.
GetNode<Label>("MyLabel").RemoveThemeColorOverride("font_color");
// Alternatively it can be overridden with the default value from the Label type.
GetNode<Label>("MyLabel").AddThemeColorOverride("font_color", GetThemeColor("font_color", "Label"));
[/csharp]
[/codeblocks]
*/
func (self Instance) AddThemeColorOverride(name string, color Color.RGBA) { //gd:Control.add_theme_color_override
	Advanced(self).AddThemeColorOverride(String.Name(String.New(name)), Color.RGBA(color))
}

/*
Creates a local override for a theme constant with the specified [param name]. Local overrides always take precedence when fetching theme items for the control. An override can be removed with [method remove_theme_constant_override].
See also [method get_theme_constant].
*/
func (self Instance) AddThemeConstantOverride(name string, constant int) { //gd:Control.add_theme_constant_override
	Advanced(self).AddThemeConstantOverride(String.Name(String.New(name)), int64(constant))
}

/*
Removes a local override for a theme icon with the specified [param name] previously added by [method add_theme_icon_override] or via the Inspector dock.
*/
func (self Instance) RemoveThemeIconOverride(name string) { //gd:Control.remove_theme_icon_override
	Advanced(self).RemoveThemeIconOverride(String.Name(String.New(name)))
}

/*
Removes a local override for a theme [StyleBox] with the specified [param name] previously added by [method add_theme_stylebox_override] or via the Inspector dock.
*/
func (self Instance) RemoveThemeStyleboxOverride(name string) { //gd:Control.remove_theme_stylebox_override
	Advanced(self).RemoveThemeStyleboxOverride(String.Name(String.New(name)))
}

/*
Removes a local override for a theme [Font] with the specified [param name] previously added by [method add_theme_font_override] or via the Inspector dock.
*/
func (self Instance) RemoveThemeFontOverride(name string) { //gd:Control.remove_theme_font_override
	Advanced(self).RemoveThemeFontOverride(String.Name(String.New(name)))
}

/*
Removes a local override for a theme font size with the specified [param name] previously added by [method add_theme_font_size_override] or via the Inspector dock.
*/
func (self Instance) RemoveThemeFontSizeOverride(name string) { //gd:Control.remove_theme_font_size_override
	Advanced(self).RemoveThemeFontSizeOverride(String.Name(String.New(name)))
}

/*
Removes a local override for a theme [Color] with the specified [param name] previously added by [method add_theme_color_override] or via the Inspector dock.
*/
func (self Instance) RemoveThemeColorOverride(name string) { //gd:Control.remove_theme_color_override
	Advanced(self).RemoveThemeColorOverride(String.Name(String.New(name)))
}

/*
Removes a local override for a theme constant with the specified [param name] previously added by [method add_theme_constant_override] or via the Inspector dock.
*/
func (self Instance) RemoveThemeConstantOverride(name string) { //gd:Control.remove_theme_constant_override
	Advanced(self).RemoveThemeConstantOverride(String.Name(String.New(name)))
}

/*
Returns an icon from the first matching [Theme] in the tree if that [Theme] has an icon item with the specified [param name] and [param theme_type].
See [method get_theme_color] for details.
*/
func (self Instance) GetThemeIcon(name string) Texture2D.Instance { //gd:Control.get_theme_icon
	return Texture2D.Instance(Advanced(self).GetThemeIcon(String.Name(String.New(name)), String.Name(String.New(""))))
}

/*
Returns an icon from the first matching [Theme] in the tree if that [Theme] has an icon item with the specified [param name] and [param theme_type].
See [method get_theme_color] for details.
*/
func (self Expanded) GetThemeIcon(name string, theme_type string) Texture2D.Instance { //gd:Control.get_theme_icon
	return Texture2D.Instance(Advanced(self).GetThemeIcon(String.Name(String.New(name)), String.Name(String.New(theme_type))))
}

/*
Returns a [StyleBox] from the first matching [Theme] in the tree if that [Theme] has a stylebox item with the specified [param name] and [param theme_type].
See [method get_theme_color] for details.
*/
func (self Instance) GetThemeStylebox(name string) StyleBox.Instance { //gd:Control.get_theme_stylebox
	return StyleBox.Instance(Advanced(self).GetThemeStylebox(String.Name(String.New(name)), String.Name(String.New(""))))
}

/*
Returns a [StyleBox] from the first matching [Theme] in the tree if that [Theme] has a stylebox item with the specified [param name] and [param theme_type].
See [method get_theme_color] for details.
*/
func (self Expanded) GetThemeStylebox(name string, theme_type string) StyleBox.Instance { //gd:Control.get_theme_stylebox
	return StyleBox.Instance(Advanced(self).GetThemeStylebox(String.Name(String.New(name)), String.Name(String.New(theme_type))))
}

/*
Returns a [Font] from the first matching [Theme] in the tree if that [Theme] has a font item with the specified [param name] and [param theme_type].
See [method get_theme_color] for details.
*/
func (self Instance) GetThemeFont(name string) Font.Instance { //gd:Control.get_theme_font
	return Font.Instance(Advanced(self).GetThemeFont(String.Name(String.New(name)), String.Name(String.New(""))))
}

/*
Returns a [Font] from the first matching [Theme] in the tree if that [Theme] has a font item with the specified [param name] and [param theme_type].
See [method get_theme_color] for details.
*/
func (self Expanded) GetThemeFont(name string, theme_type string) Font.Instance { //gd:Control.get_theme_font
	return Font.Instance(Advanced(self).GetThemeFont(String.Name(String.New(name)), String.Name(String.New(theme_type))))
}

/*
Returns a font size from the first matching [Theme] in the tree if that [Theme] has a font size item with the specified [param name] and [param theme_type].
See [method get_theme_color] for details.
*/
func (self Instance) GetThemeFontSize(name string) int { //gd:Control.get_theme_font_size
	return int(int(Advanced(self).GetThemeFontSize(String.Name(String.New(name)), String.Name(String.New("")))))
}

/*
Returns a font size from the first matching [Theme] in the tree if that [Theme] has a font size item with the specified [param name] and [param theme_type].
See [method get_theme_color] for details.
*/
func (self Expanded) GetThemeFontSize(name string, theme_type string) int { //gd:Control.get_theme_font_size
	return int(int(Advanced(self).GetThemeFontSize(String.Name(String.New(name)), String.Name(String.New(theme_type)))))
}

/*
Returns a [Color] from the first matching [Theme] in the tree if that [Theme] has a color item with the specified [param name] and [param theme_type]. If [param theme_type] is omitted the class name of the current control is used as the type, or [member theme_type_variation] if it is defined. If the type is a class name its parent classes are also checked, in order of inheritance. If the type is a variation its base types are checked, in order of dependency, then the control's class name and its parent classes are checked.
For the current control its local overrides are considered first (see [method add_theme_color_override]), then its assigned [member theme]. After the current control, each parent control and its assigned [member theme] are considered; controls without a [member theme] assigned are skipped. If no matching [Theme] is found in the tree, the custom project [Theme] (see [member ProjectSettings.gui/theme/custom]) and the default [Theme] are used (see [ThemeDB]).
[codeblocks]
[gdscript]
func _ready():

	# Get the font color defined for the current Control's class, if it exists.
	modulate = get_theme_color("font_color")
	# Get the font color defined for the Button class.
	modulate = get_theme_color("font_color", "Button")

[/gdscript]
[csharp]
public override void _Ready()

	{
	    // Get the font color defined for the current Control's class, if it exists.
	    Modulate = GetThemeColor("font_color");
	    // Get the font color defined for the Button class.
	    Modulate = GetThemeColor("font_color", "Button");
	}

[/csharp]
[/codeblocks]
*/
func (self Instance) GetThemeColor(name string) Color.RGBA { //gd:Control.get_theme_color
	return Color.RGBA(Advanced(self).GetThemeColor(String.Name(String.New(name)), String.Name(String.New(""))))
}

/*
Returns a [Color] from the first matching [Theme] in the tree if that [Theme] has a color item with the specified [param name] and [param theme_type]. If [param theme_type] is omitted the class name of the current control is used as the type, or [member theme_type_variation] if it is defined. If the type is a class name its parent classes are also checked, in order of inheritance. If the type is a variation its base types are checked, in order of dependency, then the control's class name and its parent classes are checked.
For the current control its local overrides are considered first (see [method add_theme_color_override]), then its assigned [member theme]. After the current control, each parent control and its assigned [member theme] are considered; controls without a [member theme] assigned are skipped. If no matching [Theme] is found in the tree, the custom project [Theme] (see [member ProjectSettings.gui/theme/custom]) and the default [Theme] are used (see [ThemeDB]).
[codeblocks]
[gdscript]
func _ready():

	# Get the font color defined for the current Control's class, if it exists.
	modulate = get_theme_color("font_color")
	# Get the font color defined for the Button class.
	modulate = get_theme_color("font_color", "Button")

[/gdscript]
[csharp]
public override void _Ready()

	{
	    // Get the font color defined for the current Control's class, if it exists.
	    Modulate = GetThemeColor("font_color");
	    // Get the font color defined for the Button class.
	    Modulate = GetThemeColor("font_color", "Button");
	}

[/csharp]
[/codeblocks]
*/
func (self Expanded) GetThemeColor(name string, theme_type string) Color.RGBA { //gd:Control.get_theme_color
	return Color.RGBA(Advanced(self).GetThemeColor(String.Name(String.New(name)), String.Name(String.New(theme_type))))
}

/*
Returns a constant from the first matching [Theme] in the tree if that [Theme] has a constant item with the specified [param name] and [param theme_type].
See [method get_theme_color] for details.
*/
func (self Instance) GetThemeConstant(name string) int { //gd:Control.get_theme_constant
	return int(int(Advanced(self).GetThemeConstant(String.Name(String.New(name)), String.Name(String.New("")))))
}

/*
Returns a constant from the first matching [Theme] in the tree if that [Theme] has a constant item with the specified [param name] and [param theme_type].
See [method get_theme_color] for details.
*/
func (self Expanded) GetThemeConstant(name string, theme_type string) int { //gd:Control.get_theme_constant
	return int(int(Advanced(self).GetThemeConstant(String.Name(String.New(name)), String.Name(String.New(theme_type)))))
}

/*
Returns [code]true[/code] if there is a local override for a theme icon with the specified [param name] in this [Control] node.
See [method add_theme_icon_override].
*/
func (self Instance) HasThemeIconOverride(name string) bool { //gd:Control.has_theme_icon_override
	return bool(Advanced(self).HasThemeIconOverride(String.Name(String.New(name))))
}

/*
Returns [code]true[/code] if there is a local override for a theme [StyleBox] with the specified [param name] in this [Control] node.
See [method add_theme_stylebox_override].
*/
func (self Instance) HasThemeStyleboxOverride(name string) bool { //gd:Control.has_theme_stylebox_override
	return bool(Advanced(self).HasThemeStyleboxOverride(String.Name(String.New(name))))
}

/*
Returns [code]true[/code] if there is a local override for a theme [Font] with the specified [param name] in this [Control] node.
See [method add_theme_font_override].
*/
func (self Instance) HasThemeFontOverride(name string) bool { //gd:Control.has_theme_font_override
	return bool(Advanced(self).HasThemeFontOverride(String.Name(String.New(name))))
}

/*
Returns [code]true[/code] if there is a local override for a theme font size with the specified [param name] in this [Control] node.
See [method add_theme_font_size_override].
*/
func (self Instance) HasThemeFontSizeOverride(name string) bool { //gd:Control.has_theme_font_size_override
	return bool(Advanced(self).HasThemeFontSizeOverride(String.Name(String.New(name))))
}

/*
Returns [code]true[/code] if there is a local override for a theme [Color] with the specified [param name] in this [Control] node.
See [method add_theme_color_override].
*/
func (self Instance) HasThemeColorOverride(name string) bool { //gd:Control.has_theme_color_override
	return bool(Advanced(self).HasThemeColorOverride(String.Name(String.New(name))))
}

/*
Returns [code]true[/code] if there is a local override for a theme constant with the specified [param name] in this [Control] node.
See [method add_theme_constant_override].
*/
func (self Instance) HasThemeConstantOverride(name string) bool { //gd:Control.has_theme_constant_override
	return bool(Advanced(self).HasThemeConstantOverride(String.Name(String.New(name))))
}

/*
Returns [code]true[/code] if there is a matching [Theme] in the tree that has an icon item with the specified [param name] and [param theme_type].
See [method get_theme_color] for details.
*/
func (self Instance) HasThemeIcon(name string) bool { //gd:Control.has_theme_icon
	return bool(Advanced(self).HasThemeIcon(String.Name(String.New(name)), String.Name(String.New(""))))
}

/*
Returns [code]true[/code] if there is a matching [Theme] in the tree that has an icon item with the specified [param name] and [param theme_type].
See [method get_theme_color] for details.
*/
func (self Expanded) HasThemeIcon(name string, theme_type string) bool { //gd:Control.has_theme_icon
	return bool(Advanced(self).HasThemeIcon(String.Name(String.New(name)), String.Name(String.New(theme_type))))
}

/*
Returns [code]true[/code] if there is a matching [Theme] in the tree that has a stylebox item with the specified [param name] and [param theme_type].
See [method get_theme_color] for details.
*/
func (self Instance) HasThemeStylebox(name string) bool { //gd:Control.has_theme_stylebox
	return bool(Advanced(self).HasThemeStylebox(String.Name(String.New(name)), String.Name(String.New(""))))
}

/*
Returns [code]true[/code] if there is a matching [Theme] in the tree that has a stylebox item with the specified [param name] and [param theme_type].
See [method get_theme_color] for details.
*/
func (self Expanded) HasThemeStylebox(name string, theme_type string) bool { //gd:Control.has_theme_stylebox
	return bool(Advanced(self).HasThemeStylebox(String.Name(String.New(name)), String.Name(String.New(theme_type))))
}

/*
Returns [code]true[/code] if there is a matching [Theme] in the tree that has a font item with the specified [param name] and [param theme_type].
See [method get_theme_color] for details.
*/
func (self Instance) HasThemeFont(name string) bool { //gd:Control.has_theme_font
	return bool(Advanced(self).HasThemeFont(String.Name(String.New(name)), String.Name(String.New(""))))
}

/*
Returns [code]true[/code] if there is a matching [Theme] in the tree that has a font item with the specified [param name] and [param theme_type].
See [method get_theme_color] for details.
*/
func (self Expanded) HasThemeFont(name string, theme_type string) bool { //gd:Control.has_theme_font
	return bool(Advanced(self).HasThemeFont(String.Name(String.New(name)), String.Name(String.New(theme_type))))
}

/*
Returns [code]true[/code] if there is a matching [Theme] in the tree that has a font size item with the specified [param name] and [param theme_type].
See [method get_theme_color] for details.
*/
func (self Instance) HasThemeFontSize(name string) bool { //gd:Control.has_theme_font_size
	return bool(Advanced(self).HasThemeFontSize(String.Name(String.New(name)), String.Name(String.New(""))))
}

/*
Returns [code]true[/code] if there is a matching [Theme] in the tree that has a font size item with the specified [param name] and [param theme_type].
See [method get_theme_color] for details.
*/
func (self Expanded) HasThemeFontSize(name string, theme_type string) bool { //gd:Control.has_theme_font_size
	return bool(Advanced(self).HasThemeFontSize(String.Name(String.New(name)), String.Name(String.New(theme_type))))
}

/*
Returns [code]true[/code] if there is a matching [Theme] in the tree that has a color item with the specified [param name] and [param theme_type].
See [method get_theme_color] for details.
*/
func (self Instance) HasThemeColor(name string) bool { //gd:Control.has_theme_color
	return bool(Advanced(self).HasThemeColor(String.Name(String.New(name)), String.Name(String.New(""))))
}

/*
Returns [code]true[/code] if there is a matching [Theme] in the tree that has a color item with the specified [param name] and [param theme_type].
See [method get_theme_color] for details.
*/
func (self Expanded) HasThemeColor(name string, theme_type string) bool { //gd:Control.has_theme_color
	return bool(Advanced(self).HasThemeColor(String.Name(String.New(name)), String.Name(String.New(theme_type))))
}

/*
Returns [code]true[/code] if there is a matching [Theme] in the tree that has a constant item with the specified [param name] and [param theme_type].
See [method get_theme_color] for details.
*/
func (self Instance) HasThemeConstant(name string) bool { //gd:Control.has_theme_constant
	return bool(Advanced(self).HasThemeConstant(String.Name(String.New(name)), String.Name(String.New(""))))
}

/*
Returns [code]true[/code] if there is a matching [Theme] in the tree that has a constant item with the specified [param name] and [param theme_type].
See [method get_theme_color] for details.
*/
func (self Expanded) HasThemeConstant(name string, theme_type string) bool { //gd:Control.has_theme_constant
	return bool(Advanced(self).HasThemeConstant(String.Name(String.New(name)), String.Name(String.New(theme_type))))
}

/*
Returns the default base scale value from the first matching [Theme] in the tree if that [Theme] has a valid [member Theme.default_base_scale] value.
See [method get_theme_color] for details.
*/
func (self Instance) GetThemeDefaultBaseScale() Float.X { //gd:Control.get_theme_default_base_scale
	return Float.X(Float.X(Advanced(self).GetThemeDefaultBaseScale()))
}

/*
Returns the default font from the first matching [Theme] in the tree if that [Theme] has a valid [member Theme.default_font] value.
See [method get_theme_color] for details.
*/
func (self Instance) GetThemeDefaultFont() Font.Instance { //gd:Control.get_theme_default_font
	return Font.Instance(Advanced(self).GetThemeDefaultFont())
}

/*
Returns the default font size value from the first matching [Theme] in the tree if that [Theme] has a valid [member Theme.default_font_size] value.
See [method get_theme_color] for details.
*/
func (self Instance) GetThemeDefaultFontSize() int { //gd:Control.get_theme_default_font_size
	return int(int(Advanced(self).GetThemeDefaultFontSize()))
}

/*
Returns the parent control node.
*/
func (self Instance) GetParentControl() Instance { //gd:Control.get_parent_control
	return Instance(Advanced(self).GetParentControl())
}

/*
Returns the tooltip text for the position [param at_position] in control's local coordinates, which will typically appear when the cursor is resting over this control. By default, it returns [member tooltip_text].
This method can be overridden to customize its behavior. See [method _get_tooltip].
[b]Note:[/b] If this method returns an empty [String] and [method _make_custom_tooltip] is not overridden, no tooltip is displayed.
*/
func (self Instance) GetTooltip() string { //gd:Control.get_tooltip
	return string(Advanced(self).GetTooltip(Vector2.XY(gd.Vector2{0, 0})).String())
}

/*
Returns the tooltip text for the position [param at_position] in control's local coordinates, which will typically appear when the cursor is resting over this control. By default, it returns [member tooltip_text].
This method can be overridden to customize its behavior. See [method _get_tooltip].
[b]Note:[/b] If this method returns an empty [String] and [method _make_custom_tooltip] is not overridden, no tooltip is displayed.
*/
func (self Expanded) GetTooltip(at_position Vector2.XY) string { //gd:Control.get_tooltip
	return string(Advanced(self).GetTooltip(Vector2.XY(at_position)).String())
}

/*
Returns the mouse cursor shape the control displays on mouse hover. See [enum CursorShape].
*/
func (self Instance) GetCursorShape() gdclass.ControlCursorShape { //gd:Control.get_cursor_shape
	return gdclass.ControlCursorShape(Advanced(self).GetCursorShape(Vector2.XY(gd.Vector2{0, 0})))
}

/*
Returns the mouse cursor shape the control displays on mouse hover. See [enum CursorShape].
*/
func (self Expanded) GetCursorShape(position Vector2.XY) gdclass.ControlCursorShape { //gd:Control.get_cursor_shape
	return gdclass.ControlCursorShape(Advanced(self).GetCursorShape(Vector2.XY(position)))
}

/*
Forces drag and bypasses [method _get_drag_data] and [method set_drag_preview] by passing [param data] and [param preview]. Drag will start even if the mouse is neither over nor pressed on this control.
The methods [method _can_drop_data] and [method _drop_data] must be implemented on controls that want to receive drop data.
*/
func (self Instance) ForceDrag(data any, preview Instance) { //gd:Control.force_drag
	Advanced(self).ForceDrag(variant.New(data), preview)
}

/*
Creates an [InputEventMouseButton] that attempts to click the control. If the event is received, the control gains focus.
[codeblocks]
[gdscript]
func _process(delta):

	grab_click_focus() # When clicking another Control node, this node will be clicked instead.

[/gdscript]
[csharp]
public override void _Process(double delta)

	{
	    GrabClickFocus(); // When clicking another Control node, this node will be clicked instead.
	}

[/csharp]
[/codeblocks]
*/
func (self Instance) GrabClickFocus() { //gd:Control.grab_click_focus
	Advanced(self).GrabClickFocus()
}

/*
Sets the given callables to be used instead of the control's own drag-and-drop virtual methods. If a callable is empty, its respective virtual method is used as normal.
The arguments for each callable should be exactly the same as their respective virtual methods, which would be:
- [param drag_func] corresponds to [method _get_drag_data] and requires a [Vector2];
- [param can_drop_func] corresponds to [method _can_drop_data] and requires both a [Vector2] and a [Variant];
- [param drop_func] corresponds to [method _drop_data] and requires both a [Vector2] and a [Variant].
*/
func (self Instance) SetDragForwarding(drag_func func(at_position Vector2.XY) any, can_drop_func func(at_position Vector2.XY, data any) bool, drop_func func(at_position Vector2.XY, data any)) { //gd:Control.set_drag_forwarding
	Advanced(self).SetDragForwarding(Callable.New(drag_func), Callable.New(can_drop_func), Callable.New(drop_func))
}

/*
Shows the given control at the mouse pointer. A good time to call this method is in [method _get_drag_data]. The control must not be in the scene tree. You should not free the control, and you should not keep a reference to the control beyond the duration of the drag. It will be deleted automatically after the drag has ended.
[codeblocks]
[gdscript]
@export var color = Color(1, 0, 0, 1)

func _get_drag_data(position):

	# Use a control that is not in the tree
	var cpb = ColorPickerButton.new()
	cpb.color = color
	cpb.size = Vector2(50, 50)
	set_drag_preview(cpb)
	return color

[/gdscript]
[csharp]
[Export]
private Color _color = new Color(1, 0, 0, 1);

public override Variant _GetDragData(Vector2 atPosition)

	{
	    // Use a control that is not in the tree
	    var cpb = new ColorPickerButton();
	    cpb.Color = _color;
	    cpb.Size = new Vector2(50, 50);
	    SetDragPreview(cpb);
	    return _color;
	}

[/csharp]
[/codeblocks]
*/
func (self Instance) SetDragPreview(control Instance) { //gd:Control.set_drag_preview
	Advanced(self).SetDragPreview(control)
}

/*
Returns [code]true[/code] if a drag operation is successful. Alternative to [method Viewport.gui_is_drag_successful].
Best used with [constant Node.NOTIFICATION_DRAG_END].
*/
func (self Instance) IsDragSuccessful() bool { //gd:Control.is_drag_successful
	return bool(Advanced(self).IsDragSuccessful())
}

/*
Moves the mouse cursor to [param position], relative to [member position] of this [Control].
[b]Note:[/b] [method warp_mouse] is only supported on Windows, macOS and Linux. It has no effect on Android, iOS and Web.
*/
func (self Instance) WarpMouse(position Vector2.XY) { //gd:Control.warp_mouse
	Advanced(self).WarpMouse(Vector2.XY(position))
}

/*
Invalidates the size cache in this node and in parent nodes up to top level. Intended to be used with [method get_minimum_size] when the return value is changed. Setting [member custom_minimum_size] directly calls this method automatically.
*/
func (self Instance) UpdateMinimumSize() { //gd:Control.update_minimum_size
	Advanced(self).UpdateMinimumSize()
}

/*
Returns [code]true[/code] if layout is right-to-left. See also [member layout_direction].
*/
func (self Instance) IsLayoutRtl() bool { //gd:Control.is_layout_rtl
	return bool(Advanced(self).IsLayoutRtl())
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.Control

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Extension[T]) AsObject() [1]gd.Object     { return self.Super().AsObject() }
func New() Instance {
	object := gd.Global.ClassDB.ConstructObject(gd.NewStringName("Control"))
	casted := Instance{*(*gdclass.Control)(unsafe.Pointer(&object))}
	return casted
}

func (self Instance) ClipContents() bool {
	return bool(class(self).IsClippingContents())
}

func (self Instance) SetClipContents(value bool) {
	class(self).SetClipContents(value)
}

func (self Instance) CustomMinimumSize() Vector2.XY {
	return Vector2.XY(class(self).GetCustomMinimumSize())
}

func (self Instance) SetCustomMinimumSize(value Vector2.XY) {
	class(self).SetCustomMinimumSize(Vector2.XY(value))
}

func (self Instance) LayoutDirection() gdclass.ControlLayoutDirection {
	return gdclass.ControlLayoutDirection(class(self).GetLayoutDirection())
}

func (self Instance) SetLayoutDirection(value gdclass.ControlLayoutDirection) {
	class(self).SetLayoutDirection(value)
}

func (self Instance) AnchorLeft() Float.X {
	return Float.X(Float.X(class(self).GetAnchor(0)))
}

func (self Instance) AnchorTop() Float.X {
	return Float.X(Float.X(class(self).GetAnchor(1)))
}

func (self Instance) AnchorRight() Float.X {
	return Float.X(Float.X(class(self).GetAnchor(2)))
}

func (self Instance) AnchorBottom() Float.X {
	return Float.X(Float.X(class(self).GetAnchor(3)))
}

func (self Instance) OffsetLeft() Float.X {
	return Float.X(Float.X(class(self).GetOffset(0)))
}

func (self Instance) SetOffsetLeft(value Float.X) {
	class(self).SetOffset(0, float64(value))
}

func (self Instance) OffsetTop() Float.X {
	return Float.X(Float.X(class(self).GetOffset(1)))
}

func (self Instance) SetOffsetTop(value Float.X) {
	class(self).SetOffset(1, float64(value))
}

func (self Instance) OffsetRight() Float.X {
	return Float.X(Float.X(class(self).GetOffset(2)))
}

func (self Instance) SetOffsetRight(value Float.X) {
	class(self).SetOffset(2, float64(value))
}

func (self Instance) OffsetBottom() Float.X {
	return Float.X(Float.X(class(self).GetOffset(3)))
}

func (self Instance) SetOffsetBottom(value Float.X) {
	class(self).SetOffset(3, float64(value))
}

func (self Instance) GrowHorizontal() gdclass.ControlGrowDirection {
	return gdclass.ControlGrowDirection(class(self).GetHGrowDirection())
}

func (self Instance) SetGrowHorizontal(value gdclass.ControlGrowDirection) {
	class(self).SetHGrowDirection(value)
}

func (self Instance) GrowVertical() gdclass.ControlGrowDirection {
	return gdclass.ControlGrowDirection(class(self).GetVGrowDirection())
}

func (self Instance) SetGrowVertical(value gdclass.ControlGrowDirection) {
	class(self).SetVGrowDirection(value)
}

func (self Instance) Size() Vector2.XY {
	return Vector2.XY(class(self).GetSize())
}

func (self Instance) Position() Vector2.XY {
	return Vector2.XY(class(self).GetPosition())
}

func (self Instance) GlobalPosition() Vector2.XY {
	return Vector2.XY(class(self).GetGlobalPosition())
}

func (self Instance) Rotation() Float.X {
	return Float.X(Float.X(class(self).GetRotation()))
}

func (self Instance) SetRotation(value Float.X) {
	class(self).SetRotation(float64(value))
}

func (self Instance) RotationDegrees() Float.X {
	return Float.X(Float.X(class(self).GetRotationDegrees()))
}

func (self Instance) SetRotationDegrees(value Float.X) {
	class(self).SetRotationDegrees(float64(value))
}

func (self Instance) Scale() Vector2.XY {
	return Vector2.XY(class(self).GetScale())
}

func (self Instance) SetScale(value Vector2.XY) {
	class(self).SetScale(Vector2.XY(value))
}

func (self Instance) PivotOffset() Vector2.XY {
	return Vector2.XY(class(self).GetPivotOffset())
}

func (self Instance) SetPivotOffset(value Vector2.XY) {
	class(self).SetPivotOffset(Vector2.XY(value))
}

func (self Instance) SizeFlagsHorizontal() gdclass.ControlSizeFlags {
	return gdclass.ControlSizeFlags(class(self).GetHSizeFlags())
}

func (self Instance) SetSizeFlagsHorizontal(value gdclass.ControlSizeFlags) {
	class(self).SetHSizeFlags(value)
}

func (self Instance) SizeFlagsVertical() gdclass.ControlSizeFlags {
	return gdclass.ControlSizeFlags(class(self).GetVSizeFlags())
}

func (self Instance) SetSizeFlagsVertical(value gdclass.ControlSizeFlags) {
	class(self).SetVSizeFlags(value)
}

func (self Instance) SizeFlagsStretchRatio() Float.X {
	return Float.X(Float.X(class(self).GetStretchRatio()))
}

func (self Instance) SetSizeFlagsStretchRatio(value Float.X) {
	class(self).SetStretchRatio(float64(value))
}

func (self Instance) LocalizeNumeralSystem() bool {
	return bool(class(self).IsLocalizingNumeralSystem())
}

func (self Instance) SetLocalizeNumeralSystem(value bool) {
	class(self).SetLocalizeNumeralSystem(value)
}

func (self Instance) AutoTranslate() bool {
	return bool(class(self).IsAutoTranslating())
}

func (self Instance) SetAutoTranslate(value bool) {
	class(self).SetAutoTranslate(value)
}

func (self Instance) TooltipText() string {
	return string(class(self).GetTooltipText().String())
}

func (self Instance) SetTooltipText(value string) {
	class(self).SetTooltipText(String.New(value))
}

func (self Instance) TooltipAutoTranslateMode() gdclass.NodeAutoTranslateMode {
	return gdclass.NodeAutoTranslateMode(class(self).GetTooltipAutoTranslateMode())
}

func (self Instance) SetTooltipAutoTranslateMode(value gdclass.NodeAutoTranslateMode) {
	class(self).SetTooltipAutoTranslateMode(value)
}

func (self Instance) FocusNeighborLeft() string {
	return string(class(self).GetFocusNeighbor(0).String())
}

func (self Instance) SetFocusNeighborLeft(value string) {
	class(self).SetFocusNeighbor(0, Path.ToNode(String.New(value)))
}

func (self Instance) FocusNeighborTop() string {
	return string(class(self).GetFocusNeighbor(1).String())
}

func (self Instance) SetFocusNeighborTop(value string) {
	class(self).SetFocusNeighbor(1, Path.ToNode(String.New(value)))
}

func (self Instance) FocusNeighborRight() string {
	return string(class(self).GetFocusNeighbor(2).String())
}

func (self Instance) SetFocusNeighborRight(value string) {
	class(self).SetFocusNeighbor(2, Path.ToNode(String.New(value)))
}

func (self Instance) FocusNeighborBottom() string {
	return string(class(self).GetFocusNeighbor(3).String())
}

func (self Instance) SetFocusNeighborBottom(value string) {
	class(self).SetFocusNeighbor(3, Path.ToNode(String.New(value)))
}

func (self Instance) FocusNext() string {
	return string(class(self).GetFocusNext().String())
}

func (self Instance) SetFocusNext(value string) {
	class(self).SetFocusNext(Path.ToNode(String.New(value)))
}

func (self Instance) FocusPrevious() string {
	return string(class(self).GetFocusPrevious().String())
}

func (self Instance) SetFocusPrevious(value string) {
	class(self).SetFocusPrevious(Path.ToNode(String.New(value)))
}

func (self Instance) FocusMode() gdclass.ControlFocusMode {
	return gdclass.ControlFocusMode(class(self).GetFocusMode())
}

func (self Instance) SetFocusMode(value gdclass.ControlFocusMode) {
	class(self).SetFocusMode(value)
}

func (self Instance) MouseFilter() gdclass.ControlMouseFilter {
	return gdclass.ControlMouseFilter(class(self).GetMouseFilter())
}

func (self Instance) SetMouseFilter(value gdclass.ControlMouseFilter) {
	class(self).SetMouseFilter(value)
}

func (self Instance) MouseForcePassScrollEvents() bool {
	return bool(class(self).IsForcePassScrollEvents())
}

func (self Instance) SetMouseForcePassScrollEvents(value bool) {
	class(self).SetForcePassScrollEvents(value)
}

func (self Instance) MouseDefaultCursorShape() gdclass.ControlCursorShape {
	return gdclass.ControlCursorShape(class(self).GetDefaultCursorShape())
}

func (self Instance) SetMouseDefaultCursorShape(value gdclass.ControlCursorShape) {
	class(self).SetDefaultCursorShape(value)
}

func (self Instance) ShortcutContext() Node.Instance {
	return Node.Instance(class(self).GetShortcutContext())
}

func (self Instance) SetShortcutContext(value Node.Instance) {
	class(self).SetShortcutContext(value)
}

func (self Instance) Theme() Theme.Instance {
	return Theme.Instance(class(self).GetTheme())
}

func (self Instance) SetTheme(value Theme.Instance) {
	class(self).SetTheme(value)
}

func (self Instance) ThemeTypeVariation() string {
	return string(class(self).GetThemeTypeVariation().String())
}

func (self Instance) SetThemeTypeVariation(value string) {
	class(self).SetThemeTypeVariation(String.Name(String.New(value)))
}

/*
Virtual method to be implemented by the user. Returns whether the given [param point] is inside this control.
If not overridden, default behavior is checking if the point is within control's Rect.
[b]Note:[/b] If you want to check if a point is inside the control, you can use [code]Rect2(Vector2.ZERO, size).has_point(point)[/code].
*/
func (class) _has_point(impl func(ptr unsafe.Pointer, point Vector2.XY) bool) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var point = gd.UnsafeGet[Vector2.XY](p_args, 0)
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self, point)
		gd.UnsafeSet(p_back, ret)
	}
}

/*
User defined BiDi algorithm override function.
Returns an [Array] of [Vector3i] text ranges and text base directions, in the left-to-right order. Ranges should cover full source [param text] without overlaps. BiDi algorithm will be used on each range separately.
*/
func (class) _structured_text_parser(impl func(ptr unsafe.Pointer, args Array.Any, text String.Readable) Array.Contains[Vector3i.XYZ]) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var args = Array.Through(gd.ArrayProxy[variant.Any]{}, pointers.Pack(pointers.New[gd.Array](gd.UnsafeGet[[1]gd.EnginePointer](p_args, 0))))
		defer pointers.End(gd.InternalArray(args))
		var text = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](gd.UnsafeGet[[1]gd.EnginePointer](p_args, 1))))
		defer pointers.End(gd.InternalString(text))
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self, args, text)
		ptr, ok := pointers.End(gd.InternalArray(ret))

		if !ok {
			return
		}
		gd.UnsafeSet(p_back, ptr)
	}
}

/*
Virtual method to be implemented by the user. Returns the minimum size for this control. Alternative to [member custom_minimum_size] for controlling minimum size via code. The actual minimum size will be the max value of these two (in each axis separately).
If not overridden, defaults to [constant Vector2.ZERO].
[b]Note:[/b] This method will not be called when the script is attached to a [Control] node that already overrides its minimum size (e.g. [Label], [Button], [PanelContainer] etc.). It can only be used with most basic GUI nodes, like [Control], [Container], [Panel] etc.
*/
func (class) _get_minimum_size(impl func(ptr unsafe.Pointer) Vector2.XY) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		gd.UnsafeSet(p_back, ret)
	}
}

/*
Virtual method to be implemented by the user. Returns the tooltip text for the position [param at_position] in control's local coordinates, which will typically appear when the cursor is resting over this control. See [method get_tooltip].
[b]Note:[/b] If this method returns an empty [String] and [method _make_custom_tooltip] is not overridden, no tooltip is displayed.
*/
func (class) _get_tooltip(impl func(ptr unsafe.Pointer, at_position Vector2.XY) String.Readable) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var at_position = gd.UnsafeGet[Vector2.XY](p_args, 0)
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self, at_position)
		ptr, ok := pointers.End(gd.InternalString(ret))

		if !ok {
			return
		}
		gd.UnsafeSet(p_back, ptr)
	}
}

/*
Godot calls this method to get data that can be dragged and dropped onto controls that expect drop data. Returns [code]null[/code] if there is no data to drag. Controls that want to receive drop data should implement [method _can_drop_data] and [method _drop_data]. [param at_position] is local to this control. Drag may be forced with [method force_drag].
A preview that will follow the mouse that should represent the data can be set with [method set_drag_preview]. A good time to set the preview is in this method.
[codeblocks]
[gdscript]
func _get_drag_data(position):

	var mydata = make_data() # This is your custom method generating the drag data.
	set_drag_preview(make_preview(mydata)) # This is your custom method generating the preview of the drag data.
	return mydata

[/gdscript]
[csharp]
public override Variant _GetDragData(Vector2 atPosition)

	{
	    var myData = MakeData(); // This is your custom method generating the drag data.
	    SetDragPreview(MakePreview(myData)); // This is your custom method generating the preview of the drag data.
	    return myData;
	}

[/csharp]
[/codeblocks]
*/
func (class) _get_drag_data(impl func(ptr unsafe.Pointer, at_position Vector2.XY) variant.Any) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var at_position = gd.UnsafeGet[Vector2.XY](p_args, 0)
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self, at_position)
		ptr, ok := pointers.End(gd.InternalVariant(ret))

		if !ok {
			return
		}
		gd.UnsafeSet(p_back, ptr)
	}
}

/*
Godot calls this method to test if [param data] from a control's [method _get_drag_data] can be dropped at [param at_position]. [param at_position] is local to this control.
This method should only be used to test the data. Process the data in [method _drop_data].
[codeblocks]
[gdscript]
func _can_drop_data(position, data):

	# Check position if it is relevant to you
	# Otherwise, just check data
	return typeof(data) == TYPE_DICTIONARY and data.has("expected")

[/gdscript]
[csharp]
public override bool _CanDropData(Vector2 atPosition, Variant data)

	{
	    // Check position if it is relevant to you
	    // Otherwise, just check data
	    return data.VariantType == Variant.Type.Dictionary && data.AsGodotDictionary().ContainsKey("expected");
	}

[/csharp]
[/codeblocks]
*/
func (class) _can_drop_data(impl func(ptr unsafe.Pointer, at_position Vector2.XY, data variant.Any) bool) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var at_position = gd.UnsafeGet[Vector2.XY](p_args, 0)
		var data = variant.Implementation(gd.VariantProxy{}, pointers.Pack(pointers.New[gd.Variant](gd.UnsafeGet[[3]uint64](p_args, 1))))
		defer pointers.End(gd.InternalVariant(data))
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self, at_position, data)
		gd.UnsafeSet(p_back, ret)
	}
}

/*
Godot calls this method to pass you the [param data] from a control's [method _get_drag_data] result. Godot first calls [method _can_drop_data] to test if [param data] is allowed to drop at [param at_position] where [param at_position] is local to this control.
[codeblocks]
[gdscript]
func _can_drop_data(position, data):

	return typeof(data) == TYPE_DICTIONARY and data.has("color")

func _drop_data(position, data):

	var color = data["color"]

[/gdscript]
[csharp]
public override bool _CanDropData(Vector2 atPosition, Variant data)

	{
	    return data.VariantType == Variant.Type.Dictionary && data.AsGodotDictionary().ContainsKey("color");
	}

public override void _DropData(Vector2 atPosition, Variant data)

	{
	    Color color = data.AsGodotDictionary()["color"].AsColor();
	}

[/csharp]
[/codeblocks]
*/
func (class) _drop_data(impl func(ptr unsafe.Pointer, at_position Vector2.XY, data variant.Any)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var at_position = gd.UnsafeGet[Vector2.XY](p_args, 0)
		var data = variant.Implementation(gd.VariantProxy{}, pointers.Pack(pointers.New[gd.Variant](gd.UnsafeGet[[3]uint64](p_args, 1))))
		defer pointers.End(gd.InternalVariant(data))
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, at_position, data)
	}
}

/*
Virtual method to be implemented by the user. Returns a [Control] node that should be used as a tooltip instead of the default one. [param for_text] is the return value of [method get_tooltip].
The returned node must be of type [Control] or Control-derived. It can have child nodes of any type. It is freed when the tooltip disappears, so make sure you always provide a new instance (if you want to use a pre-existing node from your scene tree, you can duplicate it and pass the duplicated instance). When [code]null[/code] or a non-Control node is returned, the default tooltip will be used instead.
The returned node will be added as child to a [PopupPanel], so you should only provide the contents of that panel. That [PopupPanel] can be themed using [method Theme.set_stylebox] for the type [code]"TooltipPanel"[/code] (see [member tooltip_text] for an example).
[b]Note:[/b] The tooltip is shrunk to minimal size. If you want to ensure it's fully visible, you might want to set its [member custom_minimum_size] to some non-zero value.
[b]Note:[/b] The node (and any relevant children) should have their [member CanvasItem.visible] set to [code]true[/code] when returned, otherwise, the viewport that instantiates it will not be able to calculate its minimum size reliably.
[b]Note:[/b] If overridden, this method is called even if [method get_tooltip] returns an empty string. When this happens with the default tooltip, it is not displayed. To copy this behavior, return [code]null[/code] in this method when [param for_text] is empty.
[b]Example:[/b] Use a constructed node as a tooltip:
[codeblocks]
[gdscript]
func _make_custom_tooltip(for_text):

	var label = Label.new()
	label.text = for_text
	return label

[/gdscript]
[csharp]
public override Control _MakeCustomTooltip(string forText)

	{
	    var label = new Label();
	    label.Text = forText;
	    return label;
	}

[/csharp]
[/codeblocks]
[b]Example:[/b] Usa a scene instance as a tooltip:
[codeblocks]
[gdscript]
func _make_custom_tooltip(for_text):

	var tooltip = preload("res://some_tooltip_scene.tscn").instantiate()
	tooltip.get_node("Label").text = for_text
	return tooltip

[/gdscript]
[csharp]
public override Control _MakeCustomTooltip(string forText)

	{
	    Node tooltip = ResourceLoader.Load<PackedScene>("res://some_tooltip_scene.tscn").Instantiate();
	    tooltip.GetNode<Label>("Label").Text = forText;
	    return tooltip;
	}

[/csharp]
[/codeblocks]
*/
func (class) _make_custom_tooltip(impl func(ptr unsafe.Pointer, for_text String.Readable) [1]gd.Object) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var for_text = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](gd.UnsafeGet[[1]gd.EnginePointer](p_args, 0))))
		defer pointers.End(gd.InternalString(for_text))
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self, for_text)
		ptr, ok := pointers.End(ret[0])

		if !ok {
			return
		}
		gd.UnsafeSet(p_back, ptr)
	}
}

/*
Virtual method to be implemented by the user. Override this method to handle and accept inputs on UI elements. See also [method accept_event].
[b]Example:[/b] Click on the control to print a message:
[codeblocks]
[gdscript]
func _gui_input(event):

	if event is InputEventMouseButton:
	    if event.button_index == MOUSE_BUTTON_LEFT and event.pressed:
	        print("I've been clicked D:")

[/gdscript]
[csharp]
public override void _GuiInput(InputEvent @event)

	{
	    if (@event is InputEventMouseButton mb)
	    {
	        if (mb.ButtonIndex == MouseButton.Left && mb.Pressed)
	        {
	            GD.Print("I've been clicked D:");
	        }
	    }
	}

[/csharp]
[/codeblocks]
If the [param event] inherits [InputEventMouse], this method will [b]not[/b] be called when:
- the control's [member mouse_filter] is set to [constant MOUSE_FILTER_IGNORE];
- the control is obstructed by another control on top, that doesn't have [member mouse_filter] set to [constant MOUSE_FILTER_IGNORE];
- the control's parent has [member mouse_filter] set to [constant MOUSE_FILTER_STOP] or has accepted the event;
- the control's parent has [member clip_contents] enabled and the [param event]'s position is outside the parent's rectangle;
- the [param event]'s position is outside the control (see [method _has_point]).
[b]Note:[/b] The [param event]'s position is relative to this control's origin.
*/
func (class) _gui_input(impl func(ptr unsafe.Pointer, event [1]gdclass.InputEvent)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var event = [1]gdclass.InputEvent{pointers.New[gdclass.InputEvent]([3]uint64{uint64(gd.UnsafeGet[gd.EnginePointer](p_args, 0))})}

		defer pointers.End(event[0])
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, event)
	}
}

/*
Marks an input event as handled. Once you accept an input event, it stops propagating, even to nodes listening to [method Node._unhandled_input] or [method Node._unhandled_key_input].
[b]Note:[/b] This does not affect the methods in [Input], only the way events are propagated.
*/
//go:nosplit
func (self class) AcceptEvent() { //gd:Control.accept_event
	var frame = callframe.New()
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_accept_event, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Returns the minimum size for this control. See [member custom_minimum_size].
*/
//go:nosplit
func (self class) GetMinimumSize() Vector2.XY { //gd:Control.get_minimum_size
	var frame = callframe.New()
	var r_ret = callframe.Ret[Vector2.XY](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_get_minimum_size, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns combined minimum size from [member custom_minimum_size] and [method get_minimum_size].
*/
//go:nosplit
func (self class) GetCombinedMinimumSize() Vector2.XY { //gd:Control.get_combined_minimum_size
	var frame = callframe.New()
	var r_ret = callframe.Ret[Vector2.XY](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_get_combined_minimum_size, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Sets the anchors to a [param preset] from [enum Control.LayoutPreset] enum. This is the code equivalent to using the Layout menu in the 2D editor.
If [param keep_offsets] is [code]true[/code], control's position will also be updated.
*/
//go:nosplit
func (self class) SetAnchorsPreset(preset gdclass.ControlLayoutPreset, keep_offsets bool) { //gd:Control.set_anchors_preset
	var frame = callframe.New()
	callframe.Arg(frame, preset)
	callframe.Arg(frame, keep_offsets)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_set_anchors_preset, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Sets the offsets to a [param preset] from [enum Control.LayoutPreset] enum. This is the code equivalent to using the Layout menu in the 2D editor.
Use parameter [param resize_mode] with constants from [enum Control.LayoutPresetMode] to better determine the resulting size of the [Control]. Constant size will be ignored if used with presets that change size, e.g. [constant PRESET_LEFT_WIDE].
Use parameter [param margin] to determine the gap between the [Control] and the edges.
*/
//go:nosplit
func (self class) SetOffsetsPreset(preset gdclass.ControlLayoutPreset, resize_mode gdclass.ControlLayoutPresetMode, margin int64) { //gd:Control.set_offsets_preset
	var frame = callframe.New()
	callframe.Arg(frame, preset)
	callframe.Arg(frame, resize_mode)
	callframe.Arg(frame, margin)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_set_offsets_preset, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Sets both anchor preset and offset preset. See [method set_anchors_preset] and [method set_offsets_preset].
*/
//go:nosplit
func (self class) SetAnchorsAndOffsetsPreset(preset gdclass.ControlLayoutPreset, resize_mode gdclass.ControlLayoutPresetMode, margin int64) { //gd:Control.set_anchors_and_offsets_preset
	var frame = callframe.New()
	callframe.Arg(frame, preset)
	callframe.Arg(frame, resize_mode)
	callframe.Arg(frame, margin)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_set_anchors_and_offsets_preset, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Sets the anchor for the specified [enum Side] to [param anchor]. A setter method for [member anchor_bottom], [member anchor_left], [member anchor_right] and [member anchor_top].
If [param keep_offset] is [code]true[/code], offsets aren't updated after this operation.
If [param push_opposite_anchor] is [code]true[/code] and the opposite anchor overlaps this anchor, the opposite one will have its value overridden. For example, when setting left anchor to 1 and the right anchor has value of 0.5, the right anchor will also get value of 1. If [param push_opposite_anchor] was [code]false[/code], the left anchor would get value 0.5.
*/
//go:nosplit
func (self class) SetAnchor(side Side, anchor float64, keep_offset bool, push_opposite_anchor bool) { //gd:Control.set_anchor
	var frame = callframe.New()
	callframe.Arg(frame, side)
	callframe.Arg(frame, anchor)
	callframe.Arg(frame, keep_offset)
	callframe.Arg(frame, push_opposite_anchor)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_set_anchor, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Returns the anchor for the specified [enum Side]. A getter method for [member anchor_bottom], [member anchor_left], [member anchor_right] and [member anchor_top].
*/
//go:nosplit
func (self class) GetAnchor(side Side) float64 { //gd:Control.get_anchor
	var frame = callframe.New()
	callframe.Arg(frame, side)
	var r_ret = callframe.Ret[float64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_get_anchor, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Sets the offset for the specified [enum Side] to [param offset]. A setter method for [member offset_bottom], [member offset_left], [member offset_right] and [member offset_top].
*/
//go:nosplit
func (self class) SetOffset(side Side, offset float64) { //gd:Control.set_offset
	var frame = callframe.New()
	callframe.Arg(frame, side)
	callframe.Arg(frame, offset)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_set_offset, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Returns the offset for the specified [enum Side]. A getter method for [member offset_bottom], [member offset_left], [member offset_right] and [member offset_top].
*/
//go:nosplit
func (self class) GetOffset(offset Side) float64 { //gd:Control.get_offset
	var frame = callframe.New()
	callframe.Arg(frame, offset)
	var r_ret = callframe.Ret[float64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_get_offset, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Works the same as [method set_anchor], but instead of [code]keep_offset[/code] argument and automatic update of offset, it allows to set the offset yourself (see [method set_offset]).
*/
//go:nosplit
func (self class) SetAnchorAndOffset(side Side, anchor float64, offset float64, push_opposite_anchor bool) { //gd:Control.set_anchor_and_offset
	var frame = callframe.New()
	callframe.Arg(frame, side)
	callframe.Arg(frame, anchor)
	callframe.Arg(frame, offset)
	callframe.Arg(frame, push_opposite_anchor)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_set_anchor_and_offset, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Sets [member offset_left] and [member offset_top] at the same time. Equivalent of changing [member position].
*/
//go:nosplit
func (self class) SetBegin(position Vector2.XY) { //gd:Control.set_begin
	var frame = callframe.New()
	callframe.Arg(frame, position)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_set_begin, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Sets [member offset_right] and [member offset_bottom] at the same time.
*/
//go:nosplit
func (self class) SetEnd(position Vector2.XY) { //gd:Control.set_end
	var frame = callframe.New()
	callframe.Arg(frame, position)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_set_end, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Sets the [member position] to given [param position].
If [param keep_offsets] is [code]true[/code], control's anchors will be updated instead of offsets.
*/
//go:nosplit
func (self class) SetPosition(position Vector2.XY, keep_offsets bool) { //gd:Control.set_position
	var frame = callframe.New()
	callframe.Arg(frame, position)
	callframe.Arg(frame, keep_offsets)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_set_position, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Sets the size (see [member size]).
If [param keep_offsets] is [code]true[/code], control's anchors will be updated instead of offsets.
*/
//go:nosplit
func (self class) SetSize(size Vector2.XY, keep_offsets bool) { //gd:Control.set_size
	var frame = callframe.New()
	callframe.Arg(frame, size)
	callframe.Arg(frame, keep_offsets)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_set_size, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Resets the size to [method get_combined_minimum_size]. This is equivalent to calling [code]set_size(Vector2())[/code] (or any size below the minimum).
*/
//go:nosplit
func (self class) ResetSize() { //gd:Control.reset_size
	var frame = callframe.New()
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_reset_size, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) SetCustomMinimumSize(size Vector2.XY) { //gd:Control.set_custom_minimum_size
	var frame = callframe.New()
	callframe.Arg(frame, size)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_set_custom_minimum_size, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Sets the [member global_position] to given [param position].
If [param keep_offsets] is [code]true[/code], control's anchors will be updated instead of offsets.
*/
//go:nosplit
func (self class) SetGlobalPosition(position Vector2.XY, keep_offsets bool) { //gd:Control.set_global_position
	var frame = callframe.New()
	callframe.Arg(frame, position)
	callframe.Arg(frame, keep_offsets)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_set_global_position, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) SetRotation(radians float64) { //gd:Control.set_rotation
	var frame = callframe.New()
	callframe.Arg(frame, radians)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_set_rotation, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) SetRotationDegrees(degrees float64) { //gd:Control.set_rotation_degrees
	var frame = callframe.New()
	callframe.Arg(frame, degrees)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_set_rotation_degrees, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) SetScale(scale Vector2.XY) { //gd:Control.set_scale
	var frame = callframe.New()
	callframe.Arg(frame, scale)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_set_scale, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) SetPivotOffset(pivot_offset Vector2.XY) { //gd:Control.set_pivot_offset
	var frame = callframe.New()
	callframe.Arg(frame, pivot_offset)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_set_pivot_offset, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Returns [member offset_left] and [member offset_top]. See also [member position].
*/
//go:nosplit
func (self class) GetBegin() Vector2.XY { //gd:Control.get_begin
	var frame = callframe.New()
	var r_ret = callframe.Ret[Vector2.XY](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_get_begin, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns [member offset_right] and [member offset_bottom].
*/
//go:nosplit
func (self class) GetEnd() Vector2.XY { //gd:Control.get_end
	var frame = callframe.New()
	var r_ret = callframe.Ret[Vector2.XY](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_get_end, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

//go:nosplit
func (self class) GetPosition() Vector2.XY { //gd:Control.get_position
	var frame = callframe.New()
	var r_ret = callframe.Ret[Vector2.XY](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_get_position, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

//go:nosplit
func (self class) GetSize() Vector2.XY { //gd:Control.get_size
	var frame = callframe.New()
	var r_ret = callframe.Ret[Vector2.XY](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_get_size, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

//go:nosplit
func (self class) GetRotation() float64 { //gd:Control.get_rotation
	var frame = callframe.New()
	var r_ret = callframe.Ret[float64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_get_rotation, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

//go:nosplit
func (self class) GetRotationDegrees() float64 { //gd:Control.get_rotation_degrees
	var frame = callframe.New()
	var r_ret = callframe.Ret[float64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_get_rotation_degrees, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

//go:nosplit
func (self class) GetScale() Vector2.XY { //gd:Control.get_scale
	var frame = callframe.New()
	var r_ret = callframe.Ret[Vector2.XY](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_get_scale, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

//go:nosplit
func (self class) GetPivotOffset() Vector2.XY { //gd:Control.get_pivot_offset
	var frame = callframe.New()
	var r_ret = callframe.Ret[Vector2.XY](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_get_pivot_offset, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

//go:nosplit
func (self class) GetCustomMinimumSize() Vector2.XY { //gd:Control.get_custom_minimum_size
	var frame = callframe.New()
	var r_ret = callframe.Ret[Vector2.XY](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_get_custom_minimum_size, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns the width/height occupied in the parent control.
*/
//go:nosplit
func (self class) GetParentAreaSize() Vector2.XY { //gd:Control.get_parent_area_size
	var frame = callframe.New()
	var r_ret = callframe.Ret[Vector2.XY](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_get_parent_area_size, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

//go:nosplit
func (self class) GetGlobalPosition() Vector2.XY { //gd:Control.get_global_position
	var frame = callframe.New()
	var r_ret = callframe.Ret[Vector2.XY](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_get_global_position, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns the position of this [Control] in global screen coordinates (i.e. taking window position into account). Mostly useful for editor plugins.
Equals to [member global_position] if the window is embedded (see [member Viewport.gui_embed_subwindows]).
[b]Example:[/b] Show a popup at the mouse position:
[codeblock]
popup_menu.position = get_screen_position() + get_local_mouse_position()
popup_menu.reset_size()
popup_menu.popup()
[/codeblock]
*/
//go:nosplit
func (self class) GetScreenPosition() Vector2.XY { //gd:Control.get_screen_position
	var frame = callframe.New()
	var r_ret = callframe.Ret[Vector2.XY](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_get_screen_position, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns the position and size of the control in the coordinate system of the containing node. See [member position], [member scale] and [member size].
[b]Note:[/b] If [member rotation] is not the default rotation, the resulting size is not meaningful.
[b]Note:[/b] Setting [member Viewport.gui_snap_controls_to_pixels] to [code]true[/code] can lead to rounding inaccuracies between the displayed control and the returned [Rect2].
*/
//go:nosplit
func (self class) GetRect() Rect2.PositionSize { //gd:Control.get_rect
	var frame = callframe.New()
	var r_ret = callframe.Ret[Rect2.PositionSize](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_get_rect, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns the position and size of the control relative to the containing canvas. See [member global_position] and [member size].
[b]Note:[/b] If the node itself or any parent [CanvasItem] between the node and the canvas have a non default rotation or skew, the resulting size is likely not meaningful.
[b]Note:[/b] Setting [member Viewport.gui_snap_controls_to_pixels] to [code]true[/code] can lead to rounding inaccuracies between the displayed control and the returned [Rect2].
*/
//go:nosplit
func (self class) GetGlobalRect() Rect2.PositionSize { //gd:Control.get_global_rect
	var frame = callframe.New()
	var r_ret = callframe.Ret[Rect2.PositionSize](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_get_global_rect, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

//go:nosplit
func (self class) SetFocusMode(mode gdclass.ControlFocusMode) { //gd:Control.set_focus_mode
	var frame = callframe.New()
	callframe.Arg(frame, mode)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_set_focus_mode, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) GetFocusMode() gdclass.ControlFocusMode { //gd:Control.get_focus_mode
	var frame = callframe.New()
	var r_ret = callframe.Ret[gdclass.ControlFocusMode](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_get_focus_mode, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if this is the current focused control. See [member focus_mode].
*/
//go:nosplit
func (self class) HasFocus() bool { //gd:Control.has_focus
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_has_focus, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Steal the focus from another control and become the focused control (see [member focus_mode]).
[b]Note:[/b] Using this method together with [method Callable.call_deferred] makes it more reliable, especially when called inside [method Node._ready].
*/
//go:nosplit
func (self class) GrabFocus() { //gd:Control.grab_focus
	var frame = callframe.New()
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_grab_focus, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Give up the focus. No other control will be able to receive input.
*/
//go:nosplit
func (self class) ReleaseFocus() { //gd:Control.release_focus
	var frame = callframe.New()
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_release_focus, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Finds the previous (above in the tree) [Control] that can receive the focus.
*/
//go:nosplit
func (self class) FindPrevValidFocus() [1]gdclass.Control { //gd:Control.find_prev_valid_focus
	var frame = callframe.New()
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_find_prev_valid_focus, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.Control{gd.PointerMustAssertInstanceID[gdclass.Control](r_ret.Get())}
	frame.Free()
	return ret
}

/*
Finds the next (below in the tree) [Control] that can receive the focus.
*/
//go:nosplit
func (self class) FindNextValidFocus() [1]gdclass.Control { //gd:Control.find_next_valid_focus
	var frame = callframe.New()
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_find_next_valid_focus, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.Control{gd.PointerMustAssertInstanceID[gdclass.Control](r_ret.Get())}
	frame.Free()
	return ret
}

/*
Finds the next [Control] that can receive the focus on the specified [enum Side].
[b]Note:[/b] This is different from [method get_focus_neighbor], which returns the path of a specified focus neighbor.
*/
//go:nosplit
func (self class) FindValidFocusNeighbor(side Side) [1]gdclass.Control { //gd:Control.find_valid_focus_neighbor
	var frame = callframe.New()
	callframe.Arg(frame, side)
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_find_valid_focus_neighbor, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.Control{gd.PointerMustAssertInstanceID[gdclass.Control](r_ret.Get())}
	frame.Free()
	return ret
}

//go:nosplit
func (self class) SetHSizeFlags(flags gdclass.ControlSizeFlags) { //gd:Control.set_h_size_flags
	var frame = callframe.New()
	callframe.Arg(frame, flags)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_set_h_size_flags, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) GetHSizeFlags() gdclass.ControlSizeFlags { //gd:Control.get_h_size_flags
	var frame = callframe.New()
	var r_ret = callframe.Ret[gdclass.ControlSizeFlags](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_get_h_size_flags, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

//go:nosplit
func (self class) SetStretchRatio(ratio float64) { //gd:Control.set_stretch_ratio
	var frame = callframe.New()
	callframe.Arg(frame, ratio)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_set_stretch_ratio, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) GetStretchRatio() float64 { //gd:Control.get_stretch_ratio
	var frame = callframe.New()
	var r_ret = callframe.Ret[float64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_get_stretch_ratio, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

//go:nosplit
func (self class) SetVSizeFlags(flags gdclass.ControlSizeFlags) { //gd:Control.set_v_size_flags
	var frame = callframe.New()
	callframe.Arg(frame, flags)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_set_v_size_flags, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) GetVSizeFlags() gdclass.ControlSizeFlags { //gd:Control.get_v_size_flags
	var frame = callframe.New()
	var r_ret = callframe.Ret[gdclass.ControlSizeFlags](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_get_v_size_flags, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

//go:nosplit
func (self class) SetTheme(theme [1]gdclass.Theme) { //gd:Control.set_theme
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(theme[0])[0])
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_set_theme, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) GetTheme() [1]gdclass.Theme { //gd:Control.get_theme
	var frame = callframe.New()
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_get_theme, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.Theme{gd.PointerWithOwnershipTransferredToGo[gdclass.Theme](r_ret.Get())}
	frame.Free()
	return ret
}

//go:nosplit
func (self class) SetThemeTypeVariation(theme_type String.Name) { //gd:Control.set_theme_type_variation
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalStringName(theme_type)))
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_set_theme_type_variation, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) GetThemeTypeVariation() String.Name { //gd:Control.get_theme_type_variation
	var frame = callframe.New()
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_get_theme_type_variation, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Name(String.Via(gd.StringNameProxy{}, pointers.Pack(pointers.New[gd.StringName](r_ret.Get()))))
	frame.Free()
	return ret
}

/*
Prevents [code]*_theme_*_override[/code] methods from emitting [constant NOTIFICATION_THEME_CHANGED] until [method end_bulk_theme_override] is called.
*/
//go:nosplit
func (self class) BeginBulkThemeOverride() { //gd:Control.begin_bulk_theme_override
	var frame = callframe.New()
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_begin_bulk_theme_override, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Ends a bulk theme override update. See [method begin_bulk_theme_override].
*/
//go:nosplit
func (self class) EndBulkThemeOverride() { //gd:Control.end_bulk_theme_override
	var frame = callframe.New()
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_end_bulk_theme_override, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Creates a local override for a theme icon with the specified [param name]. Local overrides always take precedence when fetching theme items for the control. An override can be removed with [method remove_theme_icon_override].
See also [method get_theme_icon].
*/
//go:nosplit
func (self class) AddThemeIconOverride(name String.Name, texture [1]gdclass.Texture2D) { //gd:Control.add_theme_icon_override
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalStringName(name)))
	callframe.Arg(frame, pointers.Get(texture[0])[0])
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_add_theme_icon_override, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Creates a local override for a theme [StyleBox] with the specified [param name]. Local overrides always take precedence when fetching theme items for the control. An override can be removed with [method remove_theme_stylebox_override].
See also [method get_theme_stylebox].
[b]Example:[/b] Modify a property in a [StyleBox] by duplicating it:
[codeblocks]
[gdscript]
# The snippet below assumes the child node "MyButton" has a StyleBoxFlat assigned.
# Resources are shared across instances, so we need to duplicate it
# to avoid modifying the appearance of all other buttons.
var new_stylebox_normal = $MyButton.get_theme_stylebox("normal").duplicate()
new_stylebox_normal.border_width_top = 3
new_stylebox_normal.border_color = Color(0, 1, 0.5)
$MyButton.add_theme_stylebox_override("normal", new_stylebox_normal)
# Remove the stylebox override.
$MyButton.remove_theme_stylebox_override("normal")
[/gdscript]
[csharp]
// The snippet below assumes the child node "MyButton" has a StyleBoxFlat assigned.
// Resources are shared across instances, so we need to duplicate it
// to avoid modifying the appearance of all other buttons.
StyleBoxFlat newStyleboxNormal = GetNode<Button>("MyButton").GetThemeStylebox("normal").Duplicate() as StyleBoxFlat;
newStyleboxNormal.BorderWidthTop = 3;
newStyleboxNormal.BorderColor = new Color(0, 1, 0.5f);
GetNode<Button>("MyButton").AddThemeStyleboxOverride("normal", newStyleboxNormal);
// Remove the stylebox override.
GetNode<Button>("MyButton").RemoveThemeStyleboxOverride("normal");
[/csharp]
[/codeblocks]
*/
//go:nosplit
func (self class) AddThemeStyleboxOverride(name String.Name, stylebox [1]gdclass.StyleBox) { //gd:Control.add_theme_stylebox_override
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalStringName(name)))
	callframe.Arg(frame, pointers.Get(stylebox[0])[0])
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_add_theme_stylebox_override, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Creates a local override for a theme [Font] with the specified [param name]. Local overrides always take precedence when fetching theme items for the control. An override can be removed with [method remove_theme_font_override].
See also [method get_theme_font].
*/
//go:nosplit
func (self class) AddThemeFontOverride(name String.Name, font [1]gdclass.Font) { //gd:Control.add_theme_font_override
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalStringName(name)))
	callframe.Arg(frame, pointers.Get(font[0])[0])
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_add_theme_font_override, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Creates a local override for a theme font size with the specified [param name]. Local overrides always take precedence when fetching theme items for the control. An override can be removed with [method remove_theme_font_size_override].
See also [method get_theme_font_size].
*/
//go:nosplit
func (self class) AddThemeFontSizeOverride(name String.Name, font_size int64) { //gd:Control.add_theme_font_size_override
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalStringName(name)))
	callframe.Arg(frame, font_size)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_add_theme_font_size_override, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Creates a local override for a theme [Color] with the specified [param name]. Local overrides always take precedence when fetching theme items for the control. An override can be removed with [method remove_theme_color_override].
See also [method get_theme_color].
[b]Example:[/b] Override a [Label]'s color and reset it later:
[codeblocks]
[gdscript]
# Given the child Label node "MyLabel", override its font color with a custom value.
$MyLabel.add_theme_color_override("font_color", Color(1, 0.5, 0))
# Reset the font color of the child label.
$MyLabel.remove_theme_color_override("font_color")
# Alternatively it can be overridden with the default value from the Label type.
$MyLabel.add_theme_color_override("font_color", get_theme_color("font_color", "Label"))
[/gdscript]
[csharp]
// Given the child Label node "MyLabel", override its font color with a custom value.
GetNode<Label>("MyLabel").AddThemeColorOverride("font_color", new Color(1, 0.5f, 0));
// Reset the font color of the child label.
GetNode<Label>("MyLabel").RemoveThemeColorOverride("font_color");
// Alternatively it can be overridden with the default value from the Label type.
GetNode<Label>("MyLabel").AddThemeColorOverride("font_color", GetThemeColor("font_color", "Label"));
[/csharp]
[/codeblocks]
*/
//go:nosplit
func (self class) AddThemeColorOverride(name String.Name, color Color.RGBA) { //gd:Control.add_theme_color_override
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalStringName(name)))
	callframe.Arg(frame, color)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_add_theme_color_override, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Creates a local override for a theme constant with the specified [param name]. Local overrides always take precedence when fetching theme items for the control. An override can be removed with [method remove_theme_constant_override].
See also [method get_theme_constant].
*/
//go:nosplit
func (self class) AddThemeConstantOverride(name String.Name, constant int64) { //gd:Control.add_theme_constant_override
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalStringName(name)))
	callframe.Arg(frame, constant)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_add_theme_constant_override, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Removes a local override for a theme icon with the specified [param name] previously added by [method add_theme_icon_override] or via the Inspector dock.
*/
//go:nosplit
func (self class) RemoveThemeIconOverride(name String.Name) { //gd:Control.remove_theme_icon_override
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalStringName(name)))
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_remove_theme_icon_override, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Removes a local override for a theme [StyleBox] with the specified [param name] previously added by [method add_theme_stylebox_override] or via the Inspector dock.
*/
//go:nosplit
func (self class) RemoveThemeStyleboxOverride(name String.Name) { //gd:Control.remove_theme_stylebox_override
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalStringName(name)))
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_remove_theme_stylebox_override, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Removes a local override for a theme [Font] with the specified [param name] previously added by [method add_theme_font_override] or via the Inspector dock.
*/
//go:nosplit
func (self class) RemoveThemeFontOverride(name String.Name) { //gd:Control.remove_theme_font_override
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalStringName(name)))
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_remove_theme_font_override, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Removes a local override for a theme font size with the specified [param name] previously added by [method add_theme_font_size_override] or via the Inspector dock.
*/
//go:nosplit
func (self class) RemoveThemeFontSizeOverride(name String.Name) { //gd:Control.remove_theme_font_size_override
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalStringName(name)))
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_remove_theme_font_size_override, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Removes a local override for a theme [Color] with the specified [param name] previously added by [method add_theme_color_override] or via the Inspector dock.
*/
//go:nosplit
func (self class) RemoveThemeColorOverride(name String.Name) { //gd:Control.remove_theme_color_override
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalStringName(name)))
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_remove_theme_color_override, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Removes a local override for a theme constant with the specified [param name] previously added by [method add_theme_constant_override] or via the Inspector dock.
*/
//go:nosplit
func (self class) RemoveThemeConstantOverride(name String.Name) { //gd:Control.remove_theme_constant_override
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalStringName(name)))
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_remove_theme_constant_override, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Returns an icon from the first matching [Theme] in the tree if that [Theme] has an icon item with the specified [param name] and [param theme_type].
See [method get_theme_color] for details.
*/
//go:nosplit
func (self class) GetThemeIcon(name String.Name, theme_type String.Name) [1]gdclass.Texture2D { //gd:Control.get_theme_icon
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalStringName(name)))
	callframe.Arg(frame, pointers.Get(gd.InternalStringName(theme_type)))
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_get_theme_icon, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.Texture2D{gd.PointerWithOwnershipTransferredToGo[gdclass.Texture2D](r_ret.Get())}
	frame.Free()
	return ret
}

/*
Returns a [StyleBox] from the first matching [Theme] in the tree if that [Theme] has a stylebox item with the specified [param name] and [param theme_type].
See [method get_theme_color] for details.
*/
//go:nosplit
func (self class) GetThemeStylebox(name String.Name, theme_type String.Name) [1]gdclass.StyleBox { //gd:Control.get_theme_stylebox
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalStringName(name)))
	callframe.Arg(frame, pointers.Get(gd.InternalStringName(theme_type)))
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_get_theme_stylebox, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.StyleBox{gd.PointerWithOwnershipTransferredToGo[gdclass.StyleBox](r_ret.Get())}
	frame.Free()
	return ret
}

/*
Returns a [Font] from the first matching [Theme] in the tree if that [Theme] has a font item with the specified [param name] and [param theme_type].
See [method get_theme_color] for details.
*/
//go:nosplit
func (self class) GetThemeFont(name String.Name, theme_type String.Name) [1]gdclass.Font { //gd:Control.get_theme_font
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalStringName(name)))
	callframe.Arg(frame, pointers.Get(gd.InternalStringName(theme_type)))
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_get_theme_font, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.Font{gd.PointerWithOwnershipTransferredToGo[gdclass.Font](r_ret.Get())}
	frame.Free()
	return ret
}

/*
Returns a font size from the first matching [Theme] in the tree if that [Theme] has a font size item with the specified [param name] and [param theme_type].
See [method get_theme_color] for details.
*/
//go:nosplit
func (self class) GetThemeFontSize(name String.Name, theme_type String.Name) int64 { //gd:Control.get_theme_font_size
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalStringName(name)))
	callframe.Arg(frame, pointers.Get(gd.InternalStringName(theme_type)))
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_get_theme_font_size, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns a [Color] from the first matching [Theme] in the tree if that [Theme] has a color item with the specified [param name] and [param theme_type]. If [param theme_type] is omitted the class name of the current control is used as the type, or [member theme_type_variation] if it is defined. If the type is a class name its parent classes are also checked, in order of inheritance. If the type is a variation its base types are checked, in order of dependency, then the control's class name and its parent classes are checked.
For the current control its local overrides are considered first (see [method add_theme_color_override]), then its assigned [member theme]. After the current control, each parent control and its assigned [member theme] are considered; controls without a [member theme] assigned are skipped. If no matching [Theme] is found in the tree, the custom project [Theme] (see [member ProjectSettings.gui/theme/custom]) and the default [Theme] are used (see [ThemeDB]).
[codeblocks]
[gdscript]
func _ready():
    # Get the font color defined for the current Control's class, if it exists.
    modulate = get_theme_color("font_color")
    # Get the font color defined for the Button class.
    modulate = get_theme_color("font_color", "Button")
[/gdscript]
[csharp]
public override void _Ready()
{
    // Get the font color defined for the current Control's class, if it exists.
    Modulate = GetThemeColor("font_color");
    // Get the font color defined for the Button class.
    Modulate = GetThemeColor("font_color", "Button");
}
[/csharp]
[/codeblocks]
*/
//go:nosplit
func (self class) GetThemeColor(name String.Name, theme_type String.Name) Color.RGBA { //gd:Control.get_theme_color
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalStringName(name)))
	callframe.Arg(frame, pointers.Get(gd.InternalStringName(theme_type)))
	var r_ret = callframe.Ret[Color.RGBA](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_get_theme_color, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns a constant from the first matching [Theme] in the tree if that [Theme] has a constant item with the specified [param name] and [param theme_type].
See [method get_theme_color] for details.
*/
//go:nosplit
func (self class) GetThemeConstant(name String.Name, theme_type String.Name) int64 { //gd:Control.get_theme_constant
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalStringName(name)))
	callframe.Arg(frame, pointers.Get(gd.InternalStringName(theme_type)))
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_get_theme_constant, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if there is a local override for a theme icon with the specified [param name] in this [Control] node.
See [method add_theme_icon_override].
*/
//go:nosplit
func (self class) HasThemeIconOverride(name String.Name) bool { //gd:Control.has_theme_icon_override
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalStringName(name)))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_has_theme_icon_override, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if there is a local override for a theme [StyleBox] with the specified [param name] in this [Control] node.
See [method add_theme_stylebox_override].
*/
//go:nosplit
func (self class) HasThemeStyleboxOverride(name String.Name) bool { //gd:Control.has_theme_stylebox_override
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalStringName(name)))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_has_theme_stylebox_override, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if there is a local override for a theme [Font] with the specified [param name] in this [Control] node.
See [method add_theme_font_override].
*/
//go:nosplit
func (self class) HasThemeFontOverride(name String.Name) bool { //gd:Control.has_theme_font_override
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalStringName(name)))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_has_theme_font_override, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if there is a local override for a theme font size with the specified [param name] in this [Control] node.
See [method add_theme_font_size_override].
*/
//go:nosplit
func (self class) HasThemeFontSizeOverride(name String.Name) bool { //gd:Control.has_theme_font_size_override
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalStringName(name)))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_has_theme_font_size_override, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if there is a local override for a theme [Color] with the specified [param name] in this [Control] node.
See [method add_theme_color_override].
*/
//go:nosplit
func (self class) HasThemeColorOverride(name String.Name) bool { //gd:Control.has_theme_color_override
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalStringName(name)))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_has_theme_color_override, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if there is a local override for a theme constant with the specified [param name] in this [Control] node.
See [method add_theme_constant_override].
*/
//go:nosplit
func (self class) HasThemeConstantOverride(name String.Name) bool { //gd:Control.has_theme_constant_override
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalStringName(name)))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_has_theme_constant_override, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if there is a matching [Theme] in the tree that has an icon item with the specified [param name] and [param theme_type].
See [method get_theme_color] for details.
*/
//go:nosplit
func (self class) HasThemeIcon(name String.Name, theme_type String.Name) bool { //gd:Control.has_theme_icon
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalStringName(name)))
	callframe.Arg(frame, pointers.Get(gd.InternalStringName(theme_type)))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_has_theme_icon, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if there is a matching [Theme] in the tree that has a stylebox item with the specified [param name] and [param theme_type].
See [method get_theme_color] for details.
*/
//go:nosplit
func (self class) HasThemeStylebox(name String.Name, theme_type String.Name) bool { //gd:Control.has_theme_stylebox
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalStringName(name)))
	callframe.Arg(frame, pointers.Get(gd.InternalStringName(theme_type)))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_has_theme_stylebox, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if there is a matching [Theme] in the tree that has a font item with the specified [param name] and [param theme_type].
See [method get_theme_color] for details.
*/
//go:nosplit
func (self class) HasThemeFont(name String.Name, theme_type String.Name) bool { //gd:Control.has_theme_font
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalStringName(name)))
	callframe.Arg(frame, pointers.Get(gd.InternalStringName(theme_type)))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_has_theme_font, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if there is a matching [Theme] in the tree that has a font size item with the specified [param name] and [param theme_type].
See [method get_theme_color] for details.
*/
//go:nosplit
func (self class) HasThemeFontSize(name String.Name, theme_type String.Name) bool { //gd:Control.has_theme_font_size
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalStringName(name)))
	callframe.Arg(frame, pointers.Get(gd.InternalStringName(theme_type)))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_has_theme_font_size, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if there is a matching [Theme] in the tree that has a color item with the specified [param name] and [param theme_type].
See [method get_theme_color] for details.
*/
//go:nosplit
func (self class) HasThemeColor(name String.Name, theme_type String.Name) bool { //gd:Control.has_theme_color
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalStringName(name)))
	callframe.Arg(frame, pointers.Get(gd.InternalStringName(theme_type)))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_has_theme_color, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if there is a matching [Theme] in the tree that has a constant item with the specified [param name] and [param theme_type].
See [method get_theme_color] for details.
*/
//go:nosplit
func (self class) HasThemeConstant(name String.Name, theme_type String.Name) bool { //gd:Control.has_theme_constant
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalStringName(name)))
	callframe.Arg(frame, pointers.Get(gd.InternalStringName(theme_type)))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_has_theme_constant, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns the default base scale value from the first matching [Theme] in the tree if that [Theme] has a valid [member Theme.default_base_scale] value.
See [method get_theme_color] for details.
*/
//go:nosplit
func (self class) GetThemeDefaultBaseScale() float64 { //gd:Control.get_theme_default_base_scale
	var frame = callframe.New()
	var r_ret = callframe.Ret[float64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_get_theme_default_base_scale, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns the default font from the first matching [Theme] in the tree if that [Theme] has a valid [member Theme.default_font] value.
See [method get_theme_color] for details.
*/
//go:nosplit
func (self class) GetThemeDefaultFont() [1]gdclass.Font { //gd:Control.get_theme_default_font
	var frame = callframe.New()
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_get_theme_default_font, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.Font{gd.PointerWithOwnershipTransferredToGo[gdclass.Font](r_ret.Get())}
	frame.Free()
	return ret
}

/*
Returns the default font size value from the first matching [Theme] in the tree if that [Theme] has a valid [member Theme.default_font_size] value.
See [method get_theme_color] for details.
*/
//go:nosplit
func (self class) GetThemeDefaultFontSize() int64 { //gd:Control.get_theme_default_font_size
	var frame = callframe.New()
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_get_theme_default_font_size, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns the parent control node.
*/
//go:nosplit
func (self class) GetParentControl() [1]gdclass.Control { //gd:Control.get_parent_control
	var frame = callframe.New()
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_get_parent_control, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.Control{gd.PointerMustAssertInstanceID[gdclass.Control](r_ret.Get())}
	frame.Free()
	return ret
}

//go:nosplit
func (self class) SetHGrowDirection(direction gdclass.ControlGrowDirection) { //gd:Control.set_h_grow_direction
	var frame = callframe.New()
	callframe.Arg(frame, direction)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_set_h_grow_direction, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) GetHGrowDirection() gdclass.ControlGrowDirection { //gd:Control.get_h_grow_direction
	var frame = callframe.New()
	var r_ret = callframe.Ret[gdclass.ControlGrowDirection](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_get_h_grow_direction, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

//go:nosplit
func (self class) SetVGrowDirection(direction gdclass.ControlGrowDirection) { //gd:Control.set_v_grow_direction
	var frame = callframe.New()
	callframe.Arg(frame, direction)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_set_v_grow_direction, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) GetVGrowDirection() gdclass.ControlGrowDirection { //gd:Control.get_v_grow_direction
	var frame = callframe.New()
	var r_ret = callframe.Ret[gdclass.ControlGrowDirection](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_get_v_grow_direction, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

//go:nosplit
func (self class) SetTooltipAutoTranslateMode(mode gdclass.NodeAutoTranslateMode) { //gd:Control.set_tooltip_auto_translate_mode
	var frame = callframe.New()
	callframe.Arg(frame, mode)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_set_tooltip_auto_translate_mode, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) GetTooltipAutoTranslateMode() gdclass.NodeAutoTranslateMode { //gd:Control.get_tooltip_auto_translate_mode
	var frame = callframe.New()
	var r_ret = callframe.Ret[gdclass.NodeAutoTranslateMode](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_get_tooltip_auto_translate_mode, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

//go:nosplit
func (self class) SetTooltipText(hint String.Readable) { //gd:Control.set_tooltip_text
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(hint)))
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_set_tooltip_text, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) GetTooltipText() String.Readable { //gd:Control.get_tooltip_text
	var frame = callframe.New()
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_get_tooltip_text, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Returns the tooltip text for the position [param at_position] in control's local coordinates, which will typically appear when the cursor is resting over this control. By default, it returns [member tooltip_text].
This method can be overridden to customize its behavior. See [method _get_tooltip].
[b]Note:[/b] If this method returns an empty [String] and [method _make_custom_tooltip] is not overridden, no tooltip is displayed.
*/
//go:nosplit
func (self class) GetTooltip(at_position Vector2.XY) String.Readable { //gd:Control.get_tooltip
	var frame = callframe.New()
	callframe.Arg(frame, at_position)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_get_tooltip, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

//go:nosplit
func (self class) SetDefaultCursorShape(shape gdclass.ControlCursorShape) { //gd:Control.set_default_cursor_shape
	var frame = callframe.New()
	callframe.Arg(frame, shape)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_set_default_cursor_shape, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) GetDefaultCursorShape() gdclass.ControlCursorShape { //gd:Control.get_default_cursor_shape
	var frame = callframe.New()
	var r_ret = callframe.Ret[gdclass.ControlCursorShape](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_get_default_cursor_shape, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns the mouse cursor shape the control displays on mouse hover. See [enum CursorShape].
*/
//go:nosplit
func (self class) GetCursorShape(position Vector2.XY) gdclass.ControlCursorShape { //gd:Control.get_cursor_shape
	var frame = callframe.New()
	callframe.Arg(frame, position)
	var r_ret = callframe.Ret[gdclass.ControlCursorShape](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_get_cursor_shape, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Sets the focus neighbor for the specified [enum Side] to the [Control] at [param neighbor] node path. A setter method for [member focus_neighbor_bottom], [member focus_neighbor_left], [member focus_neighbor_right] and [member focus_neighbor_top].
*/
//go:nosplit
func (self class) SetFocusNeighbor(side Side, neighbor Path.ToNode) { //gd:Control.set_focus_neighbor
	var frame = callframe.New()
	callframe.Arg(frame, side)
	callframe.Arg(frame, pointers.Get(gd.InternalNodePath(neighbor)))
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_set_focus_neighbor, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Returns the focus neighbor for the specified [enum Side]. A getter method for [member focus_neighbor_bottom], [member focus_neighbor_left], [member focus_neighbor_right] and [member focus_neighbor_top].
[b]Note:[/b] To find the next [Control] on the specific [enum Side], even if a neighbor is not assigned, use [method find_valid_focus_neighbor].
*/
//go:nosplit
func (self class) GetFocusNeighbor(side Side) Path.ToNode { //gd:Control.get_focus_neighbor
	var frame = callframe.New()
	callframe.Arg(frame, side)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_get_focus_neighbor, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Path.ToNode(String.Via(gd.NodePathProxy{}, pointers.Pack(pointers.New[gd.NodePath](r_ret.Get()))))
	frame.Free()
	return ret
}

//go:nosplit
func (self class) SetFocusNext(next Path.ToNode) { //gd:Control.set_focus_next
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalNodePath(next)))
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_set_focus_next, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) GetFocusNext() Path.ToNode { //gd:Control.get_focus_next
	var frame = callframe.New()
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_get_focus_next, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Path.ToNode(String.Via(gd.NodePathProxy{}, pointers.Pack(pointers.New[gd.NodePath](r_ret.Get()))))
	frame.Free()
	return ret
}

//go:nosplit
func (self class) SetFocusPrevious(previous Path.ToNode) { //gd:Control.set_focus_previous
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalNodePath(previous)))
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_set_focus_previous, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) GetFocusPrevious() Path.ToNode { //gd:Control.get_focus_previous
	var frame = callframe.New()
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_get_focus_previous, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Path.ToNode(String.Via(gd.NodePathProxy{}, pointers.Pack(pointers.New[gd.NodePath](r_ret.Get()))))
	frame.Free()
	return ret
}

/*
Forces drag and bypasses [method _get_drag_data] and [method set_drag_preview] by passing [param data] and [param preview]. Drag will start even if the mouse is neither over nor pressed on this control.
The methods [method _can_drop_data] and [method _drop_data] must be implemented on controls that want to receive drop data.
*/
//go:nosplit
func (self class) ForceDrag(data variant.Any, preview [1]gdclass.Control) { //gd:Control.force_drag
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalVariant(data)))
	callframe.Arg(frame, gd.PointerWithOwnershipTransferredToGodot(preview[0].AsObject()[0]))
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_force_drag, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) SetMouseFilter(filter gdclass.ControlMouseFilter) { //gd:Control.set_mouse_filter
	var frame = callframe.New()
	callframe.Arg(frame, filter)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_set_mouse_filter, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) GetMouseFilter() gdclass.ControlMouseFilter { //gd:Control.get_mouse_filter
	var frame = callframe.New()
	var r_ret = callframe.Ret[gdclass.ControlMouseFilter](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_get_mouse_filter, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

//go:nosplit
func (self class) SetForcePassScrollEvents(force_pass_scroll_events bool) { //gd:Control.set_force_pass_scroll_events
	var frame = callframe.New()
	callframe.Arg(frame, force_pass_scroll_events)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_set_force_pass_scroll_events, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) IsForcePassScrollEvents() bool { //gd:Control.is_force_pass_scroll_events
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_is_force_pass_scroll_events, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

//go:nosplit
func (self class) SetClipContents(enable bool) { //gd:Control.set_clip_contents
	var frame = callframe.New()
	callframe.Arg(frame, enable)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_set_clip_contents, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) IsClippingContents() bool { //gd:Control.is_clipping_contents
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_is_clipping_contents, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Creates an [InputEventMouseButton] that attempts to click the control. If the event is received, the control gains focus.
[codeblocks]
[gdscript]
func _process(delta):
    grab_click_focus() # When clicking another Control node, this node will be clicked instead.
[/gdscript]
[csharp]
public override void _Process(double delta)
{
    GrabClickFocus(); // When clicking another Control node, this node will be clicked instead.
}
[/csharp]
[/codeblocks]
*/
//go:nosplit
func (self class) GrabClickFocus() { //gd:Control.grab_click_focus
	var frame = callframe.New()
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_grab_click_focus, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Sets the given callables to be used instead of the control's own drag-and-drop virtual methods. If a callable is empty, its respective virtual method is used as normal.
The arguments for each callable should be exactly the same as their respective virtual methods, which would be:
- [param drag_func] corresponds to [method _get_drag_data] and requires a [Vector2];
- [param can_drop_func] corresponds to [method _can_drop_data] and requires both a [Vector2] and a [Variant];
- [param drop_func] corresponds to [method _drop_data] and requires both a [Vector2] and a [Variant].
*/
//go:nosplit
func (self class) SetDragForwarding(drag_func Callable.Function, can_drop_func Callable.Function, drop_func Callable.Function) { //gd:Control.set_drag_forwarding
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalCallable(drag_func)))
	callframe.Arg(frame, pointers.Get(gd.InternalCallable(can_drop_func)))
	callframe.Arg(frame, pointers.Get(gd.InternalCallable(drop_func)))
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_set_drag_forwarding, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Shows the given control at the mouse pointer. A good time to call this method is in [method _get_drag_data]. The control must not be in the scene tree. You should not free the control, and you should not keep a reference to the control beyond the duration of the drag. It will be deleted automatically after the drag has ended.
[codeblocks]
[gdscript]
@export var color = Color(1, 0, 0, 1)

func _get_drag_data(position):
    # Use a control that is not in the tree
    var cpb = ColorPickerButton.new()
    cpb.color = color
    cpb.size = Vector2(50, 50)
    set_drag_preview(cpb)
    return color
[/gdscript]
[csharp]
[Export]
private Color _color = new Color(1, 0, 0, 1);

public override Variant _GetDragData(Vector2 atPosition)
{
    // Use a control that is not in the tree
    var cpb = new ColorPickerButton();
    cpb.Color = _color;
    cpb.Size = new Vector2(50, 50);
    SetDragPreview(cpb);
    return _color;
}
[/csharp]
[/codeblocks]
*/
//go:nosplit
func (self class) SetDragPreview(control [1]gdclass.Control) { //gd:Control.set_drag_preview
	var frame = callframe.New()
	callframe.Arg(frame, gd.PointerWithOwnershipTransferredToGodot(control[0].AsObject()[0]))
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_set_drag_preview, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Returns [code]true[/code] if a drag operation is successful. Alternative to [method Viewport.gui_is_drag_successful].
Best used with [constant Node.NOTIFICATION_DRAG_END].
*/
//go:nosplit
func (self class) IsDragSuccessful() bool { //gd:Control.is_drag_successful
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_is_drag_successful, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Moves the mouse cursor to [param position], relative to [member position] of this [Control].
[b]Note:[/b] [method warp_mouse] is only supported on Windows, macOS and Linux. It has no effect on Android, iOS and Web.
*/
//go:nosplit
func (self class) WarpMouse(position Vector2.XY) { //gd:Control.warp_mouse
	var frame = callframe.New()
	callframe.Arg(frame, position)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_warp_mouse, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) SetShortcutContext(node [1]gdclass.Node) { //gd:Control.set_shortcut_context
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(node[0])[0])
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_set_shortcut_context, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) GetShortcutContext() [1]gdclass.Node { //gd:Control.get_shortcut_context
	var frame = callframe.New()
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_get_shortcut_context, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.Node{gd.PointerMustAssertInstanceID[gdclass.Node](r_ret.Get())}
	frame.Free()
	return ret
}

/*
Invalidates the size cache in this node and in parent nodes up to top level. Intended to be used with [method get_minimum_size] when the return value is changed. Setting [member custom_minimum_size] directly calls this method automatically.
*/
//go:nosplit
func (self class) UpdateMinimumSize() { //gd:Control.update_minimum_size
	var frame = callframe.New()
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_update_minimum_size, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) SetLayoutDirection(direction gdclass.ControlLayoutDirection) { //gd:Control.set_layout_direction
	var frame = callframe.New()
	callframe.Arg(frame, direction)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_set_layout_direction, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) GetLayoutDirection() gdclass.ControlLayoutDirection { //gd:Control.get_layout_direction
	var frame = callframe.New()
	var r_ret = callframe.Ret[gdclass.ControlLayoutDirection](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_get_layout_direction, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns [code]true[/code] if layout is right-to-left. See also [member layout_direction].
*/
//go:nosplit
func (self class) IsLayoutRtl() bool { //gd:Control.is_layout_rtl
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_is_layout_rtl, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

//go:nosplit
func (self class) SetAutoTranslate(enable bool) { //gd:Control.set_auto_translate
	var frame = callframe.New()
	callframe.Arg(frame, enable)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_set_auto_translate, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) IsAutoTranslating() bool { //gd:Control.is_auto_translating
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_is_auto_translating, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

//go:nosplit
func (self class) SetLocalizeNumeralSystem(enable bool) { //gd:Control.set_localize_numeral_system
	var frame = callframe.New()
	callframe.Arg(frame, enable)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_set_localize_numeral_system, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) IsLocalizingNumeralSystem() bool { //gd:Control.is_localizing_numeral_system
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Control.Bind_is_localizing_numeral_system, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
func (self Instance) OnResized(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("resized"), gd.NewCallable(cb), 0)
}

func (self Instance) OnGuiInput(cb func(event InputEvent.Instance)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("gui_input"), gd.NewCallable(cb), 0)
}

func (self Instance) OnMouseEntered(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("mouse_entered"), gd.NewCallable(cb), 0)
}

func (self Instance) OnMouseExited(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("mouse_exited"), gd.NewCallable(cb), 0)
}

func (self Instance) OnFocusEntered(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("focus_entered"), gd.NewCallable(cb), 0)
}

func (self Instance) OnFocusExited(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("focus_exited"), gd.NewCallable(cb), 0)
}

func (self Instance) OnSizeFlagsChanged(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("size_flags_changed"), gd.NewCallable(cb), 0)
}

func (self Instance) OnMinimumSizeChanged(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("minimum_size_changed"), gd.NewCallable(cb), 0)
}

func (self Instance) OnThemeChanged(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("theme_changed"), gd.NewCallable(cb), 0)
}

func (self class) AsControl() Advanced        { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsControl() Instance     { return *((*Instance)(unsafe.Pointer(&self))) }
func (self Extension[T]) AsControl() Instance { return self.Super().AsControl() }
func (self class) AsCanvasItem() CanvasItem.Advanced {
	return *((*CanvasItem.Advanced)(unsafe.Pointer(&self)))
}
func (self Extension[T]) AsCanvasItem() CanvasItem.Instance { return self.Super().AsCanvasItem() }
func (self Instance) AsCanvasItem() CanvasItem.Instance {
	return *((*CanvasItem.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsNode() Node.Advanced        { return *((*Node.Advanced)(unsafe.Pointer(&self))) }
func (self Extension[T]) AsNode() Node.Instance { return self.Super().AsNode() }
func (self Instance) AsNode() Node.Instance     { return *((*Node.Instance)(unsafe.Pointer(&self))) }

func (self class) Virtual(name string) reflect.Value {
	switch name {
	case "_has_point":
		return reflect.ValueOf(self._has_point)
	case "_structured_text_parser":
		return reflect.ValueOf(self._structured_text_parser)
	case "_get_minimum_size":
		return reflect.ValueOf(self._get_minimum_size)
	case "_get_tooltip":
		return reflect.ValueOf(self._get_tooltip)
	case "_get_drag_data":
		return reflect.ValueOf(self._get_drag_data)
	case "_can_drop_data":
		return reflect.ValueOf(self._can_drop_data)
	case "_drop_data":
		return reflect.ValueOf(self._drop_data)
	case "_make_custom_tooltip":
		return reflect.ValueOf(self._make_custom_tooltip)
	case "_gui_input":
		return reflect.ValueOf(self._gui_input)
	default:
		return gd.VirtualByName(CanvasItem.Advanced(self.AsCanvasItem()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	case "_has_point":
		return reflect.ValueOf(self._has_point)
	case "_structured_text_parser":
		return reflect.ValueOf(self._structured_text_parser)
	case "_get_minimum_size":
		return reflect.ValueOf(self._get_minimum_size)
	case "_get_tooltip":
		return reflect.ValueOf(self._get_tooltip)
	case "_get_drag_data":
		return reflect.ValueOf(self._get_drag_data)
	case "_can_drop_data":
		return reflect.ValueOf(self._can_drop_data)
	case "_drop_data":
		return reflect.ValueOf(self._drop_data)
	case "_make_custom_tooltip":
		return reflect.ValueOf(self._make_custom_tooltip)
	case "_gui_input":
		return reflect.ValueOf(self._gui_input)
	default:
		return gd.VirtualByName(CanvasItem.Instance(self.AsCanvasItem()), name)
	}
}
func init() {
	gdclass.Register("Control", func(ptr gd.Object) any { return [1]gdclass.Control{*(*gdclass.Control)(unsafe.Pointer(&ptr))} })
}

type FocusMode = gdclass.ControlFocusMode //gd:Control.FocusMode

const (
	/*The node cannot grab focus. Use with [member focus_mode].*/
	FocusNone FocusMode = 0
	/*The node can only grab focus on mouse clicks. Use with [member focus_mode].*/
	FocusClick FocusMode = 1
	/*The node can grab focus on mouse click, using the arrows and the Tab keys on the keyboard, or using the D-pad buttons on a gamepad. Use with [member focus_mode].*/
	FocusAll FocusMode = 2
)

type CursorShape = gdclass.ControlCursorShape //gd:Control.CursorShape

const (
	/*Show the system's arrow mouse cursor when the user hovers the node. Use with [member mouse_default_cursor_shape].*/
	CursorArrow CursorShape = 0
	/*Show the system's I-beam mouse cursor when the user hovers the node. The I-beam pointer has a shape similar to "I". It tells the user they can highlight or insert text.*/
	CursorIbeam CursorShape = 1
	/*Show the system's pointing hand mouse cursor when the user hovers the node.*/
	CursorPointingHand CursorShape = 2
	/*Show the system's cross mouse cursor when the user hovers the node.*/
	CursorCross CursorShape = 3
	/*Show the system's wait mouse cursor when the user hovers the node. Often an hourglass.*/
	CursorWait CursorShape = 4
	/*Show the system's busy mouse cursor when the user hovers the node. Often an arrow with a small hourglass.*/
	CursorBusy CursorShape = 5
	/*Show the system's drag mouse cursor, often a closed fist or a cross symbol, when the user hovers the node. It tells the user they're currently dragging an item, like a node in the Scene dock.*/
	CursorDrag CursorShape = 6
	/*Show the system's drop mouse cursor when the user hovers the node. It can be an open hand. It tells the user they can drop an item they're currently grabbing, like a node in the Scene dock.*/
	CursorCanDrop CursorShape = 7
	/*Show the system's forbidden mouse cursor when the user hovers the node. Often a crossed circle.*/
	CursorForbidden CursorShape = 8
	/*Show the system's vertical resize mouse cursor when the user hovers the node. A double-headed vertical arrow. It tells the user they can resize the window or the panel vertically.*/
	CursorVsize CursorShape = 9
	/*Show the system's horizontal resize mouse cursor when the user hovers the node. A double-headed horizontal arrow. It tells the user they can resize the window or the panel horizontally.*/
	CursorHsize CursorShape = 10
	/*Show the system's window resize mouse cursor when the user hovers the node. The cursor is a double-headed arrow that goes from the bottom left to the top right. It tells the user they can resize the window or the panel both horizontally and vertically.*/
	CursorBdiagsize CursorShape = 11
	/*Show the system's window resize mouse cursor when the user hovers the node. The cursor is a double-headed arrow that goes from the top left to the bottom right, the opposite of [constant CURSOR_BDIAGSIZE]. It tells the user they can resize the window or the panel both horizontally and vertically.*/
	CursorFdiagsize CursorShape = 12
	/*Show the system's move mouse cursor when the user hovers the node. It shows 2 double-headed arrows at a 90 degree angle. It tells the user they can move a UI element freely.*/
	CursorMove CursorShape = 13
	/*Show the system's vertical split mouse cursor when the user hovers the node. On Windows, it's the same as [constant CURSOR_VSIZE].*/
	CursorVsplit CursorShape = 14
	/*Show the system's horizontal split mouse cursor when the user hovers the node. On Windows, it's the same as [constant CURSOR_HSIZE].*/
	CursorHsplit CursorShape = 15
	/*Show the system's help mouse cursor when the user hovers the node, a question mark.*/
	CursorHelp CursorShape = 16
)

type LayoutPreset = gdclass.ControlLayoutPreset //gd:Control.LayoutPreset

const (
	/*Snap all 4 anchors to the top-left of the parent control's bounds. Use with [method set_anchors_preset].*/
	PresetTopLeft LayoutPreset = 0
	/*Snap all 4 anchors to the top-right of the parent control's bounds. Use with [method set_anchors_preset].*/
	PresetTopRight LayoutPreset = 1
	/*Snap all 4 anchors to the bottom-left of the parent control's bounds. Use with [method set_anchors_preset].*/
	PresetBottomLeft LayoutPreset = 2
	/*Snap all 4 anchors to the bottom-right of the parent control's bounds. Use with [method set_anchors_preset].*/
	PresetBottomRight LayoutPreset = 3
	/*Snap all 4 anchors to the center of the left edge of the parent control's bounds. Use with [method set_anchors_preset].*/
	PresetCenterLeft LayoutPreset = 4
	/*Snap all 4 anchors to the center of the top edge of the parent control's bounds. Use with [method set_anchors_preset].*/
	PresetCenterTop LayoutPreset = 5
	/*Snap all 4 anchors to the center of the right edge of the parent control's bounds. Use with [method set_anchors_preset].*/
	PresetCenterRight LayoutPreset = 6
	/*Snap all 4 anchors to the center of the bottom edge of the parent control's bounds. Use with [method set_anchors_preset].*/
	PresetCenterBottom LayoutPreset = 7
	/*Snap all 4 anchors to the center of the parent control's bounds. Use with [method set_anchors_preset].*/
	PresetCenter LayoutPreset = 8
	/*Snap all 4 anchors to the left edge of the parent control. The left offset becomes relative to the left edge and the top offset relative to the top left corner of the node's parent. Use with [method set_anchors_preset].*/
	PresetLeftWide LayoutPreset = 9
	/*Snap all 4 anchors to the top edge of the parent control. The left offset becomes relative to the top left corner, the top offset relative to the top edge, and the right offset relative to the top right corner of the node's parent. Use with [method set_anchors_preset].*/
	PresetTopWide LayoutPreset = 10
	/*Snap all 4 anchors to the right edge of the parent control. The right offset becomes relative to the right edge and the top offset relative to the top right corner of the node's parent. Use with [method set_anchors_preset].*/
	PresetRightWide LayoutPreset = 11
	/*Snap all 4 anchors to the bottom edge of the parent control. The left offset becomes relative to the bottom left corner, the bottom offset relative to the bottom edge, and the right offset relative to the bottom right corner of the node's parent. Use with [method set_anchors_preset].*/
	PresetBottomWide LayoutPreset = 12
	/*Snap all 4 anchors to a vertical line that cuts the parent control in half. Use with [method set_anchors_preset].*/
	PresetVcenterWide LayoutPreset = 13
	/*Snap all 4 anchors to a horizontal line that cuts the parent control in half. Use with [method set_anchors_preset].*/
	PresetHcenterWide LayoutPreset = 14
	/*Snap all 4 anchors to the respective corners of the parent control. Set all 4 offsets to 0 after you applied this preset and the [Control] will fit its parent control. Use with [method set_anchors_preset].*/
	PresetFullRect LayoutPreset = 15
)

type LayoutPresetMode = gdclass.ControlLayoutPresetMode //gd:Control.LayoutPresetMode

const (
	/*The control will be resized to its minimum size.*/
	PresetModeMinsize LayoutPresetMode = 0
	/*The control's width will not change.*/
	PresetModeKeepWidth LayoutPresetMode = 1
	/*The control's height will not change.*/
	PresetModeKeepHeight LayoutPresetMode = 2
	/*The control's size will not change.*/
	PresetModeKeepSize LayoutPresetMode = 3
)

type SizeFlags = gdclass.ControlSizeFlags //gd:Control.SizeFlags

const (
	/*Tells the parent [Container] to align the node with its start, either the top or the left edge. It is mutually exclusive with [constant SIZE_FILL] and other shrink size flags, but can be used with [constant SIZE_EXPAND] in some containers. Use with [member size_flags_horizontal] and [member size_flags_vertical].
	  [b]Note:[/b] Setting this flag is equal to not having any size flags.*/
	SizeShrinkBegin SizeFlags = 0
	/*Tells the parent [Container] to expand the bounds of this node to fill all the available space without pushing any other node. It is mutually exclusive with shrink size flags. Use with [member size_flags_horizontal] and [member size_flags_vertical].*/
	SizeFill SizeFlags = 1
	/*Tells the parent [Container] to let this node take all the available space on the axis you flag. If multiple neighboring nodes are set to expand, they'll share the space based on their stretch ratio. See [member size_flags_stretch_ratio]. Use with [member size_flags_horizontal] and [member size_flags_vertical].*/
	SizeExpand SizeFlags = 2
	/*Sets the node's size flags to both fill and expand. See [constant SIZE_FILL] and [constant SIZE_EXPAND] for more information.*/
	SizeExpandFill SizeFlags = 3
	/*Tells the parent [Container] to center the node in the available space. It is mutually exclusive with [constant SIZE_FILL] and other shrink size flags, but can be used with [constant SIZE_EXPAND] in some containers. Use with [member size_flags_horizontal] and [member size_flags_vertical].*/
	SizeShrinkCenter SizeFlags = 4
	/*Tells the parent [Container] to align the node with its end, either the bottom or the right edge. It is mutually exclusive with [constant SIZE_FILL] and other shrink size flags, but can be used with [constant SIZE_EXPAND] in some containers. Use with [member size_flags_horizontal] and [member size_flags_vertical].*/
	SizeShrinkEnd SizeFlags = 8
)

type MouseFilter = gdclass.ControlMouseFilter //gd:Control.MouseFilter

const (
	/*The control will receive mouse movement input events and mouse button input events if clicked on through [method _gui_input]. The control will also receive the [signal mouse_entered] and [signal mouse_exited] signals. These events are automatically marked as handled, and they will not propagate further to other controls. This also results in blocking signals in other controls.*/
	MouseFilterStop MouseFilter = 0
	/*The control will receive mouse movement input events and mouse button input events if clicked on through [method _gui_input]. The control will also receive the [signal mouse_entered] and [signal mouse_exited] signals.
	  If this control does not handle the event, the event will propagate up to its parent control if it has one. The event is bubbled up the node hierarchy until it reaches a non-[CanvasItem], a control with [constant MOUSE_FILTER_STOP], or a [CanvasItem] with [member CanvasItem.top_level] enabled. This will allow signals to fire in all controls it reaches. If no control handled it, the event will be passed to [method Node._shortcut_input] for further processing.*/
	MouseFilterPass MouseFilter = 1
	/*The control will not receive any mouse movement input events nor mouse button input events through [method _gui_input]. The control will also not receive the [signal mouse_entered] nor [signal mouse_exited] signals. This will not block other controls from receiving these events or firing the signals. Ignored events will not be handled automatically. If a child has [constant MOUSE_FILTER_PASS] and an event was passed to this control, the event will further propagate up to the control's parent.
	  [b]Note:[/b] If the control has received [signal mouse_entered] but not [signal mouse_exited], changing the [member mouse_filter] to [constant MOUSE_FILTER_IGNORE] will cause [signal mouse_exited] to be emitted.*/
	MouseFilterIgnore MouseFilter = 2
)

type GrowDirection = gdclass.ControlGrowDirection //gd:Control.GrowDirection

const (
	/*The control will grow to the left or top to make up if its minimum size is changed to be greater than its current size on the respective axis.*/
	GrowDirectionBegin GrowDirection = 0
	/*The control will grow to the right or bottom to make up if its minimum size is changed to be greater than its current size on the respective axis.*/
	GrowDirectionEnd GrowDirection = 1
	/*The control will grow in both directions equally to make up if its minimum size is changed to be greater than its current size.*/
	GrowDirectionBoth GrowDirection = 2
)

type Anchor = gdclass.ControlAnchor //gd:Control.Anchor

const (
	/*Snaps one of the 4 anchor's sides to the origin of the node's [code]Rect[/code], in the top left. Use it with one of the [code]anchor_*[/code] member variables, like [member anchor_left]. To change all 4 anchors at once, use [method set_anchors_preset].*/
	AnchorBegin Anchor = 0
	/*Snaps one of the 4 anchor's sides to the end of the node's [code]Rect[/code], in the bottom right. Use it with one of the [code]anchor_*[/code] member variables, like [member anchor_left]. To change all 4 anchors at once, use [method set_anchors_preset].*/
	AnchorEnd Anchor = 1
)

type LayoutDirection = gdclass.ControlLayoutDirection //gd:Control.LayoutDirection

const (
	/*Automatic layout direction, determined from the parent control layout direction.*/
	LayoutDirectionInherited LayoutDirection = 0
	/*Automatic layout direction, determined from the current locale. Right-to-left layout direction is automatically used for languages that require it such as Arabic and Hebrew, but only if a valid translation file is loaded for the given language (unless said language is configured as a fallback in [member ProjectSettings.internationalization/locale/fallback]). For all other languages (or if no valid translation file is found by Godot), left-to-right layout direction is used. If using [TextServerFallback] ([member ProjectSettings.internationalization/rendering/text_driver]), left-to-right layout direction is always used regardless of the language. Right-to-left layout direction can also be forced using [member ProjectSettings.internationalization/rendering/force_right_to_left_layout_direction].*/
	LayoutDirectionApplicationLocale LayoutDirection = 1
	/*Left-to-right layout direction.*/
	LayoutDirectionLtr LayoutDirection = 2
	/*Right-to-left layout direction.*/
	LayoutDirectionRtl LayoutDirection = 3
	/*Automatic layout direction, determined from the system locale. Right-to-left layout direction is automatically used for languages that require it such as Arabic and Hebrew, but only if a valid translation file is loaded for the given language.. For all other languages (or if no valid translation file is found by Godot), left-to-right layout direction is used. If using [TextServerFallback] ([member ProjectSettings.internationalization/rendering/text_driver]), left-to-right layout direction is always used regardless of the language.*/
	LayoutDirectionSystemLocale LayoutDirection = 4
	/*Represents the size of the [enum LayoutDirection] enum.*/
	LayoutDirectionMax    LayoutDirection = 5
	LayoutDirectionLocale LayoutDirection = 1
)

type TextDirection = gdclass.ControlTextDirection //gd:Control.TextDirection

const (
	/*Text writing direction is the same as layout direction.*/
	TextDirectionInherited TextDirection = 3
	/*Automatic text writing direction, determined from the current locale and text content.*/
	TextDirectionAuto TextDirection = 0
	/*Left-to-right text writing direction.*/
	TextDirectionLtr TextDirection = 1
	/*Right-to-left text writing direction.*/
	TextDirectionRtl TextDirection = 2
)

type Side int

const (
	/*Left side, usually used for [Control] or [StyleBox]-derived classes.*/
	SideLeft Side = 0
	/*Top side, usually used for [Control] or [StyleBox]-derived classes.*/
	SideTop Side = 1
	/*Right side, usually used for [Control] or [StyleBox]-derived classes.*/
	SideRight Side = 2
	/*Bottom side, usually used for [Control] or [StyleBox]-derived classes.*/
	SideBottom Side = 3
)
