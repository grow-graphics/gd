// Code generated by the generate package DO NOT EDIT

// Package Steam provides methods for working with Steam object instances.
package Steam

import "unsafe"
import "sync"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
Full documentation and tutorials are available at https://godotsteam.com/.
*/
type Instance [1]gdclass.Steam

func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

var self [1]gdclass.Steam
var once sync.Once

func singleton() {
	obj := gd.Global.Object.GetSingleton(gd.Global.Singletons.Steam)
	self = *(*[1]gdclass.Steam)(unsafe.Pointer(&obj))
}

/*
Returns the current version of GodotSteam you are using.
*/
func GetGodotsteamVersion() string { //gd:Steam.get_godotsteam_version
	once.Do(singleton)
	return string(Advanced().GetGodotsteamVersion().String())
}

/*
Convert a SteamID64 into a SteamID.
*/
func GetSteamID32(steam_id int) int { //gd:Steam.getSteamID32
	once.Do(singleton)
	return int(int(Advanced().GetSteamID32(int64(steam_id))))
}

/*
Is this an anonymous account?
*/
func IsAnonAccount(steam_id int) bool { //gd:Steam.isAnonAccount
	once.Do(singleton)
	return bool(Advanced().IsAnonAccount(int64(steam_id)))
}

/*
Is this an anonymous user account? Used to create an account or reset a password, but do not try to do this.
*/
func IsAnonUserAccount(steam_id int) bool { //gd:Steam.isAnonUserAccount
	once.Do(singleton)
	return bool(Advanced().IsAnonUserAccount(int64(steam_id)))
}

/*
Is this a chat account ID?
*/
func IsChatAccount(steam_id int) bool { //gd:Steam.isChatAccount
	once.Do(singleton)
	return bool(Advanced().IsChatAccount(int64(steam_id)))
}

/*
Is this a clan account ID?
*/
func IsClanAccount(steam_id int) bool { //gd:Steam.isClanAccount
	once.Do(singleton)
	return bool(Advanced().IsClanAccount(int64(steam_id)))
}

/*
Is this a faked up Steam ID for a PSN friend account?
*/
func IsConsoleUserAccount(steam_id int) bool { //gd:Steam.isConsoleUserAccount
	once.Do(singleton)
	return bool(Advanced().IsConsoleUserAccount(int64(steam_id)))
}

/*
Is this an individual user account ID?
*/
func IsIndividualAccount(steam_id int) bool { //gd:Steam.isIndividualAccount
	once.Do(singleton)
	return bool(Advanced().IsIndividualAccount(int64(steam_id)))
}

/*
Is this a lobby account ID?
*/
func IsLobby(steam_id int) bool { //gd:Steam.isLobby
	once.Do(singleton)
	return bool(Advanced().IsLobby(int64(steam_id)))
}

/*
Check if the Steam client is running.
Naturally, returns true if the Steam client is running.
[b]Note:[/b] While this is not listed in the Steamworks docs, it is in the SDK.
*/
func IsSteamRunning() bool { //gd:Steam.isSteamRunning
	once.Do(singleton)
	return bool(Advanced().IsSteamRunning())
}

/*
Enables your application to receive callbacks from Steamworks. Must be placed in your _process function.
*/
func RunCallbacks() { //gd:Steam.run_callbacks
	once.Do(singleton)
	Advanced().RunCallbacks()
}

/*
Checks if your executable was launched through Steam and relaunches it through Steam if it wasn't.
If this returns true then it starts the Steam client if required and launches your game again through it, and you should quit your process as soon as possible. If it returns false, then your game was launched by the Steam client and no action needs to be taken.
*/
func RestartAppIfNecessary(app_id int) bool { //gd:Steam.restartAppIfNecessary
	once.Do(singleton)
	return bool(Advanced().RestartAppIfNecessary(int64(app_id)))
}

/*
Starts up the Steam API.
You will receive one of four results:
[codeblock]
• 1 / "Steamworks active"
• 2 / "Steamworks failed to initialize"
• 20 / "Steam not running"
• 79 / "Invalid app ID or app not installed"
[/codeblock]
You can also pass an app ID for GodotSteam to use for your game, which will default to 480 (SpaceWars) if nothing is passed.
Finally, you can pass true for embed_callbacks which will internally do the run_callbacks for your Steam callbacks so you don't have to code that separately in your game.
*/
func SteamInit(retrieve_stats bool, app_id int, embed_callbacks bool) map[any]any { //gd:Steam.steamInit
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().SteamInit(retrieve_stats, int64(app_id), embed_callbacks)))
}

/*
Starts up the Steam API.
You will receive one of four results:
[codeblock]
• 1 / "Steamworks active"
• 2 / "Steamworks failed to initialize"
• 20 / "Steam not running"
• 79 / "Invalid app ID or app not installed"
[/codeblock]
You can also pass an app ID for GodotSteam to use for your game, which will default to 480 (SpaceWars) if nothing is passed.
Finally, you can pass true for embed_callbacks which will internally do the run_callbacks for your Steam callbacks so you don't have to code that separately in your game.
*/
func SteamInitOptions(retrieve_stats bool, app_id int, embed_callbacks bool) map[any]any { //gd:Steam.steamInit
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().SteamInit(retrieve_stats, int64(app_id), embed_callbacks)))
}

/*
Initialize the Steamworks SDK. On success [enum SteamAPIInitResult] is returned.  Otherwise, if error_message is non-NULL, it will receive a non-localized message that explains the reason for the failure.
[codeblock]
• 0 / "Steamworks active"
• 1 / "Failed (generic)"
• 2 / "Cannot connect to Steam, client probably isn't running"
• 3 / "Steam client appears to be out of date"
[/codeblock]
You can also pass an app ID for GodotSteam to use for your game, which will default to 480 (SpaceWars) if nothing is passed.
Finally, you can pass true for embed_callbacks which will internally do the run_callbacks for your Steam callbacks so you don't have to code that separately in your game.
*/
func SteamInitEx(retrieve_stats bool, app_id int, embed_callbacks bool) map[any]any { //gd:Steam.steamInitEx
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().SteamInitEx(retrieve_stats, int64(app_id), embed_callbacks)))
}

/*
Initialize the Steamworks SDK. On success [enum SteamAPIInitResult] is returned.  Otherwise, if error_message is non-NULL, it will receive a non-localized message that explains the reason for the failure.
[codeblock]
• 0 / "Steamworks active"
• 1 / "Failed (generic)"
• 2 / "Cannot connect to Steam, client probably isn't running"
• 3 / "Steam client appears to be out of date"
[/codeblock]
You can also pass an app ID for GodotSteam to use for your game, which will default to 480 (SpaceWars) if nothing is passed.
Finally, you can pass true for embed_callbacks which will internally do the run_callbacks for your Steam callbacks so you don't have to code that separately in your game.
*/
func SteamInitExOptions(retrieve_stats bool, app_id int, embed_callbacks bool) map[any]any { //gd:Steam.steamInitEx
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().SteamInitEx(retrieve_stats, int64(app_id), embed_callbacks)))
}

/*
Shuts down the Steamworks API, releases pointers and frees memory.
*/
func SteamShutdown() { //gd:Steam.steamShutdown
	once.Do(singleton)
	Advanced().SteamShutdown()
}

/*
Returns the current server list request handle.
*/
func GetServerListRequest() int { //gd:Steam.get_server_list_request
	once.Do(singleton)
	return int(int(Advanced().GetServerListRequest()))
}

/*
Set the current server list request handle.
*/
func SetServerListRequest(new_server_list_request int) { //gd:Steam.set_server_list_request
	once.Do(singleton)
	Advanced().SetServerListRequest(int64(new_server_list_request))
}

/*
Gets the build ID of this app, may change at any time based on backend updates to the game.
The current build ID of this app. Defaults to 0 if you're not running a build downloaded from Steam.
*/
func GetAppBuildId() int { //gd:Steam.getAppBuildId
	once.Do(singleton)
	return int(int(Advanced().GetAppBuildId()))
}

/*
Gets the install folder for a specific app ID. This works even if the application is not installed, based on where the game would be installed with the default Steam library location.
[codeblock]
The returned dictionary contains the following keys:
┠╴directory (string)
┠╴install_size (int)
┖╴size (int)
[/codeblock]
*/
func GetAppInstallDir(app_id int) map[any]any { //gd:Steam.getAppInstallDir
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetAppInstallDir(int64(app_id))))
}

/*
Gets the Steam ID of the original owner of the current app. If it's different from the current user then it is borrowed.
*/
func GetAppOwner() int { //gd:Steam.getAppOwner
	once.Do(singleton)
	return int(int(Advanced().GetAppOwner()))
}

/*
Gets a comma separated list of the languages the current app supports.
*/
func GetAvailableGameLanguages() string { //gd:Steam.getAvailableGameLanguages
	once.Do(singleton)
	return string(Advanced().GetAvailableGameLanguages().String())
}

/*
Return beta branch details, name, description, current build ID and state flags (BetaBranchFlags).
The returned dictionary contains the following keys:
[codeblock]
┠╴index (int)
┠╴flags (uint32)
┠╴build_id (uint32)
┠╴name (string)
┖╴description (string)
[/codeblock]
*/
func GetBetaInfo() map[any]any { //gd:Steam.getBetaInfo
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetBetaInfo()))
}

/*
Checks if the user is running from a beta branch, and gets the name of the branch if they are.
*/
func GetCurrentBetaName() string { //gd:Steam.getCurrentBetaName
	once.Do(singleton)
	return string(Advanced().GetCurrentBetaName().String())
}

/*
Gets the current language that the user has set.
*/
func GetCurrentGameLanguage() string { //gd:Steam.getCurrentGameLanguage
	once.Do(singleton)
	return string(Advanced().GetCurrentGameLanguage().String())
}

/*
Get the number of DLC the user owns for a parent application / game.
*/
func GetDLCCount() int { //gd:Steam.getDLCCount
	once.Do(singleton)
	return int(int(Advanced().GetDLCCount()))
}

/*
Get all DLC data in an array.
The returned array contains a list of:
[codeblock]
┖╴dlc (dictionary)

	┠╴app_id (int)
	┠╴available (bool)
	┖╴name (string)

[/codeblock]
*/
func GetDLCData() []any { //gd:Steam.getDLCData
	once.Do(singleton)
	return []any(gd.ArrayAs[[]any](gd.InternalArray(Advanced().GetDLCData())))
}

/*
Returns metadata for a DLC by index.
The returned dictionary contains the following keys:
[codeblock]
┠╴app_id (int)
┠╴available (bool)
┖╴name (string)
[/codeblock]
*/
func GetDLCDataByIndex(this_dlc_index int) map[any]any { //gd:Steam.getDLCDataByIndex
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetDLCDataByIndex(int64(this_dlc_index))))
}

/*
Gets the download progress for optional DLC.
The returned dictionary contains the following keys:
[codeblock]
┠╴ret (bool)
┠╴downloaded (int)
┖╴total (int)
[/codeblock]
*/
func GetDLCDownloadProgress(dlc_id int) map[any]any { //gd:Steam.getDLCDownloadProgress
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetDLCDownloadProgress(int64(dlc_id))))
}

/*
Gets the time of purchase of the specified app in Unix epoch format (time since Jan 1st, 1970).
*/
func GetEarliestPurchaseUnixTime(app_id int) int { //gd:Steam.getEarliestPurchaseUnixTime
	once.Do(singleton)
	return int(int(Advanced().GetEarliestPurchaseUnixTime(int64(app_id))))
}

/*
Asynchronously retrieves metadata details about a specific file in the depot manifest.
[b]Note:[/b] Triggers a [signal Steam.file_details_result].
*/
func GetFileDetails(filename string) { //gd:Steam.getFileDetails
	once.Do(singleton)
	Advanced().GetFileDetails(String.New(filename))
}

/*
Gets a list of all installed depots for a given App ID; returned in mount order.
Contains the installed depots, returned in mount order.
*/
func GetInstalledDepots(app_id int) []any { //gd:Steam.getInstalledDepots
	once.Do(singleton)
	return []any(gd.ArrayAs[[]any](gd.InternalArray(Advanced().GetInstalledDepots(int64(app_id)))))
}

/*
Gets the command line if the game was launched via Steam URL, e.g. steam://run/{appid}//{command line}/. This method is preferable to launching with a command line via the operating system, which can be a security risk. In order for rich presence joins to go through this and not be placed on the OS command line, you must enable "Use launch command line" from the Installation > General page on your app.
*/
func GetLaunchCommandLine() string { //gd:Steam.getLaunchCommandLine
	once.Do(singleton)
	return string(Advanced().GetLaunchCommandLine().String())
}

/*
Gets the associated launch parameter if the game is run via steam://run/{appid}/?param1=value1;param2=value2;param3=value3 etc.
*/
func GetLaunchQueryParam(key string) string { //gd:Steam.getLaunchQueryParam
	once.Do(singleton)
	return string(Advanced().GetLaunchQueryParam(String.New(key)).String())
}

/*
Returns total number of known app beta branches (including default "public" branch).
*/
func GetNumBetas() map[any]any { //gd:Steam.getNumBetas
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetNumBetas()))
}

/*
Allows you to install an optional DLC.
*/
func InstallDLC(dlc_id int) { //gd:Steam.installDLC
	once.Do(singleton)
	Advanced().InstallDLC(int64(dlc_id))
}

/*
Checks if a specific app is installed. The app may not actually be owned by the current user, they may have it left over from a free weekend, etc. This only works for base applications, not downloadable content (DLC). Use [method Steam.isDLCInstalled] for DLC instead.
True if the specified app ID is installed; otherwise, false.
*/
func IsAppInstalled(app_id int) bool { //gd:Steam.isAppInstalled
	once.Do(singleton)
	return bool(Advanced().IsAppInstalled(int64(app_id)))
}

/*
Checks whether the current App ID is for Cyber Cafes.
*/
func IsCybercafe() bool { //gd:Steam.isCybercafe
	once.Do(singleton)
	return bool(Advanced().IsCybercafe())
}

/*
Checks if the user owns a specific DLC and if the DLC is installed.
True if the user owns the DLC and it's currently installed, otherwise false.
[b]Note:[/b] Should only be used for simple client side checks - not intended for granting in-game items.
*/
func IsDLCInstalled(dlc_id int) bool { //gd:Steam.isDLCInstalled
	once.Do(singleton)
	return bool(Advanced().IsDLCInstalled(int64(dlc_id)))
}

/*
Checks if the license owned by the user provides low violence depots.
True if the user owns the DLC and it's currently installed, otherwise false.
*/
func IsLowViolence() bool { //gd:Steam.isLowViolence
	once.Do(singleton)
	return bool(Advanced().IsLowViolence())
}

/*
Checks if the active user is subscribed to the current app ID.
True if the active user owns the current app ID, otherwise false.
*/
func IsSubscribed() bool { //gd:Steam.isSubscribed
	once.Do(singleton)
	return bool(Advanced().IsSubscribed())
}

/*
Checks if the active user is subscribed to a specified app ID. Only use this if you need to check ownership of another game related to yours, a demo for example.
True if the active user is subscribed to the specified app ID, otherwise false.
*/
func IsSubscribedApp(app_id int) bool { //gd:Steam.isSubscribedApp
	once.Do(singleton)
	return bool(Advanced().IsSubscribedApp(int64(app_id)))
}

/*
Checks if the active user is accessing the current app ID via a temporary Family Shared license owned by another user.
True if the active user is accessing the current appID via family sharing, otherwise false.
If you need to determine the Steam ID of the permanent owner of the license, use [method Steam.getAppOwner].
*/
func IsSubscribedFromFamilySharing() bool { //gd:Steam.isSubscribedFromFamilySharing
	once.Do(singleton)
	return bool(Advanced().IsSubscribedFromFamilySharing())
}

/*
Checks if the user is subscribed to the current app through a free weekend. This function will return false for users who have a retail or other type of license. Suggested you contact Valve on how to package and secure your free weekend properly.
True if the active user is subscribed to the current app ID via a free weekend otherwise false any other type of license.
*/
func IsSubscribedFromFreeWeekend() bool { //gd:Steam.isSubscribedFromFreeWeekend
	once.Do(singleton)
	return bool(Advanced().IsSubscribedFromFreeWeekend())
}

/*
Checks if the user is subscribed to the current app ID through a timed trial. If so, returns true and gives back the total time the timed trial is allowed to play, along with the current amount of time the user has played.
The returned dictionary contains these keys:
[codeblock]
┠╴seconds_allowed (int)
┖╴seconds_played (int)
[/codeblock]
*/
func IsTimedTrial() map[any]any { //gd:Steam.isTimedTrial
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().IsTimedTrial()))
}

/*
Checks if the user has a VAC ban on their account.
True if the user has a VAC ban on their account; otherwise, false.
*/
func IsVACBanned() bool { //gd:Steam.isVACBanned
	once.Do(singleton)
	return bool(Advanced().IsVACBanned())
}

/*
Allows you to force verify game content on next launch.
*/
func MarkContentCorrupt(missing_files_only bool) bool { //gd:Steam.markContentCorrupt
	once.Do(singleton)
	return bool(Advanced().MarkContentCorrupt(missing_files_only))
}

/*
Select this beta branch for this app as active, might need the game to restart so Steam can update to that branch.
*/
func SetActiveBeta(beta_name string) bool { //gd:Steam.setActiveBeta
	once.Do(singleton)
	return bool(Advanced().SetActiveBeta(String.New(beta_name)))
}

/*
Set current DLC app ID being played (or 0 if none). Allows Steam to track usage of major DLC extensions.
*/
func SetDLCContext(app_id int) bool { //gd:Steam.setDLCContext
	once.Do(singleton)
	return bool(Advanced().SetDLCContext(int64(app_id)))
}

/*
Allows you to uninstall an optional DLC.
*/
func UninstallDLC(dlc_id int) { //gd:Steam.uninstallDLC
	once.Do(singleton)
	Advanced().UninstallDLC(int64(dlc_id))
}

/*
Activates the overlay with optional dialog to open the following: [b]Friend, Community, Players, Settings, OfficialGameGroup, Stats, Achievements, or LobbyInvite.[/b]
*/
func ActivateGameOverlay(atype string) { //gd:Steam.activateGameOverlay
	once.Do(singleton)
	Advanced().ActivateGameOverlay(String.New(atype))
}

/*
Activates the overlay with optional dialog to open the following: [b]Friend, Community, Players, Settings, OfficialGameGroup, Stats, Achievements, or LobbyInvite.[/b]
*/
func ActivateGameOverlayOptions(atype string) { //gd:Steam.activateGameOverlay
	once.Do(singleton)
	Advanced().ActivateGameOverlay(String.New(atype))
}

/*
Activates game overlay to open the invite dialog. Invitations will be sent for the provided lobby.
*/
func ActivateGameOverlayInviteDialog(steam_id int) { //gd:Steam.activateGameOverlayInviteDialog
	once.Do(singleton)
	Advanced().ActivateGameOverlayInviteDialog(int64(steam_id))
}

/*
Activates the game overlay to open an invite dialog that will send the provided Rich Presence connect string to selected friends.
*/
func ActivateGameOverlayInviteDialogConnectString(connect_string string) { //gd:Steam.activateGameOverlayInviteDialogConnectString
	once.Do(singleton)
	Advanced().ActivateGameOverlayInviteDialogConnectString(String.New(connect_string))
}

/*
Activates the overlay with the application / game Steam store page.
*/
func ActivateGameOverlayToStore(app_id int) { //gd:Steam.activateGameOverlayToStore
	once.Do(singleton)
	Advanced().ActivateGameOverlayToStore(int64(app_id))
}

/*
Activates the overlay with the application / game Steam store page.
*/
func ActivateGameOverlayToStoreOptions(app_id int) { //gd:Steam.activateGameOverlayToStore
	once.Do(singleton)
	Advanced().ActivateGameOverlayToStore(int64(app_id))
}

/*
Activates the overlay to one of the following: [b]steamid, chat, jointrade, stats, achievements, friendadd, friendremove, friendrequestaccept, or friendrequestignore.[/b]
*/
func ActivateGameOverlayToUser(atype string, steam_id int) { //gd:Steam.activateGameOverlayToUser
	once.Do(singleton)
	Advanced().ActivateGameOverlayToUser(String.New(atype), int64(steam_id))
}

/*
Activates the overlay to one of the following: [b]steamid, chat, jointrade, stats, achievements, friendadd, friendremove, friendrequestaccept, or friendrequestignore.[/b]
*/
func ActivateGameOverlayToUserOptions(atype string, steam_id int) { //gd:Steam.activateGameOverlayToUser
	once.Do(singleton)
	Advanced().ActivateGameOverlayToUser(String.New(atype), int64(steam_id))
}

/*
Activates the overlay with specified web address.
*/
func ActivateGameOverlayToWebPage(url string) { //gd:Steam.activateGameOverlayToWebPage
	once.Do(singleton)
	Advanced().ActivateGameOverlayToWebPage(String.New(url))
}

/*
Clear the game information in Steam; used in 'View Game Info'.
*/
func ClearRichPresence() { //gd:Steam.clearRichPresence
	once.Do(singleton)
	Advanced().ClearRichPresence()
}

/*
Closes the specified Steam group chat room in the Steam UI.
*/
func CloseClanChatWindowInSteam(chat_id int) bool { //gd:Steam.closeClanChatWindowInSteam
	once.Do(singleton)
	return bool(Advanced().CloseClanChatWindowInSteam(int64(chat_id)))
}

/*
Refresh the Steam Group activity data or get the data from groups other than one that the current user is a member. After receiving the callback you can then use [method Steam.getClanActivityCounts] to get the up to date user counts.
Triggers a [signal Steam.clan_activity_downloaded] callback.
*/
func DownloadClanActivityCounts(chat_id int, clans_to_request int) { //gd:Steam.downloadClanActivityCounts
	once.Do(singleton)
	Advanced().DownloadClanActivityCounts(int64(chat_id), int64(clans_to_request))
}

/*
Gets the list of users that the current user is following. You can be following people that are not your friends. Following allows you to receive updates when the person does things like post a new piece of content to the Steam Workshop.
Triggers a [signal Steam.enumerate_following_list] callback.
[b]Note:[/b] This returns up to k_cEnumerateFollowersMax users at once. If the current user is following more than that, you will need to call this repeatedly, with start_index set to the total number of followers that you have received so far. I.E. If you have received 50 followers, and the user is following 105, you will need to call this again with start_index = 50 to get the next 50, and then again with start_index = 100 to get the remaining 5 users.
*/
func EnumerateFollowingList(start_index int) { //gd:Steam.enumerateFollowingList
	once.Do(singleton)
	Advanced().EnumerateFollowingList(int64(start_index))
}

/*
Gets the Steam ID at the given index in a Steam group chat.
[b]Note:[/b] You must call [method Steam.getClanChatMemberCount] before calling this.
*/
func GetChatMemberByIndex(clan_id int, user int) int { //gd:Steam.getChatMemberByIndex
	once.Do(singleton)
	return int(int(Advanced().GetChatMemberByIndex(int64(clan_id), int64(user))))
}

/*
Gets the most recent information we have about what the users in a Steam Group are doing. This can only retrieve data that the local client knows about. To refresh the data or get data from a group other than one that the current user is a member of you must call [method Steam.downloadClanActivityCounts].
Contains the following keys: [b]clan (int), online (int), ingame (int), and chatting (int)[/b]
*/
func GetClanActivityCounts(clan_id int) map[any]any { //gd:Steam.getClanActivityCounts
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetClanActivityCounts(int64(clan_id))))
}

/*
Gets the Steam group's Steam ID at the given index.
[b]Note:[/b] You must call [method Steam.getClanCount] before calling this.
*/
func GetClanByIndex(clan_index int) int { //gd:Steam.getClanByIndex
	once.Do(singleton)
	return int(int(Advanced().GetClanByIndex(int64(clan_index))))
}

/*
Get the number of users in a Steam group chat.
[b]Note:[/b] Large steam groups cannot be iterated by the local user.
[b]Note:[/b] The current user must be in a lobby to retrieve the Steam IDs of other users in that lobby. This is used for iteration, after calling this then [method Steam.getChatMemberByIndex] can be used to get the Steam ID of each person in the chat.
*/
func GetClanChatMemberCount(clan_id int) int { //gd:Steam.getClanChatMemberCount
	once.Do(singleton)
	return int(int(Advanced().GetClanChatMemberCount(int64(clan_id))))
}

/*
Gets the data from a Steam group chat room message. This should only ever be called in response to a [signal Steam.connected_clan_chat_message] callback.
The returned dictionary contains the following keys: [b]ret (bool), text (string), type (int), and chatter (int) as a Steam ID.[/b]
*/
func GetClanChatMessage(chat_id int, message int) map[any]any { //gd:Steam.getClanChatMessage
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetClanChatMessage(int64(chat_id), int64(message))))
}

/*
Gets the number of Steam groups that the current user is a member of. This is used for iteration, after calling this then [method Steam.getClanByIndex] can be used to get the Steam ID of each Steam group.
*/
func GetClanCount() int { //gd:Steam.getClanCount
	once.Do(singleton)
	return int(int(Advanced().GetClanCount()))
}

/*
Gets the display name for the specified Steam group; if the local client knows about it.
*/
func GetClanName(clan_id int) string { //gd:Steam.getClanName
	once.Do(singleton)
	return string(Advanced().GetClanName(int64(clan_id)).String())
}

/*
Gets the Steam ID of the officer at the given index in a Steam group.
[b]Note:[/b] You must call [method Steam.getClanOfficerCount] before calling this.
*/
func GetClanOfficerByIndex(clan_id int, officer int) int { //gd:Steam.getClanOfficerByIndex
	once.Do(singleton)
	return int(int(Advanced().GetClanOfficerByIndex(int64(clan_id), int64(officer))))
}

/*
Gets the number of officers (administrators and moderators) in a specified Steam group. This also includes the owner of the Steam group. This is used for iteration, after calling this then [method Steam.getClanOfficerByIndex] can be used to get the Steam ID of each officer.
[b]Note:[/b] You must call [method Steam.requestClanOfficerList] before this to get the required data.
*/
func GetClanOfficerCount(clan_id int) int { //gd:Steam.getClanOfficerCount
	once.Do(singleton)
	return int(int(Advanced().GetClanOfficerCount(int64(clan_id))))
}

/*
Get the steam ID of the clan owner.
*/
func GetClanOwner(clan_id int) int { //gd:Steam.getClanOwner
	once.Do(singleton)
	return int(int(Advanced().GetClanOwner(int64(clan_id))))
}

/*
Gets the unique tag (abbreviation) for the specified Steam group; If the local client knows about it. The Steam group abbreviation is a unique way for people to identify the group and is limited to 12 characters. In some games this will appear next to the name of group members.
*/
func GetClanTag(clan_id int) string { //gd:Steam.getClanTag
	once.Do(singleton)
	return string(Advanced().GetClanTag(int64(clan_id)).String())
}

/*
Gets the Steam ID of the recently played with user at the given index.
*/
func GetCoplayFriend(friend_number int) int { //gd:Steam.getCoplayFriend
	once.Do(singleton)
	return int(int(Advanced().GetCoplayFriend(int64(friend_number))))
}

/*
Gets the number of players that the current users has recently played with, across all games. This is used for iteration, after calling this then [method Steam.getCoplayFriend] can be used to get the Steam ID of each player. These players are have been set with previous calls to [method Steam.setPlayedWith].
*/
func GetCoplayFriendCount() int { //gd:Steam.getCoplayFriendCount
	once.Do(singleton)
	return int(int(Advanced().GetCoplayFriendCount()))
}

/*
Gets the number of users following the specified user.
Triggers a [signal Steam.get_follower_count] callback.
*/
func GetFollowerCount(steam_id int) { //gd:Steam.getFollowerCount
	once.Do(singleton)
	Advanced().GetFollowerCount(int64(steam_id))
}

/*
Gets the Steam ID of the user at the given index.
[b]Note:[/b] You must call [method Steam.getFriendCount] before calling this.
*/
func GetFriendByIndex(friend_number int, friend_flags FriendFlags) int { //gd:Steam.getFriendByIndex
	once.Do(singleton)
	return int(int(Advanced().GetFriendByIndex(int64(friend_number), friend_flags)))
}

/*
Gets the app ID of the game that user played with someone on their recently-played-with list.
*/
func GetFriendCoplayGame(friend_id int) int { //gd:Steam.getFriendCoplayGame
	once.Do(singleton)
	return int(int(Advanced().GetFriendCoplayGame(int64(friend_id))))
}

/*
Gets the timestamp of when the user played with someone on their recently-played-with list. The time is provided in Unix epoch format (seconds since Jan 1st 1970).
*/
func GetFriendCoplayTime(friend_id int) int { //gd:Steam.getFriendCoplayTime
	once.Do(singleton)
	return int(int(Advanced().GetFriendCoplayTime(int64(friend_id))))
}

/*
Gets the number of users the client knows about who meet a specified criteria. (Friends, blocked, users on the same server, etc). This can be used to iterate over all of the users by calling [method Steam.getFriendByIndex] to get the Steam IDs of each user.
[b]Note:[/b] Returns -1 if the current user is not logged on.
*/
func GetFriendCount() int { //gd:Steam.getFriendCount
	once.Do(singleton)
	return int(int(Advanced().GetFriendCount(65535)))
}

/*
Gets the number of users the client knows about who meet a specified criteria. (Friends, blocked, users on the same server, etc). This can be used to iterate over all of the users by calling [method Steam.getFriendByIndex] to get the Steam IDs of each user.
[b]Note:[/b] Returns -1 if the current user is not logged on.
*/
func GetFriendCountOptions(friend_flags FriendFlags) int { //gd:Steam.getFriendCount
	once.Do(singleton)
	return int(int(Advanced().GetFriendCount(friend_flags)))
}

/*
Get the number of users in a source (Steam group, chat room, lobby, or game server). This is used for iteration, after calling this then [method Steam.getFriendFromSourceByIndex] can be used to get the Steam ID of each person in the source.
[b]Note:[/b] Large Steam groups cannot be iterated by the local user.
[b]Note:[/b] If you're getting the number of lobby members then you should use [method Steam.getNumLobbyMembers] instead.
*/
func GetFriendCountFromSource(source_id int) int { //gd:Steam.getFriendCountFromSource
	once.Do(singleton)
	return int(int(Advanced().GetFriendCountFromSource(int64(source_id))))
}

/*
Gets the Steam ID at the given index from a source (Steam group, chat room, lobby, or game server).
[b]Note:[/b] You must call [method Steam.getFriendCountFromSource] before calling this.
*/
func GetFriendFromSourceByIndex(source_id int, friend_number int) int { //gd:Steam.getFriendFromSourceByIndex
	once.Do(singleton)
	return int(int(Advanced().GetFriendFromSourceByIndex(int64(source_id), int64(friend_number))))
}

/*
Checks if the specified friend is in a game, and gets info about the game if they are.
The returned dictionary contains the following keys:
[codeblock]
┠╴id (int) as app ID
┠╴ip (string)
┠╴game_port (int)
┠╴query_port (int)
┖╴lobby (int)
[/codeblock]
*/
func GetFriendGamePlayed(steam_id int) map[any]any { //gd:Steam.getFriendGamePlayed
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetFriendGamePlayed(int64(steam_id))))
}

/*
Gets the data from a Steam friends message. This should only ever be called in response to a [signal Steam.connected_friend_chat_message] callback.
The returned dictionary contains the following keys:
[codeblock]
┠╴ret (int)
┠╴text (string)
┖╴type (int)
[/codeblock]
*/
func GetFriendMessage(friend_id int, message int) map[any]any { //gd:Steam.getFriendMessage
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetFriendMessage(int64(friend_id), int64(message))))
}

/*
Gets the specified user's persona (display) name. This will only be known to the current user if the other user is in their friends list, on the same game server, in a chat room or lobby, or in a small Steam group with the local user. To get the persona name of the current user use [method Steam.getPersonaName].
[b]Note:[/b] Upon on first joining a lobby, chat room, or game server the current user will not known the name of the other users automatically; that information will arrive asynchronously via [signal Steam.persona_state_change] callbacks.
*/
func GetFriendPersonaName(steam_id int) string { //gd:Steam.getFriendPersonaName
	once.Do(singleton)
	return string(Advanced().GetFriendPersonaName(int64(steam_id)).String())
}

/*
Gets one of the previous display names for the specified user. This only works for display names that the current user has seen on the local computer.
*/
func GetFriendPersonaNameHistory(steam_id int, name_history int) string { //gd:Steam.getFriendPersonaNameHistory
	once.Do(singleton)
	return string(Advanced().GetFriendPersonaNameHistory(int64(steam_id), int64(name_history)).String())
}

/*
Gets the current status of the specified user. This will only be known to the current user if the other user is in their friends list, on the same game server, in a chat room or lobby, or in a small Steam group with the local user. To get the state of the current user use [method Steam.getPersonaState].
Should be one of the following:
[codeblock]
• 0 / Offline
• 1 / Online
• 2 / Busy
• 3 / Away
• 4 / Snooze
• 5 / Looking For Trade
• 6 / Looking for Play
[/codeblock]
*/
func GetFriendPersonaState(steam_id int) PersonaState { //gd:Steam.getFriendPersonaState
	once.Do(singleton)
	return PersonaState(Advanced().GetFriendPersonaState(int64(steam_id)))
}

/*
Gets a relationship to a specified user.
Should be one of the following:
[codeblock]
• 0 / None
• 1 / Blocked
• 2 / Request Recipient
• 3 / Friend
• 4 / Request Initiator
• 5 / Ignored
• 6 / Ignored Friend
• 7 / Suggested
• 8 / Max
[/codeblock]
*/
func GetFriendRelationship(steam_id int) FriendRelationship { //gd:Steam.getFriendRelationship
	once.Do(singleton)
	return FriendRelationship(Advanced().GetFriendRelationship(int64(steam_id)))
}

/*
Get a Rich Presence value from a specified friend (typically only used for debugging).
*/
func GetFriendRichPresence(friend_id int, key string) string { //gd:Steam.getFriendRichPresence
	once.Do(singleton)
	return string(Advanced().GetFriendRichPresence(int64(friend_id), String.New(key)).String())
}

/*
Gets the number of Rich Presence keys that are set on the specified user. This is used for iteration, after calling this then [method Steam.getFriendRichPresenceKeyByIndex] to get the rich presence keys. This is typically only ever used for debugging purposes.
*/
func GetFriendRichPresenceKeyCount(friend_id int) int { //gd:Steam.getFriendRichPresenceKeyCount
	once.Do(singleton)
	return int(int(Advanced().GetFriendRichPresenceKeyCount(int64(friend_id))))
}

/*
Returns an empty string ("") if the index is invalid or the specified user has no Rich Presence data available.
*/
func GetFriendRichPresenceKeyByIndex(friend_id int, key int) string { //gd:Steam.getFriendRichPresenceKeyByIndex
	once.Do(singleton)
	return string(Advanced().GetFriendRichPresenceKeyByIndex(int64(friend_id), int64(key)).String())
}

/*
Gets the number of friends groups (tags) the user has created. This is used for iteration, after calling this then [method Steam.getFriendsGroupIDByIndex] can be used to get the ID of each friend group. This is not to be confused with Steam groups. Those can be obtained with [method Steam.getClanCount].
*/
func GetFriendsGroupCount() int { //gd:Steam.getFriendsGroupCount
	once.Do(singleton)
	return int(int(Advanced().GetFriendsGroupCount()))
}

/*
Gets the friends group ID for the given index.
[b]Note:[/b] You must call [method Steam.getFriendsGroupCount] before calling this.
*/
func GetFriendsGroupIDByIndex(friend_group int) int { //gd:Steam.getFriendsGroupIDByIndex
	once.Do(singleton)
	return int(int(Advanced().GetFriendsGroupIDByIndex(int64(friend_group))))
}

/*
Gets the number of friends in a given friends group. This should be called before getting the list of friends with [method Steam.getFriendsGroupMembersList].
*/
func GetFriendsGroupMembersCount(friend_group int) int { //gd:Steam.getFriendsGroupMembersCount
	once.Do(singleton)
	return int(int(Advanced().GetFriendsGroupMembersCount(int64(friend_group))))
}

/*
Gets the number of friends in the given friends group. If fewer friends exist than requested those positions' Steam IDs will be invalid. You must call [method Steam.getFriendsGroupMembersCount] before calling this to set up the member_count argument with an appropriate size!
The returned array contains a list of friend Steam IDs (int).
*/
func GetFriendsGroupMembersList(friend_group int, member_count int) []any { //gd:Steam.getFriendsGroupMembersList
	once.Do(singleton)
	return []any(gd.ArrayAs[[]any](gd.InternalArray(Advanced().GetFriendsGroupMembersList(int64(friend_group), int64(member_count)))))
}

/*
Gets the name for the given friends group.
*/
func GetFriendsGroupName(friend_group int) string { //gd:Steam.getFriendsGroupName
	once.Do(singleton)
	return string(Advanced().GetFriendsGroupName(int64(friend_group)).String())
}

/*
Gets the Steam level of the specified user. You can use the local users Steam ID to get their level.
*/
func GetFriendSteamLevel(steam_id int) int { //gd:Steam.getFriendSteamLevel
	once.Do(singleton)
	return int(int(Advanced().GetFriendSteamLevel(int64(steam_id))))
}

/*
Gets a handle to the large (128 x 128px) avatar for the specified user. You can pass in [method Steam.getSteamID] to get the current user's avatar.
Triggers a [signal Steam.avatar_loaded] callback.
A Steam image handle which is used with [method Steam.getImageSize] and [method Steam.getImageRGBA].
[b]Note:[/b] This only works for users that the local user knows about. They will automatically know about their friends, people on leaderboards they've requested, or people in the same source as them (Steam group, chat room, lobby, or game server). If they don't know about them then you must call [method Steam.requestUserInformation] to cache the avatar locally.
*/
func GetLargeFriendAvatar(steam_id int) int { //gd:Steam.getLargeFriendAvatar
	once.Do(singleton)
	return int(int(Advanced().GetLargeFriendAvatar(int64(steam_id))))
}

/*
Gets a handle to the medium (64 x 64px) avatar for the specified user. You can pass in [method Steam.getSteamID] to get the current user's avatar.
A Steam image handle which is used with [method Steam.getImageSize] and [method Steam.getImageRGBA].
[b]Note:[/b] This only works for users that the local user knows about. They will automatically know about their friends, people on leaderboards they've requested, or people in the same source as them (Steam group, chat room, lobby, or game server). If they don't know about them then you must call [method Steam.requestUserInformation] to cache the avatar locally.
*/
func GetMediumFriendAvatar(steam_id int) int { //gd:Steam.getMediumFriendAvatar
	once.Do(singleton)
	return int(int(Advanced().GetMediumFriendAvatar(int64(steam_id))))
}

/*
Gets the current user's persona (display) name. This is the same name that is displayed the users community profile page. To get the persona name of other users use [method Steam.getFriendPersonaName].
*/
func GetPersonaName() string { //gd:Steam.getPersonaName
	once.Do(singleton)
	return string(Advanced().GetPersonaName().String())
}

/*
Gets the friend status of the current user. To get the state of other users use [method Steam.getFriendPersonaState].
Should be one of the following:
[codeblock]
• 0 / Offline
• 1 / Online
• 2 / Busy
• 3 / Away
• 4 / Snooze
• 5 / Looking For Trade
• 6 / Looking for Play
[/codeblock]
*/
func GetPersonaState() PersonaState { //gd:Steam.getPersonaState
	once.Do(singleton)
	return PersonaState(Advanced().GetPersonaState())
}

/*
Get player's avatar. Short-cuts to the various avatar functions in Steamworks.
Size is passed as follows:
[codeblock]
• 1 / small avatar
• 2 / medium avatar
• 3 / large avatar
[/codeblock]
Triggers a [signal Steam.avatar_loaded] callback.
[b]Note:[/b] This is a unique function to GodotSteam.
*/
func GetPlayerAvatar(steam_id int) { //gd:Steam.getPlayerAvatar
	once.Do(singleton)
	Advanced().GetPlayerAvatar(int64(2), int64(steam_id))
}

/*
Get player's avatar. Short-cuts to the various avatar functions in Steamworks.
Size is passed as follows:
[codeblock]
• 1 / small avatar
• 2 / medium avatar
• 3 / large avatar
[/codeblock]
Triggers a [signal Steam.avatar_loaded] callback.
[b]Note:[/b] This is a unique function to GodotSteam.
*/
func GetPlayerAvatarOptions(size int, steam_id int) { //gd:Steam.getPlayerAvatar
	once.Do(singleton)
	Advanced().GetPlayerAvatar(int64(size), int64(steam_id))
}

/*
Returns nickname the current user has set for the specified player. Returns NULL if the no nickname has been set for that player.
*/
func GetPlayerNickname(steam_id int) string { //gd:Steam.getPlayerNickname
	once.Do(singleton)
	return string(Advanced().GetPlayerNickname(int64(steam_id)).String())
}

/*
Returns a string property for a user's equipped profile item.
*/
func GetProfileItemPropertyString(steam_id int, item_type CommunityProfileItemType, item_property CommunityProfileItemProperty) string { //gd:Steam.getProfileItemPropertyString
	once.Do(singleton)
	return string(Advanced().GetProfileItemPropertyString(int64(steam_id), item_type, item_property).String())
}

/*
Returns an unsigned integer property for a user's equipped profile item.
*/
func GetProfileItemPropertyInt(steam_id int, item_type CommunityProfileItemType, item_property CommunityProfileItemProperty) int { //gd:Steam.getProfileItemPropertyInt
	once.Do(singleton)
	return int(int(Advanced().GetProfileItemPropertyInt(int64(steam_id), item_type, item_property)))
}

/*
Get list of players user has recently played game with.
The returned array contains a list of:
[codeblock]
┖╴player (dictionary)

	┠╴id (int) as friend Steam ID.
	┠╴name (string)
	┠╴time (int)
	┖╴status (int)

[/codeblock]
[b]Note:[/b] This is a unique function to GodotSteam.
*/
func GetRecentPlayers() []any { //gd:Steam.getRecentPlayers
	once.Do(singleton)
	return []any(gd.ArrayAs[[]any](gd.InternalArray(Advanced().GetRecentPlayers())))
}

/*
Gets a handle to the small (32 x 32px) avatar for the specified user. You can pass in [method Steam.getSteamID] to get the current user's avatar.
Triggers a [signal Steam.avatar_loaded] callback.
A Steam image handle which is used with [method Steam.getImageSize] and [method Steam.getImageRGBA].
[b]Note:[/b] This only works for users that the local user knows about. They will automatically know about their friends, people on leaderboards they've requested, or people in the same source as them (Steam group, chat room, lobby, or game server). If they don't know about them then you must call [method Steam.requestUserInformation] to cache the avatar locally.
*/
func GetSmallFriendAvatar(steam_id int) int { //gd:Steam.getSmallFriendAvatar
	once.Do(singleton)
	return int(int(Advanced().GetSmallFriendAvatar(int64(steam_id))))
}

/*
Get list of friends groups (tags) the user has created. This is not to be confused with Steam groups.
The returned array contains a list of:
[codeblock]
┖╴tags (dictionary)

	┠╴id (int) as friend group ID
	┠╴name (string)
	┖╴members (int)

[/codeblock]
*/
func GetUserFriendsGroups() []any { //gd:Steam.getUserFriendsGroups
	once.Do(singleton)
	return []any(gd.ArrayAs[[]any](gd.InternalArray(Advanced().GetUserFriendsGroups())))
}

/*
If current user is chat restricted, they can't send or receive any text or voice chat messages. The user can't see custom avatars. But the user can be online and send or receive game invites. A chat restricted user cannot add friends or join any groups. Restricted users can still be online and send/receive game invites.
It should be one of the following:
[codeblock]
• 0 / None
• 1 / Unknown
• 2 / Any Chat
• 4 / Voice Chat
• 8 / Group Chat
• 16 / Rating
• 32 / Game Invites
• 64 / Trading
[/codeblock]
*/
func GetUserRestrictions() int { //gd:Steam.getUserRestrictions
	once.Do(singleton)
	return int(int(Advanced().GetUserRestrictions()))
}

/*
Get a list of user's Steam friends; a mix of different Steamworks API friend functions.
The returned array contains a list of:
[codeblock]
┖╴ friends (dictionary)

	┠╴id (int) as friend Steam ID
	┠╴name (string)
	┖╴status (int)

[/codeblock]
[b]Note:[/b] This is a unique function to GodotSteam.
*/
func GetUserSteamFriends() []any { //gd:Steam.getUserSteamFriends
	once.Do(singleton)
	return []any(gd.ArrayAs[[]any](gd.InternalArray(Advanced().GetUserSteamFriends())))
}

/*
Get list of user's Steam groups; a mix of different Steamworks API group functions.
The returned array contains a list of:
[codeblock]
┖╴groups (dictionary)

	┠╴id (int) as group ID
	┠╴name (string)
	┖╴tag (string)

[/codeblock]
[b]Note:[/b] This is a unique function to GodotSteam.
*/
func GetUserSteamGroups() []any { //gd:Steam.getUserSteamGroups
	once.Do(singleton)
	return []any(gd.ArrayAs[[]any](gd.InternalArray(Advanced().GetUserSteamGroups())))
}

/*
After calling [method Steam.requestEquippedProfileItems], you can use this function to check if the user has a type of profile item equipped or not.
[b]Note:[/b] Triggers a [signal Steam.equipped_profile_items] callback.
*/
func HasEquippedProfileItem(steam_id int, friend_flags CommunityProfileItemType) bool { //gd:Steam.hasEquippedProfileItem
	once.Do(singleton)
	return bool(Advanced().HasEquippedProfileItem(int64(steam_id), friend_flags))
}

/*
Returns true if the specified user meets any of the criteria specified in friend_flags:
[codeblock]
• 0x00 / None
• 0x01 / Blocked
• 0x02 / Friendship Requested
• 0x04 / Immediate
• 0x08 / Clan Member
• 0x10 / On Game Server
• 0x80 / Requesting Friendship
• 0x100 / Requesting Info
• 0x200 / Ignored
• 0x400 / Ignored Friend
• 0x0000 / Chat Member
• 0xFFFF / All
[/codeblock]
*/
func HasFriend(steam_id int, friend_flags FriendFlags) bool { //gd:Steam.hasFriend
	once.Do(singleton)
	return bool(Advanced().HasFriend(int64(steam_id), friend_flags))
}

/*
Invites a friend or clan member to the current game using a special invite string. If the target user accepts the invite then the connect_string gets added to the command-line when launching the game. If the game is already running for that user, then they will receive a [signal Steam.join_game_requested] callback with the connect string.
*/
func InviteUserToGame(friend_id int, connect_string string) bool { //gd:Steam.inviteUserToGame
	once.Do(singleton)
	return bool(Advanced().InviteUserToGame(int64(friend_id), String.New(connect_string)))
}

/*
Checks if a user in the Steam group chat room is an admin.
*/
func IsClanChatAdmin(chat_id int, steam_id int) bool { //gd:Steam.isClanChatAdmin
	once.Do(singleton)
	return bool(Advanced().IsClanChatAdmin(int64(chat_id), int64(steam_id)))
}

/*
Checks if the Steam group is public.
*/
func IsClanPublic(clan_id int) bool { //gd:Steam.isClanPublic
	once.Do(singleton)
	return bool(Advanced().IsClanPublic(int64(clan_id)))
}

/*
Checks if the Steam group is an official game group/community hub.
*/
func IsClanOfficialGameGroup(clan_id int) bool { //gd:Steam.isClanOfficialGameGroup
	once.Do(singleton)
	return bool(Advanced().IsClanOfficialGameGroup(int64(clan_id)))
}

/*
Checks if the Steam Group chat room is open in the Steam UI.
*/
func IsClanChatWindowOpenInSteam(chat_id int) bool { //gd:Steam.isClanChatWindowOpenInSteam
	once.Do(singleton)
	return bool(Advanced().IsClanChatWindowOpenInSteam(int64(chat_id)))
}

/*
Checks if the current user is following the specified user.
*/
func IsFollowing(steam_id int) { //gd:Steam.isFollowing
	once.Do(singleton)
	Advanced().IsFollowing(int64(steam_id))
}

/*
Checks if a specified user is in a source (Steam group, chat room, lobby, or game server).
*/
func IsUserInSource(steam_id int, source_id int) bool { //gd:Steam.isUserInSource
	once.Do(singleton)
	return bool(Advanced().IsUserInSource(int64(steam_id), int64(source_id)))
}

/*
Allows the user to join Steam group (clan) chats right within the game. The behavior is somewhat complicated, because the user may or may not be already in the group chat from outside the game or in the overlay. You can use [method Steam.activateGameOverlayToUser] to open the in-game overlay version of the chat.
Triggers a [signal Steam.join_clan_chat_complete] callback.
May additionally trigger the following callbacks:
[codeblock]
┠╴connect_chat_join
┠╴connect_chat_leave
┖╴connect_clan_chat_message
[/codeblock]
*/
func JoinClanChatRoom(clan_id int) { //gd:Steam.joinClanChatRoom
	once.Do(singleton)
	Advanced().JoinClanChatRoom(int64(clan_id))
}

/*
Leaves a Steam group chat that the user has previously entered with [method Steam.joinClanChatRoom].
*/
func LeaveClanChatRoom(clan_id int) bool { //gd:Steam.leaveClanChatRoom
	once.Do(singleton)
	return bool(Advanced().LeaveClanChatRoom(int64(clan_id)))
}

/*
Opens the specified Steam group chat room in the Steam UI.
*/
func OpenClanChatWindowInSteam(chat_id int) bool { //gd:Steam.openClanChatWindowInSteam
	once.Do(singleton)
	return bool(Advanced().OpenClanChatWindowInSteam(int64(chat_id)))
}

/*
Call this before calling [method Steam.activateGameOverlayToWebPage] to have the Steam Overlay Browser block navigations to your specified protocol (scheme) uris and instead dispatch a [signal Steam.overlay_browser_protocol] callback to your game. [method Steam.activateGameOverlayToWebPage] must have been called with 1.
[b]Note:[/b] While this function is in the SDK, it is not listed in the Steamworks docs.
*/
func RegisterProtocolInOverlayBrowser(protocol string) bool { //gd:Steam.registerProtocolInOverlayBrowser
	once.Do(singleton)
	return bool(Advanced().RegisterProtocolInOverlayBrowser(String.New(protocol)))
}

/*
Sends a message to a Steam friend.
*/
func ReplyToFriendMessage(steam_id int, message string) bool { //gd:Steam.replyToFriendMessage
	once.Do(singleton)
	return bool(Advanced().ReplyToFriendMessage(int64(steam_id), String.New(message)))
}

/*
Requests information about a Steam group officers (administrators and moderators).
Triggers a [signal Steam.request_clan_officer_list] callback.
[b]Note:[/b] You can only ask about Steam groups that a user is a member of.
[b]Note:[/b] This won't download avatars for the officers automatically. If no avatar image is available for an officer, then call [method Steam.requestUserInformation] to download the avatar.
*/
func RequestClanOfficerList(clan_id int) { //gd:Steam.requestClanOfficerList
	once.Do(singleton)
	Advanced().RequestClanOfficerList(int64(clan_id))
}

/*
After calling RequestEquippedProfileItems, you can use this function to check if the user has a type of profile item equipped or not.
*/
func RequestEquippedProfileItems(steam_id int) { //gd:Steam.requestEquippedProfileItems
	once.Do(singleton)
	Advanced().RequestEquippedProfileItems(int64(steam_id))
}

/*
Requests Rich Presence data from a specific user. This is used to get the Rich Presence information from a user that is not a friend of the current user, like someone in the same lobby or game server. This function is rate limited, if you call this too frequently for a particular user then it will just immediately post a callback without requesting new data from the server.
Triggers a [signal Steam.friend_rich_presence_update] callback.
*/
func RequestFriendRichPresence(friend_id int) { //gd:Steam.requestFriendRichPresence
	once.Do(singleton)
	Advanced().RequestFriendRichPresence(int64(friend_id))
}

/*
Requests information about a user - persona name and avatar; if require_name_only is set, then the avatar of a user isn't downloaded.
*/
func RequestUserInformation(steam_id int, require_name_only bool) bool { //gd:Steam.requestUserInformation
	once.Do(singleton)
	return bool(Advanced().RequestUserInformation(int64(steam_id), require_name_only))
}

/*
Sends a message to a Steam group chat room.
*/
func SendClanChatMessage(chat_id int, text string) bool { //gd:Steam.sendClanChatMessage
	once.Do(singleton)
	return bool(Advanced().SendClanChatMessage(int64(chat_id), String.New(text)))
}

/*
User is in a game pressing the talk button (will suppress the microphone for all voice comms from the Steam friends UI).
Let Steam know that the user is currently using voice chat in game. This will suppress the microphone for all voice communication in the Steam UI.
*/
func SetInGameVoiceSpeaking(steam_id int, speaking bool) { //gd:Steam.setInGameVoiceSpeaking
	once.Do(singleton)
	Advanced().SetInGameVoiceSpeaking(int64(steam_id), speaking)
}

/*
Listens for Steam friends chat messages. You can then show these chats inline in the game. For example with a Blizzard style chat message system or the chat system in Data 2. After enabling this you will receive [signal Steam.connected_friend_chat_message] callbacks when ever the user receives a chat message. You can get the actual message data from this callback with [method Steam.getFriendMessage]. You can send messages with [method Steam.replyToFriendMessage].
Triggers a [signal Steam.connected_friend_chat_message] callback.
*/
func SetListenForFriendsMessages(intercept bool) bool { //gd:Steam.setListenForFriendsMessages
	once.Do(singleton)
	return bool(Advanced().SetListenForFriendsMessages(intercept))
}

/*
Sets the current user's persona name, stores it on the server and publishes the changes to all friends who are online. Changes take place locally immediately, and a [signal Steam.persona_state_change] callback is posted, presuming success. If the name change fails to happen on the server, then an additional [signal Steam.persona_state_change] callback will be posted to change the name back, in addition to the final result available in the call result.
Triggers a [signal Steam.name_changed] callback.
*/
func SetPersonaName(name string) { //gd:Steam.setPersonaName
	once.Do(singleton)
	Advanced().SetPersonaName(String.New(name))
}

/*
Set player as 'Played With' for game.
[b]Note:[/b] The current user must be in game with the other player for the association to work.
*/
func SetPlayedWith(steam_id int) { //gd:Steam.setPlayedWith
	once.Do(singleton)
	Advanced().SetPlayedWith(int64(steam_id))
}

/*
Sets a Rich Presence key/value for the current user that is automatically shared to all friends playing the same game. Each user can have up to 20 keys set as defined by k_cchMaxRichPresenceKeys. There are two special keys used for viewing/joining games:
[b]status[/b] - A UTF-8 string that will show up in the 'view game info' dialog in the Steam friends list.
[b]connect[/b] - A UTF-8 string that contains the command-line for how a friend can connect to a game. This enables the 'join game' button in the 'view game info' dialog, in the steam friends list right click menu, and on the players Steam community profile. Be sure your app implements [method Steam.getLaunchCommandLine] so you can disable the popup warning when launched via a command line.
There are three additional special keys used by the new Steam Chat:
[b]steam_display[/b] - Names a rich presence localization token that will be displayed in the viewing user's selected language in the Steam client UI. See Rich Presence Localization for more info, including a link to a page for testing this rich presence data. If steam_display is not set to a valid localization tag, then rich presence will not be displayed in the Steam client.
[b]steam_player_group[/b] - When set, indicates to the Steam client that the player is a member of a particular group. Players in the same group may be organized together in various places in the Steam UI. This string could identify a party, a server, or whatever grouping is relevant for your game. The string itself is not displayed to users.
[b]steam_player_group_size[/b] - When set, indicates the total number of players in the steam_player_group. The Steam client may use this number to display additional information about a group when all of the members are not part of a user's friends list. (For example, "Bob, Pete, and 4 more".)
You can clear all of the keys for the current user with [method Steam.clearRichPresence]. To get rich presence keys for friends use [method Steam.getFriendRichPresence].
*/
func SetRichPresence(key string, value string) bool { //gd:Steam.setRichPresence
	once.Do(singleton)
	return bool(Advanced().SetRichPresence(String.New(key), String.New(value)))
}

/*
A keyname and a list of comma separated values: one of which is must be found in order for the match to qualify; fails if a search is currently in progress.
*/
func AddGameSearchParams(key string, values string) int { //gd:Steam.addGameSearchParams
	once.Do(singleton)
	return int(int(Advanced().AddGameSearchParams(String.New(key), String.New(values))))
}

/*
All players in lobby enter the queue and await a [signal Steam.search_for_game_progress] callback. Fails if another search is currently in progress. If not the owner of the lobby or search already in progress this call fails. Periodic callbacks will be sent as queue time estimates change.
[b]Note:[/b] The [signal Steam.search_for_game_progress] callback does not seem to exist in the SDK anywhere.
*/
func SearchForGameWithLobby(lobby_id int, player_min int, player_max int) int { //gd:Steam.searchForGameWithLobby
	once.Do(singleton)
	return int(int(Advanced().SearchForGameWithLobby(int64(lobby_id), int64(player_min), int64(player_max))))
}

/*
User enter the queue and await a [signal Steam.search_for_game_progress] callback. fails if another search is currently in progress. Periodic callbacks will be sent as queue time estimates change.
[b]Note:[/b] The [signal Steam.search_for_game_progress] callback does not seem to exist in the SDK anywhere.
*/
func SearchForGameSolo(player_min int, player_max int) int { //gd:Steam.searchForGameSolo
	once.Do(singleton)
	return int(int(Advanced().SearchForGameSolo(int64(player_min), int64(player_max))))
}

/*
After receiving [signal Steam.search_for_game_result], accept or decline the game. Multiple [signal Steam.search_for_game_result] will follow as players accept game until the host starts or cancels the game.
[b]Note:[/b] the [signal Steam.search_for_game_progress] callback does not seem to exist in the SDK anywhere.
*/
func AcceptGame() int { //gd:Steam.acceptGame
	once.Do(singleton)
	return int(int(Advanced().AcceptGame()))
}

/*
After receiving [signal Steam.search_for_game_result], accept or decline the game. Multiple [signal Steam.search_for_game_result] will follow as players accept game until the host starts or cancels the game.
[b]Note:[/b] The [signal Steam.search_for_game_progress] callback does not seem to exist in the SDK anywhere.
*/
func DeclineGame() int { //gd:Steam.declineGame
	once.Do(singleton)
	return int(int(Advanced().DeclineGame()))
}

/*
After receiving GameStartedByHostCallback_t get connection details to server.
[b]Note:[/b] The GameStartedByHostCallback_t callback does not seem to exist in the SDK anywhere.
*/
func RetrieveConnectionDetails(host_id int) string { //gd:Steam.retrieveConnectionDetails
	once.Do(singleton)
	return string(Advanced().RetrieveConnectionDetails(int64(host_id)).String())
}

/*
Leaves queue if still waiting.
*/
func EndGameSearch() int { //gd:Steam.endGameSearch
	once.Do(singleton)
	return int(int(Advanced().EndGameSearch()))
}

/*
A keyname and a list of comma separated values: all the values you allow.
*/
func SetGameHostParams(key string, value string) int { //gd:Steam.setGameHostParams
	once.Do(singleton)
	return int(int(Advanced().SetGameHostParams(String.New(key), String.New(value))))
}

/*
Set connection details for players once game is found so they can connect to this server.
*/
func SetConnectionDetails(details string, connection_details int) int { //gd:Steam.setConnectionDetails
	once.Do(singleton)
	return int(int(Advanced().SetConnectionDetails(String.New(details), int64(connection_details))))
}

/*
Mark server as available for more players with player_min, player_max desired. Accept no lobbies with player-count greater than max_team_size.
*/
func RequestPlayersForGame(player_min int, player_max int, max_team_size int) int { //gd:Steam.requestPlayersForGame
	once.Do(singleton)
	return int(int(Advanced().RequestPlayersForGame(int64(player_min), int64(player_max), int64(max_team_size))))
}

/*
Accept the player list and release connection details to players.
*/
func HostConfirmGameStart(game_id int) int { //gd:Steam.hostConfirmGameStart
	once.Do(singleton)
	return int(int(Advanced().HostConfirmGameStart(int64(game_id))))
}

/*
Cancel request and leave the pool of game hosts looking for players.
*/
func CancelRequestPlayersForGame() int { //gd:Steam.cancelRequestPlayersForGame
	once.Do(singleton)
	return int(int(Advanced().CancelRequestPlayersForGame()))
}

/*
Submit a result for one player; does not end the game. game_id continues to describe this game.
*/
func SubmitPlayerResult(game_id int, player_id int, player_result PlayerResult) int { //gd:Steam.submitPlayerResult
	once.Do(singleton)
	return int(int(Advanced().SubmitPlayerResult(int64(game_id), int64(player_id), player_result)))
}

/*
Ends the game. No further [method Steam.submitPlayerResult] for game_id will be accepted.
*/
func EndGame(game_id int) int { //gd:Steam.endGame
	once.Do(singleton)
	return int(int(Advanced().EndGame(int64(game_id))))
}

/*
Add a header to any HTTP requests from this browser. A full list of standard request fields are available here on Wikipedia.
If no handle is passed, GodotSteam will use the internal one.
*/
func AddHeader(key string, value string, this_handle int) { //gd:Steam.addHeader
	once.Do(singleton)
	Advanced().AddHeader(String.New(key), String.New(value), int64(this_handle))
}

/*
Add a header to any HTTP requests from this browser. A full list of standard request fields are available here on Wikipedia.
If no handle is passed, GodotSteam will use the internal one.
*/
func AddHeaderOptions(key string, value string, this_handle int) { //gd:Steam.addHeader
	once.Do(singleton)
	Advanced().AddHeader(String.New(key), String.New(value), int64(this_handle))
}

/*
Sets whether a pending load is allowed or if it should be canceled. You can use this feature to limit the valid pages allowed in your HTML surface.
If no handle is passed, GodotSteam will use the internal one.
[b]Note:[/b] You must call this in response to a [signal Steam.html_start_request] callback.
*/
func AllowStartRequest(allowed bool, this_handle int) { //gd:Steam.allowStartRequest
	once.Do(singleton)
	Advanced().AllowStartRequest(allowed, int64(this_handle))
}

/*
Sets whether a pending load is allowed or if it should be canceled. You can use this feature to limit the valid pages allowed in your HTML surface.
If no handle is passed, GodotSteam will use the internal one.
[b]Note:[/b] You must call this in response to a [signal Steam.html_start_request] callback.
*/
func AllowStartRequestOptions(allowed bool, this_handle int) { //gd:Steam.allowStartRequest
	once.Do(singleton)
	Advanced().AllowStartRequest(allowed, int64(this_handle))
}

/*
Copy the currently selected text from the current page in an HTML surface into the local clipboard.
If no handle is passed, GodotSteam will use the internal one.
*/
func CopyToClipboard(this_handle int) { //gd:Steam.copyToClipboard
	once.Do(singleton)
	Advanced().CopyToClipboard(int64(this_handle))
}

/*
Copy the currently selected text from the current page in an HTML surface into the local clipboard.
If no handle is passed, GodotSteam will use the internal one.
*/
func CopyToClipboardOptions(this_handle int) { //gd:Steam.copyToClipboard
	once.Do(singleton)
	Advanced().CopyToClipboard(int64(this_handle))
}

/*
Create a browser object for displaying of an HTML page.
If no handle is passed, GodotSteam will use the internal one.
[b]Note:[/b] You must call [method Steam.removeBrowser] when you are done using this browser to free up the resources associated with it. Failing to do so will result in a memory leak.
*/
func CreateBrowser(user_agent string, user_css string) { //gd:Steam.createBrowser
	once.Do(singleton)
	Advanced().CreateBrowser(String.New(user_agent), String.New(user_css))
}

/*
Create a browser object for displaying of an HTML page.
If no handle is passed, GodotSteam will use the internal one.
[b]Note:[/b] You must call [method Steam.removeBrowser] when you are done using this browser to free up the resources associated with it. Failing to do so will result in a memory leak.
*/
func CreateBrowserOptions(user_agent string, user_css string) { //gd:Steam.createBrowser
	once.Do(singleton)
	Advanced().CreateBrowser(String.New(user_agent), String.New(user_css))
}

/*
Run a javascript script in the currently loaded page.
*/
func ExecuteJavascript(script string, this_handle int) { //gd:Steam.executeJavascript
	once.Do(singleton)
	Advanced().ExecuteJavascript(String.New(script), int64(this_handle))
}

/*
Run a javascript script in the currently loaded page.
*/
func ExecuteJavascriptOptions(script string, this_handle int) { //gd:Steam.executeJavascript
	once.Do(singleton)
	Advanced().ExecuteJavascript(String.New(script), int64(this_handle))
}

/*
Find a string in the current page of an HTML surface. This is the equivalent of "ctrl+f" in your browser of choice. It will highlight all of the matching strings. You should call [method Steam.stopFind] when the input string has changed or you want to stop searching.
Triggers a [signal Steam.html_search_results] callback.
*/
func Find(search string, currently_in_find bool, reverse bool, this_handle int) { //gd:Steam.find
	once.Do(singleton)
	Advanced().Find(String.New(search), currently_in_find, reverse, int64(this_handle))
}

/*
Find a string in the current page of an HTML surface. This is the equivalent of "ctrl+f" in your browser of choice. It will highlight all of the matching strings. You should call [method Steam.stopFind] when the input string has changed or you want to stop searching.
Triggers a [signal Steam.html_search_results] callback.
*/
func FindOptions(search string, currently_in_find bool, reverse bool, this_handle int) { //gd:Steam.find
	once.Do(singleton)
	Advanced().Find(String.New(search), currently_in_find, reverse, int64(this_handle))
}

/*
Retrieves details about a link at a specific position on the current page in an HTML surface.
Triggers a [signal Steam.html_link_at_position] callback.
*/
func GetLinkAtPosition(x int, y int, this_handle int) { //gd:Steam.getLinkAtPosition
	once.Do(singleton)
	Advanced().GetLinkAtPosition(int64(x), int64(y), int64(this_handle))
}

/*
Retrieves details about a link at a specific position on the current page in an HTML surface.
Triggers a [signal Steam.html_link_at_position] callback.
*/
func GetLinkAtPositionOptions(x int, y int, this_handle int) { //gd:Steam.getLinkAtPosition
	once.Do(singleton)
	Advanced().GetLinkAtPosition(int64(x), int64(y), int64(this_handle))
}

/*
Navigate back in the page history.
*/
func GoBack(this_handle int) { //gd:Steam.goBack
	once.Do(singleton)
	Advanced().GoBack(int64(this_handle))
}

/*
Navigate back in the page history.
*/
func GoBackOptions(this_handle int) { //gd:Steam.goBack
	once.Do(singleton)
	Advanced().GoBack(int64(this_handle))
}

/*
Navigate forward in the page history.
*/
func GoForward(this_handle int) { //gd:Steam.goForward
	once.Do(singleton)
	Advanced().GoForward(int64(this_handle))
}

/*
Navigate forward in the page history.
*/
func GoForwardOptions(this_handle int) { //gd:Steam.goForward
	once.Do(singleton)
	Advanced().GoForward(int64(this_handle))
}

/*
Initializes the HTML Surface API. This must be called prior to using any other functions in this interface. You must call [method Steam.htmlShutdown] when you are done using the interface to free up the resources associated with it. Failing to do so will result in a memory leak.
*/
func HtmlInit() bool { //gd:Steam.htmlInit
	once.Do(singleton)
	return bool(Advanced().HtmlInit())
}

/*
Allows you to react to a page wanting to open a javascript modal dialog notification.
[b]Note:[/b] You must call this in response to [signal Steam.html_js_alert] and [signal Steam.html_js_confirm] callbacks.
*/
func JsDialogResponse(result bool, this_handle int) { //gd:Steam.jsDialogResponse
	once.Do(singleton)
	Advanced().JsDialogResponse(result, int64(this_handle))
}

/*
Allows you to react to a page wanting to open a javascript modal dialog notification.
[b]Note:[/b] You must call this in response to [signal Steam.html_js_alert] and [signal Steam.html_js_confirm] callbacks.
*/
func JsDialogResponseOptions(result bool, this_handle int) { //gd:Steam.jsDialogResponse
	once.Do(singleton)
	Advanced().JsDialogResponse(result, int64(this_handle))
}

/*
unicode_char is the unicode character point for this keypress (and potentially multiple chars per press).
*/
func KeyChar(unicode_char int, key_modifiers HTMLKeyModifiers, this_handle int) { //gd:Steam.keyChar
	once.Do(singleton)
	Advanced().KeyChar(int64(unicode_char), key_modifiers, int64(this_handle))
}

/*
unicode_char is the unicode character point for this keypress (and potentially multiple chars per press).
*/
func KeyCharOptions(unicode_char int, key_modifiers HTMLKeyModifiers, this_handle int) { //gd:Steam.keyChar
	once.Do(singleton)
	Advanced().KeyChar(int64(unicode_char), key_modifiers, int64(this_handle))
}

/*
Keyboard interactions, native keycode is the virtual key code value from your OS.
*/
func KeyDown(native_key_code int, key_modifiers HTMLKeyModifiers, this_handle int) { //gd:Steam.keyDown
	once.Do(singleton)
	Advanced().KeyDown(int64(native_key_code), key_modifiers, int64(this_handle))
}

/*
Keyboard interactions, native keycode is the virtual key code value from your OS.
*/
func KeyDownOptions(native_key_code int, key_modifiers HTMLKeyModifiers, this_handle int) { //gd:Steam.keyDown
	once.Do(singleton)
	Advanced().KeyDown(int64(native_key_code), key_modifiers, int64(this_handle))
}

/*
Keyboard interactions, native keycode is the virtual key code value from your OS.
*/
func KeyUp(native_key_code int, key_modifiers HTMLKeyModifiers, this_handle int) { //gd:Steam.keyUp
	once.Do(singleton)
	Advanced().KeyUp(int64(native_key_code), key_modifiers, int64(this_handle))
}

/*
Keyboard interactions, native keycode is the virtual key code value from your OS.
*/
func KeyUpOptions(native_key_code int, key_modifiers HTMLKeyModifiers, this_handle int) { //gd:Steam.keyUp
	once.Do(singleton)
	Advanced().KeyUp(int64(native_key_code), key_modifiers, int64(this_handle))
}

/*
Navigate to a specified URL. If you send POST data with post_data then the data should be formatted as: name1=value1&name2=value2. You can load any URI scheme supported by Chromium Embedded Framework including but not limited to: http://, https://, ftp://, and file:///. If no scheme is specified then http:// is used.
Triggers a [signal Steam.html_start_request] callback.
*/
func LoadURL(url string, post_data string, this_handle int) { //gd:Steam.loadURL
	once.Do(singleton)
	Advanced().LoadURL(String.New(url), String.New(post_data), int64(this_handle))
}

/*
Navigate to a specified URL. If you send POST data with post_data then the data should be formatted as: name1=value1&name2=value2. You can load any URI scheme supported by Chromium Embedded Framework including but not limited to: http://, https://, ftp://, and file:///. If no scheme is specified then http:// is used.
Triggers a [signal Steam.html_start_request] callback.
*/
func LoadURLOptions(url string, post_data string, this_handle int) { //gd:Steam.loadURL
	once.Do(singleton)
	Advanced().LoadURL(String.New(url), String.New(post_data), int64(this_handle))
}

/*
Tells an HTML surface that a mouse button has been double clicked. The click will occur where the surface thinks the mouse is based on the last call to [method Steam.mouseMove].
*/
func MouseDoubleClick(mouse_button HTMLMouseButton, this_handle int) { //gd:Steam.mouseDoubleClick
	once.Do(singleton)
	Advanced().MouseDoubleClick(mouse_button, int64(this_handle))
}

/*
Tells an HTML surface that a mouse button has been double clicked. The click will occur where the surface thinks the mouse is based on the last call to [method Steam.mouseMove].
*/
func MouseDoubleClickOptions(mouse_button HTMLMouseButton, this_handle int) { //gd:Steam.mouseDoubleClick
	once.Do(singleton)
	Advanced().MouseDoubleClick(mouse_button, int64(this_handle))
}

/*
Tells an HTML surface that a mouse button has been pressed. The click will occur where the surface thinks the mouse is based on the last call to [method Steam.mouseMove].
*/
func MouseDown(mouse_button HTMLMouseButton, this_handle int) { //gd:Steam.mouseDown
	once.Do(singleton)
	Advanced().MouseDown(mouse_button, int64(this_handle))
}

/*
Tells an HTML surface that a mouse button has been pressed. The click will occur where the surface thinks the mouse is based on the last call to [method Steam.mouseMove].
*/
func MouseDownOptions(mouse_button HTMLMouseButton, this_handle int) { //gd:Steam.mouseDown
	once.Do(singleton)
	Advanced().MouseDown(mouse_button, int64(this_handle))
}

/*
Tells an HTML surface where the mouse is.
*/
func MouseMove(x int, y int, this_handle int) { //gd:Steam.mouseMove
	once.Do(singleton)
	Advanced().MouseMove(int64(x), int64(y), int64(this_handle))
}

/*
Tells an HTML surface where the mouse is.
*/
func MouseMoveOptions(x int, y int, this_handle int) { //gd:Steam.mouseMove
	once.Do(singleton)
	Advanced().MouseMove(int64(x), int64(y), int64(this_handle))
}

/*
Tells an HTML surface that a mouse button has been released. The click will occur where the surface thinks the mouse is based on the last call to [method Steam.mouseMove].
*/
func MouseUp(mouse_button HTMLMouseButton, this_handle int) { //gd:Steam.mouseUp
	once.Do(singleton)
	Advanced().MouseUp(mouse_button, int64(this_handle))
}

/*
Tells an HTML surface that a mouse button has been released. The click will occur where the surface thinks the mouse is based on the last call to [method Steam.mouseMove].
*/
func MouseUpOptions(mouse_button HTMLMouseButton, this_handle int) { //gd:Steam.mouseUp
	once.Do(singleton)
	Advanced().MouseUp(mouse_button, int64(this_handle))
}

/*
Tells an HTML surface that the mouse wheel has moved.
*/
func MouseWheel(delta int, this_handle int) { //gd:Steam.mouseWheel
	once.Do(singleton)
	Advanced().MouseWheel(int64(delta), int64(this_handle))
}

/*
Tells an HTML surface that the mouse wheel has moved.
*/
func MouseWheelOptions(delta int, this_handle int) { //gd:Steam.mouseWheel
	once.Do(singleton)
	Advanced().MouseWheel(int64(delta), int64(this_handle))
}

/*
Paste from the local clipboard to the current page in an HTML surface.
*/
func PasteFromClipboard(this_handle int) { //gd:Steam.pasteFromClipboard
	once.Do(singleton)
	Advanced().PasteFromClipboard(int64(this_handle))
}

/*
Paste from the local clipboard to the current page in an HTML surface.
*/
func PasteFromClipboardOptions(this_handle int) { //gd:Steam.pasteFromClipboard
	once.Do(singleton)
	Advanced().PasteFromClipboard(int64(this_handle))
}

/*
Refreshes the current page. The reload will most likely hit the local cache instead of going over the network. This is equivalent to F5 or Ctrl+R in your browser of choice.
*/
func Reload(this_handle int) { //gd:Steam.reload
	once.Do(singleton)
	Advanced().Reload(int64(this_handle))
}

/*
Refreshes the current page. The reload will most likely hit the local cache instead of going over the network. This is equivalent to F5 or Ctrl+R in your browser of choice.
*/
func ReloadOptions(this_handle int) { //gd:Steam.reload
	once.Do(singleton)
	Advanced().Reload(int64(this_handle))
}

/*
You must call this when you are done with an HTML surface, freeing the resources associated with it. Failing to call this will result in a memory leak.
*/
func RemoveBrowser(this_handle int) { //gd:Steam.removeBrowser
	once.Do(singleton)
	Advanced().RemoveBrowser(int64(this_handle))
}

/*
You must call this when you are done with an HTML surface, freeing the resources associated with it. Failing to call this will result in a memory leak.
*/
func RemoveBrowserOptions(this_handle int) { //gd:Steam.removeBrowser
	once.Do(singleton)
	Advanced().RemoveBrowser(int64(this_handle))
}

/*
Enable/disable low-resource background mode, where Javascript and repaint timers are throttled, resources are more aggressively purged from memory, and audio/video elements are paused. When background mode is enabled, all HTML5 video and audio objects will execute ".pause()" and gain the property "._steam_background_paused = 1". When background mode is disabled, any video or audio objects with that property will resume with ".play()".
*/
func SetBackgroundMode(background_mode bool, this_handle int) { //gd:Steam.setBackgroundMode
	once.Do(singleton)
	Advanced().SetBackgroundMode(background_mode, int64(this_handle))
}

/*
Enable/disable low-resource background mode, where Javascript and repaint timers are throttled, resources are more aggressively purged from memory, and audio/video elements are paused. When background mode is enabled, all HTML5 video and audio objects will execute ".pause()" and gain the property "._steam_background_paused = 1". When background mode is disabled, any video or audio objects with that property will resume with ".play()".
*/
func SetBackgroundModeOptions(background_mode bool, this_handle int) { //gd:Steam.setBackgroundMode
	once.Do(singleton)
	Advanced().SetBackgroundMode(background_mode, int64(this_handle))
}

/*
Set a webcookie for a specific hostname. You can read more about the specifics of setting cookies here on Wikipedia.
*/
func SetCookie(hostname string, key string, value string, path string, expires int, secure bool, http_only bool) { //gd:Steam.setCookie
	once.Do(singleton)
	Advanced().SetCookie(String.New(hostname), String.New(key), String.New(value), String.New(path), int64(expires), secure, http_only)
}

/*
Scroll the current page horizontally.
Triggers a [signal Steam.html_horizontal_scroll] callback.
*/
func SetHorizontalScroll(absolute_pixel_scroll int, this_handle int) { //gd:Steam.setHorizontalScroll
	once.Do(singleton)
	Advanced().SetHorizontalScroll(int64(absolute_pixel_scroll), int64(this_handle))
}

/*
Scroll the current page horizontally.
Triggers a [signal Steam.html_horizontal_scroll] callback.
*/
func SetHorizontalScrollOptions(absolute_pixel_scroll int, this_handle int) { //gd:Steam.setHorizontalScroll
	once.Do(singleton)
	Advanced().SetHorizontalScroll(int64(absolute_pixel_scroll), int64(this_handle))
}

/*
Tell a HTML surface if it has key focus currently, controls showing the I-beam cursor in text controls amongst other things.
*/
func SetKeyFocus(has_key_focus bool, this_handle int) { //gd:Steam.setKeyFocus
	once.Do(singleton)
	Advanced().SetKeyFocus(has_key_focus, int64(this_handle))
}

/*
Tell a HTML surface if it has key focus currently, controls showing the I-beam cursor in text controls amongst other things.
*/
func SetKeyFocusOptions(has_key_focus bool, this_handle int) { //gd:Steam.setKeyFocus
	once.Do(singleton)
	Advanced().SetKeyFocus(has_key_focus, int64(this_handle))
}

/*
Zoom the current page in an HTML surface. The current scale factor is available from HTML_NeedsPaint_t.flPageScale, HTML_HorizontalScroll_t.flPageScale, and HTML_VerticalScroll_t.flPageScale.
*/
func SetPageScaleFactor(zoom Float.X, point_x int, point_y int, this_handle int) { //gd:Steam.setPageScaleFactor
	once.Do(singleton)
	Advanced().SetPageScaleFactor(float64(zoom), int64(point_x), int64(point_y), int64(this_handle))
}

/*
Zoom the current page in an HTML surface. The current scale factor is available from HTML_NeedsPaint_t.flPageScale, HTML_HorizontalScroll_t.flPageScale, and HTML_VerticalScroll_t.flPageScale.
*/
func SetPageScaleFactorOptions(zoom Float.X, point_x int, point_y int, this_handle int) { //gd:Steam.setPageScaleFactor
	once.Do(singleton)
	Advanced().SetPageScaleFactor(float64(zoom), int64(point_x), int64(point_y), int64(this_handle))
}

/*
Sets the display size of a surface in pixels.
*/
func SetSize(width int, height int, this_handle int) { //gd:Steam.setSize
	once.Do(singleton)
	Advanced().SetSize(int64(width), int64(height), int64(this_handle))
}

/*
Sets the display size of a surface in pixels.
*/
func SetSizeOptions(width int, height int, this_handle int) { //gd:Steam.setSize
	once.Do(singleton)
	Advanced().SetSize(int64(width), int64(height), int64(this_handle))
}

/*
Scroll the current page vertically.
Triggers a [signal Steam.html_vertical_scroll] callback.
*/
func SetVerticalScroll(absolute_pixel_scroll int, this_handle int) { //gd:Steam.setVerticalScroll
	once.Do(singleton)
	Advanced().SetVerticalScroll(int64(absolute_pixel_scroll), int64(this_handle))
}

/*
Scroll the current page vertically.
Triggers a [signal Steam.html_vertical_scroll] callback.
*/
func SetVerticalScrollOptions(absolute_pixel_scroll int, this_handle int) { //gd:Steam.setVerticalScroll
	once.Do(singleton)
	Advanced().SetVerticalScroll(int64(absolute_pixel_scroll), int64(this_handle))
}

/*
Shutdown the ISteamHTMLSurface interface, releasing the memory and handles. You must call this when you are done using this interface to prevent memory and handle leaks. After calling this then all of the functions provided in this interface will fail until you call htmlInit to reinitialize again.
*/
func HtmlShutdown() bool { //gd:Steam.htmlShutdown
	once.Do(singleton)
	return bool(Advanced().HtmlShutdown())
}

/*
Cancel a currently running find.
*/
func StopFind(this_handle int) { //gd:Steam.stopFind
	once.Do(singleton)
	Advanced().StopFind(int64(this_handle))
}

/*
Cancel a currently running find.
*/
func StopFindOptions(this_handle int) { //gd:Steam.stopFind
	once.Do(singleton)
	Advanced().StopFind(int64(this_handle))
}

/*
Stop the load of the current HTML page.
*/
func StopLoad(this_handle int) { //gd:Steam.stopLoad
	once.Do(singleton)
	Advanced().StopLoad(int64(this_handle))
}

/*
Stop the load of the current HTML page.
*/
func StopLoadOptions(this_handle int) { //gd:Steam.stopLoad
	once.Do(singleton)
	Advanced().StopLoad(int64(this_handle))
}

/*
Open the current pages HTML source code in default local text editor, used for debugging.
*/
func ViewSource(this_handle int) { //gd:Steam.viewSource
	once.Do(singleton)
	Advanced().ViewSource(int64(this_handle))
}

/*
Open the current pages HTML source code in default local text editor, used for debugging.
*/
func ViewSourceOptions(this_handle int) { //gd:Steam.viewSource
	once.Do(singleton)
	Advanced().ViewSource(int64(this_handle))
}

/*
Creates a cookie container to store cookies during the lifetime of the process. This API is just for during process lifetime, after Steam restarts no cookies are persisted and you have no way to access the cookie container across repeat executions of your process.
If allow_responses_to_modify is true then any response to your requests using this cookie container may add new cookies to the container which may be transmitted with future requests. Otherwise, if it's false then only cookies you explicitly set will be sent.
You can associate the cookie container with a http request by using [method Steam.setHTTPRequestCookieContainer], and you can set a cookie using [method Steam.setCookie]. Don't forget to free the container when you're done with it to prevent leaking memory by calling [method Steam.releaseCookieContainer]!
*/
func CreateCookieContainer(allow_response_to_modify bool) int { //gd:Steam.createCookieContainer
	once.Do(singleton)
	return int(int(Advanced().CreateCookieContainer(allow_response_to_modify)))
}

/*
Initializes a new HTTP request. Requires the method such as GET or POST and the absolute URL for the request. Both http and https are supported, so this string must start with "http://" or "https://" and should look like "http://store.steampowered.com/app/10/" or similar. This call returns a handle that you can use to make further calls to setup and then send the HTTP request with [method Steam.sendHTTPRequest] or [method Steam.sendHTTPRequestAndStreamResponse]. Don't forget to free the HTTP request when you're done with it to prevent leaking memory by calling [method Steam.releaseHTTPRequest].
*/
func CreateHTTPRequest(request_method HTTPMethod, absolute_url string) int { //gd:Steam.createHTTPRequest
	once.Do(singleton)
	return int(int(Advanced().CreateHTTPRequest(request_method, String.New(absolute_url))))
}

/*
Defers a request which has already been sent by moving it at the back of the queue.
*/
func DeferHTTPRequest(request_handle int) bool { //gd:Steam.deferHTTPRequest
	once.Do(singleton)
	return bool(Advanced().DeferHTTPRequest(int64(request_handle)))
}

/*
Gets progress on downloading the body for the request. This will be zero unless a response header has already been received which included a content-length field. For responses that contain no content-length it will report zero for the duration of the request as the size is unknown until the connection closes.
*/
func GetHTTPDownloadProgressPct(request_handle int) Float.X { //gd:Steam.getHTTPDownloadProgressPct
	once.Do(singleton)
	return Float.X(Float.X(Advanced().GetHTTPDownloadProgressPct(int64(request_handle))))
}

/*
Check if the reason the request failed was because we timed it out (rather than some harder failure). You'll want to call this within the context of [signal Steam.http_request_completed] callback if request_success is false.
*/
func GetHTTPRequestWasTimedOut(request_handle int) bool { //gd:Steam.getHTTPRequestWasTimedOut
	once.Do(singleton)
	return bool(Advanced().GetHTTPRequestWasTimedOut(int64(request_handle)))
}

/*
Gets the body data from an HTTP response. This must be called after the HTTP request has completed and returned the HTTP response via the http_request_completed call result associated with this request handle. You should first call [method Steam.getHTTPResponseBodySize] or use the body_size variable provided in the call result, you can then allocate a buffer with that size to pass into this function. This is only for HTTP requests which were sent with [method Steam.sendHTTPRequest]. Use [method Steam.getHTTPStreamingResponseBodyData] if you're using streaming HTTP requests via [method Steam.sendHTTPRequestAndStreamResponse].
*/
func GetHTTPResponseBodyData(request_handle int, buffer_size int) []byte { //gd:Steam.getHTTPResponseBodyData
	once.Do(singleton)
	return []byte(Advanced().GetHTTPResponseBodyData(int64(request_handle), int64(buffer_size)).Bytes())
}

/*
Gets the size of the body data from an HTTP response. This must be called after the HTTP request has completed and returned the HTTP response via the [signal Steam.http_request_completed] or [signal Steam.http_request_data_received] associated with this request handle. If this returns successfully, then you can allocate a buffer with the provided size to fill with the data obtained from [method Steam.getHTTPResponseBodyData] or [method Steam.getHTTPStreamingResponseBodyData].
*/
func GetHTTPResponseBodySize(request_handle int) int { //gd:Steam.getHTTPResponseBodySize
	once.Do(singleton)
	return int(int(Advanced().GetHTTPResponseBodySize(int64(request_handle))))
}

/*
Checks if a header is present in an HTTP response and returns its size. This must be called after the HTTP request has completed and returned the HTTP response via the [signal Steam.http_request_completed] call result associated with this request handle. If the response header exists in the response, then you can allocate a correctly sized buffer to get the associated value with [method Steam.getHTTPResponseHeaderValue]. Here is a list of standard response header names on Wikipedia.
*/
func GetHTTPResponseHeaderSize(request_handle int, header_name string) int { //gd:Steam.getHTTPResponseHeaderSize
	once.Do(singleton)
	return int(int(Advanced().GetHTTPResponseHeaderSize(int64(request_handle), String.New(header_name))))
}

/*
Gets a header value from an HTTP response. This must be called after the HTTP request has completed and returned the HTTP response via the [signal Steam.http_request_completed] call result associated with this request handle. You should first call [method Steam.getHTTPResponseHeaderSize] to check for the presence of the header and to get the size. You can then allocate a buffer with that size and pass it into this function. Here is a list of standard response header names on Wikipedia.
*/
func GetHTTPResponseHeaderValue(request_handle int, header_name string, buffer_size int) []byte { //gd:Steam.getHTTPResponseHeaderValue
	once.Do(singleton)
	return []byte(Advanced().GetHTTPResponseHeaderValue(int64(request_handle), String.New(header_name), int64(buffer_size)).Bytes())
}

/*
Gets the body data from a streaming HTTP response. This must be called after data is received from a streaming HTTP request via the [signal Steam.http_request_completed] callback associated with this request handle. Typically you'll want to allocate a buffer associated with the request handle using the Content-Length HTTP response field to receive the total size of the data when you receive the header via [signal Steam.http_request_headers_received]. You can then append data to that buffer as it comes in. This is only for streaming HTTP requests which were sent with [method Steam.sendHTTPRequestAndStreamResponse]. Use [method Steam.getHTTPResponseBodyData] if you're using [method Steam.sendHTTPRequest].
*/
func GetHTTPStreamingResponseBodyData(request_handle int, offset int, buffer_size int) []byte { //gd:Steam.getHTTPStreamingResponseBodyData
	once.Do(singleton)
	return []byte(Advanced().GetHTTPStreamingResponseBodyData(int64(request_handle), int64(offset), int64(buffer_size)).Bytes())
}

/*
Prioritizes a request which has already been sent by moving it at the front of the queue.
*/
func PrioritizeHTTPRequest(request_handle int) bool { //gd:Steam.prioritizeHTTPRequest
	once.Do(singleton)
	return bool(Advanced().PrioritizeHTTPRequest(int64(request_handle)))
}

/*
Releases a cookie container, freeing the memory allocated within Steam. You must call this when you are done using each HTTP cookie container handle that you obtained via [method Steam.createCookieContainer]!
*/
func ReleaseCookieContainer(cookie_handle int) bool { //gd:Steam.releaseCookieContainer
	once.Do(singleton)
	return bool(Advanced().ReleaseCookieContainer(int64(cookie_handle)))
}

/*
Releases an HTTP request handle, freeing the memory allocated within Steam. You must call this when you are done using each HTTP request handle that you obtained via [method Steam.createHTTPRequest]!
*/
func ReleaseHTTPRequest(request_handle int) bool { //gd:Steam.releaseHTTPRequest
	once.Do(singleton)
	return bool(Advanced().ReleaseHTTPRequest(int64(request_handle)))
}

/*
Sends an HTTP request. This call is asynchronous and provides a call result handle which you must use to track the call to its completion. If you have multiple requests in flight at the same time you can use [method Steam.prioritizeHTTPRequest] or [method Steam.deferHTTPRequest] to set the priority of the request.
If the user is in offline mode in Steam, then this will add an only-if-cached cache-control header and only do a local cache lookup rather than sending any actual remote request.
If the data you are expecting is large, you can use [method Steam.sendHTTPRequestAndStreamResponse] to stream the data in chunks.
*/
func SendHTTPRequest(request_handle int) bool { //gd:Steam.sendHTTPRequest
	once.Do(singleton)
	return bool(Advanced().SendHTTPRequest(int64(request_handle)))
}

/*
Sends an HTTP request and streams the response back in chunks. This call is asynchronous and provides a call result handle which you must use to track the call to its completion. Typically you'll want to allocate a buffer associated with the request handle using the Content-Length HTTP response field to receive the total size of the data when you receive the header via http_request_headers_received. You can then append data to that buffer as it comes in.
If you have multiple requests in flight at the same time you can use [method Steam.prioritizeHTTPRequest] or [method Steam.deferHTTPRequest] to set the priority of the request.
If the user is in offline mode in Steam, then this will add an only-if-cached cache-control header and only do a local cache lookup rather than sending any actual remote request.
If the data you are expecting is small (on the order of a few megabytes or less) then you'll likely want to use [method Steam.sendHTTPRequest].
*/
func SendHTTPRequestAndStreamResponse(request_handle int) bool { //gd:Steam.sendHTTPRequestAndStreamResponse
	once.Do(singleton)
	return bool(Advanced().SendHTTPRequestAndStreamResponse(int64(request_handle)))
}

/*
Adds a cookie to the specified cookie container that will be used with future requests.
*/
func SetHTTPCookie(cookie_handle int, host string, url string, cookie string) bool { //gd:Steam.setHTTPCookie
	once.Do(singleton)
	return bool(Advanced().SetHTTPCookie(int64(cookie_handle), String.New(host), String.New(url), String.New(cookie)))
}

/*
Set an absolute timeout in milliseconds for the HTTP request.
This is the total time timeout which is different than the network activity timeout which is set with [method Steam.setHTTPRequestNetworkActivityTimeout] which can bump every time we get more data.
*/
func SetHTTPRequestAbsoluteTimeoutMS(request_handle int, milliseconds int) bool { //gd:Steam.setHTTPRequestAbsoluteTimeoutMS
	once.Do(singleton)
	return bool(Advanced().SetHTTPRequestAbsoluteTimeoutMS(int64(request_handle), int64(milliseconds)))
}

/*
Set a context value for the request, which will be returned in the [signal Steam.http_request_completed] callback after sending the request.
This is just so the caller can easily keep track of which callbacks go with which request data.
Must be called before sending the request.
*/
func SetHTTPRequestContextValue(request_handle int, context_value int) bool { //gd:Steam.setHTTPRequestContextValue
	once.Do(singleton)
	return bool(Advanced().SetHTTPRequestContextValue(int64(request_handle), int64(context_value)))
}

/*
Associates a cookie container to use for an HTTP request.
*/
func SetHTTPRequestCookieContainer(request_handle int, cookie_handle int) bool { //gd:Steam.setHTTPRequestCookieContainer
	once.Do(singleton)
	return bool(Advanced().SetHTTPRequestCookieContainer(int64(request_handle), int64(cookie_handle)))
}

/*
Set a GET or POST parameter value on the HTTP request.
Must be called prior to sending the request.
*/
func SetHTTPRequestGetOrPostParameter(request_handle int, name string, value string) bool { //gd:Steam.setHTTPRequestGetOrPostParameter
	once.Do(singleton)
	return bool(Advanced().SetHTTPRequestGetOrPostParameter(int64(request_handle), String.New(name), String.New(value)))
}

/*
Set a request header value for the HTTP request.
Must be called before sending the request.
A full list of standard request fields are available here on Wikipedia. The User-Agent field is explicitly disallowed as it gets overwritten when the request is sent.
*/
func SetHTTPRequestHeaderValue(request_handle int, header_name string, header_value string) bool { //gd:Steam.setHTTPRequestHeaderValue
	once.Do(singleton)
	return bool(Advanced().SetHTTPRequestHeaderValue(int64(request_handle), String.New(header_name), String.New(header_value)))
}

/*
Set the timeout in seconds for the HTTP request.
The default timeout is 60 seconds if you don't call this. This can get bumped every time we get more data. Use [method Steam.setHTTPRequestAbsoluteTimeoutMS] if you need a strict maximum timeout.
*/
func SetHTTPRequestNetworkActivityTimeout(request_handle int, timeout_seconds int) bool { //gd:Steam.setHTTPRequestNetworkActivityTimeout
	once.Do(singleton)
	return bool(Advanced().SetHTTPRequestNetworkActivityTimeout(int64(request_handle), int64(timeout_seconds)))
}

/*
Sets the body for an HTTP Post request.
Will fail and return false on a GET request, and will fail if POST params have already been set for the request. Setting this raw body makes it the only contents for the post, the content_type parameter will set the "content-type" header for the request to inform the server how to interpret the body.
*/
func SetHTTPRequestRawPostBody(request_handle int, content_type string, body string) bool { //gd:Steam.setHTTPRequestRawPostBody
	once.Do(singleton)
	return bool(Advanced().SetHTTPRequestRawPostBody(int64(request_handle), String.New(content_type), String.New(body)))
}

/*
Sets that the HTTPS request should require verified SSL certificate via machines certificate trust store.
This currently only works Windows and macOS.
*/
func SetHTTPRequestRequiresVerifiedCertificate(request_handle int, require_verified_certificate bool) bool { //gd:Steam.setHTTPRequestRequiresVerifiedCertificate
	once.Do(singleton)
	return bool(Advanced().SetHTTPRequestRequiresVerifiedCertificate(int64(request_handle), require_verified_certificate))
}

/*
Set additional user agent info for a request.
This doesn't clobber the normal user agent, it just adds the extra info on the end. Sending NULL or an empty string resets the user agent info to the default value.
*/
func SetHTTPRequestUserAgentInfo(request_handle int, user_agent_info string) bool { //gd:Steam.setHTTPRequestUserAgentInfo
	once.Do(singleton)
	return bool(Advanced().SetHTTPRequestUserAgentInfo(int64(request_handle), String.New(user_agent_info)))
}

/*
Reconfigure the controller to use the specified action set (i.e. "Menu", "Walk", or "Drive").
This is cheap, and can be safely called repeatedly. It's often easier to repeatedly call it in your state loops, instead of trying to place it in all of your state transitions.
*/
func ActivateActionSet(input_handle int, action_set_handle int) { //gd:Steam.activateActionSet
	once.Do(singleton)
	Advanced().ActivateActionSet(int64(input_handle), int64(action_set_handle))
}

/*
Reconfigure the controller to use the specified action set layer.
*/
func ActivateActionSetLayer(input_handle int, action_set_layer_handle int) { //gd:Steam.activateActionSetLayer
	once.Do(singleton)
	Advanced().ActivateActionSetLayer(int64(input_handle), int64(action_set_layer_handle))
}

/*
Reconfigure the controller to stop using the specified action set.
*/
func DeactivateActionSetLayer(input_handle int, action_set_handle int) { //gd:Steam.deactivateActionSetLayer
	once.Do(singleton)
	Advanced().DeactivateActionSetLayer(int64(input_handle), int64(action_set_handle))
}

/*
Reconfigure the controller to stop using all action set layers.
*/
func DeactivateAllActionSetLayers(input_handle int) { //gd:Steam.deactivateAllActionSetLayers
	once.Do(singleton)
	Advanced().DeactivateAllActionSetLayers(int64(input_handle))
}

/*
Fill an array with all of the currently active action set layers for a specified controller handle.
*/
func GetActionSetHandle(action_set_name string) int { //gd:Steam.getActionSetHandle
	once.Do(singleton)
	return int(int(Advanced().GetActionSetHandle(String.New(action_set_name))))
}

/*
Get an action origin that you can use in your glyph look up table or passed into [method Steam.getGlyphForActionOrigin] or [method Steam.getStringForActionOrigin].
*/
func GetActionOriginFromXboxOrigin(input_handle int, origin int) InputActionOrigin { //gd:Steam.getActionOriginFromXboxOrigin
	once.Do(singleton)
	return InputActionOrigin(Advanced().GetActionOriginFromXboxOrigin(int64(input_handle), int64(origin)))
}

/*
Fill an array with all of the currently active action set layers for a specified controller handle.
Contains a list of handles (int).
*/
func GetActiveActionSetLayers(input_handle int) []any { //gd:Steam.getActiveActionSetLayers
	once.Do(singleton)
	return []any(gd.ArrayAs[[]any](gd.InternalArray(Advanced().GetActiveActionSetLayers(int64(input_handle)))))
}

/*
Gets the current state of the supplied analog game action.
The returned dictionary contains the following keys: [b]mode (int), x (float),y (float), and active (bool).[/b]
*/
func GetAnalogActionData(input_handle int, analog_action_handle int) map[any]any { //gd:Steam.getAnalogActionData
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetAnalogActionData(int64(input_handle), int64(analog_action_handle))))
}

/*
Get the handle of the specified analog action.
[b]Note:[/b] This function does not take an action set handle parameter. That means that each action in your VDF file must have a unique string identifier. In other words, if you use an action called "up" in two different action sets, this function will only ever return one of them and the other will be ignored.
*/
func GetAnalogActionHandle(action_name string) int { //gd:Steam.getAnalogActionHandle
	once.Do(singleton)
	return int(int(Advanced().GetAnalogActionHandle(String.New(action_name))))
}

/*
Get the origin(s) for an analog action within an action set by filling the return array with handles. Use this to display the appropriate on-screen prompt for the action.
Contains a list of handles (int).
*/
func GetAnalogActionOrigins(input_handle int, action_set_handle int, analog_action_handle int) []any { //gd:Steam.getAnalogActionOrigins
	once.Do(singleton)
	return []any(gd.ArrayAs[[]any](gd.InternalArray(Advanced().GetAnalogActionOrigins(int64(input_handle), int64(action_set_handle), int64(analog_action_handle)))))
}

/*
Enumerates currently connected controllers by filling returned array with controller handles.
Contains a list of controller handle (int).
*/
func GetConnectedControllers() []any { //gd:Steam.getConnectedControllers
	once.Do(singleton)
	return []any(gd.ArrayAs[[]any](gd.InternalArray(Advanced().GetConnectedControllers())))
}

/*
Returns the associated controller handle for the specified emulated gamepad. Can be used with [method Steam.getInputTypeForHandle] to determine the type of controller using Steam Input Gamepad Emulation.
*/
func GetControllerForGamepadIndex(index int) int { //gd:Steam.getControllerForGamepadIndex
	once.Do(singleton)
	return int(int(Advanced().GetControllerForGamepadIndex(int64(index))))
}

/*
Get the currently active action set for the specified controller.
*/
func GetCurrentActionSet(input_handle int) int { //gd:Steam.getCurrentActionSet
	once.Do(singleton)
	return int(int(Advanced().GetCurrentActionSet(int64(input_handle))))
}

/*
Gets the major and minor device binding revisions for Steam Input API configurations. Minor revisions are for small changes such as adding a new option action or updating localization in the configuration. When updating a Minor revision only one new configuration needs to be update with the "Use Action Block" flag set. Major revisions are to be used when changing the number of action sets or otherwise reworking configurations to the degree that older configurations are no longer usable. When a user's binding disagree's with the major revision of the current official configuration Steam will forcibly update the user to the new configuration. New configurations will need to be made for every controller when updating the Major revision.
The returned array contains a list of:
[codeblock]
┠╴major (int)
┖╴minor (int)minor (int)
[/codeblock]
*/
func GetDeviceBindingRevision(input_handle int) []any { //gd:Steam.getDeviceBindingRevision
	once.Do(singleton)
	return []any(gd.ArrayAs[[]any](gd.InternalArray(Advanced().GetDeviceBindingRevision(int64(input_handle)))))
}

/*
Returns the current state of the supplied digital game action.
The returned dictionary contains the following keys:
[codeblock]
┠╴state (bool)
┖╴active (bool)
[/codeblock]
*/
func GetDigitalActionData(input_handle int, digital_action_handle int) map[any]any { //gd:Steam.getDigitalActionData
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetDigitalActionData(int64(input_handle), int64(digital_action_handle))))
}

/*
Get the handle of the specified digital action.
[b]Note:[/b] This function does not take an action set handle parameter. That means that each action in your VDF file must have a unique string identifier. In other words, if you use an action called "up" in two different action sets, this function will only ever return one of them and the other will be ignored.
*/
func GetDigitalActionHandle(action_name string) int { //gd:Steam.getDigitalActionHandle
	once.Do(singleton)
	return int(int(Advanced().GetDigitalActionHandle(String.New(action_name))))
}

/*
Get the origin(s) for a digital action within an action set by filling return array with input handles. Use this to display the appropriate on-screen prompt for the action.
Contains a list of handles (int).
*/
func GetDigitalActionOrigins(input_handle int, action_set_handle int, digital_action_handle int) []any { //gd:Steam.getDigitalActionOrigins
	once.Do(singleton)
	return []any(gd.ArrayAs[[]any](gd.InternalArray(Advanced().GetDigitalActionOrigins(int64(input_handle), int64(action_set_handle), int64(digital_action_handle)))))
}

/*
Returns the associated gamepad index for the specified controller, if emulating a gamepad.
*/
func GetGamepadIndexForController(input_handle int) int { //gd:Steam.getGamepadIndexForController
	once.Do(singleton)
	return int(int(Advanced().GetGamepadIndexForController(int64(input_handle))))
}

/*
Get a local path to art for on-screen glyph for a particular origin.
*/
func GetGlyphForActionOrigin(origin InputActionOrigin) string { //gd:Steam.getGlyphForActionOrigin
	once.Do(singleton)
	return string(Advanced().GetGlyphForActionOrigin(origin).String())
}

/*
Returns the input type (device model) for the specified controller. This tells you if a given controller is a Steam controller, Xbox 360 controller, PS4 controller, etc.
*/
func GetInputTypeForHandle(input_handle int) InputType { //gd:Steam.getInputTypeForHandle
	once.Do(singleton)
	return InputType(Advanced().GetInputTypeForHandle(int64(input_handle)))
}

/*
Returns raw motion data for the specified controller.
The returned dictionary contains the following keys:
[codeblock]
┠╴rot_quat_x (float)
┠╴rot_quat_y (float)
┠╴rot_quat_z (float)
┠╴rot_quat_w (float)
┠╴pos_accel_x (float)
┠╴pos_accel_y (float)
┠╴pos_accel_z (float)
┠╴rot_vel_x (float)
┠╴rot_vel_y (float)
┖╴rot_vel_z (float)
[/codeblock]
*/
func GetMotionData(input_handle int) map[any]any { //gd:Steam.getMotionData
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetMotionData(int64(input_handle))))
}

/*
Get the Steam Remote Play session ID associated with a device, or 0 if there is no session associated with it. See isteamremoteplay.h for more information on Steam Remote Play sessions.
*/
func GetRemotePlaySessionID(input_handle int) int { //gd:Steam.getRemotePlaySessionID
	once.Do(singleton)
	return int(int(Advanced().GetRemotePlaySessionID(int64(input_handle))))
}

/*
Returns a localized string (from Steam's language setting) for the specified origin.
*/
func GetStringForActionOrigin(origin InputActionOrigin) string { //gd:Steam.getStringForActionOrigin
	once.Do(singleton)
	return string(Advanced().GetStringForActionOrigin(origin).String())
}

/*
[method Steam.inputInit] and [method Steam.inputShutdown] must be called when starting/ending use of this interface.
If explicitly_call_runframe is called then you will need to manually call runFrame each frame, otherwise Steam Input will updated when [method Steam.run_callbacks] is called.
*/
func InputInit(explicitly_call_runframe bool) bool { //gd:Steam.inputInit
	once.Do(singleton)
	return bool(Advanced().InputInit(explicitly_call_runframe))
}

/*
[method Steam.inputInit] and [method Steam.inputShutdown] must be called when starting/ending use of this interface.
If explicitly_call_runframe is called then you will need to manually call runFrame each frame, otherwise Steam Input will updated when [method Steam.run_callbacks] is called.
*/
func InputInitOptions(explicitly_call_runframe bool) bool { //gd:Steam.inputInit
	once.Do(singleton)
	return bool(Advanced().InputInit(explicitly_call_runframe))
}

/*
[method Steam.inputInit] and [method Steam.inputShutdown] must be called when starting/ending use of this interface.
*/
func InputShutdown() bool { //gd:Steam.inputShutdown
	once.Do(singleton)
	return bool(Advanced().InputShutdown())
}

/*
Synchronize API state with the latest Steam Controller inputs available. This is performed automatically by run_callbacks, but for the absolute lowest possible latency, you can call this directly before reading controller state.
*/
func RunFrame() { //gd:Steam.runFrame
	once.Do(singleton)
	Advanced().RunFrame(true)
}

/*
Synchronize API state with the latest Steam Controller inputs available. This is performed automatically by run_callbacks, but for the absolute lowest possible latency, you can call this directly before reading controller state.
*/
func RunFrameOptions(reserved_value bool) { //gd:Steam.runFrame
	once.Do(singleton)
	Advanced().RunFrame(reserved_value)
}

/*
Set the controller LED color on supported controllers.
[b]Note:[/b] The VSC does not support any color but white, and will interpret the RGB values as a grayscale value affecting the brightness of the Steam button LED. The DS4 responds to full color information and uses the values to set the color and brightness of the lightbar.
*/
func SetLEDColor(input_handle int, color_r int, color_g int, color_b int, flags int) { //gd:Steam.setLEDColor
	once.Do(singleton)
	Advanced().SetLEDColor(int64(input_handle), int64(color_r), int64(color_g), int64(color_b), int64(flags))
}

/*
Invokes the Steam overlay and brings up the binding screen.
*/
func ShowBindingPanel(input_handle int) bool { //gd:Steam.showBindingPanel
	once.Do(singleton)
	return bool(Advanced().ShowBindingPanel(int64(input_handle)))
}

/*
Stops the momentum of an analog action (where applicable, ie a touchpad w/ virtual trackball settings).
[b]Note:[/b] This will also stop all associated haptics. This is useful for situations where you want to indicate to the user that the limit of an action has been reached, such as spinning a carousel or scrolling a webpage.
*/
func StopAnalogActionMomentum(input_handle int, action int) { //gd:Steam.stopAnalogActionMomentum
	once.Do(singleton)
	Advanced().StopAnalogActionMomentum(int64(input_handle), int64(action))
}

/*
Get the equivalent origin for a given controller type or the closest controller type that existed in the SDK you built into your game if destination_inputis 0. This action origin can be used in your glyph look up table or passed into [method Steam.getGlyphForActionOrigin] or [method Steam.getStringForActionOrigin].
*/
func TranslateActionOrigin(destination_input InputType, source_origin InputActionOrigin) int { //gd:Steam.translateActionOrigin
	once.Do(singleton)
	return int(int(Advanced().TranslateActionOrigin(destination_input, source_origin)))
}

/*
Triggers a (low-level) haptic pulse on supported controllers.
Currently only the VSC supports haptic pulses. This API call will be ignored for all other controller models. The typical max value of an unsigned short is 65535, which means the longest haptic pulse you can trigger with this method has a duration of 0.065535 seconds (ie, less than 1/10th of a second). This function should be thought of as a low-level primitive meant to be repeatedly used in higher-level user functions to generate more sophisticated behavior.
*/
func TriggerHapticPulse(input_handle int, target_pad int, duration int) { //gd:Steam.triggerHapticPulse
	once.Do(singleton)
	Advanced().TriggerHapticPulse(int64(input_handle), int64(target_pad), int64(duration))
}

/*
Triggers a repeated haptic pulse on supported controllers.
[b]Note:[/b] Currently only the VSC supports haptic pulses. This API call will be ignored for incompatible controller models. This is a more user-friendly function to call than [method Steam.triggerHapticPulse] as it can generate pulse patterns long enough to be actually noticed by the user. Changing the duration and offset parameters will change the "texture" of the haptic pulse.
*/
func TriggerRepeatedHapticPulse(input_handle int, target_pad int, duration int, offset int, repeat int, flags int) { //gd:Steam.triggerRepeatedHapticPulse
	once.Do(singleton)
	Advanced().TriggerRepeatedHapticPulse(int64(input_handle), int64(target_pad), int64(duration), int64(offset), int64(repeat), int64(flags))
}

/*
Trigger a vibration event on supported controllers.
[b]Note:[/b] This API call will be ignored for incompatible controller models. This generates the traditional "rumble" vibration effect. The VSC will emulate traditional rumble using its haptics.
*/
func TriggerVibration(input_handle int, left_speed int, right_speed int) { //gd:Steam.triggerVibration
	once.Do(singleton)
	Advanced().TriggerVibration(int64(input_handle), int64(left_speed), int64(right_speed))
}

/*
Set the absolute path to the Input Action Manifest file containing the in-game actions and file paths to the official configurations. Used in games that bundle Steam Input configurations inside of the game depot instead of using the Steam Workshop.
*/
func SetInputActionManifestFilePath(manifest_path string) bool { //gd:Steam.setInputActionManifestFilePath
	once.Do(singleton)
	return bool(Advanced().SetInputActionManifestFilePath(String.New(manifest_path)))
}

/*
Set the trigger effect for a DualSense controller.
*/
func SetDualSenseTriggerEffect(input_handle int, parameters int, trigger_mask int, effect_mode SCEPadTriggerEffectMode, position int, amplitude int, frequency int) { //gd:Steam.setDualSenseTriggerEffect
	once.Do(singleton)
	Advanced().SetDualSenseTriggerEffect(int64(input_handle), int64(parameters), int64(trigger_mask), effect_mode, int64(position), int64(amplitude), int64(frequency))
}

/*
Waits on an IPC event from Steam sent when there is new data to be fetched from the data drop. Returns true when data was recievied before the timeout expires. Useful for games with a dedicated input thread.
*/
func WaitForData(wait_forever bool, timeout int) bool { //gd:Steam.waitForData
	once.Do(singleton)
	return bool(Advanced().WaitForData(wait_forever, int64(timeout)))
}

/*
Returns true if new data has been received since the last time action data was accessed via [method Steam.getDigitalActionData] or [method Steam.getAnalogActionData]. The game will still need to call [method Steam.runFrame] or [method Steam.run_callbacks] before this to update the data stream.
*/
func NewDataAvailable() bool { //gd:Steam.newDataAvailable
	once.Do(singleton)
	return bool(Advanced().NewDataAvailable())
}

/*
Enable [signal Steam.input_device_connected] and [signal Steam.input_device_disconnected] callbacks. Each controller that is already connected will generate a device connected callback when you enable them.
*/
func EnableDeviceCallbacks() { //gd:Steam.enableDeviceCallbacks
	once.Do(singleton)
	Advanced().EnableDeviceCallbacks()
}

/*
Enable the [signal Steam.input_action_event] callback.
*/
func EnableActionEventCallbacks() { //gd:Steam.enableActionEventCallbacks
	once.Do(singleton)
	Advanced().EnableActionEventCallbacks()
}

/*
Get a local path to a PNG file for the provided origin's glyph.
*/
func GetGlyphPNGForActionOrigin(origin InputActionOrigin, size InputGlyphSize, flags int) string { //gd:Steam.getGlyphPNGForActionOrigin
	once.Do(singleton)
	return string(Advanced().GetGlyphPNGForActionOrigin(origin, size, int64(flags)).String())
}

/*
Get a local path to a SVG file for the provided origin's glyph.
*/
func GetGlyphSVGForActionOrigin(origin InputActionOrigin, flags int) string { //gd:Steam.getGlyphSVGForActionOrigin
	once.Do(singleton)
	return string(Advanced().GetGlyphSVGForActionOrigin(origin, int64(flags)).String())
}

/*
Trigger a vibration event on supported controllers including Xbox trigger impulse rumble - Steam will translate these commands into haptic pulses for Steam Controllers.
*/
func TriggerVibrationExtended(input_handle int, left_speed int, right_speed int, left_trigger_speed int, right_trigger_speed int) { //gd:Steam.triggerVibrationExtended
	once.Do(singleton)
	Advanced().TriggerVibrationExtended(int64(input_handle), int64(left_speed), int64(right_speed), int64(left_trigger_speed), int64(right_trigger_speed))
}

/*
Send a haptic pulse, works on Steam Deck and Steam Controller devices.
*/
func TriggerSimpleHapticEvent(input_handle int, haptic_location int, intensity int, gain_db string, other_intensity int, other_gain_db string) { //gd:Steam.triggerSimpleHapticEvent
	once.Do(singleton)
	Advanced().TriggerSimpleHapticEvent(int64(input_handle), int64(haptic_location), int64(intensity), String.New(gain_db), int64(other_intensity), String.New(other_gain_db))
}

/*
Returns a localized string (from Steam's language setting) for the specified Xbox controller origin.
*/
func GetStringForXboxOrigin(origin int) string { //gd:Steam.getStringForXboxOrigin
	once.Do(singleton)
	return string(Advanced().GetStringForXboxOrigin(int64(origin)).String())
}

/*
Get a local path to art for on-screen glyph for a particular Xbox controller origin.
*/
func GetGlyphForXboxOrigin(origin int) string { //gd:Steam.getGlyphForXboxOrigin
	once.Do(singleton)
	return string(Advanced().GetGlyphForXboxOrigin(int64(origin)).String())
}

/*
Get a bitmask of the Steam Input Configuration types opted in for the current session. Returns InputConfigurationEnableType values.
[b]Note:[/b] user can override the settings from the Steamworks Partner site so the returned values may not exactly match your default configuration.
*/
func GetSessionInputConfigurationSettings() int { //gd:Steam.getSessionInputConfigurationSettings
	once.Do(singleton)
	return int(int(Advanced().GetSessionInputConfigurationSettings()))
}

/*
Returns a localized string (from Steam's language setting) for the user-facing action name corresponding to the specified handle.
*/
func GetStringForDigitalActionName(action_handle int) string { //gd:Steam.getStringForDigitalActionName
	once.Do(singleton)
	return string(Advanced().GetStringForDigitalActionName(int64(action_handle)).String())
}

/*
Returns a localized string (from Steam's language setting) for the user-facing action name corresponding to the specified handle.
*/
func GetStringForAnalogActionName(action_handle int) string { //gd:Steam.getStringForAnalogActionName
	once.Do(singleton)
	return string(Advanced().GetStringForAnalogActionName(int64(action_handle)).String())
}

/*
Grant a specific one-time promotional item to the current user.
This can be safely called from the client because the items it can grant can be locked down via policies in the itemdefs. One of the primary scenarios for this call is to grant an item to users who also own a specific other game. This can be useful if your game has custom UI for showing a specific promo item to the user otherwise if you want to grant multiple promotional items then use [method Steam.addPromoItems] or [method Steam.grantPromoItems].
Any items that can be granted must have a "promo" attribute in their itemdef. That promo item list a set of app IDs that the user must own to be granted this given item. This version will grant all items that have promo attributes specified for them in the configured item definitions. This allows adding additional promotional items without having to update the game client. For example the following will allow the item to be granted if the user owns either TF2 or SpaceWar.
The inventory handle, which is also stored internally. It will overwrite any previously stored inventory handle.
*/
func AddPromoItem(item int) int { //gd:Steam.addPromoItem
	once.Do(singleton)
	return int(int(Advanced().AddPromoItem(int64(item))))
}

/*
Grant a specific one-time promotional item to the current user.
This can be safely called from the client because the items it can grant can be locked down via policies in the itemdefs. One of the primary scenarios for this call is to grant an item to users who also own a specific other game. If you want to grant a single promotional item then use [method Steam.addPromoItems]. If you want to grant all possible promo items then use [method Steam.grantPromoItems].
Any items that can be granted must have a "promo" attribute in their itemdef. That promo item list a set of app ID's that the user must own to be granted this given item. This version will grant all items that have promo attributes specified for them in the configured item definitions. This allows adding additional promotional items without having to update the game client. For example the following will allow the item to be granted if the user owns either TF2 or SpaceWar.
The inventory handle, which is also stored internally. It will overwrite any previously stored inventory handle.
*/
func AddPromoItems(items []int64) int { //gd:Steam.addPromoItems
	once.Do(singleton)
	return int(int(Advanced().AddPromoItems(Packed.New(items...))))
}

/*
Checks whether an inventory result handle belongs to the specified Steam ID. This is important when using [method Steam.deserializeResult], to verify that a remote player is not pretending to have a different user's inventory.
[b]Note:[/b] If the argument this_inventory_handle is omitted, GodotSteam will use the internally stored ID.
*/
func CheckResultSteamID(steam_id_expected int, this_inventory_handle int) bool { //gd:Steam.checkResultSteamID
	once.Do(singleton)
	return bool(Advanced().CheckResultSteamID(int64(steam_id_expected), int64(this_inventory_handle)))
}

/*
Checks whether an inventory result handle belongs to the specified Steam ID. This is important when using [method Steam.deserializeResult], to verify that a remote player is not pretending to have a different user's inventory.
[b]Note:[/b] If the argument this_inventory_handle is omitted, GodotSteam will use the internally stored ID.
*/
func CheckResultSteamIDOptions(steam_id_expected int, this_inventory_handle int) bool { //gd:Steam.checkResultSteamID
	once.Do(singleton)
	return bool(Advanced().CheckResultSteamID(int64(steam_id_expected), int64(this_inventory_handle)))
}

/*
Consumes items from a user's inventory. If the quantity of the given item goes to zero, it is permanently removed.
Once an item is removed it cannot be recovered. This is not for the faint of heart - if your game implements item removal at all, a high-friction UI confirmation process is highly recommended.
The inventory handle, which is also stored internally. It will overwrite any previously stored inventory handle.
[b]Note:[/b] You must call [method Steam.destroyResult] on the provided inventory result when you are done with it.
*/
func ConsumeItem(item_consume int, quantity int) int { //gd:Steam.consumeItem
	once.Do(singleton)
	return int(int(Advanced().ConsumeItem(int64(item_consume), int64(quantity))))
}

/*
Deserializes a result set and verifies the signature bytes.
This call has a potential soft-failure mode where the handle status is set to 27. [method Steam.getResultItems] will still succeed in this mode. The "expired" result could indicate that the data may be out of date - not just due to timed expiration (one hour), but also because one of the items in the result set may have been traded or consumed since the result set was generated. You could compare the timestamp from [method Steam.getResultTimestamp] to [method Steam.getServerRealTime] to determine how old the data is. You could simply ignore the "expired" result code and continue as normal, or you could request the player with expired data to send an updated result set.
You should call [method Steam.checkResultSteamID] on the result handle when it completes to verify that a remote player is not pretending to have a different user's inventory.
The inventory handle, which is also stored internally. It will overwrite any previously stored inventory handle.
*/
func DeserializeResult(buffer []byte) int { //gd:Steam.deserializeResult
	once.Do(singleton)
	return int(int(Advanced().DeserializeResult(Packed.Bytes(Packed.New(buffer...)))))
}

/*
Destroys a result handle and frees all associated memory.
[b]Note:[/b] If the argument this_inventory_handle is omitted, GodotSteam will use the internally stored ID.
*/
func DestroyResult(this_inventory_handle int) { //gd:Steam.destroyResult
	once.Do(singleton)
	Advanced().DestroyResult(int64(this_inventory_handle))
}

/*
Destroys a result handle and frees all associated memory.
[b]Note:[/b] If the argument this_inventory_handle is omitted, GodotSteam will use the internally stored ID.
*/
func DestroyResultOptions(this_inventory_handle int) { //gd:Steam.destroyResult
	once.Do(singleton)
	Advanced().DestroyResult(int64(this_inventory_handle))
}

/*
Grant one item in exchange for a set of other items.
This can be used to implement crafting recipes or transmutations, or items which unpack themselves into other items (e.g., a chest).
The caller of this API passes in the requested item and an array of existing items and quantities to exchange for it. The API currently takes an array of items to generate but at this time the size of that array must be 1 and the quantity of the new item must be 1.
Any items that can be granted must have an exchange attribute in their itemdef. The exchange attribute specifies a set of recipes that are valid exchanges for this item. Exchange recipes are evaluated atomically by the Inventory Service; if the supplied components do not match the recipe, or do not contain sufficient quantity, the exchange will fail.
Will allow the item to be exchanged for either one #101 and one #102, five #103s or three #104s and three #105s. See the Steam Inventory Schema documentation for more details.
The inventory handle, which is also stored internally. It will overwrite any previously stored inventory handle.
[b]Note:[/b] You must call [method Steam.destroyResult] on the provided inventory result when you are done with it.
*/
func ExchangeItems(output_items []int64, output_quantity []int32, input_items []int64, input_quantity []int32) int { //gd:Steam.exchangeItems
	once.Do(singleton)
	return int(int(Advanced().ExchangeItems(Packed.New(output_items...), Packed.New(output_quantity...), Packed.New(input_items...), Packed.New(input_quantity...))))
}

/*
Grants specific items to the current user, for developers only.
This API is only intended for prototyping - it is only usable by Steam accounts that belong to the publisher group for your game.
You can pass in an array of items, identified by their item definition int's and optionally a second array of corresponding quantities for each item. The length of these arrays must match!
The inventory handle, which is also stored internally. It will overwrite any previously stored inventory handle.
[b]Note:[/b] You must call [method Steam.destroyResult] on the provided inventory result when you are done with it.
*/
func GenerateItems(items []int64, quantity []int32) int { //gd:Steam.generateItems
	once.Do(singleton)
	return int(int(Advanced().GenerateItems(Packed.New(items...), Packed.New(quantity...))))
}

/*
Start retrieving all items in the current users inventory.
The inventory handle, which is also stored internally. It will overwrite any previously stored inventory handle.
[b]Note:[/b] Calls to this function are subject to rate limits and may return cached results if called too frequently. It is suggested that you call this function only when you are about to display the user's full inventory, or if you expect that the inventory may have changed.
[b]Note:[/b] You must call [method Steam.destroyResult] on the provided inventory result when you are done with it.
*/
func GetAllItems() int { //gd:Steam.getAllItems
	once.Do(singleton)
	return int(int(Advanced().GetAllItems()))
}

/*
Gets a string property from the specified item definition. Gets a property value for a specific item definition.
Note that some properties (for example, "name") may be localized and will depend on the current Steam language settings; see [method Steam.getCurrentGameLanguage]. Property names are always ASCII alphanumeric and underscores.
Pass in NULL for name to get a comma-separated list of available property names.
[b]Note:[/b] Call [method Steam.loadItemDefinitions] first, to ensure that items are ready to be used before calling [method Steam.getItemDefinitionProperty].
*/
func GetItemDefinitionProperty(definition int, name string) string { //gd:Steam.getItemDefinitionProperty
	once.Do(singleton)
	return string(Advanced().GetItemDefinitionProperty(int64(definition), String.New(name)).String())
}

/*
Gets the state of a subset of the current user's inventory.
The subset is specified by an array of item instance IDs.
The results from this call can be serialized using [method Steam.serializeResult] and passed to other players to "prove" that the current user owns specific items, without exposing the user's entire inventory. For example, you could call this with the IDs of the user's currently equipped items and serialize this to a buffer, and then transmit this buffer to other players upon joining a game.
The inventory handle, which is also stored internally. It will overwrite any previously stored inventory handle.
[b]Note:[/b] You must call [method Steam.destroyResult] on the provided inventory result when you are done with it.
*/
func GetItemsByID(id_array []int64) int { //gd:Steam.getItemsByID
	once.Do(singleton)
	return int(int(Advanced().GetItemsByID(Packed.New(id_array...))))
}

/*
After a successful call to [method Steam.requestPrices], you can call this method to get the pricing for a specific item definition.
The returned dictionary contains the following keys:
[codeblock]
┠╴price (int)
┖╴base_price (int)
[/codeblock]
*/
func GetItemPrice(definition int) map[any]any { //gd:Steam.getItemPrice
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetItemPrice(int64(definition))))
}

/*
After a successful call to [method Steam.requestPrices], you can call this method to get all the pricing for applicable item definitions.
*/
func GetItemsWithPrices() []any { //gd:Steam.getItemsWithPrices
	once.Do(singleton)
	return []any(gd.ArrayAs[[]any](gd.InternalArray(Advanced().GetItemsWithPrices())))
}

/*
Gets the dynamic properties from an item in an inventory result set.
Property names are always composed of ASCII letters, numbers, and/or underscores.
If the results do not fit in the given buffer, partial results may be copied.
[b]Note:[/b] If the argument this_inventory_handle is omitted, GodotSteam will use the internally stored ID.
*/
func GetResultItemProperty(index int, name string, this_inventory_handle int) string { //gd:Steam.getResultItemProperty
	once.Do(singleton)
	return string(Advanced().GetResultItemProperty(int64(index), String.New(name), int64(this_inventory_handle)).String())
}

/*
Gets the dynamic properties from an item in an inventory result set.
Property names are always composed of ASCII letters, numbers, and/or underscores.
If the results do not fit in the given buffer, partial results may be copied.
[b]Note:[/b] If the argument this_inventory_handle is omitted, GodotSteam will use the internally stored ID.
*/
func GetResultItemPropertyOptions(index int, name string, this_inventory_handle int) string { //gd:Steam.getResultItemProperty
	once.Do(singleton)
	return string(Advanced().GetResultItemProperty(int64(index), String.New(name), int64(this_inventory_handle)).String())
}

/*
Get the items associated with an inventory result handle.
The returned array contains a list of dictionaries which contain the following keys:
[codeblock]
┠╴item_id (int)
┠╴item_definition (int)
┠╴flags (int)
┖╴quantity (int)
[/codeblock]
[b]Note:[/b] If the argument this_inventory_handle is omitted, GodotSteam will use the internally stored ID.
*/
func GetResultItems(this_inventory_handle int) []any { //gd:Steam.getResultItems
	once.Do(singleton)
	return []any(gd.ArrayAs[[]any](gd.InternalArray(Advanced().GetResultItems(int64(this_inventory_handle)))))
}

/*
Get the items associated with an inventory result handle.
The returned array contains a list of dictionaries which contain the following keys:
[codeblock]
┠╴item_id (int)
┠╴item_definition (int)
┠╴flags (int)
┖╴quantity (int)
[/codeblock]
[b]Note:[/b] If the argument this_inventory_handle is omitted, GodotSteam will use the internally stored ID.
*/
func GetResultItemsOptions(this_inventory_handle int) []any { //gd:Steam.getResultItems
	once.Do(singleton)
	return []any(gd.ArrayAs[[]any](gd.InternalArray(Advanced().GetResultItems(int64(this_inventory_handle)))))
}

/*
Find out the status of an asynchronous inventory result handle. This is a polling equivalent to registering a callback function for [signal Steam.inventory_result_ready].
[b]Note:[/b] If the argument this_inventory_handle is omitted, GodotSteam will use the internally stored ID.
*/
func GetResultStatus(this_inventory_handle int) Result { //gd:Steam.getResultStatus
	once.Do(singleton)
	return Result(Advanced().GetResultStatus(int64(this_inventory_handle)))
}

/*
Find out the status of an asynchronous inventory result handle. This is a polling equivalent to registering a callback function for [signal Steam.inventory_result_ready].
[b]Note:[/b] If the argument this_inventory_handle is omitted, GodotSteam will use the internally stored ID.
*/
func GetResultStatusOptions(this_inventory_handle int) Result { //gd:Steam.getResultStatus
	once.Do(singleton)
	return Result(Advanced().GetResultStatus(int64(this_inventory_handle)))
}

/*
Gets the server time at which the result was generated.
You can compare this value against getServerRealTime to determine the age of the result.
[b]Note:[/b] If the argument this_inventory_handle is omitted, GodotSteam will use the internally stored ID.
*/
func GetResultTimestamp(this_inventory_handle int) int { //gd:Steam.getResultTimestamp
	once.Do(singleton)
	return int(int(Advanced().GetResultTimestamp(int64(this_inventory_handle))))
}

/*
Gets the server time at which the result was generated.
You can compare this value against getServerRealTime to determine the age of the result.
[b]Note:[/b] If the argument this_inventory_handle is omitted, GodotSteam will use the internally stored ID.
*/
func GetResultTimestampOptions(this_inventory_handle int) int { //gd:Steam.getResultTimestamp
	once.Do(singleton)
	return int(int(Advanced().GetResultTimestamp(int64(this_inventory_handle))))
}

/*
Grant all potential one-time promotional items to the current user.
This can be safely called from the client because the items it can grant can be locked down via policies in the itemdefs. One of the primary scenarios for this call is to grant an item to users who also own a specific other game. If you want to grant specific promotional items rather than all of them see: [method Steam.addPromoItem] and [method Steam.addPromoItems].
Any items that can be granted must have a "promo" attribute in their itemdef. That promo item list a set of app ID's that the user must own to be granted this given item. This version will grant all items that have promo attributes specified for them in the configured item definitions. This allows adding additional promotional items without having to update the game client. For example the following will allow the item to be granted if the user owns either TF2 or SpaceWar.
The inventory handle, which is also stored internally. It will overwrite any previously stored inventory handle.
[b]Note:[/b] You must call [method Steam.destroyResult] on the provided inventory result when you are done with it.
*/
func GrantPromoItems() int { //gd:Steam.grantPromoItems
	once.Do(singleton)
	return int(int(Advanced().GrantPromoItems()))
}

/*
Triggers an asynchronous load and refresh of item definitions.
Item definitions are a mapping of "definition IDs" (integers between 1 and 999999999) to a set of string properties. Some of these properties are required to display items on the Steam community web site. Other properties can be defined by applications. There is no reason to call this function if your game hardcoded the numeric definition IDs (e.g. purple face mask = 20, blue weapon mod = 55) and does not allow for adding new item types without a client patch.
Triggers a [signal Steam.inventory_definition_update] callback.
*/
func LoadItemDefinitions() bool { //gd:Steam.loadItemDefinitions
	once.Do(singleton)
	return bool(Advanced().LoadItemDefinitions())
}

/*
Request the list of "eligible" promo items that can be manually granted to the given user.
These are promo items of type "manual" that won't be granted automatically. An example usage of this is an item that becomes available every week.
Triggers a [signal Steam.inventory_eligible_promo_item] callback.
*/
func RequestEligiblePromoItemDefinitionsIDs(steam_id int) { //gd:Steam.requestEligiblePromoItemDefinitionsIDs
	once.Do(singleton)
	Advanced().RequestEligiblePromoItemDefinitionsIDs(int64(steam_id))
}

/*
Request prices for all item definitions that can be purchased in the user's local currency. A [signal Steam.inventory_request_prices_result] call result will be returned with the user's local currency code.
Triggers a [signal Steam.inventory_request_prices_result] callback.
*/
func RequestPrices() { //gd:Steam.requestPrices
	once.Do(singleton)
	Advanced().RequestPrices()
}

/*
Serialized result sets contain a short signature which can't be forged or replayed across different game sessions.
A result set can be serialized on the local client, transmitted to other players via your game networking, and deserialized by the remote players. This is a secure way of preventing hackers from lying about possessing rare/high-value items. Serializes a result set with signature bytes to an output buffer. The size of a serialized result depends on the number items which are being serialized. When securely transmitting items to other players, it is recommended to use [method Steam.getItemsByID] first to create a minimal result set.
[b]Note:[/b] If the argument this_inventory_handle is omitted, GodotSteam will use the internally stored ID.
Results have a built-in timestamp which will be considered "expired" after an hour has elapsed. See [method Steam.deserializeResult] for expiration handling.
*/
func SerializeResult(this_inventory_handle int) []byte { //gd:Steam.serializeResult
	once.Do(singleton)
	return []byte(Advanced().SerializeResult(int64(this_inventory_handle)).Bytes())
}

/*
Serialized result sets contain a short signature which can't be forged or replayed across different game sessions.
A result set can be serialized on the local client, transmitted to other players via your game networking, and deserialized by the remote players. This is a secure way of preventing hackers from lying about possessing rare/high-value items. Serializes a result set with signature bytes to an output buffer. The size of a serialized result depends on the number items which are being serialized. When securely transmitting items to other players, it is recommended to use [method Steam.getItemsByID] first to create a minimal result set.
[b]Note:[/b] If the argument this_inventory_handle is omitted, GodotSteam will use the internally stored ID.
Results have a built-in timestamp which will be considered "expired" after an hour has elapsed. See [method Steam.deserializeResult] for expiration handling.
*/
func SerializeResultOptions(this_inventory_handle int) []byte { //gd:Steam.serializeResult
	once.Do(singleton)
	return []byte(Advanced().SerializeResult(int64(this_inventory_handle)).Bytes())
}

/*
Starts the purchase process for the user, given a "shopping cart" of item definitions that the user would like to buy. The user will be prompted in the Steam Overlay to complete the purchase in their local currency, funding their Steam Wallet if necessary, etc.
If the purchase process was started successfully, then order_id and transaction_id will be valid in the [signal Steam.inventory_start_purchase_result] call result.
If the user authorizes the transaction and completes the purchase, then the callback [signal Steam.inventory_result_ready] will be triggered and you can then retrieve what new items the user has acquired.
Triggers a [signal Steam.inventory_start_purchase_result] callback.
[b]Note:[/b] You must call [method Steam.destroyResult] on the inventory result for when you are done with it.
*/
func StartPurchase(items []int64, quantity []int32) { //gd:Steam.startPurchase
	once.Do(singleton)
	Advanced().StartPurchase(Packed.New(items...), Packed.New(quantity...))
}

/*
Transfer items between stacks within a user's inventory.
This can be used to stack, split, and moving items. The source and destination items must have the same itemdef id. To move items onto a destination stack specify the source, the quantity to move, and the destination item id. To split an existing stack, pass -1 into item_destination. A new item stack will be generated with the requested quantity.
The inventory handle, which is also stored internally. It will overwrite any previously stored inventory handle.
[b]Note:[/b] Tradability/marketability restrictions are copied along with transferred items. The destination stack receives the latest tradability/marketability date of any item in its composition.
*/
func TransferItemQuantity(item_id int, quantity int, item_destination int, split bool) int { //gd:Steam.transferItemQuantity
	once.Do(singleton)
	return int(int(Advanced().TransferItemQuantity(int64(item_id), int64(quantity), int64(item_destination), split)))
}

/*
Trigger an item drop if the user has played a long enough period of time.
This period can be customized in two places:
At the application level within Inventory Service: Playtime Item Grants. This will automatically apply to all "playtimegenerator" items that do not specify any overrides.
In an individual "playtimegenerator" item definition. The settings would take precedence over any application-level settings.
Only item definitions which are marked as "playtime item generators" can be spawned. Typically this function should be called at the end of a game or level or match or any point of significance in the game in which an item drop could occur. The granularity of the playtime generator settings is in minutes, so calling it more frequently than minutes is not useful and will be rate limited in the Steam client. The Steam servers will perform playtime accounting to prevent too-frequent drops. The servers will also manage adding the item to the players inventory.
The inventory handle, which is also stored internally. It will overwrite any previously stored inventory handle.
*/
func TriggerItemDrop(definition int) int { //gd:Steam.triggerItemDrop
	once.Do(singleton)
	return int(int(Advanced().TriggerItemDrop(int64(definition))))
}

/*
Starts a transaction request to update dynamic properties on items for the current user. This call is rate-limited by user, so property modifications should be batched as much as possible (e.g. at the end of a map or game session). After calling [method Steam.setPropertyBool] or [method Steam.setPropertyFloat] or [method Steam.setPropertyInt] or [method Steam.setPropertyString] or [method Steam.removeProperty] for all the items that you want to modify, you will need to call [method Steam.submitUpdateProperties] to send the request to the Steam servers. A [signal Steam.inventory_result_ready] callback will be fired with the results of the operation.
*/
func StartUpdateProperties() { //gd:Steam.startUpdateProperties
	once.Do(singleton)
	Advanced().StartUpdateProperties()
}

/*
Submits the transaction request to modify dynamic properties on items for the current user. See [method Steam.startUpdateProperties].
The inventory handle, which is also stored internally. It will overwrite any previously stored inventory handle.
[b]Note:[/b] You must call [method Steam.destroyResult] on the provided inventory result for when you are done with it.
*/
func SubmitUpdateProperties(this_inventory_update_handle int) int { //gd:Steam.submitUpdateProperties
	once.Do(singleton)
	return int(int(Advanced().SubmitUpdateProperties(int64(this_inventory_update_handle))))
}

/*
Submits the transaction request to modify dynamic properties on items for the current user. See [method Steam.startUpdateProperties].
The inventory handle, which is also stored internally. It will overwrite any previously stored inventory handle.
[b]Note:[/b] You must call [method Steam.destroyResult] on the provided inventory result for when you are done with it.
*/
func SubmitUpdatePropertiesOptions(this_inventory_update_handle int) int { //gd:Steam.submitUpdateProperties
	once.Do(singleton)
	return int(int(Advanced().SubmitUpdateProperties(int64(this_inventory_update_handle))))
}

/*
Removes a dynamic property for the given item.
[b]Note:[/b] If the argument this_inventory_update_handle is omitted, GodotSteam will use the internally stored ID. This is different from this_inventory_handle and is stored separately.
*/
func RemoveProperty(item_id int, name string, this_inventory_update_handle int) bool { //gd:Steam.removeProperty
	once.Do(singleton)
	return bool(Advanced().RemoveProperty(int64(item_id), String.New(name), int64(this_inventory_update_handle)))
}

/*
Removes a dynamic property for the given item.
[b]Note:[/b] If the argument this_inventory_update_handle is omitted, GodotSteam will use the internally stored ID. This is different from this_inventory_handle and is stored separately.
*/
func RemovePropertyOptions(item_id int, name string, this_inventory_update_handle int) bool { //gd:Steam.removeProperty
	once.Do(singleton)
	return bool(Advanced().RemoveProperty(int64(item_id), String.New(name), int64(this_inventory_update_handle)))
}

/*
Sets a dynamic property for the given item. Supported value types are strings.
[b]Note:[/b] If the argument this_inventory_update_handle is omitted, GodotSteam will use the internally stored ID. This is different from this_inventory_handle and is stored separately.
*/
func SetPropertyString(item_id int, name string, value string, this_inventory_update_handle int) bool { //gd:Steam.setPropertyString
	once.Do(singleton)
	return bool(Advanced().SetPropertyString(int64(item_id), String.New(name), String.New(value), int64(this_inventory_update_handle)))
}

/*
Sets a dynamic property for the given item. Supported value types are strings.
[b]Note:[/b] If the argument this_inventory_update_handle is omitted, GodotSteam will use the internally stored ID. This is different from this_inventory_handle and is stored separately.
*/
func SetPropertyStringOptions(item_id int, name string, value string, this_inventory_update_handle int) bool { //gd:Steam.setPropertyString
	once.Do(singleton)
	return bool(Advanced().SetPropertyString(int64(item_id), String.New(name), String.New(value), int64(this_inventory_update_handle)))
}

/*
Sets a dynamic property for the given item. Supported value types are boolean.
[b]Note:[/b] If the argument this_inventory_update_handle is omitted, GodotSteam will use the internally stored ID. This is different from this_inventory_handle and is stored separately.
*/
func SetPropertyBool(item_id int, name string, value bool, this_inventory_update_handle int) bool { //gd:Steam.setPropertyBool
	once.Do(singleton)
	return bool(Advanced().SetPropertyBool(int64(item_id), String.New(name), value, int64(this_inventory_update_handle)))
}

/*
Sets a dynamic property for the given item. Supported value types are boolean.
[b]Note:[/b] If the argument this_inventory_update_handle is omitted, GodotSteam will use the internally stored ID. This is different from this_inventory_handle and is stored separately.
*/
func SetPropertyBoolOptions(item_id int, name string, value bool, this_inventory_update_handle int) bool { //gd:Steam.setPropertyBool
	once.Do(singleton)
	return bool(Advanced().SetPropertyBool(int64(item_id), String.New(name), value, int64(this_inventory_update_handle)))
}

/*
Sets a dynamic property for the given item. Supported value types are 64 bit integers.
[b]Note:[/b] If the argument this_inventory_update_handle is omitted, GodotSteam will use the internally stored ID. This is different from this_inventory_handle and is stored separately.
*/
func SetPropertyInt(item_id int, name string, value int, this_inventory_update_handle int) bool { //gd:Steam.setPropertyInt
	once.Do(singleton)
	return bool(Advanced().SetPropertyInt(int64(item_id), String.New(name), int64(value), int64(this_inventory_update_handle)))
}

/*
Sets a dynamic property for the given item. Supported value types are 64 bit integers.
[b]Note:[/b] If the argument this_inventory_update_handle is omitted, GodotSteam will use the internally stored ID. This is different from this_inventory_handle and is stored separately.
*/
func SetPropertyIntOptions(item_id int, name string, value int, this_inventory_update_handle int) bool { //gd:Steam.setPropertyInt
	once.Do(singleton)
	return bool(Advanced().SetPropertyInt(int64(item_id), String.New(name), int64(value), int64(this_inventory_update_handle)))
}

/*
Sets a dynamic property for the given item. Supported value types are 32 bit floats.
[b]Note:[/b] If the argument this_inventory_update_handle is omitted, GodotSteam will use the internally stored ID. Also note this different from this_inventory_handle and is stored separately.
*/
func SetPropertyFloat(item_id int, name string, value Float.X, this_inventory_update_handle int) bool { //gd:Steam.setPropertyFloat
	once.Do(singleton)
	return bool(Advanced().SetPropertyFloat(int64(item_id), String.New(name), float64(value), int64(this_inventory_update_handle)))
}

/*
Sets a dynamic property for the given item. Supported value types are 32 bit floats.
[b]Note:[/b] If the argument this_inventory_update_handle is omitted, GodotSteam will use the internally stored ID. Also note this different from this_inventory_handle and is stored separately.
*/
func SetPropertyFloatOptions(item_id int, name string, value Float.X, this_inventory_update_handle int) bool { //gd:Steam.setPropertyFloat
	once.Do(singleton)
	return bool(Advanced().SetPropertyFloat(int64(item_id), String.New(name), float64(value), int64(this_inventory_update_handle)))
}

/*
Gets the details of the favorite game server by index.
The returned array contains a list of:
[codeblock]
┖╴favorite (dictionary)

	┠╴ret (bool)
	┠╴app (int)
	┠╴ip (string)
	┠╴game_port (int)
	┠╴query_port (int)
	┠╴flags (int)
	┖╴last_played (int)

[/codeblock]
*/
func GetFavoriteGames() []any { //gd:Steam.getFavoriteGames
	once.Do(singleton)
	return []any(gd.ArrayAs[[]any](gd.InternalArray(Advanced().GetFavoriteGames())))
}

/*
Adds the game server to the local list; updates the time played of the server if it already exists in the list.
*/
func AddFavoriteGame(ip string, port int, query_port int, flags int, last_played int) int { //gd:Steam.addFavoriteGame
	once.Do(singleton)
	return int(int(Advanced().AddFavoriteGame(String.New(ip), int64(port), int64(query_port), int64(flags), int64(last_played))))
}

/*
Removes the game server from the local favorites list.
*/
func RemoveFavoriteGame(app_id int, ip string, port int, query_port int, flags int) bool { //gd:Steam.removeFavoriteGame
	once.Do(singleton)
	return bool(Advanced().RemoveFavoriteGame(int64(app_id), String.New(ip), int64(port), int64(query_port), int64(flags)))
}

/*
Get a filtered list of relevant lobbies.
There can only be one active lobby search at a time. The old request will be canceled if a new one is started. Depending on the users connection to the Steam back-end, this call can take from 300ms to 5 seconds to complete, and has a timeout of 20 seconds.
Triggers a [signal Steam.lobby_match_list] callback.
[b]Note:[/b] To filter the results you must call the addRequestLobbyList functions before calling this. The filters are cleared on each call to this function.
[b]Note:[/b] If [method Steam.addRequestLobbyListDistanceFilter] is not called, k_ELobbyDistanceFilterDefault will be used, which will only find matches in the same or nearby regions.
[b]Note:[/b] This will only return lobbies that are not full, and only lobbies that are public (2) or invisible (3), and are set to joinable with [method Steam.setLobbyJoinable].
*/
func RequestLobbyList() { //gd:Steam.requestLobbyList
	once.Do(singleton)
	Advanced().RequestLobbyList()
}

/*
Adds a string comparison filter to the next [method Steam.requestLobbyList] call.
*/
func AddRequestLobbyListStringFilter(key_to_match string, value_to_match string, comparison_type LobbyComparison) { //gd:Steam.addRequestLobbyListStringFilter
	once.Do(singleton)
	Advanced().AddRequestLobbyListStringFilter(String.New(key_to_match), String.New(value_to_match), comparison_type)
}

/*
Adds a numerical comparison filter to the next [method Steam.requestLobbyList] call.
*/
func AddRequestLobbyListNumericalFilter(key_to_match string, value_to_match int, comparison_type LobbyComparison) { //gd:Steam.addRequestLobbyListNumericalFilter
	once.Do(singleton)
	Advanced().AddRequestLobbyListNumericalFilter(String.New(key_to_match), int64(value_to_match), comparison_type)
}

/*
Sorts the results closest to the specified value
Near filters don't actually filter out values, they just influence how the results are sorted. You can specify multiple near filters, with the first near filter influencing the most, and the last near filter influencing the least.
*/
func AddRequestLobbyListNearValueFilter(key_to_match string, value_to_be_close_to int) { //gd:Steam.addRequestLobbyListNearValueFilter
	once.Do(singleton)
	Advanced().AddRequestLobbyListNearValueFilter(String.New(key_to_match), int64(value_to_be_close_to))
}

/*
Filters to only return lobbies with the specified number of open slots available.
*/
func AddRequestLobbyListFilterSlotsAvailable(slots_available int) { //gd:Steam.addRequestLobbyListFilterSlotsAvailable
	once.Do(singleton)
	Advanced().AddRequestLobbyListFilterSlotsAvailable(int64(slots_available))
}

/*
Sets the physical distance for which we should search for lobbies, this is based on the users IP address and a IP location map on the Steam backed.
*/
func AddRequestLobbyListDistanceFilter(distance_filter LobbyDistanceFilter) { //gd:Steam.addRequestLobbyListDistanceFilter
	once.Do(singleton)
	Advanced().AddRequestLobbyListDistanceFilter(distance_filter)
}

/*
Sets the maximum number of lobbies to return. The lower the count the faster it is to download the lobby results and details to the client.
*/
func AddRequestLobbyListResultCountFilter(max_results int) { //gd:Steam.addRequestLobbyListResultCountFilter
	once.Do(singleton)
	Advanced().AddRequestLobbyListResultCountFilter(int64(max_results))
}

/*
Create a new matchmaking lobby.
Triggers all three callbacks: [signal Steam.lobby_created], [signal Steam.lobby_joined], and [signal Steam.lobby_data_update].
If the results returned via the [signal Steam.lobby_created] call result indicate success then the lobby is joined and ready to use at this point.
*/
func CreateLobby(lobby_type LobbyType) { //gd:Steam.createLobby
	once.Do(singleton)
	Advanced().CreateLobby(lobby_type, int64(2))
}

/*
Create a new matchmaking lobby.
Triggers all three callbacks: [signal Steam.lobby_created], [signal Steam.lobby_joined], and [signal Steam.lobby_data_update].
If the results returned via the [signal Steam.lobby_created] call result indicate success then the lobby is joined and ready to use at this point.
*/
func CreateLobbyOptions(lobby_type LobbyType, max_members int) { //gd:Steam.createLobby
	once.Do(singleton)
	Advanced().CreateLobby(lobby_type, int64(max_members))
}

/*
Joins an existing lobby.
The lobby Steam ID can be obtained either from a search with [method Steam.requestLobbyList] joining on a friend, or from an invite.
Triggers a [signal Steam.lobby_joined] callback for other users.
*/
func JoinLobby(steam_lobby_id int) { //gd:Steam.joinLobby
	once.Do(singleton)
	Advanced().JoinLobby(int64(steam_lobby_id))
}

/*
Leave a lobby that the user is currently in; this will take effect immediately on the client side, other users in the lobby will be notified by a [signal Steam.lobby_chat_update] callback.
*/
func LeaveLobby(steam_lobby_id int) { //gd:Steam.leaveLobby
	once.Do(singleton)
	Advanced().LeaveLobby(int64(steam_lobby_id))
}

/*
Invite another user to the lobby.
If the specified user clicks the join link, a join_requested callback will be posted if the user is in-game, or if the game isn't running yet then the game will be automatically launched with the command line parameter +connect_lobby (64-bit lobby Steam ID) instead.
*/
func InviteUserToLobby(steam_lobby_id int, steam_id_invitee int) bool { //gd:Steam.inviteUserToLobby
	once.Do(singleton)
	return bool(Advanced().InviteUserToLobby(int64(steam_lobby_id), int64(steam_id_invitee)))
}

/*
Gets the number of users in a lobby.
This is used for iteration, after calling this then [method Steam.getLobbyMemberByIndex] can be used to get the Steam ID of each person in the lobby. Persona information for other lobby members (name, avatar, etc.) is automatically received and accessible via the SteamFriends interface.
[b]Note:[/b] The current user must be in the lobby to retrieve the Steam IDs of other users in that lobby.
*/
func GetNumLobbyMembers(steam_lobby_id int) int { //gd:Steam.getNumLobbyMembers
	once.Do(singleton)
	return int(int(Advanced().GetNumLobbyMembers(int64(steam_lobby_id))))
}

/*
Gets the Steam ID of the lobby member at the given index.
[b]Note:[/b] You must call [method Steam.getNumLobbyMembers] before calling this.
[b]Note:[/b] The current user must be in the lobby to retrieve the Steam IDs of other users in that lobby.
*/
func GetLobbyMemberByIndex(steam_lobby_id int, member int) int { //gd:Steam.getLobbyMemberByIndex
	once.Do(singleton)
	return int(int(Advanced().GetLobbyMemberByIndex(int64(steam_lobby_id), int64(member))))
}

/*
Gets the metadata associated with the specified key from the specified lobby.
Returns an empty string if no value is set for this key, or if steam_lobby_id is invalid.
[b]Note:[/b] This can only get metadata from lobbies that the client knows about, either after receiving a list of lobbies from [signal Steam.lobby_match_list], retrieving the data with [method Steam.requestLobbyData] or after joining a lobby.
*/
func GetLobbyData(steam_lobby_id int, key string) string { //gd:Steam.getLobbyData
	once.Do(singleton)
	return string(Advanced().GetLobbyData(int64(steam_lobby_id), String.New(key)).String())
}

/*
Sets a key/value pair in the lobby metadata. This can be used to set the the lobby name, current map, game mode, etc.
This can only be set by the owner of the lobby. Lobby members should use [method Steam.setLobbyMemberData] instead.
Each user in the lobby will be receive notification of the lobby data change via a [signal Steam.lobby_data_update] callback, and any new users joining will receive any existing data.
This will only send the data if it has changed. There is a slight delay before sending the data so you can call this repeatedly to set all the data you need to and it will automatically be batched up and sent after the last sequential call.
True if the data has been set successfully. False if steam_lobby_id was invalid, or the key/value are too long.
*/
func SetLobbyData(steam_lobby_id int, key string, value string) bool { //gd:Steam.setLobbyData
	once.Do(singleton)
	return bool(Advanced().SetLobbyData(int64(steam_lobby_id), String.New(key), String.New(value)))
}

/*
Get lobby data by the lobby's ID.
The returned dictionary contains the following keys: [b]index (int), key (string), and value (string).[/b]
[b]Note:[/b] This is a GodotSteam specific function.
*/
func GetAllLobbyData(steam_lobby_id int) map[any]any { //gd:Steam.getAllLobbyData
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetAllLobbyData(int64(steam_lobby_id))))
}

/*
Removes a metadata key from the lobby.
This can only be done by the owner of the lobby.
This will only send the data if the key existed. There is a slight delay before sending the data so you can call this repeatedly to set all the data you need to and it will automatically be batched up and sent after the last sequential call.
*/
func DeleteLobbyData(steam_lobby_id int, key string) bool { //gd:Steam.deleteLobbyData
	once.Do(singleton)
	return bool(Advanced().DeleteLobbyData(int64(steam_lobby_id), String.New(key)))
}

/*
Gets per-user metadata from another player in the specified lobby.
This can only be queried from members in lobbies that you are currently in.
Returns NULL if steam_lobby_id is invalid, or steam_user_id is not in the lobby. Returns an empty string if key is not set for the player.
*/
func GetLobbyMemberData(steam_lobby_id int, steam_id_user int, key string) string { //gd:Steam.getLobbyMemberData
	once.Do(singleton)
	return string(Advanced().GetLobbyMemberData(int64(steam_lobby_id), int64(steam_id_user), String.New(key)).String())
}

/*
Sets per-user metadata for the local user.
Each user in the lobby will be receive notification of the lobby data change via a [signal Steam.lobby_data_update] callback, and any new users joining will receive any existing data.
There is a slight delay before sending the data so you can call this repeatedly to set all the data you need to and it will automatically be batched up and sent after the last sequential call.
Triggers a [signal Steam.lobby_data_update] callback.
*/
func SetLobbyMemberData(steam_lobby_id int, key string, value string) { //gd:Steam.setLobbyMemberData
	once.Do(singleton)
	Advanced().SetLobbyMemberData(int64(steam_lobby_id), String.New(key), String.New(value))
}

/*
Broadcasts a chat (text or binary data) message to the all of the users in the lobby. All users in the lobby (including the local user) will receive a [signal Steam.lobby_message] callback with the message.
For communication that needs to be arbitrated (for example having a user pick from a set of characters, and making sure only one user has picked a character), you can use the lobby owner as the decision maker. [method Steam.getLobbyOwner] returns the current lobby owner. There is guaranteed to always be one and only one lobby member who is the owner. So for the choose-a-character scenario, the user who is picking a character would send the binary message 'I want to be Zoe', the lobby owner would see that message, see if it was OK, and broadcast the appropriate result (user X is Zoe).
These messages are sent via the Steam back-end, and so the bandwidth available is limited. For higher-volume traffic like voice or game data, you'll want to use the Steam Networking API.
Triggers a [signal Steam.lobby_message] callback.
*/
func SendLobbyChatMsg(steam_lobby_id int, message_body string) bool { //gd:Steam.sendLobbyChatMsg
	once.Do(singleton)
	return bool(Advanced().SendLobbyChatMsg(int64(steam_lobby_id), String.New(message_body)))
}

/*
Refreshes all of the metadata for a lobby that you're not in right now.
You will never do this for lobbies you're a member of, that data will always be up to date. You can use this to refresh lobbies that you have obtained from [method Steam.requestLobbyList] or that are available via friends.
Triggers a [signal Steam.lobby_data_update] callback.
True if the request was successfully sent to the server. False if no connection to Steam could be made, or steam_lobby_id is invalid.
*/
func RequestLobbyData(steam_lobby_id int) bool { //gd:Steam.requestLobbyData
	once.Do(singleton)
	return bool(Advanced().RequestLobbyData(int64(steam_lobby_id)))
}

/*
Sets the game server associated with the lobby.
This can only be set by the owner of the lobby.
Either the IP/Port or the Steam ID of the game server must be valid, depending on how you want the clients to be able to connect.
A [signal Steam.lobby_game_created] callback will be sent to all players in the lobby, usually at this point, the users will join the specified game server.
Triggers a [signal Steam.lobby_game_created] callback.
*/
func SetLobbyGameServer(steam_lobby_id int, server_port int, steam_id_game_server int) { //gd:Steam.setLobbyGameServer
	once.Do(singleton)
	Advanced().SetLobbyGameServer(int64(steam_lobby_id), String.New("0"), int64(server_port), int64(steam_id_game_server))
}

/*
Sets the game server associated with the lobby.
This can only be set by the owner of the lobby.
Either the IP/Port or the Steam ID of the game server must be valid, depending on how you want the clients to be able to connect.
A [signal Steam.lobby_game_created] callback will be sent to all players in the lobby, usually at this point, the users will join the specified game server.
Triggers a [signal Steam.lobby_game_created] callback.
*/
func SetLobbyGameServerOptions(steam_lobby_id int, server_ip string, server_port int, steam_id_game_server int) { //gd:Steam.setLobbyGameServer
	once.Do(singleton)
	Advanced().SetLobbyGameServer(int64(steam_lobby_id), String.New(server_ip), int64(server_port), int64(steam_id_game_server))
}

/*
Gets the details of a game server set in a lobby. Either the IP/Port or the Steam ID of the game server has to be valid, depending on how you want the clients to be able to connect.
The returned dictionary contains the following keys:
[codeblock]
┠╴ret (bool) - true if the lobby is valid and has a valid game server set; otherwise, false.
┠╴ip (string)
┠╴port (int)
┖╴id (int)
[/codeblock]
*/
func GetLobbyGameServer(steam_lobby_id int) map[any]any { //gd:Steam.getLobbyGameServer
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetLobbyGameServer(int64(steam_lobby_id))))
}

/*
Set the maximum number of players that can join the lobby.
This is also set when you create the lobby with [method Steam.createLobby].
This can only be set by the owner of the lobby.
*/
func SetLobbyMemberLimit(steam_lobby_id int, max_members int) bool { //gd:Steam.setLobbyMemberLimit
	once.Do(singleton)
	return bool(Advanced().SetLobbyMemberLimit(int64(steam_lobby_id), int64(max_members)))
}

/*
The current limit on the number of users who can join the lobby.
*/
func GetLobbyMemberLimit(steam_lobby_id int) int { //gd:Steam.getLobbyMemberLimit
	once.Do(singleton)
	return int(int(Advanced().GetLobbyMemberLimit(int64(steam_lobby_id))))
}

/*
Updates what type of lobby this is.
This is also set when you create the lobby with [method Steam.createLobby].
This can only be set by the owner of the lobby.
*/
func SetLobbyType(steam_lobby_id int, lobby_type LobbyType) bool { //gd:Steam.setLobbyType
	once.Do(singleton)
	return bool(Advanced().SetLobbyType(int64(steam_lobby_id), lobby_type))
}

/*
Sets whether or not a lobby is joinable by other players. This always defaults to enabled for a new lobby.
If joining is disabled, then no players can join, even if they are a friend or have been invited.
Lobbies with joining disabled will not be returned from a lobby search.
True upon success; otherwise, false if you're not the owner of the lobby.
*/
func SetLobbyJoinable(steam_lobby_id int, joinable bool) bool { //gd:Steam.setLobbyJoinable
	once.Do(singleton)
	return bool(Advanced().SetLobbyJoinable(int64(steam_lobby_id), joinable))
}

/*
Returns the current lobby owner.
[b]Note:[/b] You must be a member of the lobby to access this. There always one lobby owner - if the current owner leaves, another user in the lobby will become the owner automatically. It is possible (but rare) to join a lobby just as the owner is leaving, thus entering a lobby with self as the owner.
*/
func GetLobbyOwner(steam_lobby_id int) int { //gd:Steam.getLobbyOwner
	once.Do(singleton)
	return int(int(Advanced().GetLobbyOwner(int64(steam_lobby_id))))
}

/*
Changes who the lobby owner is.
This can only be set by the owner of the lobby. This will trigger a [signal Steam.lobby_data_update] for all of the users in the lobby, each user should update their local state to reflect the new owner. This is typically accomplished by displaying a crown icon next to the owners name.
Triggers a [signal Steam.lobby_data_update] callback.
*/
func SetLobbyOwner(steam_lobby_id int, steam_id_new_owner int) bool { //gd:Steam.setLobbyOwner
	once.Do(singleton)
	return bool(Advanced().SetLobbyOwner(int64(steam_lobby_id), int64(steam_id_new_owner)))
}

/*
Cancel an outstanding server list request.
You should call this to cancel any in-progress requests before destructing a callback object that may have been passed to one of the below request calls. Not doing so may result in a crash when a callback occurs on the destructed object. Canceling a query does not release the allocated request handle. The request handle must be released using [method Steam.releaseRequest].
You can pass a server_list_request handle or, if you do not, it will use the last internally stored one.
*/
func CancelQuery(server_list_request int) { //gd:Steam.cancelQuery
	once.Do(singleton)
	Advanced().CancelQuery(int64(server_list_request))
}

/*
Cancel an outstanding individual server query.
The calls that create this type of query are: [method Steam.pingServer], [method Steam.playerDetails], and [method Steam.serverRules]. You should call this to cancel any in-progress requests before destructing a callback object that may have been passed to one of the above calls to avoid crashing when callbacks occur.
*/
func CancelServerQuery(server_query int) { //gd:Steam.cancelServerQuery
	once.Do(singleton)
	Advanced().CancelServerQuery(int64(server_query))
}

/*
Gets the number of servers in the given list. This is used for iterating with [method Steam.getServerDetails].
You can pass a server_list_request handle or, if you do not, it will use the last internally stored one.
*/
func GetServerCount(server_list_request int) int { //gd:Steam.getServerCount
	once.Do(singleton)
	return int(int(Advanced().GetServerCount(int64(server_list_request))))
}

/*
Get the details of a given server in the list.
You can get the valid range of index values by calling [method Steam.getServerCount]. You will also receive index values in server_responded callbacks.
You can pass a server_list_request handle or, if you do not, it will use the last internally stored one.
The returned dictionary contains the following keys:
[codeblock]
┠╴ping (int)
┠╴success_response (bool)
┠╴no_refresh (bool)
┠╴game_dir (string)
┠╴map (string)
┠╴description (string)
┠╴app_id (int)
┠╴players (int)
┠╴max_players (int)
┠╴bot_players (int)
┠╴password (bool)
┠╴secure (bool)
┠╴last_played (int)
┖╴server_version (int)
[/codeblock]
*/
func GetServerDetails(server int, server_list_request int) map[any]any { //gd:Steam.getServerDetails
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetServerDetails(int64(server), int64(server_list_request))))
}

/*
Checks if the server list request is currently refreshing.
You can pass a server_list_request handle or, if you do not, it will use the last internally stored one.
*/
func IsRefreshing(server_list_request int) bool { //gd:Steam.isRefreshing
	once.Do(singleton)
	return bool(Advanced().IsRefreshing(int64(server_list_request)))
}

/*
Queries an individual game server directly via IP/Port to request an updated ping time and other details from the server.
You must inherit from the ISteamMatchmakingPingResponse object to receive this callback.
[b]Currently not enabled.[/b]
*/
func PingServer(ip string, port int) int { //gd:Steam.pingServer
	once.Do(singleton)
	return int(int(Advanced().PingServer(String.New(ip), int64(port))))
}

/*
Queries an individual game server directly via IP/Port to request the list of players currently playing on the server.
You must inherit from the ISteamMatchmakingPlayersResponse object to receive this callback.
[b]Currently not enabled.[/b]
*/
func PlayerDetails(ip string, port int) int { //gd:Steam.playerDetails
	once.Do(singleton)
	return int(int(Advanced().PlayerDetails(String.New(ip), int64(port))))
}

/*
Ping every server in your list again but don't update the list of servers.
The query callback installed when the server list was requested will be used again to post notifications and refresh_complete will be called again, so the callback must remain valid until it completes or the request is released with [method Steam.releaseRequest].
You can pass a server_list_request handle or, if you do not, it will use the last internally stored one.
The returned array contains a list of:
[codeblock]
┖╴messages (dictionary):

	┠╴payload (string)
	┠╴size (int)
	┠╴connection (int)
	┠╴identity (string)
	┠╴user_data (int)
	┠╴time_received (int)
	┠╴message_number (int)
	┠╴channel (int)
	┠╴flags (int)
	┖╴user_data (int)

[/codeblock]
*/
func RefreshQuery(server_list_request int) { //gd:Steam.refreshQuery
	once.Do(singleton)
	Advanced().RefreshQuery(int64(server_list_request))
}

/*
Refreshes a single server inside of a query.
If you want to refresh all of the servers then you should use [method Steam.refreshQuery].
You can pass a server_list_request handle or, if you do not, it will use the last internally stored one.
*/
func RefreshServer(server int, server_list_request int) { //gd:Steam.refreshServer
	once.Do(singleton)
	Advanced().RefreshServer(int64(server), int64(server_list_request))
}

/*
Releases the asynchronous server list request object and cancels any pending query on it if there's a pending query in progress.
You can pass a server_list_request handle or, if you do not, it will use the last internally stored one.
*/
func ReleaseRequest(server_list_request int) { //gd:Steam.releaseRequest
	once.Do(singleton)
	Advanced().ReleaseRequest(int64(server_list_request))
}

/*
Request a new list of game servers from the 'favorites' server list.
See MatchMakingKeyValuePair_t for more information.
*/
func RequestFavoritesServerList(app_id int, filters []any) int { //gd:Steam.requestFavoritesServerList
	once.Do(singleton)
	return int(int(Advanced().RequestFavoritesServerList(int64(app_id), gd.EngineArrayFromSlice(filters))))
}

/*
Request a new list of game servers from the 'friends' server list.
See MatchMakingKeyValuePair_t for more information.
*/
func RequestFriendsServerList(app_id int, filters []any) int { //gd:Steam.requestFriendsServerList
	once.Do(singleton)
	return int(int(Advanced().RequestFriendsServerList(int64(app_id), gd.EngineArrayFromSlice(filters))))
}

/*
Request a new list of game servers from the 'history' server list.
See MatchMakingKeyValuePair_t for more information.
*/
func RequestHistoryServerList(app_id int, filters []any) int { //gd:Steam.requestHistoryServerList
	once.Do(singleton)
	return int(int(Advanced().RequestHistoryServerList(int64(app_id), gd.EngineArrayFromSlice(filters))))
}

/*
Request a new list of game servers from the 'internet' server list.
See MatchMakingKeyValuePair_t for more information.
*/
func RequestInternetServerList(app_id int, filters []any) int { //gd:Steam.requestInternetServerList
	once.Do(singleton)
	return int(int(Advanced().RequestInternetServerList(int64(app_id), gd.EngineArrayFromSlice(filters))))
}

/*
Request a new list of game servers from the 'LAN' server list.
See MatchMakingKeyValuePair_t for more information.
*/
func RequestLANServerList(app_id int) int { //gd:Steam.requestLANServerList
	once.Do(singleton)
	return int(int(Advanced().RequestLANServerList(int64(app_id))))
}

/*
Request a new list of game servers from the 'spectator' server list.
See MatchMakingKeyValuePair_t for more information.
*/
func RequestSpectatorServerList(app_id int, filters []any) int { //gd:Steam.requestSpectatorServerList
	once.Do(singleton)
	return int(int(Advanced().RequestSpectatorServerList(int64(app_id), gd.EngineArrayFromSlice(filters))))
}

/*
Queries an individual game server directly via IP/Port to request the list of rules that the server is running. (See setKeyValue to set the rules on the server side.)
You must inherit from the ISteamMatchmakingRulesResponse object to receive this callback.
*/
func ServerRules(ip string, port int) int { //gd:Steam.serverRules
	once.Do(singleton)
	return int(int(Advanced().ServerRules(String.New(ip), int64(port))))
}

/*
Checks if Steam Music is enabled.
*/
func MusicIsEnabled() bool { //gd:Steam.musicIsEnabled
	once.Do(singleton)
	return bool(Advanced().MusicIsEnabled())
}

/*
Checks if Steam Music is active. This does not necessarily a song is currently playing, it may be paused. For finer grain control use [method Steam.getPlaybackStatus].
*/
func MusicIsPlaying() bool { //gd:Steam.musicIsPlaying
	once.Do(singleton)
	return bool(Advanced().MusicIsPlaying())
}

/*
Gets the current status of the Steam Music player.
*/
func GetPlaybackStatus() AudioPlaybackStatus { //gd:Steam.getPlaybackStatus
	once.Do(singleton)
	return AudioPlaybackStatus(Advanced().GetPlaybackStatus())
}

/*
Gets the current volume of the Steam Music player.
*/
func MusicGetVolume() Float.X { //gd:Steam.musicGetVolume
	once.Do(singleton)
	return Float.X(Float.X(Advanced().MusicGetVolume()))
}

/*
Pause the Steam Music player.
*/
func MusicPause() { //gd:Steam.musicPause
	once.Do(singleton)
	Advanced().MusicPause()
}

/*
Have the Steam Music player resume playing.
*/
func MusicPlay() { //gd:Steam.musicPlay
	once.Do(singleton)
	Advanced().MusicPlay()
}

/*
Have the Steam Music player skip to the next song.
*/
func MusicPlayNext() { //gd:Steam.musicPlayNext
	once.Do(singleton)
	Advanced().MusicPlayNext()
}

/*
Have the Steam Music player play the previous song.
*/
func MusicPlayPrev() { //gd:Steam.musicPlayPrev
	once.Do(singleton)
	Advanced().MusicPlayPrev()
}

/*
Sets the volume of the Steam Music player.
*/
func MusicSetVolume(volume Float.X) { //gd:Steam.musicSetVolume
	once.Do(singleton)
	Advanced().MusicSetVolume(float64(volume))
}

/*
If remote access was successfully activated.
*/
func ActivationSuccess(activate bool) bool { //gd:Steam.activationSuccess
	once.Do(singleton)
	return bool(Advanced().ActivationSuccess(activate))
}

/*
Is a remote music client / host connected?
*/
func IsCurrentMusicRemote() bool { //gd:Steam.isCurrentMusicRemote
	once.Do(singleton)
	return bool(Advanced().IsCurrentMusicRemote())
}

/*
Did the current music entry just change?
*/
func CurrentEntryDidChange() bool { //gd:Steam.currentEntryDidChange
	once.Do(singleton)
	return bool(Advanced().CurrentEntryDidChange())
}

/*
Is the current music entry available?
*/
func CurrentEntryIsAvailable(available bool) bool { //gd:Steam.currentEntryIsAvailable
	once.Do(singleton)
	return bool(Advanced().CurrentEntryIsAvailable(available))
}

/*
Will the current music entry change?
*/
func CurrentEntryWillChange() bool { //gd:Steam.currentEntryWillChange
	once.Do(singleton)
	return bool(Advanced().CurrentEntryWillChange())
}

/*
Disconnect from remote music client / host.
*/
func DeregisterSteamMusicRemote() bool { //gd:Steam.deregisterSteamMusicRemote
	once.Do(singleton)
	return bool(Advanced().DeregisterSteamMusicRemote())
}

/*
Enable track loop on client.
*/
func EnableLooped(loop bool) bool { //gd:Steam.enableLooped
	once.Do(singleton)
	return bool(Advanced().EnableLooped(loop))
}

/*
Enable playlists on client.
*/
func EnablePlaylists(playlists bool) bool { //gd:Steam.enablePlaylists
	once.Do(singleton)
	return bool(Advanced().EnablePlaylists(playlists))
}

/*
Play the next track on client.
*/
func EnablePlayNext(next bool) bool { //gd:Steam.enablePlayNext
	once.Do(singleton)
	return bool(Advanced().EnablePlayNext(next))
}

/*
Play previous track on client.
*/
func EnablePlayPrevious(previous bool) bool { //gd:Steam.enablePlayPrevious
	once.Do(singleton)
	return bool(Advanced().EnablePlayPrevious(previous))
}

/*
Enable the music queue on the client.
*/
func EnableQueue(queue bool) bool { //gd:Steam.enableQueue
	once.Do(singleton)
	return bool(Advanced().EnableQueue(queue))
}

/*
Enable shuffle on the client.
*/
func EnableShuffled(shuffle bool) bool { //gd:Steam.enableShuffled
	once.Do(singleton)
	return bool(Advanced().EnableShuffled(shuffle))
}

/*
Has the playlist changed?
*/
func PlaylistDidChange() bool { //gd:Steam.playlistDidChange
	once.Do(singleton)
	return bool(Advanced().PlaylistDidChange())
}

/*
Will the playlist change?
*/
func PlaylistWillChange() bool { //gd:Steam.playlistWillChange
	once.Do(singleton)
	return bool(Advanced().PlaylistWillChange())
}

/*
Did the song queue change?
*/
func QueueDidChange() bool { //gd:Steam.queueDidChange
	once.Do(singleton)
	return bool(Advanced().QueueDidChange())
}

/*
Will the song queue change?
*/
func QueueWillChange() bool { //gd:Steam.queueWillChange
	once.Do(singleton)
	return bool(Advanced().QueueWillChange())
}

/*
Connect to a music remote client / host?
*/
func RegisterSteamMusicRemote(name string) bool { //gd:Steam.registerSteamMusicRemote
	once.Do(singleton)
	return bool(Advanced().RegisterSteamMusicRemote(String.New(name)))
}

/*
Reset the playlist entries.
*/
func ResetPlaylistEntries() bool { //gd:Steam.resetPlaylistEntries
	once.Do(singleton)
	return bool(Advanced().ResetPlaylistEntries())
}

/*
Reset the song queue entries.
*/
func ResetQueueEntries() bool { //gd:Steam.resetQueueEntries
	once.Do(singleton)
	return bool(Advanced().ResetQueueEntries())
}

/*
Set a new current playlist.
*/
func SetCurrentPlaylistEntry(id int) bool { //gd:Steam.setCurrentPlaylistEntry
	once.Do(singleton)
	return bool(Advanced().SetCurrentPlaylistEntry(int64(id)))
}

/*
Set a new current song queue.
*/
func SetCurrentQueueEntry(id int) bool { //gd:Steam.setCurrentQueueEntry
	once.Do(singleton)
	return bool(Advanced().SetCurrentQueueEntry(int64(id)))
}

/*
Set a new display name.
*/
func SetDisplayName(name string) bool { //gd:Steam.setDisplayName
	once.Do(singleton)
	return bool(Advanced().SetDisplayName(String.New(name)))
}

/*
Set a new playlist entry.
*/
func SetPlaylistEntry(id int, position int, entry_text string) bool { //gd:Steam.setPlaylistEntry
	once.Do(singleton)
	return bool(Advanced().SetPlaylistEntry(int64(id), int64(position), String.New(entry_text)))
}

/*
Set a PNG icon for a song? A playlist?
*/
func SetPNGIcon64x64(icon []byte) bool { //gd:Steam.setPNGIcon64x64
	once.Do(singleton)
	return bool(Advanced().SetPNGIcon64x64(Packed.Bytes(Packed.New(icon...))))
}

/*
Set a new queue entry.
*/
func SetQueueEntry(id int, position int, entry_text string) bool { //gd:Steam.setQueueEntry
	once.Do(singleton)
	return bool(Advanced().SetQueueEntry(int64(id), int64(position), String.New(entry_text)))
}

/*
Update the current song entry's cover art.
*/
func UpdateCurrentEntryCoverArt(art []byte) bool { //gd:Steam.updateCurrentEntryCoverArt
	once.Do(singleton)
	return bool(Advanced().UpdateCurrentEntryCoverArt(Packed.Bytes(Packed.New(art...))))
}

/*
Update the current seconds that have elapsed for an entry.
*/
func UpdateCurrentEntryElapsedSeconds(seconds int) bool { //gd:Steam.updateCurrentEntryElapsedSeconds
	once.Do(singleton)
	return bool(Advanced().UpdateCurrentEntryElapsedSeconds(int64(seconds)))
}

/*
Update the current song entry's text?
*/
func UpdateCurrentEntryText(text string) bool { //gd:Steam.updateCurrentEntryText
	once.Do(singleton)
	return bool(Advanced().UpdateCurrentEntryText(String.New(text)))
}

/*
Update looped or not.
*/
func UpdateLooped(looped bool) bool { //gd:Steam.updateLooped
	once.Do(singleton)
	return bool(Advanced().UpdateLooped(looped))
}

/*
Update the current playback status:
[codeblock]
• 0 / undefined
• 1 / playing
• 2 / paused
• 3 / idle
[/codeblock]
*/
func UpdatePlaybackStatus(status AudioPlaybackStatus) bool { //gd:Steam.updatePlaybackStatus
	once.Do(singleton)
	return bool(Advanced().UpdatePlaybackStatus(status))
}

/*
Update whether to shuffle or not.
*/
func UpdateShuffled(shuffle bool) bool { //gd:Steam.updateShuffled
	once.Do(singleton)
	return bool(Advanced().UpdateShuffled(shuffle))
}

/*
Volume is between 0.0 and 1.0.
*/
func UpdateVolume(volume Float.X) bool { //gd:Steam.updateVolume
	once.Do(singleton)
	return bool(Advanced().UpdateVolume(float64(volume)))
}

/*
This allows the game to specify accept an incoming packet. This needs to be called before a real connection is established to a remote host, the game will get a chance to say whether or not the remote user is allowed to talk to them.
When a remote user that you haven't sent a packet to recently, tries to first send you a packet, your game will receive a callback [signal Steam.p2p_session_request]. This callback contains the Steam ID of the user who wants to send you a packet. In response to this callback, you'll want to see if it's someone you want to talk to (for example, if they're in a lobby with you), and if so, accept the connection; otherwise if you don't want to talk to the user, just ignore the request. If the user continues to send you packets, another [signal Steam.p2p_session_request] will be posted periodically. If you've called [method Steam.sendP2PPacket] on the other user, this implicitly accepts the session request.
[b]Note:[/b] This call should only be made in response to a [signal Steam.p2p_session_request] callback.
*/
func AcceptP2PSessionWithUser(remote_steam_id int) bool { //gd:Steam.acceptP2PSessionWithUser
	once.Do(singleton)
	return bool(Advanced().AcceptP2PSessionWithUser(int64(remote_steam_id)))
}

/*
Allow or disallow P2P connections to fall back to being relayed through the Steam servers if a direct connection or NAT-traversal cannot be established.
This only applies to connections created after setting this value, or to existing connections that need to automatically reconnect after this value is set.
P2P packet relay is allowed by default.
*/
func AllowP2PPacketRelay(allow bool) bool { //gd:Steam.allowP2PPacketRelay
	once.Do(singleton)
	return bool(Advanced().AllowP2PPacketRelay(allow))
}

/*
Closes a P2P channel when you're done talking to a user on the specific channel.
Once all channels to a user have been closed, the open session to the user will be closed and new data from this user will trigger a new [signal Steam.p2p_session_request] callback.
*/
func CloseP2PChannelWithUser(remote_steam_id int, channel int) bool { //gd:Steam.closeP2PChannelWithUser
	once.Do(singleton)
	return bool(Advanced().CloseP2PChannelWithUser(int64(remote_steam_id), int64(channel)))
}

/*
This should be called when you're done communicating with a user, as this will free up all of the resources allocated for the connection under-the-hood.
If the remote user tries to send data to you again, a new [signal Steam.p2p_session_request] callback will be posted.
*/
func CloseP2PSessionWithUser(remote_steam_id int) bool { //gd:Steam.closeP2PSessionWithUser
	once.Do(singleton)
	return bool(Advanced().CloseP2PSessionWithUser(int64(remote_steam_id)))
}

/*
Fills out a dictionary with details about the connection like whether or not there is an active connection; number of bytes queued on the connection; the last error code, if any; whether or not a relay server is being used; and the IP and Port of the remote user, if known.
This should only needed for debugging purposes.
The returned dictionary contains the following keys:
[codeblock]
┠╴connection_active (bool)
┠╴connecting (bool)
┠╴session_error (int)
┠╴using_relay (bool)
┠╴bytes_queued_for_send (int)
┠╴packets_queued_for_send (int)
┠╴remote_ip (int)
┖╴remote_port (int)
[/codeblock]
*/
func GetP2PSessionState(remote_steam_id int) map[any]any { //gd:Steam.getP2PSessionState
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetP2PSessionState(int64(remote_steam_id))))
}

/*
Calls isP2PPacketAvailable under the hood, returns the size of the available packet or zero if there is no such packet.
*/
func GetAvailableP2PPacketSize(channel int) int { //gd:Steam.getAvailableP2PPacketSize
	once.Do(singleton)
	return int(int(Advanced().GetAvailableP2PPacketSize(int64(channel))))
}

/*
Calls isP2PPacketAvailable under the hood, returns the size of the available packet or zero if there is no such packet.
*/
func GetAvailableP2PPacketSizeOptions(channel int) int { //gd:Steam.getAvailableP2PPacketSize
	once.Do(singleton)
	return int(int(Advanced().GetAvailableP2PPacketSize(int64(channel))))
}

/*
Reads in a packet that has been sent from another user via [method Steam.sendP2PPacket].
This call is not blocking, and will return false if no data is available.
Before calling this you should have called [method Steam.getAvailableP2PPacketSize].
The returned dictionary contains the following keys:
[codeblock]
┠╴data (PackedByteArray)
┖╴remote_steam_id (int)
[/codeblock]
*/
func ReadP2PPacket(packet int, channel int) map[any]any { //gd:Steam.readP2PPacket
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().ReadP2PPacket(int64(packet), int64(channel))))
}

/*
Reads in a packet that has been sent from another user via [method Steam.sendP2PPacket].
This call is not blocking, and will return false if no data is available.
Before calling this you should have called [method Steam.getAvailableP2PPacketSize].
The returned dictionary contains the following keys:
[codeblock]
┠╴data (PackedByteArray)
┖╴remote_steam_id (int)
[/codeblock]
*/
func ReadP2PPacketOptions(packet int, channel int) map[any]any { //gd:Steam.readP2PPacket
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().ReadP2PPacket(int64(packet), int64(channel))))
}

/*
Sends a P2P packet to the specified user.
This is a session-less API which automatically establishes NAT-traversing or Steam relay server connections.
See EP2PSend for descriptions of the different ways of sending packets. The integers passed in GodotSteam are:
[codeblock]
• 0 / send unreliable
• 1 / send unreliable, no delay
• 2 / send reliable
• 3 / send reliable with buffering
[/codeblock]
The type of data you send is arbitrary, you can use an off the shelf system like Protocol Buffers or Cap'n Proto to encode your packets in an efficient way, or you can create your own messaging system.
Sends a P2P packet to the specified user.
Triggers a [signal Steam.p2p_session_request] callback.
True if the packet was successfully sent. Note that this does not mean successfully received, if we can't get through to the user after a timeout of 20 seconds, then an error will be posted via the [signal Steam.p2p_session_connect_fail] callback.
False upon the following conditions:
[codeblock]
The packet is too large for the send type.
The target Steam ID is not valid.
There are too many bytes queued up to be sent.
[/codeblock]
[b]Note:[/b] The first packet send may be delayed as the NAT-traversal code runs.
*/
func SendP2PPacket(remote_steam_id int, data []byte, send_type P2PSend, channel int) bool { //gd:Steam.sendP2PPacket
	once.Do(singleton)
	return bool(Advanced().SendP2PPacket(int64(remote_steam_id), Packed.Bytes(Packed.New(data...)), send_type, int64(channel)))
}

/*
Sends a P2P packet to the specified user.
This is a session-less API which automatically establishes NAT-traversing or Steam relay server connections.
See EP2PSend for descriptions of the different ways of sending packets. The integers passed in GodotSteam are:
[codeblock]
• 0 / send unreliable
• 1 / send unreliable, no delay
• 2 / send reliable
• 3 / send reliable with buffering
[/codeblock]
The type of data you send is arbitrary, you can use an off the shelf system like Protocol Buffers or Cap'n Proto to encode your packets in an efficient way, or you can create your own messaging system.
Sends a P2P packet to the specified user.
Triggers a [signal Steam.p2p_session_request] callback.
True if the packet was successfully sent. Note that this does not mean successfully received, if we can't get through to the user after a timeout of 20 seconds, then an error will be posted via the [signal Steam.p2p_session_connect_fail] callback.
False upon the following conditions:
[codeblock]
The packet is too large for the send type.
The target Steam ID is not valid.
There are too many bytes queued up to be sent.
[/codeblock]
[b]Note:[/b] The first packet send may be delayed as the NAT-traversal code runs.
*/
func SendP2PPacketOptions(remote_steam_id int, data []byte, send_type P2PSend, channel int) bool { //gd:Steam.sendP2PPacket
	once.Do(singleton)
	return bool(Advanced().SendP2PPacket(int64(remote_steam_id), Packed.Bytes(Packed.New(data...)), send_type, int64(channel)))
}

/*
Call this in response to a [signal Steam.network_messages_session_request] callback. [signal Steam.network_messages_session_request] callbacks are posted when a user tries to send you a message, and you haven't tried to talk to them first. If you don't want to talk to them, just ignore the request. If the user continues to send you messages, [signal Steam.network_messages_session_request] callbacks will continue to be posted periodically.
Returns false if there is no session with the user pending or otherwise. If there is an existing active session, this function will return true, even if it is not pending.
Calling [method Steam.sendMessageToUser] will implicitly accepts any pending session request to that user.
*/
func AcceptSessionWithUser(remote_steam_id int) bool { //gd:Steam.acceptSessionWithUser
	once.Do(singleton)
	return bool(Advanced().AcceptSessionWithUser(int64(remote_steam_id)))
}

/*
Call this when you're done talking to a user on a specific channel. Once all open channels to a user have been closed, the open session to the user will be closed, and any new data from this user will trigger a [signal Steam.network_messages_session_request] callback.
*/
func CloseChannelWithUser(remote_steam_id int, channel int) bool { //gd:Steam.closeChannelWithUser
	once.Do(singleton)
	return bool(Advanced().CloseChannelWithUser(int64(remote_steam_id), int64(channel)))
}

/*
Call this when you're done talking to a user to immediately free up resources under-the-hood. If the remote user tries to send data to you again, another [signal Steam.network_messages_session_request] callback will be posted.
[b]Note:[/b] sessions that go unused for a few minutes are automatically timed out.
*/
func CloseSessionWithUser(remote_steam_id int) bool { //gd:Steam.closeSessionWithUser
	once.Do(singleton)
	return bool(Advanced().CloseSessionWithUser(int64(remote_steam_id)))
}

/*
Returns information about the latest state of a connection, if any, with the given peer. Primarily intended for debugging purposes, but can also be used to get more detailed failure information.
Returns the value of connection state or 0 if no connection exists with specified peer. You may pass false for either get_connection or get_status if you do not need the corresponding details. Note that sessions time out after a while, so if a connection fails, or [method Steam.sendMessageToUser] returns 3, you cannot wait indefinitely to obtain the reason for failure.
*/
func GetSessionConnectionInfo(remote_steam_id int, get_connection bool, get_status bool) map[any]any { //gd:Steam.getSessionConnectionInfo
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetSessionConnectionInfo(int64(remote_steam_id), get_connection, get_status)))
}

/*
Reads the next message that has been sent from another user via [method Steam.sendMessageToUser] on the given channel. Returns number of messages returned into your list. (0 if no message are available on that channel.)
The returned array contains a list of:
[codeblock]
┖╴messages (dictionary)

	┠╴payload (PackedByteArray)
	┠╴size (int)
	┠╴connection (int)
	┠╴identity (string)
	┠╴receiver_user_data (int)
	┠╴time_received (int)
	┠╴message_number (int)
	┠╴channel (int)
	┠╴flags (int)
	┖╴sender_user_data (int)

[/codeblock]
*/
func ReceiveMessagesOnChannel(channel int, max_messages int) []any { //gd:Steam.receiveMessagesOnChannel
	once.Do(singleton)
	return []any(gd.ArrayAs[[]any](gd.InternalArray(Advanced().ReceiveMessagesOnChannel(int64(channel), int64(max_messages)))))
}

/*
Sends a message to the specified host via Steam ID. If we don't already have a session with that user, a session is implicitly created. There might be some handshaking that needs to happen before we can actually begin sending message data. If this handshaking fails and we can't get through, an error will be posted via the callback [signal Steam.network_messages_session_failed]. There is no notification when the operation succeeds. (You should have the peer send a reply for this purpose.)
Sending a message to a host will also implicitly accept any incoming connection from that host.
[b]flags[/b] is a bitmask of k_nSteamNetworkingSend_xxx options.
[b]channel[/b] is a routing number you can use to help route message to different systems. You'll have to call [method Steam.receiveMessagesOnChannel] with the same channel number in order to retrieve the data on the other end.
Using different channels to talk to the same user will still use the same underlying connection, saving on resources. If you don't need this feature, use 0. Otherwise, small integers are the most efficient.
It is guaranteed that reliable messages to the same host on the same channel will be be received by the remote host (if they are received at all) exactly once, and in the same order that they were sent.
No other order guarantees exist! In particular, unreliable messages may be dropped, received out of order with respect to each other and with respect to reliable data, or may be received multiple times. Messages on different channels are not guaranteed to be received in the order they were sent.
A note for those familiar with TCP/IP ports, or converting an existing codebase that opened multiple sockets: You might notice that there is only one channel, and with TCP/IP each endpoint has a port number. You can think of the channel number as the destination port. If you need each message to also include a source port (so the recipient can route the reply), then just put that in your message. That is essentially how UDP works!
*/
func SendMessageToUser(remote_steam_id int, data []byte, flags int, channel int) int { //gd:Steam.sendMessageToUser
	once.Do(singleton)
	return int(int(Advanced().SendMessageToUser(int64(remote_steam_id), Packed.Bytes(Packed.New(data...)), int64(flags), int64(channel))))
}

/*
Accept an incoming connection that has been received on a listen socket.
*/
func AcceptConnection(connection_handle int) int { //gd:Steam.acceptConnection
	once.Do(singleton)
	return int(int(Advanced().AcceptConnection(int64(connection_handle))))
}

/*
Begin asynchronous process of allocating a fake IPv4 address that other peers can use to contact us via P2P. IP addresses returned by this function are globally unique for a given app ID.
Triggers a [signal Steam.fake_ip_result] callback.
False if a request was already in progress, true if a new request was started.
*/
func BeginAsyncRequestFakeIP(num_ports int) bool { //gd:Steam.beginAsyncRequestFakeIP
	once.Do(singleton)
	return bool(Advanced().BeginAsyncRequestFakeIP(int64(num_ports)))
}

/*
Disconnects from the remote host and invalidates the connection handle. Any unread data on the connection is discarded.
[b]reason[/b] is an application defined code that will be received on the other end and recorded (when possible) in backend analytics. The value should come from a restricted range. (See ESteamNetConnectionEnd.) If you don't need to communicate any information to the remote host, and do not want analytics to be able to distinguish "normal" connection terminations from "exceptional" ones, you may pass zero, in which case the generic value of CONNECTION_END_APP_MIN will be used.
[b]debug_message[/b] is an optional human-readable diagnostic string that will be received by the remote host and recorded (when possible) in backend analytics.
*/
func CloseConnection(peer int, reason int, debug_message string, linger bool) bool { //gd:Steam.closeConnection
	once.Do(singleton)
	return bool(Advanced().CloseConnection(int64(peer), int64(reason), String.New(debug_message), linger))
}

/*
Destroy a listen socket. All the connections that were accepted on the listen socket are closed ungracefully.
*/
func CloseListenSocket(socket int) bool { //gd:Steam.closeListenSocket
	once.Do(singleton)
	return bool(Advanced().CloseListenSocket(int64(socket)))
}

/*
Configure multiple outbound messages streams ("lanes") on a connection, and control head-of-line blocking between them. Messages within a given lane are always sent in the order they are queued, but messages from different lanes may be sent out of order. Each lane has its own message number sequence. The first message sent on each lane will be assigned the number 1.
Each lane has a "priority". Lower priority lanes will only be processed when all higher-priority lanes are empty. The magnitudes of the priority values are not relevant, only their sort order. Higher numeric values take priority over lower numeric values.
Each lane also is assigned a weight, which controls the approximate proportion of the bandwidth that will be consumed by the lane, relative to other lanes of the same priority. (This is assuming the lane stays busy. An idle lane does not build up "credits" to be be spent once a message is queued.) This value is only meaningful as a proportion, relative to other lanes with the same priority. For lanes with different priorities, the strict priority order will prevail, and their weights relative to each other are not relevant. Thus, if a lane has a unique priority value, the weight value for that lane is not relevant.
*/
func ConfigureConnectionLanes(connection int, lanes int, priorities []any, weights []any) int { //gd:Steam.configureConnectionLanes
	once.Do(singleton)
	return int(int(Advanced().ConfigureConnectionLanes(int64(connection), int64(lanes), gd.EngineArrayFromSlice(priorities), gd.EngineArrayFromSlice(weights))))
}

/*
Begin connecting to a server that is identified using a platform-specific identifier. This uses the default rendezvous service, which depends on the platform and library configuration. (E.g. on Steam, it goes through the steam backend.) The traffic is relayed over the Steam Datagram Relay network.
If you use this, you probably want to call initRelayNetworkAccess when your app initializes. If you need to set any initial config options, pass them here.
See SteamNetworkingConfigValue_t for more about why this is preferable to setting the options "immediately" after creation.
Pass your options as an array of arrays; each sub-array containing: [b]config value (int), data type (int), and data value (int or string).[/b]
Alternately you can pass an empty array.
*/
func ConnectP2P(remote_steam_id int, virtual_port int, options map[any]any) int { //gd:Steam.connectP2P
	once.Do(singleton)
	return int(int(Advanced().ConnectP2P(int64(remote_steam_id), int64(virtual_port), gd.DictionaryFromMap(options))))
}

/*
Begin connecting to a server listen socket that is identified using an ip-address:port, i.e. 127.0.0.1:27015. Used with [method Steam.createListenSocketIP].
*/
func ConnectByIPAddress(ip_address_with_port string, options map[any]any) int { //gd:Steam.connectByIPAddress
	once.Do(singleton)
	return int(int(Advanced().ConnectByIPAddress(String.New(ip_address_with_port), gd.DictionaryFromMap(options))))
}

/*
Client call to connect to a server hosted in a Valve data center, on the specified virtual port. You must have placed a ticket for this server into the cache, or else this connect attempt will fail!
Pass your options as an array of arrays; each sub-array containing: [b]config value (int), data type (int), and data value (int or string).[/b]
Alternately you can pass an empty array.
*/
func ConnectToHostedDedicatedServer(remote_steam_id int, virtual_port int, options map[any]any) int { //gd:Steam.connectToHostedDedicatedServer
	once.Do(singleton)
	return int(int(Advanced().ConnectToHostedDedicatedServer(int64(remote_steam_id), int64(virtual_port), gd.DictionaryFromMap(options))))
}

/*
Get an interface that can be used like a UDP port to send/receive datagrams to a FakeIP address. This is intended to make it easy to port existing UDP-based code to take advantage of SDR.
[b]fake_server_port[/b] refers to the index of the port allocated using [method Steam.beginAsyncRequestFakeIP] and is used to create "server" ports. You may call this before the allocation has completed. However, any attempts to send packets will fail until the allocation has succeeded. When the peer receives packets sent from this interface, the from address of the packet will be the globally-unique FakeIP. If you call this function multiple times and pass the same (nonnegative) fake port index, the same object will be returned, and this object is not reference counted.
To create a "client" port (e.g. the equivalent of an ephemeral UDP port) pass -1. In this case, a distinct object will be returned for each call. When the peer receives packets sent from this interface, the peer will assign a FakeIP from its own locally-controlled namespace.
*/
func CreateFakeUDPPort(fake_server_port int) { //gd:Steam.createFakeUDPPort
	once.Do(singleton)
	Advanced().CreateFakeUDPPort(int64(fake_server_port))
}

/*
Create a listen socket on the specified virtual port. The physical UDP port to use will be determined by the SDR_LISTEN_PORT environment variable. If a UDP port is not configured, this call will fail.
This function should be used when you are using the ticket generator library to issue your own tickets. Clients connecting to the server on this virtual port will need a ticket, and they must connect using [method Steam.connectToHostedDedicatedServer].
Pass your options as an array of arrays; each sub-array containing: [b]config value (int), data type (int), and data value (int or string).[/b]
Alternately you can pass an empty array.
*/
func CreateHostedDedicatedServerListenSocket(virtual_port int, options map[any]any) int { //gd:Steam.createHostedDedicatedServerListenSocket
	once.Do(singleton)
	return int(int(Advanced().CreateHostedDedicatedServerListenSocket(int64(virtual_port), gd.DictionaryFromMap(options))))
}

/*
Creates a "server" socket that listens for clients to connect to by calling [method Steam.connectByIPAddress], over ordinary UDP (IPv4 or IPv6)
Pass your options as an array of arrays; each sub-array containing: [b]config value (int), data type (int), and data value (int or string).[/b]
Alternately you can pass an empty array.
*/
func CreateListenSocketIP(ip_reference string, options map[any]any) int { //gd:Steam.createListenSocketIP
	once.Do(singleton)
	return int(int(Advanced().CreateListenSocketIP(String.New(ip_reference), gd.DictionaryFromMap(options))))
}

/*
Create a listen socket that will listen for P2P connections sent to our FakeIP.  A peer can initiate connections to this listen socket by calling [method Steam.connectByIPAddress].
*/
func CreateListenSocketP2P(virtual_port int, options map[any]any) int { //gd:Steam.createListenSocketP2P
	once.Do(singleton)
	return int(int(Advanced().CreateListenSocketP2P(int64(virtual_port), gd.DictionaryFromMap(options))))
}

/*
Like [method Steam.createListenSocketIP], but clients will connect using [method Steam.connectP2P]. The connection will be relayed through the Valve network.
[b]virtual_port[/b] specifies how clients can connect to this socket using [method Steam.connectP2P]. It's very common for applications to only have one listening socket; in that case, use zero. If you need to open multiple listen sockets and have clients be able to connect to one or the other, then virtual_port should be a small integer (less than 1000) unique to each listen socket you create.
Pass your options as an array of arrays; each sub-array containing: [b]config value (int), data type (int), and data value (int or string).[/b]
Alternately you can pass an empty array.
*/
func CreateListenSocketP2PFakeIP(fake_port int, options map[any]any) int { //gd:Steam.createListenSocketP2PFakeIP
	once.Do(singleton)
	return int(int(Advanced().CreateListenSocketP2PFakeIP(int64(fake_port), gd.DictionaryFromMap(options))))
}

/*
Create a new poll group.
You should destroy the poll group when you are done using [method Steam.destroyPollGroup].
*/
func CreatePollGroup() int { //gd:Steam.createPollGroup
	once.Do(singleton)
	return int(int(Advanced().CreatePollGroup()))
}

/*
Create a pair of connections that are talking to each other, e.g. a loopback connection. This is very useful for testing, or so that your client/server code can work the same even when you are running a local "server".
The two connections will immediately be placed into the connected state, and no callbacks will be posted immediately. After this, if you close either connection, the other connection will receive a callback, exactly as if they were communicating over the network. You must close both sides in order to fully clean up the resources!
By default, internal buffers are used, completely bypassing the network, the chopping up of messages into packets, encryption, copying the payload, etc. This means that loopback packets, by default, will not simulate lag or loss. Passing true for loopback will cause the socket pair to send packets through the local network loopback device (127.0.0.1) on ephemeral ports. Fake lag and loss are supported in this case, and CPU time is expended to encrypt and decrypt.
If you wish to assign a specific identity to either connection, you may pass a particular identity. Otherwise, if you pass nullptr, the respective connection will assume a generic "localhost" identity. If you use real network loopback, this might be translated to the actual bound loopback port. Otherwise, the port will be zero.
The returned dictionary contains the following keys: [b]success (bool), connection1 (int), and connection2 (int).[/b]
*/
func CreateSocketPair(loopback bool, remote_steam_id1 int, remote_steam_id2 int) map[any]any { //gd:Steam.createSocketPair
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().CreateSocketPair(loopback, int64(remote_steam_id1), int64(remote_steam_id2))))
}

/*
Destroy a poll group created with [method Steam.createPollGroup].
If there are any connections in the poll group, they are removed from the group, and left in a state where they are not part of any poll group. Returns false if passed an invalid poll group handle.
*/
func DestroyPollGroup(poll_group int) bool { //gd:Steam.destroyPollGroup
	once.Do(singleton)
	return bool(Advanced().DestroyPollGroup(int64(poll_group)))
}

/*
Flush any messages waiting on the Nagle timer and send them at the next transmission opportunity (often that means right now).
*/
func FlushMessagesOnConnection(connection_handle int) int { //gd:Steam.flushMessagesOnConnection
	once.Do(singleton)
	return int(int(Advanced().FlushMessagesOnConnection(int64(connection_handle))))
}

/*
Query our readiness to participate in authenticated communications. A [signal Steam.network_authentication_status] callback is posted any time this status changes, but you can use this function to query it at any time.
*/
func GetAuthenticationStatus() NetworkingAvailability { //gd:Steam.getAuthenticationStatus
	once.Do(singleton)
	return NetworkingAvailability(Advanced().GetAuthenticationStatus())
}

/*
Certificate provision by the application. On Steam, we normally handle all this automatically and you will not need to use these advanced functions.
Get blob that describes a certificate request. You can send this to your game coordinator. Pass this blob to your game coordinator and call SteamDatagram_CreateCert.
Returned dictionary contains the following keys: [b]certificate (PackedByteArray), and error_message (string).[/b]
*/
func GetCertificateRequest() map[any]any { //gd:Steam.getCertificateRequest
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetCertificateRequest()))
}

/*
Returns basic information about the high-level state of the connection. Returns false if the connection handle is invalid.
The returned dictionary contains the following keys: [b]identity (string), user_data (int), listen_socket (int), remote_address (string), remote_pop (int), pop_relay (int), connection_state (int), end_reason (int), end_debug (string), and debug_description (string).[/b]
*/
func GetConnectionInfo(connection_handle int) map[any]any { //gd:Steam.getConnectionInfo
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetConnectionInfo(int64(connection_handle))))
}

/*
Fetch connection name into your buffer, which is at least nMaxLen bytes. Returns false if handle is invalid.
*/
func GetConnectionName(peer int) string { //gd:Steam.getConnectionName
	once.Do(singleton)
	return string(Advanced().GetConnectionName(int64(peer)).String())
}

/*
Returns a small set of information about the real-time state of the connection and the queue status of each lane.
The returned dictionary contains the following keys:
[codeblock]
┠╴connection_status (dictionary)

	┠╴state (int)
	┠╴ping (int)
	┠╴local_quality (float)
	┠╴remote_quality (float)
	┠╴packets_out_per_second (float)
	┠╴bytes_out_per_second (float)
	┠╴packets_in_per_second (float)
	┠╴bytes_in_per_second (float)
	┠╴send_rate (int)
	┠╴pending_unreliable (int)
	┠╴pending_reliable (int)
	┠╴send_unacknowledged_reliable (int)
	┖╴queue_time (int)

┖╴lanes_status (array)

	┖╴lane_status (dictionary)
	    ┠╴pending_unreliable (int)
	    ┠╴pending_reliable (int)
	    ┠╴sent_unacknowledged_reliable (int)
	    ┖╴queue_time (int)

[/codeblock]
*/
func GetConnectionRealTimeStatus(connection_handle int, lanes int) map[any]any { //gd:Steam.getConnectionRealTimeStatus
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetConnectionRealTimeStatus(int64(connection_handle), int64(lanes), true)))
}

/*
Returns a small set of information about the real-time state of the connection and the queue status of each lane.
The returned dictionary contains the following keys:
[codeblock]
┠╴connection_status (dictionary)

	┠╴state (int)
	┠╴ping (int)
	┠╴local_quality (float)
	┠╴remote_quality (float)
	┠╴packets_out_per_second (float)
	┠╴bytes_out_per_second (float)
	┠╴packets_in_per_second (float)
	┠╴bytes_in_per_second (float)
	┠╴send_rate (int)
	┠╴pending_unreliable (int)
	┠╴pending_reliable (int)
	┠╴send_unacknowledged_reliable (int)
	┖╴queue_time (int)

┖╴lanes_status (array)

	┖╴lane_status (dictionary)
	    ┠╴pending_unreliable (int)
	    ┠╴pending_reliable (int)
	    ┠╴sent_unacknowledged_reliable (int)
	    ┖╴queue_time (int)

[/codeblock]
*/
func GetConnectionRealTimeStatusOptions(connection_handle int, lanes int, get_status bool) map[any]any { //gd:Steam.getConnectionRealTimeStatus
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetConnectionRealTimeStatus(int64(connection_handle), int64(lanes), get_status)))
}

/*
Fetch connection user data. Returns -1 if handle is invalid or if you haven't set any userdata on the connection.
*/
func GetConnectionUserData(peer int) int { //gd:Steam.getConnectionUserData
	once.Do(singleton)
	return int(int(Advanced().GetConnectionUserData(int64(peer))))
}

/*
Returns very detailed connection stats in diagnostic text format. Useful for dumping to a log, etc. The format of this information is subject to change.
The returned dictionary contains the following keys:
[codeblock]
┠╴success (int)
┖╴buffer (string)
[/codeblock]
*/
func GetDetailedConnectionStatus(connection_handle int) map[any]any { //gd:Steam.getDetailedConnectionStatus
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetDetailedConnectionStatus(int64(connection_handle))))
}

/*
Return info about the FakeIP and port(s) that we have been assigned, if any.
[b]first_port[/b] is currently reserved and must be zero. Make sure and check result.
The returned dictionary contains the following keys:
[codeblock]
┠╴result (int)
┠╴identity_type (int)
┠╴ip (string)
┖╴ports (PackedInt32Array)
[/codeblock]
*/
func GetFakeIP(first_port int) map[any]any { //gd:Steam.getFakeIP
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetFakeIP(int64(first_port))))
}

/*
Return info about the FakeIP and port(s) that we have been assigned, if any.
[b]first_port[/b] is currently reserved and must be zero. Make sure and check result.
The returned dictionary contains the following keys:
[codeblock]
┠╴result (int)
┠╴identity_type (int)
┠╴ip (string)
┖╴ports (PackedInt32Array)
[/codeblock]
*/
func GetFakeIPOptions(first_port int) map[any]any { //gd:Steam.getFakeIP
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetFakeIP(int64(first_port))))
}

/*
Returns 0 if SDR_LISTEN_PORT is not set. Otherwise, returns the data center the server is running in. This will be k_SteamDatagramPOPID_dev in non-production environment.
*/
func GetHostedDedicatedServerPOPId() int { //gd:Steam.getHostedDedicatedServerPOPId
	once.Do(singleton)
	return int(int(Advanced().GetHostedDedicatedServerPOPId()))
}

/*
Returns the value of the SDR_LISTEN_PORT environment variable. This is the UDP server your server will be listening on. This will configured automatically for you in production environments.
*/
func GetHostedDedicatedServerPort() int { //gd:Steam.getHostedDedicatedServerPort
	once.Do(singleton)
	return int(int(Advanced().GetHostedDedicatedServerPort()))
}

/*
Returns local IP and port that a listen socket created using [method Steam.createListenSocketIP] is bound to.
[b]Note:[/b] This is not how you find out your public IP that clients can connect to.
*/
func GetListenSocketAddress(socket int) string { //gd:Steam.getListenSocketAddress
	once.Do(singleton)
	return string(Advanced().GetListenSocketAddress(int64(socket), true).String())
}

/*
Returns local IP and port that a listen socket created using [method Steam.createListenSocketIP] is bound to.
[b]Note:[/b] This is not how you find out your public IP that clients can connect to.
*/
func GetListenSocketAddressOptions(socket int, with_port bool) string { //gd:Steam.getListenSocketAddress
	once.Do(singleton)
	return string(Advanced().GetListenSocketAddress(int64(socket), with_port).String())
}

/*
If the connection was initiated using the "FakeIP" system, then we we can get an IP address for the remote host. If the remote host had a global FakeIP at the time the connection was established, this function will return that global IP.
Otherwise, a FakeIP that is unique locally will be allocated from the local FakeIP address space, and that will be returned.
This should also add the returning struct to your ip_addresses vector as fake_ip_address.
The returned dictionary contains the following keys:
[codeblock]
┠╴result (int)
┠╴ip_address (string)
┠╴port (int)
┖╴ip_type (int)
[/codeblock]
*/
func GetRemoteFakeIPForConnection(connection int) map[any]any { //gd:Steam.getRemoteFakeIPForConnection
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetRemoteFakeIPForConnection(int64(connection))))
}

/*
Indicate our desire to be ready participate in authenticated communications. If we are currently not ready, then steps will be taken to obtain the necessary certificates. (This includes a certificate for us, as well as any CA certificates needed to authenticate peers.)
*/
func InitAuthentication() NetworkingAvailability { //gd:Steam.initAuthentication
	once.Do(singleton)
	return NetworkingAvailability(Advanced().InitAuthentication())
}

/*
Fetch the next available message(s) from the connection, if any. Returns the number of messages returned into your array, up to max_messages. If the connection handle is invalid, -1 is returned. If no data is available, 0, is returned.
The returned array contains a list of:
[codeblock]
┖╴messages (dictionary):

	┠╴payload (string)
	┠╴size (int)
	┠╴connection (int)
	┠╴identity (string)
	┠╴receiver_user_data (int)
	┠╴time_received (int)
	┠╴message_number (int)
	┠╴channel (int)
	┠╴flags (int)
	┖╴sender_user_data (int)

[/codeblock]
*/
func ReceiveMessagesOnConnection(connection int, max_messages int) []any { //gd:Steam.receiveMessagesOnConnection
	once.Do(singleton)
	return []any(gd.ArrayAs[[]any](gd.InternalArray(Advanced().ReceiveMessagesOnConnection(int64(connection), int64(max_messages)))))
}

/*
Same as [method Steam.receiveMessagesOnConnection], but will return the next messages available on any connection in the poll group. Examine connection to know which connection. user_data might also be useful.
The returned array contains a list of:
[codeblock]
┖╴messages (dictionary):

	┠╴payload (string)
	┠╴size (int)
	┠╴connection (int)
	┠╴identity (string)
	┠╴receiver_user_data (int)
	┠╴time_received (int)
	┠╴message_number (int)
	┠╴channel (int)
	┠╴flags (int)
	┖╴sender_user_data (int)

[/codeblock]
*/
func ReceiveMessagesOnPollGroup(poll_group int, max_messages int) []any { //gd:Steam.receiveMessagesOnPollGroup
	once.Do(singleton)
	return []any(gd.ArrayAs[[]any](gd.InternalArray(Advanced().ReceiveMessagesOnPollGroup(int64(poll_group), int64(max_messages)))))
}

/*
Reset the identity associated with this instance. Any open connections are closed. Any previous certificates, etc are discarded.
[b]Note:[/b] This function is not actually supported on Steam! It is included for use on other platforms where the active user can sign out and a new user can sign in.
*/
func ResetIdentity(remote_steam_id int) { //gd:Steam.resetIdentity
	once.Do(singleton)
	Advanced().ResetIdentity(int64(remote_steam_id))
}

/*
Invoke all callback functions queued for this interface. You don't need to call this if you are using Steam's callback dispatch mechanism [method Steam.run_callbacks].
*/
func RunNetworkingCallbacks() { //gd:Steam.runNetworkingCallbacks
	once.Do(singleton)
	Advanced().RunNetworkingCallbacks()
}

/*
Send a message to the remote host on the specified connection.
The returned dictionary contains the following keys:
[codeblock]
┠╴result (int)
┖╴message_number (int)
[/codeblock]
*/
func SendMessageToConnection(connection_handle int, data []byte, flags int) map[any]any { //gd:Steam.sendMessageToConnection
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().SendMessageToConnection(int64(connection_handle), Packed.Bytes(Packed.New(data...)), int64(flags))))
}

/*
Set the certificate. The certificate blob should be the output of SteamDatagram_CreateCert.
*/
func SetCertificate(certificate []byte) map[any]any { //gd:Steam.setCertificate
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().SetCertificate(Packed.Bytes(Packed.New(certificate...)))))
}

/*
Assign a connection to a poll group. Note that a connection may only belong to a single poll group. Adding a connection to a poll group implicitly removes it from any other poll group it is in.
*/
func SetConnectionPollGroup(connection_handle int, poll_group int) bool { //gd:Steam.setConnectionPollGroup
	once.Do(singleton)
	return bool(Advanced().SetConnectionPollGroup(int64(connection_handle), int64(poll_group)))
}

/*
Set a name for the connection, used mostly for debugging.
*/
func SetConnectionName(peer int, name string) { //gd:Steam.setConnectionName
	once.Do(singleton)
	Advanced().SetConnectionName(int64(peer), String.New(name))
}

/*
Check if the ping data of sufficient recency is available, and if it's too old, start refreshing it.
Please only call this function when you really do need to force an immediate refresh of the data. (For example, in response to a specific user input to refresh this information.) Don't call it "just in case", before every connection, etc. That will cause extra traffic to be sent for no benefit. The library will automatically refresh the information as needed.
True if sufficiently recent data is already available. False if sufficiently recent data is not available. In this case, ping measurement is initiated, if it is not already active. (You cannot restart a measurement already in progress.)
*/
func CheckPingDataUpToDate(max_age_in_seconds Float.X) bool { //gd:Steam.checkPingDataUpToDate
	once.Do(singleton)
	return bool(Advanced().CheckPingDataUpToDate(float64(max_age_in_seconds)))
}

/*
Convert a ping location into a text format suitable for sending over the wire. The format is a compact and human readable. However, it is subject to change so please do not parse it yourself.
*/
func ConvertPingLocationToString(location []byte) string { //gd:Steam.convertPingLocationToString
	once.Do(singleton)
	return string(Advanced().ConvertPingLocationToString(Packed.Bytes(Packed.New(location...))).String())
}

/*
Estimate the round-trip latency between two arbitrary locations, in milliseconds. This is a conservative estimate, based on routing through the relay network. For most basic relayed connections, this ping time will be pretty accurate, since it will be based on the route likely to be actually used.
If a direct IP route is used (perhaps via NAT traversal), then the route will be different, and the ping time might be better. Or it might actually be a bit worse! Standard IP routing is frequently suboptimal! But even in this case, the estimate obtained using this method is a reasonable upper bound on the ping time. (Also it has the advantage of returning immediately and not sending any packets.)
In a few cases we might not able to estimate the route. In this case a negative value is returned. k_nSteamNetworkingPing_Failed means the reason was because of some networking difficulty. (Failure to ping, etc) k_nSteamNetworkingPing_Unknown is returned if we cannot currently answer the question for some other reason.
*/
func EstimatePingTimeBetweenTwoLocations(location1 []byte, location2 []byte) int { //gd:Steam.estimatePingTimeBetweenTwoLocations
	once.Do(singleton)
	return int(int(Advanced().EstimatePingTimeBetweenTwoLocations(Packed.Bytes(Packed.New(location1...)), Packed.Bytes(Packed.New(location2...)))))
}

/*
Same as [method Steam.estimatePingTimeBetweenTwoLocations], but assumes that one location is the local host. This is a bit faster, especially if you need to calculate a bunch of these in a loop to find the fastest one. In rare cases this might return a slightly different estimate than combining [method Steam.getLocalPingLocation] with [method Steam.estimatePingTimeBetweenTwoLocations]. That's because this function uses a slightly more complete set of information about what route would be taken.
*/
func EstimatePingTimeFromLocalHost(location []byte) int { //gd:Steam.estimatePingTimeFromLocalHost
	once.Do(singleton)
	return int(int(Advanced().EstimatePingTimeFromLocalHost(Packed.Bytes(Packed.New(location...)))))
}

/*
Get a configuration value.
For values to pass to config_value, check the SDK's listing.
For values to pass to scope_type, check the SDK's listing.
Returned dictionary contains the following keys: [b]result (int), type (int), value (PackedByteArray), and buffer (int).[/b]
The result key value may be one of the following: [b]-1 / bad value, -2 / bad connection handle, -3 / buffer too small, 1 / OK, or 2 / OK, inherited.[/b]
*/
func GetConfigValue(config_value NetworkingConfigValue, scope_type NetworkingConfigScope, connection_handle int) map[any]any { //gd:Steam.getConfigValue
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetConfigValue(config_value, scope_type, int64(connection_handle))))
}

/*
Returns info about a configuration value. For values to pass to config_value, check the SDK's listing. next_value can be used to iterate through all of the known configuration values.
The returned dictionary contains the following keys: [b]type (int), scope (int), and next_value (int).[/b]
*/
func GetConfigValueInfo(config_value NetworkingConfigValue) map[any]any { //gd:Steam.getConfigValueInfo
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetConfigValueInfo(config_value)))
}

/*
Get direct ping time to the relays at the point of presence.
*/
func GetDirectPingToPOP(pop_id int) int { //gd:Steam.getDirectPingToPOP
	once.Do(singleton)
	return int(int(Advanced().GetDirectPingToPOP(int64(pop_id))))
}

/*
Return location info for the current host. Returns the approximate age of the data, in seconds, or -1 if no data is available. You can use this value in [method Steam.checkPingDataUpToDate].
It takes a few seconds to initialize access to the relay network.
This always return the most up-to-date information we have available right now, even if we are in the middle of re-calculating ping times.
The returned dictionary contains the following keys:
[codeblock]
┠╴location (PackedByteArray)
┖╴age (float)
[/codeblock]
*/
func GetLocalPingLocation() map[any]any { //gd:Steam.getLocalPingLocation
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetLocalPingLocation()))
}

/*
A general purpose high resolution local timer with the following properties:
Monotonicity is guaranteed.
The initial value will be at least 24360030*1e6, i.e. about 30 days worth of microseconds. In this way, the timestamp value of 0 will always be at least "30 days ago". Also, negative numbers will never be returned.
Wraparound / overflow is not a practical concern.
If you are running under the debugger and stop the process, the clock might not advance the full wall clock time that has elapsed between calls. If the process is not blocked from normal operation, the timestamp values will track wall clock time, even if you don't call the function frequently.
The value is only meaningful for this run of the process. Don't compare it to values obtained on another computer, or other runs of the same process.
*/
func GetLocalTimestamp() int { //gd:Steam.getLocalTimestamp
	once.Do(singleton)
	return int(int(Advanced().GetLocalTimestamp()))
}

/*
Fetch ping time of best available relayed route from this host to the specified data center.
The returned dictionary contains the following keys:
[codeblock]
┠╴pop_relay (int)
┖╴ping (int)
[/codeblock]
*/
func GetPingToDataCenter(pop_id int) map[any]any { //gd:Steam.getPingToDataCenter
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetPingToDataCenter(int64(pop_id))))
}

/*
Get number of network points of presence in the config.
*/
func GetPOPCount() int { //gd:Steam.getPOPCount
	once.Do(singleton)
	return int(int(Advanced().GetPOPCount()))
}

/*
Get list of all POP IDs. Returns the number of entries that were filled into your list.
*/
func GetPOPList() []any { //gd:Steam.getPOPList
	once.Do(singleton)
	return []any(gd.ArrayAs[[]any](gd.InternalArray(Advanced().GetPOPList())))
}

/*
Fetch current status of the relay network.
[signal Steam.relay_network_status] is also a callback. It will be triggered on both the user and gameserver interfaces any time the status changes, or ping measurement starts or stops.
Possible returned statuses can be:
[codeblock]
• -102 / cannot try
• -101 / failed
• -100 / previously worked, now there is a problem
• -10 / retrying
• 0 / unknown
• 1 / never tried
• 2 / waiting
• 3 / attempting
• 100 / current
[/codeblock]
*/
func GetRelayNetworkStatus() NetworkingAvailability { //gd:Steam.getRelayNetworkStatus
	once.Do(singleton)
	return NetworkingAvailability(Advanced().GetRelayNetworkStatus())
}

/*
If you know that you are going to be using the relay network (for example, because you anticipate making P2P connections), call this to initialize the relay network. If you do not call this, the initialization will be delayed until the first time you use a feature that requires access to the relay network, which will delay that first access.
You can also call this to force a retry if the previous attempt has failed. Performing any action that requires access to the relay network will also trigger a retry, and so calling this function is never strictly necessary, but it can be useful to call it a program launch time, if access to the relay network is anticipated. Use [method Steam.getRelayNetworkStatus] or listen for [signal Steam.relay_network_status] callbacks to know when initialization has completed. Typically initialization completes in a few seconds.
[b]Note:[/b] dedicated servers hosted in known data centers do not need to call this, since they do not make routing decisions. However, if the dedicated server will be using P2P functionality, it will act as a "client" and this should be called.
*/
func InitRelayNetworkAccess() { //gd:Steam.initRelayNetworkAccess
	once.Do(singleton)
	Advanced().InitRelayNetworkAccess()
}

/*
Parse back location_string string. Returns false if we couldn't understand the string.
The returned dictionary contains the following keys:
[codeblock]
┠╴success (bool)
┖╴ping_location (PackedByteArray)
[/codeblock]
*/
func ParsePingLocationString(s string) map[any]any { //gd:Steam.parsePingLocationString
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().ParsePingLocationString(String.New(s))))
}

/*
Set a configuration value.
*/
func SetConnectionConfigValueFloat(connection int, config NetworkingConfigValue, value Float.X) bool { //gd:Steam.setConnectionConfigValueFloat
	once.Do(singleton)
	return bool(Advanced().SetConnectionConfigValueFloat(int64(connection), config, float64(value)))
}

/*
Set a configuration value.
*/
func SetConnectionConfigValueInt32(connection int, config NetworkingConfigValue, value int) bool { //gd:Steam.setConnectionConfigValueInt32
	once.Do(singleton)
	return bool(Advanced().SetConnectionConfigValueInt32(int64(connection), config, int64(value)))
}

/*
Set a configuration value.
*/
func SetConnectionConfigValueString(connection int, config NetworkingConfigValue, value string) bool { //gd:Steam.setConnectionConfigValueString
	once.Do(singleton)
	return bool(Advanced().SetConnectionConfigValueString(int64(connection), config, String.New(value)))
}

/*
Set a configuration value.
*/
func SetGlobalConfigValueFloat(config NetworkingConfigValue, value Float.X) bool { //gd:Steam.setGlobalConfigValueFloat
	once.Do(singleton)
	return bool(Advanced().SetGlobalConfigValueFloat(config, float64(value)))
}

/*
Set a configuration value.
*/
func SetGlobalConfigValueInt32(config NetworkingConfigValue, value int) bool { //gd:Steam.setGlobalConfigValueInt32
	once.Do(singleton)
	return bool(Advanced().SetGlobalConfigValueInt32(config, int64(value)))
}

/*
Set a configuration value.
*/
func SetGlobalConfigValueString(config NetworkingConfigValue, value string) bool { //gd:Steam.setGlobalConfigValueString
	once.Do(singleton)
	return bool(Advanced().SetGlobalConfigValueString(config, String.New(value)))
}

/*
Check if the parental lock is enabled.
*/
func IsParentalLockEnabled() bool { //gd:Steam.isParentalLockEnabled
	once.Do(singleton)
	return bool(Advanced().IsParentalLockEnabled())
}

/*
Check if the parental lock is actually locked.
*/
func IsParentalLockLocked() bool { //gd:Steam.isParentalLockLocked
	once.Do(singleton)
	return bool(Advanced().IsParentalLockLocked())
}

/*
Check if the given app is blocked by parental settings.
*/
func IsAppBlocked(app_id int) bool { //gd:Steam.isAppBlocked
	once.Do(singleton)
	return bool(Advanced().IsAppBlocked(int64(app_id)))
}

/*
Check if this app is in the block list.
*/
func IsAppInBlockList(app_id int) bool { //gd:Steam.isAppInBlockList
	once.Do(singleton)
	return bool(Advanced().IsAppInBlockList(int64(app_id)))
}

/*
Check if the given feature is blocked by parental settings.
*/
func IsFeatureBlocked(feature ParentalFeature) bool { //gd:Steam.isFeatureBlocked
	once.Do(singleton)
	return bool(Advanced().IsFeatureBlocked(feature))
}

/*
Check if the given feature is in the block list.
*/
func IsFeatureInBlockList(feature ParentalFeature) bool { //gd:Steam.isFeatureInBlockList
	once.Do(singleton)
	return bool(Advanced().IsFeatureInBlockList(feature))
}

/*
To cancel a reservation (due to timeout or user input), call this. Steam will open a new reservation slot.
[b]Note:[/b] The user may already be in-flight to your game, so it's possible they will still connect and try to join your party.
*/
func CancelReservation(beacon_id int, steam_id int) { //gd:Steam.cancelReservation
	once.Do(singleton)
	Advanced().CancelReservation(int64(beacon_id), int64(steam_id))
}

/*
If a user joins your party through other matchmaking (perhaps a direct Steam friend, or your own matchmaking system), your game should reduce the number of open slots that Steam is managing through the party beacon. For example, if you created a beacon with five slots, and Steam sent you two reservation_notification callbacks, and then a third user joined directly, you would want to call [method Steam.changeNumOpenSlots] with a value of 2 for open_slots. That value represents the total number of new users that you would like Steam to send to your party.
Triggers a [signal Steam.change_num_open_slots] call result.
*/
func ChangeNumOpenSlots(beacon_id int, open_slots int) { //gd:Steam.changeNumOpenSlots
	once.Do(singleton)
	Advanced().ChangeNumOpenSlots(int64(beacon_id), int64(open_slots))
}

/*
Create a beacon. You can only create one beacon at a time. Steam will display the beacon in the specified location, and let up to open_slots users "follow" the beacon to your party.
If users join your party through other matchmaking, adjust the number of remaining open slots using [method Steam.changeNumOpenSlots].
Triggers a [signal Steam.create_beacon] call result.
*/
func CreateBeacon(open_slots int, location_id int, atype PartyBeaconLocationType, connect_string string, beacon_metadata string) { //gd:Steam.createBeacon
	once.Do(singleton)
	Advanced().CreateBeacon(int64(open_slots), int64(location_id), atype, String.New(connect_string), String.New(beacon_metadata))
}

/*
Call this method to destroy the Steam party beacon. This will immediately cause Steam to stop showing the beacon in the target location. Note that any users currently in-flight may still arrive at your party expecting to join.
*/
func DestroyBeacon(beacon_id int) bool { //gd:Steam.destroyBeacon
	once.Do(singleton)
	return bool(Advanced().DestroyBeacon(int64(beacon_id)))
}

/*
Get the list of locations in which you can post a party beacon.
The returned array contains a list of:
[codeblock]
beacon_data (dictionary)
┠╴type (int)
┖╴location_id (int)
[/codeblock]
*/
func GetAvailableBeaconLocations(max int) []any { //gd:Steam.getAvailableBeaconLocations
	once.Do(singleton)
	return []any(gd.ArrayAs[[]any](gd.InternalArray(Advanced().GetAvailableBeaconLocations(int64(max)))))
}

/*
Use with [method Steam.getNumActiveBeacons] to iterate the active beacons visible to the current user. Argument index is a zero-based index, so iterate over the range (0, getNumActiveBeacons() - 1). The return is a beacon_id that can be used with [method Steam.getBeaconDetails] to get information about the beacons suitable for display to the user.
*/
func GetBeaconByIndex(index int) int { //gd:Steam.getBeaconByIndex
	once.Do(singleton)
	return int(int(Advanced().GetBeaconByIndex(int64(index))))
}

/*
Get details about the specified beacon. You can use the Friends API to get further details about owner_id, and [method Steam.getBeaconLocationData] to get further details about location_id. The metadata contents are specific to your game, and will be whatever was set (if anything) by the game process that created the beacon.
The returned dictionary contains the following keys:
[codeblock]
┠╴beacon_id (int)
┠╴owner_id (int)
┠╴type (int)
┠╴location_id (int)
┖╴metadata (string)
[/codeblock]
*/
func GetBeaconDetails(beacon_id int) map[any]any { //gd:Steam.getBeaconDetails
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetBeaconDetails(int64(beacon_id))))
}

/*
Query general metadata for the given beacon location. For instance the Name, or the URL for an icon if the location type supports icons (for example, the icon for a Steam Chat Room Group).
*/
func GetBeaconLocationData(location_id int, location_type PartyBeaconLocationType, location_data PartyBeaconLocationData) string { //gd:Steam.getBeaconLocationData
	once.Do(singleton)
	return string(Advanced().GetBeaconLocationData(int64(location_id), location_type, location_data).String())
}

/*
Get the number of active party beacons created by other users for your game, that are visible to the current user.
*/
func GetNumActiveBeacons() int { //gd:Steam.getNumActiveBeacons
	once.Do(singleton)
	return int(int(Advanced().GetNumActiveBeacons()))
}

/*
When the user indicates they wish to join the party advertised by a given beacon, call this method. On success, Steam will reserve a slot for this user in the party and return the necessary "join game" string to use to complete the connection.
Triggers a [signal Steam.join_party] call result.
*/
func JoinParty(beacon_id int) { //gd:Steam.joinParty
	once.Do(singleton)
	Advanced().JoinParty(int64(beacon_id))
}

/*
When a user follows your beacon, Steam will reserve one of the open party slots for them, and send your game a reservation_notification callback. When that user joins your party, call [method Steam.onReservationCompleted] to notify Steam that the user has joined successfully.
Triggers a [signal Steam.reservation_notification] callback.
*/
func OnReservationCompleted(beacon_id int, steam_id int) { //gd:Steam.onReservationCompleted
	once.Do(singleton)
	Advanced().OnReservationCompleted(int64(beacon_id), int64(steam_id))
}

/*
Get the number of currently connected Steam Remote Play sessions.
*/
func GetSessionCount() int { //gd:Steam.getSessionCount
	once.Do(singleton)
	return int(int(Advanced().GetSessionCount()))
}

/*
Get the currently connected Steam Remote Play session ID at the specified index.
*/
func GetSessionID(index int) int { //gd:Steam.getSessionID
	once.Do(singleton)
	return int(int(Advanced().GetSessionID(int64(index))))
}

/*
Get the Steam ID of the connected user.
*/
func GetSessionSteamID(session_id int) int { //gd:Steam.getSessionSteamID
	once.Do(singleton)
	return int(int(Advanced().GetSessionSteamID(int64(session_id))))
}

/*
Get the name of the session client device.
*/
func GetSessionClientName(session_id int) string { //gd:Steam.getSessionClientName
	once.Do(singleton)
	return string(Advanced().GetSessionClientName(int64(session_id)).String())
}

/*
Get the form factor of the session client device.
*/
func GetSessionClientFormFactor(session_id int) int { //gd:Steam.getSessionClientFormFactor
	once.Do(singleton)
	return int(int(Advanced().GetSessionClientFormFactor(int64(session_id))))
}

/*
Get the resolution, in pixels, of the session client device. This is set to 0x0 if the resolution is not available.
The returned dictionary contains the following keys:
[codeblock]
┠╴success (bool)
┠╴x (int)
┖╴y (int)
[/codeblock]
*/
func GetSessionClientResolution(session_id int) map[any]any { //gd:Steam.getSessionClientResolution
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetSessionClientResolution(int64(session_id))))
}

/*
Invite a friend to join the game using Remote Play Together.
*/
func SendRemotePlayTogetherInvite(friend_id int) bool { //gd:Steam.sendRemotePlayTogetherInvite
	once.Do(singleton)
	return bool(Advanced().SendRemotePlayTogetherInvite(int64(friend_id)))
}

/*
Start a Remote Play session.
*/
func StartRemotePlayTogether() bool { //gd:Steam.startRemotePlayTogether
	once.Do(singleton)
	return bool(Advanced().StartRemotePlayTogether(true))
}

/*
Start a Remote Play session.
*/
func StartRemotePlayTogetherOptions(show_overlay bool) bool { //gd:Steam.startRemotePlayTogether
	once.Do(singleton)
	return bool(Advanced().StartRemotePlayTogether(show_overlay))
}

/*
Use this along with [method Steam.endFileWriteBatch] to wrap a set of local file writes/deletes that should be considered part of one single state change. For example, if saving game progress requires updating both savegame1.dat and maxprogress.dat, wrap those operations with calls to [method Steam.beginFileWriteBatch] and [method Steam.endFileWriteBatch].
These functions provide a hint to Steam which will help it manage the app's Cloud files. Using these functions is optional, however it will provide better reliability.
Note that the functions may be used whether the writes are done using the Remote Storage API, or done directly to local disk (where AutoCloud is used).
*/
func BeginFileWriteBatch() bool { //gd:Steam.beginFileWriteBatch
	once.Do(singleton)
	return bool(Advanced().BeginFileWriteBatch())
}

/*
Use this along with [method Steam.beginFileWriteBatch] - see that documentation for more details.
*/
func EndFileWriteBatch() bool { //gd:Steam.endFileWriteBatch
	once.Do(singleton)
	return bool(Advanced().EndFileWriteBatch())
}

/*
Deletes a file from the local disk, and propagates that delete to the cloud.
This is meant to be used when a user actively deletes a file. Use [method Steam.fileForget] if you want to remove a file from the Steam Cloud but retain it on the users local disk.
When a file has been deleted it can be re-written with [method Steam.fileWrite] to reupload it to the Steam Cloud.
*/
func FileDelete(file string) bool { //gd:Steam.fileDelete
	once.Do(singleton)
	return bool(Advanced().FileDelete(String.New(file)))
}

/*
Check if a remote file exists.
*/
func FileExists(file string) bool { //gd:Steam.fileExists
	once.Do(singleton)
	return bool(Advanced().FileExists(String.New(file)))
}

/*
Deletes the file from remote storage, but leaves it on the local disk and remains accessible from the API.
When you are out of Cloud space, this can be used to allow calls to [method Steam.fileWrite] to keep working without needing to make the user delete files.
How you decide which files to forget are up to you. It could be a simple Least Recently Used (LRU) queue or something more complicated.
Requiring the user to manage their Cloud-ized files for a game, while is possible to do, it is never recommended. For instance, "Which file would you like to delete so that you may store this new one?" removes a significant advantage of using the Cloud in the first place: its transparency.
Once a file has been deleted or forgotten, calling [method Steam.fileWrite] will resynchronize it in the Cloud. Rewriting a forgotten file is the only way to make it persisted again.
*/
func FileForget(file string) bool { //gd:Steam.fileForget
	once.Do(singleton)
	return bool(Advanced().FileForget(String.New(file)))
}

/*
Checks if a specific file is persisted in the Steam Cloud.
*/
func FilePersisted(file string) bool { //gd:Steam.filePersisted
	once.Do(singleton)
	return bool(Advanced().FilePersisted(String.New(file)))
}

/*
Opens a binary file, reads the contents of the file into a byte array, and then closes the file.
The returned dictionary contains the following keys:
[codeblock]
┠╴ret (bool)
┖╴buf (PackedByteArray)
[/codeblock]
[b]Note:[/b] This is a synchronous call and as such is a will block your calling thread on the disk IO, and will also block the SteamAPI, which can cause other threads in your application to block. To avoid "hitching" due to a busy disk on the client machine using [method Steam.fileReadAsync], the asynchronous version of this API is recommended.
*/
func FileRead(file string, data_to_read int) map[any]any { //gd:Steam.fileRead
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().FileRead(String.New(file), int64(data_to_read))))
}

/*
Starts an asynchronous read from a file. The offset and amount to read should be valid for the size of the file, as indicated by [method Steam.getFileSize] or [method Steam.getFileTimestamp].
Triggers a [signal Steam.file_read_async_complete] call result.
*/
func FileReadAsync(file string, offset int, data_to_read int) { //gd:Steam.fileReadAsync
	once.Do(singleton)
	Advanced().FileReadAsync(String.New(file), int64(offset), int64(data_to_read))
}

/*
Share a file.
Triggers a [signal Steam.file_share_result] call result.
*/
func FileShare(file string) { //gd:Steam.fileShare
	once.Do(singleton)
	Advanced().FileShare(String.New(file))
}

/*
Creates a new file, writes the bytes to the file, and then closes the file. If the target file already exists, it is overwritten.
[b]Note:[/b] This is a synchronous call and as such is a will block your calling thread on the disk IO, and will also block the SteamAPI, which can cause other threads in your application to block. To avoid "hitching" due to a busy disk on the client machine using [method Steam.fileWriteAsync], the asynchronous version of this API is recommended.
*/
func FileWrite(file string, data []byte, size int) bool { //gd:Steam.fileWrite
	once.Do(singleton)
	return bool(Advanced().FileWrite(String.New(file), Packed.Bytes(Packed.New(data...)), int64(size)))
}

/*
Creates a new file, writes the bytes to the file, and then closes the file. If the target file already exists, it is overwritten.
[b]Note:[/b] This is a synchronous call and as such is a will block your calling thread on the disk IO, and will also block the SteamAPI, which can cause other threads in your application to block. To avoid "hitching" due to a busy disk on the client machine using [method Steam.fileWriteAsync], the asynchronous version of this API is recommended.
*/
func FileWriteOptions(file string, data []byte, size int) bool { //gd:Steam.fileWrite
	once.Do(singleton)
	return bool(Advanced().FileWrite(String.New(file), Packed.Bytes(Packed.New(data...)), int64(size)))
}

/*
Creates a new file and asynchronously writes the raw byte data to the Steam Cloud, and then closes the file. If the target file already exists, it is overwritten.
Triggers a [signal Steam.file_write_async_complete] call result.
*/
func FileWriteAsync(file string, data []byte, size int) { //gd:Steam.fileWriteAsync
	once.Do(singleton)
	Advanced().FileWriteAsync(String.New(file), Packed.Bytes(Packed.New(data...)), int64(size))
}

/*
Creates a new file and asynchronously writes the raw byte data to the Steam Cloud, and then closes the file. If the target file already exists, it is overwritten.
Triggers a [signal Steam.file_write_async_complete] call result.
*/
func FileWriteAsyncOptions(file string, data []byte, size int) { //gd:Steam.fileWriteAsync
	once.Do(singleton)
	Advanced().FileWriteAsync(String.New(file), Packed.Bytes(Packed.New(data...)), int64(size))
}

/*
Cancels a file write stream that was started by [method Steam.fileWriteStreamOpen].
This trashes all of the data written and closes the write stream, but if there was an existing file with this name, it remains untouched.
*/
func FileWriteStreamCancel(write_handle int) bool { //gd:Steam.fileWriteStreamCancel
	once.Do(singleton)
	return bool(Advanced().FileWriteStreamCancel(int64(write_handle)))
}

/*
Closes a file write stream that was started by [method Steam.fileWriteStreamOpen].
This flushes the stream to the disk, overwriting the existing file if there was one.
*/
func FileWriteStreamClose(write_handle int) bool { //gd:Steam.fileWriteStreamClose
	once.Do(singleton)
	return bool(Advanced().FileWriteStreamClose(int64(write_handle)))
}

/*
Creates a new file output stream allowing you to stream out data to the Steam Cloud file in chunks. If the target file already exists, it is not overwritten until [method Steam.fileWriteStreamClose] has been called.
To write data out to this stream you can use [method Steam.fileWriteStreamWriteChunk], and then to close or cancel you use [method Steam.fileWriteStreamClose] and [method Steam.fileWriteStreamCancel] respectively.
*/
func FileWriteStreamOpen(file string) int { //gd:Steam.fileWriteStreamOpen
	once.Do(singleton)
	return int(int(Advanced().FileWriteStreamOpen(String.New(file))))
}

/*
Writes a blob of data to the file write stream.
*/
func FileWriteStreamWriteChunk(write_handle int, data []byte) bool { //gd:Steam.fileWriteStreamWriteChunk
	once.Do(singleton)
	return bool(Advanced().FileWriteStreamWriteChunk(int64(write_handle), Packed.Bytes(Packed.New(data...))))
}

/*
Gets the number of cached UGC.
*/
func GetCachedUGCCount() int { //gd:Steam.getCachedUGCCount
	once.Do(singleton)
	return int(int(Advanced().GetCachedUGCCount()))
}

/*
Gets the cached UGC's handle.
*/
func GetCachedUGCHandle(content int) int { //gd:Steam.getCachedUGCHandle
	once.Do(singleton)
	return int(int(Advanced().GetCachedUGCHandle(int64(content))))
}

/*
Gets the total number of local files synchronized by Steam Cloud.
Used for enumeration with [method Steam.getFileNameAndSize].
*/
func GetFileCount() int { //gd:Steam.getFileCount
	once.Do(singleton)
	return int(int(Advanced().GetFileCount()))
}

/*
Gets the file name and size of a file from the index.
The returned dictionary contains the following keys:
[codeblock]
┠╴name (string)
┖╴size (int)
[/codeblock]
[b]Note:[/b] You must call [method Steam.getFileCount] first to get the number of files.
*/
func GetFileNameAndSize(file int) map[any]any { //gd:Steam.getFileNameAndSize
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetFileNameAndSize(int64(file))))
}

/*
Get the size of the current file.
*/
func GetFileSize(file string) int { //gd:Steam.getFileSize
	once.Do(singleton)
	return int(int(Advanced().GetFileSize(String.New(file))))
}

/*
Get the timestamp of when the file was uploaded.
*/
func GetFileTimestamp(file string) int { //gd:Steam.getFileTimestamp
	once.Do(singleton)
	return int(int(Advanced().GetFileTimestamp(String.New(file))))
}

/*
After calling [method Steam.getLocalFileChangeCount], use this method to iterate over the changes. The changes described have already been made to local files. Your application should take appropriate action to reload state from disk, and possibly notify the user.
For example: The local system had been suspended, during which time the user played elsewhere and uploaded changes to the Steam Cloud. On resume, Steam downloads those changes to the local system before resuming the application. The application receives an [signal Steam.local_file_changed], and uses [method Steam.getLocalFileChangeCount], and [method Steam.getLocalFileChange] to iterate those changes. Depending on the application structure and the nature of the changes, the application could:
• Re-load game progress to resume at exactly the point where the user was when they exited the game on the other device
• Notify the user of any synchronized changes that don't require reloading
• Etc.
The returned dictionary contains the following keys:
[codeblock]
┠╴file (string)
┠╴change_type (int)
┖╴path_type (int)
[/codeblock]
[b]Note:[/b] only applies to applications flagged as supporting dynamic Steam Cloud sync.
*/
func GetLocalFileChange(file int) map[any]any { //gd:Steam.getLocalFileChange
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetLocalFileChange(int64(file))))
}

/*
When your application receives a [signal Steam.local_file_changed], use this method to get the number of changes (file updates and file deletes) that have been made. You can then iterate the changes using [method Steam.getLocalFileChange].
[b]Note:[/b] only applies to applications flagged as supporting dynamic Steam Cloud sync.
*/
func GetLocalFileChangeCount() int { //gd:Steam.getLocalFileChangeCount
	once.Do(singleton)
	return int(int(Advanced().GetLocalFileChangeCount()))
}

/*
Gets the number of bytes available, and used on the users Steam Cloud storage.
The returned dictionary contains the following keys:
[codeblock]
┠╴total_bytes (int)
┖╴available_bytes (int)
[/codeblock]
*/
func GetQuota() map[any]any { //gd:Steam.getQuota
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetQuota()))
}

/*
Obtains the platforms that the specified file will synchronize to.
The returned dictionary contains the following keys:
[codeblock]
┠╴bitwise (int)
  - 0 / None
  - 1<<0 / Windows
  - 1<<1 / OSX
  - 1<<2 / PS3
  - 1<<3 / Linux
  - 1<<4 / Reserved
  - 0xffffffff / All

┖╴verbose (string)
[/codeblock]
*/
func GetSyncPlatforms(file string) map[any]any { //gd:Steam.getSyncPlatforms
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetSyncPlatforms(String.New(file))))
}

/*
Gets metadata for a file after it has been downloaded. This is the same metadata given in the [signal Steam.download_ugc_result] call result.
The returned dictionary contains the following keys:
[codeblock]
┠╴handle (int)
┠╴app_id (int)
┠╴size (int)
┠╴filename (string)
┖╴owner_id (int)
[/codeblock]
*/
func GetUGCDetails(content int) map[any]any { //gd:Steam.getUGCDetails
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetUGCDetails(int64(content))))
}

/*
Gets the amount of data downloaded so far for a piece of content. bytes_expected can be 0 if function returns false or if the transfer hasn't started yet, so be careful to check for that before dividing to get a percentage.
The returned dictionary contains the following keys:
[codeblock]
┠╴bytes_downloaded (int)
┖╴bytes_expected (int)
[/codeblock]
*/
func GetUGCDownloadProgress(content int) map[any]any { //gd:Steam.getUGCDownloadProgress
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetUGCDownloadProgress(int64(content))))
}

/*
Checks if the account wide Steam Cloud setting is enabled for this user; or if they disabled it in the Settings->Cloud dialog.
Ensure that you are also checking [method Steam.isCloudEnabledForApp], as these two options are mutually exclusive.
*/
func IsCloudEnabledForAccount() bool { //gd:Steam.isCloudEnabledForAccount
	once.Do(singleton)
	return bool(Advanced().IsCloudEnabledForAccount())
}

/*
Checks if the per game Steam Cloud setting is enabled for this user; or if they disabled it in the Game Properties->Update dialog.
Ensure that you are also checking [method Steam.isCloudEnabledForAccount], as these two options are mutually exclusive.
It's generally recommended that you allow the user to toggle this setting within your in-game options, you can toggle it with [method Steam.setCloudEnabledForApp].
*/
func IsCloudEnabledForApp() bool { //gd:Steam.isCloudEnabledForApp
	once.Do(singleton)
	return bool(Advanced().IsCloudEnabledForApp())
}

/*
Enable or disable Steam Cloud for this application. This must only ever be called as the direct result of the user explicitly requesting that it's enabled or not. This is typically accomplished with a checkbox within your in-game options.
*/
func SetCloudEnabledForApp(enabled bool) { //gd:Steam.setCloudEnabledForApp
	once.Do(singleton)
	Advanced().SetCloudEnabledForApp(enabled)
}

/*
Allows you to specify which operating systems a file will be synchronized to.
Use this if you have a multiplatform game but have data which is incompatible between platforms.
Files default to k_ERemoteStoragePlatformAll (0xffffffff) when they are first created. You can use the bitwise OR operator, "|" to specify multiple platforms.
*/
func SetSyncPlatforms(file string, platform int) bool { //gd:Steam.setSyncPlatforms
	once.Do(singleton)
	return bool(Advanced().SetSyncPlatforms(String.New(file), int64(platform)))
}

/*
Downloads a UGC file.
A priority value of 0 will download the file immediately, otherwise it will wait to download the file until all downloads with a lower priority value are completed.  Downloads with equal priority will occur simultaneously.
*/
func UgcDownload(content int, priority int) { //gd:Steam.ugcDownload
	once.Do(singleton)
	Advanced().UgcDownload(int64(content), int64(priority))
}

/*
Downloads a UGC file to a specific location.
*/
func UgcDownloadToLocation(content int, location string, priority int) { //gd:Steam.ugcDownloadToLocation
	once.Do(singleton)
	Advanced().UgcDownloadToLocation(int64(content), String.New(location), int64(priority))
}

/*
After download, gets the content of the file.
*/
func UgcRead(content int, data_size int, offset int, action UGCReadAction) []byte { //gd:Steam.ugcRead
	once.Do(singleton)
	return []byte(Advanced().UgcRead(int64(content), int64(data_size), int64(offset), action).Bytes())
}

/*
Adds a screenshot to the user's Steam screenshot library from disk.
*/
func AddScreenshotToLibrary(filename string, thumbnail_filename string, width int, height int) int { //gd:Steam.addScreenshotToLibrary
	once.Do(singleton)
	return int(int(Advanced().AddScreenshotToLibrary(String.New(filename), String.New(thumbnail_filename), int64(width), int64(height))))
}

/*
Adds a VR screenshot to the user's Steam screenshot library from disk in the supported type.
*/
func AddVRScreenshotToLibrary(atype VRScreenshotType, filename string, vr_filename string) int { //gd:Steam.addVRScreenshotToLibrary
	once.Do(singleton)
	return int(int(Advanced().AddVRScreenshotToLibrary(atype, String.New(filename), String.New(vr_filename))))
}

/*
Toggles whether the overlay handles screenshots.
*/
func HookScreenshots(hook bool) { //gd:Steam.hookScreenshots
	once.Do(singleton)
	Advanced().HookScreenshots(hook)
}

/*
Checks if the app is hooking screenshots.
*/
func IsScreenshotsHooked() bool { //gd:Steam.isScreenshotsHooked
	once.Do(singleton)
	return bool(Advanced().IsScreenshotsHooked())
}

/*
Sets optional metadata about a screenshot's location.
*/
func SetLocation(screenshot int, location string) bool { //gd:Steam.setLocation
	once.Do(singleton)
	return bool(Advanced().SetLocation(int64(screenshot), String.New(location)))
}

/*
Tags a published file as being visible in the screenshot.
*/
func TagPublishedFile(screenshot int, file_id int) bool { //gd:Steam.tagPublishedFile
	once.Do(singleton)
	return bool(Advanced().TagPublishedFile(int64(screenshot), int64(file_id)))
}

/*
Tags a Steam user as being visible in the screenshot. You can tag up to the value declared by k_nScreenshotMaxTaggedUsers in a single screenshot. Tagging more users than that will just be discarded. This function has a built in delay before saving the tag which allows you to call it repeatedly for each item. You can get the handle to tag the screenshot once it has been successfully saved from the [signal Steam.screenshot_ready] callback or via the [method Steam.writeScreenshot], [method Steam.addScreenshotToLibrary], [method Steam.addVRScreenshotToLibrary] calls.
*/
func TagUser(screenshot int, steam_id int) bool { //gd:Steam.tagUser
	once.Do(singleton)
	return bool(Advanced().TagUser(int64(screenshot), int64(steam_id)))
}

/*
Causes Steam overlay to take a screenshot.
*/
func TriggerScreenshot() { //gd:Steam.triggerScreenshot
	once.Do(singleton)
	Advanced().TriggerScreenshot()
}

/*
Writes a screenshot to the user's Steam screenshot library.
*/
func WriteScreenshot(rgb []byte, width int, height int) int { //gd:Steam.writeScreenshot
	once.Do(singleton)
	return int(int(Advanced().WriteScreenshot(Packed.Bytes(Packed.New(rgb...)), int64(width), int64(height))))
}

/*
Add a tag that applies to the entire phase.
*/
func AddGamePhaseTag(tag_name string, tag_icon string, tag_group string, priority int) { //gd:Steam.addGamePhaseTag
	once.Do(singleton)
	Advanced().AddGamePhaseTag(String.New(tag_name), String.New(tag_icon), String.New(tag_group), int64(priority))
}

/*
Use this to mark an event (A) on the Timeline. This event will be instantaneous. (See [method Steam.addRangeTimelineEvent] to add events that happened over time.)
*/
func AddInstantaneousTimelineEvent(title string, description string, icon string, icon_priority int, start_offset_seconds Float.X) int { //gd:Steam.addInstantaneousTimelineEvent
	once.Do(singleton)
	return int(int(Advanced().AddInstantaneousTimelineEvent(String.New(title), String.New(description), String.New(icon), int64(icon_priority), float64(start_offset_seconds), 1)))
}

/*
Use this to mark an event (A) on the Timeline. This event will be instantaneous. (See [method Steam.addRangeTimelineEvent] to add events that happened over time.)
*/
func AddInstantaneousTimelineEventOptions(title string, description string, icon string, icon_priority int, start_offset_seconds Float.X, possible_clip TimelineEventClipPriority) int { //gd:Steam.addInstantaneousTimelineEvent
	once.Do(singleton)
	return int(int(Advanced().AddInstantaneousTimelineEvent(String.New(title), String.New(description), String.New(icon), int64(icon_priority), float64(start_offset_seconds), possible_clip)))
}

/*
Use this to mark an event (A) on the Timeline that takes some amount of time to complete.
*/
func AddRangeTimelineEvent(title string, description string, icon string, icon_priority int, start_offset_seconds Float.X, duration Float.X) int { //gd:Steam.addRangeTimelineEvent
	once.Do(singleton)
	return int(int(Advanced().AddRangeTimelineEvent(String.New(title), String.New(description), String.New(icon), int64(icon_priority), float64(start_offset_seconds), float64(duration), 1)))
}

/*
Use this to mark an event (A) on the Timeline that takes some amount of time to complete.
*/
func AddRangeTimelineEventOptions(title string, description string, icon string, icon_priority int, start_offset_seconds Float.X, duration Float.X, possible_clip TimelineEventClipPriority) int { //gd:Steam.addRangeTimelineEvent
	once.Do(singleton)
	return int(int(Advanced().AddRangeTimelineEvent(String.New(title), String.New(description), String.New(icon), int64(icon_priority), float64(start_offset_seconds), float64(duration), possible_clip)))
}

/*
Clear a network identity's data.
*/
func ClearTimelineTooltip(time_delta Float.X) { //gd:Steam.clearTimelineTooltip
	once.Do(singleton)
	Advanced().ClearTimelineTooltip(float64(time_delta))
}

/*
Add a tag to whatever time range is represented by the event.
*/
func DoesEventRecordingExist(this_event int) { //gd:Steam.doesEventRecordingExist
	once.Do(singleton)
	Advanced().DoesEventRecordingExist(int64(this_event))
}

/*
Use this to determine if video recordings exist for the specified game phase. Steam will sent a [signal Steam.timeline_game_phase_recording_exists] callback with the result. This can be useful when the game needs to decide whether or not to show a control that will call [method Steam.openOverlayToGamePhase].
*/
func DoesGamePhaseRecordingExist(phase_id string) { //gd:Steam.doesGamePhaseRecordingExist
	once.Do(singleton)
	Advanced().DoesGamePhaseRecordingExist(String.New(phase_id))
}

/*
Use this to end a game phase that was started with [method Steam.startGamePhase].
*/
func EndGamePhase() { //gd:Steam.endGamePhase
	once.Do(singleton)
	Advanced().EndGamePhase()
}

/*
Ends a range timeline event and shows it in the UI.
*/
func EndRangeTimelineEvent(this_event int, end_offset_seconds Float.X) { //gd:Steam.endRangeTimelineEvent
	once.Do(singleton)
	Advanced().EndRangeTimelineEvent(int64(this_event), float64(end_offset_seconds))
}

/*
Opens the Steam overlay to a game phase.
*/
func OpenOverlayToGamePhase(phase_id string) { //gd:Steam.openOverlayToGamePhase
	once.Do(singleton)
	Advanced().OpenOverlayToGamePhase(String.New(phase_id))
}

/*
Opens the Steam overlay to a timeline event.
*/
func OpenOverlayToTimelineEvent(this_event int) { //gd:Steam.openOverlayToTimelineEvent
	once.Do(singleton)
	Advanced().OpenOverlayToTimelineEvent(int64(this_event))
}

/*
Delete the event from the timeline. This can be called on a timeline event from [method Steam.addInstantaneousTimelineEvent], [method Steam.addRangeTimelineEvent], or [method Steam.startRangeTimelineEvent] / [method Steam.endRangeTimelineEvent]. The timeline event handle must be from the current game process.
*/
func RemoveTimelineEvent(this_event int) { //gd:Steam.removeTimelineEvent
	once.Do(singleton)
	Advanced().RemoveTimelineEvent(int64(this_event))
}

/*
Add a text attribute that applies to the entire phase.
*/
func SetGamePhaseAttribute(attribute_group string, attribute_value string, priority int) { //gd:Steam.setGamePhaseAttribute
	once.Do(singleton)
	Advanced().SetGamePhaseAttribute(String.New(attribute_group), String.New(attribute_value), int64(priority))
}

/*
Games can set a phase ID.
*/
func SetGamePhaseID(phase_id string) { //gd:Steam.setGamePhaseID
	once.Do(singleton)
	Advanced().SetGamePhaseID(String.New(phase_id))
}

/*
Changes the color of the timeline bar. See TimelineGameMode comments for how to use each value.
*/
func SetTimelineGameMode(mode TimelineGameMode) { //gd:Steam.setTimelineGameMode
	once.Do(singleton)
	Advanced().SetTimelineGameMode(mode)
}

/*
Sets a description for the current game state in the timeline. These help the user to find specific moments in the timeline when saving clips. Setting a new state description replaces any previous description.
*/
func SetTimelineTooltip(description string, time_delta Float.X) { //gd:Steam.setTimelineTooltip
	once.Do(singleton)
	Advanced().SetTimelineTooltip(String.New(description), float64(time_delta))
}

/*
Use this to start a game phase. Game phases allow the user to navigate their background recordings and clips. Exactly what a game phase means will vary game to game, but the game phase should be a section of gameplay that is usually between 10 minutes and a few hours in length, and should be the main way a user would think to divide up the game. These are presented to the user in a UI that shows the date the game was played, with one row per game slice. Game phases should be used to mark sections of gameplay that the user might be interested in watching.
*/
func StartGamePhase() { //gd:Steam.startGamePhase
	once.Do(singleton)
	Advanced().StartGamePhase()
}

/*
Starts a timeline event at a the current time, plus an offset in seconds. This event must be ended with [method Steam.endRangeTimelineEvent]. Any timeline events that have not been ended when the game exits will be discarded.
*/
func StartRangeTimelineEvent(title string, description string, icon string, priority int, start_offset_seconds Float.X) int { //gd:Steam.startRangeTimelineEvent
	once.Do(singleton)
	return int(int(Advanced().StartRangeTimelineEvent(String.New(title), String.New(description), String.New(icon), int64(priority), float64(start_offset_seconds), 1)))
}

/*
Starts a timeline event at a the current time, plus an offset in seconds. This event must be ended with [method Steam.endRangeTimelineEvent]. Any timeline events that have not been ended when the game exits will be discarded.
*/
func StartRangeTimelineEventOptions(title string, description string, icon string, priority int, start_offset_seconds Float.X, possible_clip TimelineEventClipPriority) int { //gd:Steam.startRangeTimelineEvent
	once.Do(singleton)
	return int(int(Advanced().StartRangeTimelineEvent(String.New(title), String.New(description), String.New(icon), int64(priority), float64(start_offset_seconds), possible_clip)))
}

/*
Updates fields on a range timeline event that was started with StartRangeTimelineEvent, and which has not been ended.
*/
func UpdateRangeTimelineEvent(this_event int, title string, description string, icon string, priority int) { //gd:Steam.updateRangeTimelineEvent
	once.Do(singleton)
	Advanced().UpdateRangeTimelineEvent(int64(this_event), String.New(title), String.New(description), String.New(icon), int64(priority), 1)
}

/*
Updates fields on a range timeline event that was started with StartRangeTimelineEvent, and which has not been ended.
*/
func UpdateRangeTimelineEventOptions(this_event int, title string, description string, icon string, priority int, possible_clip TimelineEventClipPriority) { //gd:Steam.updateRangeTimelineEvent
	once.Do(singleton)
	Advanced().UpdateRangeTimelineEvent(int64(this_event), String.New(title), String.New(description), String.New(icon), int64(priority), possible_clip)
}

/*
Adds a dependency between the given item and the appid. This list of dependencies can be retrieved by calling [method  Steam.getAppDependencies]. This is a soft-dependency that is displayed on the web. It is up to the application to determine whether the item can actually be used or not.
Triggers a [signal Steam.add_app_dependency_result] callback.
*/
func AddAppDependency(published_file_id int, app_id int) { //gd:Steam.addAppDependency
	once.Do(singleton)
	Advanced().AddAppDependency(int64(published_file_id), int64(app_id))
}

/*
Add a content descriptor to a piece of UGC.
[b]Note:[/b] Valve has no documentation on this function currently.
*/
func AddContentDescriptor(update_handle int, descriptor_id int) bool { //gd:Steam.addContentDescriptor
	once.Do(singleton)
	return bool(Advanced().AddContentDescriptor(int64(update_handle), int64(descriptor_id)))
}

/*
Adds a workshop item as a dependency to the specified item. If the published_file_id item is of type WORKSHOP_FILE_TYPE_COLLECTION (2), than the child_published_file_id is simply added to that collection. Otherwise, the dependency is a soft one that is displayed on the web and can be retrieved via the UGC API using a combination of the [b]children[/b] key returned from [method Steam.getQueryUGCResult] and [method Steam.getQueryUGCChildren].
Triggers a [signal Steam.add_ugc_dependency_result] callback.
*/
func AddDependency(published_file_id int, child_published_file_id int) { //gd:Steam.addDependency
	once.Do(singleton)
	Advanced().AddDependency(int64(published_file_id), int64(child_published_file_id))
}

/*
Adds a excluded tag to a pending UGC Query. This will only return UGC without the specified tag.
[b]Note:[/b] This must be set before you send a UGC Query handle using [method Steam.sendQueryUGCRequest].
*/
func AddExcludedTag(query_handle int, tag_name string) bool { //gd:Steam.addExcludedTag
	once.Do(singleton)
	return bool(Advanced().AddExcludedTag(int64(query_handle), String.New(tag_name)))
}

/*
Adds a key-value tag pair to an item. Keys can map to multiple different values (1-to-many relationship).
Key names are restricted to alphanumeric characters and the '_' character.
Both keys and values cannot exceed 255 characters in length.
Key-value tags are searchable by exact match only.
[b]Note:[/b] This must be set before you submit the UGC update handle using [method Steam.submitItemUpdate].
*/
func AddItemKeyValueTag(query_handle int, key string, value string) bool { //gd:Steam.addItemKeyValueTag
	once.Do(singleton)
	return bool(Advanced().AddItemKeyValueTag(int64(query_handle), String.New(key), String.New(value)))
}

/*
Adds an additional preview file for the item.
Then the format of the image should be one that both the web and the application (if necessary) can render, and must be under 1MB. Suggested formats include JPG, PNG and GIF.
[b]Note:[/b] Using 1 or 2 in type are not currently supported with this API. For YouTube videos you should use [method Steam.addItemPreviewVideo].
[b]Note:[/b] This must be set before you submit the UGC update handle using [method Steam.submitItemUpdate].
*/
func AddItemPreviewFile(query_handle int, preview_file string, atype ItemPreviewType) bool { //gd:Steam.addItemPreviewFile
	once.Do(singleton)
	return bool(Advanced().AddItemPreviewFile(int64(query_handle), String.New(preview_file), atype))
}

/*
Adds an additional video preview from YouTube for the item.
[b]Note:[/b] This must be set before you submit the UGC update handle using [method Steam.submitItemUpdate](/functions/ugc/#submititemupdate).
*/
func AddItemPreviewVideo(query_handle int, video_id string) bool { //gd:Steam.addItemPreviewVideo
	once.Do(singleton)
	return bool(Advanced().AddItemPreviewVideo(int64(query_handle), String.New(video_id)))
}

/*
Adds a workshop item to the users favorites list.
Triggers a [signal Steam.user_favorite_items_list_changed] callback.
*/
func AddItemToFavorites(app_id int, published_file_id int) { //gd:Steam.addItemToFavorites
	once.Do(singleton)
	Advanced().AddItemToFavorites(int64(app_id), int64(published_file_id))
}

/*
Adds a required key-value tag to a pending UGC Query. This will only return workshop items that have a key and a value.
[b]Note:[/b] This must be set before you submit the UGC update handle using [method Steam.submitItemUpdate].
*/
func AddRequiredKeyValueTag(query_handle int, key string, value string) bool { //gd:Steam.addRequiredKeyValueTag
	once.Do(singleton)
	return bool(Advanced().AddRequiredKeyValueTag(int64(query_handle), String.New(key), String.New(value)))
}

/*
Adds a required tag to a pending UGC Query. This will only return UGC with the specified tag.
[b]Note:[/b] This must be set before you submit the UGC update handle using [method Steam.submitItemUpdate].
*/
func AddRequiredTag(query_handle int, tag_name string) bool { //gd:Steam.addRequiredTag
	once.Do(singleton)
	return bool(Advanced().AddRequiredTag(int64(query_handle), String.New(tag_name)))
}

/*
Adds the requirement that the returned items from the pending UGC Query have at least one of the tags in the given set (logical "or"). For each tag group that is added, at least one tag from each group is required to be on the matching items.
[b]Note:[/b] This must be set before you submit the UGC update handle using [method Steam.submitItemUpdate].
*/
func AddRequiredTagGroup(query_handle int, tag_array []any) bool { //gd:Steam.addRequiredTagGroup
	once.Do(singleton)
	return bool(Advanced().AddRequiredTagGroup(int64(query_handle), gd.EngineArrayFromSlice(tag_array)))
}

/*
Lets game servers set a specific workshop folder before issuing any UGC commands.
This is helpful if you want to support multiple game servers running out of the same install folder.
*/
func InitWorkshopForGameServer(workshop_depot_id int, folder string) bool { //gd:Steam.initWorkshopForGameServer
	once.Do(singleton)
	return bool(Advanced().InitWorkshopForGameServer(int64(workshop_depot_id), String.New(folder)))
}

/*
Creates a new workshop item with no content attached yet.
Triggers a [signal Steam.item_created] callback.
*/
func CreateItem(app_id int, file_type WorkshopFileType) { //gd:Steam.createItem
	once.Do(singleton)
	Advanced().CreateItem(int64(app_id), file_type)
}

/*
Query for all matching UGC. You can use this to list all of the available UGC for your app.
This will return up to 50 results. You can make subsequent calls to this function, increasing the page each time to get the next set of results.
To query for the UGC associated with a single user you can use [method Steam.createQueryUserUGCRequest] instead.
[b]Note:[/b] Either consumer_id or creator_id must have a valid app ID.
[b]Note:[/b] You must release the handle returned by this function by calling [method Steam.releaseQueryUGCRequest] when you are done with it.
*/
func CreateQueryAllUGCRequest(query_type UGCQuery, matching_type UGCMatchingUGCType, creator_id int, consumer_id int, page int) int { //gd:Steam.createQueryAllUGCRequest
	once.Do(singleton)
	return int(int(Advanced().CreateQueryAllUGCRequest(query_type, matching_type, int64(creator_id), int64(consumer_id), int64(page))))
}

/*
Query for the details of specific workshop items.
This will return up to 50 results.
To query all the UGC for your app you can use [method Steam.createQueryAllUGCRequest] instead.
[b]Note:[/b] Either consumer_id or creator_id must have a valid app ID.
[b]Note:[/b] You must release the handle returned by this function by calling [method Steam.releaseQueryUGCRequest] when you are done with it.
*/
func CreateQueryUGCDetailsRequest(published_file_id []any) int { //gd:Steam.createQueryUGCDetailsRequest
	once.Do(singleton)
	return int(int(Advanced().CreateQueryUGCDetailsRequest(gd.EngineArrayFromSlice(published_file_id))))
}

/*
Query UGC associated with a user. You can use this to list the UGC the user is subscribed to amongst other things.
This will return up to 50 results.
To query all the UGC for your app you can use [method Steam.createQueryAllUGCRequest] instead.
[b]Note:[/b] Either consumer_id or creator_id must have a valid app ID.
[b]Note:[/b] You must release the handle returned by this function by calling [method Steam.releaseQueryUGCRequest] when you are done with it.
*/
func CreateQueryUserUGCRequest(account_id int, list_type UserUGCList, matching_ugc_type UGCMatchingUGCType, sort_order UserUGCListSortOrder, creator_id int, consumer_id int, page int) int { //gd:Steam.createQueryUserUGCRequest
	once.Do(singleton)
	return int(int(Advanced().CreateQueryUserUGCRequest(int64(account_id), list_type, matching_ugc_type, sort_order, int64(creator_id), int64(consumer_id), int64(page))))
}

/*
Deletes the item without prompting the user.
Triggers a [signal Steam.item_deleted] callback.
*/
func DeleteItem(published_file_id int) { //gd:Steam.deleteItem
	once.Do(singleton)
	Advanced().DeleteItem(int64(published_file_id))
}

/*
Download new or update already installed item.
If the return value is true then register and wait for the callback [signal Steam.item_downloaded] before calling [method Steam.getItemInstallInfo] or accessing the workshop item on disk.
If the user is not subscribed to the item (e.g. a Game Server using anonymous login), the workshop item will be downloaded and cached temporarily.
If the workshop item has an item state of 8, then this function can be called to initiate the update. Do not access the workshop item on disk until the callback [signal Steam.item_downloaded] is called.
*/
func DownloadItem(published_file_id int, high_priority bool) bool { //gd:Steam.downloadItem
	once.Do(singleton)
	return bool(Advanced().DownloadItem(int64(published_file_id), high_priority))
}

/*
Get info about a pending download of a workshop item that has 8 set.
The returned dictionary contains the following keys:
[codeblock]
┠╴ret (bool)
┠╴downloaded (int)
┖╴total (int)
[/codeblock]
*/
func GetItemDownloadInfo(published_file_id int) map[any]any { //gd:Steam.getItemDownloadInfo
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetItemDownloadInfo(int64(published_file_id))))
}

/*
Gets info about currently installed content on the disc for workshop items that have k_EItemStateInstalled (4) set.
Calling this sets the "used" flag on the workshop item for the current player and adds it to their k_EUserUGCList_UsedOrPlayed (7) list.
If k_EItemStateLegacyItem (2) is set then folder contains the path to the legacy file itself, not a folder.
The returned dictionary contains the following keys:
[codeblock]
┠╴ret (bool)
┠╴size (int)
┠╴folder (string)
┖╴timestamp (int)
[/codeblock]
*/
func GetItemInstallInfo(published_file_id int) map[any]any { //gd:Steam.getItemInstallInfo
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetItemInstallInfo(int64(published_file_id))))
}

/*
Gets the current state of a workshop item on this client.
It should be one of the following:
[codeblock]
• 0 / None
• 1 / Subscribed
• 2 / Legacy
• 4 / Installed
• 8 / Update
• 16 / Downloading
• 32 / Pending
[/codeblock]
*/
func GetItemState(published_file_id int) int { //gd:Steam.getItemState
	once.Do(singleton)
	return int(int(Advanced().GetItemState(int64(published_file_id))))
}

/*
Gets the progress of an item update.
The returned dictionary contains the following keys:
[codeblock]
┠╴status (int)
┠╴processed (int)
┖╴total (int)
[/codeblock]
*/
func GetItemUpdateProgress(update_handle int) map[any]any { //gd:Steam.getItemUpdateProgress
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetItemUpdateProgress(int64(update_handle))))
}

/*
Gets the total number of items the current user is subscribed to for the game or application.
*/
func GetNumSubscribedItems() int { //gd:Steam.getNumSubscribedItems
	once.Do(singleton)
	return int(int(Advanced().GetNumSubscribedItems()))
}

/*
Get the number of supported game versions for this UGC content.
*/
func GetNumSupportedGameVersions(query_handle int, index int) int { //gd:Steam.getNumSupportedGameVersions
	once.Do(singleton)
	return int(int(Advanced().GetNumSupportedGameVersions(int64(query_handle), int64(index))))
}

/*
Retrieve the details of an additional preview associated with an individual workshop item after receiving a querying UGC call result.
You should call this in a loop to get the details of all the workshop items returned.
Before calling this you should call [method Steam.getQueryUGCNumAdditionalPreviews] to get number of additional previews.
The returned dictionary contains the following keys:
[codeblock]
┠╴success (bool)
┠╴handle (int)
┠╴index (int)
┠╴preview (int)
┠╴url_or_video (string)
┠╴filename (string)
┖╴type (int)
[/codeblock]
[b]Note:[/b] This must only be called with the handle obtained from a successful [signal Steam.ugc_query_completed] call result.
*/
func GetQueryUGCAdditionalPreview(query_handle int, index int, preview_index int) map[any]any { //gd:Steam.getQueryUGCAdditionalPreview
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetQueryUGCAdditionalPreview(int64(query_handle), int64(index), int64(preview_index))))
}

/*
Retrieve the IDs of any child items of an individual workshop item after receiving a querying UGC call result. These items can either be a part of a collection or some other dependency (see [method Steam.addDependency]).
You should create published_file_id with num_children provided in returned dictionary after getting the UGC details with [method Steam.getQueryUGCResult].
The returned dictionary contains the following keys:
[codeblock]
┠╴success (bool)
┠╴handle (int)
┠╴index (int)
┖╴children (int)
[/codeblock]
[b]Note:[/b] This must only be called with the handle obtained from a successful [signal Steam.ugc_query_completed] call result.
*/
func GetQueryUGCChildren(query_handle int, index int, child_count int) map[any]any { //gd:Steam.getQueryUGCChildren
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetQueryUGCChildren(int64(query_handle), int64(index), int64(child_count))))
}

/*
Get an UGC item's content descriptors for mature content.
The returned dictionary contains the following keys:
[codeblock]
┠╴result (int)
┠╴handle (int)
┠╴index (int)
┖╴descriptors (array)
[/codeblock]
Descriptors array will contain a list of integers that correspond to the following UGC enums for descriptors:
[codeblock]
• 1 / Nudity or sexual content
• 2 / Frequent violence or gore
• 3 / Adult only sexual content
• 4 / Gratuitous sexual content
• 5 / Any mature content
[/codeblock]
[b]Note:[/b] Valve does not have any documentation covering this function at this time.
*/
func GetQueryUGCContentDescriptors(query_handle int, index int, max_entries int) map[any]any { //gd:Steam.getQueryUGCContentDescriptors
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetQueryUGCContentDescriptors(int64(query_handle), int64(index), int64(max_entries))))
}

/*
Retrieve the number of key-value tags of an individual workshop item after receiving a querying UGC call result.
You can then call [method Steam.getQueryUGCKeyValueTag] to get the details of each tag.
[b]Note:[/b] This must only be called with the handle obtained from a successful [signal Steam.ugc_query_completed] call result.
*/
func GetQueryUGCKeyValueTag(query_handle int, index int, key_value_tag_index int) map[any]any { //gd:Steam.getQueryUGCKeyValueTag
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetQueryUGCKeyValueTag(int64(query_handle), int64(index), int64(key_value_tag_index))))
}

/*
Retrieve the developer set metadata of an individual workshop item after receiving a querying UGC call result.
You should call this in a loop to get the details of all the workshop items returned.
[b]Note:[/b] This must only be called with the handle obtained from a successful [signal Steam.ugc_query_completed] call result.
*/
func GetQueryUGCMetadata(query_handle int, index int) string { //gd:Steam.getQueryUGCMetadata
	once.Do(singleton)
	return string(Advanced().GetQueryUGCMetadata(int64(query_handle), int64(index)).String())
}

/*
Retrieve the number of additional previews of an individual workshop item after receiving a querying UGC call result.
You can then call [method Steam.getQueryUGCAdditionalPreview] to get the details of each additional preview.
[b]Note:[/b] This must only be called with the handle obtained from a successful [signal Steam.ugc_query_completed] call result.
*/
func GetQueryUGCNumAdditionalPreviews(query_handle int, index int) int { //gd:Steam.getQueryUGCNumAdditionalPreviews
	once.Do(singleton)
	return int(int(Advanced().GetQueryUGCNumAdditionalPreviews(int64(query_handle), int64(index))))
}

/*
Retrieve the number of key-value tags of an individual workshop item after receiving a querying UGC call result.
You can then call [method Steam.getQueryUGCKeyValueTag] to get the details of each tag.
[b]Note:[/b] This must only be called with the handle obtained from a successful [signal Steam.ugc_query_completed] call result.
*/
func GetQueryUGCNumKeyValueTags(query_handle int, index int) int { //gd:Steam.getQueryUGCNumKeyValueTags
	once.Do(singleton)
	return int(int(Advanced().GetQueryUGCNumKeyValueTags(int64(query_handle), int64(index))))
}

/*
Available in SDK v1.51.
Retrieve the number of tags for an individual workshop item after receiving a querying UGC call result.
You can then call [method Steam.getQueryUGCTag] to get the tag name or [method Steam.getQueryUGCTagDisplayName] to get the localized tag string (if any).
[b]Note:[/b] This must only be called with the handle obtained from a successful [signal Steam.ugc_query_completed] call result.
*/
func GetQueryUGCNumTags(query_handle int, index int) int { //gd:Steam.getQueryUGCNumTags
	once.Do(singleton)
	return int(int(Advanced().GetQueryUGCNumTags(int64(query_handle), int64(index))))
}

/*
Retrieve the URL to the preview image of an individual workshop item after receiving a querying UGC call result.
You can use this URL to download and display the preview image instead of having to download it using the handle_preview_file key in the return dictionary from [method Steam.getQueryUGCResult].
[b]Note:[/b] This must only be called with the handle obtained from a successful [signal Steam.ugc_query_completed] call result.
*/
func GetQueryUGCPreviewURL(query_handle int, index int) string { //gd:Steam.getQueryUGCPreviewURL
	once.Do(singleton)
	return string(Advanced().GetQueryUGCPreviewURL(int64(query_handle), int64(index)).String())
}

/*
Retrieve the details of an individual workshop item after receiving a querying UGC call result.
The returned dictionary contains the following keys:
[codeblock]
┠╴result (int)
┠╴file_id (int)
┠╴file_type (int)
┠╴creator_app_id (int)
┠╴consumer_app_id (int)
┠╴title (string)
┠╴description (string)
┠╴steam_id_owner (int)
┠╴time_created (int)
┠╴time_updated (int)
┠╴time_added_to_user_list (int)
┠╴visibility (int)
┠╴banned (bool)
┠╴accepted_for_use (bool)
┠╴tags_truncated (bool)
┠╴tags (string)
┠╴handle_file (int)
┠╴handle_preview-file (int)
┠╴file_name (string)
┠╴file_size (int)
┠╴preview_file_size (int)
┠╴url (string)
┠╴votes_up (int)
┠╴votes_down (int)
┠╴score (float)
┖╴num_children (int)
[/codeblock]
[b]Note:[/b] This must only be called with the handle obtained from a successful [signal Steam.ugc_query_completed] call result.
*/
func GetQueryUGCResult(query_handle int, index int) map[any]any { //gd:Steam.getQueryUGCResult
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetQueryUGCResult(int64(query_handle), int64(index))))
}

/*
Retrieve various statistics of an individual workshop item after receiving a querying UGC call result.
The returned dictionary contains the following keys:
[codeblock]
┠╴success (bool)
┠╴handle (int)
┠╴index (int)
┠╴type (int)
┖╴value (int)
[/codeblock]
[b]Note:[/b] This must only be called with the handle obtained from a successful [signal Steam.ugc_query_completed] call result.
*/
func GetQueryUGCStatistic(query_handle int, index int, stat_type ItemStatistic) map[any]any { //gd:Steam.getQueryUGCStatistic
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetQueryUGCStatistic(int64(query_handle), int64(index), stat_type)))
}

/*
Available in SDK v1.51.
Retrieve the "nth" tag associated with an individual workshop item after receiving a querying UGC call result.
Before calling this you should call [method Steam.getQueryUGCNumTags] to get number of tags.
[b]Note:[/b] This must only be called with the handle obtained from a successful [signal Steam.ugc_query_completed] call result.
*/
func GetQueryUGCTag(query_handle int, index int, tag_index int) string { //gd:Steam.getQueryUGCTag
	once.Do(singleton)
	return string(Advanced().GetQueryUGCTag(int64(query_handle), int64(index), int64(tag_index)).String())
}

/*
Available in SDK v1.51.
Retrieve the "nth" display string (usually localized) for a tag, which is associated with an individual workshop item after receiving a querying UGC call result.
Before calling this you should call [method Steam.getQueryUGCNumTags] to get number of tags.
[b]Note:[/b] This must only be called with the handle obtained from a successful [signal Steam.ugc_query_completed] call result.
*/
func GetQueryUGCTagDisplayName(query_handle int, index int, tag_index int) string { //gd:Steam.getQueryUGCTagDisplayName
	once.Do(singleton)
	return string(Advanced().GetQueryUGCTagDisplayName(int64(query_handle), int64(index), int64(tag_index)).String())
}

/*
Gets a list of all of the items the current user is subscribed to for the current game.
*/
func GetSubscribedItems() []any { //gd:Steam.getSubscribedItems
	once.Do(singleton)
	return []any(gd.ArrayAs[[]any](gd.InternalArray(Advanced().GetSubscribedItems())))
}

/*
Some items can specify that they have a version that is valid for a range of game versions (Steam branch).
[codeblock]
┠╴min (string)
┠╴max (string)
┖╴size (uint32)
[/codeblock]
*/
func GetSupportedGameVersionData(query_handle int, index int, version_index int) map[any]any { //gd:Steam.getSupportedGameVersionData
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetSupportedGameVersionData(int64(query_handle), int64(index), int64(version_index))))
}

/*
Return the user's community content descriptor preferences.
*/
func GetUserContentDescriptorPreferences(max_entries int) []any { //gd:Steam.getUserContentDescriptorPreferences
	once.Do(singleton)
	return []any(gd.ArrayAs[[]any](gd.InternalArray(Advanced().GetUserContentDescriptorPreferences(int64(max_entries)))))
}

/*
Gets the users vote status on a workshop item.
Triggers a [signal Steam.get_item_vote_result]( callback.
*/
func GetUserItemVote(published_file_id int) { //gd:Steam.getUserItemVote
	once.Do(singleton)
	Advanced().GetUserItemVote(int64(published_file_id))
}

/*
Releases a UGC query handle when you are done with it to free up memory.
*/
func ReleaseQueryUGCRequest(query_handle int) bool { //gd:Steam.releaseQueryUGCRequest
	once.Do(singleton)
	return bool(Advanced().ReleaseQueryUGCRequest(int64(query_handle)))
}

/*
Removes the dependency between the given item and the appid. This list of dependencies can be retrieved by calling [method Steam.getAppDependencies].
Triggers a [signal Steam.remove_app_dependency_result] callback.
*/
func RemoveAppDependency(published_file_id int, app_id int) { //gd:Steam.removeAppDependency
	once.Do(singleton)
	Advanced().RemoveAppDependency(int64(published_file_id), int64(app_id))
}

/*
Removes a mature content descriptor from a piece of UGC.
[b]Note:[/b] Valve has no documentation on this function currently.
*/
func RemoveContentDescriptor(update_handle int, descriptor_id int) bool { //gd:Steam.removeContentDescriptor
	once.Do(singleton)
	return bool(Advanced().RemoveContentDescriptor(int64(update_handle), int64(descriptor_id)))
}

/*
Removes a workshop item as a dependency from the specified item.
Triggers a [signal Steam.remove_ugc_dependency_result] callback.
*/
func RemoveDependency(published_file_id int, child_published_file_id int) { //gd:Steam.removeDependency
	once.Do(singleton)
	Advanced().RemoveDependency(int64(published_file_id), int64(child_published_file_id))
}

/*
Removes a workshop item from the users favorites list.
Triggers a [signal Steam.user_favorite_items_list_changed]callback.
*/
func RemoveItemFromFavorites(app_id int, published_file_id int) { //gd:Steam.removeItemFromFavorites
	once.Do(singleton)
	Advanced().RemoveItemFromFavorites(int64(app_id), int64(published_file_id))
}

/*
Removes an existing key value tag from an item.
You can only call this up to 100 times per item update. If you need remove more tags than that you'll need to make subsequent item updates.
[b]Note:[/b] This must be set before you submit the UGC update handle using [method Steam.submitItemUpdate].
*/
func RemoveItemKeyValueTags(update_handle int, key string) bool { //gd:Steam.removeItemKeyValueTags
	once.Do(singleton)
	return bool(Advanced().RemoveItemKeyValueTags(int64(update_handle), String.New(key)))
}

/*
Removes an existing preview from an item.
*/
func RemoveItemPreview(update_handle int, index int) bool { //gd:Steam.removeItemPreview
	once.Do(singleton)
	return bool(Advanced().RemoveItemPreview(int64(update_handle), int64(index)))
}

/*
Send a UGC query to Steam.
This must be called with a handle obtained from [method Steam.createQueryUserUGCRequest], [method Steam.createQueryAllUGCRequest], or [method Steam.createQueryUGCDetailsRequest] to actually send the request to Steam.
Before calling this you should use one or more of the following APIs to customize your query: [method Steam.addRequiredTag], [method Steam.addExcludedTag], [method Steam.setReturnOnlyIDs], [method Steam.setReturnKeyValueTags], [method Steam.setReturnLongDescription], [method Steam.setReturnMetadata], [method Steam.setReturnChildren], [method Steam.setReturnAdditionalPreviews], [method Steam.setReturnTotalOnly], [method Steam.setLanguage], [method Steam.setAllowCachedResponse], [method Steam.setCloudFileNameFilter], [method Steam.setMatchAnyTag], [method Steam.setSearchText], [method Steam.setRankedByTrendDays], or [method Steam.addRequiredKeyValueTag].
Triggers a [signal Steam.ugc_query_completed] callback.
*/
func SendQueryUGCRequest(update_handle int) { //gd:Steam.sendQueryUGCRequest
	once.Do(singleton)
	Advanced().SendQueryUGCRequest(int64(update_handle))
}

/*
Admin queries return hidden items.
*/
func SetAdminQuery(update_handle int, admin_query bool) bool { //gd:Steam.setAdminQuery
	once.Do(singleton)
	return bool(Advanced().SetAdminQuery(int64(update_handle), admin_query))
}

/*
Sets whether results will be returned from the cache for the specific period of time on a pending UGC Query.
*/
func SetAllowCachedResponse(update_handle int, max_age_seconds int) bool { //gd:Steam.setAllowCachedResponse
	once.Do(singleton)
	return bool(Advanced().SetAllowCachedResponse(int64(update_handle), int64(max_age_seconds)))
}

/*
Sets to only return items that have a specific filename on a pending UGC Query.
[b]Note:[/b] This can only be used with [method Steam.createQueryUserUGCRequest].
[b]Note:[/b] This must be set before you send a UGC Query handle using [method Steam.sendQueryUGCRequest].
*/
func SetCloudFileNameFilter(update_handle int, match_cloud_filename string) bool { //gd:Steam.setCloudFileNameFilter
	once.Do(singleton)
	return bool(Advanced().SetCloudFileNameFilter(int64(update_handle), String.New(match_cloud_filename)))
}

/*
Sets the folder that will be stored as the content for an item.
For efficient upload and download, files should not be merged or compressed into single files (e.g. zip files).
[b]Note:[/b] This must be set before you submit the UGC update handle using [method Steam.submitItemUpdate].
*/
func SetItemContent(update_handle int, content_folder string) bool { //gd:Steam.setItemContent
	once.Do(singleton)
	return bool(Advanced().SetItemContent(int64(update_handle), String.New(content_folder)))
}

/*
Sets a new description for an item.
The description must be limited to the length defined by k_cchPublishedDocumentDescriptionMax (8000).
You can set what language this is for by using [method Steam.setItemUpdateLanguage], if no language is set then "english" is assumed.
[b]Note:[/b] This must be set before you submit the UGC update handle using [method Steam.submitItemUpdate].
*/
func SetItemDescription(update_handle int, description string) bool { //gd:Steam.setItemDescription
	once.Do(singleton)
	return bool(Advanced().SetItemDescription(int64(update_handle), String.New(description)))
}

/*
Sets arbitrary metadata for an item. This metadata can be returned from queries without having to download and install the actual content.
The metadata must be limited to the size defined by k_cchDeveloperMetadataMax (5000).
[b]Note:[/b] This must be set before you submit the UGC update handle using [method Steam.submitItemUpdate].
*/
func SetItemMetadata(update_handle int, ugc_metadata string) bool { //gd:Steam.setItemMetadata
	once.Do(singleton)
	return bool(Advanced().SetItemMetadata(int64(update_handle), String.New(ugc_metadata)))
}

/*
Sets the primary preview image for the item.
The format should be one that both the web and the application (if necessary) can render. Suggested formats include JPG, PNG and GIF.
[b]Note:[/b] This must be set before you submit the UGC update handle using [method Steam.submitItemUpdate].
*/
func SetItemPreview(update_handle int, preview_file string) bool { //gd:Steam.setItemPreview
	once.Do(singleton)
	return bool(Advanced().SetItemPreview(int64(update_handle), String.New(preview_file)))
}

/*
Sets arbitrary developer specified tags on an item.
Each tag must be limited to 255 characters. Tag names can only include printable characters, excluding ','.
[b]Note:[/b] This must be set before you submit the UGC update handle using [method Steam.submitItemUpdate].
*/
func SetItemTags(update_handle int, tag_array []any, allow_admin_tags bool) bool { //gd:Steam.setItemTags
	once.Do(singleton)
	return bool(Advanced().SetItemTags(int64(update_handle), gd.EngineArrayFromSlice(tag_array), allow_admin_tags))
}

/*
Sets arbitrary developer specified tags on an item.
Each tag must be limited to 255 characters. Tag names can only include printable characters, excluding ','.
[b]Note:[/b] This must be set before you submit the UGC update handle using [method Steam.submitItemUpdate].
*/
func SetItemTagsOptions(update_handle int, tag_array []any, allow_admin_tags bool) bool { //gd:Steam.setItemTags
	once.Do(singleton)
	return bool(Advanced().SetItemTags(int64(update_handle), gd.EngineArrayFromSlice(tag_array), allow_admin_tags))
}

/*
Sets a new title for an item.
The title must be limited to the size defined by k_cchPublishedDocumentTitleMax (128).
You can set what language this is for by using [method Steam.setItemUpdateLanguage], if no language is set then "english" is assumed.
[b]Note:[/b] This must be set before you submit the UGC update handle using [method Steam.submitItemUpdate].
*/
func SetItemTitle(update_handle int, title string) bool { //gd:Steam.setItemTitle
	once.Do(singleton)
	return bool(Advanced().SetItemTitle(int64(update_handle), String.New(title)))
}

/*
Sets the language of the title and description that will be set in this item update.
This must be in the format of the API language code.
If this is not set then "english" is assumed.
[b]Note:[/b] This must be set before you submit the UGC update handle using [method Steam.submitItemUpdate].
*/
func SetItemUpdateLanguage(update_handle int, language string) bool { //gd:Steam.setItemUpdateLanguage
	once.Do(singleton)
	return bool(Advanced().SetItemUpdateLanguage(int64(update_handle), String.New(language)))
}

/*
Sets the visibility of an item.
*/
func SetItemVisibility(update_handle int, visibility RemoteStoragePublishedFileVisibility) bool { //gd:Steam.setItemVisibility
	once.Do(singleton)
	return bool(Advanced().SetItemVisibility(int64(update_handle), visibility))
}

/*
Sets the language to return the title and description in for the items on a pending UGC Query.
This must be in the format of the API language code.
If this is not set then "english" is assumed.
[b]Note:[/b] This must be set before you submit the UGC query handle using [method Steam.submitItemUpdate].
*/
func SetLanguage(query_handle int, language string) bool { //gd:Steam.setLanguage
	once.Do(singleton)
	return bool(Advanced().SetLanguage(int64(query_handle), String.New(language)))
}

/*
Sets whether workshop items will be returned if they have one or more matching tag, or if all tags need to match on a pending UGC Query.
[b]Note:[/b] This can only be used with [method Steam.createQueryAllUGCRequest].
[b]Note:[/b] This must be set before you submit the UGC query handle using [method Steam.submitItemUpdate].
*/
func SetMatchAnyTag(query_handle int, match_any_tag bool) bool { //gd:Steam.setMatchAnyTag
	once.Do(singleton)
	return bool(Advanced().SetMatchAnyTag(int64(query_handle), match_any_tag))
}

/*
Sets whether the order of the results will be updated based on the rank of items over a number of days on a pending UGC Query.
[b]Note:[/b] This can only be used with [method Steam.createQueryAllUGCRequest].
[b]Note:[/b] This must be set before you submit the UGC query handle using [method Steam.submitItemUpdate].
*/
func SetRankedByTrendDays(query_handle int, days int) bool { //gd:Steam.setRankedByTrendDays
	once.Do(singleton)
	return bool(Advanced().SetRankedByTrendDays(int64(query_handle), int64(days)))
}

/*
An empty string for either parameter means that it will match any version on that end of the range. This will only be applied if the actual content has been changed.
*/
func SetRequiredGameVersions(query_handle int, game_branch_min string, game_branch_max string) bool { //gd:Steam.setRequiredGameVersions
	once.Do(singleton)
	return bool(Advanced().SetRequiredGameVersions(int64(query_handle), String.New(game_branch_min), String.New(game_branch_max)))
}

/*
Sets whether to return any additional images/videos attached to the items on a pending UGC Query.
[b]Note:[/b] This must be set before you submit the UGC query handle using [method Steam.submitItemUpdate].
*/
func SetReturnAdditionalPreviews(query_handle int, return_additional_previews bool) bool { //gd:Steam.setReturnAdditionalPreviews
	once.Do(singleton)
	return bool(Advanced().SetReturnAdditionalPreviews(int64(query_handle), return_additional_previews))
}

/*
Sets whether to return the IDs of the child items of the items on a pending UGC Query.
[b]Note:[/b] This must be set before you submit the UGC query handle using [method Steam.submitItemUpdate].
*/
func SetReturnChildren(query_handle int, return_children bool) bool { //gd:Steam.setReturnChildren
	once.Do(singleton)
	return bool(Advanced().SetReturnChildren(int64(query_handle), return_children))
}

/*
Sets whether to return any key-value tags for the items on a pending UGC Query.
[b]Note:[/b] This must be set before you submit the UGC query handle using [method Steam.submitItemUpdate].
*/
func SetReturnKeyValueTags(query_handle int, return_key_value_tags bool) bool { //gd:Steam.setReturnKeyValueTags
	once.Do(singleton)
	return bool(Advanced().SetReturnKeyValueTags(int64(query_handle), return_key_value_tags))
}

/*
Sets whether to return the full description for the items on a pending UGC Query.
If you don't set this then you only receive the summary which is the description truncated at 255 bytes.
[b]Note:[/b] This must be set before you submit the UGC query handle using [method Steam.submitItemUpdate].
*/
func SetReturnLongDescription(query_handle int, return_long_description bool) bool { //gd:Steam.setReturnLongDescription
	once.Do(singleton)
	return bool(Advanced().SetReturnLongDescription(int64(query_handle), return_long_description))
}

/*
Sets whether to return the developer specified metadata for the items on a pending UGC Query.
[b]Note:[/b] This must be set before you submit the UGC query handle using [method Steam.submitItemUpdate].
*/
func SetReturnMetadata(query_handle int, return_metadata bool) bool { //gd:Steam.setReturnMetadata
	once.Do(singleton)
	return bool(Advanced().SetReturnMetadata(int64(query_handle), return_metadata))
}

/*
Sets whether to only return IDs instead of all the details on a pending UGC Query.
This is useful for when you don't need all the information (e.g. you just want to get the IDs of the items a user has in their favorites list.)
[b]Note:[/b] This must be set before you submit the UGC query handle using [method Steam.submitItemUpdate].
*/
func SetReturnOnlyIDs(query_handle int, return_only_ids bool) bool { //gd:Steam.setReturnOnlyIDs
	once.Do(singleton)
	return bool(Advanced().SetReturnOnlyIDs(int64(query_handle), return_only_ids))
}

/*
Sets whether to return the the playtime stats on a pending UGC Query.
[b]Note:[/b] This must be set before you submit the UGC query handle using [method Steam.submitItemUpdate].
*/
func SetReturnPlaytimeStats(query_handle int, days int) bool { //gd:Steam.setReturnPlaytimeStats
	once.Do(singleton)
	return bool(Advanced().SetReturnPlaytimeStats(int64(query_handle), int64(days)))
}

/*
Sets whether to only return the the total number of matching items on a pending UGC Query.
The actual items will not be returned when [signal Steam.ugc_query_completed] is called.
[b]Note:[/b] This must be set before you submit the UGC query handle using [method Steam.submitItemUpdate].
*/
func SetReturnTotalOnly(query_handle int, return_total_only bool) bool { //gd:Steam.setReturnTotalOnly
	once.Do(singleton)
	return bool(Advanced().SetReturnTotalOnly(int64(query_handle), return_total_only))
}

/*
Sets a string to that items need to match in either the title or the description on a pending UGC Query.
[b]Note:[/b] This can only be used with [method Steam.createQueryAllUGCRequest].
[b]Note:[/b] This must be set before you submit the UGC query handle using [method Steam.submitItemUpdate].
*/
func SetSearchText(query_handle int, search_text string) bool { //gd:Steam.setSearchText
	once.Do(singleton)
	return bool(Advanced().SetSearchText(int64(query_handle), String.New(search_text)))
}

/*
Allows the user to rate a workshop item up or down.
Triggers a [signal Steam.set_user_item_vote] callback.
*/
func SetUserItemVote(published_file_id int, vote_up bool) { //gd:Steam.setUserItemVote
	once.Do(singleton)
	Advanced().SetUserItemVote(int64(published_file_id), vote_up)
}

/*
Starts the item update process.
This gets you a handle that you can use to modify the item before finally sending off the update to the server with [method Steam.submitItemUpdate].
*/
func StartItemUpdate(app_id int, file_id int) int { //gd:Steam.startItemUpdate
	once.Do(singleton)
	return int(int(Advanced().StartItemUpdate(int64(app_id), int64(file_id))))
}

/*
Start tracking playtime on a set of workshop items.
When your app shuts down, playtime tracking will automatically stop.
Triggers a [signal Steam.start_playtime_tracking] callback.
*/
func StartPlaytimeTracking(published_file_ids []any) { //gd:Steam.startPlaytimeTracking
	once.Do(singleton)
	Advanced().StartPlaytimeTracking(gd.EngineArrayFromSlice(published_file_ids))
}

/*
Stop tracking playtime on a set of workshop items.
When your app shuts down, playtime tracking will automatically stop.
Triggers a [signal Steam.stop_playtime_tracking] callback.
*/
func StopPlaytimeTracking(published_file_ids []any) { //gd:Steam.stopPlaytimeTracking
	once.Do(singleton)
	Advanced().StopPlaytimeTracking(gd.EngineArrayFromSlice(published_file_ids))
}

/*
Stop tracking playtime of all workshop items.
When your app shuts down, playtime tracking will automatically stop.
Triggers a [signal Steam.stop_playtime_tracking] callback.
*/
func StopPlaytimeTrackingForAllItems() { //gd:Steam.stopPlaytimeTrackingForAllItems
	once.Do(singleton)
	Advanced().StopPlaytimeTrackingForAllItems()
}

/*
Get the app dependencies associated with the given published_file_id. These are "soft" dependencies that are shown on the web. It is up to the application to determine whether an item can be used or not.
Triggers a [signal Steam.get_app_dependencies_result] callback.
*/
func GetAppDependencies(published_file_id int) { //gd:Steam.getAppDependencies
	once.Do(singleton)
	Advanced().GetAppDependencies(int64(published_file_id))
}

/*
Uploads the changes made to an item to the Steam Workshop.
You can track the progress of an item update with [method Steam.getItemUpdateProgress].
Triggers a [signal Steam.item_updated] callback.
*/
func SubmitItemUpdate(update_handle int, change_note string) { //gd:Steam.submitItemUpdate
	once.Do(singleton)
	Advanced().SubmitItemUpdate(int64(update_handle), String.New(change_note))
}

/*
Subscribe to a workshop item. It will be downloaded and installed as soon as possible.
Triggers a [signal Steam.subscribe_item] callback.
*/
func SubscribeItem(published_file_id int) { //gd:Steam.subscribeItem
	once.Do(singleton)
	Advanced().SubscribeItem(int64(published_file_id))
}

/*
Suspends and resumes all workshop downloads.
If you call this with suspend set to true then downloads will be suspended until you resume them by setting suspend to false or when the game ends.
*/
func SuspendDownloads(suspend bool) { //gd:Steam.suspendDownloads
	once.Do(singleton)
	Advanced().SuspendDownloads(suspend)
}

/*
Unsubscribe from a workshop item. This will result in the item being removed after the game quits.
Triggers a [signal Steam.unsubscribe_item] callback.
*/
func UnsubscribeItem(published_file_id int) { //gd:Steam.unsubscribeItem
	once.Do(singleton)
	Advanced().UnsubscribeItem(int64(published_file_id))
}

/*
Updates an additional video preview from YouTube for the item.
[b]Note:[/b] This must be set before you submit the UGC update handle using [method Steam.submitItemUpdate].
*/
func UpdateItemPreviewFile(update_handle int, index int, preview_file string) bool { //gd:Steam.updateItemPreviewFile
	once.Do(singleton)
	return bool(Advanced().UpdateItemPreviewFile(int64(update_handle), int64(index), String.New(preview_file)))
}

/*
Updates an additional video preview from YouTube for the item.
[b]Note:[/b] This must be set before you submit the UGC update handle using [method Steam.submitItemUpdate].
*/
func UpdateItemPreviewVideo(update_handle int, index int, video_id string) bool { //gd:Steam.updateItemPreviewVideo
	once.Do(singleton)
	return bool(Advanced().UpdateItemPreviewVideo(int64(update_handle), int64(index), String.New(video_id)))
}

/*
Show the app's latest Workshop EULA to the user in an overlay window, where they can accept it or not.
*/
func ShowWorkshopEULA() bool { //gd:Steam.showWorkshopEULA
	once.Do(singleton)
	return bool(Advanced().ShowWorkshopEULA())
}

/*
Asynchronously retrieves data about whether the user accepted the Workshop EULA for the current app.
*/
func GetWorkshopEULAStatus() { //gd:Steam.getWorkshopEULAStatus
	once.Do(singleton)
	Advanced().GetWorkshopEULAStatus()
}

/*
Set the time range this item was created.
*/
func SetTimeCreatedDateRange(update_handle int, start int, end int) bool { //gd:Steam.setTimeCreatedDateRange
	once.Do(singleton)
	return bool(Advanced().SetTimeCreatedDateRange(int64(update_handle), int64(start), int64(end)))
}

/*
Set the time range this item was updated.
*/
func SetTimeUpdatedDateRange(update_handle int, start int, end int) bool { //gd:Steam.setTimeUpdatedDateRange
	once.Do(singleton)
	return bool(Advanced().SetTimeUpdatedDateRange(int64(update_handle), int64(start), int64(end)))
}

/*
Set the rich presence data for an unsecured game server that the user is playing on. This allows friends to be able to view the game info and join your game.
When you are using Steam authentication system this call is never required, the auth system automatically sets the appropriate rich presence.
[b]Note:[/b] This is a legacy function.
*/
func AdvertiseGame(server_ip string, port int) { //gd:Steam.advertiseGame
	once.Do(singleton)
	Advanced().AdvertiseGame(String.New(server_ip), int64(port))
}

/*
Authenticate the ticket from the entity Steam ID to be sure it is valid and isn't reused.
The ticket is created on the entity with [method Steam.getAuthSessionTicket] and then needs to be provided over the network for the other end to validate.
This registers for [signal Steam.validate_auth_ticket_response] callbacks if the entity goes offline or cancels the ticket.
When the multiplayer session terminates you must call [method Steam.endAuthSession]
Trigger a [signal Steam.validate_auth_ticket_response] callback.
*/
func BeginAuthSession(ticket []byte, ticket_size int, steam_id int) BeginAuthSessionResult { //gd:Steam.beginAuthSession
	once.Do(singleton)
	return BeginAuthSessionResult(Advanced().BeginAuthSession(Packed.Bytes(Packed.New(ticket...)), int64(ticket_size), int64(steam_id)))
}

/*
Cancels an auth ticket received from [method Steam.getAuthSessionTicket]. This should be called when no longer playing with the specified entity.
*/
func CancelAuthTicket(auth_ticket int) { //gd:Steam.cancelAuthTicket
	once.Do(singleton)
	Advanced().CancelAuthTicket(int64(auth_ticket))
}

/*
Decodes the compressed voice data returned by [method Steam.getVoice].
The output data is raw single-channel 16-bit PCM audio. The decoder supports any sample rate from 11025 to 48000. See [method Steam.getVoiceOptimalSampleRate] for more information.
It is recommended that you start with a 20KiB buffer and then reallocate as necessary.
The returned dictionary contains the following keys:
[codeblock]
┠╴uncompressed (PackedByteArray)
[/codeblock]
*/
func DecompressVoice(voice []byte, sample_rate int) map[any]any { //gd:Steam.decompressVoice
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().DecompressVoice(Packed.Bytes(Packed.New(voice...)), int64(sample_rate), int64(20480))))
}

/*
Decodes the compressed voice data returned by [method Steam.getVoice].
The output data is raw single-channel 16-bit PCM audio. The decoder supports any sample rate from 11025 to 48000. See [method Steam.getVoiceOptimalSampleRate] for more information.
It is recommended that you start with a 20KiB buffer and then reallocate as necessary.
The returned dictionary contains the following keys:
[codeblock]
┠╴uncompressed (PackedByteArray)
[/codeblock]
*/
func DecompressVoiceOptions(voice []byte, sample_rate int, buffer_size_override int) map[any]any { //gd:Steam.decompressVoice
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().DecompressVoice(Packed.Bytes(Packed.New(voice...)), int64(sample_rate), int64(buffer_size_override))))
}

/*
Ends an auth session that was started with [method Steam.beginAuthSession]. This should be called when no longer playing with the specified entity.
*/
func EndAuthSession(steam_id int) { //gd:Steam.endAuthSession
	once.Do(singleton)
	Advanced().EndAuthSession(int64(steam_id))
}

/*
Retrieve an authentication ticket to be sent to the entity who wishes to authenticate you.
After calling this you can send the ticket to the entity where they can then call [method Steam.beginAuthSession] to verify this entities integrity.
When creating a ticket, the calling application should wait for the [signal Steam.get_auth_session_ticket_response] callback generated by the API call before attempting to use the ticket to ensure that the ticket has been communicated to the server. If this callback does not come in a timely fashion (10 - 20 seconds), then your client is not connected to Steam.
Triggers a [signal Steam.get_auth_session_ticket_response] callback.
[codeblock]
The returned dictionary contains the following keys:
┠╴id (int)
┠╴buffer (PackedByteArray)
┖╴size (int)
[/codeblock]
[b]Note:[/b] As of Steamworks SDK 1.57, you need to pass a network identity that was created with our Networking Tools class.  However, this is optional and defaults to NULL.
*/
func GetAuthSessionTicket(remote_steam_id int) map[any]any { //gd:Steam.getAuthSessionTicket
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetAuthSessionTicket(int64(remote_steam_id))))
}

/*
Retrieve an authentication ticket to be sent to the entity who wishes to authenticate you.
After calling this you can send the ticket to the entity where they can then call [method Steam.beginAuthSession] to verify this entities integrity.
When creating a ticket, the calling application should wait for the [signal Steam.get_auth_session_ticket_response] callback generated by the API call before attempting to use the ticket to ensure that the ticket has been communicated to the server. If this callback does not come in a timely fashion (10 - 20 seconds), then your client is not connected to Steam.
Triggers a [signal Steam.get_auth_session_ticket_response] callback.
[codeblock]
The returned dictionary contains the following keys:
┠╴id (int)
┠╴buffer (PackedByteArray)
┖╴size (int)
[/codeblock]
[b]Note:[/b] As of Steamworks SDK 1.57, you need to pass a network identity that was created with our Networking Tools class.  However, this is optional and defaults to NULL.
*/
func GetAuthSessionTicketOptions(remote_steam_id int) map[any]any { //gd:Steam.getAuthSessionTicket
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetAuthSessionTicket(int64(remote_steam_id))))
}

/*
Request a ticket which will be used for webapi "ISteamUserAuth\AuthenticateUserTicket"; [b]service_identity[/b] is an optional input parameter to identify the service the ticket will be sent to the ticket will be returned in callback [signal Steam.get_ticket_for_web_api].
Triggers a [signal Steam.get_ticket_for_web_api] callback.
[b]Note:[/b] The [b]service_identity[/b] is not a network identity used by or created with GodotSteam's Networking Tools class.
*/
func GetAuthTicketForWebApi(service_identity string) int { //gd:Steam.getAuthTicketForWebApi
	once.Do(singleton)
	return int(int(Advanced().GetAuthTicketForWebApi(String.New(service_identity))))
}

/*
Request a ticket which will be used for webapi "ISteamUserAuth\AuthenticateUserTicket"; [b]service_identity[/b] is an optional input parameter to identify the service the ticket will be sent to the ticket will be returned in callback [signal Steam.get_ticket_for_web_api].
Triggers a [signal Steam.get_ticket_for_web_api] callback.
[b]Note:[/b] The [b]service_identity[/b] is not a network identity used by or created with GodotSteam's Networking Tools class.
*/
func GetAuthTicketForWebApiOptions(service_identity string) int { //gd:Steam.getAuthTicketForWebApi
	once.Do(singleton)
	return int(int(Advanced().GetAuthTicketForWebApi(String.New(service_identity))))
}

/*
Checks to see if there is captured audio data available from [method Steam.getVoice], and gets the size of the data.
Most applications will only use compressed data and should ignore the other parameters, which exist primarily for backwards compatibility. See [method Steam.getVoice] for further explanation of "uncompressed" data.
The returned dictionary contains the following keys:
[codeblock]
┠╴result (int)
┖╴buffer (int)
[/codeblock]
*/
func GetAvailableVoice() map[any]any { //gd:Steam.getAvailableVoice
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetAvailableVoice()))
}

/*
Retrieves anti indulgence / duration control for current user / game combination.
Triggers a [signal Steam.duration_control] call result.
*/
func GetDurationControl() { //gd:Steam.getDurationControl
	once.Do(singleton)
	Advanced().GetDurationControl()
}

/*
Retrieve an encrypted ticket.
This should be called after requesting an encrypted app ticket with [method Steam.requestEncryptedAppTicket] and receiving the [signal Steam.encrypted_app_ticket_response] call result.
You should then pass this encrypted ticket to your secure servers to be decrypted using your secret key.
The returned dictionary contains the following keys:
[codeblock]
┠╴buffer (PackedByteArray)
┖╴size (int)
[/codeblock]
[b]Note:[/b] If you call this without calling [method Steam.requestEncryptedAppTicket], the call may succeed but you will likely get a stale ticket.
*/
func GetEncryptedAppTicket() map[any]any { //gd:Steam.getEncryptedAppTicket
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetEncryptedAppTicket()))
}

/*
Gets the level of the users Steam badge for your game.
The user can have two different badges for a series; the regular badge (max level 5) and the foil badge (max level 1).
*/
func GetGameBadgeLevel(series int, foil bool) int { //gd:Steam.getGameBadgeLevel
	once.Do(singleton)
	return int(int(Advanced().GetGameBadgeLevel(int64(series), foil)))
}

/*
Gets the Steam level of the user, as shown on their Steam community profile.
*/
func GetPlayerSteamLevel() int { //gd:Steam.getPlayerSteamLevel
	once.Do(singleton)
	return int(int(Advanced().GetPlayerSteamLevel()))
}

/*
Gets the Steam ID (ID64) of the account currently logged into the Steam client. This is commonly called the 'current user', or 'local user'.
A Steam ID is a unique identifier for a Steam accounts, Steam groups, Lobbies and Chat rooms, and used to differentiate users in all parts of the Steamworks API.
*/
func GetSteamID() int { //gd:Steam.getSteamID
	once.Do(singleton)
	return int(int(Advanced().GetSteamID()))
}

/*
Read captured audio data from the microphone buffer.
The compressed data can be transmitted by your application and decoded back into raw audio data using DecompressVoice on the other side. The compressed data provided is in an arbitrary format and is not meant to be played directly.
This should be called once per frame, and at worst no more than four times a second to keep the microphone input delay as low as possible. Calling this any less may result in gaps in the returned stream.
It is recommended that you pass in an 8 kilobytes or larger destination buffer for compressed audio. Static buffers are recommended for performance reasons. However, if you would like to allocate precisely the right amount of space for a buffer before each call you may use [method getAvailableVoice](/functions/users/#getavailablevoice) to find out how much data is available to be read.
The returned dictionary contains the following keys:
[codeblock]
┠╴result (int)
┖╴buffer (int)
[/codeblock]
[b]Note:[/b] "Uncompressed" audio is a deprecated feature and should not be used by most applications. It is raw single-channel 16-bit PCM wave data which may have been run through preprocessing filters and/or had silence removed, so the uncompressed audio could have a shorter duration than you expect. There may be no data at all during long periods of silence. Also, fetching uncompressed audio will cause [method Steam.getVoice] to discard any leftover compressed audio, so you must fetch both types at once. Finally, [method Steam.getAvailableVoice] is not precisely accurate when the uncompressed size is requested. So if you really need to use uncompressed audio, you should call [method Steam.getVoice] frequently with two very large (20KiB+) output buffers instead of trying to allocate perfectly-sized buffers. But most applications should ignore all of these details and simply leave the "uncompressed" parameters as NULL/0.
*/
func GetVoice(buffer_size_override int) map[any]any { //gd:Steam.getVoice
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetVoice(int64(buffer_size_override))))
}

/*
Read captured audio data from the microphone buffer.
The compressed data can be transmitted by your application and decoded back into raw audio data using DecompressVoice on the other side. The compressed data provided is in an arbitrary format and is not meant to be played directly.
This should be called once per frame, and at worst no more than four times a second to keep the microphone input delay as low as possible. Calling this any less may result in gaps in the returned stream.
It is recommended that you pass in an 8 kilobytes or larger destination buffer for compressed audio. Static buffers are recommended for performance reasons. However, if you would like to allocate precisely the right amount of space for a buffer before each call you may use [method getAvailableVoice](/functions/users/#getavailablevoice) to find out how much data is available to be read.
The returned dictionary contains the following keys:
[codeblock]
┠╴result (int)
┖╴buffer (int)
[/codeblock]
[b]Note:[/b] "Uncompressed" audio is a deprecated feature and should not be used by most applications. It is raw single-channel 16-bit PCM wave data which may have been run through preprocessing filters and/or had silence removed, so the uncompressed audio could have a shorter duration than you expect. There may be no data at all during long periods of silence. Also, fetching uncompressed audio will cause [method Steam.getVoice] to discard any leftover compressed audio, so you must fetch both types at once. Finally, [method Steam.getAvailableVoice] is not precisely accurate when the uncompressed size is requested. So if you really need to use uncompressed audio, you should call [method Steam.getVoice] frequently with two very large (20KiB+) output buffers instead of trying to allocate perfectly-sized buffers. But most applications should ignore all of these details and simply leave the "uncompressed" parameters as NULL/0.
*/
func GetVoiceOptions(buffer_size_override int) map[any]any { //gd:Steam.getVoice
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetVoice(int64(buffer_size_override))))
}

/*
Gets the native sample rate of the Steam voice decoder.
Using this sample rate for [method Steam.decompressVoice] will perform the least CPU processing. However, the final audio quality will depend on how well the audio device (and/or your application's audio output SDK) deals with lower sample rates. You may find that you get the best audio output quality when you ignore this function and use the native sample rate of your audio output device, which is usually 48000 or 44100.
*/
func GetVoiceOptimalSampleRate() int { //gd:Steam.getVoiceOptimalSampleRate
	once.Do(singleton)
	return int(int(Advanced().GetVoiceOptimalSampleRate()))
}

/*
This starts the state machine for authenticating the game client with the game server.
It is the client portion of a three-way handshake between the client, the game server, and the steam servers.
The returned dictionary contains the following keys:
[codeblock]
┠╴auth_blob (PackedByteArray)
┠╴server_id (int)
┠╴server_ip (int)
┖╴server_port (int)
[/codeblock]
[b]Note:[/b] When you're done with the connection you must call [method Steam.terminateGameConnection].
[b]Note:[/b] This is part of the old user authentication API and should not be mixed with the new API.
*/
func InitiateGameConnection(server_id int, server_ip string, server_port int, secure bool) map[any]any { //gd:Steam.initiateGameConnection
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().InitiateGameConnection(int64(server_id), String.New(server_ip), int64(server_port), secure)))
}

/*
Checks if the current user looks like they are behind a NAT device.
This is only valid if the user is connected to the Steam servers and may not catch all forms of NAT.
*/
func IsBehindNAT() bool { //gd:Steam.isBehindNAT
	once.Do(singleton)
	return bool(Advanced().IsBehindNAT())
}

/*
Checks whether the user's phone number is used to uniquely identify them.
*/
func IsPhoneIdentifying() bool { //gd:Steam.isPhoneIdentifying
	once.Do(singleton)
	return bool(Advanced().IsPhoneIdentifying())
}

/*
Checks whether the current user's phone number is awaiting (re)verification.
*/
func IsPhoneRequiringVerification() bool { //gd:Steam.isPhoneRequiringVerification
	once.Do(singleton)
	return bool(Advanced().IsPhoneRequiringVerification())
}

/*
Checks whether the current user has verified their phone number.
*/
func IsPhoneVerified() bool { //gd:Steam.isPhoneVerified
	once.Do(singleton)
	return bool(Advanced().IsPhoneVerified())
}

/*
Checks whether the current user has Steam Guard two factor authentication enabled on their account.
*/
func IsTwoFactorEnabled() bool { //gd:Steam.isTwoFactorEnabled
	once.Do(singleton)
	return bool(Advanced().IsTwoFactorEnabled())
}

/*
Checks if the current user's Steam client is connected to the Steam servers.
If it's not then no real-time services provided by the Steamworks API will be enabled. The Steam client will automatically be trying to recreate the connection as often as possible. When the connection is restored a [signal Steam.steam_server_connected] callback will be posted.
You usually don't need to check for this yourself. All of the API calls that rely on this will check internally. Forcefully disabling stuff when the player loses access is usually not a very good experience for the player and you could be preventing them from accessing APIs that do not need a live connection to Steam.
*/
func LoggedOn() bool { //gd:Steam.loggedOn
	once.Do(singleton)
	return bool(Advanced().LoggedOn())
}

/*
Requests an application ticket encrypted with the secret "encrypted app ticket key".
The encryption key can be obtained from the Encrypted App Ticket Key page on the App Admin for your app.
There can only be one [signal Steam.encrypted_app_ticket_response] pending, and this call is subject to a 60 second rate limit.
After receiving the response you should call [method Steam.getEncryptedAppTicket]) to get the ticket data, and then you need to send it to a secure server to be decrypted with the SteamEncryptedAppTicket functions.
Triggers a [signal Steam.encrypted_app_ticket_response] call result.
*/
func RequestEncryptedAppTicket(secret string) { //gd:Steam.requestEncryptedAppTicket
	once.Do(singleton)
	Advanced().RequestEncryptedAppTicket(String.New(secret))
}

/*
Requests a URL which authenticates an in-game browser for store check-out, and then redirects to the specified URL.
As long as the in-game browser accepts and handles session cookies, Steam microtransaction checkout pages will automatically recognize the user instead of presenting a login page.
Triggers a [signal Steam.store_auth_url_response] call result.
[b]Note:[/b] The URL has a very short lifetime to prevent history-snooping attacks, so you should only call this API when you are about to launch the browser, or else immediately navigate to the result URL using a hidden browser window.
[b]Note:[/b] The resulting authorization cookie has an expiration time of one day, so it would be a good idea to request and visit a new auth URL every 12 hours.
*/
func RequestStoreAuthURL(redirect string) { //gd:Steam.requestStoreAuthURL
	once.Do(singleton)
	Advanced().RequestStoreAuthURL(String.New(redirect))
}

/*
Starts voice recording.
Once started, use [method Steam.getAvailableVoice] and [method Steam.getVoice] to get the data, and then call [method Steam.stopVoiceRecording] when the user has released their push-to-talk hotkey or the game session has completed.
*/
func StartVoiceRecording() { //gd:Steam.startVoiceRecording
	once.Do(singleton)
	Advanced().StartVoiceRecording()
}

/*
Allows the game to specify the offline/online gameplay state for Steam China duration control.
*/
func SetDurationControlOnlineState(new_state int) bool { //gd:Steam.setDurationControlOnlineState
	once.Do(singleton)
	return bool(Advanced().SetDurationControlOnlineState(int64(new_state)))
}

/*
Stops voice recording.
Because people often release push-to-talk keys early, the system will keep recording for a little bit after this function is called. As such, [method Steam.getVoice] should continue to be called until it returns 2, only then will voice recording be stopped.
*/
func StopVoiceRecording() { //gd:Steam.stopVoiceRecording
	once.Do(singleton)
	Advanced().StopVoiceRecording()
}

/*
Notify the game server that we are disconnecting.
This needs to occur when the game client leaves the specified game server, needs to match with the [method Steam.initiateGameConnection] call.
[b]Note:[/b] This is part of the old user authentication API and should not be mixed with the new API.
*/
func TerminateGameConnection(server_ip string, server_port int) { //gd:Steam.terminateGameConnection
	once.Do(singleton)
	Advanced().TerminateGameConnection(String.New(server_ip), int64(server_port))
}

/*
Checks if the user owns a specific piece of Downloadable Content (DLC).
This can only be called after sending the users auth ticket to [method Steam.beginAuthSession].
*/
func UserHasLicenseForApp(steam_id int, app_id int) int { //gd:Steam.userHasLicenseForApp
	once.Do(singleton)
	return int(int(Advanced().UserHasLicenseForApp(int64(steam_id), int64(app_id))))
}

/*
If no this_leaderboard is passed, then the function will use the last internally-stored handle.
Attaches a piece of user generated content the current user's entry on a leaderboard.
This content could be a replay of the user achieving the score or a ghost to race against. To create and download user generated content see the documentation for the Steam Workshop.
Once attached, the content will be available even if the underlying Cloud file is changed or deleted by the user.
You must call [method Steam.findLeaderboard] or [method Steam.findOrCreateLeaderboard] to get a leaderboard handle prior to calling this function.
Triggers a [signal Steam.leaderboard_ugc_set] callback.
*/
func AttachLeaderboardUGC(ugc_handle int, this_leaderboard int) { //gd:Steam.attachLeaderboardUGC
	once.Do(singleton)
	Advanced().AttachLeaderboardUGC(int64(ugc_handle), int64(this_leaderboard))
}

/*
If no this_leaderboard is passed, then the function will use the last internally-stored handle.
Attaches a piece of user generated content the current user's entry on a leaderboard.
This content could be a replay of the user achieving the score or a ghost to race against. To create and download user generated content see the documentation for the Steam Workshop.
Once attached, the content will be available even if the underlying Cloud file is changed or deleted by the user.
You must call [method Steam.findLeaderboard] or [method Steam.findOrCreateLeaderboard] to get a leaderboard handle prior to calling this function.
Triggers a [signal Steam.leaderboard_ugc_set] callback.
*/
func AttachLeaderboardUGCOptions(ugc_handle int, this_leaderboard int) { //gd:Steam.attachLeaderboardUGC
	once.Do(singleton)
	Advanced().AttachLeaderboardUGC(int64(ugc_handle), int64(this_leaderboard))
}

/*
Resets the unlock status of an achievement.
This is primarily only ever used for testing.
This call only modifies Steam's in-memory state so it is quite cheap. To send the unlock status to the server and to trigger the Steam overlay notification you must call [method Steam.storeStats].
*/
func ClearAchievement(achievement_name string) bool { //gd:Steam.clearAchievement
	once.Do(singleton)
	return bool(Advanced().ClearAchievement(String.New(achievement_name)))
}

/*
If no leaderboard_handle is passed, then the function will use the last internally-stored handle.
Fetches a series of leaderboard entries for a specified leaderboard.
You can ask for more entries than exist, then this will return as many as do exist.
If you want to download entries for an arbitrary set of users, such as all of the users on a server then you can use [method Steam.downloadLeaderboardEntriesForUsers] which takes an array of Steam IDs.
You must call [method Steam.findLeaderboard] or [method Steam.findOrCreateLeaderboard] to get a leaderboard handle prior to calling this function.
Triggers a [signal Steam.leaderboard_scores_downloaded] call result.
*/
func DownloadLeaderboardEntries(start int, end int, atype LeaderboardDataRequest, this_leaderboard int) { //gd:Steam.downloadLeaderboardEntries
	once.Do(singleton)
	Advanced().DownloadLeaderboardEntries(int64(start), int64(end), atype, int64(this_leaderboard))
}

/*
If no leaderboard_handle is passed, then the function will use the last internally-stored handle.
Fetches a series of leaderboard entries for a specified leaderboard.
You can ask for more entries than exist, then this will return as many as do exist.
If you want to download entries for an arbitrary set of users, such as all of the users on a server then you can use [method Steam.downloadLeaderboardEntriesForUsers] which takes an array of Steam IDs.
You must call [method Steam.findLeaderboard] or [method Steam.findOrCreateLeaderboard] to get a leaderboard handle prior to calling this function.
Triggers a [signal Steam.leaderboard_scores_downloaded] call result.
*/
func DownloadLeaderboardEntriesOptions(start int, end int, atype LeaderboardDataRequest, this_leaderboard int) { //gd:Steam.downloadLeaderboardEntries
	once.Do(singleton)
	Advanced().DownloadLeaderboardEntries(int64(start), int64(end), atype, int64(this_leaderboard))
}

/*
If no leaderboard_handle is passed, then the function will use the last internally-stored handle.
Fetches leaderboard entries for an arbitrary set of users on a specified leaderboard.
A maximum of 100 users can be downloaded at a time, with only one outstanding call at a time. If a user doesn't have an entry on the specified leaderboard, they won't be included in the result.
If you want to download entries based on their ranking or friends of the current user then you should use [method Steam.downloadLeaderboardEntries].
You must call [method Steam.findLeaderboard] or [method Steam.findOrCreateLeaderboard] to get a leaderboard handle prior to calling this function.
Triggers a [signal Steam.leaderboard_scores_downloaded] callback.
*/
func DownloadLeaderboardEntriesForUsers(users_id []any, this_leaderboard int) { //gd:Steam.downloadLeaderboardEntriesForUsers
	once.Do(singleton)
	Advanced().DownloadLeaderboardEntriesForUsers(gd.EngineArrayFromSlice(users_id), int64(this_leaderboard))
}

/*
If no leaderboard_handle is passed, then the function will use the last internally-stored handle.
Fetches leaderboard entries for an arbitrary set of users on a specified leaderboard.
A maximum of 100 users can be downloaded at a time, with only one outstanding call at a time. If a user doesn't have an entry on the specified leaderboard, they won't be included in the result.
If you want to download entries based on their ranking or friends of the current user then you should use [method Steam.downloadLeaderboardEntries].
You must call [method Steam.findLeaderboard] or [method Steam.findOrCreateLeaderboard] to get a leaderboard handle prior to calling this function.
Triggers a [signal Steam.leaderboard_scores_downloaded] callback.
*/
func DownloadLeaderboardEntriesForUsersOptions(users_id []any, this_leaderboard int) { //gd:Steam.downloadLeaderboardEntriesForUsers
	once.Do(singleton)
	Advanced().DownloadLeaderboardEntriesForUsers(gd.EngineArrayFromSlice(users_id), int64(this_leaderboard))
}

/*
Gets a leaderboard by name.
You must call either this or [method Steam.findOrCreateLeaderboard] to obtain the leaderboard handle which is valid for the game session for each leaderboard you wish to access prior to calling any other Leaderboard functions.
Triggers a [signal Steam.leaderboard_find_result] call result.
*/
func FindLeaderboard(leaderboard_name string) { //gd:Steam.findLeaderboard
	once.Do(singleton)
	Advanced().FindLeaderboard(String.New(leaderboard_name))
}

/*
Gets a leaderboard by name, it will create it if it's not yet created.
You must call either this or [method Steam.findLeaderboard] to obtain the leaderboard handle which is valid for the game session for each leaderboard you wish to access prior to calling any other Leaderboard functions.
Leaderboards created with this function will not automatically show up in the Steam Community. You must manually set the Community Name field in the App Admin panel of the Steamworks website. As such it's generally recommended to prefer creating the leaderboards in the App Admin panel on the Steamworks website and using [method Steam.findLeaderboard] unless you're expected to have a large amount of dynamically created leaderboards.
You should never pass 0 for sort_method or 0 for display_type as this is undefined behavior.
Triggers a [signal Steam.leaderboard_find_result] callback.
*/
func FindOrCreateLeaderboard(leaderboard_name string, sort_method LeaderboardSortMethod, display_type LeaderboardDisplayType) { //gd:Steam.findOrCreateLeaderboard
	once.Do(singleton)
	Advanced().FindOrCreateLeaderboard(String.New(leaderboard_name), sort_method, display_type)
}

/*
Gets the unlock status of the Achievement.
The equivalent function for other users is [method getUserAchievement].
The returned dictionary contains the following keys:
[codeblock]
┠╴ret (bool)
┖╴achieved (bool)
[/codeblock]
*/
func GetAchievement(achievement_name string) map[any]any { //gd:Steam.getAchievement
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetAchievement(String.New(achievement_name))))
}

/*
Returns the percentage of users who have unlocked the specified achievement.
You must have called [method Steam.requestGlobalAchievementPercentages] and it needs to return successfully via its callback prior to calling this.
The returned dictionary contains the following keys:
[codeblock]
┠╴ret (bool)
┖╴percent (float)
[/codeblock]
*/
func GetAchievementAchievedPercent(achievement_name string) map[any]any { //gd:Steam.getAchievementAchievedPercent
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetAchievementAchievedPercent(String.New(achievement_name))))
}

/*
Gets the achievement status, and the time it was unlocked if unlocked.
If the return value is true, but the unlock time is zero, that means it was unlocked before Steam began tracking achievement unlock times (December 2009). The time is provided in Unix epoch format, seconds since January 1, 1970 UTC.
The equivalent function for other users is [method Steam.getUserAchievementAndUnlockTime].
[codeblock lang=text]
The returning dictionary contains the following keys:
┠╴retrieve (bool)
┠╴achieved (bool)
┖╴unlocked (int)
[/codeblock]
*/
func GetAchievementAndUnlockTime(achievement_name string) map[any]any { //gd:Steam.getAchievementAndUnlockTime
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetAchievementAndUnlockTime(String.New(achievement_name))))
}

/*
Get general attributes for an achievement. Currently provides: Name, Description, and Hidden status.
This receives the value from a dictionary/map keyvalue store, so you must provide one of the following keys:
[codeblock]
• name: to retrieve the localized achievement name in UTF8
• desc: to retrieve the localized achievement description in UTF8
• hidden: for retrieving if an achievement is hidden. Returns "0" when not hidden, "1" when hidden
[/codeblock]
This localization is provided based on the games language if it's set, otherwise it checks if a localization is available for the users Steam UI Language. If that fails too, then it falls back to English.
*/
func GetAchievementDisplayAttribute(achievement_name string, key string) string { //gd:Steam.getAchievementDisplayAttribute
	once.Do(singleton)
	return string(Advanced().GetAchievementDisplayAttribute(String.New(achievement_name), String.New(key)).String())
}

/*
Gets the icon for an achievement.
Triggers a [signal Steam.user_achievement_icon_fetched] callback.
*/
func GetAchievementIcon(achievement_name string) int { //gd:Steam.getAchievementIcon
	once.Do(singleton)
	return int(int(Advanced().GetAchievementIcon(String.New(achievement_name))))
}

/*
Gets the 'API name' for an achievement index between 0 and [method Steam.getNumAchievements].
This function must be used in conjunction with [method Steam.getNumAchievements] to loop over the list of achievements.
In general games should not need these functions as they should have the list of achievements compiled into them.
*/
func GetAchievementName(achievement int) string { //gd:Steam.getAchievementName
	once.Do(singleton)
	return string(Advanced().GetAchievementName(int64(achievement)).String())
}

/*
For achievements that have related progress stats, use this to query what the bounds of that progress are. You may want this info to selectively call [method Steam.indicateAchievementProgress] when appropriate milestones of progress have been made, to show a progress notification to the user.
The returned dictionary contains the following keys:
[codeblock]
┠╴name (string)
┠╴min (int)
┖╴max (int)
[/codeblock]
*/
func GetAchievementProgressLimitsInt(achievement_name string) map[any]any { //gd:Steam.getAchievementProgressLimitsInt
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetAchievementProgressLimitsInt(String.New(achievement_name))))
}

/*
For achievements that have related progress stats, use this to query what the bounds of that progress are. You may want this info to selectively call [method Steam.indicateAchievementProgress] when appropriate milestones of progress have been made, to show a progress notification to the user.
The returned dictionary contains the following keys:
[codeblock]
┠╴name (string)
┠╴min (float)
┖╴max (float)
[/codeblock]
*/
func GetAchievementProgressLimitsFloat(achievement_name string) map[any]any { //gd:Steam.getAchievementProgressLimitsFloat
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetAchievementProgressLimitsFloat(String.New(achievement_name))))
}

/*
Gets the lifetime totals for an aggregated stat.
You must have called [method Steam.requestGlobalStats] and it needs to return successfully via its callback prior to calling this.
*/
func GetGlobalStatInt(stat_name string) int { //gd:Steam.getGlobalStatInt
	once.Do(singleton)
	return int(int(Advanced().GetGlobalStatInt(String.New(stat_name))))
}

/*
Gets the lifetime totals for an aggregated stat.
You must have called [method Steam.requestGlobalStats] and it needs to return successfully via its callback prior to calling this.
*/
func GetGlobalStatFloat(stat_name string) Float.X { //gd:Steam.getGlobalStatFloat
	once.Do(singleton)
	return Float.X(Float.X(Advanced().GetGlobalStatFloat(String.New(stat_name))))
}

/*
Gets the daily history for an aggregated stat.
Array.0 will be today, Array.1 will be yesterday, and Array.2 will be two days ago, etc.
You must have called [method Steam.requestGlobalStats] and it needs to return successfully via its callback prior to calling this.
*/
func GetGlobalStatIntHistory(stat_name string) []int64 { //gd:Steam.getGlobalStatIntHistory
	once.Do(singleton)
	return []int64(slices.Collect(Advanced().GetGlobalStatIntHistory(String.New(stat_name)).Values()))
}

/*
Gets the daily history for an aggregated stat.
Array.0 will be today, Array.1 will be yesterday, and Array.2 will be two days ago, etc.
You must have called [method Steam.requestGlobalStats] and it needs to return successfully via its callback prior to calling this.
*/
func GetGlobalStatFloatHistory(stat_name string) []float64 { //gd:Steam.getGlobalStatFloatHistory
	once.Do(singleton)
	return []float64(slices.Collect(Advanced().GetGlobalStatFloatHistory(String.New(stat_name)).Values()))
}

/*
If no leaderboard_handle is passed, then the function will use the last internally-stored handle.
Get the display type of a leaderboard handle.
The returned dictionary contains the following keys:
[codeblock]
┠╴result (int)
┖╴verbal (string)
[/codeblock]
*/
func GetLeaderboardDisplayType(this_leaderboard int) map[any]any { //gd:Steam.getLeaderboardDisplayType
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetLeaderboardDisplayType(int64(this_leaderboard))))
}

/*
If no leaderboard_handle is passed, then the function will use the last internally-stored handle.
Get the display type of a leaderboard handle.
The returned dictionary contains the following keys:
[codeblock]
┠╴result (int)
┖╴verbal (string)
[/codeblock]
*/
func GetLeaderboardDisplayTypeOptions(this_leaderboard int) map[any]any { //gd:Steam.getLeaderboardDisplayType
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetLeaderboardDisplayType(int64(this_leaderboard))))
}

/*
If no leaderboard_handle is passed, then the function will use the last internally-stored handle.
Returns the total number of entries in a leaderboard.
This is cached on a per leaderboard basis upon the first call to [method Steam.findLeaderboard] or [method Steam.findOrCreateLeaderboard] and is refreshed on each successful call to [method Steam.downloadLeaderboardEntries], [method Steam.downloadLeaderboardEntriesForUsers], and [method Steam.uploadLeaderboardScore].
*/
func GetLeaderboardEntryCount(this_leaderboard int) int { //gd:Steam.getLeaderboardEntryCount
	once.Do(singleton)
	return int(int(Advanced().GetLeaderboardEntryCount(int64(this_leaderboard))))
}

/*
If no leaderboard_handle is passed, then the function will use the last internally-stored handle.
Returns the total number of entries in a leaderboard.
This is cached on a per leaderboard basis upon the first call to [method Steam.findLeaderboard] or [method Steam.findOrCreateLeaderboard] and is refreshed on each successful call to [method Steam.downloadLeaderboardEntries], [method Steam.downloadLeaderboardEntriesForUsers], and [method Steam.uploadLeaderboardScore].
*/
func GetLeaderboardEntryCountOptions(this_leaderboard int) int { //gd:Steam.getLeaderboardEntryCount
	once.Do(singleton)
	return int(int(Advanced().GetLeaderboardEntryCount(int64(this_leaderboard))))
}

/*
If no leaderboard_handle is passed, then the function will use the last internally-stored handle.
Returns the name of a leaderboard handle.
*/
func GetLeaderboardName(this_leaderboard int) string { //gd:Steam.getLeaderboardName
	once.Do(singleton)
	return string(Advanced().GetLeaderboardName(int64(this_leaderboard)).String())
}

/*
If no leaderboard_handle is passed, then the function will use the last internally-stored handle.
Returns the name of a leaderboard handle.
*/
func GetLeaderboardNameOptions(this_leaderboard int) string { //gd:Steam.getLeaderboardName
	once.Do(singleton)
	return string(Advanced().GetLeaderboardName(int64(this_leaderboard)).String())
}

/*
If no leaderboard_handle is passed, then the function will use the last internally-stored handle.
Get the sort order of a leaderboard handle. If no thisLeaderboard handle is passed, then the function will use the last stored internal handle.
The returned dictionary contains the following keys:
[codeblock]
┠╴result (int)
┖╴verbal (string)
[/codeblock]
*/
func GetLeaderboardSortMethod(this_leaderboard int) map[any]any { //gd:Steam.getLeaderboardSortMethod
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetLeaderboardSortMethod(int64(this_leaderboard))))
}

/*
If no leaderboard_handle is passed, then the function will use the last internally-stored handle.
Get the sort order of a leaderboard handle. If no thisLeaderboard handle is passed, then the function will use the last stored internal handle.
The returned dictionary contains the following keys:
[codeblock]
┠╴result (int)
┖╴verbal (string)
[/codeblock]
*/
func GetLeaderboardSortMethodOptions(this_leaderboard int) map[any]any { //gd:Steam.getLeaderboardSortMethod
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetLeaderboardSortMethod(int64(this_leaderboard))))
}

/*
Gets the info on the most achieved achievement for the game.
You must have called [method Steam.requestGlobalAchievementPercentages] and it needs to return successfully via its callback prior to calling this.
The returned dictionary contains the following keys:
[codeblock]
┠╴rank (int)
┠╴name (string)
┠╴percent (float)
┖╴achieved (bool)
[/codeblock]
*/
func GetMostAchievedAchievementInfo() map[any]any { //gd:Steam.getMostAchievedAchievementInfo
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetMostAchievedAchievementInfo()))
}

/*
Gets the info on the next most achieved achievement for the game.
You must have called [method Steam.requestGlobalAchievementPercentages] and it needs to return successfully via its callback prior to calling this.
The returned dictionary contains the following keys:
[codeblock]
┠╴rank (int)
┠╴name (string)
┠╴percent (float)
┖╴achieved (bool)
[/codeblock]
*/
func GetNextMostAchievedAchievementInfo(iterator int) map[any]any { //gd:Steam.getNextMostAchievedAchievementInfo
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetNextMostAchievedAchievementInfo(int64(iterator))))
}

/*
Get the number of achievements defined in the App Admin panel of the Steamworks website.
This is used for iterating through all of the achievements with [method Steam.getAchievementName].
In general games should not need these functions because they should have a list of existing achievements compiled into them.
*/
func GetNumAchievements() int { //gd:Steam.getNumAchievements
	once.Do(singleton)
	return int(int(Advanced().GetNumAchievements()))
}

/*
Asynchronously retrieves the total number of players currently playing the current game. Both online and in offline mode.
Triggers a [signal Steam.number_of_current_players] callback.
*/
func GetNumberOfCurrentPlayers() { //gd:Steam.getNumberOfCurrentPlayers
	once.Do(singleton)
	Advanced().GetNumberOfCurrentPlayers()
}

/*
Gets the current value of the a stat for the current user.
To receive stats for other users use [method Steam.getUserStatFloat] or [method Steam.getUserStatInt].
*/
func GetStatFloat(stat_name string) Float.X { //gd:Steam.getStatFloat
	once.Do(singleton)
	return Float.X(Float.X(Advanced().GetStatFloat(String.New(stat_name))))
}

/*
Gets the current value of the a stat for the current user.
To receive stats for other users use [method Steam.getUserStatFloat] or [method Steam.getUserStatInt].
*/
func GetStatInt(stat_name string) int { //gd:Steam.getStatInt
	once.Do(singleton)
	return int(int(Advanced().GetStatInt(String.New(stat_name))))
}

/*
Gets the unlock status of the Achievement.
The equivalent function for the local user is [method Steam.getAchievement].
The returned dictionary contains the following keys:
[codeblock]
┠╴steam_id (int)
┠╴retrieved (bool)
┠╴name (string)
┖╴achieved (bool)
[/codeblock]
*/
func GetUserAchievement(steam_id int, name string) map[any]any { //gd:Steam.getUserAchievement
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetUserAchievement(int64(steam_id), String.New(name))))
}

/*
Gets the achievement status, and the time it was unlocked if unlocked.
If the return value is true, but the unlock time is zero, that means it was unlocked before Steam began tracking achievement unlock times (December 2009). The time is provided in Unix epoch format, seconds since January 1, 1970 UTC.
The equivalent function for the local user is [method Steam.getAchievementAndUnlockTime].
The returned dictionary contains the following keys:
[codeblock]
┠╴retrieved (bool)
┠╴name (string)
┠╴achieved (bool)
┖╴unlocked (int)
[/codeblock]
*/
func GetUserAchievementAndUnlockTime(steam_id int, name string) map[any]any { //gd:Steam.getUserAchievementAndUnlockTime
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetUserAchievementAndUnlockTime(int64(steam_id), String.New(name))))
}

/*
Gets the current value of the a stat for the specified user.
You must have called [method Steam.requestUserStats] and it needs to return successfully via its callback prior to calling this.
The equivalent function for the local user is [method Steam.getStatFloat] or [method Steam.getStatInt].
*/
func GetUserStatFloat(steam_id int, name string) Float.X { //gd:Steam.getUserStatFloat
	once.Do(singleton)
	return Float.X(Float.X(Advanced().GetUserStatFloat(int64(steam_id), String.New(name))))
}

/*
Gets the current value of the a stat for the specified user.
You must have called [method Steam.requestUserStats] and it needs to return successfully via its callback prior to calling this.
The equivalent function for the local user is [method Steam.getStatInt] or [method Steam.getStatFloat].
*/
func GetUserStatInt(steam_id int, name string) int { //gd:Steam.getUserStatInt
	once.Do(singleton)
	return int(int(Advanced().GetUserStatInt(int64(steam_id), String.New(name))))
}

/*
Shows the user a pop-up notification with the current progress of an achievement.
Calling this function will not set the progress or unlock the achievement, the game must do that manually by calling [method Steam.setStatFloat] or [method Steam.setStatInt].
Triggers a [signal Steam.user_stats_stored] callback.
Triggers a [signal Steam.user_achievement_stored] callback.
*/
func IndicateAchievementProgress(name string, current_progress int, max_progress int) bool { //gd:Steam.indicateAchievementProgress
	once.Do(singleton)
	return bool(Advanced().IndicateAchievementProgress(String.New(name), int64(current_progress), int64(max_progress)))
}

/*
Asynchronously fetches global stats data, which is available for stats marked as "aggregated" in the App Admin panel of the Steamworks website.
Triggers a [signal Steam.global_achievement_percentages_ready] callback.
*/
func RequestGlobalAchievementPercentages() { //gd:Steam.requestGlobalAchievementPercentages
	once.Do(singleton)
	Advanced().RequestGlobalAchievementPercentages()
}

/*
Asynchronously fetches global stats data, which is available for stats marked as "aggregated" in the App Admin panel of the Steamworks website.
The limit is 60.
Triggers a [signal Steam.global_stats_received] callback.
*/
func RequestGlobalStats(history_days int) { //gd:Steam.requestGlobalStats
	once.Do(singleton)
	Advanced().RequestGlobalStats(int64(history_days))
}

/*
Asynchronously downloads stats and achievements for the specified user from the server.
These stats are not automatically updated; you'll need to call this function again to refresh any data that may have change.
To keep from using too much memory, an least recently used cache (LRU) is maintained and other user's stats will occasionally be unloaded. When this happens a [signal Steam.user_stats_unloaded] callback is sent. After receiving this callback the user's stats will be unavailable until this function is called again.
Triggers a [signal Steam.user_stats_received] callback.
*/
func RequestUserStats(steam_id int) { //gd:Steam.requestUserStats
	once.Do(singleton)
	Advanced().RequestUserStats(int64(steam_id))
}

/*
Resets the current users stats and, optionally achievements.
This automatically calls [method Steam.storeStats] to persist the changes to the server. This should typically only be used for testing purposes during development.
*/
func ResetAllStats(achievements_too bool) bool { //gd:Steam.resetAllStats
	once.Do(singleton)
	return bool(Advanced().ResetAllStats(achievements_too))
}

/*
Unlocks an achievement.
You can unlock an achievement multiple times so you don't need to worry about only setting achievements that aren't already set. This call only modifies Steam's in-memory state so it is quite cheap. To send the unlock status to the server and to trigger the Steam overlay notification you must call [method Steam.storeStats].
*/
func SetAchievement(name string) bool { //gd:Steam.setAchievement
	once.Do(singleton)
	return bool(Advanced().SetAchievement(String.New(name)))
}

/*
Sets / updates the float value of a given stat for the current user.
This call only modifies Steam's in-memory state and is very cheap. Doing so allows Steam to persist the changes even in the event of a game crash or unexpected shutdown. To submit the stats to the server you must call [method Steam.storeStats].
If this is returning false and everything appears correct, then check to ensure that your changes in the App Admin panel of the Steamworks website are published.
*/
func SetStatFloat(name string, value Float.X) bool { //gd:Steam.setStatFloat
	once.Do(singleton)
	return bool(Advanced().SetStatFloat(String.New(name), float64(value)))
}

/*
Sets / updates the integer value of a given stat for the current user.
This call only modifies Steam's in-memory state and is very cheap. Doing so allows Steam to persist the changes even in the event of a game crash or unexpected shutdown. To submit the stats to the server you must call [method Steam.storeStats].
If this is returning false and everything appears correct, then check to ensure that your changes in the App Admin panel of the Steamworks website are published.
*/
func SetStatInt(name string, value int) bool { //gd:Steam.setStatInt
	once.Do(singleton)
	return bool(Advanced().SetStatInt(String.New(name), int64(value)))
}

/*
Send the changed stats and achievements data to the server for permanent storage.
If this fails then nothing is sent to the server. It's advisable to keep trying until the call is successful.
This call can be rate limited. Call frequency should be on the order of minutes, rather than seconds. You should only be calling this during major state changes such as the end of a round, the map changing, or the user leaving a server. This call is required to display the achievement unlock notification dialog though, so if you have called [method Steam.setAchievement] then it's advisable to call this soon after that.
If you have stats or achievements that you have saved locally but haven't uploaded with this function when your application process ends then this function will automatically be called.
You can find additional debug information written to the [code]%steam_install%\logs\stats_log.txt[/code] file.
Triggers a [signal Steam.user_stats_stored] callback.
Triggers a [signal Steam.user_achievement_stored] callback.
*/
func StoreStats() bool { //gd:Steam.storeStats
	once.Do(singleton)
	return bool(Advanced().StoreStats())
}

/*
Updates an AVGRATE stat with new values.
This call only modifies Steam's in-memory state and is very cheap. Doing so allows Steam to persist the changes even in the event of a game crash or unexpected shutdown. To submit the stats to the server you must call [method Steam.storeStats].
If this is returning false and everything appears correct, then check to ensure that your changes in the App Admin panel of the Steamworks website are published.
*/
func UpdateAvgRateStat(name string, this_session Float.X, session_length Float.X) bool { //gd:Steam.updateAvgRateStat
	once.Do(singleton)
	return bool(Advanced().UpdateAvgRateStat(String.New(name), float64(this_session), float64(session_length)))
}

/*
If this_leaderboard is not passed, then the function will use the last internally-stored handle.
Uploads a user score to a specified leaderboard.
Details are optional game-defined information which outlines how the user got that score. For example if it's a racing style time based leaderboard you could store the timestamps when the player hits each checkpoint. If you have collectibles along the way you could use bit fields as booleans to store the items the player picked up in the playthrough.
Uploading scores to Steam is rate limited to 10 uploads per 10 minutes and you may only have one outstanding call to this function at a time.
Triggers a [signal Steam.leaderboard_score_uploaded] callback.
*/
func UploadLeaderboardScore(score int, details []int32, this_leaderboard int) { //gd:Steam.uploadLeaderboardScore
	once.Do(singleton)
	Advanced().UploadLeaderboardScore(int64(score), true, Packed.New(details...), int64(this_leaderboard))
}

/*
If this_leaderboard is not passed, then the function will use the last internally-stored handle.
Uploads a user score to a specified leaderboard.
Details are optional game-defined information which outlines how the user got that score. For example if it's a racing style time based leaderboard you could store the timestamps when the player hits each checkpoint. If you have collectibles along the way you could use bit fields as booleans to store the items the player picked up in the playthrough.
Uploading scores to Steam is rate limited to 10 uploads per 10 minutes and you may only have one outstanding call to this function at a time.
Triggers a [signal Steam.leaderboard_score_uploaded] callback.
*/
func UploadLeaderboardScoreOptions(score int, keep_best bool, details []int32, this_leaderboard int) { //gd:Steam.uploadLeaderboardScore
	once.Do(singleton)
	Advanced().UploadLeaderboardScore(int64(score), keep_best, Packed.New(details...), int64(this_leaderboard))
}

/*
Dismisses the floating keyboard.
*/
func DismissFloatingGamepadTextInput() bool { //gd:Steam.dismissFloatingGamepadTextInput
	once.Do(singleton)
	return bool(Advanced().DismissFloatingGamepadTextInput())
}

/*
Dismisses the full-screen text input dialog.
*/
func DismissGamepadTextInput() bool { //gd:Steam.dismissGamepadTextInput
	once.Do(singleton)
	return bool(Advanced().DismissGamepadTextInput())
}

/*
Filters the provided input message and returns the filtered result. Legally required filtering is always applied. Additional filtering may occur, based on the context and user settings.
*/
func FilterText(context TextFilteringContext, steam_id int, message string) string { //gd:Steam.filterText
	once.Do(singleton)
	return string(Advanced().FilterText(context, int64(steam_id), String.New(message)).String())
}

/*
Used to get the failure reason of a call result.
The primary usage for this function is debugging. The failure reasons are typically out of your control and tend to not be very important. Just keep retrying your API Call until it works.
*/
func GetAPICallFailureReason() string { //gd:Steam.getAPICallFailureReason
	once.Do(singleton)
	return string(Advanced().GetAPICallFailureReason().String())
}

/*
Gets the App ID of the current process.
*/
func GetAppID() int { //gd:Steam.getAppID
	once.Do(singleton)
	return int(int(Advanced().GetAppID()))
}

/*
Gets the current amount of battery power on the computer.
*/
func GetCurrentBatteryPower() int { //gd:Steam.getCurrentBatteryPower
	once.Do(singleton)
	return int(int(Advanced().GetCurrentBatteryPower()))
}

/*
Gets the image bytes from an image handle.
Prior to calling this you must get the size of the image by calling [method Steam.getImageSize] so that you can create your buffer with an appropriate size. You can then allocate your buffer with the width and height as: width * height * 4. The image is provided in RGBA format. This call can be somewhat expensive as it converts from the compressed type (JPG, PNG, TGA) and provides no internal caching of returned buffer, thus it is highly recommended to only call this once per image handle and cache the result. This function is only used for Steam Avatars and Achievement images and those are not expected to change mid game.
The returned dictionary contains the following keys:
[codeblock]
┠╴buffer (PackedByteArray)
┖╴success (bool)
[/codeblock]
*/
func GetImageRGBA(image int) map[any]any { //gd:Steam.getImageRGBA
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetImageRGBA(int64(image))))
}

/*
Gets the size of a Steam image handle.
This must be called before calling [method Steam.getImageRGBA] to create an appropriately sized buffer that will be filled with the raw image data.
The returned dictionary contains the following keys:
[codeblock]
┠╴width (int)
┖╴height (int)
[/codeblock]
*/
func GetImageSize(image int) map[any]any { //gd:Steam.getImageSize
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().GetImageSize(int64(image))))
}

/*
Returns the number of IPC calls made since the last time this function was called.
Used for perf debugging so you can determine how many IPC (Inter-Process Communication) calls your game makes per frame.
Every IPC call is at minimum a thread context switch if not a process one so you want to rate control how often you do them.
*/
func GetIPCCallCount() int { //gd:Steam.getIPCCallCount
	once.Do(singleton)
	return int(int(Advanced().GetIPCCallCount()))
}

/*
Returns the 2 digit ISO 3166-1-alpha-2 format country code which client is running in. e.g "US" or "UK".
This is looked up via an IP-to-location database.
*/
func GetIPCountry() string { //gd:Steam.getIPCountry
	once.Do(singleton)
	return string(Advanced().GetIPCountry().String())
}

/*
Returns the number of seconds since the application was active.
*/
func GetSecondsSinceAppActive() int { //gd:Steam.getSecondsSinceAppActive
	once.Do(singleton)
	return int(int(Advanced().GetSecondsSinceAppActive()))
}

/*
Returns the number of seconds since the user last moved the mouse.
*/
func GetSecondsSinceComputerActive() int { //gd:Steam.getSecondsSinceComputerActive
	once.Do(singleton)
	return int(int(Advanced().GetSecondsSinceComputerActive()))
}

/*
Returns the Steam server time in Unix epoch format. (Number of seconds since Jan 1, 1970 UTC).
*/
func GetServerRealTime() int { //gd:Steam.getServerRealTime
	once.Do(singleton)
	return int(int(Advanced().GetServerRealTime()))
}

/*
Returns the language the steam client is running in.
You probably want [method Steam.getCurrentGameLanguage] instead, this should only be used in very special cases.
For a full list of languages see Supported Languages in Valve's documentation.
*/
func GetSteamUILanguage() string { //gd:Steam.getSteamUILanguage
	once.Do(singleton)
	return string(Advanced().GetSteamUILanguage().String())
}

/*
Initializes text filtering, loading dictionaries for the language the game is running in.
Users can customize the text filter behavior in their Steam Account preferences.
*/
func InitFilterText() bool { //gd:Steam.initFilterText
	once.Do(singleton)
	return bool(Advanced().InitFilterText())
}

/*
Checks if an API Call is completed. Provides the backend of the CallResult wrapper.
It's generally not recommended that you use this yourself.
The returned dictionary contains the following keys:
[codeblock]
┠╴completed (bool)
┖╴failed (bool)
[/codeblock]
*/
func IsAPICallCompleted() map[any]any { //gd:Steam.isAPICallCompleted
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().IsAPICallCompleted()))
}

/*
Checks if the Steam Overlay is running and the user can access it.
The overlay process could take a few seconds to start and hook the game process, so this function will initially return false while the overlay is loading.
*/
func IsOverlayEnabled() bool { //gd:Steam.isOverlayEnabled
	once.Do(singleton)
	return bool(Advanced().IsOverlayEnabled())
}

/*
Returns whether the current launcher is a Steam China launcher. You can cause the client to behave as the Steam China launcher by adding [code]-dev -steamchina[/code] to the command line when running Steam.
*/
func IsSteamChinaLauncher() bool { //gd:Steam.isSteamChinaLauncher
	once.Do(singleton)
	return bool(Advanced().IsSteamChinaLauncher())
}

/*
Checks if Steam and the Steam Overlay are running in Big Picture mode.
Games must be launched through the Steam client to enable the Big Picture overlay. During development, a game can be added as a non-steam game to the developers library to test this feature.
*/
func IsSteamInBigPictureMode() bool { //gd:Steam.isSteamInBigPictureMode
	once.Do(singleton)
	return bool(Advanced().IsSteamInBigPictureMode())
}

/*
Checks if Steam is running in VR mode.
*/
func IsSteamRunningInVR() bool { //gd:Steam.isSteamRunningInVR
	once.Do(singleton)
	return bool(Advanced().IsSteamRunningInVR())
}

/*
Checks if Steam is running on a Steam Deck device.
*/
func IsSteamRunningOnSteamDeck() bool { //gd:Steam.isSteamRunningOnSteamDeck
	once.Do(singleton)
	return bool(Advanced().IsSteamRunningOnSteamDeck())
}

/*
Checks if the HMD view will be streamed via Steam In-Home Streaming.
*/
func IsVRHeadsetStreamingEnabled() bool { //gd:Steam.isVRHeadsetStreamingEnabled
	once.Do(singleton)
	return bool(Advanced().IsVRHeadsetStreamingEnabled())
}

/*
Checks if the Overlay needs a present. Only required if using event driven render updates.
Typically this call is unneeded if your game has a constantly running frame loop that calls the D3D Present API, or OGL SwapBuffers API every frame as is the case in most games. However, if you have a game that only refreshes the screen on an event driven basis then that can break the overlay, as it uses your Present/SwapBuffers calls to drive it's internal frame loop and it may also need to Present() to the screen any time a notification happens or when the overlay is brought up over the game by a user. You can use this API to ask the overlay if it currently need a present in that case, and then you can check for this periodically (roughly 33hz is desirable) and make sure you refresh the screen with Present or SwapBuffers to allow the overlay to do it's work.
*/
func OverlayNeedsPresent() bool { //gd:Steam.overlayNeedsPresent
	once.Do(singleton)
	return bool(Advanced().OverlayNeedsPresent())
}

/*
In game launchers that don't have controller support you can call this to have Steam Input translate the controller input into mouse/kb to navigate the launcher.
*/
func SetGameLauncherMode(mode bool) { //gd:Steam.setGameLauncherMode
	once.Do(singleton)
	Advanced().SetGameLauncherMode(mode)
}

/*
Sets the inset of the overlay notification from the corner specified by [method Steam.setOverlayNotificationPosition]. Integer should be number of pixels.
*/
func SetOverlayNotificationInset(horizontal int, vertical int) { //gd:Steam.setOverlayNotificationInset
	once.Do(singleton)
	Advanced().SetOverlayNotificationInset(int64(horizontal), int64(vertical))
}

/*
Set the position where overlay shows notifications. Accepts the following integer inputs:
[codeblock]
• 0 / Top Left
• 1 / Top Right
• 2 / Bottom Left
• 3 / Bottom Right
[/codeblock]
*/
func SetOverlayNotificationPosition(pos int) { //gd:Steam.setOverlayNotificationPosition
	once.Do(singleton)
	Advanced().SetOverlayNotificationPosition(int64(pos))
}

/*
Set whether the HMD content will be streamed via Steam In-Home Streaming.
*/
func SetVRHeadsetStreamingEnabled(enabled bool) { //gd:Steam.setVRHeadsetStreamingEnabled
	once.Do(singleton)
	Advanced().SetVRHeadsetStreamingEnabled(enabled)
}

/*
Opens a floating keyboard over the game content and sends OS keyboard keys directly to the game.
The text field position is specified in pixels relative the origin of the game window and is used to position the floating keyboard in a way that doesn't cover the text field.
*/
func ShowFloatingGamepadTextInput(input_mode FloatingGamepadTextInputMode, text_field_x_position int, text_field_y_position int, text_field_width int, text_field_height int) bool { //gd:Steam.showFloatingGamepadTextInput
	once.Do(singleton)
	return bool(Advanced().ShowFloatingGamepadTextInput(input_mode, int64(text_field_x_position), int64(text_field_y_position), int64(text_field_width), int64(text_field_height)))
}

/*
Activates the Big Picture text input dialog which only supports gamepad input.
*/
func ShowGamepadTextInput(input_mode GamepadTextInputMode, line_input_mode GamepadTextInputLineMode, description string, max_text int, preset_text string) bool { //gd:Steam.showGamepadTextInput
	once.Do(singleton)
	return bool(Advanced().ShowGamepadTextInput(input_mode, line_input_mode, String.New(description), int64(max_text), String.New(preset_text)))
}

/*
Ask SteamUI to create and render its OpenVR dashboard.
*/
func StartVRDashboard() { //gd:Steam.startVRDashboard
	once.Do(singleton)
	Advanced().StartVRDashboard()
}
func CheckFileSignature(file_name string) { //gd:Steam.checkFileSignature
	once.Do(singleton)
	Advanced().CheckFileSignature(String.New(file_name))
}

/*
Get the OPF details for 360 video playback.
To retrieve the 360 OPF (open projection format) data to playback a 360 video, start by making a call to this, then the callback will indicate whether the request was successful. If it was successful, the actual OPF JSON data can be retrieved with a call to [method Steam.getOPFStringForApp].
[b]Note:[/b] Triggers a [signal Steam.get_opf_settings_result] callback.
*/
func GetOPFSettings(app_id int) { //gd:Steam.getOPFSettings
	once.Do(singleton)
	Advanced().GetOPFSettings(int64(app_id))
}

/*
Gets the OPF string for the specified video app ID.
Once the callback for [signal Steam.get_opf_settings_result] has been raised and the EResult indicates success, then calling this will return back the actual OPF data in a JSON format. The size of the OPF string varies, but at this time 48,000 bytes should be sufficient to contain the full string.
[b]Note:[/b] The data returned in a successful call to [method Steam.getOPFStringForApp] can only be retrieved once. If you need to retrieve it multiple times, a call to [method Steam.getOPFSettings] will need to be made each time.
*/
func GetOPFStringForApp(app_id int) string { //gd:Steam.getOPFStringForApp
	once.Do(singleton)
	return string(Advanced().GetOPFStringForApp(int64(app_id)).String())
}

/*
Asynchronously gets the URL suitable for streaming the video associated with the specified video app ID.
[b]Note:[/b] Triggers a [signal Steam.get_video_result] callback.
*/
func GetVideoURL(app_id int) { //gd:Steam.getVideoURL
	once.Do(singleton)
	Advanced().GetVideoURL(int64(app_id))
}

/*
Checks if the user is currently live broadcasting and gets the number of users.
The returned dictionary contains the following keys:
[codeblock]
┠╴broadcasting (bool)
┖╴viewers (int)
[/codeblock]
*/
func IsBroadcasting() map[any]any { //gd:Steam.isBroadcasting
	once.Do(singleton)
	return map[any]any(gd.DictionaryAs[map[any]any](Advanced().IsBroadcasting()))
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
func Advanced() class { once.Do(singleton); return self }

type class [1]gdclass.Steam

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }

func BrowserHandle() int {
	once.Do(singleton)
	return int(int(class(self).GetBrowserHandle()))
}

func SetBrowserHandle(value int) {
	once.Do(singleton)
	class(self).SetBrowserHandle(int64(value))
}

func CurrentClanId() int {
	once.Do(singleton)
	return int(int(class(self).GetCurrentClanId()))
}

func SetCurrentClanId(value int) {
	once.Do(singleton)
	class(self).SetCurrentClanId(int64(value))
}

func InventoryHandle() int {
	once.Do(singleton)
	return int(int(class(self).GetInventoryHandle()))
}

func SetInventoryHandle(value int) {
	once.Do(singleton)
	class(self).SetInventoryHandle(int64(value))
}

func InventoryUpdateHandle() int {
	once.Do(singleton)
	return int(int(class(self).GetInventoryUpdateHandle()))
}

func SetInventoryUpdateHandle(value int) {
	once.Do(singleton)
	class(self).SetInventoryUpdateHandle(int64(value))
}

func CurrentSteamId() int {
	once.Do(singleton)
	return int(int(class(self).GetCurrentSteamId()))
}

func SetCurrentSteamId(value int) {
	once.Do(singleton)
	class(self).SetCurrentSteamId(int64(value))
}

func LeaderboardDetailsMax() int {
	once.Do(singleton)
	return int(int(class(self).GetLeaderboardDetailsMax()))
}

func SetLeaderboardDetailsMax(value int) {
	once.Do(singleton)
	class(self).SetLeaderboardDetailsMax(int64(value))
}

func LeaderboardEntriesArray() []any {
	once.Do(singleton)
	return []any(gd.ArrayAs[[]any](gd.InternalArray(class(self).GetLeaderboardEntries())))
}

func SetLeaderboardEntriesArray(value []any) {
	once.Do(singleton)
	class(self).SetLeaderboardEntries(gd.EngineArrayFromSlice(value))
}

func LeaderboardHandle() int {
	once.Do(singleton)
	return int(int(class(self).GetLeaderboardHandle()))
}

func SetLeaderboardHandle(value int) {
	once.Do(singleton)
	class(self).SetLeaderboardHandle(int64(value))
}

func CurrentAppId() int {
	once.Do(singleton)
	return int(int(class(self).GetCurrentAppId()))
}

func SetCurrentAppId(value int) {
	once.Do(singleton)
	class(self).SetCurrentAppId(int64(value))
}

/*
Returns the current version of GodotSteam you are using.
*/
//go:nosplit
func (self class) GetGodotsteamVersion() String.Readable { //gd:Steam.get_godotsteam_version
	var frame = callframe.New()
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_get_godotsteam_version, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Convert a SteamID64 into a SteamID.
*/
//go:nosplit
func (self class) GetSteamID32(steam_id int64) int64 { //gd:Steam.getSteamID32
	var frame = callframe.New()
	callframe.Arg(frame, steam_id)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getSteamID32, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Is this an anonymous account?
*/
//go:nosplit
func (self class) IsAnonAccount(steam_id int64) bool { //gd:Steam.isAnonAccount
	var frame = callframe.New()
	callframe.Arg(frame, steam_id)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_isAnonAccount, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Is this an anonymous user account? Used to create an account or reset a password, but do not try to do this.
*/
//go:nosplit
func (self class) IsAnonUserAccount(steam_id int64) bool { //gd:Steam.isAnonUserAccount
	var frame = callframe.New()
	callframe.Arg(frame, steam_id)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_isAnonUserAccount, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Is this a chat account ID?
*/
//go:nosplit
func (self class) IsChatAccount(steam_id int64) bool { //gd:Steam.isChatAccount
	var frame = callframe.New()
	callframe.Arg(frame, steam_id)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_isChatAccount, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Is this a clan account ID?
*/
//go:nosplit
func (self class) IsClanAccount(steam_id int64) bool { //gd:Steam.isClanAccount
	var frame = callframe.New()
	callframe.Arg(frame, steam_id)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_isClanAccount, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Is this a faked up Steam ID for a PSN friend account?
*/
//go:nosplit
func (self class) IsConsoleUserAccount(steam_id int64) bool { //gd:Steam.isConsoleUserAccount
	var frame = callframe.New()
	callframe.Arg(frame, steam_id)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_isConsoleUserAccount, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Is this an individual user account ID?
*/
//go:nosplit
func (self class) IsIndividualAccount(steam_id int64) bool { //gd:Steam.isIndividualAccount
	var frame = callframe.New()
	callframe.Arg(frame, steam_id)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_isIndividualAccount, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Is this a lobby account ID?
*/
//go:nosplit
func (self class) IsLobby(steam_id int64) bool { //gd:Steam.isLobby
	var frame = callframe.New()
	callframe.Arg(frame, steam_id)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_isLobby, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Check if the Steam client is running.
Naturally, returns true if the Steam client is running.
[b]Note:[/b] While this is not listed in the Steamworks docs, it is in the SDK.
*/
//go:nosplit
func (self class) IsSteamRunning() bool { //gd:Steam.isSteamRunning
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_isSteamRunning, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Enables your application to receive callbacks from Steamworks. Must be placed in your _process function.
*/
//go:nosplit
func (self class) RunCallbacks() { //gd:Steam.run_callbacks
	var frame = callframe.New()
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_run_callbacks, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Checks if your executable was launched through Steam and relaunches it through Steam if it wasn't.
If this returns true then it starts the Steam client if required and launches your game again through it, and you should quit your process as soon as possible. If it returns false, then your game was launched by the Steam client and no action needs to be taken.
*/
//go:nosplit
func (self class) RestartAppIfNecessary(app_id int64) bool { //gd:Steam.restartAppIfNecessary
	var frame = callframe.New()
	callframe.Arg(frame, app_id)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_restartAppIfNecessary, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Starts up the Steam API.
You will receive one of four results:
[codeblock]
• 1 / "Steamworks active"
• 2 / "Steamworks failed to initialize"
• 20 / "Steam not running"
• 79 / "Invalid app ID or app not installed"
[/codeblock]
You can also pass an app ID for GodotSteam to use for your game, which will default to 480 (SpaceWars) if nothing is passed.
Finally, you can pass true for embed_callbacks which will internally do the run_callbacks for your Steam callbacks so you don't have to code that separately in your game.
*/
//go:nosplit
func (self class) SteamInit(retrieve_stats bool, app_id int64, embed_callbacks bool) Dictionary.Any { //gd:Steam.steamInit
	var frame = callframe.New()
	callframe.Arg(frame, retrieve_stats)
	callframe.Arg(frame, app_id)
	callframe.Arg(frame, embed_callbacks)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_steamInit, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Initialize the Steamworks SDK. On success [enum SteamAPIInitResult] is returned.  Otherwise, if error_message is non-NULL, it will receive a non-localized message that explains the reason for the failure.
[codeblock]
• 0 / "Steamworks active"
• 1 / "Failed (generic)"
• 2 / "Cannot connect to Steam, client probably isn't running"
• 3 / "Steam client appears to be out of date"
[/codeblock]
You can also pass an app ID for GodotSteam to use for your game, which will default to 480 (SpaceWars) if nothing is passed.
Finally, you can pass true for embed_callbacks which will internally do the run_callbacks for your Steam callbacks so you don't have to code that separately in your game.
*/
//go:nosplit
func (self class) SteamInitEx(retrieve_stats bool, app_id int64, embed_callbacks bool) Dictionary.Any { //gd:Steam.steamInitEx
	var frame = callframe.New()
	callframe.Arg(frame, retrieve_stats)
	callframe.Arg(frame, app_id)
	callframe.Arg(frame, embed_callbacks)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_steamInitEx, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Shuts down the Steamworks API, releases pointers and frees memory.
*/
//go:nosplit
func (self class) SteamShutdown() { //gd:Steam.steamShutdown
	var frame = callframe.New()
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_steamShutdown, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) GetBrowserHandle() int64 { //gd:Steam.get_browser_handle
	var frame = callframe.New()
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_get_browser_handle, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

//go:nosplit
func (self class) GetCurrentAppId() int64 { //gd:Steam.get_current_app_id
	var frame = callframe.New()
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_get_current_app_id, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

//go:nosplit
func (self class) GetCurrentClanId() int64 { //gd:Steam.get_current_clan_id
	var frame = callframe.New()
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_get_current_clan_id, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

//go:nosplit
func (self class) GetCurrentSteamId() int64 { //gd:Steam.get_current_steam_id
	var frame = callframe.New()
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_get_current_steam_id, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

//go:nosplit
func (self class) GetInventoryHandle() int64 { //gd:Steam.get_inventory_handle
	var frame = callframe.New()
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_get_inventory_handle, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

//go:nosplit
func (self class) GetInventoryUpdateHandle() int64 { //gd:Steam.get_inventory_update_handle
	var frame = callframe.New()
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_get_inventory_update_handle, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

//go:nosplit
func (self class) GetLeaderboardHandle() int64 { //gd:Steam.get_leaderboard_handle
	var frame = callframe.New()
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_get_leaderboard_handle, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

//go:nosplit
func (self class) GetLeaderboardDetailsMax() int64 { //gd:Steam.get_leaderboard_details_max
	var frame = callframe.New()
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_get_leaderboard_details_max, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

//go:nosplit
func (self class) GetLeaderboardEntries() Array.Any { //gd:Steam.get_leaderboard_entries
	var frame = callframe.New()
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_get_leaderboard_entries, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Array.Through(gd.ArrayProxy[variant.Any]{}, pointers.Pack(pointers.New[gd.Array](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Returns the current server list request handle.
*/
//go:nosplit
func (self class) GetServerListRequest() int64 { //gd:Steam.get_server_list_request
	var frame = callframe.New()
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_get_server_list_request, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

//go:nosplit
func (self class) SetBrowserHandle(new_browser_handle int64) { //gd:Steam.set_browser_handle
	var frame = callframe.New()
	callframe.Arg(frame, new_browser_handle)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_set_browser_handle, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) SetCurrentAppId(new_current_app_id int64) { //gd:Steam.set_current_app_id
	var frame = callframe.New()
	callframe.Arg(frame, new_current_app_id)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_set_current_app_id, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) SetCurrentClanId(new_current_clan_id int64) { //gd:Steam.set_current_clan_id
	var frame = callframe.New()
	callframe.Arg(frame, new_current_clan_id)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_set_current_clan_id, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) SetCurrentSteamId(new_current_steam_id int64) { //gd:Steam.set_current_steam_id
	var frame = callframe.New()
	callframe.Arg(frame, new_current_steam_id)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_set_current_steam_id, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) SetInventoryHandle(new_inventory_handle int64) { //gd:Steam.set_inventory_handle
	var frame = callframe.New()
	callframe.Arg(frame, new_inventory_handle)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_set_inventory_handle, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) SetInventoryUpdateHandle(new_inventory_update_handle int64) { //gd:Steam.set_inventory_update_handle
	var frame = callframe.New()
	callframe.Arg(frame, new_inventory_update_handle)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_set_inventory_update_handle, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) SetLeaderboardDetailsMax(new_leaderboard_details_max int64) { //gd:Steam.set_leaderboard_details_max
	var frame = callframe.New()
	callframe.Arg(frame, new_leaderboard_details_max)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_set_leaderboard_details_max, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) SetLeaderboardEntries(new_leaderboard_entries Array.Any) { //gd:Steam.set_leaderboard_entries
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalArray(new_leaderboard_entries)))
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_set_leaderboard_entries, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) SetLeaderboardHandle(new_leaderboard_handle int64) { //gd:Steam.set_leaderboard_handle
	var frame = callframe.New()
	callframe.Arg(frame, new_leaderboard_handle)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_set_leaderboard_handle, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Set the current server list request handle.
*/
//go:nosplit
func (self class) SetServerListRequest(new_server_list_request int64) { //gd:Steam.set_server_list_request
	var frame = callframe.New()
	callframe.Arg(frame, new_server_list_request)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_set_server_list_request, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Gets the build ID of this app, may change at any time based on backend updates to the game.
The current build ID of this app. Defaults to 0 if you're not running a build downloaded from Steam.
*/
//go:nosplit
func (self class) GetAppBuildId() int64 { //gd:Steam.getAppBuildId
	var frame = callframe.New()
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getAppBuildId, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Gets the install folder for a specific app ID. This works even if the application is not installed, based on where the game would be installed with the default Steam library location.
[codeblock]
The returned dictionary contains the following keys:
┠╴directory (string)
┠╴install_size (int)
┖╴size (int)
[/codeblock]
*/
//go:nosplit
func (self class) GetAppInstallDir(app_id int64) Dictionary.Any { //gd:Steam.getAppInstallDir
	var frame = callframe.New()
	callframe.Arg(frame, app_id)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getAppInstallDir, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Gets the Steam ID of the original owner of the current app. If it's different from the current user then it is borrowed.
*/
//go:nosplit
func (self class) GetAppOwner() int64 { //gd:Steam.getAppOwner
	var frame = callframe.New()
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getAppOwner, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Gets a comma separated list of the languages the current app supports.
*/
//go:nosplit
func (self class) GetAvailableGameLanguages() String.Readable { //gd:Steam.getAvailableGameLanguages
	var frame = callframe.New()
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getAvailableGameLanguages, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Return beta branch details, name, description, current build ID and state flags (BetaBranchFlags).
The returned dictionary contains the following keys:
[codeblock]
┠╴index (int)
┠╴flags (uint32)
┠╴build_id (uint32)
┠╴name (string)
┖╴description (string)
[/codeblock]
*/
//go:nosplit
func (self class) GetBetaInfo() Dictionary.Any { //gd:Steam.getBetaInfo
	var frame = callframe.New()
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getBetaInfo, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Checks if the user is running from a beta branch, and gets the name of the branch if they are.
*/
//go:nosplit
func (self class) GetCurrentBetaName() String.Readable { //gd:Steam.getCurrentBetaName
	var frame = callframe.New()
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getCurrentBetaName, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Gets the current language that the user has set.
*/
//go:nosplit
func (self class) GetCurrentGameLanguage() String.Readable { //gd:Steam.getCurrentGameLanguage
	var frame = callframe.New()
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getCurrentGameLanguage, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Get the number of DLC the user owns for a parent application / game.
*/
//go:nosplit
func (self class) GetDLCCount() int64 { //gd:Steam.getDLCCount
	var frame = callframe.New()
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getDLCCount, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Get all DLC data in an array.
The returned array contains a list of:
[codeblock]
┖╴dlc (dictionary)
    ┠╴app_id (int)
    ┠╴available (bool)
    ┖╴name (string)
[/codeblock]
*/
//go:nosplit
func (self class) GetDLCData() Array.Any { //gd:Steam.getDLCData
	var frame = callframe.New()
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getDLCData, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Array.Through(gd.ArrayProxy[variant.Any]{}, pointers.Pack(pointers.New[gd.Array](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Returns metadata for a DLC by index.
The returned dictionary contains the following keys:
[codeblock]
┠╴app_id (int)
┠╴available (bool)
┖╴name (string)
[/codeblock]
*/
//go:nosplit
func (self class) GetDLCDataByIndex(this_dlc_index int64) Dictionary.Any { //gd:Steam.getDLCDataByIndex
	var frame = callframe.New()
	callframe.Arg(frame, this_dlc_index)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getDLCDataByIndex, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Gets the download progress for optional DLC.
The returned dictionary contains the following keys:
[codeblock]
┠╴ret (bool)
┠╴downloaded (int)
┖╴total (int)
[/codeblock]
*/
//go:nosplit
func (self class) GetDLCDownloadProgress(dlc_id int64) Dictionary.Any { //gd:Steam.getDLCDownloadProgress
	var frame = callframe.New()
	callframe.Arg(frame, dlc_id)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getDLCDownloadProgress, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Gets the time of purchase of the specified app in Unix epoch format (time since Jan 1st, 1970).
*/
//go:nosplit
func (self class) GetEarliestPurchaseUnixTime(app_id int64) int64 { //gd:Steam.getEarliestPurchaseUnixTime
	var frame = callframe.New()
	callframe.Arg(frame, app_id)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getEarliestPurchaseUnixTime, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Asynchronously retrieves metadata details about a specific file in the depot manifest.
[b]Note:[/b] Triggers a [signal Steam.file_details_result].
*/
//go:nosplit
func (self class) GetFileDetails(filename String.Readable) { //gd:Steam.getFileDetails
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(filename)))
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getFileDetails, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Gets a list of all installed depots for a given App ID; returned in mount order.
Contains the installed depots, returned in mount order.
*/
//go:nosplit
func (self class) GetInstalledDepots(app_id int64) Array.Any { //gd:Steam.getInstalledDepots
	var frame = callframe.New()
	callframe.Arg(frame, app_id)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getInstalledDepots, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Array.Through(gd.ArrayProxy[variant.Any]{}, pointers.Pack(pointers.New[gd.Array](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Gets the command line if the game was launched via Steam URL, e.g. steam://run/{appid}//{command line}/. This method is preferable to launching with a command line via the operating system, which can be a security risk. In order for rich presence joins to go through this and not be placed on the OS command line, you must enable "Use launch command line" from the Installation > General page on your app.
*/
//go:nosplit
func (self class) GetLaunchCommandLine() String.Readable { //gd:Steam.getLaunchCommandLine
	var frame = callframe.New()
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getLaunchCommandLine, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Gets the associated launch parameter if the game is run via steam://run/{appid}/?param1=value1;param2=value2;param3=value3 etc.
*/
//go:nosplit
func (self class) GetLaunchQueryParam(key String.Readable) String.Readable { //gd:Steam.getLaunchQueryParam
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(key)))
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getLaunchQueryParam, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Returns total number of known app beta branches (including default "public" branch).
*/
//go:nosplit
func (self class) GetNumBetas() Dictionary.Any { //gd:Steam.getNumBetas
	var frame = callframe.New()
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getNumBetas, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Allows you to install an optional DLC.
*/
//go:nosplit
func (self class) InstallDLC(dlc_id int64) { //gd:Steam.installDLC
	var frame = callframe.New()
	callframe.Arg(frame, dlc_id)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_installDLC, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Checks if a specific app is installed. The app may not actually be owned by the current user, they may have it left over from a free weekend, etc. This only works for base applications, not downloadable content (DLC). Use [method Steam.isDLCInstalled] for DLC instead.
True if the specified app ID is installed; otherwise, false.
*/
//go:nosplit
func (self class) IsAppInstalled(app_id int64) bool { //gd:Steam.isAppInstalled
	var frame = callframe.New()
	callframe.Arg(frame, app_id)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_isAppInstalled, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Checks whether the current App ID is for Cyber Cafes.
*/
//go:nosplit
func (self class) IsCybercafe() bool { //gd:Steam.isCybercafe
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_isCybercafe, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Checks if the user owns a specific DLC and if the DLC is installed.
True if the user owns the DLC and it's currently installed, otherwise false.
[b]Note:[/b] Should only be used for simple client side checks - not intended for granting in-game items.
*/
//go:nosplit
func (self class) IsDLCInstalled(dlc_id int64) bool { //gd:Steam.isDLCInstalled
	var frame = callframe.New()
	callframe.Arg(frame, dlc_id)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_isDLCInstalled, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Checks if the license owned by the user provides low violence depots.
True if the user owns the DLC and it's currently installed, otherwise false.
*/
//go:nosplit
func (self class) IsLowViolence() bool { //gd:Steam.isLowViolence
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_isLowViolence, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Checks if the active user is subscribed to the current app ID.
True if the active user owns the current app ID, otherwise false.
*/
//go:nosplit
func (self class) IsSubscribed() bool { //gd:Steam.isSubscribed
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_isSubscribed, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Checks if the active user is subscribed to a specified app ID. Only use this if you need to check ownership of another game related to yours, a demo for example.
True if the active user is subscribed to the specified app ID, otherwise false.
*/
//go:nosplit
func (self class) IsSubscribedApp(app_id int64) bool { //gd:Steam.isSubscribedApp
	var frame = callframe.New()
	callframe.Arg(frame, app_id)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_isSubscribedApp, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Checks if the active user is accessing the current app ID via a temporary Family Shared license owned by another user.
True if the active user is accessing the current appID via family sharing, otherwise false.
If you need to determine the Steam ID of the permanent owner of the license, use [method Steam.getAppOwner].
*/
//go:nosplit
func (self class) IsSubscribedFromFamilySharing() bool { //gd:Steam.isSubscribedFromFamilySharing
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_isSubscribedFromFamilySharing, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Checks if the user is subscribed to the current app through a free weekend. This function will return false for users who have a retail or other type of license. Suggested you contact Valve on how to package and secure your free weekend properly.
True if the active user is subscribed to the current app ID via a free weekend otherwise false any other type of license.
*/
//go:nosplit
func (self class) IsSubscribedFromFreeWeekend() bool { //gd:Steam.isSubscribedFromFreeWeekend
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_isSubscribedFromFreeWeekend, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Checks if the user is subscribed to the current app ID through a timed trial. If so, returns true and gives back the total time the timed trial is allowed to play, along with the current amount of time the user has played.
The returned dictionary contains these keys:
[codeblock]
┠╴seconds_allowed (int)
┖╴seconds_played (int)
[/codeblock]
*/
//go:nosplit
func (self class) IsTimedTrial() Dictionary.Any { //gd:Steam.isTimedTrial
	var frame = callframe.New()
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_isTimedTrial, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Checks if the user has a VAC ban on their account.
True if the user has a VAC ban on their account; otherwise, false.
*/
//go:nosplit
func (self class) IsVACBanned() bool { //gd:Steam.isVACBanned
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_isVACBanned, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Allows you to force verify game content on next launch.
*/
//go:nosplit
func (self class) MarkContentCorrupt(missing_files_only bool) bool { //gd:Steam.markContentCorrupt
	var frame = callframe.New()
	callframe.Arg(frame, missing_files_only)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_markContentCorrupt, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Select this beta branch for this app as active, might need the game to restart so Steam can update to that branch.
*/
//go:nosplit
func (self class) SetActiveBeta(beta_name String.Readable) bool { //gd:Steam.setActiveBeta
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(beta_name)))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setActiveBeta, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Set current DLC app ID being played (or 0 if none). Allows Steam to track usage of major DLC extensions.
*/
//go:nosplit
func (self class) SetDLCContext(app_id int64) bool { //gd:Steam.setDLCContext
	var frame = callframe.New()
	callframe.Arg(frame, app_id)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setDLCContext, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Allows you to uninstall an optional DLC.
*/
//go:nosplit
func (self class) UninstallDLC(dlc_id int64) { //gd:Steam.uninstallDLC
	var frame = callframe.New()
	callframe.Arg(frame, dlc_id)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_uninstallDLC, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Activates the overlay with optional dialog to open the following: [b]Friend, Community, Players, Settings, OfficialGameGroup, Stats, Achievements, or LobbyInvite.[/b]
*/
//go:nosplit
func (self class) ActivateGameOverlay(atype String.Readable) { //gd:Steam.activateGameOverlay
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(atype)))
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_activateGameOverlay, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Activates game overlay to open the invite dialog. Invitations will be sent for the provided lobby.
*/
//go:nosplit
func (self class) ActivateGameOverlayInviteDialog(steam_id int64) { //gd:Steam.activateGameOverlayInviteDialog
	var frame = callframe.New()
	callframe.Arg(frame, steam_id)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_activateGameOverlayInviteDialog, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Activates the game overlay to open an invite dialog that will send the provided Rich Presence connect string to selected friends.
*/
//go:nosplit
func (self class) ActivateGameOverlayInviteDialogConnectString(connect_string String.Readable) { //gd:Steam.activateGameOverlayInviteDialogConnectString
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(connect_string)))
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_activateGameOverlayInviteDialogConnectString, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Activates the overlay with the application / game Steam store page.
*/
//go:nosplit
func (self class) ActivateGameOverlayToStore(app_id int64) { //gd:Steam.activateGameOverlayToStore
	var frame = callframe.New()
	callframe.Arg(frame, app_id)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_activateGameOverlayToStore, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Activates the overlay to one of the following: [b]steamid, chat, jointrade, stats, achievements, friendadd, friendremove, friendrequestaccept, or friendrequestignore.[/b]
*/
//go:nosplit
func (self class) ActivateGameOverlayToUser(atype String.Readable, steam_id int64) { //gd:Steam.activateGameOverlayToUser
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(atype)))
	callframe.Arg(frame, steam_id)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_activateGameOverlayToUser, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Activates the overlay with specified web address.
*/
//go:nosplit
func (self class) ActivateGameOverlayToWebPage(url String.Readable) { //gd:Steam.activateGameOverlayToWebPage
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(url)))
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_activateGameOverlayToWebPage, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Clear the game information in Steam; used in 'View Game Info'.
*/
//go:nosplit
func (self class) ClearRichPresence() { //gd:Steam.clearRichPresence
	var frame = callframe.New()
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_clearRichPresence, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Closes the specified Steam group chat room in the Steam UI.
*/
//go:nosplit
func (self class) CloseClanChatWindowInSteam(chat_id int64) bool { //gd:Steam.closeClanChatWindowInSteam
	var frame = callframe.New()
	callframe.Arg(frame, chat_id)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_closeClanChatWindowInSteam, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Refresh the Steam Group activity data or get the data from groups other than one that the current user is a member. After receiving the callback you can then use [method Steam.getClanActivityCounts] to get the up to date user counts.
Triggers a [signal Steam.clan_activity_downloaded] callback.
*/
//go:nosplit
func (self class) DownloadClanActivityCounts(chat_id int64, clans_to_request int64) { //gd:Steam.downloadClanActivityCounts
	var frame = callframe.New()
	callframe.Arg(frame, chat_id)
	callframe.Arg(frame, clans_to_request)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_downloadClanActivityCounts, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Gets the list of users that the current user is following. You can be following people that are not your friends. Following allows you to receive updates when the person does things like post a new piece of content to the Steam Workshop.
Triggers a [signal Steam.enumerate_following_list] callback.
[b]Note:[/b] This returns up to k_cEnumerateFollowersMax users at once. If the current user is following more than that, you will need to call this repeatedly, with start_index set to the total number of followers that you have received so far. I.E. If you have received 50 followers, and the user is following 105, you will need to call this again with start_index = 50 to get the next 50, and then again with start_index = 100 to get the remaining 5 users.
*/
//go:nosplit
func (self class) EnumerateFollowingList(start_index int64) { //gd:Steam.enumerateFollowingList
	var frame = callframe.New()
	callframe.Arg(frame, start_index)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_enumerateFollowingList, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Gets the Steam ID at the given index in a Steam group chat.
[b]Note:[/b] You must call [method Steam.getClanChatMemberCount] before calling this.
*/
//go:nosplit
func (self class) GetChatMemberByIndex(clan_id int64, user int64) int64 { //gd:Steam.getChatMemberByIndex
	var frame = callframe.New()
	callframe.Arg(frame, clan_id)
	callframe.Arg(frame, user)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getChatMemberByIndex, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Gets the most recent information we have about what the users in a Steam Group are doing. This can only retrieve data that the local client knows about. To refresh the data or get data from a group other than one that the current user is a member of you must call [method Steam.downloadClanActivityCounts].
Contains the following keys: [b]clan (int), online (int), ingame (int), and chatting (int)[/b]
*/
//go:nosplit
func (self class) GetClanActivityCounts(clan_id int64) Dictionary.Any { //gd:Steam.getClanActivityCounts
	var frame = callframe.New()
	callframe.Arg(frame, clan_id)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getClanActivityCounts, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Gets the Steam group's Steam ID at the given index.
[b]Note:[/b] You must call [method Steam.getClanCount] before calling this.
*/
//go:nosplit
func (self class) GetClanByIndex(clan_index int64) int64 { //gd:Steam.getClanByIndex
	var frame = callframe.New()
	callframe.Arg(frame, clan_index)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getClanByIndex, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Get the number of users in a Steam group chat.
[b]Note:[/b] Large steam groups cannot be iterated by the local user.
[b]Note:[/b] The current user must be in a lobby to retrieve the Steam IDs of other users in that lobby. This is used for iteration, after calling this then [method Steam.getChatMemberByIndex] can be used to get the Steam ID of each person in the chat.
*/
//go:nosplit
func (self class) GetClanChatMemberCount(clan_id int64) int64 { //gd:Steam.getClanChatMemberCount
	var frame = callframe.New()
	callframe.Arg(frame, clan_id)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getClanChatMemberCount, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Gets the data from a Steam group chat room message. This should only ever be called in response to a [signal Steam.connected_clan_chat_message] callback.
The returned dictionary contains the following keys: [b]ret (bool), text (string), type (int), and chatter (int) as a Steam ID.[/b]
*/
//go:nosplit
func (self class) GetClanChatMessage(chat_id int64, message int64) Dictionary.Any { //gd:Steam.getClanChatMessage
	var frame = callframe.New()
	callframe.Arg(frame, chat_id)
	callframe.Arg(frame, message)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getClanChatMessage, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Gets the number of Steam groups that the current user is a member of. This is used for iteration, after calling this then [method Steam.getClanByIndex] can be used to get the Steam ID of each Steam group.
*/
//go:nosplit
func (self class) GetClanCount() int64 { //gd:Steam.getClanCount
	var frame = callframe.New()
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getClanCount, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Gets the display name for the specified Steam group; if the local client knows about it.
*/
//go:nosplit
func (self class) GetClanName(clan_id int64) String.Readable { //gd:Steam.getClanName
	var frame = callframe.New()
	callframe.Arg(frame, clan_id)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getClanName, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Gets the Steam ID of the officer at the given index in a Steam group.
[b]Note:[/b] You must call [method Steam.getClanOfficerCount] before calling this.
*/
//go:nosplit
func (self class) GetClanOfficerByIndex(clan_id int64, officer int64) int64 { //gd:Steam.getClanOfficerByIndex
	var frame = callframe.New()
	callframe.Arg(frame, clan_id)
	callframe.Arg(frame, officer)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getClanOfficerByIndex, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Gets the number of officers (administrators and moderators) in a specified Steam group. This also includes the owner of the Steam group. This is used for iteration, after calling this then [method Steam.getClanOfficerByIndex] can be used to get the Steam ID of each officer.
[b]Note:[/b] You must call [method Steam.requestClanOfficerList] before this to get the required data.
*/
//go:nosplit
func (self class) GetClanOfficerCount(clan_id int64) int64 { //gd:Steam.getClanOfficerCount
	var frame = callframe.New()
	callframe.Arg(frame, clan_id)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getClanOfficerCount, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Get the steam ID of the clan owner.
*/
//go:nosplit
func (self class) GetClanOwner(clan_id int64) int64 { //gd:Steam.getClanOwner
	var frame = callframe.New()
	callframe.Arg(frame, clan_id)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getClanOwner, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Gets the unique tag (abbreviation) for the specified Steam group; If the local client knows about it. The Steam group abbreviation is a unique way for people to identify the group and is limited to 12 characters. In some games this will appear next to the name of group members.
*/
//go:nosplit
func (self class) GetClanTag(clan_id int64) String.Readable { //gd:Steam.getClanTag
	var frame = callframe.New()
	callframe.Arg(frame, clan_id)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getClanTag, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Gets the Steam ID of the recently played with user at the given index.
*/
//go:nosplit
func (self class) GetCoplayFriend(friend_number int64) int64 { //gd:Steam.getCoplayFriend
	var frame = callframe.New()
	callframe.Arg(frame, friend_number)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getCoplayFriend, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Gets the number of players that the current users has recently played with, across all games. This is used for iteration, after calling this then [method Steam.getCoplayFriend] can be used to get the Steam ID of each player. These players are have been set with previous calls to [method Steam.setPlayedWith].
*/
//go:nosplit
func (self class) GetCoplayFriendCount() int64 { //gd:Steam.getCoplayFriendCount
	var frame = callframe.New()
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getCoplayFriendCount, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Gets the number of users following the specified user.
Triggers a [signal Steam.get_follower_count] callback.
*/
//go:nosplit
func (self class) GetFollowerCount(steam_id int64) { //gd:Steam.getFollowerCount
	var frame = callframe.New()
	callframe.Arg(frame, steam_id)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getFollowerCount, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Gets the Steam ID of the user at the given index.
[b]Note:[/b] You must call [method Steam.getFriendCount] before calling this.
*/
//go:nosplit
func (self class) GetFriendByIndex(friend_number int64, friend_flags FriendFlags) int64 { //gd:Steam.getFriendByIndex
	var frame = callframe.New()
	callframe.Arg(frame, friend_number)
	callframe.Arg(frame, friend_flags)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getFriendByIndex, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Gets the app ID of the game that user played with someone on their recently-played-with list.
*/
//go:nosplit
func (self class) GetFriendCoplayGame(friend_id int64) int64 { //gd:Steam.getFriendCoplayGame
	var frame = callframe.New()
	callframe.Arg(frame, friend_id)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getFriendCoplayGame, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Gets the timestamp of when the user played with someone on their recently-played-with list. The time is provided in Unix epoch format (seconds since Jan 1st 1970).
*/
//go:nosplit
func (self class) GetFriendCoplayTime(friend_id int64) int64 { //gd:Steam.getFriendCoplayTime
	var frame = callframe.New()
	callframe.Arg(frame, friend_id)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getFriendCoplayTime, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Gets the number of users the client knows about who meet a specified criteria. (Friends, blocked, users on the same server, etc). This can be used to iterate over all of the users by calling [method Steam.getFriendByIndex] to get the Steam IDs of each user.
[b]Note:[/b] Returns -1 if the current user is not logged on.
*/
//go:nosplit
func (self class) GetFriendCount(friend_flags FriendFlags) int64 { //gd:Steam.getFriendCount
	var frame = callframe.New()
	callframe.Arg(frame, friend_flags)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getFriendCount, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Get the number of users in a source (Steam group, chat room, lobby, or game server). This is used for iteration, after calling this then [method Steam.getFriendFromSourceByIndex] can be used to get the Steam ID of each person in the source.
[b]Note:[/b] Large Steam groups cannot be iterated by the local user.
[b]Note:[/b] If you're getting the number of lobby members then you should use [method Steam.getNumLobbyMembers] instead.
*/
//go:nosplit
func (self class) GetFriendCountFromSource(source_id int64) int64 { //gd:Steam.getFriendCountFromSource
	var frame = callframe.New()
	callframe.Arg(frame, source_id)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getFriendCountFromSource, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Gets the Steam ID at the given index from a source (Steam group, chat room, lobby, or game server).
[b]Note:[/b] You must call [method Steam.getFriendCountFromSource] before calling this.
*/
//go:nosplit
func (self class) GetFriendFromSourceByIndex(source_id int64, friend_number int64) int64 { //gd:Steam.getFriendFromSourceByIndex
	var frame = callframe.New()
	callframe.Arg(frame, source_id)
	callframe.Arg(frame, friend_number)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getFriendFromSourceByIndex, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Checks if the specified friend is in a game, and gets info about the game if they are.
The returned dictionary contains the following keys:
[codeblock]
┠╴id (int) as app ID
┠╴ip (string)
┠╴game_port (int)
┠╴query_port (int)
┖╴lobby (int)
[/codeblock]
*/
//go:nosplit
func (self class) GetFriendGamePlayed(steam_id int64) Dictionary.Any { //gd:Steam.getFriendGamePlayed
	var frame = callframe.New()
	callframe.Arg(frame, steam_id)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getFriendGamePlayed, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Gets the data from a Steam friends message. This should only ever be called in response to a [signal Steam.connected_friend_chat_message] callback.
The returned dictionary contains the following keys:
[codeblock]
┠╴ret (int)
┠╴text (string)
┖╴type (int)
[/codeblock]
*/
//go:nosplit
func (self class) GetFriendMessage(friend_id int64, message int64) Dictionary.Any { //gd:Steam.getFriendMessage
	var frame = callframe.New()
	callframe.Arg(frame, friend_id)
	callframe.Arg(frame, message)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getFriendMessage, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Gets the specified user's persona (display) name. This will only be known to the current user if the other user is in their friends list, on the same game server, in a chat room or lobby, or in a small Steam group with the local user. To get the persona name of the current user use [method Steam.getPersonaName].
[b]Note:[/b] Upon on first joining a lobby, chat room, or game server the current user will not known the name of the other users automatically; that information will arrive asynchronously via [signal Steam.persona_state_change] callbacks.
*/
//go:nosplit
func (self class) GetFriendPersonaName(steam_id int64) String.Readable { //gd:Steam.getFriendPersonaName
	var frame = callframe.New()
	callframe.Arg(frame, steam_id)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getFriendPersonaName, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Gets one of the previous display names for the specified user. This only works for display names that the current user has seen on the local computer.
*/
//go:nosplit
func (self class) GetFriendPersonaNameHistory(steam_id int64, name_history int64) String.Readable { //gd:Steam.getFriendPersonaNameHistory
	var frame = callframe.New()
	callframe.Arg(frame, steam_id)
	callframe.Arg(frame, name_history)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getFriendPersonaNameHistory, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Gets the current status of the specified user. This will only be known to the current user if the other user is in their friends list, on the same game server, in a chat room or lobby, or in a small Steam group with the local user. To get the state of the current user use [method Steam.getPersonaState].
Should be one of the following:
[codeblock]
• 0 / Offline
• 1 / Online
• 2 / Busy
• 3 / Away
• 4 / Snooze
• 5 / Looking For Trade
• 6 / Looking for Play
[/codeblock]
*/
//go:nosplit
func (self class) GetFriendPersonaState(steam_id int64) PersonaState { //gd:Steam.getFriendPersonaState
	var frame = callframe.New()
	callframe.Arg(frame, steam_id)
	var r_ret = callframe.Ret[PersonaState](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getFriendPersonaState, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Gets a relationship to a specified user.
Should be one of the following:
[codeblock]
• 0 / None
• 1 / Blocked
• 2 / Request Recipient
• 3 / Friend
• 4 / Request Initiator
• 5 / Ignored
• 6 / Ignored Friend
• 7 / Suggested
• 8 / Max
[/codeblock]
*/
//go:nosplit
func (self class) GetFriendRelationship(steam_id int64) FriendRelationship { //gd:Steam.getFriendRelationship
	var frame = callframe.New()
	callframe.Arg(frame, steam_id)
	var r_ret = callframe.Ret[FriendRelationship](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getFriendRelationship, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Get a Rich Presence value from a specified friend (typically only used for debugging).
*/
//go:nosplit
func (self class) GetFriendRichPresence(friend_id int64, key String.Readable) String.Readable { //gd:Steam.getFriendRichPresence
	var frame = callframe.New()
	callframe.Arg(frame, friend_id)
	callframe.Arg(frame, pointers.Get(gd.InternalString(key)))
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getFriendRichPresence, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Gets the number of Rich Presence keys that are set on the specified user. This is used for iteration, after calling this then [method Steam.getFriendRichPresenceKeyByIndex] to get the rich presence keys. This is typically only ever used for debugging purposes.
*/
//go:nosplit
func (self class) GetFriendRichPresenceKeyCount(friend_id int64) int64 { //gd:Steam.getFriendRichPresenceKeyCount
	var frame = callframe.New()
	callframe.Arg(frame, friend_id)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getFriendRichPresenceKeyCount, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns an empty string ("") if the index is invalid or the specified user has no Rich Presence data available.
*/
//go:nosplit
func (self class) GetFriendRichPresenceKeyByIndex(friend_id int64, key int64) String.Readable { //gd:Steam.getFriendRichPresenceKeyByIndex
	var frame = callframe.New()
	callframe.Arg(frame, friend_id)
	callframe.Arg(frame, key)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getFriendRichPresenceKeyByIndex, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Gets the number of friends groups (tags) the user has created. This is used for iteration, after calling this then [method Steam.getFriendsGroupIDByIndex] can be used to get the ID of each friend group. This is not to be confused with Steam groups. Those can be obtained with [method Steam.getClanCount].
*/
//go:nosplit
func (self class) GetFriendsGroupCount() int64 { //gd:Steam.getFriendsGroupCount
	var frame = callframe.New()
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getFriendsGroupCount, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Gets the friends group ID for the given index.
[b]Note:[/b] You must call [method Steam.getFriendsGroupCount] before calling this.
*/
//go:nosplit
func (self class) GetFriendsGroupIDByIndex(friend_group int64) int64 { //gd:Steam.getFriendsGroupIDByIndex
	var frame = callframe.New()
	callframe.Arg(frame, friend_group)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getFriendsGroupIDByIndex, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Gets the number of friends in a given friends group. This should be called before getting the list of friends with [method Steam.getFriendsGroupMembersList].
*/
//go:nosplit
func (self class) GetFriendsGroupMembersCount(friend_group int64) int64 { //gd:Steam.getFriendsGroupMembersCount
	var frame = callframe.New()
	callframe.Arg(frame, friend_group)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getFriendsGroupMembersCount, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Gets the number of friends in the given friends group. If fewer friends exist than requested those positions' Steam IDs will be invalid. You must call [method Steam.getFriendsGroupMembersCount] before calling this to set up the member_count argument with an appropriate size!
The returned array contains a list of friend Steam IDs (int).
*/
//go:nosplit
func (self class) GetFriendsGroupMembersList(friend_group int64, member_count int64) Array.Any { //gd:Steam.getFriendsGroupMembersList
	var frame = callframe.New()
	callframe.Arg(frame, friend_group)
	callframe.Arg(frame, member_count)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getFriendsGroupMembersList, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Array.Through(gd.ArrayProxy[variant.Any]{}, pointers.Pack(pointers.New[gd.Array](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Gets the name for the given friends group.
*/
//go:nosplit
func (self class) GetFriendsGroupName(friend_group int64) String.Readable { //gd:Steam.getFriendsGroupName
	var frame = callframe.New()
	callframe.Arg(frame, friend_group)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getFriendsGroupName, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Gets the Steam level of the specified user. You can use the local users Steam ID to get their level.
*/
//go:nosplit
func (self class) GetFriendSteamLevel(steam_id int64) int64 { //gd:Steam.getFriendSteamLevel
	var frame = callframe.New()
	callframe.Arg(frame, steam_id)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getFriendSteamLevel, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Gets a handle to the large (128 x 128px) avatar for the specified user. You can pass in [method Steam.getSteamID] to get the current user's avatar.
Triggers a [signal Steam.avatar_loaded] callback.
A Steam image handle which is used with [method Steam.getImageSize] and [method Steam.getImageRGBA].
[b]Note:[/b] This only works for users that the local user knows about. They will automatically know about their friends, people on leaderboards they've requested, or people in the same source as them (Steam group, chat room, lobby, or game server). If they don't know about them then you must call [method Steam.requestUserInformation] to cache the avatar locally.
*/
//go:nosplit
func (self class) GetLargeFriendAvatar(steam_id int64) int64 { //gd:Steam.getLargeFriendAvatar
	var frame = callframe.New()
	callframe.Arg(frame, steam_id)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getLargeFriendAvatar, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Gets a handle to the medium (64 x 64px) avatar for the specified user. You can pass in [method Steam.getSteamID] to get the current user's avatar.
A Steam image handle which is used with [method Steam.getImageSize] and [method Steam.getImageRGBA].
[b]Note:[/b] This only works for users that the local user knows about. They will automatically know about their friends, people on leaderboards they've requested, or people in the same source as them (Steam group, chat room, lobby, or game server). If they don't know about them then you must call [method Steam.requestUserInformation] to cache the avatar locally.
*/
//go:nosplit
func (self class) GetMediumFriendAvatar(steam_id int64) int64 { //gd:Steam.getMediumFriendAvatar
	var frame = callframe.New()
	callframe.Arg(frame, steam_id)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getMediumFriendAvatar, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Gets the current user's persona (display) name. This is the same name that is displayed the users community profile page. To get the persona name of other users use [method Steam.getFriendPersonaName].
*/
//go:nosplit
func (self class) GetPersonaName() String.Readable { //gd:Steam.getPersonaName
	var frame = callframe.New()
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getPersonaName, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Gets the friend status of the current user. To get the state of other users use [method Steam.getFriendPersonaState].
Should be one of the following:
[codeblock]
• 0 / Offline
• 1 / Online
• 2 / Busy
• 3 / Away
• 4 / Snooze
• 5 / Looking For Trade
• 6 / Looking for Play
[/codeblock]
*/
//go:nosplit
func (self class) GetPersonaState() PersonaState { //gd:Steam.getPersonaState
	var frame = callframe.New()
	var r_ret = callframe.Ret[PersonaState](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getPersonaState, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Get player's avatar. Short-cuts to the various avatar functions in Steamworks.
Size is passed as follows:
[codeblock]
• 1 / small avatar
• 2 / medium avatar
• 3 / large avatar
[/codeblock]
Triggers a [signal Steam.avatar_loaded] callback.
[b]Note:[/b] This is a unique function to GodotSteam.
*/
//go:nosplit
func (self class) GetPlayerAvatar(size int64, steam_id int64) { //gd:Steam.getPlayerAvatar
	var frame = callframe.New()
	callframe.Arg(frame, size)
	callframe.Arg(frame, steam_id)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getPlayerAvatar, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Returns nickname the current user has set for the specified player. Returns NULL if the no nickname has been set for that player.
*/
//go:nosplit
func (self class) GetPlayerNickname(steam_id int64) String.Readable { //gd:Steam.getPlayerNickname
	var frame = callframe.New()
	callframe.Arg(frame, steam_id)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getPlayerNickname, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Returns a string property for a user's equipped profile item.
*/
//go:nosplit
func (self class) GetProfileItemPropertyString(steam_id int64, item_type CommunityProfileItemType, item_property CommunityProfileItemProperty) String.Readable { //gd:Steam.getProfileItemPropertyString
	var frame = callframe.New()
	callframe.Arg(frame, steam_id)
	callframe.Arg(frame, item_type)
	callframe.Arg(frame, item_property)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getProfileItemPropertyString, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Returns an unsigned integer property for a user's equipped profile item.
*/
//go:nosplit
func (self class) GetProfileItemPropertyInt(steam_id int64, item_type CommunityProfileItemType, item_property CommunityProfileItemProperty) int64 { //gd:Steam.getProfileItemPropertyInt
	var frame = callframe.New()
	callframe.Arg(frame, steam_id)
	callframe.Arg(frame, item_type)
	callframe.Arg(frame, item_property)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getProfileItemPropertyInt, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Get list of players user has recently played game with.
The returned array contains a list of:
[codeblock]
┖╴player (dictionary)
    ┠╴id (int) as friend Steam ID.
    ┠╴name (string)
    ┠╴time (int)
    ┖╴status (int)
[/codeblock]
[b]Note:[/b] This is a unique function to GodotSteam.
*/
//go:nosplit
func (self class) GetRecentPlayers() Array.Any { //gd:Steam.getRecentPlayers
	var frame = callframe.New()
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getRecentPlayers, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Array.Through(gd.ArrayProxy[variant.Any]{}, pointers.Pack(pointers.New[gd.Array](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Gets a handle to the small (32 x 32px) avatar for the specified user. You can pass in [method Steam.getSteamID] to get the current user's avatar.
Triggers a [signal Steam.avatar_loaded] callback.
A Steam image handle which is used with [method Steam.getImageSize] and [method Steam.getImageRGBA].
[b]Note:[/b] This only works for users that the local user knows about. They will automatically know about their friends, people on leaderboards they've requested, or people in the same source as them (Steam group, chat room, lobby, or game server). If they don't know about them then you must call [method Steam.requestUserInformation] to cache the avatar locally.
*/
//go:nosplit
func (self class) GetSmallFriendAvatar(steam_id int64) int64 { //gd:Steam.getSmallFriendAvatar
	var frame = callframe.New()
	callframe.Arg(frame, steam_id)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getSmallFriendAvatar, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Get list of friends groups (tags) the user has created. This is not to be confused with Steam groups.
The returned array contains a list of:
[codeblock]
┖╴tags (dictionary)
    ┠╴id (int) as friend group ID
    ┠╴name (string)
    ┖╴members (int)
[/codeblock]
*/
//go:nosplit
func (self class) GetUserFriendsGroups() Array.Any { //gd:Steam.getUserFriendsGroups
	var frame = callframe.New()
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getUserFriendsGroups, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Array.Through(gd.ArrayProxy[variant.Any]{}, pointers.Pack(pointers.New[gd.Array](r_ret.Get())))
	frame.Free()
	return ret
}

/*
If current user is chat restricted, they can't send or receive any text or voice chat messages. The user can't see custom avatars. But the user can be online and send or receive game invites. A chat restricted user cannot add friends or join any groups. Restricted users can still be online and send/receive game invites.
It should be one of the following:
[codeblock]
• 0 / None
• 1 / Unknown
• 2 / Any Chat
• 4 / Voice Chat
• 8 / Group Chat
• 16 / Rating
• 32 / Game Invites
• 64 / Trading
[/codeblock]
*/
//go:nosplit
func (self class) GetUserRestrictions() int64 { //gd:Steam.getUserRestrictions
	var frame = callframe.New()
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getUserRestrictions, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Get a list of user's Steam friends; a mix of different Steamworks API friend functions.
The returned array contains a list of:
[codeblock]
┖╴ friends (dictionary)
    ┠╴id (int) as friend Steam ID
    ┠╴name (string)
    ┖╴status (int)
[/codeblock]
[b]Note:[/b] This is a unique function to GodotSteam.
*/
//go:nosplit
func (self class) GetUserSteamFriends() Array.Any { //gd:Steam.getUserSteamFriends
	var frame = callframe.New()
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getUserSteamFriends, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Array.Through(gd.ArrayProxy[variant.Any]{}, pointers.Pack(pointers.New[gd.Array](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Get list of user's Steam groups; a mix of different Steamworks API group functions.
The returned array contains a list of:
[codeblock]
┖╴groups (dictionary)
    ┠╴id (int) as group ID
    ┠╴name (string)
    ┖╴tag (string)
[/codeblock]
[b]Note:[/b] This is a unique function to GodotSteam.
*/
//go:nosplit
func (self class) GetUserSteamGroups() Array.Any { //gd:Steam.getUserSteamGroups
	var frame = callframe.New()
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getUserSteamGroups, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Array.Through(gd.ArrayProxy[variant.Any]{}, pointers.Pack(pointers.New[gd.Array](r_ret.Get())))
	frame.Free()
	return ret
}

/*
After calling [method Steam.requestEquippedProfileItems], you can use this function to check if the user has a type of profile item equipped or not.
[b]Note:[/b] Triggers a [signal Steam.equipped_profile_items] callback.
*/
//go:nosplit
func (self class) HasEquippedProfileItem(steam_id int64, friend_flags CommunityProfileItemType) bool { //gd:Steam.hasEquippedProfileItem
	var frame = callframe.New()
	callframe.Arg(frame, steam_id)
	callframe.Arg(frame, friend_flags)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_hasEquippedProfileItem, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns true if the specified user meets any of the criteria specified in friend_flags:
[codeblock]
• 0x00 / None
• 0x01 / Blocked
• 0x02 / Friendship Requested
• 0x04 / Immediate
• 0x08 / Clan Member
• 0x10 / On Game Server
• 0x80 / Requesting Friendship
• 0x100 / Requesting Info
• 0x200 / Ignored
• 0x400 / Ignored Friend
• 0x0000 / Chat Member
• 0xFFFF / All
[/codeblock]
*/
//go:nosplit
func (self class) HasFriend(steam_id int64, friend_flags FriendFlags) bool { //gd:Steam.hasFriend
	var frame = callframe.New()
	callframe.Arg(frame, steam_id)
	callframe.Arg(frame, friend_flags)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_hasFriend, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Invites a friend or clan member to the current game using a special invite string. If the target user accepts the invite then the connect_string gets added to the command-line when launching the game. If the game is already running for that user, then they will receive a [signal Steam.join_game_requested] callback with the connect string.
*/
//go:nosplit
func (self class) InviteUserToGame(friend_id int64, connect_string String.Readable) bool { //gd:Steam.inviteUserToGame
	var frame = callframe.New()
	callframe.Arg(frame, friend_id)
	callframe.Arg(frame, pointers.Get(gd.InternalString(connect_string)))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_inviteUserToGame, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Checks if a user in the Steam group chat room is an admin.
*/
//go:nosplit
func (self class) IsClanChatAdmin(chat_id int64, steam_id int64) bool { //gd:Steam.isClanChatAdmin
	var frame = callframe.New()
	callframe.Arg(frame, chat_id)
	callframe.Arg(frame, steam_id)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_isClanChatAdmin, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Checks if the Steam group is public.
*/
//go:nosplit
func (self class) IsClanPublic(clan_id int64) bool { //gd:Steam.isClanPublic
	var frame = callframe.New()
	callframe.Arg(frame, clan_id)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_isClanPublic, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Checks if the Steam group is an official game group/community hub.
*/
//go:nosplit
func (self class) IsClanOfficialGameGroup(clan_id int64) bool { //gd:Steam.isClanOfficialGameGroup
	var frame = callframe.New()
	callframe.Arg(frame, clan_id)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_isClanOfficialGameGroup, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Checks if the Steam Group chat room is open in the Steam UI.
*/
//go:nosplit
func (self class) IsClanChatWindowOpenInSteam(chat_id int64) bool { //gd:Steam.isClanChatWindowOpenInSteam
	var frame = callframe.New()
	callframe.Arg(frame, chat_id)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_isClanChatWindowOpenInSteam, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Checks if the current user is following the specified user.
*/
//go:nosplit
func (self class) IsFollowing(steam_id int64) { //gd:Steam.isFollowing
	var frame = callframe.New()
	callframe.Arg(frame, steam_id)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_isFollowing, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Checks if a specified user is in a source (Steam group, chat room, lobby, or game server).
*/
//go:nosplit
func (self class) IsUserInSource(steam_id int64, source_id int64) bool { //gd:Steam.isUserInSource
	var frame = callframe.New()
	callframe.Arg(frame, steam_id)
	callframe.Arg(frame, source_id)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_isUserInSource, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Allows the user to join Steam group (clan) chats right within the game. The behavior is somewhat complicated, because the user may or may not be already in the group chat from outside the game or in the overlay. You can use [method Steam.activateGameOverlayToUser] to open the in-game overlay version of the chat.
Triggers a [signal Steam.join_clan_chat_complete] callback.
May additionally trigger the following callbacks:
[codeblock]
┠╴connect_chat_join
┠╴connect_chat_leave
┖╴connect_clan_chat_message
[/codeblock]
*/
//go:nosplit
func (self class) JoinClanChatRoom(clan_id int64) { //gd:Steam.joinClanChatRoom
	var frame = callframe.New()
	callframe.Arg(frame, clan_id)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_joinClanChatRoom, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Leaves a Steam group chat that the user has previously entered with [method Steam.joinClanChatRoom].
*/
//go:nosplit
func (self class) LeaveClanChatRoom(clan_id int64) bool { //gd:Steam.leaveClanChatRoom
	var frame = callframe.New()
	callframe.Arg(frame, clan_id)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_leaveClanChatRoom, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Opens the specified Steam group chat room in the Steam UI.
*/
//go:nosplit
func (self class) OpenClanChatWindowInSteam(chat_id int64) bool { //gd:Steam.openClanChatWindowInSteam
	var frame = callframe.New()
	callframe.Arg(frame, chat_id)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_openClanChatWindowInSteam, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Call this before calling [method Steam.activateGameOverlayToWebPage] to have the Steam Overlay Browser block navigations to your specified protocol (scheme) uris and instead dispatch a [signal Steam.overlay_browser_protocol] callback to your game. [method Steam.activateGameOverlayToWebPage] must have been called with 1.
[b]Note:[/b] While this function is in the SDK, it is not listed in the Steamworks docs.
*/
//go:nosplit
func (self class) RegisterProtocolInOverlayBrowser(protocol String.Readable) bool { //gd:Steam.registerProtocolInOverlayBrowser
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(protocol)))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_registerProtocolInOverlayBrowser, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Sends a message to a Steam friend.
*/
//go:nosplit
func (self class) ReplyToFriendMessage(steam_id int64, message String.Readable) bool { //gd:Steam.replyToFriendMessage
	var frame = callframe.New()
	callframe.Arg(frame, steam_id)
	callframe.Arg(frame, pointers.Get(gd.InternalString(message)))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_replyToFriendMessage, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Requests information about a Steam group officers (administrators and moderators).
Triggers a [signal Steam.request_clan_officer_list] callback.
[b]Note:[/b] You can only ask about Steam groups that a user is a member of.
[b]Note:[/b] This won't download avatars for the officers automatically. If no avatar image is available for an officer, then call [method Steam.requestUserInformation] to download the avatar.
*/
//go:nosplit
func (self class) RequestClanOfficerList(clan_id int64) { //gd:Steam.requestClanOfficerList
	var frame = callframe.New()
	callframe.Arg(frame, clan_id)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_requestClanOfficerList, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
After calling RequestEquippedProfileItems, you can use this function to check if the user has a type of profile item equipped or not.
*/
//go:nosplit
func (self class) RequestEquippedProfileItems(steam_id int64) { //gd:Steam.requestEquippedProfileItems
	var frame = callframe.New()
	callframe.Arg(frame, steam_id)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_requestEquippedProfileItems, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Requests Rich Presence data from a specific user. This is used to get the Rich Presence information from a user that is not a friend of the current user, like someone in the same lobby or game server. This function is rate limited, if you call this too frequently for a particular user then it will just immediately post a callback without requesting new data from the server.
Triggers a [signal Steam.friend_rich_presence_update] callback.
*/
//go:nosplit
func (self class) RequestFriendRichPresence(friend_id int64) { //gd:Steam.requestFriendRichPresence
	var frame = callframe.New()
	callframe.Arg(frame, friend_id)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_requestFriendRichPresence, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Requests information about a user - persona name and avatar; if require_name_only is set, then the avatar of a user isn't downloaded.
*/
//go:nosplit
func (self class) RequestUserInformation(steam_id int64, require_name_only bool) bool { //gd:Steam.requestUserInformation
	var frame = callframe.New()
	callframe.Arg(frame, steam_id)
	callframe.Arg(frame, require_name_only)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_requestUserInformation, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Sends a message to a Steam group chat room.
*/
//go:nosplit
func (self class) SendClanChatMessage(chat_id int64, text String.Readable) bool { //gd:Steam.sendClanChatMessage
	var frame = callframe.New()
	callframe.Arg(frame, chat_id)
	callframe.Arg(frame, pointers.Get(gd.InternalString(text)))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_sendClanChatMessage, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
User is in a game pressing the talk button (will suppress the microphone for all voice comms from the Steam friends UI).
Let Steam know that the user is currently using voice chat in game. This will suppress the microphone for all voice communication in the Steam UI.
*/
//go:nosplit
func (self class) SetInGameVoiceSpeaking(steam_id int64, speaking bool) { //gd:Steam.setInGameVoiceSpeaking
	var frame = callframe.New()
	callframe.Arg(frame, steam_id)
	callframe.Arg(frame, speaking)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setInGameVoiceSpeaking, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Listens for Steam friends chat messages. You can then show these chats inline in the game. For example with a Blizzard style chat message system or the chat system in Data 2. After enabling this you will receive [signal Steam.connected_friend_chat_message] callbacks when ever the user receives a chat message. You can get the actual message data from this callback with [method Steam.getFriendMessage]. You can send messages with [method Steam.replyToFriendMessage].
Triggers a [signal Steam.connected_friend_chat_message] callback.
*/
//go:nosplit
func (self class) SetListenForFriendsMessages(intercept bool) bool { //gd:Steam.setListenForFriendsMessages
	var frame = callframe.New()
	callframe.Arg(frame, intercept)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setListenForFriendsMessages, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Sets the current user's persona name, stores it on the server and publishes the changes to all friends who are online. Changes take place locally immediately, and a [signal Steam.persona_state_change] callback is posted, presuming success. If the name change fails to happen on the server, then an additional [signal Steam.persona_state_change] callback will be posted to change the name back, in addition to the final result available in the call result.
Triggers a [signal Steam.name_changed] callback.
*/
//go:nosplit
func (self class) SetPersonaName(name String.Readable) { //gd:Steam.setPersonaName
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(name)))
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setPersonaName, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Set player as 'Played With' for game.
[b]Note:[/b] The current user must be in game with the other player for the association to work.
*/
//go:nosplit
func (self class) SetPlayedWith(steam_id int64) { //gd:Steam.setPlayedWith
	var frame = callframe.New()
	callframe.Arg(frame, steam_id)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setPlayedWith, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Sets a Rich Presence key/value for the current user that is automatically shared to all friends playing the same game. Each user can have up to 20 keys set as defined by k_cchMaxRichPresenceKeys. There are two special keys used for viewing/joining games:
[b]status[/b] - A UTF-8 string that will show up in the 'view game info' dialog in the Steam friends list.
[b]connect[/b] - A UTF-8 string that contains the command-line for how a friend can connect to a game. This enables the 'join game' button in the 'view game info' dialog, in the steam friends list right click menu, and on the players Steam community profile. Be sure your app implements [method Steam.getLaunchCommandLine] so you can disable the popup warning when launched via a command line.
There are three additional special keys used by the new Steam Chat:
[b]steam_display[/b] - Names a rich presence localization token that will be displayed in the viewing user's selected language in the Steam client UI. See Rich Presence Localization for more info, including a link to a page for testing this rich presence data. If steam_display is not set to a valid localization tag, then rich presence will not be displayed in the Steam client.
[b]steam_player_group[/b] - When set, indicates to the Steam client that the player is a member of a particular group. Players in the same group may be organized together in various places in the Steam UI. This string could identify a party, a server, or whatever grouping is relevant for your game. The string itself is not displayed to users.
[b]steam_player_group_size[/b] - When set, indicates the total number of players in the steam_player_group. The Steam client may use this number to display additional information about a group when all of the members are not part of a user's friends list. (For example, "Bob, Pete, and 4 more".)
You can clear all of the keys for the current user with [method Steam.clearRichPresence]. To get rich presence keys for friends use [method Steam.getFriendRichPresence].
*/
//go:nosplit
func (self class) SetRichPresence(key String.Readable, value String.Readable) bool { //gd:Steam.setRichPresence
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(key)))
	callframe.Arg(frame, pointers.Get(gd.InternalString(value)))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setRichPresence, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
A keyname and a list of comma separated values: one of which is must be found in order for the match to qualify; fails if a search is currently in progress.
*/
//go:nosplit
func (self class) AddGameSearchParams(key String.Readable, values String.Readable) int64 { //gd:Steam.addGameSearchParams
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(key)))
	callframe.Arg(frame, pointers.Get(gd.InternalString(values)))
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_addGameSearchParams, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
All players in lobby enter the queue and await a [signal Steam.search_for_game_progress] callback. Fails if another search is currently in progress. If not the owner of the lobby or search already in progress this call fails. Periodic callbacks will be sent as queue time estimates change.
[b]Note:[/b] The [signal Steam.search_for_game_progress] callback does not seem to exist in the SDK anywhere.
*/
//go:nosplit
func (self class) SearchForGameWithLobby(lobby_id int64, player_min int64, player_max int64) int64 { //gd:Steam.searchForGameWithLobby
	var frame = callframe.New()
	callframe.Arg(frame, lobby_id)
	callframe.Arg(frame, player_min)
	callframe.Arg(frame, player_max)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_searchForGameWithLobby, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
User enter the queue and await a [signal Steam.search_for_game_progress] callback. fails if another search is currently in progress. Periodic callbacks will be sent as queue time estimates change.
[b]Note:[/b] The [signal Steam.search_for_game_progress] callback does not seem to exist in the SDK anywhere.
*/
//go:nosplit
func (self class) SearchForGameSolo(player_min int64, player_max int64) int64 { //gd:Steam.searchForGameSolo
	var frame = callframe.New()
	callframe.Arg(frame, player_min)
	callframe.Arg(frame, player_max)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_searchForGameSolo, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
After receiving [signal Steam.search_for_game_result], accept or decline the game. Multiple [signal Steam.search_for_game_result] will follow as players accept game until the host starts or cancels the game.
[b]Note:[/b] the [signal Steam.search_for_game_progress] callback does not seem to exist in the SDK anywhere.
*/
//go:nosplit
func (self class) AcceptGame() int64 { //gd:Steam.acceptGame
	var frame = callframe.New()
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_acceptGame, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
After receiving [signal Steam.search_for_game_result], accept or decline the game. Multiple [signal Steam.search_for_game_result] will follow as players accept game until the host starts or cancels the game.
[b]Note:[/b] The [signal Steam.search_for_game_progress] callback does not seem to exist in the SDK anywhere.
*/
//go:nosplit
func (self class) DeclineGame() int64 { //gd:Steam.declineGame
	var frame = callframe.New()
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_declineGame, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
After receiving GameStartedByHostCallback_t get connection details to server.
[b]Note:[/b] The GameStartedByHostCallback_t callback does not seem to exist in the SDK anywhere.
*/
//go:nosplit
func (self class) RetrieveConnectionDetails(host_id int64) String.Readable { //gd:Steam.retrieveConnectionDetails
	var frame = callframe.New()
	callframe.Arg(frame, host_id)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_retrieveConnectionDetails, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Leaves queue if still waiting.
*/
//go:nosplit
func (self class) EndGameSearch() int64 { //gd:Steam.endGameSearch
	var frame = callframe.New()
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_endGameSearch, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
A keyname and a list of comma separated values: all the values you allow.
*/
//go:nosplit
func (self class) SetGameHostParams(key String.Readable, value String.Readable) int64 { //gd:Steam.setGameHostParams
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(key)))
	callframe.Arg(frame, pointers.Get(gd.InternalString(value)))
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setGameHostParams, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Set connection details for players once game is found so they can connect to this server.
*/
//go:nosplit
func (self class) SetConnectionDetails(details String.Readable, connection_details int64) int64 { //gd:Steam.setConnectionDetails
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(details)))
	callframe.Arg(frame, connection_details)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setConnectionDetails, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Mark server as available for more players with player_min, player_max desired. Accept no lobbies with player-count greater than max_team_size.
*/
//go:nosplit
func (self class) RequestPlayersForGame(player_min int64, player_max int64, max_team_size int64) int64 { //gd:Steam.requestPlayersForGame
	var frame = callframe.New()
	callframe.Arg(frame, player_min)
	callframe.Arg(frame, player_max)
	callframe.Arg(frame, max_team_size)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_requestPlayersForGame, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Accept the player list and release connection details to players.
*/
//go:nosplit
func (self class) HostConfirmGameStart(game_id int64) int64 { //gd:Steam.hostConfirmGameStart
	var frame = callframe.New()
	callframe.Arg(frame, game_id)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_hostConfirmGameStart, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Cancel request and leave the pool of game hosts looking for players.
*/
//go:nosplit
func (self class) CancelRequestPlayersForGame() int64 { //gd:Steam.cancelRequestPlayersForGame
	var frame = callframe.New()
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_cancelRequestPlayersForGame, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Submit a result for one player; does not end the game. game_id continues to describe this game.
*/
//go:nosplit
func (self class) SubmitPlayerResult(game_id int64, player_id int64, player_result PlayerResult) int64 { //gd:Steam.submitPlayerResult
	var frame = callframe.New()
	callframe.Arg(frame, game_id)
	callframe.Arg(frame, player_id)
	callframe.Arg(frame, player_result)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_submitPlayerResult, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Ends the game. No further [method Steam.submitPlayerResult] for game_id will be accepted.
*/
//go:nosplit
func (self class) EndGame(game_id int64) int64 { //gd:Steam.endGame
	var frame = callframe.New()
	callframe.Arg(frame, game_id)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_endGame, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Add a header to any HTTP requests from this browser. A full list of standard request fields are available here on Wikipedia.
If no handle is passed, GodotSteam will use the internal one.
*/
//go:nosplit
func (self class) AddHeader(key String.Readable, value String.Readable, this_handle int64) { //gd:Steam.addHeader
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(key)))
	callframe.Arg(frame, pointers.Get(gd.InternalString(value)))
	callframe.Arg(frame, this_handle)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_addHeader, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Sets whether a pending load is allowed or if it should be canceled. You can use this feature to limit the valid pages allowed in your HTML surface.
If no handle is passed, GodotSteam will use the internal one.
[b]Note:[/b] You must call this in response to a [signal Steam.html_start_request] callback.
*/
//go:nosplit
func (self class) AllowStartRequest(allowed bool, this_handle int64) { //gd:Steam.allowStartRequest
	var frame = callframe.New()
	callframe.Arg(frame, allowed)
	callframe.Arg(frame, this_handle)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_allowStartRequest, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Copy the currently selected text from the current page in an HTML surface into the local clipboard.
If no handle is passed, GodotSteam will use the internal one.
*/
//go:nosplit
func (self class) CopyToClipboard(this_handle int64) { //gd:Steam.copyToClipboard
	var frame = callframe.New()
	callframe.Arg(frame, this_handle)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_copyToClipboard, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Create a browser object for displaying of an HTML page.
If no handle is passed, GodotSteam will use the internal one.
[b]Note:[/b] You must call [method Steam.removeBrowser] when you are done using this browser to free up the resources associated with it. Failing to do so will result in a memory leak.
*/
//go:nosplit
func (self class) CreateBrowser(user_agent String.Readable, user_css String.Readable) { //gd:Steam.createBrowser
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(user_agent)))
	callframe.Arg(frame, pointers.Get(gd.InternalString(user_css)))
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_createBrowser, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Run a javascript script in the currently loaded page.
*/
//go:nosplit
func (self class) ExecuteJavascript(script String.Readable, this_handle int64) { //gd:Steam.executeJavascript
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(script)))
	callframe.Arg(frame, this_handle)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_executeJavascript, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Find a string in the current page of an HTML surface. This is the equivalent of "ctrl+f" in your browser of choice. It will highlight all of the matching strings. You should call [method Steam.stopFind] when the input string has changed or you want to stop searching.
Triggers a [signal Steam.html_search_results] callback.
*/
//go:nosplit
func (self class) Find(search String.Readable, currently_in_find bool, reverse bool, this_handle int64) { //gd:Steam.find
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(search)))
	callframe.Arg(frame, currently_in_find)
	callframe.Arg(frame, reverse)
	callframe.Arg(frame, this_handle)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_find, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Retrieves details about a link at a specific position on the current page in an HTML surface.
Triggers a [signal Steam.html_link_at_position] callback.
*/
//go:nosplit
func (self class) GetLinkAtPosition(x int64, y int64, this_handle int64) { //gd:Steam.getLinkAtPosition
	var frame = callframe.New()
	callframe.Arg(frame, x)
	callframe.Arg(frame, y)
	callframe.Arg(frame, this_handle)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getLinkAtPosition, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Navigate back in the page history.
*/
//go:nosplit
func (self class) GoBack(this_handle int64) { //gd:Steam.goBack
	var frame = callframe.New()
	callframe.Arg(frame, this_handle)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_goBack, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Navigate forward in the page history.
*/
//go:nosplit
func (self class) GoForward(this_handle int64) { //gd:Steam.goForward
	var frame = callframe.New()
	callframe.Arg(frame, this_handle)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_goForward, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Initializes the HTML Surface API. This must be called prior to using any other functions in this interface. You must call [method Steam.htmlShutdown] when you are done using the interface to free up the resources associated with it. Failing to do so will result in a memory leak.
*/
//go:nosplit
func (self class) HtmlInit() bool { //gd:Steam.htmlInit
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_htmlInit, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Allows you to react to a page wanting to open a javascript modal dialog notification.
[b]Note:[/b] You must call this in response to [signal Steam.html_js_alert] and [signal Steam.html_js_confirm] callbacks.
*/
//go:nosplit
func (self class) JsDialogResponse(result bool, this_handle int64) { //gd:Steam.jsDialogResponse
	var frame = callframe.New()
	callframe.Arg(frame, result)
	callframe.Arg(frame, this_handle)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_jsDialogResponse, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
unicode_char is the unicode character point for this keypress (and potentially multiple chars per press).
*/
//go:nosplit
func (self class) KeyChar(unicode_char int64, key_modifiers HTMLKeyModifiers, this_handle int64) { //gd:Steam.keyChar
	var frame = callframe.New()
	callframe.Arg(frame, unicode_char)
	callframe.Arg(frame, key_modifiers)
	callframe.Arg(frame, this_handle)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_keyChar, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Keyboard interactions, native keycode is the virtual key code value from your OS.
*/
//go:nosplit
func (self class) KeyDown(native_key_code int64, key_modifiers HTMLKeyModifiers, this_handle int64) { //gd:Steam.keyDown
	var frame = callframe.New()
	callframe.Arg(frame, native_key_code)
	callframe.Arg(frame, key_modifiers)
	callframe.Arg(frame, this_handle)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_keyDown, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Keyboard interactions, native keycode is the virtual key code value from your OS.
*/
//go:nosplit
func (self class) KeyUp(native_key_code int64, key_modifiers HTMLKeyModifiers, this_handle int64) { //gd:Steam.keyUp
	var frame = callframe.New()
	callframe.Arg(frame, native_key_code)
	callframe.Arg(frame, key_modifiers)
	callframe.Arg(frame, this_handle)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_keyUp, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Navigate to a specified URL. If you send POST data with post_data then the data should be formatted as: name1=value1&name2=value2. You can load any URI scheme supported by Chromium Embedded Framework including but not limited to: http://, https://, ftp://, and file:///. If no scheme is specified then http:// is used.
Triggers a [signal Steam.html_start_request] callback.
*/
//go:nosplit
func (self class) LoadURL(url String.Readable, post_data String.Readable, this_handle int64) { //gd:Steam.loadURL
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(url)))
	callframe.Arg(frame, pointers.Get(gd.InternalString(post_data)))
	callframe.Arg(frame, this_handle)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_loadURL, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Tells an HTML surface that a mouse button has been double clicked. The click will occur where the surface thinks the mouse is based on the last call to [method Steam.mouseMove].
*/
//go:nosplit
func (self class) MouseDoubleClick(mouse_button HTMLMouseButton, this_handle int64) { //gd:Steam.mouseDoubleClick
	var frame = callframe.New()
	callframe.Arg(frame, mouse_button)
	callframe.Arg(frame, this_handle)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_mouseDoubleClick, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Tells an HTML surface that a mouse button has been pressed. The click will occur where the surface thinks the mouse is based on the last call to [method Steam.mouseMove].
*/
//go:nosplit
func (self class) MouseDown(mouse_button HTMLMouseButton, this_handle int64) { //gd:Steam.mouseDown
	var frame = callframe.New()
	callframe.Arg(frame, mouse_button)
	callframe.Arg(frame, this_handle)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_mouseDown, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Tells an HTML surface where the mouse is.
*/
//go:nosplit
func (self class) MouseMove(x int64, y int64, this_handle int64) { //gd:Steam.mouseMove
	var frame = callframe.New()
	callframe.Arg(frame, x)
	callframe.Arg(frame, y)
	callframe.Arg(frame, this_handle)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_mouseMove, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Tells an HTML surface that a mouse button has been released. The click will occur where the surface thinks the mouse is based on the last call to [method Steam.mouseMove].
*/
//go:nosplit
func (self class) MouseUp(mouse_button HTMLMouseButton, this_handle int64) { //gd:Steam.mouseUp
	var frame = callframe.New()
	callframe.Arg(frame, mouse_button)
	callframe.Arg(frame, this_handle)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_mouseUp, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Tells an HTML surface that the mouse wheel has moved.
*/
//go:nosplit
func (self class) MouseWheel(delta int64, this_handle int64) { //gd:Steam.mouseWheel
	var frame = callframe.New()
	callframe.Arg(frame, delta)
	callframe.Arg(frame, this_handle)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_mouseWheel, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Paste from the local clipboard to the current page in an HTML surface.
*/
//go:nosplit
func (self class) PasteFromClipboard(this_handle int64) { //gd:Steam.pasteFromClipboard
	var frame = callframe.New()
	callframe.Arg(frame, this_handle)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_pasteFromClipboard, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Refreshes the current page. The reload will most likely hit the local cache instead of going over the network. This is equivalent to F5 or Ctrl+R in your browser of choice.
*/
//go:nosplit
func (self class) Reload(this_handle int64) { //gd:Steam.reload
	var frame = callframe.New()
	callframe.Arg(frame, this_handle)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_reload, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
You must call this when you are done with an HTML surface, freeing the resources associated with it. Failing to call this will result in a memory leak.
*/
//go:nosplit
func (self class) RemoveBrowser(this_handle int64) { //gd:Steam.removeBrowser
	var frame = callframe.New()
	callframe.Arg(frame, this_handle)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_removeBrowser, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Enable/disable low-resource background mode, where Javascript and repaint timers are throttled, resources are more aggressively purged from memory, and audio/video elements are paused. When background mode is enabled, all HTML5 video and audio objects will execute ".pause()" and gain the property "._steam_background_paused = 1". When background mode is disabled, any video or audio objects with that property will resume with ".play()".
*/
//go:nosplit
func (self class) SetBackgroundMode(background_mode bool, this_handle int64) { //gd:Steam.setBackgroundMode
	var frame = callframe.New()
	callframe.Arg(frame, background_mode)
	callframe.Arg(frame, this_handle)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setBackgroundMode, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Set a webcookie for a specific hostname. You can read more about the specifics of setting cookies here on Wikipedia.
*/
//go:nosplit
func (self class) SetCookie(hostname String.Readable, key String.Readable, value String.Readable, path String.Readable, expires int64, secure bool, http_only bool) { //gd:Steam.setCookie
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(hostname)))
	callframe.Arg(frame, pointers.Get(gd.InternalString(key)))
	callframe.Arg(frame, pointers.Get(gd.InternalString(value)))
	callframe.Arg(frame, pointers.Get(gd.InternalString(path)))
	callframe.Arg(frame, expires)
	callframe.Arg(frame, secure)
	callframe.Arg(frame, http_only)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setCookie, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Scroll the current page horizontally.
Triggers a [signal Steam.html_horizontal_scroll] callback.
*/
//go:nosplit
func (self class) SetHorizontalScroll(absolute_pixel_scroll int64, this_handle int64) { //gd:Steam.setHorizontalScroll
	var frame = callframe.New()
	callframe.Arg(frame, absolute_pixel_scroll)
	callframe.Arg(frame, this_handle)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setHorizontalScroll, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Tell a HTML surface if it has key focus currently, controls showing the I-beam cursor in text controls amongst other things.
*/
//go:nosplit
func (self class) SetKeyFocus(has_key_focus bool, this_handle int64) { //gd:Steam.setKeyFocus
	var frame = callframe.New()
	callframe.Arg(frame, has_key_focus)
	callframe.Arg(frame, this_handle)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setKeyFocus, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Zoom the current page in an HTML surface. The current scale factor is available from HTML_NeedsPaint_t.flPageScale, HTML_HorizontalScroll_t.flPageScale, and HTML_VerticalScroll_t.flPageScale.
*/
//go:nosplit
func (self class) SetPageScaleFactor(zoom float64, point_x int64, point_y int64, this_handle int64) { //gd:Steam.setPageScaleFactor
	var frame = callframe.New()
	callframe.Arg(frame, zoom)
	callframe.Arg(frame, point_x)
	callframe.Arg(frame, point_y)
	callframe.Arg(frame, this_handle)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setPageScaleFactor, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Sets the display size of a surface in pixels.
*/
//go:nosplit
func (self class) SetSize(width int64, height int64, this_handle int64) { //gd:Steam.setSize
	var frame = callframe.New()
	callframe.Arg(frame, width)
	callframe.Arg(frame, height)
	callframe.Arg(frame, this_handle)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setSize, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Scroll the current page vertically.
Triggers a [signal Steam.html_vertical_scroll] callback.
*/
//go:nosplit
func (self class) SetVerticalScroll(absolute_pixel_scroll int64, this_handle int64) { //gd:Steam.setVerticalScroll
	var frame = callframe.New()
	callframe.Arg(frame, absolute_pixel_scroll)
	callframe.Arg(frame, this_handle)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setVerticalScroll, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Shutdown the ISteamHTMLSurface interface, releasing the memory and handles. You must call this when you are done using this interface to prevent memory and handle leaks. After calling this then all of the functions provided in this interface will fail until you call htmlInit to reinitialize again.
*/
//go:nosplit
func (self class) HtmlShutdown() bool { //gd:Steam.htmlShutdown
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_htmlShutdown, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Cancel a currently running find.
*/
//go:nosplit
func (self class) StopFind(this_handle int64) { //gd:Steam.stopFind
	var frame = callframe.New()
	callframe.Arg(frame, this_handle)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_stopFind, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Stop the load of the current HTML page.
*/
//go:nosplit
func (self class) StopLoad(this_handle int64) { //gd:Steam.stopLoad
	var frame = callframe.New()
	callframe.Arg(frame, this_handle)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_stopLoad, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Open the current pages HTML source code in default local text editor, used for debugging.
*/
//go:nosplit
func (self class) ViewSource(this_handle int64) { //gd:Steam.viewSource
	var frame = callframe.New()
	callframe.Arg(frame, this_handle)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_viewSource, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Creates a cookie container to store cookies during the lifetime of the process. This API is just for during process lifetime, after Steam restarts no cookies are persisted and you have no way to access the cookie container across repeat executions of your process.
If allow_responses_to_modify is true then any response to your requests using this cookie container may add new cookies to the container which may be transmitted with future requests. Otherwise, if it's false then only cookies you explicitly set will be sent.
You can associate the cookie container with a http request by using [method Steam.setHTTPRequestCookieContainer], and you can set a cookie using [method Steam.setCookie]. Don't forget to free the container when you're done with it to prevent leaking memory by calling [method Steam.releaseCookieContainer]!
*/
//go:nosplit
func (self class) CreateCookieContainer(allow_response_to_modify bool) int64 { //gd:Steam.createCookieContainer
	var frame = callframe.New()
	callframe.Arg(frame, allow_response_to_modify)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_createCookieContainer, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Initializes a new HTTP request. Requires the method such as GET or POST and the absolute URL for the request. Both http and https are supported, so this string must start with "http://" or "https://" and should look like "http://store.steampowered.com/app/10/" or similar. This call returns a handle that you can use to make further calls to setup and then send the HTTP request with [method Steam.sendHTTPRequest] or [method Steam.sendHTTPRequestAndStreamResponse]. Don't forget to free the HTTP request when you're done with it to prevent leaking memory by calling [method Steam.releaseHTTPRequest].
*/
//go:nosplit
func (self class) CreateHTTPRequest(request_method HTTPMethod, absolute_url String.Readable) int64 { //gd:Steam.createHTTPRequest
	var frame = callframe.New()
	callframe.Arg(frame, request_method)
	callframe.Arg(frame, pointers.Get(gd.InternalString(absolute_url)))
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_createHTTPRequest, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Defers a request which has already been sent by moving it at the back of the queue.
*/
//go:nosplit
func (self class) DeferHTTPRequest(request_handle int64) bool { //gd:Steam.deferHTTPRequest
	var frame = callframe.New()
	callframe.Arg(frame, request_handle)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_deferHTTPRequest, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Gets progress on downloading the body for the request. This will be zero unless a response header has already been received which included a content-length field. For responses that contain no content-length it will report zero for the duration of the request as the size is unknown until the connection closes.
*/
//go:nosplit
func (self class) GetHTTPDownloadProgressPct(request_handle int64) float64 { //gd:Steam.getHTTPDownloadProgressPct
	var frame = callframe.New()
	callframe.Arg(frame, request_handle)
	var r_ret = callframe.Ret[float64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getHTTPDownloadProgressPct, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Check if the reason the request failed was because we timed it out (rather than some harder failure). You'll want to call this within the context of [signal Steam.http_request_completed] callback if request_success is false.
*/
//go:nosplit
func (self class) GetHTTPRequestWasTimedOut(request_handle int64) bool { //gd:Steam.getHTTPRequestWasTimedOut
	var frame = callframe.New()
	callframe.Arg(frame, request_handle)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getHTTPRequestWasTimedOut, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Gets the body data from an HTTP response. This must be called after the HTTP request has completed and returned the HTTP response via the http_request_completed call result associated with this request handle. You should first call [method Steam.getHTTPResponseBodySize] or use the body_size variable provided in the call result, you can then allocate a buffer with that size to pass into this function. This is only for HTTP requests which were sent with [method Steam.sendHTTPRequest]. Use [method Steam.getHTTPStreamingResponseBodyData] if you're using streaming HTTP requests via [method Steam.sendHTTPRequestAndStreamResponse].
*/
//go:nosplit
func (self class) GetHTTPResponseBodyData(request_handle int64, buffer_size int64) Packed.Bytes { //gd:Steam.getHTTPResponseBodyData
	var frame = callframe.New()
	callframe.Arg(frame, request_handle)
	callframe.Arg(frame, buffer_size)
	var r_ret = callframe.Ret[gd.PackedPointers](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getHTTPResponseBodyData, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Packed.Bytes(Array.Through(gd.PackedProxy[gd.PackedByteArray, byte]{}, pointers.Pack(pointers.New[gd.PackedByteArray](r_ret.Get()))))
	frame.Free()
	return ret
}

/*
Gets the size of the body data from an HTTP response. This must be called after the HTTP request has completed and returned the HTTP response via the [signal Steam.http_request_completed] or [signal Steam.http_request_data_received] associated with this request handle. If this returns successfully, then you can allocate a buffer with the provided size to fill with the data obtained from [method Steam.getHTTPResponseBodyData] or [method Steam.getHTTPStreamingResponseBodyData].
*/
//go:nosplit
func (self class) GetHTTPResponseBodySize(request_handle int64) int64 { //gd:Steam.getHTTPResponseBodySize
	var frame = callframe.New()
	callframe.Arg(frame, request_handle)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getHTTPResponseBodySize, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Checks if a header is present in an HTTP response and returns its size. This must be called after the HTTP request has completed and returned the HTTP response via the [signal Steam.http_request_completed] call result associated with this request handle. If the response header exists in the response, then you can allocate a correctly sized buffer to get the associated value with [method Steam.getHTTPResponseHeaderValue]. Here is a list of standard response header names on Wikipedia.
*/
//go:nosplit
func (self class) GetHTTPResponseHeaderSize(request_handle int64, header_name String.Readable) int64 { //gd:Steam.getHTTPResponseHeaderSize
	var frame = callframe.New()
	callframe.Arg(frame, request_handle)
	callframe.Arg(frame, pointers.Get(gd.InternalString(header_name)))
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getHTTPResponseHeaderSize, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Gets a header value from an HTTP response. This must be called after the HTTP request has completed and returned the HTTP response via the [signal Steam.http_request_completed] call result associated with this request handle. You should first call [method Steam.getHTTPResponseHeaderSize] to check for the presence of the header and to get the size. You can then allocate a buffer with that size and pass it into this function. Here is a list of standard response header names on Wikipedia.
*/
//go:nosplit
func (self class) GetHTTPResponseHeaderValue(request_handle int64, header_name String.Readable, buffer_size int64) Packed.Bytes { //gd:Steam.getHTTPResponseHeaderValue
	var frame = callframe.New()
	callframe.Arg(frame, request_handle)
	callframe.Arg(frame, pointers.Get(gd.InternalString(header_name)))
	callframe.Arg(frame, buffer_size)
	var r_ret = callframe.Ret[gd.PackedPointers](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getHTTPResponseHeaderValue, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Packed.Bytes(Array.Through(gd.PackedProxy[gd.PackedByteArray, byte]{}, pointers.Pack(pointers.New[gd.PackedByteArray](r_ret.Get()))))
	frame.Free()
	return ret
}

/*
Gets the body data from a streaming HTTP response. This must be called after data is received from a streaming HTTP request via the [signal Steam.http_request_completed] callback associated with this request handle. Typically you'll want to allocate a buffer associated with the request handle using the Content-Length HTTP response field to receive the total size of the data when you receive the header via [signal Steam.http_request_headers_received]. You can then append data to that buffer as it comes in. This is only for streaming HTTP requests which were sent with [method Steam.sendHTTPRequestAndStreamResponse]. Use [method Steam.getHTTPResponseBodyData] if you're using [method Steam.sendHTTPRequest].
*/
//go:nosplit
func (self class) GetHTTPStreamingResponseBodyData(request_handle int64, offset int64, buffer_size int64) Packed.Bytes { //gd:Steam.getHTTPStreamingResponseBodyData
	var frame = callframe.New()
	callframe.Arg(frame, request_handle)
	callframe.Arg(frame, offset)
	callframe.Arg(frame, buffer_size)
	var r_ret = callframe.Ret[gd.PackedPointers](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getHTTPStreamingResponseBodyData, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Packed.Bytes(Array.Through(gd.PackedProxy[gd.PackedByteArray, byte]{}, pointers.Pack(pointers.New[gd.PackedByteArray](r_ret.Get()))))
	frame.Free()
	return ret
}

/*
Prioritizes a request which has already been sent by moving it at the front of the queue.
*/
//go:nosplit
func (self class) PrioritizeHTTPRequest(request_handle int64) bool { //gd:Steam.prioritizeHTTPRequest
	var frame = callframe.New()
	callframe.Arg(frame, request_handle)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_prioritizeHTTPRequest, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Releases a cookie container, freeing the memory allocated within Steam. You must call this when you are done using each HTTP cookie container handle that you obtained via [method Steam.createCookieContainer]!
*/
//go:nosplit
func (self class) ReleaseCookieContainer(cookie_handle int64) bool { //gd:Steam.releaseCookieContainer
	var frame = callframe.New()
	callframe.Arg(frame, cookie_handle)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_releaseCookieContainer, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Releases an HTTP request handle, freeing the memory allocated within Steam. You must call this when you are done using each HTTP request handle that you obtained via [method Steam.createHTTPRequest]!
*/
//go:nosplit
func (self class) ReleaseHTTPRequest(request_handle int64) bool { //gd:Steam.releaseHTTPRequest
	var frame = callframe.New()
	callframe.Arg(frame, request_handle)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_releaseHTTPRequest, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Sends an HTTP request. This call is asynchronous and provides a call result handle which you must use to track the call to its completion. If you have multiple requests in flight at the same time you can use [method Steam.prioritizeHTTPRequest] or [method Steam.deferHTTPRequest] to set the priority of the request.
If the user is in offline mode in Steam, then this will add an only-if-cached cache-control header and only do a local cache lookup rather than sending any actual remote request.
If the data you are expecting is large, you can use [method Steam.sendHTTPRequestAndStreamResponse] to stream the data in chunks.
*/
//go:nosplit
func (self class) SendHTTPRequest(request_handle int64) bool { //gd:Steam.sendHTTPRequest
	var frame = callframe.New()
	callframe.Arg(frame, request_handle)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_sendHTTPRequest, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Sends an HTTP request and streams the response back in chunks. This call is asynchronous and provides a call result handle which you must use to track the call to its completion. Typically you'll want to allocate a buffer associated with the request handle using the Content-Length HTTP response field to receive the total size of the data when you receive the header via http_request_headers_received. You can then append data to that buffer as it comes in.
If you have multiple requests in flight at the same time you can use [method Steam.prioritizeHTTPRequest] or [method Steam.deferHTTPRequest] to set the priority of the request.
If the user is in offline mode in Steam, then this will add an only-if-cached cache-control header and only do a local cache lookup rather than sending any actual remote request.
If the data you are expecting is small (on the order of a few megabytes or less) then you'll likely want to use [method Steam.sendHTTPRequest].
*/
//go:nosplit
func (self class) SendHTTPRequestAndStreamResponse(request_handle int64) bool { //gd:Steam.sendHTTPRequestAndStreamResponse
	var frame = callframe.New()
	callframe.Arg(frame, request_handle)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_sendHTTPRequestAndStreamResponse, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Adds a cookie to the specified cookie container that will be used with future requests.
*/
//go:nosplit
func (self class) SetHTTPCookie(cookie_handle int64, host String.Readable, url String.Readable, cookie String.Readable) bool { //gd:Steam.setHTTPCookie
	var frame = callframe.New()
	callframe.Arg(frame, cookie_handle)
	callframe.Arg(frame, pointers.Get(gd.InternalString(host)))
	callframe.Arg(frame, pointers.Get(gd.InternalString(url)))
	callframe.Arg(frame, pointers.Get(gd.InternalString(cookie)))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setHTTPCookie, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Set an absolute timeout in milliseconds for the HTTP request.
This is the total time timeout which is different than the network activity timeout which is set with [method Steam.setHTTPRequestNetworkActivityTimeout] which can bump every time we get more data.
*/
//go:nosplit
func (self class) SetHTTPRequestAbsoluteTimeoutMS(request_handle int64, milliseconds int64) bool { //gd:Steam.setHTTPRequestAbsoluteTimeoutMS
	var frame = callframe.New()
	callframe.Arg(frame, request_handle)
	callframe.Arg(frame, milliseconds)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setHTTPRequestAbsoluteTimeoutMS, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Set a context value for the request, which will be returned in the [signal Steam.http_request_completed] callback after sending the request.
This is just so the caller can easily keep track of which callbacks go with which request data.
Must be called before sending the request.
*/
//go:nosplit
func (self class) SetHTTPRequestContextValue(request_handle int64, context_value int64) bool { //gd:Steam.setHTTPRequestContextValue
	var frame = callframe.New()
	callframe.Arg(frame, request_handle)
	callframe.Arg(frame, context_value)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setHTTPRequestContextValue, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Associates a cookie container to use for an HTTP request.
*/
//go:nosplit
func (self class) SetHTTPRequestCookieContainer(request_handle int64, cookie_handle int64) bool { //gd:Steam.setHTTPRequestCookieContainer
	var frame = callframe.New()
	callframe.Arg(frame, request_handle)
	callframe.Arg(frame, cookie_handle)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setHTTPRequestCookieContainer, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Set a GET or POST parameter value on the HTTP request.
Must be called prior to sending the request.
*/
//go:nosplit
func (self class) SetHTTPRequestGetOrPostParameter(request_handle int64, name String.Readable, value String.Readable) bool { //gd:Steam.setHTTPRequestGetOrPostParameter
	var frame = callframe.New()
	callframe.Arg(frame, request_handle)
	callframe.Arg(frame, pointers.Get(gd.InternalString(name)))
	callframe.Arg(frame, pointers.Get(gd.InternalString(value)))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setHTTPRequestGetOrPostParameter, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Set a request header value for the HTTP request.
Must be called before sending the request.
A full list of standard request fields are available here on Wikipedia. The User-Agent field is explicitly disallowed as it gets overwritten when the request is sent.
*/
//go:nosplit
func (self class) SetHTTPRequestHeaderValue(request_handle int64, header_name String.Readable, header_value String.Readable) bool { //gd:Steam.setHTTPRequestHeaderValue
	var frame = callframe.New()
	callframe.Arg(frame, request_handle)
	callframe.Arg(frame, pointers.Get(gd.InternalString(header_name)))
	callframe.Arg(frame, pointers.Get(gd.InternalString(header_value)))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setHTTPRequestHeaderValue, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Set the timeout in seconds for the HTTP request.
The default timeout is 60 seconds if you don't call this. This can get bumped every time we get more data. Use [method Steam.setHTTPRequestAbsoluteTimeoutMS] if you need a strict maximum timeout.
*/
//go:nosplit
func (self class) SetHTTPRequestNetworkActivityTimeout(request_handle int64, timeout_seconds int64) bool { //gd:Steam.setHTTPRequestNetworkActivityTimeout
	var frame = callframe.New()
	callframe.Arg(frame, request_handle)
	callframe.Arg(frame, timeout_seconds)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setHTTPRequestNetworkActivityTimeout, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Sets the body for an HTTP Post request.
Will fail and return false on a GET request, and will fail if POST params have already been set for the request. Setting this raw body makes it the only contents for the post, the content_type parameter will set the "content-type" header for the request to inform the server how to interpret the body.
*/
//go:nosplit
func (self class) SetHTTPRequestRawPostBody(request_handle int64, content_type String.Readable, body String.Readable) bool { //gd:Steam.setHTTPRequestRawPostBody
	var frame = callframe.New()
	callframe.Arg(frame, request_handle)
	callframe.Arg(frame, pointers.Get(gd.InternalString(content_type)))
	callframe.Arg(frame, pointers.Get(gd.InternalString(body)))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setHTTPRequestRawPostBody, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Sets that the HTTPS request should require verified SSL certificate via machines certificate trust store.
This currently only works Windows and macOS.
*/
//go:nosplit
func (self class) SetHTTPRequestRequiresVerifiedCertificate(request_handle int64, require_verified_certificate bool) bool { //gd:Steam.setHTTPRequestRequiresVerifiedCertificate
	var frame = callframe.New()
	callframe.Arg(frame, request_handle)
	callframe.Arg(frame, require_verified_certificate)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setHTTPRequestRequiresVerifiedCertificate, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Set additional user agent info for a request.
This doesn't clobber the normal user agent, it just adds the extra info on the end. Sending NULL or an empty string resets the user agent info to the default value.
*/
//go:nosplit
func (self class) SetHTTPRequestUserAgentInfo(request_handle int64, user_agent_info String.Readable) bool { //gd:Steam.setHTTPRequestUserAgentInfo
	var frame = callframe.New()
	callframe.Arg(frame, request_handle)
	callframe.Arg(frame, pointers.Get(gd.InternalString(user_agent_info)))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setHTTPRequestUserAgentInfo, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Reconfigure the controller to use the specified action set (i.e. "Menu", "Walk", or "Drive").
This is cheap, and can be safely called repeatedly. It's often easier to repeatedly call it in your state loops, instead of trying to place it in all of your state transitions.
*/
//go:nosplit
func (self class) ActivateActionSet(input_handle int64, action_set_handle int64) { //gd:Steam.activateActionSet
	var frame = callframe.New()
	callframe.Arg(frame, input_handle)
	callframe.Arg(frame, action_set_handle)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_activateActionSet, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Reconfigure the controller to use the specified action set layer.
*/
//go:nosplit
func (self class) ActivateActionSetLayer(input_handle int64, action_set_layer_handle int64) { //gd:Steam.activateActionSetLayer
	var frame = callframe.New()
	callframe.Arg(frame, input_handle)
	callframe.Arg(frame, action_set_layer_handle)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_activateActionSetLayer, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Reconfigure the controller to stop using the specified action set.
*/
//go:nosplit
func (self class) DeactivateActionSetLayer(input_handle int64, action_set_handle int64) { //gd:Steam.deactivateActionSetLayer
	var frame = callframe.New()
	callframe.Arg(frame, input_handle)
	callframe.Arg(frame, action_set_handle)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_deactivateActionSetLayer, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Reconfigure the controller to stop using all action set layers.
*/
//go:nosplit
func (self class) DeactivateAllActionSetLayers(input_handle int64) { //gd:Steam.deactivateAllActionSetLayers
	var frame = callframe.New()
	callframe.Arg(frame, input_handle)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_deactivateAllActionSetLayers, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Fill an array with all of the currently active action set layers for a specified controller handle.
*/
//go:nosplit
func (self class) GetActionSetHandle(action_set_name String.Readable) int64 { //gd:Steam.getActionSetHandle
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(action_set_name)))
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getActionSetHandle, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Get an action origin that you can use in your glyph look up table or passed into [method Steam.getGlyphForActionOrigin] or [method Steam.getStringForActionOrigin].
*/
//go:nosplit
func (self class) GetActionOriginFromXboxOrigin(input_handle int64, origin int64) InputActionOrigin { //gd:Steam.getActionOriginFromXboxOrigin
	var frame = callframe.New()
	callframe.Arg(frame, input_handle)
	callframe.Arg(frame, origin)
	var r_ret = callframe.Ret[InputActionOrigin](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getActionOriginFromXboxOrigin, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Fill an array with all of the currently active action set layers for a specified controller handle.
Contains a list of handles (int).
*/
//go:nosplit
func (self class) GetActiveActionSetLayers(input_handle int64) Array.Any { //gd:Steam.getActiveActionSetLayers
	var frame = callframe.New()
	callframe.Arg(frame, input_handle)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getActiveActionSetLayers, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Array.Through(gd.ArrayProxy[variant.Any]{}, pointers.Pack(pointers.New[gd.Array](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Gets the current state of the supplied analog game action.
The returned dictionary contains the following keys: [b]mode (int), x (float),y (float), and active (bool).[/b]
*/
//go:nosplit
func (self class) GetAnalogActionData(input_handle int64, analog_action_handle int64) Dictionary.Any { //gd:Steam.getAnalogActionData
	var frame = callframe.New()
	callframe.Arg(frame, input_handle)
	callframe.Arg(frame, analog_action_handle)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getAnalogActionData, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Get the handle of the specified analog action.
[b]Note:[/b] This function does not take an action set handle parameter. That means that each action in your VDF file must have a unique string identifier. In other words, if you use an action called "up" in two different action sets, this function will only ever return one of them and the other will be ignored.
*/
//go:nosplit
func (self class) GetAnalogActionHandle(action_name String.Readable) int64 { //gd:Steam.getAnalogActionHandle
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(action_name)))
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getAnalogActionHandle, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Get the origin(s) for an analog action within an action set by filling the return array with handles. Use this to display the appropriate on-screen prompt for the action.
Contains a list of handles (int).
*/
//go:nosplit
func (self class) GetAnalogActionOrigins(input_handle int64, action_set_handle int64, analog_action_handle int64) Array.Any { //gd:Steam.getAnalogActionOrigins
	var frame = callframe.New()
	callframe.Arg(frame, input_handle)
	callframe.Arg(frame, action_set_handle)
	callframe.Arg(frame, analog_action_handle)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getAnalogActionOrigins, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Array.Through(gd.ArrayProxy[variant.Any]{}, pointers.Pack(pointers.New[gd.Array](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Enumerates currently connected controllers by filling returned array with controller handles.
Contains a list of controller handle (int).
*/
//go:nosplit
func (self class) GetConnectedControllers() Array.Any { //gd:Steam.getConnectedControllers
	var frame = callframe.New()
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getConnectedControllers, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Array.Through(gd.ArrayProxy[variant.Any]{}, pointers.Pack(pointers.New[gd.Array](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Returns the associated controller handle for the specified emulated gamepad. Can be used with [method Steam.getInputTypeForHandle] to determine the type of controller using Steam Input Gamepad Emulation.
*/
//go:nosplit
func (self class) GetControllerForGamepadIndex(index int64) int64 { //gd:Steam.getControllerForGamepadIndex
	var frame = callframe.New()
	callframe.Arg(frame, index)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getControllerForGamepadIndex, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Get the currently active action set for the specified controller.
*/
//go:nosplit
func (self class) GetCurrentActionSet(input_handle int64) int64 { //gd:Steam.getCurrentActionSet
	var frame = callframe.New()
	callframe.Arg(frame, input_handle)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getCurrentActionSet, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Gets the major and minor device binding revisions for Steam Input API configurations. Minor revisions are for small changes such as adding a new option action or updating localization in the configuration. When updating a Minor revision only one new configuration needs to be update with the "Use Action Block" flag set. Major revisions are to be used when changing the number of action sets or otherwise reworking configurations to the degree that older configurations are no longer usable. When a user's binding disagree's with the major revision of the current official configuration Steam will forcibly update the user to the new configuration. New configurations will need to be made for every controller when updating the Major revision.
The returned array contains a list of:
[codeblock]
┠╴major (int)
┖╴minor (int)minor (int)
[/codeblock]
*/
//go:nosplit
func (self class) GetDeviceBindingRevision(input_handle int64) Array.Any { //gd:Steam.getDeviceBindingRevision
	var frame = callframe.New()
	callframe.Arg(frame, input_handle)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getDeviceBindingRevision, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Array.Through(gd.ArrayProxy[variant.Any]{}, pointers.Pack(pointers.New[gd.Array](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Returns the current state of the supplied digital game action.
The returned dictionary contains the following keys:
[codeblock]
┠╴state (bool)
┖╴active (bool)
[/codeblock]
*/
//go:nosplit
func (self class) GetDigitalActionData(input_handle int64, digital_action_handle int64) Dictionary.Any { //gd:Steam.getDigitalActionData
	var frame = callframe.New()
	callframe.Arg(frame, input_handle)
	callframe.Arg(frame, digital_action_handle)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getDigitalActionData, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Get the handle of the specified digital action.
[b]Note:[/b] This function does not take an action set handle parameter. That means that each action in your VDF file must have a unique string identifier. In other words, if you use an action called "up" in two different action sets, this function will only ever return one of them and the other will be ignored.
*/
//go:nosplit
func (self class) GetDigitalActionHandle(action_name String.Readable) int64 { //gd:Steam.getDigitalActionHandle
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(action_name)))
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getDigitalActionHandle, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Get the origin(s) for a digital action within an action set by filling return array with input handles. Use this to display the appropriate on-screen prompt for the action.
Contains a list of handles (int).
*/
//go:nosplit
func (self class) GetDigitalActionOrigins(input_handle int64, action_set_handle int64, digital_action_handle int64) Array.Any { //gd:Steam.getDigitalActionOrigins
	var frame = callframe.New()
	callframe.Arg(frame, input_handle)
	callframe.Arg(frame, action_set_handle)
	callframe.Arg(frame, digital_action_handle)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getDigitalActionOrigins, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Array.Through(gd.ArrayProxy[variant.Any]{}, pointers.Pack(pointers.New[gd.Array](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Returns the associated gamepad index for the specified controller, if emulating a gamepad.
*/
//go:nosplit
func (self class) GetGamepadIndexForController(input_handle int64) int64 { //gd:Steam.getGamepadIndexForController
	var frame = callframe.New()
	callframe.Arg(frame, input_handle)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getGamepadIndexForController, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Get a local path to art for on-screen glyph for a particular origin.
*/
//go:nosplit
func (self class) GetGlyphForActionOrigin(origin InputActionOrigin) String.Readable { //gd:Steam.getGlyphForActionOrigin
	var frame = callframe.New()
	callframe.Arg(frame, origin)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getGlyphForActionOrigin, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Returns the input type (device model) for the specified controller. This tells you if a given controller is a Steam controller, Xbox 360 controller, PS4 controller, etc.
*/
//go:nosplit
func (self class) GetInputTypeForHandle(input_handle int64) InputType { //gd:Steam.getInputTypeForHandle
	var frame = callframe.New()
	callframe.Arg(frame, input_handle)
	var r_ret = callframe.Ret[InputType](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getInputTypeForHandle, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns raw motion data for the specified controller.
The returned dictionary contains the following keys:
[codeblock]
┠╴rot_quat_x (float)
┠╴rot_quat_y (float)
┠╴rot_quat_z (float)
┠╴rot_quat_w (float)
┠╴pos_accel_x (float)
┠╴pos_accel_y (float)
┠╴pos_accel_z (float)
┠╴rot_vel_x (float)
┠╴rot_vel_y (float)
┖╴rot_vel_z (float)
[/codeblock]
*/
//go:nosplit
func (self class) GetMotionData(input_handle int64) Dictionary.Any { //gd:Steam.getMotionData
	var frame = callframe.New()
	callframe.Arg(frame, input_handle)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getMotionData, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Get the Steam Remote Play session ID associated with a device, or 0 if there is no session associated with it. See isteamremoteplay.h for more information on Steam Remote Play sessions.
*/
//go:nosplit
func (self class) GetRemotePlaySessionID(input_handle int64) int64 { //gd:Steam.getRemotePlaySessionID
	var frame = callframe.New()
	callframe.Arg(frame, input_handle)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getRemotePlaySessionID, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns a localized string (from Steam's language setting) for the specified origin.
*/
//go:nosplit
func (self class) GetStringForActionOrigin(origin InputActionOrigin) String.Readable { //gd:Steam.getStringForActionOrigin
	var frame = callframe.New()
	callframe.Arg(frame, origin)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getStringForActionOrigin, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

/*
[method Steam.inputInit] and [method Steam.inputShutdown] must be called when starting/ending use of this interface.
If explicitly_call_runframe is called then you will need to manually call runFrame each frame, otherwise Steam Input will updated when [method Steam.run_callbacks] is called.
*/
//go:nosplit
func (self class) InputInit(explicitly_call_runframe bool) bool { //gd:Steam.inputInit
	var frame = callframe.New()
	callframe.Arg(frame, explicitly_call_runframe)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_inputInit, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
[method Steam.inputInit] and [method Steam.inputShutdown] must be called when starting/ending use of this interface.
*/
//go:nosplit
func (self class) InputShutdown() bool { //gd:Steam.inputShutdown
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_inputShutdown, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Synchronize API state with the latest Steam Controller inputs available. This is performed automatically by run_callbacks, but for the absolute lowest possible latency, you can call this directly before reading controller state.
*/
//go:nosplit
func (self class) RunFrame(reserved_value bool) { //gd:Steam.runFrame
	var frame = callframe.New()
	callframe.Arg(frame, reserved_value)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_runFrame, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Set the controller LED color on supported controllers.
[b]Note:[/b] The VSC does not support any color but white, and will interpret the RGB values as a grayscale value affecting the brightness of the Steam button LED. The DS4 responds to full color information and uses the values to set the color and brightness of the lightbar.
*/
//go:nosplit
func (self class) SetLEDColor(input_handle int64, color_r int64, color_g int64, color_b int64, flags int64) { //gd:Steam.setLEDColor
	var frame = callframe.New()
	callframe.Arg(frame, input_handle)
	callframe.Arg(frame, color_r)
	callframe.Arg(frame, color_g)
	callframe.Arg(frame, color_b)
	callframe.Arg(frame, flags)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setLEDColor, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Invokes the Steam overlay and brings up the binding screen.
*/
//go:nosplit
func (self class) ShowBindingPanel(input_handle int64) bool { //gd:Steam.showBindingPanel
	var frame = callframe.New()
	callframe.Arg(frame, input_handle)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_showBindingPanel, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Stops the momentum of an analog action (where applicable, ie a touchpad w/ virtual trackball settings).
[b]Note:[/b] This will also stop all associated haptics. This is useful for situations where you want to indicate to the user that the limit of an action has been reached, such as spinning a carousel or scrolling a webpage.
*/
//go:nosplit
func (self class) StopAnalogActionMomentum(input_handle int64, action int64) { //gd:Steam.stopAnalogActionMomentum
	var frame = callframe.New()
	callframe.Arg(frame, input_handle)
	callframe.Arg(frame, action)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_stopAnalogActionMomentum, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Get the equivalent origin for a given controller type or the closest controller type that existed in the SDK you built into your game if destination_inputis 0. This action origin can be used in your glyph look up table or passed into [method Steam.getGlyphForActionOrigin] or [method Steam.getStringForActionOrigin].
*/
//go:nosplit
func (self class) TranslateActionOrigin(destination_input InputType, source_origin InputActionOrigin) int64 { //gd:Steam.translateActionOrigin
	var frame = callframe.New()
	callframe.Arg(frame, destination_input)
	callframe.Arg(frame, source_origin)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_translateActionOrigin, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Triggers a (low-level) haptic pulse on supported controllers.
Currently only the VSC supports haptic pulses. This API call will be ignored for all other controller models. The typical max value of an unsigned short is 65535, which means the longest haptic pulse you can trigger with this method has a duration of 0.065535 seconds (ie, less than 1/10th of a second). This function should be thought of as a low-level primitive meant to be repeatedly used in higher-level user functions to generate more sophisticated behavior.
*/
//go:nosplit
func (self class) TriggerHapticPulse(input_handle int64, target_pad int64, duration int64) { //gd:Steam.triggerHapticPulse
	var frame = callframe.New()
	callframe.Arg(frame, input_handle)
	callframe.Arg(frame, target_pad)
	callframe.Arg(frame, duration)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_triggerHapticPulse, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Triggers a repeated haptic pulse on supported controllers.
[b]Note:[/b] Currently only the VSC supports haptic pulses. This API call will be ignored for incompatible controller models. This is a more user-friendly function to call than [method Steam.triggerHapticPulse] as it can generate pulse patterns long enough to be actually noticed by the user. Changing the duration and offset parameters will change the "texture" of the haptic pulse.
*/
//go:nosplit
func (self class) TriggerRepeatedHapticPulse(input_handle int64, target_pad int64, duration int64, offset int64, repeat int64, flags int64) { //gd:Steam.triggerRepeatedHapticPulse
	var frame = callframe.New()
	callframe.Arg(frame, input_handle)
	callframe.Arg(frame, target_pad)
	callframe.Arg(frame, duration)
	callframe.Arg(frame, offset)
	callframe.Arg(frame, repeat)
	callframe.Arg(frame, flags)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_triggerRepeatedHapticPulse, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Trigger a vibration event on supported controllers.
[b]Note:[/b] This API call will be ignored for incompatible controller models. This generates the traditional "rumble" vibration effect. The VSC will emulate traditional rumble using its haptics.
*/
//go:nosplit
func (self class) TriggerVibration(input_handle int64, left_speed int64, right_speed int64) { //gd:Steam.triggerVibration
	var frame = callframe.New()
	callframe.Arg(frame, input_handle)
	callframe.Arg(frame, left_speed)
	callframe.Arg(frame, right_speed)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_triggerVibration, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Set the absolute path to the Input Action Manifest file containing the in-game actions and file paths to the official configurations. Used in games that bundle Steam Input configurations inside of the game depot instead of using the Steam Workshop.
*/
//go:nosplit
func (self class) SetInputActionManifestFilePath(manifest_path String.Readable) bool { //gd:Steam.setInputActionManifestFilePath
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(manifest_path)))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setInputActionManifestFilePath, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Set the trigger effect for a DualSense controller.
*/
//go:nosplit
func (self class) SetDualSenseTriggerEffect(input_handle int64, parameters int64, trigger_mask int64, effect_mode SCEPadTriggerEffectMode, position int64, amplitude int64, frequency int64) { //gd:Steam.setDualSenseTriggerEffect
	var frame = callframe.New()
	callframe.Arg(frame, input_handle)
	callframe.Arg(frame, parameters)
	callframe.Arg(frame, trigger_mask)
	callframe.Arg(frame, effect_mode)
	callframe.Arg(frame, position)
	callframe.Arg(frame, amplitude)
	callframe.Arg(frame, frequency)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setDualSenseTriggerEffect, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Waits on an IPC event from Steam sent when there is new data to be fetched from the data drop. Returns true when data was recievied before the timeout expires. Useful for games with a dedicated input thread.
*/
//go:nosplit
func (self class) WaitForData(wait_forever bool, timeout int64) bool { //gd:Steam.waitForData
	var frame = callframe.New()
	callframe.Arg(frame, wait_forever)
	callframe.Arg(frame, timeout)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_waitForData, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns true if new data has been received since the last time action data was accessed via [method Steam.getDigitalActionData] or [method Steam.getAnalogActionData]. The game will still need to call [method Steam.runFrame] or [method Steam.run_callbacks] before this to update the data stream.
*/
//go:nosplit
func (self class) NewDataAvailable() bool { //gd:Steam.newDataAvailable
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_newDataAvailable, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Enable [signal Steam.input_device_connected] and [signal Steam.input_device_disconnected] callbacks. Each controller that is already connected will generate a device connected callback when you enable them.
*/
//go:nosplit
func (self class) EnableDeviceCallbacks() { //gd:Steam.enableDeviceCallbacks
	var frame = callframe.New()
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_enableDeviceCallbacks, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Enable the [signal Steam.input_action_event] callback.
*/
//go:nosplit
func (self class) EnableActionEventCallbacks() { //gd:Steam.enableActionEventCallbacks
	var frame = callframe.New()
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_enableActionEventCallbacks, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Get a local path to a PNG file for the provided origin's glyph.
*/
//go:nosplit
func (self class) GetGlyphPNGForActionOrigin(origin InputActionOrigin, size InputGlyphSize, flags int64) String.Readable { //gd:Steam.getGlyphPNGForActionOrigin
	var frame = callframe.New()
	callframe.Arg(frame, origin)
	callframe.Arg(frame, size)
	callframe.Arg(frame, flags)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getGlyphPNGForActionOrigin, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Get a local path to a SVG file for the provided origin's glyph.
*/
//go:nosplit
func (self class) GetGlyphSVGForActionOrigin(origin InputActionOrigin, flags int64) String.Readable { //gd:Steam.getGlyphSVGForActionOrigin
	var frame = callframe.New()
	callframe.Arg(frame, origin)
	callframe.Arg(frame, flags)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getGlyphSVGForActionOrigin, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Trigger a vibration event on supported controllers including Xbox trigger impulse rumble - Steam will translate these commands into haptic pulses for Steam Controllers.
*/
//go:nosplit
func (self class) TriggerVibrationExtended(input_handle int64, left_speed int64, right_speed int64, left_trigger_speed int64, right_trigger_speed int64) { //gd:Steam.triggerVibrationExtended
	var frame = callframe.New()
	callframe.Arg(frame, input_handle)
	callframe.Arg(frame, left_speed)
	callframe.Arg(frame, right_speed)
	callframe.Arg(frame, left_trigger_speed)
	callframe.Arg(frame, right_trigger_speed)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_triggerVibrationExtended, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Send a haptic pulse, works on Steam Deck and Steam Controller devices.
*/
//go:nosplit
func (self class) TriggerSimpleHapticEvent(input_handle int64, haptic_location int64, intensity int64, gain_db String.Readable, other_intensity int64, other_gain_db String.Readable) { //gd:Steam.triggerSimpleHapticEvent
	var frame = callframe.New()
	callframe.Arg(frame, input_handle)
	callframe.Arg(frame, haptic_location)
	callframe.Arg(frame, intensity)
	callframe.Arg(frame, pointers.Get(gd.InternalString(gain_db)))
	callframe.Arg(frame, other_intensity)
	callframe.Arg(frame, pointers.Get(gd.InternalString(other_gain_db)))
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_triggerSimpleHapticEvent, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Returns a localized string (from Steam's language setting) for the specified Xbox controller origin.
*/
//go:nosplit
func (self class) GetStringForXboxOrigin(origin int64) String.Readable { //gd:Steam.getStringForXboxOrigin
	var frame = callframe.New()
	callframe.Arg(frame, origin)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getStringForXboxOrigin, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Get a local path to art for on-screen glyph for a particular Xbox controller origin.
*/
//go:nosplit
func (self class) GetGlyphForXboxOrigin(origin int64) String.Readable { //gd:Steam.getGlyphForXboxOrigin
	var frame = callframe.New()
	callframe.Arg(frame, origin)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getGlyphForXboxOrigin, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Get a bitmask of the Steam Input Configuration types opted in for the current session. Returns InputConfigurationEnableType values.
[b]Note:[/b] user can override the settings from the Steamworks Partner site so the returned values may not exactly match your default configuration.
*/
//go:nosplit
func (self class) GetSessionInputConfigurationSettings() int64 { //gd:Steam.getSessionInputConfigurationSettings
	var frame = callframe.New()
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getSessionInputConfigurationSettings, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns a localized string (from Steam's language setting) for the user-facing action name corresponding to the specified handle.
*/
//go:nosplit
func (self class) GetStringForDigitalActionName(action_handle int64) String.Readable { //gd:Steam.getStringForDigitalActionName
	var frame = callframe.New()
	callframe.Arg(frame, action_handle)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getStringForDigitalActionName, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Returns a localized string (from Steam's language setting) for the user-facing action name corresponding to the specified handle.
*/
//go:nosplit
func (self class) GetStringForAnalogActionName(action_handle int64) String.Readable { //gd:Steam.getStringForAnalogActionName
	var frame = callframe.New()
	callframe.Arg(frame, action_handle)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getStringForAnalogActionName, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Grant a specific one-time promotional item to the current user.
This can be safely called from the client because the items it can grant can be locked down via policies in the itemdefs. One of the primary scenarios for this call is to grant an item to users who also own a specific other game. This can be useful if your game has custom UI for showing a specific promo item to the user otherwise if you want to grant multiple promotional items then use [method Steam.addPromoItems] or [method Steam.grantPromoItems].
Any items that can be granted must have a "promo" attribute in their itemdef. That promo item list a set of app IDs that the user must own to be granted this given item. This version will grant all items that have promo attributes specified for them in the configured item definitions. This allows adding additional promotional items without having to update the game client. For example the following will allow the item to be granted if the user owns either TF2 or SpaceWar.
The inventory handle, which is also stored internally. It will overwrite any previously stored inventory handle.
*/
//go:nosplit
func (self class) AddPromoItem(item int64) int64 { //gd:Steam.addPromoItem
	var frame = callframe.New()
	callframe.Arg(frame, item)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_addPromoItem, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Grant a specific one-time promotional item to the current user.
This can be safely called from the client because the items it can grant can be locked down via policies in the itemdefs. One of the primary scenarios for this call is to grant an item to users who also own a specific other game. If you want to grant a single promotional item then use [method Steam.addPromoItems]. If you want to grant all possible promo items then use [method Steam.grantPromoItems].
Any items that can be granted must have a "promo" attribute in their itemdef. That promo item list a set of app ID's that the user must own to be granted this given item. This version will grant all items that have promo attributes specified for them in the configured item definitions. This allows adding additional promotional items without having to update the game client. For example the following will allow the item to be granted if the user owns either TF2 or SpaceWar.
The inventory handle, which is also stored internally. It will overwrite any previously stored inventory handle.
*/
//go:nosplit
func (self class) AddPromoItems(items Packed.Array[int64]) int64 { //gd:Steam.addPromoItems
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalPacked[gd.PackedInt64Array, int64](items)))
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_addPromoItems, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Checks whether an inventory result handle belongs to the specified Steam ID. This is important when using [method Steam.deserializeResult], to verify that a remote player is not pretending to have a different user's inventory.
[b]Note:[/b] If the argument this_inventory_handle is omitted, GodotSteam will use the internally stored ID.
*/
//go:nosplit
func (self class) CheckResultSteamID(steam_id_expected int64, this_inventory_handle int64) bool { //gd:Steam.checkResultSteamID
	var frame = callframe.New()
	callframe.Arg(frame, steam_id_expected)
	callframe.Arg(frame, this_inventory_handle)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_checkResultSteamID, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Consumes items from a user's inventory. If the quantity of the given item goes to zero, it is permanently removed.
Once an item is removed it cannot be recovered. This is not for the faint of heart - if your game implements item removal at all, a high-friction UI confirmation process is highly recommended.
The inventory handle, which is also stored internally. It will overwrite any previously stored inventory handle.
[b]Note:[/b] You must call [method Steam.destroyResult] on the provided inventory result when you are done with it.
*/
//go:nosplit
func (self class) ConsumeItem(item_consume int64, quantity int64) int64 { //gd:Steam.consumeItem
	var frame = callframe.New()
	callframe.Arg(frame, item_consume)
	callframe.Arg(frame, quantity)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_consumeItem, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Deserializes a result set and verifies the signature bytes.
This call has a potential soft-failure mode where the handle status is set to 27. [method Steam.getResultItems] will still succeed in this mode. The "expired" result could indicate that the data may be out of date - not just due to timed expiration (one hour), but also because one of the items in the result set may have been traded or consumed since the result set was generated. You could compare the timestamp from [method Steam.getResultTimestamp] to [method Steam.getServerRealTime] to determine how old the data is. You could simply ignore the "expired" result code and continue as normal, or you could request the player with expired data to send an updated result set.
You should call [method Steam.checkResultSteamID] on the result handle when it completes to verify that a remote player is not pretending to have a different user's inventory.
The inventory handle, which is also stored internally. It will overwrite any previously stored inventory handle.
*/
//go:nosplit
func (self class) DeserializeResult(buffer Packed.Bytes) int64 { //gd:Steam.deserializeResult
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalPacked[gd.PackedByteArray, byte](Packed.Array[byte](buffer))))
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_deserializeResult, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Destroys a result handle and frees all associated memory.
[b]Note:[/b] If the argument this_inventory_handle is omitted, GodotSteam will use the internally stored ID.
*/
//go:nosplit
func (self class) DestroyResult(this_inventory_handle int64) { //gd:Steam.destroyResult
	var frame = callframe.New()
	callframe.Arg(frame, this_inventory_handle)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_destroyResult, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Grant one item in exchange for a set of other items.
This can be used to implement crafting recipes or transmutations, or items which unpack themselves into other items (e.g., a chest).
The caller of this API passes in the requested item and an array of existing items and quantities to exchange for it. The API currently takes an array of items to generate but at this time the size of that array must be 1 and the quantity of the new item must be 1.
Any items that can be granted must have an exchange attribute in their itemdef. The exchange attribute specifies a set of recipes that are valid exchanges for this item. Exchange recipes are evaluated atomically by the Inventory Service; if the supplied components do not match the recipe, or do not contain sufficient quantity, the exchange will fail.
Will allow the item to be exchanged for either one #101 and one #102, five #103s or three #104s and three #105s. See the Steam Inventory Schema documentation for more details.
The inventory handle, which is also stored internally. It will overwrite any previously stored inventory handle.
[b]Note:[/b] You must call [method Steam.destroyResult] on the provided inventory result when you are done with it.
*/
//go:nosplit
func (self class) ExchangeItems(output_items Packed.Array[int64], output_quantity Packed.Array[int32], input_items Packed.Array[int64], input_quantity Packed.Array[int32]) int64 { //gd:Steam.exchangeItems
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalPacked[gd.PackedInt64Array, int64](output_items)))
	callframe.Arg(frame, pointers.Get(gd.InternalPacked[gd.PackedInt32Array, int32](output_quantity)))
	callframe.Arg(frame, pointers.Get(gd.InternalPacked[gd.PackedInt64Array, int64](input_items)))
	callframe.Arg(frame, pointers.Get(gd.InternalPacked[gd.PackedInt32Array, int32](input_quantity)))
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_exchangeItems, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Grants specific items to the current user, for developers only.
This API is only intended for prototyping - it is only usable by Steam accounts that belong to the publisher group for your game.
You can pass in an array of items, identified by their item definition int's and optionally a second array of corresponding quantities for each item. The length of these arrays must match!
The inventory handle, which is also stored internally. It will overwrite any previously stored inventory handle.
[b]Note:[/b] You must call [method Steam.destroyResult] on the provided inventory result when you are done with it.
*/
//go:nosplit
func (self class) GenerateItems(items Packed.Array[int64], quantity Packed.Array[int32]) int64 { //gd:Steam.generateItems
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalPacked[gd.PackedInt64Array, int64](items)))
	callframe.Arg(frame, pointers.Get(gd.InternalPacked[gd.PackedInt32Array, int32](quantity)))
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_generateItems, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Start retrieving all items in the current users inventory.
The inventory handle, which is also stored internally. It will overwrite any previously stored inventory handle.
[b]Note:[/b] Calls to this function are subject to rate limits and may return cached results if called too frequently. It is suggested that you call this function only when you are about to display the user's full inventory, or if you expect that the inventory may have changed.
[b]Note:[/b] You must call [method Steam.destroyResult] on the provided inventory result when you are done with it.
*/
//go:nosplit
func (self class) GetAllItems() int64 { //gd:Steam.getAllItems
	var frame = callframe.New()
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getAllItems, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Gets a string property from the specified item definition. Gets a property value for a specific item definition.
Note that some properties (for example, "name") may be localized and will depend on the current Steam language settings; see [method Steam.getCurrentGameLanguage]. Property names are always ASCII alphanumeric and underscores.
Pass in NULL for name to get a comma-separated list of available property names.
[b]Note:[/b] Call [method Steam.loadItemDefinitions] first, to ensure that items are ready to be used before calling [method Steam.getItemDefinitionProperty].
*/
//go:nosplit
func (self class) GetItemDefinitionProperty(definition int64, name String.Readable) String.Readable { //gd:Steam.getItemDefinitionProperty
	var frame = callframe.New()
	callframe.Arg(frame, definition)
	callframe.Arg(frame, pointers.Get(gd.InternalString(name)))
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getItemDefinitionProperty, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Gets the state of a subset of the current user's inventory.
The subset is specified by an array of item instance IDs.
The results from this call can be serialized using [method Steam.serializeResult] and passed to other players to "prove" that the current user owns specific items, without exposing the user's entire inventory. For example, you could call this with the IDs of the user's currently equipped items and serialize this to a buffer, and then transmit this buffer to other players upon joining a game.
The inventory handle, which is also stored internally. It will overwrite any previously stored inventory handle.
[b]Note:[/b] You must call [method Steam.destroyResult] on the provided inventory result when you are done with it.
*/
//go:nosplit
func (self class) GetItemsByID(id_array Packed.Array[int64]) int64 { //gd:Steam.getItemsByID
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalPacked[gd.PackedInt64Array, int64](id_array)))
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getItemsByID, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
After a successful call to [method Steam.requestPrices], you can call this method to get the pricing for a specific item definition.
The returned dictionary contains the following keys:
[codeblock]
┠╴price (int)
┖╴base_price (int)
[/codeblock]
*/
//go:nosplit
func (self class) GetItemPrice(definition int64) Dictionary.Any { //gd:Steam.getItemPrice
	var frame = callframe.New()
	callframe.Arg(frame, definition)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getItemPrice, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
After a successful call to [method Steam.requestPrices], you can call this method to get all the pricing for applicable item definitions.
*/
//go:nosplit
func (self class) GetItemsWithPrices() Array.Any { //gd:Steam.getItemsWithPrices
	var frame = callframe.New()
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getItemsWithPrices, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Array.Through(gd.ArrayProxy[variant.Any]{}, pointers.Pack(pointers.New[gd.Array](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Gets the dynamic properties from an item in an inventory result set.
Property names are always composed of ASCII letters, numbers, and/or underscores.
If the results do not fit in the given buffer, partial results may be copied.
[b]Note:[/b] If the argument this_inventory_handle is omitted, GodotSteam will use the internally stored ID.
*/
//go:nosplit
func (self class) GetResultItemProperty(index int64, name String.Readable, this_inventory_handle int64) String.Readable { //gd:Steam.getResultItemProperty
	var frame = callframe.New()
	callframe.Arg(frame, index)
	callframe.Arg(frame, pointers.Get(gd.InternalString(name)))
	callframe.Arg(frame, this_inventory_handle)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getResultItemProperty, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Get the items associated with an inventory result handle.
The returned array contains a list of dictionaries which contain the following keys:
[codeblock]
┠╴item_id (int)
┠╴item_definition (int)
┠╴flags (int)
┖╴quantity (int)
[/codeblock]
[b]Note:[/b] If the argument this_inventory_handle is omitted, GodotSteam will use the internally stored ID.
*/
//go:nosplit
func (self class) GetResultItems(this_inventory_handle int64) Array.Any { //gd:Steam.getResultItems
	var frame = callframe.New()
	callframe.Arg(frame, this_inventory_handle)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getResultItems, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Array.Through(gd.ArrayProxy[variant.Any]{}, pointers.Pack(pointers.New[gd.Array](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Find out the status of an asynchronous inventory result handle. This is a polling equivalent to registering a callback function for [signal Steam.inventory_result_ready].
[b]Note:[/b] If the argument this_inventory_handle is omitted, GodotSteam will use the internally stored ID.
*/
//go:nosplit
func (self class) GetResultStatus(this_inventory_handle int64) Result { //gd:Steam.getResultStatus
	var frame = callframe.New()
	callframe.Arg(frame, this_inventory_handle)
	var r_ret = callframe.Ret[Result](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getResultStatus, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Gets the server time at which the result was generated.
You can compare this value against getServerRealTime to determine the age of the result.
[b]Note:[/b] If the argument this_inventory_handle is omitted, GodotSteam will use the internally stored ID.
*/
//go:nosplit
func (self class) GetResultTimestamp(this_inventory_handle int64) int64 { //gd:Steam.getResultTimestamp
	var frame = callframe.New()
	callframe.Arg(frame, this_inventory_handle)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getResultTimestamp, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Grant all potential one-time promotional items to the current user.
This can be safely called from the client because the items it can grant can be locked down via policies in the itemdefs. One of the primary scenarios for this call is to grant an item to users who also own a specific other game. If you want to grant specific promotional items rather than all of them see: [method Steam.addPromoItem] and [method Steam.addPromoItems].
Any items that can be granted must have a "promo" attribute in their itemdef. That promo item list a set of app ID's that the user must own to be granted this given item. This version will grant all items that have promo attributes specified for them in the configured item definitions. This allows adding additional promotional items without having to update the game client. For example the following will allow the item to be granted if the user owns either TF2 or SpaceWar.
The inventory handle, which is also stored internally. It will overwrite any previously stored inventory handle.
[b]Note:[/b] You must call [method Steam.destroyResult] on the provided inventory result when you are done with it.
*/
//go:nosplit
func (self class) GrantPromoItems() int64 { //gd:Steam.grantPromoItems
	var frame = callframe.New()
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_grantPromoItems, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Triggers an asynchronous load and refresh of item definitions.
Item definitions are a mapping of "definition IDs" (integers between 1 and 999999999) to a set of string properties. Some of these properties are required to display items on the Steam community web site. Other properties can be defined by applications. There is no reason to call this function if your game hardcoded the numeric definition IDs (e.g. purple face mask = 20, blue weapon mod = 55) and does not allow for adding new item types without a client patch.
Triggers a [signal Steam.inventory_definition_update] callback.
*/
//go:nosplit
func (self class) LoadItemDefinitions() bool { //gd:Steam.loadItemDefinitions
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_loadItemDefinitions, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Request the list of "eligible" promo items that can be manually granted to the given user.
These are promo items of type "manual" that won't be granted automatically. An example usage of this is an item that becomes available every week.
Triggers a [signal Steam.inventory_eligible_promo_item] callback.
*/
//go:nosplit
func (self class) RequestEligiblePromoItemDefinitionsIDs(steam_id int64) { //gd:Steam.requestEligiblePromoItemDefinitionsIDs
	var frame = callframe.New()
	callframe.Arg(frame, steam_id)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_requestEligiblePromoItemDefinitionsIDs, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Request prices for all item definitions that can be purchased in the user's local currency. A [signal Steam.inventory_request_prices_result] call result will be returned with the user's local currency code.
Triggers a [signal Steam.inventory_request_prices_result] callback.
*/
//go:nosplit
func (self class) RequestPrices() { //gd:Steam.requestPrices
	var frame = callframe.New()
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_requestPrices, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Serialized result sets contain a short signature which can't be forged or replayed across different game sessions.
A result set can be serialized on the local client, transmitted to other players via your game networking, and deserialized by the remote players. This is a secure way of preventing hackers from lying about possessing rare/high-value items. Serializes a result set with signature bytes to an output buffer. The size of a serialized result depends on the number items which are being serialized. When securely transmitting items to other players, it is recommended to use [method Steam.getItemsByID] first to create a minimal result set.
[b]Note:[/b] If the argument this_inventory_handle is omitted, GodotSteam will use the internally stored ID.
Results have a built-in timestamp which will be considered "expired" after an hour has elapsed. See [method Steam.deserializeResult] for expiration handling.
*/
//go:nosplit
func (self class) SerializeResult(this_inventory_handle int64) Packed.Bytes { //gd:Steam.serializeResult
	var frame = callframe.New()
	callframe.Arg(frame, this_inventory_handle)
	var r_ret = callframe.Ret[gd.PackedPointers](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_serializeResult, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Packed.Bytes(Array.Through(gd.PackedProxy[gd.PackedByteArray, byte]{}, pointers.Pack(pointers.New[gd.PackedByteArray](r_ret.Get()))))
	frame.Free()
	return ret
}

/*
Starts the purchase process for the user, given a "shopping cart" of item definitions that the user would like to buy. The user will be prompted in the Steam Overlay to complete the purchase in their local currency, funding their Steam Wallet if necessary, etc.
If the purchase process was started successfully, then order_id and transaction_id will be valid in the [signal Steam.inventory_start_purchase_result] call result.
If the user authorizes the transaction and completes the purchase, then the callback [signal Steam.inventory_result_ready] will be triggered and you can then retrieve what new items the user has acquired.
Triggers a [signal Steam.inventory_start_purchase_result] callback.
[b]Note:[/b] You must call [method Steam.destroyResult] on the inventory result for when you are done with it.
*/
//go:nosplit
func (self class) StartPurchase(items Packed.Array[int64], quantity Packed.Array[int32]) { //gd:Steam.startPurchase
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalPacked[gd.PackedInt64Array, int64](items)))
	callframe.Arg(frame, pointers.Get(gd.InternalPacked[gd.PackedInt32Array, int32](quantity)))
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_startPurchase, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Transfer items between stacks within a user's inventory.
This can be used to stack, split, and moving items. The source and destination items must have the same itemdef id. To move items onto a destination stack specify the source, the quantity to move, and the destination item id. To split an existing stack, pass -1 into item_destination. A new item stack will be generated with the requested quantity.
The inventory handle, which is also stored internally. It will overwrite any previously stored inventory handle.
[b]Note:[/b] Tradability/marketability restrictions are copied along with transferred items. The destination stack receives the latest tradability/marketability date of any item in its composition.
*/
//go:nosplit
func (self class) TransferItemQuantity(item_id int64, quantity int64, item_destination int64, split bool) int64 { //gd:Steam.transferItemQuantity
	var frame = callframe.New()
	callframe.Arg(frame, item_id)
	callframe.Arg(frame, quantity)
	callframe.Arg(frame, item_destination)
	callframe.Arg(frame, split)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_transferItemQuantity, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Trigger an item drop if the user has played a long enough period of time.
This period can be customized in two places:
At the application level within Inventory Service: Playtime Item Grants. This will automatically apply to all "playtimegenerator" items that do not specify any overrides.
In an individual "playtimegenerator" item definition. The settings would take precedence over any application-level settings.
Only item definitions which are marked as "playtime item generators" can be spawned. Typically this function should be called at the end of a game or level or match or any point of significance in the game in which an item drop could occur. The granularity of the playtime generator settings is in minutes, so calling it more frequently than minutes is not useful and will be rate limited in the Steam client. The Steam servers will perform playtime accounting to prevent too-frequent drops. The servers will also manage adding the item to the players inventory.
The inventory handle, which is also stored internally. It will overwrite any previously stored inventory handle.
*/
//go:nosplit
func (self class) TriggerItemDrop(definition int64) int64 { //gd:Steam.triggerItemDrop
	var frame = callframe.New()
	callframe.Arg(frame, definition)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_triggerItemDrop, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Starts a transaction request to update dynamic properties on items for the current user. This call is rate-limited by user, so property modifications should be batched as much as possible (e.g. at the end of a map or game session). After calling [method Steam.setPropertyBool] or [method Steam.setPropertyFloat] or [method Steam.setPropertyInt] or [method Steam.setPropertyString] or [method Steam.removeProperty] for all the items that you want to modify, you will need to call [method Steam.submitUpdateProperties] to send the request to the Steam servers. A [signal Steam.inventory_result_ready] callback will be fired with the results of the operation.
*/
//go:nosplit
func (self class) StartUpdateProperties() { //gd:Steam.startUpdateProperties
	var frame = callframe.New()
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_startUpdateProperties, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Submits the transaction request to modify dynamic properties on items for the current user. See [method Steam.startUpdateProperties].
The inventory handle, which is also stored internally. It will overwrite any previously stored inventory handle.
[b]Note:[/b] You must call [method Steam.destroyResult] on the provided inventory result for when you are done with it.
*/
//go:nosplit
func (self class) SubmitUpdateProperties(this_inventory_update_handle int64) int64 { //gd:Steam.submitUpdateProperties
	var frame = callframe.New()
	callframe.Arg(frame, this_inventory_update_handle)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_submitUpdateProperties, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Removes a dynamic property for the given item.
[b]Note:[/b] If the argument this_inventory_update_handle is omitted, GodotSteam will use the internally stored ID. This is different from this_inventory_handle and is stored separately.
*/
//go:nosplit
func (self class) RemoveProperty(item_id int64, name String.Readable, this_inventory_update_handle int64) bool { //gd:Steam.removeProperty
	var frame = callframe.New()
	callframe.Arg(frame, item_id)
	callframe.Arg(frame, pointers.Get(gd.InternalString(name)))
	callframe.Arg(frame, this_inventory_update_handle)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_removeProperty, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Sets a dynamic property for the given item. Supported value types are strings.
[b]Note:[/b] If the argument this_inventory_update_handle is omitted, GodotSteam will use the internally stored ID. This is different from this_inventory_handle and is stored separately.
*/
//go:nosplit
func (self class) SetPropertyString(item_id int64, name String.Readable, value String.Readable, this_inventory_update_handle int64) bool { //gd:Steam.setPropertyString
	var frame = callframe.New()
	callframe.Arg(frame, item_id)
	callframe.Arg(frame, pointers.Get(gd.InternalString(name)))
	callframe.Arg(frame, pointers.Get(gd.InternalString(value)))
	callframe.Arg(frame, this_inventory_update_handle)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setPropertyString, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Sets a dynamic property for the given item. Supported value types are boolean.
[b]Note:[/b] If the argument this_inventory_update_handle is omitted, GodotSteam will use the internally stored ID. This is different from this_inventory_handle and is stored separately.
*/
//go:nosplit
func (self class) SetPropertyBool(item_id int64, name String.Readable, value bool, this_inventory_update_handle int64) bool { //gd:Steam.setPropertyBool
	var frame = callframe.New()
	callframe.Arg(frame, item_id)
	callframe.Arg(frame, pointers.Get(gd.InternalString(name)))
	callframe.Arg(frame, value)
	callframe.Arg(frame, this_inventory_update_handle)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setPropertyBool, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Sets a dynamic property for the given item. Supported value types are 64 bit integers.
[b]Note:[/b] If the argument this_inventory_update_handle is omitted, GodotSteam will use the internally stored ID. This is different from this_inventory_handle and is stored separately.
*/
//go:nosplit
func (self class) SetPropertyInt(item_id int64, name String.Readable, value int64, this_inventory_update_handle int64) bool { //gd:Steam.setPropertyInt
	var frame = callframe.New()
	callframe.Arg(frame, item_id)
	callframe.Arg(frame, pointers.Get(gd.InternalString(name)))
	callframe.Arg(frame, value)
	callframe.Arg(frame, this_inventory_update_handle)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setPropertyInt, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Sets a dynamic property for the given item. Supported value types are 32 bit floats.
[b]Note:[/b] If the argument this_inventory_update_handle is omitted, GodotSteam will use the internally stored ID. Also note this different from this_inventory_handle and is stored separately.
*/
//go:nosplit
func (self class) SetPropertyFloat(item_id int64, name String.Readable, value float64, this_inventory_update_handle int64) bool { //gd:Steam.setPropertyFloat
	var frame = callframe.New()
	callframe.Arg(frame, item_id)
	callframe.Arg(frame, pointers.Get(gd.InternalString(name)))
	callframe.Arg(frame, value)
	callframe.Arg(frame, this_inventory_update_handle)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setPropertyFloat, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Gets the details of the favorite game server by index.
The returned array contains a list of:
[codeblock]
┖╴favorite (dictionary)
    ┠╴ret (bool)
    ┠╴app (int)
    ┠╴ip (string)
    ┠╴game_port (int)
    ┠╴query_port (int)
    ┠╴flags (int)
    ┖╴last_played (int)
[/codeblock]
*/
//go:nosplit
func (self class) GetFavoriteGames() Array.Any { //gd:Steam.getFavoriteGames
	var frame = callframe.New()
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getFavoriteGames, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Array.Through(gd.ArrayProxy[variant.Any]{}, pointers.Pack(pointers.New[gd.Array](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Adds the game server to the local list; updates the time played of the server if it already exists in the list.
*/
//go:nosplit
func (self class) AddFavoriteGame(ip String.Readable, port int64, query_port int64, flags int64, last_played int64) int64 { //gd:Steam.addFavoriteGame
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(ip)))
	callframe.Arg(frame, port)
	callframe.Arg(frame, query_port)
	callframe.Arg(frame, flags)
	callframe.Arg(frame, last_played)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_addFavoriteGame, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Removes the game server from the local favorites list.
*/
//go:nosplit
func (self class) RemoveFavoriteGame(app_id int64, ip String.Readable, port int64, query_port int64, flags int64) bool { //gd:Steam.removeFavoriteGame
	var frame = callframe.New()
	callframe.Arg(frame, app_id)
	callframe.Arg(frame, pointers.Get(gd.InternalString(ip)))
	callframe.Arg(frame, port)
	callframe.Arg(frame, query_port)
	callframe.Arg(frame, flags)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_removeFavoriteGame, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Get a filtered list of relevant lobbies.
There can only be one active lobby search at a time. The old request will be canceled if a new one is started. Depending on the users connection to the Steam back-end, this call can take from 300ms to 5 seconds to complete, and has a timeout of 20 seconds.
Triggers a [signal Steam.lobby_match_list] callback.
[b]Note:[/b] To filter the results you must call the addRequestLobbyList functions before calling this. The filters are cleared on each call to this function.
[b]Note:[/b] If [method Steam.addRequestLobbyListDistanceFilter] is not called, k_ELobbyDistanceFilterDefault will be used, which will only find matches in the same or nearby regions.
[b]Note:[/b] This will only return lobbies that are not full, and only lobbies that are public (2) or invisible (3), and are set to joinable with [method Steam.setLobbyJoinable].
*/
//go:nosplit
func (self class) RequestLobbyList() { //gd:Steam.requestLobbyList
	var frame = callframe.New()
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_requestLobbyList, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Adds a string comparison filter to the next [method Steam.requestLobbyList] call.
*/
//go:nosplit
func (self class) AddRequestLobbyListStringFilter(key_to_match String.Readable, value_to_match String.Readable, comparison_type LobbyComparison) { //gd:Steam.addRequestLobbyListStringFilter
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(key_to_match)))
	callframe.Arg(frame, pointers.Get(gd.InternalString(value_to_match)))
	callframe.Arg(frame, comparison_type)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_addRequestLobbyListStringFilter, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Adds a numerical comparison filter to the next [method Steam.requestLobbyList] call.
*/
//go:nosplit
func (self class) AddRequestLobbyListNumericalFilter(key_to_match String.Readable, value_to_match int64, comparison_type LobbyComparison) { //gd:Steam.addRequestLobbyListNumericalFilter
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(key_to_match)))
	callframe.Arg(frame, value_to_match)
	callframe.Arg(frame, comparison_type)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_addRequestLobbyListNumericalFilter, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Sorts the results closest to the specified value
Near filters don't actually filter out values, they just influence how the results are sorted. You can specify multiple near filters, with the first near filter influencing the most, and the last near filter influencing the least.
*/
//go:nosplit
func (self class) AddRequestLobbyListNearValueFilter(key_to_match String.Readable, value_to_be_close_to int64) { //gd:Steam.addRequestLobbyListNearValueFilter
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(key_to_match)))
	callframe.Arg(frame, value_to_be_close_to)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_addRequestLobbyListNearValueFilter, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Filters to only return lobbies with the specified number of open slots available.
*/
//go:nosplit
func (self class) AddRequestLobbyListFilterSlotsAvailable(slots_available int64) { //gd:Steam.addRequestLobbyListFilterSlotsAvailable
	var frame = callframe.New()
	callframe.Arg(frame, slots_available)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_addRequestLobbyListFilterSlotsAvailable, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Sets the physical distance for which we should search for lobbies, this is based on the users IP address and a IP location map on the Steam backed.
*/
//go:nosplit
func (self class) AddRequestLobbyListDistanceFilter(distance_filter LobbyDistanceFilter) { //gd:Steam.addRequestLobbyListDistanceFilter
	var frame = callframe.New()
	callframe.Arg(frame, distance_filter)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_addRequestLobbyListDistanceFilter, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Sets the maximum number of lobbies to return. The lower the count the faster it is to download the lobby results and details to the client.
*/
//go:nosplit
func (self class) AddRequestLobbyListResultCountFilter(max_results int64) { //gd:Steam.addRequestLobbyListResultCountFilter
	var frame = callframe.New()
	callframe.Arg(frame, max_results)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_addRequestLobbyListResultCountFilter, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Create a new matchmaking lobby.
Triggers all three callbacks: [signal Steam.lobby_created], [signal Steam.lobby_joined], and [signal Steam.lobby_data_update].
If the results returned via the [signal Steam.lobby_created] call result indicate success then the lobby is joined and ready to use at this point.
*/
//go:nosplit
func (self class) CreateLobby(lobby_type LobbyType, max_members int64) { //gd:Steam.createLobby
	var frame = callframe.New()
	callframe.Arg(frame, lobby_type)
	callframe.Arg(frame, max_members)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_createLobby, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Joins an existing lobby.
The lobby Steam ID can be obtained either from a search with [method Steam.requestLobbyList] joining on a friend, or from an invite.
Triggers a [signal Steam.lobby_joined] callback for other users.
*/
//go:nosplit
func (self class) JoinLobby(steam_lobby_id int64) { //gd:Steam.joinLobby
	var frame = callframe.New()
	callframe.Arg(frame, steam_lobby_id)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_joinLobby, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Leave a lobby that the user is currently in; this will take effect immediately on the client side, other users in the lobby will be notified by a [signal Steam.lobby_chat_update] callback.
*/
//go:nosplit
func (self class) LeaveLobby(steam_lobby_id int64) { //gd:Steam.leaveLobby
	var frame = callframe.New()
	callframe.Arg(frame, steam_lobby_id)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_leaveLobby, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Invite another user to the lobby.
If the specified user clicks the join link, a join_requested callback will be posted if the user is in-game, or if the game isn't running yet then the game will be automatically launched with the command line parameter +connect_lobby (64-bit lobby Steam ID) instead.
*/
//go:nosplit
func (self class) InviteUserToLobby(steam_lobby_id int64, steam_id_invitee int64) bool { //gd:Steam.inviteUserToLobby
	var frame = callframe.New()
	callframe.Arg(frame, steam_lobby_id)
	callframe.Arg(frame, steam_id_invitee)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_inviteUserToLobby, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Gets the number of users in a lobby.
This is used for iteration, after calling this then [method Steam.getLobbyMemberByIndex] can be used to get the Steam ID of each person in the lobby. Persona information for other lobby members (name, avatar, etc.) is automatically received and accessible via the SteamFriends interface.
[b]Note:[/b] The current user must be in the lobby to retrieve the Steam IDs of other users in that lobby.
*/
//go:nosplit
func (self class) GetNumLobbyMembers(steam_lobby_id int64) int64 { //gd:Steam.getNumLobbyMembers
	var frame = callframe.New()
	callframe.Arg(frame, steam_lobby_id)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getNumLobbyMembers, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Gets the Steam ID of the lobby member at the given index.
[b]Note:[/b] You must call [method Steam.getNumLobbyMembers] before calling this.
[b]Note:[/b] The current user must be in the lobby to retrieve the Steam IDs of other users in that lobby.
*/
//go:nosplit
func (self class) GetLobbyMemberByIndex(steam_lobby_id int64, member int64) int64 { //gd:Steam.getLobbyMemberByIndex
	var frame = callframe.New()
	callframe.Arg(frame, steam_lobby_id)
	callframe.Arg(frame, member)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getLobbyMemberByIndex, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Gets the metadata associated with the specified key from the specified lobby.
Returns an empty string if no value is set for this key, or if steam_lobby_id is invalid.
[b]Note:[/b] This can only get metadata from lobbies that the client knows about, either after receiving a list of lobbies from [signal Steam.lobby_match_list], retrieving the data with [method Steam.requestLobbyData] or after joining a lobby.
*/
//go:nosplit
func (self class) GetLobbyData(steam_lobby_id int64, key String.Readable) String.Readable { //gd:Steam.getLobbyData
	var frame = callframe.New()
	callframe.Arg(frame, steam_lobby_id)
	callframe.Arg(frame, pointers.Get(gd.InternalString(key)))
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getLobbyData, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Sets a key/value pair in the lobby metadata. This can be used to set the the lobby name, current map, game mode, etc.
This can only be set by the owner of the lobby. Lobby members should use [method Steam.setLobbyMemberData] instead.
Each user in the lobby will be receive notification of the lobby data change via a [signal Steam.lobby_data_update] callback, and any new users joining will receive any existing data.
This will only send the data if it has changed. There is a slight delay before sending the data so you can call this repeatedly to set all the data you need to and it will automatically be batched up and sent after the last sequential call.
True if the data has been set successfully. False if steam_lobby_id was invalid, or the key/value are too long.
*/
//go:nosplit
func (self class) SetLobbyData(steam_lobby_id int64, key String.Readable, value String.Readable) bool { //gd:Steam.setLobbyData
	var frame = callframe.New()
	callframe.Arg(frame, steam_lobby_id)
	callframe.Arg(frame, pointers.Get(gd.InternalString(key)))
	callframe.Arg(frame, pointers.Get(gd.InternalString(value)))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setLobbyData, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Get lobby data by the lobby's ID.
The returned dictionary contains the following keys: [b]index (int), key (string), and value (string).[/b]
[b]Note:[/b] This is a GodotSteam specific function.
*/
//go:nosplit
func (self class) GetAllLobbyData(steam_lobby_id int64) Dictionary.Any { //gd:Steam.getAllLobbyData
	var frame = callframe.New()
	callframe.Arg(frame, steam_lobby_id)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getAllLobbyData, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Removes a metadata key from the lobby.
This can only be done by the owner of the lobby.
This will only send the data if the key existed. There is a slight delay before sending the data so you can call this repeatedly to set all the data you need to and it will automatically be batched up and sent after the last sequential call.
*/
//go:nosplit
func (self class) DeleteLobbyData(steam_lobby_id int64, key String.Readable) bool { //gd:Steam.deleteLobbyData
	var frame = callframe.New()
	callframe.Arg(frame, steam_lobby_id)
	callframe.Arg(frame, pointers.Get(gd.InternalString(key)))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_deleteLobbyData, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Gets per-user metadata from another player in the specified lobby.
This can only be queried from members in lobbies that you are currently in.
Returns NULL if steam_lobby_id is invalid, or steam_user_id is not in the lobby. Returns an empty string if key is not set for the player.
*/
//go:nosplit
func (self class) GetLobbyMemberData(steam_lobby_id int64, steam_id_user int64, key String.Readable) String.Readable { //gd:Steam.getLobbyMemberData
	var frame = callframe.New()
	callframe.Arg(frame, steam_lobby_id)
	callframe.Arg(frame, steam_id_user)
	callframe.Arg(frame, pointers.Get(gd.InternalString(key)))
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getLobbyMemberData, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Sets per-user metadata for the local user.
Each user in the lobby will be receive notification of the lobby data change via a [signal Steam.lobby_data_update] callback, and any new users joining will receive any existing data.
There is a slight delay before sending the data so you can call this repeatedly to set all the data you need to and it will automatically be batched up and sent after the last sequential call.
Triggers a [signal Steam.lobby_data_update] callback.
*/
//go:nosplit
func (self class) SetLobbyMemberData(steam_lobby_id int64, key String.Readable, value String.Readable) { //gd:Steam.setLobbyMemberData
	var frame = callframe.New()
	callframe.Arg(frame, steam_lobby_id)
	callframe.Arg(frame, pointers.Get(gd.InternalString(key)))
	callframe.Arg(frame, pointers.Get(gd.InternalString(value)))
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setLobbyMemberData, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Broadcasts a chat (text or binary data) message to the all of the users in the lobby. All users in the lobby (including the local user) will receive a [signal Steam.lobby_message] callback with the message.
For communication that needs to be arbitrated (for example having a user pick from a set of characters, and making sure only one user has picked a character), you can use the lobby owner as the decision maker. [method Steam.getLobbyOwner] returns the current lobby owner. There is guaranteed to always be one and only one lobby member who is the owner. So for the choose-a-character scenario, the user who is picking a character would send the binary message 'I want to be Zoe', the lobby owner would see that message, see if it was OK, and broadcast the appropriate result (user X is Zoe).
These messages are sent via the Steam back-end, and so the bandwidth available is limited. For higher-volume traffic like voice or game data, you'll want to use the Steam Networking API.
Triggers a [signal Steam.lobby_message] callback.
*/
//go:nosplit
func (self class) SendLobbyChatMsg(steam_lobby_id int64, message_body String.Readable) bool { //gd:Steam.sendLobbyChatMsg
	var frame = callframe.New()
	callframe.Arg(frame, steam_lobby_id)
	callframe.Arg(frame, pointers.Get(gd.InternalString(message_body)))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_sendLobbyChatMsg, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Refreshes all of the metadata for a lobby that you're not in right now.
You will never do this for lobbies you're a member of, that data will always be up to date. You can use this to refresh lobbies that you have obtained from [method Steam.requestLobbyList] or that are available via friends.
Triggers a [signal Steam.lobby_data_update] callback.
True if the request was successfully sent to the server. False if no connection to Steam could be made, or steam_lobby_id is invalid.
*/
//go:nosplit
func (self class) RequestLobbyData(steam_lobby_id int64) bool { //gd:Steam.requestLobbyData
	var frame = callframe.New()
	callframe.Arg(frame, steam_lobby_id)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_requestLobbyData, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Sets the game server associated with the lobby.
This can only be set by the owner of the lobby.
Either the IP/Port or the Steam ID of the game server must be valid, depending on how you want the clients to be able to connect.
A [signal Steam.lobby_game_created] callback will be sent to all players in the lobby, usually at this point, the users will join the specified game server.
Triggers a [signal Steam.lobby_game_created] callback.
*/
//go:nosplit
func (self class) SetLobbyGameServer(steam_lobby_id int64, server_ip String.Readable, server_port int64, steam_id_game_server int64) { //gd:Steam.setLobbyGameServer
	var frame = callframe.New()
	callframe.Arg(frame, steam_lobby_id)
	callframe.Arg(frame, pointers.Get(gd.InternalString(server_ip)))
	callframe.Arg(frame, server_port)
	callframe.Arg(frame, steam_id_game_server)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setLobbyGameServer, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Gets the details of a game server set in a lobby. Either the IP/Port or the Steam ID of the game server has to be valid, depending on how you want the clients to be able to connect.
The returned dictionary contains the following keys:
[codeblock]
┠╴ret (bool) - true if the lobby is valid and has a valid game server set; otherwise, false.
┠╴ip (string)
┠╴port (int)
┖╴id (int)
[/codeblock]
*/
//go:nosplit
func (self class) GetLobbyGameServer(steam_lobby_id int64) Dictionary.Any { //gd:Steam.getLobbyGameServer
	var frame = callframe.New()
	callframe.Arg(frame, steam_lobby_id)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getLobbyGameServer, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Set the maximum number of players that can join the lobby.
This is also set when you create the lobby with [method Steam.createLobby].
This can only be set by the owner of the lobby.
*/
//go:nosplit
func (self class) SetLobbyMemberLimit(steam_lobby_id int64, max_members int64) bool { //gd:Steam.setLobbyMemberLimit
	var frame = callframe.New()
	callframe.Arg(frame, steam_lobby_id)
	callframe.Arg(frame, max_members)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setLobbyMemberLimit, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
The current limit on the number of users who can join the lobby.
*/
//go:nosplit
func (self class) GetLobbyMemberLimit(steam_lobby_id int64) int64 { //gd:Steam.getLobbyMemberLimit
	var frame = callframe.New()
	callframe.Arg(frame, steam_lobby_id)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getLobbyMemberLimit, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Updates what type of lobby this is.
This is also set when you create the lobby with [method Steam.createLobby].
This can only be set by the owner of the lobby.
*/
//go:nosplit
func (self class) SetLobbyType(steam_lobby_id int64, lobby_type LobbyType) bool { //gd:Steam.setLobbyType
	var frame = callframe.New()
	callframe.Arg(frame, steam_lobby_id)
	callframe.Arg(frame, lobby_type)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setLobbyType, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Sets whether or not a lobby is joinable by other players. This always defaults to enabled for a new lobby.
If joining is disabled, then no players can join, even if they are a friend or have been invited.
Lobbies with joining disabled will not be returned from a lobby search.
True upon success; otherwise, false if you're not the owner of the lobby.
*/
//go:nosplit
func (self class) SetLobbyJoinable(steam_lobby_id int64, joinable bool) bool { //gd:Steam.setLobbyJoinable
	var frame = callframe.New()
	callframe.Arg(frame, steam_lobby_id)
	callframe.Arg(frame, joinable)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setLobbyJoinable, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns the current lobby owner.
[b]Note:[/b] You must be a member of the lobby to access this. There always one lobby owner - if the current owner leaves, another user in the lobby will become the owner automatically. It is possible (but rare) to join a lobby just as the owner is leaving, thus entering a lobby with self as the owner.
*/
//go:nosplit
func (self class) GetLobbyOwner(steam_lobby_id int64) int64 { //gd:Steam.getLobbyOwner
	var frame = callframe.New()
	callframe.Arg(frame, steam_lobby_id)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getLobbyOwner, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Changes who the lobby owner is.
This can only be set by the owner of the lobby. This will trigger a [signal Steam.lobby_data_update] for all of the users in the lobby, each user should update their local state to reflect the new owner. This is typically accomplished by displaying a crown icon next to the owners name.
Triggers a [signal Steam.lobby_data_update] callback.
*/
//go:nosplit
func (self class) SetLobbyOwner(steam_lobby_id int64, steam_id_new_owner int64) bool { //gd:Steam.setLobbyOwner
	var frame = callframe.New()
	callframe.Arg(frame, steam_lobby_id)
	callframe.Arg(frame, steam_id_new_owner)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setLobbyOwner, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Cancel an outstanding server list request.
You should call this to cancel any in-progress requests before destructing a callback object that may have been passed to one of the below request calls. Not doing so may result in a crash when a callback occurs on the destructed object. Canceling a query does not release the allocated request handle. The request handle must be released using [method Steam.releaseRequest].
You can pass a server_list_request handle or, if you do not, it will use the last internally stored one.
*/
//go:nosplit
func (self class) CancelQuery(server_list_request int64) { //gd:Steam.cancelQuery
	var frame = callframe.New()
	callframe.Arg(frame, server_list_request)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_cancelQuery, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Cancel an outstanding individual server query.
The calls that create this type of query are: [method Steam.pingServer], [method Steam.playerDetails], and [method Steam.serverRules]. You should call this to cancel any in-progress requests before destructing a callback object that may have been passed to one of the above calls to avoid crashing when callbacks occur.
*/
//go:nosplit
func (self class) CancelServerQuery(server_query int64) { //gd:Steam.cancelServerQuery
	var frame = callframe.New()
	callframe.Arg(frame, server_query)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_cancelServerQuery, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Gets the number of servers in the given list. This is used for iterating with [method Steam.getServerDetails].
You can pass a server_list_request handle or, if you do not, it will use the last internally stored one.
*/
//go:nosplit
func (self class) GetServerCount(server_list_request int64) int64 { //gd:Steam.getServerCount
	var frame = callframe.New()
	callframe.Arg(frame, server_list_request)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getServerCount, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Get the details of a given server in the list.
You can get the valid range of index values by calling [method Steam.getServerCount]. You will also receive index values in server_responded callbacks.
You can pass a server_list_request handle or, if you do not, it will use the last internally stored one.
The returned dictionary contains the following keys:
[codeblock]
┠╴ping (int)
┠╴success_response (bool)
┠╴no_refresh (bool)
┠╴game_dir (string)
┠╴map (string)
┠╴description (string)
┠╴app_id (int)
┠╴players (int)
┠╴max_players (int)
┠╴bot_players (int)
┠╴password (bool)
┠╴secure (bool)
┠╴last_played (int)
┖╴server_version (int)
[/codeblock]
*/
//go:nosplit
func (self class) GetServerDetails(server int64, server_list_request int64) Dictionary.Any { //gd:Steam.getServerDetails
	var frame = callframe.New()
	callframe.Arg(frame, server)
	callframe.Arg(frame, server_list_request)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getServerDetails, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Checks if the server list request is currently refreshing.
You can pass a server_list_request handle or, if you do not, it will use the last internally stored one.
*/
//go:nosplit
func (self class) IsRefreshing(server_list_request int64) bool { //gd:Steam.isRefreshing
	var frame = callframe.New()
	callframe.Arg(frame, server_list_request)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_isRefreshing, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Queries an individual game server directly via IP/Port to request an updated ping time and other details from the server.
You must inherit from the ISteamMatchmakingPingResponse object to receive this callback.
[b]Currently not enabled.[/b]
*/
//go:nosplit
func (self class) PingServer(ip String.Readable, port int64) int64 { //gd:Steam.pingServer
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(ip)))
	callframe.Arg(frame, port)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_pingServer, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Queries an individual game server directly via IP/Port to request the list of players currently playing on the server.
You must inherit from the ISteamMatchmakingPlayersResponse object to receive this callback.
[b]Currently not enabled.[/b]
*/
//go:nosplit
func (self class) PlayerDetails(ip String.Readable, port int64) int64 { //gd:Steam.playerDetails
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(ip)))
	callframe.Arg(frame, port)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_playerDetails, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Ping every server in your list again but don't update the list of servers.
The query callback installed when the server list was requested will be used again to post notifications and refresh_complete will be called again, so the callback must remain valid until it completes or the request is released with [method Steam.releaseRequest].
You can pass a server_list_request handle or, if you do not, it will use the last internally stored one.
The returned array contains a list of:
[codeblock]
┖╴messages (dictionary):
    ┠╴payload (string)
    ┠╴size (int)
    ┠╴connection (int)
    ┠╴identity (string)
    ┠╴user_data (int)
    ┠╴time_received (int)
    ┠╴message_number (int)
    ┠╴channel (int)
    ┠╴flags (int)
    ┖╴user_data (int)
[/codeblock]
*/
//go:nosplit
func (self class) RefreshQuery(server_list_request int64) { //gd:Steam.refreshQuery
	var frame = callframe.New()
	callframe.Arg(frame, server_list_request)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_refreshQuery, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Refreshes a single server inside of a query.
If you want to refresh all of the servers then you should use [method Steam.refreshQuery].
You can pass a server_list_request handle or, if you do not, it will use the last internally stored one.
*/
//go:nosplit
func (self class) RefreshServer(server int64, server_list_request int64) { //gd:Steam.refreshServer
	var frame = callframe.New()
	callframe.Arg(frame, server)
	callframe.Arg(frame, server_list_request)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_refreshServer, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Releases the asynchronous server list request object and cancels any pending query on it if there's a pending query in progress.
You can pass a server_list_request handle or, if you do not, it will use the last internally stored one.
*/
//go:nosplit
func (self class) ReleaseRequest(server_list_request int64) { //gd:Steam.releaseRequest
	var frame = callframe.New()
	callframe.Arg(frame, server_list_request)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_releaseRequest, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Request a new list of game servers from the 'favorites' server list.
See MatchMakingKeyValuePair_t for more information.
*/
//go:nosplit
func (self class) RequestFavoritesServerList(app_id int64, filters Array.Any) int64 { //gd:Steam.requestFavoritesServerList
	var frame = callframe.New()
	callframe.Arg(frame, app_id)
	callframe.Arg(frame, pointers.Get(gd.InternalArray(filters)))
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_requestFavoritesServerList, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Request a new list of game servers from the 'friends' server list.
See MatchMakingKeyValuePair_t for more information.
*/
//go:nosplit
func (self class) RequestFriendsServerList(app_id int64, filters Array.Any) int64 { //gd:Steam.requestFriendsServerList
	var frame = callframe.New()
	callframe.Arg(frame, app_id)
	callframe.Arg(frame, pointers.Get(gd.InternalArray(filters)))
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_requestFriendsServerList, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Request a new list of game servers from the 'history' server list.
See MatchMakingKeyValuePair_t for more information.
*/
//go:nosplit
func (self class) RequestHistoryServerList(app_id int64, filters Array.Any) int64 { //gd:Steam.requestHistoryServerList
	var frame = callframe.New()
	callframe.Arg(frame, app_id)
	callframe.Arg(frame, pointers.Get(gd.InternalArray(filters)))
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_requestHistoryServerList, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Request a new list of game servers from the 'internet' server list.
See MatchMakingKeyValuePair_t for more information.
*/
//go:nosplit
func (self class) RequestInternetServerList(app_id int64, filters Array.Any) int64 { //gd:Steam.requestInternetServerList
	var frame = callframe.New()
	callframe.Arg(frame, app_id)
	callframe.Arg(frame, pointers.Get(gd.InternalArray(filters)))
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_requestInternetServerList, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Request a new list of game servers from the 'LAN' server list.
See MatchMakingKeyValuePair_t for more information.
*/
//go:nosplit
func (self class) RequestLANServerList(app_id int64) int64 { //gd:Steam.requestLANServerList
	var frame = callframe.New()
	callframe.Arg(frame, app_id)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_requestLANServerList, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Request a new list of game servers from the 'spectator' server list.
See MatchMakingKeyValuePair_t for more information.
*/
//go:nosplit
func (self class) RequestSpectatorServerList(app_id int64, filters Array.Any) int64 { //gd:Steam.requestSpectatorServerList
	var frame = callframe.New()
	callframe.Arg(frame, app_id)
	callframe.Arg(frame, pointers.Get(gd.InternalArray(filters)))
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_requestSpectatorServerList, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Queries an individual game server directly via IP/Port to request the list of rules that the server is running. (See setKeyValue to set the rules on the server side.)
You must inherit from the ISteamMatchmakingRulesResponse object to receive this callback.
*/
//go:nosplit
func (self class) ServerRules(ip String.Readable, port int64) int64 { //gd:Steam.serverRules
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(ip)))
	callframe.Arg(frame, port)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_serverRules, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Checks if Steam Music is enabled.
*/
//go:nosplit
func (self class) MusicIsEnabled() bool { //gd:Steam.musicIsEnabled
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_musicIsEnabled, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Checks if Steam Music is active. This does not necessarily a song is currently playing, it may be paused. For finer grain control use [method Steam.getPlaybackStatus].
*/
//go:nosplit
func (self class) MusicIsPlaying() bool { //gd:Steam.musicIsPlaying
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_musicIsPlaying, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Gets the current status of the Steam Music player.
*/
//go:nosplit
func (self class) GetPlaybackStatus() AudioPlaybackStatus { //gd:Steam.getPlaybackStatus
	var frame = callframe.New()
	var r_ret = callframe.Ret[AudioPlaybackStatus](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getPlaybackStatus, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Gets the current volume of the Steam Music player.
*/
//go:nosplit
func (self class) MusicGetVolume() float64 { //gd:Steam.musicGetVolume
	var frame = callframe.New()
	var r_ret = callframe.Ret[float64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_musicGetVolume, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Pause the Steam Music player.
*/
//go:nosplit
func (self class) MusicPause() { //gd:Steam.musicPause
	var frame = callframe.New()
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_musicPause, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Have the Steam Music player resume playing.
*/
//go:nosplit
func (self class) MusicPlay() { //gd:Steam.musicPlay
	var frame = callframe.New()
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_musicPlay, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Have the Steam Music player skip to the next song.
*/
//go:nosplit
func (self class) MusicPlayNext() { //gd:Steam.musicPlayNext
	var frame = callframe.New()
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_musicPlayNext, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Have the Steam Music player play the previous song.
*/
//go:nosplit
func (self class) MusicPlayPrev() { //gd:Steam.musicPlayPrev
	var frame = callframe.New()
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_musicPlayPrev, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Sets the volume of the Steam Music player.
*/
//go:nosplit
func (self class) MusicSetVolume(volume float64) { //gd:Steam.musicSetVolume
	var frame = callframe.New()
	callframe.Arg(frame, volume)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_musicSetVolume, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
If remote access was successfully activated.
*/
//go:nosplit
func (self class) ActivationSuccess(activate bool) bool { //gd:Steam.activationSuccess
	var frame = callframe.New()
	callframe.Arg(frame, activate)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_activationSuccess, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Is a remote music client / host connected?
*/
//go:nosplit
func (self class) IsCurrentMusicRemote() bool { //gd:Steam.isCurrentMusicRemote
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_isCurrentMusicRemote, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Did the current music entry just change?
*/
//go:nosplit
func (self class) CurrentEntryDidChange() bool { //gd:Steam.currentEntryDidChange
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_currentEntryDidChange, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Is the current music entry available?
*/
//go:nosplit
func (self class) CurrentEntryIsAvailable(available bool) bool { //gd:Steam.currentEntryIsAvailable
	var frame = callframe.New()
	callframe.Arg(frame, available)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_currentEntryIsAvailable, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Will the current music entry change?
*/
//go:nosplit
func (self class) CurrentEntryWillChange() bool { //gd:Steam.currentEntryWillChange
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_currentEntryWillChange, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Disconnect from remote music client / host.
*/
//go:nosplit
func (self class) DeregisterSteamMusicRemote() bool { //gd:Steam.deregisterSteamMusicRemote
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_deregisterSteamMusicRemote, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Enable track loop on client.
*/
//go:nosplit
func (self class) EnableLooped(loop bool) bool { //gd:Steam.enableLooped
	var frame = callframe.New()
	callframe.Arg(frame, loop)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_enableLooped, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Enable playlists on client.
*/
//go:nosplit
func (self class) EnablePlaylists(playlists bool) bool { //gd:Steam.enablePlaylists
	var frame = callframe.New()
	callframe.Arg(frame, playlists)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_enablePlaylists, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Play the next track on client.
*/
//go:nosplit
func (self class) EnablePlayNext(next bool) bool { //gd:Steam.enablePlayNext
	var frame = callframe.New()
	callframe.Arg(frame, next)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_enablePlayNext, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Play previous track on client.
*/
//go:nosplit
func (self class) EnablePlayPrevious(previous bool) bool { //gd:Steam.enablePlayPrevious
	var frame = callframe.New()
	callframe.Arg(frame, previous)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_enablePlayPrevious, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Enable the music queue on the client.
*/
//go:nosplit
func (self class) EnableQueue(queue bool) bool { //gd:Steam.enableQueue
	var frame = callframe.New()
	callframe.Arg(frame, queue)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_enableQueue, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Enable shuffle on the client.
*/
//go:nosplit
func (self class) EnableShuffled(shuffle bool) bool { //gd:Steam.enableShuffled
	var frame = callframe.New()
	callframe.Arg(frame, shuffle)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_enableShuffled, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Has the playlist changed?
*/
//go:nosplit
func (self class) PlaylistDidChange() bool { //gd:Steam.playlistDidChange
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_playlistDidChange, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Will the playlist change?
*/
//go:nosplit
func (self class) PlaylistWillChange() bool { //gd:Steam.playlistWillChange
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_playlistWillChange, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Did the song queue change?
*/
//go:nosplit
func (self class) QueueDidChange() bool { //gd:Steam.queueDidChange
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_queueDidChange, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Will the song queue change?
*/
//go:nosplit
func (self class) QueueWillChange() bool { //gd:Steam.queueWillChange
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_queueWillChange, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Connect to a music remote client / host?
*/
//go:nosplit
func (self class) RegisterSteamMusicRemote(name String.Readable) bool { //gd:Steam.registerSteamMusicRemote
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(name)))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_registerSteamMusicRemote, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Reset the playlist entries.
*/
//go:nosplit
func (self class) ResetPlaylistEntries() bool { //gd:Steam.resetPlaylistEntries
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_resetPlaylistEntries, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Reset the song queue entries.
*/
//go:nosplit
func (self class) ResetQueueEntries() bool { //gd:Steam.resetQueueEntries
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_resetQueueEntries, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Set a new current playlist.
*/
//go:nosplit
func (self class) SetCurrentPlaylistEntry(id int64) bool { //gd:Steam.setCurrentPlaylistEntry
	var frame = callframe.New()
	callframe.Arg(frame, id)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setCurrentPlaylistEntry, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Set a new current song queue.
*/
//go:nosplit
func (self class) SetCurrentQueueEntry(id int64) bool { //gd:Steam.setCurrentQueueEntry
	var frame = callframe.New()
	callframe.Arg(frame, id)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setCurrentQueueEntry, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Set a new display name.
*/
//go:nosplit
func (self class) SetDisplayName(name String.Readable) bool { //gd:Steam.setDisplayName
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(name)))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setDisplayName, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Set a new playlist entry.
*/
//go:nosplit
func (self class) SetPlaylistEntry(id int64, position int64, entry_text String.Readable) bool { //gd:Steam.setPlaylistEntry
	var frame = callframe.New()
	callframe.Arg(frame, id)
	callframe.Arg(frame, position)
	callframe.Arg(frame, pointers.Get(gd.InternalString(entry_text)))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setPlaylistEntry, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Set a PNG icon for a song? A playlist?
*/
//go:nosplit
func (self class) SetPNGIcon64x64(icon Packed.Bytes) bool { //gd:Steam.setPNGIcon64x64
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalPacked[gd.PackedByteArray, byte](Packed.Array[byte](icon))))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setPNGIcon64x64, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Set a new queue entry.
*/
//go:nosplit
func (self class) SetQueueEntry(id int64, position int64, entry_text String.Readable) bool { //gd:Steam.setQueueEntry
	var frame = callframe.New()
	callframe.Arg(frame, id)
	callframe.Arg(frame, position)
	callframe.Arg(frame, pointers.Get(gd.InternalString(entry_text)))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setQueueEntry, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Update the current song entry's cover art.
*/
//go:nosplit
func (self class) UpdateCurrentEntryCoverArt(art Packed.Bytes) bool { //gd:Steam.updateCurrentEntryCoverArt
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalPacked[gd.PackedByteArray, byte](Packed.Array[byte](art))))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_updateCurrentEntryCoverArt, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Update the current seconds that have elapsed for an entry.
*/
//go:nosplit
func (self class) UpdateCurrentEntryElapsedSeconds(seconds int64) bool { //gd:Steam.updateCurrentEntryElapsedSeconds
	var frame = callframe.New()
	callframe.Arg(frame, seconds)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_updateCurrentEntryElapsedSeconds, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Update the current song entry's text?
*/
//go:nosplit
func (self class) UpdateCurrentEntryText(text String.Readable) bool { //gd:Steam.updateCurrentEntryText
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(text)))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_updateCurrentEntryText, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Update looped or not.
*/
//go:nosplit
func (self class) UpdateLooped(looped bool) bool { //gd:Steam.updateLooped
	var frame = callframe.New()
	callframe.Arg(frame, looped)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_updateLooped, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Update the current playback status:
[codeblock]
• 0 / undefined
• 1 / playing
• 2 / paused
• 3 / idle
[/codeblock]
*/
//go:nosplit
func (self class) UpdatePlaybackStatus(status AudioPlaybackStatus) bool { //gd:Steam.updatePlaybackStatus
	var frame = callframe.New()
	callframe.Arg(frame, status)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_updatePlaybackStatus, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Update whether to shuffle or not.
*/
//go:nosplit
func (self class) UpdateShuffled(shuffle bool) bool { //gd:Steam.updateShuffled
	var frame = callframe.New()
	callframe.Arg(frame, shuffle)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_updateShuffled, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Volume is between 0.0 and 1.0.
*/
//go:nosplit
func (self class) UpdateVolume(volume float64) bool { //gd:Steam.updateVolume
	var frame = callframe.New()
	callframe.Arg(frame, volume)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_updateVolume, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
This allows the game to specify accept an incoming packet. This needs to be called before a real connection is established to a remote host, the game will get a chance to say whether or not the remote user is allowed to talk to them.
When a remote user that you haven't sent a packet to recently, tries to first send you a packet, your game will receive a callback [signal Steam.p2p_session_request]. This callback contains the Steam ID of the user who wants to send you a packet. In response to this callback, you'll want to see if it's someone you want to talk to (for example, if they're in a lobby with you), and if so, accept the connection; otherwise if you don't want to talk to the user, just ignore the request. If the user continues to send you packets, another [signal Steam.p2p_session_request] will be posted periodically. If you've called [method Steam.sendP2PPacket] on the other user, this implicitly accepts the session request.
[b]Note:[/b] This call should only be made in response to a [signal Steam.p2p_session_request] callback.
*/
//go:nosplit
func (self class) AcceptP2PSessionWithUser(remote_steam_id int64) bool { //gd:Steam.acceptP2PSessionWithUser
	var frame = callframe.New()
	callframe.Arg(frame, remote_steam_id)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_acceptP2PSessionWithUser, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Allow or disallow P2P connections to fall back to being relayed through the Steam servers if a direct connection or NAT-traversal cannot be established.
This only applies to connections created after setting this value, or to existing connections that need to automatically reconnect after this value is set.
P2P packet relay is allowed by default.
*/
//go:nosplit
func (self class) AllowP2PPacketRelay(allow bool) bool { //gd:Steam.allowP2PPacketRelay
	var frame = callframe.New()
	callframe.Arg(frame, allow)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_allowP2PPacketRelay, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Closes a P2P channel when you're done talking to a user on the specific channel.
Once all channels to a user have been closed, the open session to the user will be closed and new data from this user will trigger a new [signal Steam.p2p_session_request] callback.
*/
//go:nosplit
func (self class) CloseP2PChannelWithUser(remote_steam_id int64, channel int64) bool { //gd:Steam.closeP2PChannelWithUser
	var frame = callframe.New()
	callframe.Arg(frame, remote_steam_id)
	callframe.Arg(frame, channel)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_closeP2PChannelWithUser, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
This should be called when you're done communicating with a user, as this will free up all of the resources allocated for the connection under-the-hood.
If the remote user tries to send data to you again, a new [signal Steam.p2p_session_request] callback will be posted.
*/
//go:nosplit
func (self class) CloseP2PSessionWithUser(remote_steam_id int64) bool { //gd:Steam.closeP2PSessionWithUser
	var frame = callframe.New()
	callframe.Arg(frame, remote_steam_id)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_closeP2PSessionWithUser, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Fills out a dictionary with details about the connection like whether or not there is an active connection; number of bytes queued on the connection; the last error code, if any; whether or not a relay server is being used; and the IP and Port of the remote user, if known.
This should only needed for debugging purposes.
The returned dictionary contains the following keys:
[codeblock]
┠╴connection_active (bool)
┠╴connecting (bool)
┠╴session_error (int)
┠╴using_relay (bool)
┠╴bytes_queued_for_send (int)
┠╴packets_queued_for_send (int)
┠╴remote_ip (int)
┖╴remote_port (int)
[/codeblock]
*/
//go:nosplit
func (self class) GetP2PSessionState(remote_steam_id int64) Dictionary.Any { //gd:Steam.getP2PSessionState
	var frame = callframe.New()
	callframe.Arg(frame, remote_steam_id)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getP2PSessionState, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Calls isP2PPacketAvailable under the hood, returns the size of the available packet or zero if there is no such packet.
*/
//go:nosplit
func (self class) GetAvailableP2PPacketSize(channel int64) int64 { //gd:Steam.getAvailableP2PPacketSize
	var frame = callframe.New()
	callframe.Arg(frame, channel)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getAvailableP2PPacketSize, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Reads in a packet that has been sent from another user via [method Steam.sendP2PPacket].
This call is not blocking, and will return false if no data is available.
Before calling this you should have called [method Steam.getAvailableP2PPacketSize].
The returned dictionary contains the following keys:
[codeblock]
┠╴data (PackedByteArray)
┖╴remote_steam_id (int)
[/codeblock]
*/
//go:nosplit
func (self class) ReadP2PPacket(packet int64, channel int64) Dictionary.Any { //gd:Steam.readP2PPacket
	var frame = callframe.New()
	callframe.Arg(frame, packet)
	callframe.Arg(frame, channel)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_readP2PPacket, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Sends a P2P packet to the specified user.
This is a session-less API which automatically establishes NAT-traversing or Steam relay server connections.
See EP2PSend for descriptions of the different ways of sending packets. The integers passed in GodotSteam are:
[codeblock]
• 0 / send unreliable
• 1 / send unreliable, no delay
• 2 / send reliable
• 3 / send reliable with buffering
[/codeblock]
The type of data you send is arbitrary, you can use an off the shelf system like Protocol Buffers or Cap'n Proto to encode your packets in an efficient way, or you can create your own messaging system.
Sends a P2P packet to the specified user.
Triggers a [signal Steam.p2p_session_request] callback.
True if the packet was successfully sent. Note that this does not mean successfully received, if we can't get through to the user after a timeout of 20 seconds, then an error will be posted via the [signal Steam.p2p_session_connect_fail] callback.
False upon the following conditions:
[codeblock]
The packet is too large for the send type.
The target Steam ID is not valid.
There are too many bytes queued up to be sent.
[/codeblock]
[b]Note:[/b] The first packet send may be delayed as the NAT-traversal code runs.
*/
//go:nosplit
func (self class) SendP2PPacket(remote_steam_id int64, data Packed.Bytes, send_type P2PSend, channel int64) bool { //gd:Steam.sendP2PPacket
	var frame = callframe.New()
	callframe.Arg(frame, remote_steam_id)
	callframe.Arg(frame, pointers.Get(gd.InternalPacked[gd.PackedByteArray, byte](Packed.Array[byte](data))))
	callframe.Arg(frame, send_type)
	callframe.Arg(frame, channel)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_sendP2PPacket, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Call this in response to a [signal Steam.network_messages_session_request] callback. [signal Steam.network_messages_session_request] callbacks are posted when a user tries to send you a message, and you haven't tried to talk to them first. If you don't want to talk to them, just ignore the request. If the user continues to send you messages, [signal Steam.network_messages_session_request] callbacks will continue to be posted periodically.
Returns false if there is no session with the user pending or otherwise. If there is an existing active session, this function will return true, even if it is not pending.
Calling [method Steam.sendMessageToUser] will implicitly accepts any pending session request to that user.
*/
//go:nosplit
func (self class) AcceptSessionWithUser(remote_steam_id int64) bool { //gd:Steam.acceptSessionWithUser
	var frame = callframe.New()
	callframe.Arg(frame, remote_steam_id)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_acceptSessionWithUser, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Call this when you're done talking to a user on a specific channel. Once all open channels to a user have been closed, the open session to the user will be closed, and any new data from this user will trigger a [signal Steam.network_messages_session_request] callback.
*/
//go:nosplit
func (self class) CloseChannelWithUser(remote_steam_id int64, channel int64) bool { //gd:Steam.closeChannelWithUser
	var frame = callframe.New()
	callframe.Arg(frame, remote_steam_id)
	callframe.Arg(frame, channel)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_closeChannelWithUser, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Call this when you're done talking to a user to immediately free up resources under-the-hood. If the remote user tries to send data to you again, another [signal Steam.network_messages_session_request] callback will be posted.
[b]Note:[/b] sessions that go unused for a few minutes are automatically timed out.
*/
//go:nosplit
func (self class) CloseSessionWithUser(remote_steam_id int64) bool { //gd:Steam.closeSessionWithUser
	var frame = callframe.New()
	callframe.Arg(frame, remote_steam_id)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_closeSessionWithUser, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns information about the latest state of a connection, if any, with the given peer. Primarily intended for debugging purposes, but can also be used to get more detailed failure information.
Returns the value of connection state or 0 if no connection exists with specified peer. You may pass false for either get_connection or get_status if you do not need the corresponding details. Note that sessions time out after a while, so if a connection fails, or [method Steam.sendMessageToUser] returns 3, you cannot wait indefinitely to obtain the reason for failure.
*/
//go:nosplit
func (self class) GetSessionConnectionInfo(remote_steam_id int64, get_connection bool, get_status bool) Dictionary.Any { //gd:Steam.getSessionConnectionInfo
	var frame = callframe.New()
	callframe.Arg(frame, remote_steam_id)
	callframe.Arg(frame, get_connection)
	callframe.Arg(frame, get_status)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getSessionConnectionInfo, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Reads the next message that has been sent from another user via [method Steam.sendMessageToUser] on the given channel. Returns number of messages returned into your list. (0 if no message are available on that channel.)
The returned array contains a list of:
[codeblock]
┖╴messages (dictionary)
    ┠╴payload (PackedByteArray)
    ┠╴size (int)
    ┠╴connection (int)
    ┠╴identity (string)
    ┠╴receiver_user_data (int)
    ┠╴time_received (int)
    ┠╴message_number (int)
    ┠╴channel (int)
    ┠╴flags (int)
    ┖╴sender_user_data (int)
[/codeblock]
*/
//go:nosplit
func (self class) ReceiveMessagesOnChannel(channel int64, max_messages int64) Array.Any { //gd:Steam.receiveMessagesOnChannel
	var frame = callframe.New()
	callframe.Arg(frame, channel)
	callframe.Arg(frame, max_messages)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_receiveMessagesOnChannel, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Array.Through(gd.ArrayProxy[variant.Any]{}, pointers.Pack(pointers.New[gd.Array](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Sends a message to the specified host via Steam ID. If we don't already have a session with that user, a session is implicitly created. There might be some handshaking that needs to happen before we can actually begin sending message data. If this handshaking fails and we can't get through, an error will be posted via the callback [signal Steam.network_messages_session_failed]. There is no notification when the operation succeeds. (You should have the peer send a reply for this purpose.)
Sending a message to a host will also implicitly accept any incoming connection from that host.
[b]flags[/b] is a bitmask of k_nSteamNetworkingSend_xxx options.
[b]channel[/b] is a routing number you can use to help route message to different systems. You'll have to call [method Steam.receiveMessagesOnChannel] with the same channel number in order to retrieve the data on the other end.
Using different channels to talk to the same user will still use the same underlying connection, saving on resources. If you don't need this feature, use 0. Otherwise, small integers are the most efficient.
It is guaranteed that reliable messages to the same host on the same channel will be be received by the remote host (if they are received at all) exactly once, and in the same order that they were sent.
No other order guarantees exist! In particular, unreliable messages may be dropped, received out of order with respect to each other and with respect to reliable data, or may be received multiple times. Messages on different channels are not guaranteed to be received in the order they were sent.
A note for those familiar with TCP/IP ports, or converting an existing codebase that opened multiple sockets: You might notice that there is only one channel, and with TCP/IP each endpoint has a port number. You can think of the channel number as the destination port. If you need each message to also include a source port (so the recipient can route the reply), then just put that in your message. That is essentially how UDP works!
*/
//go:nosplit
func (self class) SendMessageToUser(remote_steam_id int64, data Packed.Bytes, flags int64, channel int64) int64 { //gd:Steam.sendMessageToUser
	var frame = callframe.New()
	callframe.Arg(frame, remote_steam_id)
	callframe.Arg(frame, pointers.Get(gd.InternalPacked[gd.PackedByteArray, byte](Packed.Array[byte](data))))
	callframe.Arg(frame, flags)
	callframe.Arg(frame, channel)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_sendMessageToUser, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Accept an incoming connection that has been received on a listen socket.
*/
//go:nosplit
func (self class) AcceptConnection(connection_handle int64) int64 { //gd:Steam.acceptConnection
	var frame = callframe.New()
	callframe.Arg(frame, connection_handle)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_acceptConnection, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Begin asynchronous process of allocating a fake IPv4 address that other peers can use to contact us via P2P. IP addresses returned by this function are globally unique for a given app ID.
Triggers a [signal Steam.fake_ip_result] callback.
False if a request was already in progress, true if a new request was started.
*/
//go:nosplit
func (self class) BeginAsyncRequestFakeIP(num_ports int64) bool { //gd:Steam.beginAsyncRequestFakeIP
	var frame = callframe.New()
	callframe.Arg(frame, num_ports)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_beginAsyncRequestFakeIP, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Disconnects from the remote host and invalidates the connection handle. Any unread data on the connection is discarded.
[b]reason[/b] is an application defined code that will be received on the other end and recorded (when possible) in backend analytics. The value should come from a restricted range. (See ESteamNetConnectionEnd.) If you don't need to communicate any information to the remote host, and do not want analytics to be able to distinguish "normal" connection terminations from "exceptional" ones, you may pass zero, in which case the generic value of CONNECTION_END_APP_MIN will be used.
[b]debug_message[/b] is an optional human-readable diagnostic string that will be received by the remote host and recorded (when possible) in backend analytics.
*/
//go:nosplit
func (self class) CloseConnection(peer int64, reason int64, debug_message String.Readable, linger bool) bool { //gd:Steam.closeConnection
	var frame = callframe.New()
	callframe.Arg(frame, peer)
	callframe.Arg(frame, reason)
	callframe.Arg(frame, pointers.Get(gd.InternalString(debug_message)))
	callframe.Arg(frame, linger)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_closeConnection, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Destroy a listen socket. All the connections that were accepted on the listen socket are closed ungracefully.
*/
//go:nosplit
func (self class) CloseListenSocket(socket int64) bool { //gd:Steam.closeListenSocket
	var frame = callframe.New()
	callframe.Arg(frame, socket)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_closeListenSocket, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Configure multiple outbound messages streams ("lanes") on a connection, and control head-of-line blocking between them. Messages within a given lane are always sent in the order they are queued, but messages from different lanes may be sent out of order. Each lane has its own message number sequence. The first message sent on each lane will be assigned the number 1.
Each lane has a "priority". Lower priority lanes will only be processed when all higher-priority lanes are empty. The magnitudes of the priority values are not relevant, only their sort order. Higher numeric values take priority over lower numeric values.
Each lane also is assigned a weight, which controls the approximate proportion of the bandwidth that will be consumed by the lane, relative to other lanes of the same priority. (This is assuming the lane stays busy. An idle lane does not build up "credits" to be be spent once a message is queued.) This value is only meaningful as a proportion, relative to other lanes with the same priority. For lanes with different priorities, the strict priority order will prevail, and their weights relative to each other are not relevant. Thus, if a lane has a unique priority value, the weight value for that lane is not relevant.
*/
//go:nosplit
func (self class) ConfigureConnectionLanes(connection int64, lanes int64, priorities Array.Any, weights Array.Any) int64 { //gd:Steam.configureConnectionLanes
	var frame = callframe.New()
	callframe.Arg(frame, connection)
	callframe.Arg(frame, lanes)
	callframe.Arg(frame, pointers.Get(gd.InternalArray(priorities)))
	callframe.Arg(frame, pointers.Get(gd.InternalArray(weights)))
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_configureConnectionLanes, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Begin connecting to a server that is identified using a platform-specific identifier. This uses the default rendezvous service, which depends on the platform and library configuration. (E.g. on Steam, it goes through the steam backend.) The traffic is relayed over the Steam Datagram Relay network.
If you use this, you probably want to call initRelayNetworkAccess when your app initializes. If you need to set any initial config options, pass them here.
See SteamNetworkingConfigValue_t for more about why this is preferable to setting the options "immediately" after creation.
Pass your options as an array of arrays; each sub-array containing: [b]config value (int), data type (int), and data value (int or string).[/b]
Alternately you can pass an empty array.
*/
//go:nosplit
func (self class) ConnectP2P(remote_steam_id int64, virtual_port int64, options Dictionary.Any) int64 { //gd:Steam.connectP2P
	var frame = callframe.New()
	callframe.Arg(frame, remote_steam_id)
	callframe.Arg(frame, virtual_port)
	callframe.Arg(frame, pointers.Get(gd.InternalDictionary(options)))
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_connectP2P, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Begin connecting to a server listen socket that is identified using an ip-address:port, i.e. 127.0.0.1:27015. Used with [method Steam.createListenSocketIP].
*/
//go:nosplit
func (self class) ConnectByIPAddress(ip_address_with_port String.Readable, options Dictionary.Any) int64 { //gd:Steam.connectByIPAddress
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(ip_address_with_port)))
	callframe.Arg(frame, pointers.Get(gd.InternalDictionary(options)))
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_connectByIPAddress, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Client call to connect to a server hosted in a Valve data center, on the specified virtual port. You must have placed a ticket for this server into the cache, or else this connect attempt will fail!
Pass your options as an array of arrays; each sub-array containing: [b]config value (int), data type (int), and data value (int or string).[/b]
Alternately you can pass an empty array.
*/
//go:nosplit
func (self class) ConnectToHostedDedicatedServer(remote_steam_id int64, virtual_port int64, options Dictionary.Any) int64 { //gd:Steam.connectToHostedDedicatedServer
	var frame = callframe.New()
	callframe.Arg(frame, remote_steam_id)
	callframe.Arg(frame, virtual_port)
	callframe.Arg(frame, pointers.Get(gd.InternalDictionary(options)))
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_connectToHostedDedicatedServer, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Get an interface that can be used like a UDP port to send/receive datagrams to a FakeIP address. This is intended to make it easy to port existing UDP-based code to take advantage of SDR.
[b]fake_server_port[/b] refers to the index of the port allocated using [method Steam.beginAsyncRequestFakeIP] and is used to create "server" ports. You may call this before the allocation has completed. However, any attempts to send packets will fail until the allocation has succeeded. When the peer receives packets sent from this interface, the from address of the packet will be the globally-unique FakeIP. If you call this function multiple times and pass the same (nonnegative) fake port index, the same object will be returned, and this object is not reference counted.
To create a "client" port (e.g. the equivalent of an ephemeral UDP port) pass -1. In this case, a distinct object will be returned for each call. When the peer receives packets sent from this interface, the peer will assign a FakeIP from its own locally-controlled namespace.
*/
//go:nosplit
func (self class) CreateFakeUDPPort(fake_server_port int64) { //gd:Steam.createFakeUDPPort
	var frame = callframe.New()
	callframe.Arg(frame, fake_server_port)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_createFakeUDPPort, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Create a listen socket on the specified virtual port. The physical UDP port to use will be determined by the SDR_LISTEN_PORT environment variable. If a UDP port is not configured, this call will fail.
This function should be used when you are using the ticket generator library to issue your own tickets. Clients connecting to the server on this virtual port will need a ticket, and they must connect using [method Steam.connectToHostedDedicatedServer].
Pass your options as an array of arrays; each sub-array containing: [b]config value (int), data type (int), and data value (int or string).[/b]
Alternately you can pass an empty array.
*/
//go:nosplit
func (self class) CreateHostedDedicatedServerListenSocket(virtual_port int64, options Dictionary.Any) int64 { //gd:Steam.createHostedDedicatedServerListenSocket
	var frame = callframe.New()
	callframe.Arg(frame, virtual_port)
	callframe.Arg(frame, pointers.Get(gd.InternalDictionary(options)))
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_createHostedDedicatedServerListenSocket, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Creates a "server" socket that listens for clients to connect to by calling [method Steam.connectByIPAddress], over ordinary UDP (IPv4 or IPv6)
Pass your options as an array of arrays; each sub-array containing: [b]config value (int), data type (int), and data value (int or string).[/b]
Alternately you can pass an empty array.
*/
//go:nosplit
func (self class) CreateListenSocketIP(ip_reference String.Readable, options Dictionary.Any) int64 { //gd:Steam.createListenSocketIP
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(ip_reference)))
	callframe.Arg(frame, pointers.Get(gd.InternalDictionary(options)))
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_createListenSocketIP, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Create a listen socket that will listen for P2P connections sent to our FakeIP.  A peer can initiate connections to this listen socket by calling [method Steam.connectByIPAddress].
*/
//go:nosplit
func (self class) CreateListenSocketP2P(virtual_port int64, options Dictionary.Any) int64 { //gd:Steam.createListenSocketP2P
	var frame = callframe.New()
	callframe.Arg(frame, virtual_port)
	callframe.Arg(frame, pointers.Get(gd.InternalDictionary(options)))
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_createListenSocketP2P, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Like [method Steam.createListenSocketIP], but clients will connect using [method Steam.connectP2P]. The connection will be relayed through the Valve network.
[b]virtual_port[/b] specifies how clients can connect to this socket using [method Steam.connectP2P]. It's very common for applications to only have one listening socket; in that case, use zero. If you need to open multiple listen sockets and have clients be able to connect to one or the other, then virtual_port should be a small integer (less than 1000) unique to each listen socket you create.
Pass your options as an array of arrays; each sub-array containing: [b]config value (int), data type (int), and data value (int or string).[/b]
Alternately you can pass an empty array.
*/
//go:nosplit
func (self class) CreateListenSocketP2PFakeIP(fake_port int64, options Dictionary.Any) int64 { //gd:Steam.createListenSocketP2PFakeIP
	var frame = callframe.New()
	callframe.Arg(frame, fake_port)
	callframe.Arg(frame, pointers.Get(gd.InternalDictionary(options)))
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_createListenSocketP2PFakeIP, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Create a new poll group.
You should destroy the poll group when you are done using [method Steam.destroyPollGroup].
*/
//go:nosplit
func (self class) CreatePollGroup() int64 { //gd:Steam.createPollGroup
	var frame = callframe.New()
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_createPollGroup, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Create a pair of connections that are talking to each other, e.g. a loopback connection. This is very useful for testing, or so that your client/server code can work the same even when you are running a local "server".
The two connections will immediately be placed into the connected state, and no callbacks will be posted immediately. After this, if you close either connection, the other connection will receive a callback, exactly as if they were communicating over the network. You must close both sides in order to fully clean up the resources!
By default, internal buffers are used, completely bypassing the network, the chopping up of messages into packets, encryption, copying the payload, etc. This means that loopback packets, by default, will not simulate lag or loss. Passing true for loopback will cause the socket pair to send packets through the local network loopback device (127.0.0.1) on ephemeral ports. Fake lag and loss are supported in this case, and CPU time is expended to encrypt and decrypt.
If you wish to assign a specific identity to either connection, you may pass a particular identity. Otherwise, if you pass nullptr, the respective connection will assume a generic "localhost" identity. If you use real network loopback, this might be translated to the actual bound loopback port. Otherwise, the port will be zero.
The returned dictionary contains the following keys: [b]success (bool), connection1 (int), and connection2 (int).[/b]
*/
//go:nosplit
func (self class) CreateSocketPair(loopback bool, remote_steam_id1 int64, remote_steam_id2 int64) Dictionary.Any { //gd:Steam.createSocketPair
	var frame = callframe.New()
	callframe.Arg(frame, loopback)
	callframe.Arg(frame, remote_steam_id1)
	callframe.Arg(frame, remote_steam_id2)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_createSocketPair, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Destroy a poll group created with [method Steam.createPollGroup].
If there are any connections in the poll group, they are removed from the group, and left in a state where they are not part of any poll group. Returns false if passed an invalid poll group handle.
*/
//go:nosplit
func (self class) DestroyPollGroup(poll_group int64) bool { //gd:Steam.destroyPollGroup
	var frame = callframe.New()
	callframe.Arg(frame, poll_group)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_destroyPollGroup, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Flush any messages waiting on the Nagle timer and send them at the next transmission opportunity (often that means right now).
*/
//go:nosplit
func (self class) FlushMessagesOnConnection(connection_handle int64) int64 { //gd:Steam.flushMessagesOnConnection
	var frame = callframe.New()
	callframe.Arg(frame, connection_handle)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_flushMessagesOnConnection, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Query our readiness to participate in authenticated communications. A [signal Steam.network_authentication_status] callback is posted any time this status changes, but you can use this function to query it at any time.
*/
//go:nosplit
func (self class) GetAuthenticationStatus() NetworkingAvailability { //gd:Steam.getAuthenticationStatus
	var frame = callframe.New()
	var r_ret = callframe.Ret[NetworkingAvailability](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getAuthenticationStatus, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Certificate provision by the application. On Steam, we normally handle all this automatically and you will not need to use these advanced functions.
Get blob that describes a certificate request. You can send this to your game coordinator. Pass this blob to your game coordinator and call SteamDatagram_CreateCert.
Returned dictionary contains the following keys: [b]certificate (PackedByteArray), and error_message (string).[/b]
*/
//go:nosplit
func (self class) GetCertificateRequest() Dictionary.Any { //gd:Steam.getCertificateRequest
	var frame = callframe.New()
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getCertificateRequest, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Returns basic information about the high-level state of the connection. Returns false if the connection handle is invalid.
The returned dictionary contains the following keys: [b]identity (string), user_data (int), listen_socket (int), remote_address (string), remote_pop (int), pop_relay (int), connection_state (int), end_reason (int), end_debug (string), and debug_description (string).[/b]
*/
//go:nosplit
func (self class) GetConnectionInfo(connection_handle int64) Dictionary.Any { //gd:Steam.getConnectionInfo
	var frame = callframe.New()
	callframe.Arg(frame, connection_handle)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getConnectionInfo, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Fetch connection name into your buffer, which is at least nMaxLen bytes. Returns false if handle is invalid.
*/
//go:nosplit
func (self class) GetConnectionName(peer int64) String.Readable { //gd:Steam.getConnectionName
	var frame = callframe.New()
	callframe.Arg(frame, peer)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getConnectionName, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Returns a small set of information about the real-time state of the connection and the queue status of each lane.
The returned dictionary contains the following keys:
[codeblock]
┠╴connection_status (dictionary)
    ┠╴state (int)
    ┠╴ping (int)
    ┠╴local_quality (float)
    ┠╴remote_quality (float)
    ┠╴packets_out_per_second (float)
    ┠╴bytes_out_per_second (float)
    ┠╴packets_in_per_second (float)
    ┠╴bytes_in_per_second (float)
    ┠╴send_rate (int)
    ┠╴pending_unreliable (int)
    ┠╴pending_reliable (int)
    ┠╴send_unacknowledged_reliable (int)
    ┖╴queue_time (int)
┖╴lanes_status (array)
    ┖╴lane_status (dictionary)
        ┠╴pending_unreliable (int)
        ┠╴pending_reliable (int)
        ┠╴sent_unacknowledged_reliable (int)
        ┖╴queue_time (int)
[/codeblock]
*/
//go:nosplit
func (self class) GetConnectionRealTimeStatus(connection_handle int64, lanes int64, get_status bool) Dictionary.Any { //gd:Steam.getConnectionRealTimeStatus
	var frame = callframe.New()
	callframe.Arg(frame, connection_handle)
	callframe.Arg(frame, lanes)
	callframe.Arg(frame, get_status)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getConnectionRealTimeStatus, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Fetch connection user data. Returns -1 if handle is invalid or if you haven't set any userdata on the connection.
*/
//go:nosplit
func (self class) GetConnectionUserData(peer int64) int64 { //gd:Steam.getConnectionUserData
	var frame = callframe.New()
	callframe.Arg(frame, peer)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getConnectionUserData, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns very detailed connection stats in diagnostic text format. Useful for dumping to a log, etc. The format of this information is subject to change.
The returned dictionary contains the following keys:
[codeblock]
┠╴success (int)
┖╴buffer (string)
[/codeblock]
*/
//go:nosplit
func (self class) GetDetailedConnectionStatus(connection_handle int64) Dictionary.Any { //gd:Steam.getDetailedConnectionStatus
	var frame = callframe.New()
	callframe.Arg(frame, connection_handle)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getDetailedConnectionStatus, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Return info about the FakeIP and port(s) that we have been assigned, if any.
[b]first_port[/b] is currently reserved and must be zero. Make sure and check result.
The returned dictionary contains the following keys:
[codeblock]
┠╴result (int)
┠╴identity_type (int)
┠╴ip (string)
┖╴ports (PackedInt32Array)
[/codeblock]
*/
//go:nosplit
func (self class) GetFakeIP(first_port int64) Dictionary.Any { //gd:Steam.getFakeIP
	var frame = callframe.New()
	callframe.Arg(frame, first_port)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getFakeIP, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Returns 0 if SDR_LISTEN_PORT is not set. Otherwise, returns the data center the server is running in. This will be k_SteamDatagramPOPID_dev in non-production environment.
*/
//go:nosplit
func (self class) GetHostedDedicatedServerPOPId() int64 { //gd:Steam.getHostedDedicatedServerPOPId
	var frame = callframe.New()
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getHostedDedicatedServerPOPId, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns the value of the SDR_LISTEN_PORT environment variable. This is the UDP server your server will be listening on. This will configured automatically for you in production environments.
*/
//go:nosplit
func (self class) GetHostedDedicatedServerPort() int64 { //gd:Steam.getHostedDedicatedServerPort
	var frame = callframe.New()
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getHostedDedicatedServerPort, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns local IP and port that a listen socket created using [method Steam.createListenSocketIP] is bound to.
[b]Note:[/b] This is not how you find out your public IP that clients can connect to.
*/
//go:nosplit
func (self class) GetListenSocketAddress(socket int64, with_port bool) String.Readable { //gd:Steam.getListenSocketAddress
	var frame = callframe.New()
	callframe.Arg(frame, socket)
	callframe.Arg(frame, with_port)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getListenSocketAddress, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

/*
If the connection was initiated using the "FakeIP" system, then we we can get an IP address for the remote host. If the remote host had a global FakeIP at the time the connection was established, this function will return that global IP.
Otherwise, a FakeIP that is unique locally will be allocated from the local FakeIP address space, and that will be returned.
This should also add the returning struct to your ip_addresses vector as fake_ip_address.
The returned dictionary contains the following keys:
[codeblock]
┠╴result (int)
┠╴ip_address (string)
┠╴port (int)
┖╴ip_type (int)
[/codeblock]
*/
//go:nosplit
func (self class) GetRemoteFakeIPForConnection(connection int64) Dictionary.Any { //gd:Steam.getRemoteFakeIPForConnection
	var frame = callframe.New()
	callframe.Arg(frame, connection)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getRemoteFakeIPForConnection, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Indicate our desire to be ready participate in authenticated communications. If we are currently not ready, then steps will be taken to obtain the necessary certificates. (This includes a certificate for us, as well as any CA certificates needed to authenticate peers.)
*/
//go:nosplit
func (self class) InitAuthentication() NetworkingAvailability { //gd:Steam.initAuthentication
	var frame = callframe.New()
	var r_ret = callframe.Ret[NetworkingAvailability](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_initAuthentication, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Fetch the next available message(s) from the connection, if any. Returns the number of messages returned into your array, up to max_messages. If the connection handle is invalid, -1 is returned. If no data is available, 0, is returned.
The returned array contains a list of:
[codeblock]
┖╴messages (dictionary):
    ┠╴payload (string)
    ┠╴size (int)
    ┠╴connection (int)
    ┠╴identity (string)
    ┠╴receiver_user_data (int)
    ┠╴time_received (int)
    ┠╴message_number (int)
    ┠╴channel (int)
    ┠╴flags (int)
    ┖╴sender_user_data (int)
[/codeblock]
*/
//go:nosplit
func (self class) ReceiveMessagesOnConnection(connection int64, max_messages int64) Array.Any { //gd:Steam.receiveMessagesOnConnection
	var frame = callframe.New()
	callframe.Arg(frame, connection)
	callframe.Arg(frame, max_messages)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_receiveMessagesOnConnection, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Array.Through(gd.ArrayProxy[variant.Any]{}, pointers.Pack(pointers.New[gd.Array](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Same as [method Steam.receiveMessagesOnConnection], but will return the next messages available on any connection in the poll group. Examine connection to know which connection. user_data might also be useful.
The returned array contains a list of:
[codeblock]
┖╴messages (dictionary):
    ┠╴payload (string)
    ┠╴size (int)
    ┠╴connection (int)
    ┠╴identity (string)
    ┠╴receiver_user_data (int)
    ┠╴time_received (int)
    ┠╴message_number (int)
    ┠╴channel (int)
    ┠╴flags (int)
    ┖╴sender_user_data (int)
[/codeblock]
*/
//go:nosplit
func (self class) ReceiveMessagesOnPollGroup(poll_group int64, max_messages int64) Array.Any { //gd:Steam.receiveMessagesOnPollGroup
	var frame = callframe.New()
	callframe.Arg(frame, poll_group)
	callframe.Arg(frame, max_messages)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_receiveMessagesOnPollGroup, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Array.Through(gd.ArrayProxy[variant.Any]{}, pointers.Pack(pointers.New[gd.Array](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Reset the identity associated with this instance. Any open connections are closed. Any previous certificates, etc are discarded.
[b]Note:[/b] This function is not actually supported on Steam! It is included for use on other platforms where the active user can sign out and a new user can sign in.
*/
//go:nosplit
func (self class) ResetIdentity(remote_steam_id int64) { //gd:Steam.resetIdentity
	var frame = callframe.New()
	callframe.Arg(frame, remote_steam_id)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_resetIdentity, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Invoke all callback functions queued for this interface. You don't need to call this if you are using Steam's callback dispatch mechanism [method Steam.run_callbacks].
*/
//go:nosplit
func (self class) RunNetworkingCallbacks() { //gd:Steam.runNetworkingCallbacks
	var frame = callframe.New()
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_runNetworkingCallbacks, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Send a message to the remote host on the specified connection.
The returned dictionary contains the following keys:
[codeblock]
┠╴result (int)
┖╴message_number (int)
[/codeblock]
*/
//go:nosplit
func (self class) SendMessageToConnection(connection_handle int64, data Packed.Bytes, flags int64) Dictionary.Any { //gd:Steam.sendMessageToConnection
	var frame = callframe.New()
	callframe.Arg(frame, connection_handle)
	callframe.Arg(frame, pointers.Get(gd.InternalPacked[gd.PackedByteArray, byte](Packed.Array[byte](data))))
	callframe.Arg(frame, flags)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_sendMessageToConnection, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Set the certificate. The certificate blob should be the output of SteamDatagram_CreateCert.
*/
//go:nosplit
func (self class) SetCertificate(certificate Packed.Bytes) Dictionary.Any { //gd:Steam.setCertificate
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalPacked[gd.PackedByteArray, byte](Packed.Array[byte](certificate))))
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setCertificate, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Assign a connection to a poll group. Note that a connection may only belong to a single poll group. Adding a connection to a poll group implicitly removes it from any other poll group it is in.
*/
//go:nosplit
func (self class) SetConnectionPollGroup(connection_handle int64, poll_group int64) bool { //gd:Steam.setConnectionPollGroup
	var frame = callframe.New()
	callframe.Arg(frame, connection_handle)
	callframe.Arg(frame, poll_group)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setConnectionPollGroup, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Set a name for the connection, used mostly for debugging.
*/
//go:nosplit
func (self class) SetConnectionName(peer int64, name String.Readable) { //gd:Steam.setConnectionName
	var frame = callframe.New()
	callframe.Arg(frame, peer)
	callframe.Arg(frame, pointers.Get(gd.InternalString(name)))
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setConnectionName, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Check if the ping data of sufficient recency is available, and if it's too old, start refreshing it.
Please only call this function when you really do need to force an immediate refresh of the data. (For example, in response to a specific user input to refresh this information.) Don't call it "just in case", before every connection, etc. That will cause extra traffic to be sent for no benefit. The library will automatically refresh the information as needed.
True if sufficiently recent data is already available. False if sufficiently recent data is not available. In this case, ping measurement is initiated, if it is not already active. (You cannot restart a measurement already in progress.)
*/
//go:nosplit
func (self class) CheckPingDataUpToDate(max_age_in_seconds float64) bool { //gd:Steam.checkPingDataUpToDate
	var frame = callframe.New()
	callframe.Arg(frame, max_age_in_seconds)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_checkPingDataUpToDate, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Convert a ping location into a text format suitable for sending over the wire. The format is a compact and human readable. However, it is subject to change so please do not parse it yourself.
*/
//go:nosplit
func (self class) ConvertPingLocationToString(location Packed.Bytes) String.Readable { //gd:Steam.convertPingLocationToString
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalPacked[gd.PackedByteArray, byte](Packed.Array[byte](location))))
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_convertPingLocationToString, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Estimate the round-trip latency between two arbitrary locations, in milliseconds. This is a conservative estimate, based on routing through the relay network. For most basic relayed connections, this ping time will be pretty accurate, since it will be based on the route likely to be actually used.
If a direct IP route is used (perhaps via NAT traversal), then the route will be different, and the ping time might be better. Or it might actually be a bit worse! Standard IP routing is frequently suboptimal! But even in this case, the estimate obtained using this method is a reasonable upper bound on the ping time. (Also it has the advantage of returning immediately and not sending any packets.)
In a few cases we might not able to estimate the route. In this case a negative value is returned. k_nSteamNetworkingPing_Failed means the reason was because of some networking difficulty. (Failure to ping, etc) k_nSteamNetworkingPing_Unknown is returned if we cannot currently answer the question for some other reason.
*/
//go:nosplit
func (self class) EstimatePingTimeBetweenTwoLocations(location1 Packed.Bytes, location2 Packed.Bytes) int64 { //gd:Steam.estimatePingTimeBetweenTwoLocations
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalPacked[gd.PackedByteArray, byte](Packed.Array[byte](location1))))
	callframe.Arg(frame, pointers.Get(gd.InternalPacked[gd.PackedByteArray, byte](Packed.Array[byte](location2))))
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_estimatePingTimeBetweenTwoLocations, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Same as [method Steam.estimatePingTimeBetweenTwoLocations], but assumes that one location is the local host. This is a bit faster, especially if you need to calculate a bunch of these in a loop to find the fastest one. In rare cases this might return a slightly different estimate than combining [method Steam.getLocalPingLocation] with [method Steam.estimatePingTimeBetweenTwoLocations]. That's because this function uses a slightly more complete set of information about what route would be taken.
*/
//go:nosplit
func (self class) EstimatePingTimeFromLocalHost(location Packed.Bytes) int64 { //gd:Steam.estimatePingTimeFromLocalHost
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalPacked[gd.PackedByteArray, byte](Packed.Array[byte](location))))
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_estimatePingTimeFromLocalHost, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Get a configuration value.
For values to pass to config_value, check the SDK's listing.
For values to pass to scope_type, check the SDK's listing.
Returned dictionary contains the following keys: [b]result (int), type (int), value (PackedByteArray), and buffer (int).[/b]
The result key value may be one of the following: [b]-1 / bad value, -2 / bad connection handle, -3 / buffer too small, 1 / OK, or 2 / OK, inherited.[/b]
*/
//go:nosplit
func (self class) GetConfigValue(config_value NetworkingConfigValue, scope_type NetworkingConfigScope, connection_handle int64) Dictionary.Any { //gd:Steam.getConfigValue
	var frame = callframe.New()
	callframe.Arg(frame, config_value)
	callframe.Arg(frame, scope_type)
	callframe.Arg(frame, connection_handle)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getConfigValue, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Returns info about a configuration value. For values to pass to config_value, check the SDK's listing. next_value can be used to iterate through all of the known configuration values.
The returned dictionary contains the following keys: [b]type (int), scope (int), and next_value (int).[/b]
*/
//go:nosplit
func (self class) GetConfigValueInfo(config_value NetworkingConfigValue) Dictionary.Any { //gd:Steam.getConfigValueInfo
	var frame = callframe.New()
	callframe.Arg(frame, config_value)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getConfigValueInfo, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Get direct ping time to the relays at the point of presence.
*/
//go:nosplit
func (self class) GetDirectPingToPOP(pop_id int64) int64 { //gd:Steam.getDirectPingToPOP
	var frame = callframe.New()
	callframe.Arg(frame, pop_id)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getDirectPingToPOP, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Return location info for the current host. Returns the approximate age of the data, in seconds, or -1 if no data is available. You can use this value in [method Steam.checkPingDataUpToDate].
It takes a few seconds to initialize access to the relay network.
This always return the most up-to-date information we have available right now, even if we are in the middle of re-calculating ping times.
The returned dictionary contains the following keys:
[codeblock]
┠╴location (PackedByteArray)
┖╴age (float)
[/codeblock]
*/
//go:nosplit
func (self class) GetLocalPingLocation() Dictionary.Any { //gd:Steam.getLocalPingLocation
	var frame = callframe.New()
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getLocalPingLocation, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
A general purpose high resolution local timer with the following properties:
Monotonicity is guaranteed.
The initial value will be at least 24360030*1e6, i.e. about 30 days worth of microseconds. In this way, the timestamp value of 0 will always be at least "30 days ago". Also, negative numbers will never be returned.
Wraparound / overflow is not a practical concern.
If you are running under the debugger and stop the process, the clock might not advance the full wall clock time that has elapsed between calls. If the process is not blocked from normal operation, the timestamp values will track wall clock time, even if you don't call the function frequently.
The value is only meaningful for this run of the process. Don't compare it to values obtained on another computer, or other runs of the same process.
*/
//go:nosplit
func (self class) GetLocalTimestamp() int64 { //gd:Steam.getLocalTimestamp
	var frame = callframe.New()
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getLocalTimestamp, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Fetch ping time of best available relayed route from this host to the specified data center.
The returned dictionary contains the following keys:
[codeblock]
┠╴pop_relay (int)
┖╴ping (int)
[/codeblock]
*/
//go:nosplit
func (self class) GetPingToDataCenter(pop_id int64) Dictionary.Any { //gd:Steam.getPingToDataCenter
	var frame = callframe.New()
	callframe.Arg(frame, pop_id)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getPingToDataCenter, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Get number of network points of presence in the config.
*/
//go:nosplit
func (self class) GetPOPCount() int64 { //gd:Steam.getPOPCount
	var frame = callframe.New()
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getPOPCount, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Get list of all POP IDs. Returns the number of entries that were filled into your list.
*/
//go:nosplit
func (self class) GetPOPList() Array.Any { //gd:Steam.getPOPList
	var frame = callframe.New()
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getPOPList, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Array.Through(gd.ArrayProxy[variant.Any]{}, pointers.Pack(pointers.New[gd.Array](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Fetch current status of the relay network.
[signal Steam.relay_network_status] is also a callback. It will be triggered on both the user and gameserver interfaces any time the status changes, or ping measurement starts or stops.
Possible returned statuses can be:
[codeblock]
• -102 / cannot try
• -101 / failed
• -100 / previously worked, now there is a problem
• -10 / retrying
• 0 / unknown
• 1 / never tried
• 2 / waiting
• 3 / attempting
• 100 / current
[/codeblock]
*/
//go:nosplit
func (self class) GetRelayNetworkStatus() NetworkingAvailability { //gd:Steam.getRelayNetworkStatus
	var frame = callframe.New()
	var r_ret = callframe.Ret[NetworkingAvailability](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getRelayNetworkStatus, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
If you know that you are going to be using the relay network (for example, because you anticipate making P2P connections), call this to initialize the relay network. If you do not call this, the initialization will be delayed until the first time you use a feature that requires access to the relay network, which will delay that first access.
You can also call this to force a retry if the previous attempt has failed. Performing any action that requires access to the relay network will also trigger a retry, and so calling this function is never strictly necessary, but it can be useful to call it a program launch time, if access to the relay network is anticipated. Use [method Steam.getRelayNetworkStatus] or listen for [signal Steam.relay_network_status] callbacks to know when initialization has completed. Typically initialization completes in a few seconds.
[b]Note:[/b] dedicated servers hosted in known data centers do not need to call this, since they do not make routing decisions. However, if the dedicated server will be using P2P functionality, it will act as a "client" and this should be called.
*/
//go:nosplit
func (self class) InitRelayNetworkAccess() { //gd:Steam.initRelayNetworkAccess
	var frame = callframe.New()
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_initRelayNetworkAccess, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Parse back location_string string. Returns false if we couldn't understand the string.
The returned dictionary contains the following keys:
[codeblock]
┠╴success (bool)
┖╴ping_location (PackedByteArray)
[/codeblock]
*/
//go:nosplit
func (self class) ParsePingLocationString(s String.Readable) Dictionary.Any { //gd:Steam.parsePingLocationString
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(s)))
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_parsePingLocationString, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Set a configuration value.
*/
//go:nosplit
func (self class) SetConnectionConfigValueFloat(connection int64, config NetworkingConfigValue, value float64) bool { //gd:Steam.setConnectionConfigValueFloat
	var frame = callframe.New()
	callframe.Arg(frame, connection)
	callframe.Arg(frame, config)
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setConnectionConfigValueFloat, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Set a configuration value.
*/
//go:nosplit
func (self class) SetConnectionConfigValueInt32(connection int64, config NetworkingConfigValue, value int64) bool { //gd:Steam.setConnectionConfigValueInt32
	var frame = callframe.New()
	callframe.Arg(frame, connection)
	callframe.Arg(frame, config)
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setConnectionConfigValueInt32, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Set a configuration value.
*/
//go:nosplit
func (self class) SetConnectionConfigValueString(connection int64, config NetworkingConfigValue, value String.Readable) bool { //gd:Steam.setConnectionConfigValueString
	var frame = callframe.New()
	callframe.Arg(frame, connection)
	callframe.Arg(frame, config)
	callframe.Arg(frame, pointers.Get(gd.InternalString(value)))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setConnectionConfigValueString, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Set a configuration value.
*/
//go:nosplit
func (self class) SetGlobalConfigValueFloat(config NetworkingConfigValue, value float64) bool { //gd:Steam.setGlobalConfigValueFloat
	var frame = callframe.New()
	callframe.Arg(frame, config)
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setGlobalConfigValueFloat, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Set a configuration value.
*/
//go:nosplit
func (self class) SetGlobalConfigValueInt32(config NetworkingConfigValue, value int64) bool { //gd:Steam.setGlobalConfigValueInt32
	var frame = callframe.New()
	callframe.Arg(frame, config)
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setGlobalConfigValueInt32, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Set a configuration value.
*/
//go:nosplit
func (self class) SetGlobalConfigValueString(config NetworkingConfigValue, value String.Readable) bool { //gd:Steam.setGlobalConfigValueString
	var frame = callframe.New()
	callframe.Arg(frame, config)
	callframe.Arg(frame, pointers.Get(gd.InternalString(value)))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setGlobalConfigValueString, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Check if the parental lock is enabled.
*/
//go:nosplit
func (self class) IsParentalLockEnabled() bool { //gd:Steam.isParentalLockEnabled
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_isParentalLockEnabled, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Check if the parental lock is actually locked.
*/
//go:nosplit
func (self class) IsParentalLockLocked() bool { //gd:Steam.isParentalLockLocked
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_isParentalLockLocked, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Check if the given app is blocked by parental settings.
*/
//go:nosplit
func (self class) IsAppBlocked(app_id int64) bool { //gd:Steam.isAppBlocked
	var frame = callframe.New()
	callframe.Arg(frame, app_id)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_isAppBlocked, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Check if this app is in the block list.
*/
//go:nosplit
func (self class) IsAppInBlockList(app_id int64) bool { //gd:Steam.isAppInBlockList
	var frame = callframe.New()
	callframe.Arg(frame, app_id)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_isAppInBlockList, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Check if the given feature is blocked by parental settings.
*/
//go:nosplit
func (self class) IsFeatureBlocked(feature ParentalFeature) bool { //gd:Steam.isFeatureBlocked
	var frame = callframe.New()
	callframe.Arg(frame, feature)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_isFeatureBlocked, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Check if the given feature is in the block list.
*/
//go:nosplit
func (self class) IsFeatureInBlockList(feature ParentalFeature) bool { //gd:Steam.isFeatureInBlockList
	var frame = callframe.New()
	callframe.Arg(frame, feature)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_isFeatureInBlockList, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
To cancel a reservation (due to timeout or user input), call this. Steam will open a new reservation slot.
[b]Note:[/b] The user may already be in-flight to your game, so it's possible they will still connect and try to join your party.
*/
//go:nosplit
func (self class) CancelReservation(beacon_id int64, steam_id int64) { //gd:Steam.cancelReservation
	var frame = callframe.New()
	callframe.Arg(frame, beacon_id)
	callframe.Arg(frame, steam_id)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_cancelReservation, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
If a user joins your party through other matchmaking (perhaps a direct Steam friend, or your own matchmaking system), your game should reduce the number of open slots that Steam is managing through the party beacon. For example, if you created a beacon with five slots, and Steam sent you two reservation_notification callbacks, and then a third user joined directly, you would want to call [method Steam.changeNumOpenSlots] with a value of 2 for open_slots. That value represents the total number of new users that you would like Steam to send to your party.
Triggers a [signal Steam.change_num_open_slots] call result.
*/
//go:nosplit
func (self class) ChangeNumOpenSlots(beacon_id int64, open_slots int64) { //gd:Steam.changeNumOpenSlots
	var frame = callframe.New()
	callframe.Arg(frame, beacon_id)
	callframe.Arg(frame, open_slots)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_changeNumOpenSlots, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Create a beacon. You can only create one beacon at a time. Steam will display the beacon in the specified location, and let up to open_slots users "follow" the beacon to your party.
If users join your party through other matchmaking, adjust the number of remaining open slots using [method Steam.changeNumOpenSlots].
Triggers a [signal Steam.create_beacon] call result.
*/
//go:nosplit
func (self class) CreateBeacon(open_slots int64, location_id int64, atype PartyBeaconLocationType, connect_string String.Readable, beacon_metadata String.Readable) { //gd:Steam.createBeacon
	var frame = callframe.New()
	callframe.Arg(frame, open_slots)
	callframe.Arg(frame, location_id)
	callframe.Arg(frame, atype)
	callframe.Arg(frame, pointers.Get(gd.InternalString(connect_string)))
	callframe.Arg(frame, pointers.Get(gd.InternalString(beacon_metadata)))
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_createBeacon, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Call this method to destroy the Steam party beacon. This will immediately cause Steam to stop showing the beacon in the target location. Note that any users currently in-flight may still arrive at your party expecting to join.
*/
//go:nosplit
func (self class) DestroyBeacon(beacon_id int64) bool { //gd:Steam.destroyBeacon
	var frame = callframe.New()
	callframe.Arg(frame, beacon_id)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_destroyBeacon, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Get the list of locations in which you can post a party beacon.
The returned array contains a list of:
[codeblock]
beacon_data (dictionary)
┠╴type (int)
┖╴location_id (int)
[/codeblock]
*/
//go:nosplit
func (self class) GetAvailableBeaconLocations(max int64) Array.Any { //gd:Steam.getAvailableBeaconLocations
	var frame = callframe.New()
	callframe.Arg(frame, max)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getAvailableBeaconLocations, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Array.Through(gd.ArrayProxy[variant.Any]{}, pointers.Pack(pointers.New[gd.Array](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Use with [method Steam.getNumActiveBeacons] to iterate the active beacons visible to the current user. Argument index is a zero-based index, so iterate over the range (0, getNumActiveBeacons() - 1). The return is a beacon_id that can be used with [method Steam.getBeaconDetails] to get information about the beacons suitable for display to the user.
*/
//go:nosplit
func (self class) GetBeaconByIndex(index int64) int64 { //gd:Steam.getBeaconByIndex
	var frame = callframe.New()
	callframe.Arg(frame, index)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getBeaconByIndex, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Get details about the specified beacon. You can use the Friends API to get further details about owner_id, and [method Steam.getBeaconLocationData] to get further details about location_id. The metadata contents are specific to your game, and will be whatever was set (if anything) by the game process that created the beacon.
The returned dictionary contains the following keys:
[codeblock]
┠╴beacon_id (int)
┠╴owner_id (int)
┠╴type (int)
┠╴location_id (int)
┖╴metadata (string)
[/codeblock]
*/
//go:nosplit
func (self class) GetBeaconDetails(beacon_id int64) Dictionary.Any { //gd:Steam.getBeaconDetails
	var frame = callframe.New()
	callframe.Arg(frame, beacon_id)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getBeaconDetails, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Query general metadata for the given beacon location. For instance the Name, or the URL for an icon if the location type supports icons (for example, the icon for a Steam Chat Room Group).
*/
//go:nosplit
func (self class) GetBeaconLocationData(location_id int64, location_type PartyBeaconLocationType, location_data PartyBeaconLocationData) String.Readable { //gd:Steam.getBeaconLocationData
	var frame = callframe.New()
	callframe.Arg(frame, location_id)
	callframe.Arg(frame, location_type)
	callframe.Arg(frame, location_data)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getBeaconLocationData, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Get the number of active party beacons created by other users for your game, that are visible to the current user.
*/
//go:nosplit
func (self class) GetNumActiveBeacons() int64 { //gd:Steam.getNumActiveBeacons
	var frame = callframe.New()
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getNumActiveBeacons, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
When the user indicates they wish to join the party advertised by a given beacon, call this method. On success, Steam will reserve a slot for this user in the party and return the necessary "join game" string to use to complete the connection.
Triggers a [signal Steam.join_party] call result.
*/
//go:nosplit
func (self class) JoinParty(beacon_id int64) { //gd:Steam.joinParty
	var frame = callframe.New()
	callframe.Arg(frame, beacon_id)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_joinParty, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
When a user follows your beacon, Steam will reserve one of the open party slots for them, and send your game a reservation_notification callback. When that user joins your party, call [method Steam.onReservationCompleted] to notify Steam that the user has joined successfully.
Triggers a [signal Steam.reservation_notification] callback.
*/
//go:nosplit
func (self class) OnReservationCompleted(beacon_id int64, steam_id int64) { //gd:Steam.onReservationCompleted
	var frame = callframe.New()
	callframe.Arg(frame, beacon_id)
	callframe.Arg(frame, steam_id)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_onReservationCompleted, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Get the number of currently connected Steam Remote Play sessions.
*/
//go:nosplit
func (self class) GetSessionCount() int64 { //gd:Steam.getSessionCount
	var frame = callframe.New()
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getSessionCount, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Get the currently connected Steam Remote Play session ID at the specified index.
*/
//go:nosplit
func (self class) GetSessionID(index int64) int64 { //gd:Steam.getSessionID
	var frame = callframe.New()
	callframe.Arg(frame, index)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getSessionID, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Get the Steam ID of the connected user.
*/
//go:nosplit
func (self class) GetSessionSteamID(session_id int64) int64 { //gd:Steam.getSessionSteamID
	var frame = callframe.New()
	callframe.Arg(frame, session_id)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getSessionSteamID, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Get the name of the session client device.
*/
//go:nosplit
func (self class) GetSessionClientName(session_id int64) String.Readable { //gd:Steam.getSessionClientName
	var frame = callframe.New()
	callframe.Arg(frame, session_id)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getSessionClientName, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Get the form factor of the session client device.
*/
//go:nosplit
func (self class) GetSessionClientFormFactor(session_id int64) int64 { //gd:Steam.getSessionClientFormFactor
	var frame = callframe.New()
	callframe.Arg(frame, session_id)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getSessionClientFormFactor, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Get the resolution, in pixels, of the session client device. This is set to 0x0 if the resolution is not available.
The returned dictionary contains the following keys:
[codeblock]
┠╴success (bool)
┠╴x (int)
┖╴y (int)
[/codeblock]
*/
//go:nosplit
func (self class) GetSessionClientResolution(session_id int64) Dictionary.Any { //gd:Steam.getSessionClientResolution
	var frame = callframe.New()
	callframe.Arg(frame, session_id)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getSessionClientResolution, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Invite a friend to join the game using Remote Play Together.
*/
//go:nosplit
func (self class) SendRemotePlayTogetherInvite(friend_id int64) bool { //gd:Steam.sendRemotePlayTogetherInvite
	var frame = callframe.New()
	callframe.Arg(frame, friend_id)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_sendRemotePlayTogetherInvite, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Start a Remote Play session.
*/
//go:nosplit
func (self class) StartRemotePlayTogether(show_overlay bool) bool { //gd:Steam.startRemotePlayTogether
	var frame = callframe.New()
	callframe.Arg(frame, show_overlay)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_startRemotePlayTogether, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Use this along with [method Steam.endFileWriteBatch] to wrap a set of local file writes/deletes that should be considered part of one single state change. For example, if saving game progress requires updating both savegame1.dat and maxprogress.dat, wrap those operations with calls to [method Steam.beginFileWriteBatch] and [method Steam.endFileWriteBatch].
These functions provide a hint to Steam which will help it manage the app's Cloud files. Using these functions is optional, however it will provide better reliability.
Note that the functions may be used whether the writes are done using the Remote Storage API, or done directly to local disk (where AutoCloud is used).
*/
//go:nosplit
func (self class) BeginFileWriteBatch() bool { //gd:Steam.beginFileWriteBatch
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_beginFileWriteBatch, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Use this along with [method Steam.beginFileWriteBatch] - see that documentation for more details.
*/
//go:nosplit
func (self class) EndFileWriteBatch() bool { //gd:Steam.endFileWriteBatch
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_endFileWriteBatch, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Deletes a file from the local disk, and propagates that delete to the cloud.
This is meant to be used when a user actively deletes a file. Use [method Steam.fileForget] if you want to remove a file from the Steam Cloud but retain it on the users local disk.
When a file has been deleted it can be re-written with [method Steam.fileWrite] to reupload it to the Steam Cloud.
*/
//go:nosplit
func (self class) FileDelete(file String.Readable) bool { //gd:Steam.fileDelete
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(file)))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_fileDelete, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Check if a remote file exists.
*/
//go:nosplit
func (self class) FileExists(file String.Readable) bool { //gd:Steam.fileExists
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(file)))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_fileExists, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Deletes the file from remote storage, but leaves it on the local disk and remains accessible from the API.
When you are out of Cloud space, this can be used to allow calls to [method Steam.fileWrite] to keep working without needing to make the user delete files.
How you decide which files to forget are up to you. It could be a simple Least Recently Used (LRU) queue or something more complicated.
Requiring the user to manage their Cloud-ized files for a game, while is possible to do, it is never recommended. For instance, "Which file would you like to delete so that you may store this new one?" removes a significant advantage of using the Cloud in the first place: its transparency.
Once a file has been deleted or forgotten, calling [method Steam.fileWrite] will resynchronize it in the Cloud. Rewriting a forgotten file is the only way to make it persisted again.
*/
//go:nosplit
func (self class) FileForget(file String.Readable) bool { //gd:Steam.fileForget
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(file)))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_fileForget, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Checks if a specific file is persisted in the Steam Cloud.
*/
//go:nosplit
func (self class) FilePersisted(file String.Readable) bool { //gd:Steam.filePersisted
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(file)))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_filePersisted, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Opens a binary file, reads the contents of the file into a byte array, and then closes the file.
The returned dictionary contains the following keys:
[codeblock]
┠╴ret (bool)
┖╴buf (PackedByteArray)
[/codeblock]
[b]Note:[/b] This is a synchronous call and as such is a will block your calling thread on the disk IO, and will also block the SteamAPI, which can cause other threads in your application to block. To avoid "hitching" due to a busy disk on the client machine using [method Steam.fileReadAsync], the asynchronous version of this API is recommended.
*/
//go:nosplit
func (self class) FileRead(file String.Readable, data_to_read int64) Dictionary.Any { //gd:Steam.fileRead
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(file)))
	callframe.Arg(frame, data_to_read)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_fileRead, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Starts an asynchronous read from a file. The offset and amount to read should be valid for the size of the file, as indicated by [method Steam.getFileSize] or [method Steam.getFileTimestamp].
Triggers a [signal Steam.file_read_async_complete] call result.
*/
//go:nosplit
func (self class) FileReadAsync(file String.Readable, offset int64, data_to_read int64) { //gd:Steam.fileReadAsync
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(file)))
	callframe.Arg(frame, offset)
	callframe.Arg(frame, data_to_read)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_fileReadAsync, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Share a file.
Triggers a [signal Steam.file_share_result] call result.
*/
//go:nosplit
func (self class) FileShare(file String.Readable) { //gd:Steam.fileShare
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(file)))
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_fileShare, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Creates a new file, writes the bytes to the file, and then closes the file. If the target file already exists, it is overwritten.
[b]Note:[/b] This is a synchronous call and as such is a will block your calling thread on the disk IO, and will also block the SteamAPI, which can cause other threads in your application to block. To avoid "hitching" due to a busy disk on the client machine using [method Steam.fileWriteAsync], the asynchronous version of this API is recommended.
*/
//go:nosplit
func (self class) FileWrite(file String.Readable, data Packed.Bytes, size int64) bool { //gd:Steam.fileWrite
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(file)))
	callframe.Arg(frame, pointers.Get(gd.InternalPacked[gd.PackedByteArray, byte](Packed.Array[byte](data))))
	callframe.Arg(frame, size)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_fileWrite, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Creates a new file and asynchronously writes the raw byte data to the Steam Cloud, and then closes the file. If the target file already exists, it is overwritten.
Triggers a [signal Steam.file_write_async_complete] call result.
*/
//go:nosplit
func (self class) FileWriteAsync(file String.Readable, data Packed.Bytes, size int64) { //gd:Steam.fileWriteAsync
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(file)))
	callframe.Arg(frame, pointers.Get(gd.InternalPacked[gd.PackedByteArray, byte](Packed.Array[byte](data))))
	callframe.Arg(frame, size)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_fileWriteAsync, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Cancels a file write stream that was started by [method Steam.fileWriteStreamOpen].
This trashes all of the data written and closes the write stream, but if there was an existing file with this name, it remains untouched.
*/
//go:nosplit
func (self class) FileWriteStreamCancel(write_handle int64) bool { //gd:Steam.fileWriteStreamCancel
	var frame = callframe.New()
	callframe.Arg(frame, write_handle)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_fileWriteStreamCancel, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Closes a file write stream that was started by [method Steam.fileWriteStreamOpen].
This flushes the stream to the disk, overwriting the existing file if there was one.
*/
//go:nosplit
func (self class) FileWriteStreamClose(write_handle int64) bool { //gd:Steam.fileWriteStreamClose
	var frame = callframe.New()
	callframe.Arg(frame, write_handle)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_fileWriteStreamClose, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Creates a new file output stream allowing you to stream out data to the Steam Cloud file in chunks. If the target file already exists, it is not overwritten until [method Steam.fileWriteStreamClose] has been called.
To write data out to this stream you can use [method Steam.fileWriteStreamWriteChunk], and then to close or cancel you use [method Steam.fileWriteStreamClose] and [method Steam.fileWriteStreamCancel] respectively.
*/
//go:nosplit
func (self class) FileWriteStreamOpen(file String.Readable) int64 { //gd:Steam.fileWriteStreamOpen
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(file)))
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_fileWriteStreamOpen, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Writes a blob of data to the file write stream.
*/
//go:nosplit
func (self class) FileWriteStreamWriteChunk(write_handle int64, data Packed.Bytes) bool { //gd:Steam.fileWriteStreamWriteChunk
	var frame = callframe.New()
	callframe.Arg(frame, write_handle)
	callframe.Arg(frame, pointers.Get(gd.InternalPacked[gd.PackedByteArray, byte](Packed.Array[byte](data))))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_fileWriteStreamWriteChunk, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Gets the number of cached UGC.
*/
//go:nosplit
func (self class) GetCachedUGCCount() int64 { //gd:Steam.getCachedUGCCount
	var frame = callframe.New()
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getCachedUGCCount, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Gets the cached UGC's handle.
*/
//go:nosplit
func (self class) GetCachedUGCHandle(content int64) int64 { //gd:Steam.getCachedUGCHandle
	var frame = callframe.New()
	callframe.Arg(frame, content)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getCachedUGCHandle, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Gets the total number of local files synchronized by Steam Cloud.
Used for enumeration with [method Steam.getFileNameAndSize].
*/
//go:nosplit
func (self class) GetFileCount() int64 { //gd:Steam.getFileCount
	var frame = callframe.New()
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getFileCount, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Gets the file name and size of a file from the index.
The returned dictionary contains the following keys:
[codeblock]
┠╴name (string)
┖╴size (int)
[/codeblock]
[b]Note:[/b] You must call [method Steam.getFileCount] first to get the number of files.
*/
//go:nosplit
func (self class) GetFileNameAndSize(file int64) Dictionary.Any { //gd:Steam.getFileNameAndSize
	var frame = callframe.New()
	callframe.Arg(frame, file)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getFileNameAndSize, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Get the size of the current file.
*/
//go:nosplit
func (self class) GetFileSize(file String.Readable) int64 { //gd:Steam.getFileSize
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(file)))
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getFileSize, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Get the timestamp of when the file was uploaded.
*/
//go:nosplit
func (self class) GetFileTimestamp(file String.Readable) int64 { //gd:Steam.getFileTimestamp
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(file)))
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getFileTimestamp, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
After calling [method Steam.getLocalFileChangeCount], use this method to iterate over the changes. The changes described have already been made to local files. Your application should take appropriate action to reload state from disk, and possibly notify the user.
For example: The local system had been suspended, during which time the user played elsewhere and uploaded changes to the Steam Cloud. On resume, Steam downloads those changes to the local system before resuming the application. The application receives an [signal Steam.local_file_changed], and uses [method Steam.getLocalFileChangeCount], and [method Steam.getLocalFileChange] to iterate those changes. Depending on the application structure and the nature of the changes, the application could:
• Re-load game progress to resume at exactly the point where the user was when they exited the game on the other device
• Notify the user of any synchronized changes that don't require reloading
• Etc.
The returned dictionary contains the following keys:
[codeblock]
┠╴file (string)
┠╴change_type (int)
┖╴path_type (int)
[/codeblock]
[b]Note:[/b] only applies to applications flagged as supporting dynamic Steam Cloud sync.
*/
//go:nosplit
func (self class) GetLocalFileChange(file int64) Dictionary.Any { //gd:Steam.getLocalFileChange
	var frame = callframe.New()
	callframe.Arg(frame, file)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getLocalFileChange, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
When your application receives a [signal Steam.local_file_changed], use this method to get the number of changes (file updates and file deletes) that have been made. You can then iterate the changes using [method Steam.getLocalFileChange].
[b]Note:[/b] only applies to applications flagged as supporting dynamic Steam Cloud sync.
*/
//go:nosplit
func (self class) GetLocalFileChangeCount() int64 { //gd:Steam.getLocalFileChangeCount
	var frame = callframe.New()
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getLocalFileChangeCount, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Gets the number of bytes available, and used on the users Steam Cloud storage.
The returned dictionary contains the following keys:
[codeblock]
┠╴total_bytes (int)
┖╴available_bytes (int)
[/codeblock]
*/
//go:nosplit
func (self class) GetQuota() Dictionary.Any { //gd:Steam.getQuota
	var frame = callframe.New()
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getQuota, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Obtains the platforms that the specified file will synchronize to.
The returned dictionary contains the following keys:
[codeblock]
┠╴bitwise (int)
    • 0 / None
    • 1<<0 / Windows
    • 1<<1 / OSX
    • 1<<2 / PS3
    • 1<<3 / Linux
    • 1<<4 / Reserved
    • 0xffffffff / All
┖╴verbose (string)
[/codeblock]
*/
//go:nosplit
func (self class) GetSyncPlatforms(file String.Readable) Dictionary.Any { //gd:Steam.getSyncPlatforms
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(file)))
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getSyncPlatforms, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Gets metadata for a file after it has been downloaded. This is the same metadata given in the [signal Steam.download_ugc_result] call result.
The returned dictionary contains the following keys:
[codeblock]
┠╴handle (int)
┠╴app_id (int)
┠╴size (int)
┠╴filename (string)
┖╴owner_id (int)
[/codeblock]
*/
//go:nosplit
func (self class) GetUGCDetails(content int64) Dictionary.Any { //gd:Steam.getUGCDetails
	var frame = callframe.New()
	callframe.Arg(frame, content)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getUGCDetails, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Gets the amount of data downloaded so far for a piece of content. bytes_expected can be 0 if function returns false or if the transfer hasn't started yet, so be careful to check for that before dividing to get a percentage.
The returned dictionary contains the following keys:
[codeblock]
┠╴bytes_downloaded (int)
┖╴bytes_expected (int)
[/codeblock]
*/
//go:nosplit
func (self class) GetUGCDownloadProgress(content int64) Dictionary.Any { //gd:Steam.getUGCDownloadProgress
	var frame = callframe.New()
	callframe.Arg(frame, content)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getUGCDownloadProgress, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Checks if the account wide Steam Cloud setting is enabled for this user; or if they disabled it in the Settings->Cloud dialog.
Ensure that you are also checking [method Steam.isCloudEnabledForApp], as these two options are mutually exclusive.
*/
//go:nosplit
func (self class) IsCloudEnabledForAccount() bool { //gd:Steam.isCloudEnabledForAccount
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_isCloudEnabledForAccount, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Checks if the per game Steam Cloud setting is enabled for this user; or if they disabled it in the Game Properties->Update dialog.
Ensure that you are also checking [method Steam.isCloudEnabledForAccount], as these two options are mutually exclusive.
It's generally recommended that you allow the user to toggle this setting within your in-game options, you can toggle it with [method Steam.setCloudEnabledForApp].
*/
//go:nosplit
func (self class) IsCloudEnabledForApp() bool { //gd:Steam.isCloudEnabledForApp
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_isCloudEnabledForApp, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Enable or disable Steam Cloud for this application. This must only ever be called as the direct result of the user explicitly requesting that it's enabled or not. This is typically accomplished with a checkbox within your in-game options.
*/
//go:nosplit
func (self class) SetCloudEnabledForApp(enabled bool) { //gd:Steam.setCloudEnabledForApp
	var frame = callframe.New()
	callframe.Arg(frame, enabled)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setCloudEnabledForApp, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Allows you to specify which operating systems a file will be synchronized to.
Use this if you have a multiplatform game but have data which is incompatible between platforms.
Files default to k_ERemoteStoragePlatformAll (0xffffffff) when they are first created. You can use the bitwise OR operator, "|" to specify multiple platforms.
*/
//go:nosplit
func (self class) SetSyncPlatforms(file String.Readable, platform int64) bool { //gd:Steam.setSyncPlatforms
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(file)))
	callframe.Arg(frame, platform)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setSyncPlatforms, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Downloads a UGC file.
A priority value of 0 will download the file immediately, otherwise it will wait to download the file until all downloads with a lower priority value are completed.  Downloads with equal priority will occur simultaneously.
*/
//go:nosplit
func (self class) UgcDownload(content int64, priority int64) { //gd:Steam.ugcDownload
	var frame = callframe.New()
	callframe.Arg(frame, content)
	callframe.Arg(frame, priority)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_ugcDownload, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Downloads a UGC file to a specific location.
*/
//go:nosplit
func (self class) UgcDownloadToLocation(content int64, location String.Readable, priority int64) { //gd:Steam.ugcDownloadToLocation
	var frame = callframe.New()
	callframe.Arg(frame, content)
	callframe.Arg(frame, pointers.Get(gd.InternalString(location)))
	callframe.Arg(frame, priority)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_ugcDownloadToLocation, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
After download, gets the content of the file.
*/
//go:nosplit
func (self class) UgcRead(content int64, data_size int64, offset int64, action UGCReadAction) Packed.Bytes { //gd:Steam.ugcRead
	var frame = callframe.New()
	callframe.Arg(frame, content)
	callframe.Arg(frame, data_size)
	callframe.Arg(frame, offset)
	callframe.Arg(frame, action)
	var r_ret = callframe.Ret[gd.PackedPointers](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_ugcRead, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Packed.Bytes(Array.Through(gd.PackedProxy[gd.PackedByteArray, byte]{}, pointers.Pack(pointers.New[gd.PackedByteArray](r_ret.Get()))))
	frame.Free()
	return ret
}

/*
Adds a screenshot to the user's Steam screenshot library from disk.
*/
//go:nosplit
func (self class) AddScreenshotToLibrary(filename String.Readable, thumbnail_filename String.Readable, width int64, height int64) int64 { //gd:Steam.addScreenshotToLibrary
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(filename)))
	callframe.Arg(frame, pointers.Get(gd.InternalString(thumbnail_filename)))
	callframe.Arg(frame, width)
	callframe.Arg(frame, height)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_addScreenshotToLibrary, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Adds a VR screenshot to the user's Steam screenshot library from disk in the supported type.
*/
//go:nosplit
func (self class) AddVRScreenshotToLibrary(atype VRScreenshotType, filename String.Readable, vr_filename String.Readable) int64 { //gd:Steam.addVRScreenshotToLibrary
	var frame = callframe.New()
	callframe.Arg(frame, atype)
	callframe.Arg(frame, pointers.Get(gd.InternalString(filename)))
	callframe.Arg(frame, pointers.Get(gd.InternalString(vr_filename)))
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_addVRScreenshotToLibrary, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Toggles whether the overlay handles screenshots.
*/
//go:nosplit
func (self class) HookScreenshots(hook bool) { //gd:Steam.hookScreenshots
	var frame = callframe.New()
	callframe.Arg(frame, hook)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_hookScreenshots, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Checks if the app is hooking screenshots.
*/
//go:nosplit
func (self class) IsScreenshotsHooked() bool { //gd:Steam.isScreenshotsHooked
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_isScreenshotsHooked, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Sets optional metadata about a screenshot's location.
*/
//go:nosplit
func (self class) SetLocation(screenshot int64, location String.Readable) bool { //gd:Steam.setLocation
	var frame = callframe.New()
	callframe.Arg(frame, screenshot)
	callframe.Arg(frame, pointers.Get(gd.InternalString(location)))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setLocation, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Tags a published file as being visible in the screenshot.
*/
//go:nosplit
func (self class) TagPublishedFile(screenshot int64, file_id int64) bool { //gd:Steam.tagPublishedFile
	var frame = callframe.New()
	callframe.Arg(frame, screenshot)
	callframe.Arg(frame, file_id)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_tagPublishedFile, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Tags a Steam user as being visible in the screenshot. You can tag up to the value declared by k_nScreenshotMaxTaggedUsers in a single screenshot. Tagging more users than that will just be discarded. This function has a built in delay before saving the tag which allows you to call it repeatedly for each item. You can get the handle to tag the screenshot once it has been successfully saved from the [signal Steam.screenshot_ready] callback or via the [method Steam.writeScreenshot], [method Steam.addScreenshotToLibrary], [method Steam.addVRScreenshotToLibrary] calls.
*/
//go:nosplit
func (self class) TagUser(screenshot int64, steam_id int64) bool { //gd:Steam.tagUser
	var frame = callframe.New()
	callframe.Arg(frame, screenshot)
	callframe.Arg(frame, steam_id)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_tagUser, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Causes Steam overlay to take a screenshot.
*/
//go:nosplit
func (self class) TriggerScreenshot() { //gd:Steam.triggerScreenshot
	var frame = callframe.New()
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_triggerScreenshot, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Writes a screenshot to the user's Steam screenshot library.
*/
//go:nosplit
func (self class) WriteScreenshot(rgb Packed.Bytes, width int64, height int64) int64 { //gd:Steam.writeScreenshot
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalPacked[gd.PackedByteArray, byte](Packed.Array[byte](rgb))))
	callframe.Arg(frame, width)
	callframe.Arg(frame, height)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_writeScreenshot, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Add a tag that applies to the entire phase.
*/
//go:nosplit
func (self class) AddGamePhaseTag(tag_name String.Readable, tag_icon String.Readable, tag_group String.Readable, priority int64) { //gd:Steam.addGamePhaseTag
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(tag_name)))
	callframe.Arg(frame, pointers.Get(gd.InternalString(tag_icon)))
	callframe.Arg(frame, pointers.Get(gd.InternalString(tag_group)))
	callframe.Arg(frame, priority)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_addGamePhaseTag, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Use this to mark an event (A) on the Timeline. This event will be instantaneous. (See [method Steam.addRangeTimelineEvent] to add events that happened over time.)
*/
//go:nosplit
func (self class) AddInstantaneousTimelineEvent(title String.Readable, description String.Readable, icon String.Readable, icon_priority int64, start_offset_seconds float64, possible_clip TimelineEventClipPriority) int64 { //gd:Steam.addInstantaneousTimelineEvent
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(title)))
	callframe.Arg(frame, pointers.Get(gd.InternalString(description)))
	callframe.Arg(frame, pointers.Get(gd.InternalString(icon)))
	callframe.Arg(frame, icon_priority)
	callframe.Arg(frame, start_offset_seconds)
	callframe.Arg(frame, possible_clip)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_addInstantaneousTimelineEvent, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Use this to mark an event (A) on the Timeline that takes some amount of time to complete.
*/
//go:nosplit
func (self class) AddRangeTimelineEvent(title String.Readable, description String.Readable, icon String.Readable, icon_priority int64, start_offset_seconds float64, duration float64, possible_clip TimelineEventClipPriority) int64 { //gd:Steam.addRangeTimelineEvent
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(title)))
	callframe.Arg(frame, pointers.Get(gd.InternalString(description)))
	callframe.Arg(frame, pointers.Get(gd.InternalString(icon)))
	callframe.Arg(frame, icon_priority)
	callframe.Arg(frame, start_offset_seconds)
	callframe.Arg(frame, duration)
	callframe.Arg(frame, possible_clip)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_addRangeTimelineEvent, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Clear a network identity's data.
*/
//go:nosplit
func (self class) ClearTimelineTooltip(time_delta float64) { //gd:Steam.clearTimelineTooltip
	var frame = callframe.New()
	callframe.Arg(frame, time_delta)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_clearTimelineTooltip, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Add a tag to whatever time range is represented by the event.
*/
//go:nosplit
func (self class) DoesEventRecordingExist(this_event int64) { //gd:Steam.doesEventRecordingExist
	var frame = callframe.New()
	callframe.Arg(frame, this_event)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_doesEventRecordingExist, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Use this to determine if video recordings exist for the specified game phase. Steam will sent a [signal Steam.timeline_game_phase_recording_exists] callback with the result. This can be useful when the game needs to decide whether or not to show a control that will call [method Steam.openOverlayToGamePhase].
*/
//go:nosplit
func (self class) DoesGamePhaseRecordingExist(phase_id String.Readable) { //gd:Steam.doesGamePhaseRecordingExist
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(phase_id)))
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_doesGamePhaseRecordingExist, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Use this to end a game phase that was started with [method Steam.startGamePhase].
*/
//go:nosplit
func (self class) EndGamePhase() { //gd:Steam.endGamePhase
	var frame = callframe.New()
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_endGamePhase, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Ends a range timeline event and shows it in the UI.
*/
//go:nosplit
func (self class) EndRangeTimelineEvent(this_event int64, end_offset_seconds float64) { //gd:Steam.endRangeTimelineEvent
	var frame = callframe.New()
	callframe.Arg(frame, this_event)
	callframe.Arg(frame, end_offset_seconds)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_endRangeTimelineEvent, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Opens the Steam overlay to a game phase.
*/
//go:nosplit
func (self class) OpenOverlayToGamePhase(phase_id String.Readable) { //gd:Steam.openOverlayToGamePhase
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(phase_id)))
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_openOverlayToGamePhase, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Opens the Steam overlay to a timeline event.
*/
//go:nosplit
func (self class) OpenOverlayToTimelineEvent(this_event int64) { //gd:Steam.openOverlayToTimelineEvent
	var frame = callframe.New()
	callframe.Arg(frame, this_event)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_openOverlayToTimelineEvent, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Delete the event from the timeline. This can be called on a timeline event from [method Steam.addInstantaneousTimelineEvent], [method Steam.addRangeTimelineEvent], or [method Steam.startRangeTimelineEvent] / [method Steam.endRangeTimelineEvent]. The timeline event handle must be from the current game process.
*/
//go:nosplit
func (self class) RemoveTimelineEvent(this_event int64) { //gd:Steam.removeTimelineEvent
	var frame = callframe.New()
	callframe.Arg(frame, this_event)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_removeTimelineEvent, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Add a text attribute that applies to the entire phase.
*/
//go:nosplit
func (self class) SetGamePhaseAttribute(attribute_group String.Readable, attribute_value String.Readable, priority int64) { //gd:Steam.setGamePhaseAttribute
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(attribute_group)))
	callframe.Arg(frame, pointers.Get(gd.InternalString(attribute_value)))
	callframe.Arg(frame, priority)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setGamePhaseAttribute, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Games can set a phase ID.
*/
//go:nosplit
func (self class) SetGamePhaseID(phase_id String.Readable) { //gd:Steam.setGamePhaseID
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(phase_id)))
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setGamePhaseID, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Changes the color of the timeline bar. See TimelineGameMode comments for how to use each value.
*/
//go:nosplit
func (self class) SetTimelineGameMode(mode TimelineGameMode) { //gd:Steam.setTimelineGameMode
	var frame = callframe.New()
	callframe.Arg(frame, mode)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setTimelineGameMode, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Sets a description for the current game state in the timeline. These help the user to find specific moments in the timeline when saving clips. Setting a new state description replaces any previous description.
*/
//go:nosplit
func (self class) SetTimelineTooltip(description String.Readable, time_delta float64) { //gd:Steam.setTimelineTooltip
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(description)))
	callframe.Arg(frame, time_delta)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setTimelineTooltip, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Use this to start a game phase. Game phases allow the user to navigate their background recordings and clips. Exactly what a game phase means will vary game to game, but the game phase should be a section of gameplay that is usually between 10 minutes and a few hours in length, and should be the main way a user would think to divide up the game. These are presented to the user in a UI that shows the date the game was played, with one row per game slice. Game phases should be used to mark sections of gameplay that the user might be interested in watching.
*/
//go:nosplit
func (self class) StartGamePhase() { //gd:Steam.startGamePhase
	var frame = callframe.New()
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_startGamePhase, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Starts a timeline event at a the current time, plus an offset in seconds. This event must be ended with [method Steam.endRangeTimelineEvent]. Any timeline events that have not been ended when the game exits will be discarded.
*/
//go:nosplit
func (self class) StartRangeTimelineEvent(title String.Readable, description String.Readable, icon String.Readable, priority int64, start_offset_seconds float64, possible_clip TimelineEventClipPriority) int64 { //gd:Steam.startRangeTimelineEvent
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(title)))
	callframe.Arg(frame, pointers.Get(gd.InternalString(description)))
	callframe.Arg(frame, pointers.Get(gd.InternalString(icon)))
	callframe.Arg(frame, priority)
	callframe.Arg(frame, start_offset_seconds)
	callframe.Arg(frame, possible_clip)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_startRangeTimelineEvent, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Updates fields on a range timeline event that was started with StartRangeTimelineEvent, and which has not been ended.
*/
//go:nosplit
func (self class) UpdateRangeTimelineEvent(this_event int64, title String.Readable, description String.Readable, icon String.Readable, priority int64, possible_clip TimelineEventClipPriority) { //gd:Steam.updateRangeTimelineEvent
	var frame = callframe.New()
	callframe.Arg(frame, this_event)
	callframe.Arg(frame, pointers.Get(gd.InternalString(title)))
	callframe.Arg(frame, pointers.Get(gd.InternalString(description)))
	callframe.Arg(frame, pointers.Get(gd.InternalString(icon)))
	callframe.Arg(frame, priority)
	callframe.Arg(frame, possible_clip)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_updateRangeTimelineEvent, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Adds a dependency between the given item and the appid. This list of dependencies can be retrieved by calling [method  Steam.getAppDependencies]. This is a soft-dependency that is displayed on the web. It is up to the application to determine whether the item can actually be used or not.
Triggers a [signal Steam.add_app_dependency_result] callback.
*/
//go:nosplit
func (self class) AddAppDependency(published_file_id int64, app_id int64) { //gd:Steam.addAppDependency
	var frame = callframe.New()
	callframe.Arg(frame, published_file_id)
	callframe.Arg(frame, app_id)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_addAppDependency, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Add a content descriptor to a piece of UGC.
[b]Note:[/b] Valve has no documentation on this function currently.
*/
//go:nosplit
func (self class) AddContentDescriptor(update_handle int64, descriptor_id int64) bool { //gd:Steam.addContentDescriptor
	var frame = callframe.New()
	callframe.Arg(frame, update_handle)
	callframe.Arg(frame, descriptor_id)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_addContentDescriptor, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Adds a workshop item as a dependency to the specified item. If the published_file_id item is of type WORKSHOP_FILE_TYPE_COLLECTION (2), than the child_published_file_id is simply added to that collection. Otherwise, the dependency is a soft one that is displayed on the web and can be retrieved via the UGC API using a combination of the [b]children[/b] key returned from [method Steam.getQueryUGCResult] and [method Steam.getQueryUGCChildren].
Triggers a [signal Steam.add_ugc_dependency_result] callback.
*/
//go:nosplit
func (self class) AddDependency(published_file_id int64, child_published_file_id int64) { //gd:Steam.addDependency
	var frame = callframe.New()
	callframe.Arg(frame, published_file_id)
	callframe.Arg(frame, child_published_file_id)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_addDependency, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Adds a excluded tag to a pending UGC Query. This will only return UGC without the specified tag.
[b]Note:[/b] This must be set before you send a UGC Query handle using [method Steam.sendQueryUGCRequest].
*/
//go:nosplit
func (self class) AddExcludedTag(query_handle int64, tag_name String.Readable) bool { //gd:Steam.addExcludedTag
	var frame = callframe.New()
	callframe.Arg(frame, query_handle)
	callframe.Arg(frame, pointers.Get(gd.InternalString(tag_name)))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_addExcludedTag, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Adds a key-value tag pair to an item. Keys can map to multiple different values (1-to-many relationship).
Key names are restricted to alphanumeric characters and the '_' character.
Both keys and values cannot exceed 255 characters in length.
Key-value tags are searchable by exact match only.
[b]Note:[/b] This must be set before you submit the UGC update handle using [method Steam.submitItemUpdate].
*/
//go:nosplit
func (self class) AddItemKeyValueTag(query_handle int64, key String.Readable, value String.Readable) bool { //gd:Steam.addItemKeyValueTag
	var frame = callframe.New()
	callframe.Arg(frame, query_handle)
	callframe.Arg(frame, pointers.Get(gd.InternalString(key)))
	callframe.Arg(frame, pointers.Get(gd.InternalString(value)))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_addItemKeyValueTag, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Adds an additional preview file for the item.
Then the format of the image should be one that both the web and the application (if necessary) can render, and must be under 1MB. Suggested formats include JPG, PNG and GIF.
[b]Note:[/b] Using 1 or 2 in type are not currently supported with this API. For YouTube videos you should use [method Steam.addItemPreviewVideo].
[b]Note:[/b] This must be set before you submit the UGC update handle using [method Steam.submitItemUpdate].
*/
//go:nosplit
func (self class) AddItemPreviewFile(query_handle int64, preview_file String.Readable, atype ItemPreviewType) bool { //gd:Steam.addItemPreviewFile
	var frame = callframe.New()
	callframe.Arg(frame, query_handle)
	callframe.Arg(frame, pointers.Get(gd.InternalString(preview_file)))
	callframe.Arg(frame, atype)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_addItemPreviewFile, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Adds an additional video preview from YouTube for the item.
[b]Note:[/b] This must be set before you submit the UGC update handle using [method Steam.submitItemUpdate](/functions/ugc/#submititemupdate).
*/
//go:nosplit
func (self class) AddItemPreviewVideo(query_handle int64, video_id String.Readable) bool { //gd:Steam.addItemPreviewVideo
	var frame = callframe.New()
	callframe.Arg(frame, query_handle)
	callframe.Arg(frame, pointers.Get(gd.InternalString(video_id)))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_addItemPreviewVideo, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Adds a workshop item to the users favorites list.
Triggers a [signal Steam.user_favorite_items_list_changed] callback.
*/
//go:nosplit
func (self class) AddItemToFavorites(app_id int64, published_file_id int64) { //gd:Steam.addItemToFavorites
	var frame = callframe.New()
	callframe.Arg(frame, app_id)
	callframe.Arg(frame, published_file_id)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_addItemToFavorites, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Adds a required key-value tag to a pending UGC Query. This will only return workshop items that have a key and a value.
[b]Note:[/b] This must be set before you submit the UGC update handle using [method Steam.submitItemUpdate].
*/
//go:nosplit
func (self class) AddRequiredKeyValueTag(query_handle int64, key String.Readable, value String.Readable) bool { //gd:Steam.addRequiredKeyValueTag
	var frame = callframe.New()
	callframe.Arg(frame, query_handle)
	callframe.Arg(frame, pointers.Get(gd.InternalString(key)))
	callframe.Arg(frame, pointers.Get(gd.InternalString(value)))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_addRequiredKeyValueTag, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Adds a required tag to a pending UGC Query. This will only return UGC with the specified tag.
[b]Note:[/b] This must be set before you submit the UGC update handle using [method Steam.submitItemUpdate].
*/
//go:nosplit
func (self class) AddRequiredTag(query_handle int64, tag_name String.Readable) bool { //gd:Steam.addRequiredTag
	var frame = callframe.New()
	callframe.Arg(frame, query_handle)
	callframe.Arg(frame, pointers.Get(gd.InternalString(tag_name)))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_addRequiredTag, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Adds the requirement that the returned items from the pending UGC Query have at least one of the tags in the given set (logical "or"). For each tag group that is added, at least one tag from each group is required to be on the matching items.
[b]Note:[/b] This must be set before you submit the UGC update handle using [method Steam.submitItemUpdate].
*/
//go:nosplit
func (self class) AddRequiredTagGroup(query_handle int64, tag_array Array.Any) bool { //gd:Steam.addRequiredTagGroup
	var frame = callframe.New()
	callframe.Arg(frame, query_handle)
	callframe.Arg(frame, pointers.Get(gd.InternalArray(tag_array)))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_addRequiredTagGroup, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Lets game servers set a specific workshop folder before issuing any UGC commands.
This is helpful if you want to support multiple game servers running out of the same install folder.
*/
//go:nosplit
func (self class) InitWorkshopForGameServer(workshop_depot_id int64, folder String.Readable) bool { //gd:Steam.initWorkshopForGameServer
	var frame = callframe.New()
	callframe.Arg(frame, workshop_depot_id)
	callframe.Arg(frame, pointers.Get(gd.InternalString(folder)))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_initWorkshopForGameServer, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Creates a new workshop item with no content attached yet.
Triggers a [signal Steam.item_created] callback.
*/
//go:nosplit
func (self class) CreateItem(app_id int64, file_type WorkshopFileType) { //gd:Steam.createItem
	var frame = callframe.New()
	callframe.Arg(frame, app_id)
	callframe.Arg(frame, file_type)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_createItem, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Query for all matching UGC. You can use this to list all of the available UGC for your app.
This will return up to 50 results. You can make subsequent calls to this function, increasing the page each time to get the next set of results.
To query for the UGC associated with a single user you can use [method Steam.createQueryUserUGCRequest] instead.
[b]Note:[/b] Either consumer_id or creator_id must have a valid app ID.
[b]Note:[/b] You must release the handle returned by this function by calling [method Steam.releaseQueryUGCRequest] when you are done with it.
*/
//go:nosplit
func (self class) CreateQueryAllUGCRequest(query_type UGCQuery, matching_type UGCMatchingUGCType, creator_id int64, consumer_id int64, page int64) int64 { //gd:Steam.createQueryAllUGCRequest
	var frame = callframe.New()
	callframe.Arg(frame, query_type)
	callframe.Arg(frame, matching_type)
	callframe.Arg(frame, creator_id)
	callframe.Arg(frame, consumer_id)
	callframe.Arg(frame, page)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_createQueryAllUGCRequest, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Query for the details of specific workshop items.
This will return up to 50 results.
To query all the UGC for your app you can use [method Steam.createQueryAllUGCRequest] instead.
[b]Note:[/b] Either consumer_id or creator_id must have a valid app ID.
[b]Note:[/b] You must release the handle returned by this function by calling [method Steam.releaseQueryUGCRequest] when you are done with it.
*/
//go:nosplit
func (self class) CreateQueryUGCDetailsRequest(published_file_id Array.Any) int64 { //gd:Steam.createQueryUGCDetailsRequest
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalArray(published_file_id)))
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_createQueryUGCDetailsRequest, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Query UGC associated with a user. You can use this to list the UGC the user is subscribed to amongst other things.
This will return up to 50 results.
To query all the UGC for your app you can use [method Steam.createQueryAllUGCRequest] instead.
[b]Note:[/b] Either consumer_id or creator_id must have a valid app ID.
[b]Note:[/b] You must release the handle returned by this function by calling [method Steam.releaseQueryUGCRequest] when you are done with it.
*/
//go:nosplit
func (self class) CreateQueryUserUGCRequest(account_id int64, list_type UserUGCList, matching_ugc_type UGCMatchingUGCType, sort_order UserUGCListSortOrder, creator_id int64, consumer_id int64, page int64) int64 { //gd:Steam.createQueryUserUGCRequest
	var frame = callframe.New()
	callframe.Arg(frame, account_id)
	callframe.Arg(frame, list_type)
	callframe.Arg(frame, matching_ugc_type)
	callframe.Arg(frame, sort_order)
	callframe.Arg(frame, creator_id)
	callframe.Arg(frame, consumer_id)
	callframe.Arg(frame, page)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_createQueryUserUGCRequest, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Deletes the item without prompting the user.
Triggers a [signal Steam.item_deleted] callback.
*/
//go:nosplit
func (self class) DeleteItem(published_file_id int64) { //gd:Steam.deleteItem
	var frame = callframe.New()
	callframe.Arg(frame, published_file_id)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_deleteItem, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Download new or update already installed item.
If the return value is true then register and wait for the callback [signal Steam.item_downloaded] before calling [method Steam.getItemInstallInfo] or accessing the workshop item on disk.
If the user is not subscribed to the item (e.g. a Game Server using anonymous login), the workshop item will be downloaded and cached temporarily.
If the workshop item has an item state of 8, then this function can be called to initiate the update. Do not access the workshop item on disk until the callback [signal Steam.item_downloaded] is called.
*/
//go:nosplit
func (self class) DownloadItem(published_file_id int64, high_priority bool) bool { //gd:Steam.downloadItem
	var frame = callframe.New()
	callframe.Arg(frame, published_file_id)
	callframe.Arg(frame, high_priority)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_downloadItem, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Get info about a pending download of a workshop item that has 8 set.
The returned dictionary contains the following keys:
[codeblock]
┠╴ret (bool)
┠╴downloaded (int)
┖╴total (int)
[/codeblock]
*/
//go:nosplit
func (self class) GetItemDownloadInfo(published_file_id int64) Dictionary.Any { //gd:Steam.getItemDownloadInfo
	var frame = callframe.New()
	callframe.Arg(frame, published_file_id)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getItemDownloadInfo, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Gets info about currently installed content on the disc for workshop items that have k_EItemStateInstalled (4) set.
Calling this sets the "used" flag on the workshop item for the current player and adds it to their k_EUserUGCList_UsedOrPlayed (7) list.
If k_EItemStateLegacyItem (2) is set then folder contains the path to the legacy file itself, not a folder.
The returned dictionary contains the following keys:
[codeblock]
┠╴ret (bool)
┠╴size (int)
┠╴folder (string)
┖╴timestamp (int)
[/codeblock]
*/
//go:nosplit
func (self class) GetItemInstallInfo(published_file_id int64) Dictionary.Any { //gd:Steam.getItemInstallInfo
	var frame = callframe.New()
	callframe.Arg(frame, published_file_id)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getItemInstallInfo, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Gets the current state of a workshop item on this client.
It should be one of the following:
[codeblock]
• 0 / None
• 1 / Subscribed
• 2 / Legacy
• 4 / Installed
• 8 / Update
• 16 / Downloading
• 32 / Pending
[/codeblock]
*/
//go:nosplit
func (self class) GetItemState(published_file_id int64) int64 { //gd:Steam.getItemState
	var frame = callframe.New()
	callframe.Arg(frame, published_file_id)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getItemState, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Gets the progress of an item update.
The returned dictionary contains the following keys:
[codeblock]
┠╴status (int)
┠╴processed (int)
┖╴total (int)
[/codeblock]
*/
//go:nosplit
func (self class) GetItemUpdateProgress(update_handle int64) Dictionary.Any { //gd:Steam.getItemUpdateProgress
	var frame = callframe.New()
	callframe.Arg(frame, update_handle)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getItemUpdateProgress, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Gets the total number of items the current user is subscribed to for the game or application.
*/
//go:nosplit
func (self class) GetNumSubscribedItems() int64 { //gd:Steam.getNumSubscribedItems
	var frame = callframe.New()
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getNumSubscribedItems, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Get the number of supported game versions for this UGC content.
*/
//go:nosplit
func (self class) GetNumSupportedGameVersions(query_handle int64, index int64) int64 { //gd:Steam.getNumSupportedGameVersions
	var frame = callframe.New()
	callframe.Arg(frame, query_handle)
	callframe.Arg(frame, index)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getNumSupportedGameVersions, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Retrieve the details of an additional preview associated with an individual workshop item after receiving a querying UGC call result.
You should call this in a loop to get the details of all the workshop items returned.
Before calling this you should call [method Steam.getQueryUGCNumAdditionalPreviews] to get number of additional previews.
The returned dictionary contains the following keys:
[codeblock]
┠╴success (bool)
┠╴handle (int)
┠╴index (int)
┠╴preview (int)
┠╴url_or_video (string)
┠╴filename (string)
┖╴type (int)
[/codeblock]
[b]Note:[/b] This must only be called with the handle obtained from a successful [signal Steam.ugc_query_completed] call result.
*/
//go:nosplit
func (self class) GetQueryUGCAdditionalPreview(query_handle int64, index int64, preview_index int64) Dictionary.Any { //gd:Steam.getQueryUGCAdditionalPreview
	var frame = callframe.New()
	callframe.Arg(frame, query_handle)
	callframe.Arg(frame, index)
	callframe.Arg(frame, preview_index)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getQueryUGCAdditionalPreview, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Retrieve the IDs of any child items of an individual workshop item after receiving a querying UGC call result. These items can either be a part of a collection or some other dependency (see [method Steam.addDependency]).
You should create published_file_id with num_children provided in returned dictionary after getting the UGC details with [method Steam.getQueryUGCResult].
The returned dictionary contains the following keys:
[codeblock]
┠╴success (bool)
┠╴handle (int)
┠╴index (int)
┖╴children (int)
[/codeblock]
[b]Note:[/b] This must only be called with the handle obtained from a successful [signal Steam.ugc_query_completed] call result.
*/
//go:nosplit
func (self class) GetQueryUGCChildren(query_handle int64, index int64, child_count int64) Dictionary.Any { //gd:Steam.getQueryUGCChildren
	var frame = callframe.New()
	callframe.Arg(frame, query_handle)
	callframe.Arg(frame, index)
	callframe.Arg(frame, child_count)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getQueryUGCChildren, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Get an UGC item's content descriptors for mature content.
The returned dictionary contains the following keys:
[codeblock]
┠╴result (int)
┠╴handle (int)
┠╴index (int)
┖╴descriptors (array)
[/codeblock]
Descriptors array will contain a list of integers that correspond to the following UGC enums for descriptors:
[codeblock]
• 1 / Nudity or sexual content
• 2 / Frequent violence or gore
• 3 / Adult only sexual content
• 4 / Gratuitous sexual content
• 5 / Any mature content
[/codeblock]
[b]Note:[/b] Valve does not have any documentation covering this function at this time.
*/
//go:nosplit
func (self class) GetQueryUGCContentDescriptors(query_handle int64, index int64, max_entries int64) Dictionary.Any { //gd:Steam.getQueryUGCContentDescriptors
	var frame = callframe.New()
	callframe.Arg(frame, query_handle)
	callframe.Arg(frame, index)
	callframe.Arg(frame, max_entries)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getQueryUGCContentDescriptors, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Retrieve the number of key-value tags of an individual workshop item after receiving a querying UGC call result.
You can then call [method Steam.getQueryUGCKeyValueTag] to get the details of each tag.
[b]Note:[/b] This must only be called with the handle obtained from a successful [signal Steam.ugc_query_completed] call result.
*/
//go:nosplit
func (self class) GetQueryUGCKeyValueTag(query_handle int64, index int64, key_value_tag_index int64) Dictionary.Any { //gd:Steam.getQueryUGCKeyValueTag
	var frame = callframe.New()
	callframe.Arg(frame, query_handle)
	callframe.Arg(frame, index)
	callframe.Arg(frame, key_value_tag_index)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getQueryUGCKeyValueTag, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Retrieve the developer set metadata of an individual workshop item after receiving a querying UGC call result.
You should call this in a loop to get the details of all the workshop items returned.
[b]Note:[/b] This must only be called with the handle obtained from a successful [signal Steam.ugc_query_completed] call result.
*/
//go:nosplit
func (self class) GetQueryUGCMetadata(query_handle int64, index int64) String.Readable { //gd:Steam.getQueryUGCMetadata
	var frame = callframe.New()
	callframe.Arg(frame, query_handle)
	callframe.Arg(frame, index)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getQueryUGCMetadata, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Retrieve the number of additional previews of an individual workshop item after receiving a querying UGC call result.
You can then call [method Steam.getQueryUGCAdditionalPreview] to get the details of each additional preview.
[b]Note:[/b] This must only be called with the handle obtained from a successful [signal Steam.ugc_query_completed] call result.
*/
//go:nosplit
func (self class) GetQueryUGCNumAdditionalPreviews(query_handle int64, index int64) int64 { //gd:Steam.getQueryUGCNumAdditionalPreviews
	var frame = callframe.New()
	callframe.Arg(frame, query_handle)
	callframe.Arg(frame, index)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getQueryUGCNumAdditionalPreviews, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Retrieve the number of key-value tags of an individual workshop item after receiving a querying UGC call result.
You can then call [method Steam.getQueryUGCKeyValueTag] to get the details of each tag.
[b]Note:[/b] This must only be called with the handle obtained from a successful [signal Steam.ugc_query_completed] call result.
*/
//go:nosplit
func (self class) GetQueryUGCNumKeyValueTags(query_handle int64, index int64) int64 { //gd:Steam.getQueryUGCNumKeyValueTags
	var frame = callframe.New()
	callframe.Arg(frame, query_handle)
	callframe.Arg(frame, index)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getQueryUGCNumKeyValueTags, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Available in SDK v1.51.
Retrieve the number of tags for an individual workshop item after receiving a querying UGC call result.
You can then call [method Steam.getQueryUGCTag] to get the tag name or [method Steam.getQueryUGCTagDisplayName] to get the localized tag string (if any).
[b]Note:[/b] This must only be called with the handle obtained from a successful [signal Steam.ugc_query_completed] call result.
*/
//go:nosplit
func (self class) GetQueryUGCNumTags(query_handle int64, index int64) int64 { //gd:Steam.getQueryUGCNumTags
	var frame = callframe.New()
	callframe.Arg(frame, query_handle)
	callframe.Arg(frame, index)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getQueryUGCNumTags, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Retrieve the URL to the preview image of an individual workshop item after receiving a querying UGC call result.
You can use this URL to download and display the preview image instead of having to download it using the handle_preview_file key in the return dictionary from [method Steam.getQueryUGCResult].
[b]Note:[/b] This must only be called with the handle obtained from a successful [signal Steam.ugc_query_completed] call result.
*/
//go:nosplit
func (self class) GetQueryUGCPreviewURL(query_handle int64, index int64) String.Readable { //gd:Steam.getQueryUGCPreviewURL
	var frame = callframe.New()
	callframe.Arg(frame, query_handle)
	callframe.Arg(frame, index)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getQueryUGCPreviewURL, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Retrieve the details of an individual workshop item after receiving a querying UGC call result.
The returned dictionary contains the following keys:
[codeblock]
┠╴result (int)
┠╴file_id (int)
┠╴file_type (int)
┠╴creator_app_id (int)
┠╴consumer_app_id (int)
┠╴title (string)
┠╴description (string)
┠╴steam_id_owner (int)
┠╴time_created (int)
┠╴time_updated (int)
┠╴time_added_to_user_list (int)
┠╴visibility (int)
┠╴banned (bool)
┠╴accepted_for_use (bool)
┠╴tags_truncated (bool)
┠╴tags (string)
┠╴handle_file (int)
┠╴handle_preview-file (int)
┠╴file_name (string)
┠╴file_size (int)
┠╴preview_file_size (int)
┠╴url (string)
┠╴votes_up (int)
┠╴votes_down (int)
┠╴score (float)
┖╴num_children (int)
[/codeblock]
[b]Note:[/b] This must only be called with the handle obtained from a successful [signal Steam.ugc_query_completed] call result.
*/
//go:nosplit
func (self class) GetQueryUGCResult(query_handle int64, index int64) Dictionary.Any { //gd:Steam.getQueryUGCResult
	var frame = callframe.New()
	callframe.Arg(frame, query_handle)
	callframe.Arg(frame, index)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getQueryUGCResult, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Retrieve various statistics of an individual workshop item after receiving a querying UGC call result.
The returned dictionary contains the following keys:
[codeblock]
┠╴success (bool)
┠╴handle (int)
┠╴index (int)
┠╴type (int)
┖╴value (int)
[/codeblock]
[b]Note:[/b] This must only be called with the handle obtained from a successful [signal Steam.ugc_query_completed] call result.
*/
//go:nosplit
func (self class) GetQueryUGCStatistic(query_handle int64, index int64, stat_type ItemStatistic) Dictionary.Any { //gd:Steam.getQueryUGCStatistic
	var frame = callframe.New()
	callframe.Arg(frame, query_handle)
	callframe.Arg(frame, index)
	callframe.Arg(frame, stat_type)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getQueryUGCStatistic, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Available in SDK v1.51.
Retrieve the "nth" tag associated with an individual workshop item after receiving a querying UGC call result.
Before calling this you should call [method Steam.getQueryUGCNumTags] to get number of tags.
[b]Note:[/b] This must only be called with the handle obtained from a successful [signal Steam.ugc_query_completed] call result.
*/
//go:nosplit
func (self class) GetQueryUGCTag(query_handle int64, index int64, tag_index int64) String.Readable { //gd:Steam.getQueryUGCTag
	var frame = callframe.New()
	callframe.Arg(frame, query_handle)
	callframe.Arg(frame, index)
	callframe.Arg(frame, tag_index)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getQueryUGCTag, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Available in SDK v1.51.
Retrieve the "nth" display string (usually localized) for a tag, which is associated with an individual workshop item after receiving a querying UGC call result.
Before calling this you should call [method Steam.getQueryUGCNumTags] to get number of tags.
[b]Note:[/b] This must only be called with the handle obtained from a successful [signal Steam.ugc_query_completed] call result.
*/
//go:nosplit
func (self class) GetQueryUGCTagDisplayName(query_handle int64, index int64, tag_index int64) String.Readable { //gd:Steam.getQueryUGCTagDisplayName
	var frame = callframe.New()
	callframe.Arg(frame, query_handle)
	callframe.Arg(frame, index)
	callframe.Arg(frame, tag_index)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getQueryUGCTagDisplayName, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Gets a list of all of the items the current user is subscribed to for the current game.
*/
//go:nosplit
func (self class) GetSubscribedItems() Array.Any { //gd:Steam.getSubscribedItems
	var frame = callframe.New()
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getSubscribedItems, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Array.Through(gd.ArrayProxy[variant.Any]{}, pointers.Pack(pointers.New[gd.Array](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Some items can specify that they have a version that is valid for a range of game versions (Steam branch).
[codeblock]
┠╴min (string)
┠╴max (string)
┖╴size (uint32)
[/codeblock]
*/
//go:nosplit
func (self class) GetSupportedGameVersionData(query_handle int64, index int64, version_index int64) Dictionary.Any { //gd:Steam.getSupportedGameVersionData
	var frame = callframe.New()
	callframe.Arg(frame, query_handle)
	callframe.Arg(frame, index)
	callframe.Arg(frame, version_index)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getSupportedGameVersionData, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Return the user's community content descriptor preferences.
*/
//go:nosplit
func (self class) GetUserContentDescriptorPreferences(max_entries int64) Array.Any { //gd:Steam.getUserContentDescriptorPreferences
	var frame = callframe.New()
	callframe.Arg(frame, max_entries)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getUserContentDescriptorPreferences, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Array.Through(gd.ArrayProxy[variant.Any]{}, pointers.Pack(pointers.New[gd.Array](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Gets the users vote status on a workshop item.
Triggers a [signal Steam.get_item_vote_result]( callback.
*/
//go:nosplit
func (self class) GetUserItemVote(published_file_id int64) { //gd:Steam.getUserItemVote
	var frame = callframe.New()
	callframe.Arg(frame, published_file_id)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getUserItemVote, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Releases a UGC query handle when you are done with it to free up memory.
*/
//go:nosplit
func (self class) ReleaseQueryUGCRequest(query_handle int64) bool { //gd:Steam.releaseQueryUGCRequest
	var frame = callframe.New()
	callframe.Arg(frame, query_handle)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_releaseQueryUGCRequest, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Removes the dependency between the given item and the appid. This list of dependencies can be retrieved by calling [method Steam.getAppDependencies].
Triggers a [signal Steam.remove_app_dependency_result] callback.
*/
//go:nosplit
func (self class) RemoveAppDependency(published_file_id int64, app_id int64) { //gd:Steam.removeAppDependency
	var frame = callframe.New()
	callframe.Arg(frame, published_file_id)
	callframe.Arg(frame, app_id)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_removeAppDependency, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Removes a mature content descriptor from a piece of UGC.
[b]Note:[/b] Valve has no documentation on this function currently.
*/
//go:nosplit
func (self class) RemoveContentDescriptor(update_handle int64, descriptor_id int64) bool { //gd:Steam.removeContentDescriptor
	var frame = callframe.New()
	callframe.Arg(frame, update_handle)
	callframe.Arg(frame, descriptor_id)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_removeContentDescriptor, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Removes a workshop item as a dependency from the specified item.
Triggers a [signal Steam.remove_ugc_dependency_result] callback.
*/
//go:nosplit
func (self class) RemoveDependency(published_file_id int64, child_published_file_id int64) { //gd:Steam.removeDependency
	var frame = callframe.New()
	callframe.Arg(frame, published_file_id)
	callframe.Arg(frame, child_published_file_id)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_removeDependency, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Removes a workshop item from the users favorites list.
Triggers a [signal Steam.user_favorite_items_list_changed]callback.
*/
//go:nosplit
func (self class) RemoveItemFromFavorites(app_id int64, published_file_id int64) { //gd:Steam.removeItemFromFavorites
	var frame = callframe.New()
	callframe.Arg(frame, app_id)
	callframe.Arg(frame, published_file_id)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_removeItemFromFavorites, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Removes an existing key value tag from an item.
You can only call this up to 100 times per item update. If you need remove more tags than that you'll need to make subsequent item updates.
[b]Note:[/b] This must be set before you submit the UGC update handle using [method Steam.submitItemUpdate].
*/
//go:nosplit
func (self class) RemoveItemKeyValueTags(update_handle int64, key String.Readable) bool { //gd:Steam.removeItemKeyValueTags
	var frame = callframe.New()
	callframe.Arg(frame, update_handle)
	callframe.Arg(frame, pointers.Get(gd.InternalString(key)))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_removeItemKeyValueTags, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Removes an existing preview from an item.
*/
//go:nosplit
func (self class) RemoveItemPreview(update_handle int64, index int64) bool { //gd:Steam.removeItemPreview
	var frame = callframe.New()
	callframe.Arg(frame, update_handle)
	callframe.Arg(frame, index)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_removeItemPreview, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Send a UGC query to Steam.
This must be called with a handle obtained from [method Steam.createQueryUserUGCRequest], [method Steam.createQueryAllUGCRequest], or [method Steam.createQueryUGCDetailsRequest] to actually send the request to Steam.
Before calling this you should use one or more of the following APIs to customize your query: [method Steam.addRequiredTag], [method Steam.addExcludedTag], [method Steam.setReturnOnlyIDs], [method Steam.setReturnKeyValueTags], [method Steam.setReturnLongDescription], [method Steam.setReturnMetadata], [method Steam.setReturnChildren], [method Steam.setReturnAdditionalPreviews], [method Steam.setReturnTotalOnly], [method Steam.setLanguage], [method Steam.setAllowCachedResponse], [method Steam.setCloudFileNameFilter], [method Steam.setMatchAnyTag], [method Steam.setSearchText], [method Steam.setRankedByTrendDays], or [method Steam.addRequiredKeyValueTag].
Triggers a [signal Steam.ugc_query_completed] callback.
*/
//go:nosplit
func (self class) SendQueryUGCRequest(update_handle int64) { //gd:Steam.sendQueryUGCRequest
	var frame = callframe.New()
	callframe.Arg(frame, update_handle)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_sendQueryUGCRequest, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Admin queries return hidden items.
*/
//go:nosplit
func (self class) SetAdminQuery(update_handle int64, admin_query bool) bool { //gd:Steam.setAdminQuery
	var frame = callframe.New()
	callframe.Arg(frame, update_handle)
	callframe.Arg(frame, admin_query)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setAdminQuery, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Sets whether results will be returned from the cache for the specific period of time on a pending UGC Query.
*/
//go:nosplit
func (self class) SetAllowCachedResponse(update_handle int64, max_age_seconds int64) bool { //gd:Steam.setAllowCachedResponse
	var frame = callframe.New()
	callframe.Arg(frame, update_handle)
	callframe.Arg(frame, max_age_seconds)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setAllowCachedResponse, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Sets to only return items that have a specific filename on a pending UGC Query.
[b]Note:[/b] This can only be used with [method Steam.createQueryUserUGCRequest].
[b]Note:[/b] This must be set before you send a UGC Query handle using [method Steam.sendQueryUGCRequest].
*/
//go:nosplit
func (self class) SetCloudFileNameFilter(update_handle int64, match_cloud_filename String.Readable) bool { //gd:Steam.setCloudFileNameFilter
	var frame = callframe.New()
	callframe.Arg(frame, update_handle)
	callframe.Arg(frame, pointers.Get(gd.InternalString(match_cloud_filename)))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setCloudFileNameFilter, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Sets the folder that will be stored as the content for an item.
For efficient upload and download, files should not be merged or compressed into single files (e.g. zip files).
[b]Note:[/b] This must be set before you submit the UGC update handle using [method Steam.submitItemUpdate].
*/
//go:nosplit
func (self class) SetItemContent(update_handle int64, content_folder String.Readable) bool { //gd:Steam.setItemContent
	var frame = callframe.New()
	callframe.Arg(frame, update_handle)
	callframe.Arg(frame, pointers.Get(gd.InternalString(content_folder)))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setItemContent, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Sets a new description for an item.
The description must be limited to the length defined by k_cchPublishedDocumentDescriptionMax (8000).
You can set what language this is for by using [method Steam.setItemUpdateLanguage], if no language is set then "english" is assumed.
[b]Note:[/b] This must be set before you submit the UGC update handle using [method Steam.submitItemUpdate].
*/
//go:nosplit
func (self class) SetItemDescription(update_handle int64, description String.Readable) bool { //gd:Steam.setItemDescription
	var frame = callframe.New()
	callframe.Arg(frame, update_handle)
	callframe.Arg(frame, pointers.Get(gd.InternalString(description)))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setItemDescription, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Sets arbitrary metadata for an item. This metadata can be returned from queries without having to download and install the actual content.
The metadata must be limited to the size defined by k_cchDeveloperMetadataMax (5000).
[b]Note:[/b] This must be set before you submit the UGC update handle using [method Steam.submitItemUpdate].
*/
//go:nosplit
func (self class) SetItemMetadata(update_handle int64, ugc_metadata String.Readable) bool { //gd:Steam.setItemMetadata
	var frame = callframe.New()
	callframe.Arg(frame, update_handle)
	callframe.Arg(frame, pointers.Get(gd.InternalString(ugc_metadata)))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setItemMetadata, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Sets the primary preview image for the item.
The format should be one that both the web and the application (if necessary) can render. Suggested formats include JPG, PNG and GIF.
[b]Note:[/b] This must be set before you submit the UGC update handle using [method Steam.submitItemUpdate].
*/
//go:nosplit
func (self class) SetItemPreview(update_handle int64, preview_file String.Readable) bool { //gd:Steam.setItemPreview
	var frame = callframe.New()
	callframe.Arg(frame, update_handle)
	callframe.Arg(frame, pointers.Get(gd.InternalString(preview_file)))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setItemPreview, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Sets arbitrary developer specified tags on an item.
Each tag must be limited to 255 characters. Tag names can only include printable characters, excluding ','.
[b]Note:[/b] This must be set before you submit the UGC update handle using [method Steam.submitItemUpdate].
*/
//go:nosplit
func (self class) SetItemTags(update_handle int64, tag_array Array.Any, allow_admin_tags bool) bool { //gd:Steam.setItemTags
	var frame = callframe.New()
	callframe.Arg(frame, update_handle)
	callframe.Arg(frame, pointers.Get(gd.InternalArray(tag_array)))
	callframe.Arg(frame, allow_admin_tags)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setItemTags, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Sets a new title for an item.
The title must be limited to the size defined by k_cchPublishedDocumentTitleMax (128).
You can set what language this is for by using [method Steam.setItemUpdateLanguage], if no language is set then "english" is assumed.
[b]Note:[/b] This must be set before you submit the UGC update handle using [method Steam.submitItemUpdate].
*/
//go:nosplit
func (self class) SetItemTitle(update_handle int64, title String.Readable) bool { //gd:Steam.setItemTitle
	var frame = callframe.New()
	callframe.Arg(frame, update_handle)
	callframe.Arg(frame, pointers.Get(gd.InternalString(title)))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setItemTitle, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Sets the language of the title and description that will be set in this item update.
This must be in the format of the API language code.
If this is not set then "english" is assumed.
[b]Note:[/b] This must be set before you submit the UGC update handle using [method Steam.submitItemUpdate].
*/
//go:nosplit
func (self class) SetItemUpdateLanguage(update_handle int64, language String.Readable) bool { //gd:Steam.setItemUpdateLanguage
	var frame = callframe.New()
	callframe.Arg(frame, update_handle)
	callframe.Arg(frame, pointers.Get(gd.InternalString(language)))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setItemUpdateLanguage, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Sets the visibility of an item.
*/
//go:nosplit
func (self class) SetItemVisibility(update_handle int64, visibility RemoteStoragePublishedFileVisibility) bool { //gd:Steam.setItemVisibility
	var frame = callframe.New()
	callframe.Arg(frame, update_handle)
	callframe.Arg(frame, visibility)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setItemVisibility, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Sets the language to return the title and description in for the items on a pending UGC Query.
This must be in the format of the API language code.
If this is not set then "english" is assumed.
[b]Note:[/b] This must be set before you submit the UGC query handle using [method Steam.submitItemUpdate].
*/
//go:nosplit
func (self class) SetLanguage(query_handle int64, language String.Readable) bool { //gd:Steam.setLanguage
	var frame = callframe.New()
	callframe.Arg(frame, query_handle)
	callframe.Arg(frame, pointers.Get(gd.InternalString(language)))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setLanguage, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Sets whether workshop items will be returned if they have one or more matching tag, or if all tags need to match on a pending UGC Query.
[b]Note:[/b] This can only be used with [method Steam.createQueryAllUGCRequest].
[b]Note:[/b] This must be set before you submit the UGC query handle using [method Steam.submitItemUpdate].
*/
//go:nosplit
func (self class) SetMatchAnyTag(query_handle int64, match_any_tag bool) bool { //gd:Steam.setMatchAnyTag
	var frame = callframe.New()
	callframe.Arg(frame, query_handle)
	callframe.Arg(frame, match_any_tag)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setMatchAnyTag, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Sets whether the order of the results will be updated based on the rank of items over a number of days on a pending UGC Query.
[b]Note:[/b] This can only be used with [method Steam.createQueryAllUGCRequest].
[b]Note:[/b] This must be set before you submit the UGC query handle using [method Steam.submitItemUpdate].
*/
//go:nosplit
func (self class) SetRankedByTrendDays(query_handle int64, days int64) bool { //gd:Steam.setRankedByTrendDays
	var frame = callframe.New()
	callframe.Arg(frame, query_handle)
	callframe.Arg(frame, days)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setRankedByTrendDays, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
An empty string for either parameter means that it will match any version on that end of the range. This will only be applied if the actual content has been changed.
*/
//go:nosplit
func (self class) SetRequiredGameVersions(query_handle int64, game_branch_min String.Readable, game_branch_max String.Readable) bool { //gd:Steam.setRequiredGameVersions
	var frame = callframe.New()
	callframe.Arg(frame, query_handle)
	callframe.Arg(frame, pointers.Get(gd.InternalString(game_branch_min)))
	callframe.Arg(frame, pointers.Get(gd.InternalString(game_branch_max)))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setRequiredGameVersions, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Sets whether to return any additional images/videos attached to the items on a pending UGC Query.
[b]Note:[/b] This must be set before you submit the UGC query handle using [method Steam.submitItemUpdate].
*/
//go:nosplit
func (self class) SetReturnAdditionalPreviews(query_handle int64, return_additional_previews bool) bool { //gd:Steam.setReturnAdditionalPreviews
	var frame = callframe.New()
	callframe.Arg(frame, query_handle)
	callframe.Arg(frame, return_additional_previews)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setReturnAdditionalPreviews, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Sets whether to return the IDs of the child items of the items on a pending UGC Query.
[b]Note:[/b] This must be set before you submit the UGC query handle using [method Steam.submitItemUpdate].
*/
//go:nosplit
func (self class) SetReturnChildren(query_handle int64, return_children bool) bool { //gd:Steam.setReturnChildren
	var frame = callframe.New()
	callframe.Arg(frame, query_handle)
	callframe.Arg(frame, return_children)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setReturnChildren, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Sets whether to return any key-value tags for the items on a pending UGC Query.
[b]Note:[/b] This must be set before you submit the UGC query handle using [method Steam.submitItemUpdate].
*/
//go:nosplit
func (self class) SetReturnKeyValueTags(query_handle int64, return_key_value_tags bool) bool { //gd:Steam.setReturnKeyValueTags
	var frame = callframe.New()
	callframe.Arg(frame, query_handle)
	callframe.Arg(frame, return_key_value_tags)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setReturnKeyValueTags, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Sets whether to return the full description for the items on a pending UGC Query.
If you don't set this then you only receive the summary which is the description truncated at 255 bytes.
[b]Note:[/b] This must be set before you submit the UGC query handle using [method Steam.submitItemUpdate].
*/
//go:nosplit
func (self class) SetReturnLongDescription(query_handle int64, return_long_description bool) bool { //gd:Steam.setReturnLongDescription
	var frame = callframe.New()
	callframe.Arg(frame, query_handle)
	callframe.Arg(frame, return_long_description)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setReturnLongDescription, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Sets whether to return the developer specified metadata for the items on a pending UGC Query.
[b]Note:[/b] This must be set before you submit the UGC query handle using [method Steam.submitItemUpdate].
*/
//go:nosplit
func (self class) SetReturnMetadata(query_handle int64, return_metadata bool) bool { //gd:Steam.setReturnMetadata
	var frame = callframe.New()
	callframe.Arg(frame, query_handle)
	callframe.Arg(frame, return_metadata)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setReturnMetadata, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Sets whether to only return IDs instead of all the details on a pending UGC Query.
This is useful for when you don't need all the information (e.g. you just want to get the IDs of the items a user has in their favorites list.)
[b]Note:[/b] This must be set before you submit the UGC query handle using [method Steam.submitItemUpdate].
*/
//go:nosplit
func (self class) SetReturnOnlyIDs(query_handle int64, return_only_ids bool) bool { //gd:Steam.setReturnOnlyIDs
	var frame = callframe.New()
	callframe.Arg(frame, query_handle)
	callframe.Arg(frame, return_only_ids)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setReturnOnlyIDs, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Sets whether to return the the playtime stats on a pending UGC Query.
[b]Note:[/b] This must be set before you submit the UGC query handle using [method Steam.submitItemUpdate].
*/
//go:nosplit
func (self class) SetReturnPlaytimeStats(query_handle int64, days int64) bool { //gd:Steam.setReturnPlaytimeStats
	var frame = callframe.New()
	callframe.Arg(frame, query_handle)
	callframe.Arg(frame, days)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setReturnPlaytimeStats, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Sets whether to only return the the total number of matching items on a pending UGC Query.
The actual items will not be returned when [signal Steam.ugc_query_completed] is called.
[b]Note:[/b] This must be set before you submit the UGC query handle using [method Steam.submitItemUpdate].
*/
//go:nosplit
func (self class) SetReturnTotalOnly(query_handle int64, return_total_only bool) bool { //gd:Steam.setReturnTotalOnly
	var frame = callframe.New()
	callframe.Arg(frame, query_handle)
	callframe.Arg(frame, return_total_only)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setReturnTotalOnly, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Sets a string to that items need to match in either the title or the description on a pending UGC Query.
[b]Note:[/b] This can only be used with [method Steam.createQueryAllUGCRequest].
[b]Note:[/b] This must be set before you submit the UGC query handle using [method Steam.submitItemUpdate].
*/
//go:nosplit
func (self class) SetSearchText(query_handle int64, search_text String.Readable) bool { //gd:Steam.setSearchText
	var frame = callframe.New()
	callframe.Arg(frame, query_handle)
	callframe.Arg(frame, pointers.Get(gd.InternalString(search_text)))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setSearchText, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Allows the user to rate a workshop item up or down.
Triggers a [signal Steam.set_user_item_vote] callback.
*/
//go:nosplit
func (self class) SetUserItemVote(published_file_id int64, vote_up bool) { //gd:Steam.setUserItemVote
	var frame = callframe.New()
	callframe.Arg(frame, published_file_id)
	callframe.Arg(frame, vote_up)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setUserItemVote, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Starts the item update process.
This gets you a handle that you can use to modify the item before finally sending off the update to the server with [method Steam.submitItemUpdate].
*/
//go:nosplit
func (self class) StartItemUpdate(app_id int64, file_id int64) int64 { //gd:Steam.startItemUpdate
	var frame = callframe.New()
	callframe.Arg(frame, app_id)
	callframe.Arg(frame, file_id)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_startItemUpdate, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Start tracking playtime on a set of workshop items.
When your app shuts down, playtime tracking will automatically stop.
Triggers a [signal Steam.start_playtime_tracking] callback.
*/
//go:nosplit
func (self class) StartPlaytimeTracking(published_file_ids Array.Any) { //gd:Steam.startPlaytimeTracking
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalArray(published_file_ids)))
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_startPlaytimeTracking, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Stop tracking playtime on a set of workshop items.
When your app shuts down, playtime tracking will automatically stop.
Triggers a [signal Steam.stop_playtime_tracking] callback.
*/
//go:nosplit
func (self class) StopPlaytimeTracking(published_file_ids Array.Any) { //gd:Steam.stopPlaytimeTracking
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalArray(published_file_ids)))
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_stopPlaytimeTracking, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Stop tracking playtime of all workshop items.
When your app shuts down, playtime tracking will automatically stop.
Triggers a [signal Steam.stop_playtime_tracking] callback.
*/
//go:nosplit
func (self class) StopPlaytimeTrackingForAllItems() { //gd:Steam.stopPlaytimeTrackingForAllItems
	var frame = callframe.New()
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_stopPlaytimeTrackingForAllItems, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Get the app dependencies associated with the given published_file_id. These are "soft" dependencies that are shown on the web. It is up to the application to determine whether an item can be used or not.
Triggers a [signal Steam.get_app_dependencies_result] callback.
*/
//go:nosplit
func (self class) GetAppDependencies(published_file_id int64) { //gd:Steam.getAppDependencies
	var frame = callframe.New()
	callframe.Arg(frame, published_file_id)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getAppDependencies, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Uploads the changes made to an item to the Steam Workshop.
You can track the progress of an item update with [method Steam.getItemUpdateProgress].
Triggers a [signal Steam.item_updated] callback.
*/
//go:nosplit
func (self class) SubmitItemUpdate(update_handle int64, change_note String.Readable) { //gd:Steam.submitItemUpdate
	var frame = callframe.New()
	callframe.Arg(frame, update_handle)
	callframe.Arg(frame, pointers.Get(gd.InternalString(change_note)))
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_submitItemUpdate, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Subscribe to a workshop item. It will be downloaded and installed as soon as possible.
Triggers a [signal Steam.subscribe_item] callback.
*/
//go:nosplit
func (self class) SubscribeItem(published_file_id int64) { //gd:Steam.subscribeItem
	var frame = callframe.New()
	callframe.Arg(frame, published_file_id)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_subscribeItem, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Suspends and resumes all workshop downloads.
If you call this with suspend set to true then downloads will be suspended until you resume them by setting suspend to false or when the game ends.
*/
//go:nosplit
func (self class) SuspendDownloads(suspend bool) { //gd:Steam.suspendDownloads
	var frame = callframe.New()
	callframe.Arg(frame, suspend)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_suspendDownloads, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Unsubscribe from a workshop item. This will result in the item being removed after the game quits.
Triggers a [signal Steam.unsubscribe_item] callback.
*/
//go:nosplit
func (self class) UnsubscribeItem(published_file_id int64) { //gd:Steam.unsubscribeItem
	var frame = callframe.New()
	callframe.Arg(frame, published_file_id)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_unsubscribeItem, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Updates an additional video preview from YouTube for the item.
[b]Note:[/b] This must be set before you submit the UGC update handle using [method Steam.submitItemUpdate].
*/
//go:nosplit
func (self class) UpdateItemPreviewFile(update_handle int64, index int64, preview_file String.Readable) bool { //gd:Steam.updateItemPreviewFile
	var frame = callframe.New()
	callframe.Arg(frame, update_handle)
	callframe.Arg(frame, index)
	callframe.Arg(frame, pointers.Get(gd.InternalString(preview_file)))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_updateItemPreviewFile, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Updates an additional video preview from YouTube for the item.
[b]Note:[/b] This must be set before you submit the UGC update handle using [method Steam.submitItemUpdate].
*/
//go:nosplit
func (self class) UpdateItemPreviewVideo(update_handle int64, index int64, video_id String.Readable) bool { //gd:Steam.updateItemPreviewVideo
	var frame = callframe.New()
	callframe.Arg(frame, update_handle)
	callframe.Arg(frame, index)
	callframe.Arg(frame, pointers.Get(gd.InternalString(video_id)))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_updateItemPreviewVideo, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Show the app's latest Workshop EULA to the user in an overlay window, where they can accept it or not.
*/
//go:nosplit
func (self class) ShowWorkshopEULA() bool { //gd:Steam.showWorkshopEULA
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_showWorkshopEULA, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Asynchronously retrieves data about whether the user accepted the Workshop EULA for the current app.
*/
//go:nosplit
func (self class) GetWorkshopEULAStatus() { //gd:Steam.getWorkshopEULAStatus
	var frame = callframe.New()
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getWorkshopEULAStatus, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Set the time range this item was created.
*/
//go:nosplit
func (self class) SetTimeCreatedDateRange(update_handle int64, start int64, end int64) bool { //gd:Steam.setTimeCreatedDateRange
	var frame = callframe.New()
	callframe.Arg(frame, update_handle)
	callframe.Arg(frame, start)
	callframe.Arg(frame, end)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setTimeCreatedDateRange, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Set the time range this item was updated.
*/
//go:nosplit
func (self class) SetTimeUpdatedDateRange(update_handle int64, start int64, end int64) bool { //gd:Steam.setTimeUpdatedDateRange
	var frame = callframe.New()
	callframe.Arg(frame, update_handle)
	callframe.Arg(frame, start)
	callframe.Arg(frame, end)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setTimeUpdatedDateRange, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Set the rich presence data for an unsecured game server that the user is playing on. This allows friends to be able to view the game info and join your game.
When you are using Steam authentication system this call is never required, the auth system automatically sets the appropriate rich presence.
[b]Note:[/b] This is a legacy function.
*/
//go:nosplit
func (self class) AdvertiseGame(server_ip String.Readable, port int64) { //gd:Steam.advertiseGame
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(server_ip)))
	callframe.Arg(frame, port)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_advertiseGame, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Authenticate the ticket from the entity Steam ID to be sure it is valid and isn't reused.
The ticket is created on the entity with [method Steam.getAuthSessionTicket] and then needs to be provided over the network for the other end to validate.
This registers for [signal Steam.validate_auth_ticket_response] callbacks if the entity goes offline or cancels the ticket.
When the multiplayer session terminates you must call [method Steam.endAuthSession]
Trigger a [signal Steam.validate_auth_ticket_response] callback.
*/
//go:nosplit
func (self class) BeginAuthSession(ticket Packed.Bytes, ticket_size int64, steam_id int64) BeginAuthSessionResult { //gd:Steam.beginAuthSession
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalPacked[gd.PackedByteArray, byte](Packed.Array[byte](ticket))))
	callframe.Arg(frame, ticket_size)
	callframe.Arg(frame, steam_id)
	var r_ret = callframe.Ret[BeginAuthSessionResult](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_beginAuthSession, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Cancels an auth ticket received from [method Steam.getAuthSessionTicket]. This should be called when no longer playing with the specified entity.
*/
//go:nosplit
func (self class) CancelAuthTicket(auth_ticket int64) { //gd:Steam.cancelAuthTicket
	var frame = callframe.New()
	callframe.Arg(frame, auth_ticket)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_cancelAuthTicket, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Decodes the compressed voice data returned by [method Steam.getVoice].
The output data is raw single-channel 16-bit PCM audio. The decoder supports any sample rate from 11025 to 48000. See [method Steam.getVoiceOptimalSampleRate] for more information.
It is recommended that you start with a 20KiB buffer and then reallocate as necessary.
The returned dictionary contains the following keys:
[codeblock]
┠╴uncompressed (PackedByteArray)
[/codeblock]
*/
//go:nosplit
func (self class) DecompressVoice(voice Packed.Bytes, sample_rate int64, buffer_size_override int64) Dictionary.Any { //gd:Steam.decompressVoice
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalPacked[gd.PackedByteArray, byte](Packed.Array[byte](voice))))
	callframe.Arg(frame, sample_rate)
	callframe.Arg(frame, buffer_size_override)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_decompressVoice, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Ends an auth session that was started with [method Steam.beginAuthSession]. This should be called when no longer playing with the specified entity.
*/
//go:nosplit
func (self class) EndAuthSession(steam_id int64) { //gd:Steam.endAuthSession
	var frame = callframe.New()
	callframe.Arg(frame, steam_id)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_endAuthSession, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Retrieve an authentication ticket to be sent to the entity who wishes to authenticate you.
After calling this you can send the ticket to the entity where they can then call [method Steam.beginAuthSession] to verify this entities integrity.
When creating a ticket, the calling application should wait for the [signal Steam.get_auth_session_ticket_response] callback generated by the API call before attempting to use the ticket to ensure that the ticket has been communicated to the server. If this callback does not come in a timely fashion (10 - 20 seconds), then your client is not connected to Steam.
Triggers a [signal Steam.get_auth_session_ticket_response] callback.
[codeblock]
The returned dictionary contains the following keys:
┠╴id (int)
┠╴buffer (PackedByteArray)
┖╴size (int)
[/codeblock]
[b]Note:[/b] As of Steamworks SDK 1.57, you need to pass a network identity that was created with our Networking Tools class.  However, this is optional and defaults to NULL.
*/
//go:nosplit
func (self class) GetAuthSessionTicket(remote_steam_id int64) Dictionary.Any { //gd:Steam.getAuthSessionTicket
	var frame = callframe.New()
	callframe.Arg(frame, remote_steam_id)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getAuthSessionTicket, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Request a ticket which will be used for webapi "ISteamUserAuth\AuthenticateUserTicket"; [b]service_identity[/b] is an optional input parameter to identify the service the ticket will be sent to the ticket will be returned in callback [signal Steam.get_ticket_for_web_api].
Triggers a [signal Steam.get_ticket_for_web_api] callback.
[b]Note:[/b] The [b]service_identity[/b] is not a network identity used by or created with GodotSteam's Networking Tools class.
*/
//go:nosplit
func (self class) GetAuthTicketForWebApi(service_identity String.Readable) int64 { //gd:Steam.getAuthTicketForWebApi
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(service_identity)))
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getAuthTicketForWebApi, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Checks to see if there is captured audio data available from [method Steam.getVoice], and gets the size of the data.
Most applications will only use compressed data and should ignore the other parameters, which exist primarily for backwards compatibility. See [method Steam.getVoice] for further explanation of "uncompressed" data.
The returned dictionary contains the following keys:
[codeblock]
┠╴result (int)
┖╴buffer (int)
[/codeblock]
*/
//go:nosplit
func (self class) GetAvailableVoice() Dictionary.Any { //gd:Steam.getAvailableVoice
	var frame = callframe.New()
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getAvailableVoice, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Retrieves anti indulgence / duration control for current user / game combination.
Triggers a [signal Steam.duration_control] call result.
*/
//go:nosplit
func (self class) GetDurationControl() { //gd:Steam.getDurationControl
	var frame = callframe.New()
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getDurationControl, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Retrieve an encrypted ticket.
This should be called after requesting an encrypted app ticket with [method Steam.requestEncryptedAppTicket] and receiving the [signal Steam.encrypted_app_ticket_response] call result.
You should then pass this encrypted ticket to your secure servers to be decrypted using your secret key.
The returned dictionary contains the following keys:
[codeblock]
┠╴buffer (PackedByteArray)
┖╴size (int)
[/codeblock]
[b]Note:[/b] If you call this without calling [method Steam.requestEncryptedAppTicket], the call may succeed but you will likely get a stale ticket.
*/
//go:nosplit
func (self class) GetEncryptedAppTicket() Dictionary.Any { //gd:Steam.getEncryptedAppTicket
	var frame = callframe.New()
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getEncryptedAppTicket, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Gets the level of the users Steam badge for your game.
The user can have two different badges for a series; the regular badge (max level 5) and the foil badge (max level 1).
*/
//go:nosplit
func (self class) GetGameBadgeLevel(series int64, foil bool) int64 { //gd:Steam.getGameBadgeLevel
	var frame = callframe.New()
	callframe.Arg(frame, series)
	callframe.Arg(frame, foil)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getGameBadgeLevel, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Gets the Steam level of the user, as shown on their Steam community profile.
*/
//go:nosplit
func (self class) GetPlayerSteamLevel() int64 { //gd:Steam.getPlayerSteamLevel
	var frame = callframe.New()
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getPlayerSteamLevel, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Gets the Steam ID (ID64) of the account currently logged into the Steam client. This is commonly called the 'current user', or 'local user'.
A Steam ID is a unique identifier for a Steam accounts, Steam groups, Lobbies and Chat rooms, and used to differentiate users in all parts of the Steamworks API.
*/
//go:nosplit
func (self class) GetSteamID() int64 { //gd:Steam.getSteamID
	var frame = callframe.New()
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getSteamID, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Read captured audio data from the microphone buffer.
The compressed data can be transmitted by your application and decoded back into raw audio data using DecompressVoice on the other side. The compressed data provided is in an arbitrary format and is not meant to be played directly.
This should be called once per frame, and at worst no more than four times a second to keep the microphone input delay as low as possible. Calling this any less may result in gaps in the returned stream.
It is recommended that you pass in an 8 kilobytes or larger destination buffer for compressed audio. Static buffers are recommended for performance reasons. However, if you would like to allocate precisely the right amount of space for a buffer before each call you may use [method getAvailableVoice](/functions/users/#getavailablevoice) to find out how much data is available to be read.
The returned dictionary contains the following keys:
[codeblock]
┠╴result (int)
┖╴buffer (int)
[/codeblock]
[b]Note:[/b] "Uncompressed" audio is a deprecated feature and should not be used by most applications. It is raw single-channel 16-bit PCM wave data which may have been run through preprocessing filters and/or had silence removed, so the uncompressed audio could have a shorter duration than you expect. There may be no data at all during long periods of silence. Also, fetching uncompressed audio will cause [method Steam.getVoice] to discard any leftover compressed audio, so you must fetch both types at once. Finally, [method Steam.getAvailableVoice] is not precisely accurate when the uncompressed size is requested. So if you really need to use uncompressed audio, you should call [method Steam.getVoice] frequently with two very large (20KiB+) output buffers instead of trying to allocate perfectly-sized buffers. But most applications should ignore all of these details and simply leave the "uncompressed" parameters as NULL/0.
*/
//go:nosplit
func (self class) GetVoice(buffer_size_override int64) Dictionary.Any { //gd:Steam.getVoice
	var frame = callframe.New()
	callframe.Arg(frame, buffer_size_override)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getVoice, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Gets the native sample rate of the Steam voice decoder.
Using this sample rate for [method Steam.decompressVoice] will perform the least CPU processing. However, the final audio quality will depend on how well the audio device (and/or your application's audio output SDK) deals with lower sample rates. You may find that you get the best audio output quality when you ignore this function and use the native sample rate of your audio output device, which is usually 48000 or 44100.
*/
//go:nosplit
func (self class) GetVoiceOptimalSampleRate() int64 { //gd:Steam.getVoiceOptimalSampleRate
	var frame = callframe.New()
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getVoiceOptimalSampleRate, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
This starts the state machine for authenticating the game client with the game server.
It is the client portion of a three-way handshake between the client, the game server, and the steam servers.
The returned dictionary contains the following keys:
[codeblock]
┠╴auth_blob (PackedByteArray)
┠╴server_id (int)
┠╴server_ip (int)
┖╴server_port (int)
[/codeblock]
[b]Note:[/b] When you're done with the connection you must call [method Steam.terminateGameConnection].
[b]Note:[/b] This is part of the old user authentication API and should not be mixed with the new API.
*/
//go:nosplit
func (self class) InitiateGameConnection(server_id int64, server_ip String.Readable, server_port int64, secure bool) Dictionary.Any { //gd:Steam.initiateGameConnection
	var frame = callframe.New()
	callframe.Arg(frame, server_id)
	callframe.Arg(frame, pointers.Get(gd.InternalString(server_ip)))
	callframe.Arg(frame, server_port)
	callframe.Arg(frame, secure)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_initiateGameConnection, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Checks if the current user looks like they are behind a NAT device.
This is only valid if the user is connected to the Steam servers and may not catch all forms of NAT.
*/
//go:nosplit
func (self class) IsBehindNAT() bool { //gd:Steam.isBehindNAT
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_isBehindNAT, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Checks whether the user's phone number is used to uniquely identify them.
*/
//go:nosplit
func (self class) IsPhoneIdentifying() bool { //gd:Steam.isPhoneIdentifying
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_isPhoneIdentifying, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Checks whether the current user's phone number is awaiting (re)verification.
*/
//go:nosplit
func (self class) IsPhoneRequiringVerification() bool { //gd:Steam.isPhoneRequiringVerification
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_isPhoneRequiringVerification, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Checks whether the current user has verified their phone number.
*/
//go:nosplit
func (self class) IsPhoneVerified() bool { //gd:Steam.isPhoneVerified
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_isPhoneVerified, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Checks whether the current user has Steam Guard two factor authentication enabled on their account.
*/
//go:nosplit
func (self class) IsTwoFactorEnabled() bool { //gd:Steam.isTwoFactorEnabled
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_isTwoFactorEnabled, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Checks if the current user's Steam client is connected to the Steam servers.
If it's not then no real-time services provided by the Steamworks API will be enabled. The Steam client will automatically be trying to recreate the connection as often as possible. When the connection is restored a [signal Steam.steam_server_connected] callback will be posted.
You usually don't need to check for this yourself. All of the API calls that rely on this will check internally. Forcefully disabling stuff when the player loses access is usually not a very good experience for the player and you could be preventing them from accessing APIs that do not need a live connection to Steam.
*/
//go:nosplit
func (self class) LoggedOn() bool { //gd:Steam.loggedOn
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_loggedOn, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Requests an application ticket encrypted with the secret "encrypted app ticket key".
The encryption key can be obtained from the Encrypted App Ticket Key page on the App Admin for your app.
There can only be one [signal Steam.encrypted_app_ticket_response] pending, and this call is subject to a 60 second rate limit.
After receiving the response you should call [method Steam.getEncryptedAppTicket]) to get the ticket data, and then you need to send it to a secure server to be decrypted with the SteamEncryptedAppTicket functions.
Triggers a [signal Steam.encrypted_app_ticket_response] call result.
*/
//go:nosplit
func (self class) RequestEncryptedAppTicket(secret String.Readable) { //gd:Steam.requestEncryptedAppTicket
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(secret)))
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_requestEncryptedAppTicket, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Requests a URL which authenticates an in-game browser for store check-out, and then redirects to the specified URL.
As long as the in-game browser accepts and handles session cookies, Steam microtransaction checkout pages will automatically recognize the user instead of presenting a login page.
Triggers a [signal Steam.store_auth_url_response] call result.
[b]Note:[/b] The URL has a very short lifetime to prevent history-snooping attacks, so you should only call this API when you are about to launch the browser, or else immediately navigate to the result URL using a hidden browser window.
[b]Note:[/b] The resulting authorization cookie has an expiration time of one day, so it would be a good idea to request and visit a new auth URL every 12 hours.
*/
//go:nosplit
func (self class) RequestStoreAuthURL(redirect String.Readable) { //gd:Steam.requestStoreAuthURL
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(redirect)))
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_requestStoreAuthURL, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Starts voice recording.
Once started, use [method Steam.getAvailableVoice] and [method Steam.getVoice] to get the data, and then call [method Steam.stopVoiceRecording] when the user has released their push-to-talk hotkey or the game session has completed.
*/
//go:nosplit
func (self class) StartVoiceRecording() { //gd:Steam.startVoiceRecording
	var frame = callframe.New()
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_startVoiceRecording, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Allows the game to specify the offline/online gameplay state for Steam China duration control.
*/
//go:nosplit
func (self class) SetDurationControlOnlineState(new_state int64) bool { //gd:Steam.setDurationControlOnlineState
	var frame = callframe.New()
	callframe.Arg(frame, new_state)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setDurationControlOnlineState, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Stops voice recording.
Because people often release push-to-talk keys early, the system will keep recording for a little bit after this function is called. As such, [method Steam.getVoice] should continue to be called until it returns 2, only then will voice recording be stopped.
*/
//go:nosplit
func (self class) StopVoiceRecording() { //gd:Steam.stopVoiceRecording
	var frame = callframe.New()
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_stopVoiceRecording, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Notify the game server that we are disconnecting.
This needs to occur when the game client leaves the specified game server, needs to match with the [method Steam.initiateGameConnection] call.
[b]Note:[/b] This is part of the old user authentication API and should not be mixed with the new API.
*/
//go:nosplit
func (self class) TerminateGameConnection(server_ip String.Readable, server_port int64) { //gd:Steam.terminateGameConnection
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(server_ip)))
	callframe.Arg(frame, server_port)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_terminateGameConnection, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Checks if the user owns a specific piece of Downloadable Content (DLC).
This can only be called after sending the users auth ticket to [method Steam.beginAuthSession].
*/
//go:nosplit
func (self class) UserHasLicenseForApp(steam_id int64, app_id int64) int64 { //gd:Steam.userHasLicenseForApp
	var frame = callframe.New()
	callframe.Arg(frame, steam_id)
	callframe.Arg(frame, app_id)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_userHasLicenseForApp, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
If no this_leaderboard is passed, then the function will use the last internally-stored handle.
Attaches a piece of user generated content the current user's entry on a leaderboard.
This content could be a replay of the user achieving the score or a ghost to race against. To create and download user generated content see the documentation for the Steam Workshop.
Once attached, the content will be available even if the underlying Cloud file is changed or deleted by the user.
You must call [method Steam.findLeaderboard] or [method Steam.findOrCreateLeaderboard] to get a leaderboard handle prior to calling this function.
Triggers a [signal Steam.leaderboard_ugc_set] callback.
*/
//go:nosplit
func (self class) AttachLeaderboardUGC(ugc_handle int64, this_leaderboard int64) { //gd:Steam.attachLeaderboardUGC
	var frame = callframe.New()
	callframe.Arg(frame, ugc_handle)
	callframe.Arg(frame, this_leaderboard)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_attachLeaderboardUGC, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Resets the unlock status of an achievement.
This is primarily only ever used for testing.
This call only modifies Steam's in-memory state so it is quite cheap. To send the unlock status to the server and to trigger the Steam overlay notification you must call [method Steam.storeStats].
*/
//go:nosplit
func (self class) ClearAchievement(achievement_name String.Readable) bool { //gd:Steam.clearAchievement
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(achievement_name)))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_clearAchievement, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
If no leaderboard_handle is passed, then the function will use the last internally-stored handle.
Fetches a series of leaderboard entries for a specified leaderboard.
You can ask for more entries than exist, then this will return as many as do exist.
If you want to download entries for an arbitrary set of users, such as all of the users on a server then you can use [method Steam.downloadLeaderboardEntriesForUsers] which takes an array of Steam IDs.
You must call [method Steam.findLeaderboard] or [method Steam.findOrCreateLeaderboard] to get a leaderboard handle prior to calling this function.
Triggers a [signal Steam.leaderboard_scores_downloaded] call result.
*/
//go:nosplit
func (self class) DownloadLeaderboardEntries(start int64, end int64, atype LeaderboardDataRequest, this_leaderboard int64) { //gd:Steam.downloadLeaderboardEntries
	var frame = callframe.New()
	callframe.Arg(frame, start)
	callframe.Arg(frame, end)
	callframe.Arg(frame, atype)
	callframe.Arg(frame, this_leaderboard)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_downloadLeaderboardEntries, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
If no leaderboard_handle is passed, then the function will use the last internally-stored handle.
Fetches leaderboard entries for an arbitrary set of users on a specified leaderboard.
A maximum of 100 users can be downloaded at a time, with only one outstanding call at a time. If a user doesn't have an entry on the specified leaderboard, they won't be included in the result.
If you want to download entries based on their ranking or friends of the current user then you should use [method Steam.downloadLeaderboardEntries].
You must call [method Steam.findLeaderboard] or [method Steam.findOrCreateLeaderboard] to get a leaderboard handle prior to calling this function.
Triggers a [signal Steam.leaderboard_scores_downloaded] callback.
*/
//go:nosplit
func (self class) DownloadLeaderboardEntriesForUsers(users_id Array.Any, this_leaderboard int64) { //gd:Steam.downloadLeaderboardEntriesForUsers
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalArray(users_id)))
	callframe.Arg(frame, this_leaderboard)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_downloadLeaderboardEntriesForUsers, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Gets a leaderboard by name.
You must call either this or [method Steam.findOrCreateLeaderboard] to obtain the leaderboard handle which is valid for the game session for each leaderboard you wish to access prior to calling any other Leaderboard functions.
Triggers a [signal Steam.leaderboard_find_result] call result.
*/
//go:nosplit
func (self class) FindLeaderboard(leaderboard_name String.Readable) { //gd:Steam.findLeaderboard
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(leaderboard_name)))
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_findLeaderboard, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Gets a leaderboard by name, it will create it if it's not yet created.
You must call either this or [method Steam.findLeaderboard] to obtain the leaderboard handle which is valid for the game session for each leaderboard you wish to access prior to calling any other Leaderboard functions.
Leaderboards created with this function will not automatically show up in the Steam Community. You must manually set the Community Name field in the App Admin panel of the Steamworks website. As such it's generally recommended to prefer creating the leaderboards in the App Admin panel on the Steamworks website and using [method Steam.findLeaderboard] unless you're expected to have a large amount of dynamically created leaderboards.
You should never pass 0 for sort_method or 0 for display_type as this is undefined behavior.
Triggers a [signal Steam.leaderboard_find_result] callback.
*/
//go:nosplit
func (self class) FindOrCreateLeaderboard(leaderboard_name String.Readable, sort_method LeaderboardSortMethod, display_type LeaderboardDisplayType) { //gd:Steam.findOrCreateLeaderboard
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(leaderboard_name)))
	callframe.Arg(frame, sort_method)
	callframe.Arg(frame, display_type)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_findOrCreateLeaderboard, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Gets the unlock status of the Achievement.
The equivalent function for other users is [method getUserAchievement].
The returned dictionary contains the following keys:
[codeblock]
┠╴ret (bool)
┖╴achieved (bool)
[/codeblock]
*/
//go:nosplit
func (self class) GetAchievement(achievement_name String.Readable) Dictionary.Any { //gd:Steam.getAchievement
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(achievement_name)))
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getAchievement, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Returns the percentage of users who have unlocked the specified achievement.
You must have called [method Steam.requestGlobalAchievementPercentages] and it needs to return successfully via its callback prior to calling this.
The returned dictionary contains the following keys:
[codeblock]
┠╴ret (bool)
┖╴percent (float)
[/codeblock]
*/
//go:nosplit
func (self class) GetAchievementAchievedPercent(achievement_name String.Readable) Dictionary.Any { //gd:Steam.getAchievementAchievedPercent
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(achievement_name)))
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getAchievementAchievedPercent, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Gets the achievement status, and the time it was unlocked if unlocked.
If the return value is true, but the unlock time is zero, that means it was unlocked before Steam began tracking achievement unlock times (December 2009). The time is provided in Unix epoch format, seconds since January 1, 1970 UTC.
The equivalent function for other users is [method Steam.getUserAchievementAndUnlockTime].
[codeblock lang=text]
The returning dictionary contains the following keys:
┠╴retrieve (bool)
┠╴achieved (bool)
┖╴unlocked (int)
[/codeblock]
*/
//go:nosplit
func (self class) GetAchievementAndUnlockTime(achievement_name String.Readable) Dictionary.Any { //gd:Steam.getAchievementAndUnlockTime
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(achievement_name)))
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getAchievementAndUnlockTime, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Get general attributes for an achievement. Currently provides: Name, Description, and Hidden status.
This receives the value from a dictionary/map keyvalue store, so you must provide one of the following keys:
[codeblock]
• name: to retrieve the localized achievement name in UTF8
• desc: to retrieve the localized achievement description in UTF8
• hidden: for retrieving if an achievement is hidden. Returns "0" when not hidden, "1" when hidden
[/codeblock]
This localization is provided based on the games language if it's set, otherwise it checks if a localization is available for the users Steam UI Language. If that fails too, then it falls back to English.
*/
//go:nosplit
func (self class) GetAchievementDisplayAttribute(achievement_name String.Readable, key String.Readable) String.Readable { //gd:Steam.getAchievementDisplayAttribute
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(achievement_name)))
	callframe.Arg(frame, pointers.Get(gd.InternalString(key)))
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getAchievementDisplayAttribute, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Gets the icon for an achievement.
Triggers a [signal Steam.user_achievement_icon_fetched] callback.
*/
//go:nosplit
func (self class) GetAchievementIcon(achievement_name String.Readable) int64 { //gd:Steam.getAchievementIcon
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(achievement_name)))
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getAchievementIcon, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Gets the 'API name' for an achievement index between 0 and [method Steam.getNumAchievements].
This function must be used in conjunction with [method Steam.getNumAchievements] to loop over the list of achievements.
In general games should not need these functions as they should have the list of achievements compiled into them.
*/
//go:nosplit
func (self class) GetAchievementName(achievement int64) String.Readable { //gd:Steam.getAchievementName
	var frame = callframe.New()
	callframe.Arg(frame, achievement)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getAchievementName, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

/*
For achievements that have related progress stats, use this to query what the bounds of that progress are. You may want this info to selectively call [method Steam.indicateAchievementProgress] when appropriate milestones of progress have been made, to show a progress notification to the user.
The returned dictionary contains the following keys:
[codeblock]
┠╴name (string)
┠╴min (int)
┖╴max (int)
[/codeblock]
*/
//go:nosplit
func (self class) GetAchievementProgressLimitsInt(achievement_name String.Readable) Dictionary.Any { //gd:Steam.getAchievementProgressLimitsInt
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(achievement_name)))
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getAchievementProgressLimitsInt, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
For achievements that have related progress stats, use this to query what the bounds of that progress are. You may want this info to selectively call [method Steam.indicateAchievementProgress] when appropriate milestones of progress have been made, to show a progress notification to the user.
The returned dictionary contains the following keys:
[codeblock]
┠╴name (string)
┠╴min (float)
┖╴max (float)
[/codeblock]
*/
//go:nosplit
func (self class) GetAchievementProgressLimitsFloat(achievement_name String.Readable) Dictionary.Any { //gd:Steam.getAchievementProgressLimitsFloat
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(achievement_name)))
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getAchievementProgressLimitsFloat, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Gets the lifetime totals for an aggregated stat.
You must have called [method Steam.requestGlobalStats] and it needs to return successfully via its callback prior to calling this.
*/
//go:nosplit
func (self class) GetGlobalStatInt(stat_name String.Readable) int64 { //gd:Steam.getGlobalStatInt
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(stat_name)))
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getGlobalStatInt, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Gets the lifetime totals for an aggregated stat.
You must have called [method Steam.requestGlobalStats] and it needs to return successfully via its callback prior to calling this.
*/
//go:nosplit
func (self class) GetGlobalStatFloat(stat_name String.Readable) float64 { //gd:Steam.getGlobalStatFloat
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(stat_name)))
	var r_ret = callframe.Ret[float64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getGlobalStatFloat, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Gets the daily history for an aggregated stat.
Array.0 will be today, Array.1 will be yesterday, and Array.2 will be two days ago, etc.
You must have called [method Steam.requestGlobalStats] and it needs to return successfully via its callback prior to calling this.
*/
//go:nosplit
func (self class) GetGlobalStatIntHistory(stat_name String.Readable) Packed.Array[int64] { //gd:Steam.getGlobalStatIntHistory
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(stat_name)))
	var r_ret = callframe.Ret[gd.PackedPointers](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getGlobalStatIntHistory, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Packed.Array[int64](Array.Through(gd.PackedProxy[gd.PackedInt64Array, int64]{}, pointers.Pack(pointers.New[gd.PackedStringArray](r_ret.Get()))))
	frame.Free()
	return ret
}

/*
Gets the daily history for an aggregated stat.
Array.0 will be today, Array.1 will be yesterday, and Array.2 will be two days ago, etc.
You must have called [method Steam.requestGlobalStats] and it needs to return successfully via its callback prior to calling this.
*/
//go:nosplit
func (self class) GetGlobalStatFloatHistory(stat_name String.Readable) Packed.Array[float64] { //gd:Steam.getGlobalStatFloatHistory
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(stat_name)))
	var r_ret = callframe.Ret[gd.PackedPointers](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getGlobalStatFloatHistory, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Packed.Array[float64](Array.Through(gd.PackedProxy[gd.PackedFloat64Array, float64]{}, pointers.Pack(pointers.New[gd.PackedStringArray](r_ret.Get()))))
	frame.Free()
	return ret
}

/*
If no leaderboard_handle is passed, then the function will use the last internally-stored handle.
Get the display type of a leaderboard handle.
The returned dictionary contains the following keys:
[codeblock]
┠╴result (int)
┖╴verbal (string)
[/codeblock]
*/
//go:nosplit
func (self class) GetLeaderboardDisplayType(this_leaderboard int64) Dictionary.Any { //gd:Steam.getLeaderboardDisplayType
	var frame = callframe.New()
	callframe.Arg(frame, this_leaderboard)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getLeaderboardDisplayType, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
If no leaderboard_handle is passed, then the function will use the last internally-stored handle.
Returns the total number of entries in a leaderboard.
This is cached on a per leaderboard basis upon the first call to [method Steam.findLeaderboard] or [method Steam.findOrCreateLeaderboard] and is refreshed on each successful call to [method Steam.downloadLeaderboardEntries], [method Steam.downloadLeaderboardEntriesForUsers], and [method Steam.uploadLeaderboardScore].
*/
//go:nosplit
func (self class) GetLeaderboardEntryCount(this_leaderboard int64) int64 { //gd:Steam.getLeaderboardEntryCount
	var frame = callframe.New()
	callframe.Arg(frame, this_leaderboard)
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getLeaderboardEntryCount, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
If no leaderboard_handle is passed, then the function will use the last internally-stored handle.
Returns the name of a leaderboard handle.
*/
//go:nosplit
func (self class) GetLeaderboardName(this_leaderboard int64) String.Readable { //gd:Steam.getLeaderboardName
	var frame = callframe.New()
	callframe.Arg(frame, this_leaderboard)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getLeaderboardName, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

/*
If no leaderboard_handle is passed, then the function will use the last internally-stored handle.
Get the sort order of a leaderboard handle. If no thisLeaderboard handle is passed, then the function will use the last stored internal handle.
The returned dictionary contains the following keys:
[codeblock]
┠╴result (int)
┖╴verbal (string)
[/codeblock]
*/
//go:nosplit
func (self class) GetLeaderboardSortMethod(this_leaderboard int64) Dictionary.Any { //gd:Steam.getLeaderboardSortMethod
	var frame = callframe.New()
	callframe.Arg(frame, this_leaderboard)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getLeaderboardSortMethod, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Gets the info on the most achieved achievement for the game.
You must have called [method Steam.requestGlobalAchievementPercentages] and it needs to return successfully via its callback prior to calling this.
The returned dictionary contains the following keys:
[codeblock]
┠╴rank (int)
┠╴name (string)
┠╴percent (float)
┖╴achieved (bool)
[/codeblock]
*/
//go:nosplit
func (self class) GetMostAchievedAchievementInfo() Dictionary.Any { //gd:Steam.getMostAchievedAchievementInfo
	var frame = callframe.New()
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getMostAchievedAchievementInfo, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Gets the info on the next most achieved achievement for the game.
You must have called [method Steam.requestGlobalAchievementPercentages] and it needs to return successfully via its callback prior to calling this.
The returned dictionary contains the following keys:
[codeblock]
┠╴rank (int)
┠╴name (string)
┠╴percent (float)
┖╴achieved (bool)
[/codeblock]
*/
//go:nosplit
func (self class) GetNextMostAchievedAchievementInfo(iterator int64) Dictionary.Any { //gd:Steam.getNextMostAchievedAchievementInfo
	var frame = callframe.New()
	callframe.Arg(frame, iterator)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getNextMostAchievedAchievementInfo, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Get the number of achievements defined in the App Admin panel of the Steamworks website.
This is used for iterating through all of the achievements with [method Steam.getAchievementName].
In general games should not need these functions because they should have a list of existing achievements compiled into them.
*/
//go:nosplit
func (self class) GetNumAchievements() int64 { //gd:Steam.getNumAchievements
	var frame = callframe.New()
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getNumAchievements, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Asynchronously retrieves the total number of players currently playing the current game. Both online and in offline mode.
Triggers a [signal Steam.number_of_current_players] callback.
*/
//go:nosplit
func (self class) GetNumberOfCurrentPlayers() { //gd:Steam.getNumberOfCurrentPlayers
	var frame = callframe.New()
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getNumberOfCurrentPlayers, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Gets the current value of the a stat for the current user.
To receive stats for other users use [method Steam.getUserStatFloat] or [method Steam.getUserStatInt].
*/
//go:nosplit
func (self class) GetStatFloat(stat_name String.Readable) float64 { //gd:Steam.getStatFloat
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(stat_name)))
	var r_ret = callframe.Ret[float64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getStatFloat, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Gets the current value of the a stat for the current user.
To receive stats for other users use [method Steam.getUserStatFloat] or [method Steam.getUserStatInt].
*/
//go:nosplit
func (self class) GetStatInt(stat_name String.Readable) int64 { //gd:Steam.getStatInt
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(stat_name)))
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getStatInt, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Gets the unlock status of the Achievement.
The equivalent function for the local user is [method Steam.getAchievement].
The returned dictionary contains the following keys:
[codeblock]
┠╴steam_id (int)
┠╴retrieved (bool)
┠╴name (string)
┖╴achieved (bool)
[/codeblock]
*/
//go:nosplit
func (self class) GetUserAchievement(steam_id int64, name String.Readable) Dictionary.Any { //gd:Steam.getUserAchievement
	var frame = callframe.New()
	callframe.Arg(frame, steam_id)
	callframe.Arg(frame, pointers.Get(gd.InternalString(name)))
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getUserAchievement, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Gets the achievement status, and the time it was unlocked if unlocked.
If the return value is true, but the unlock time is zero, that means it was unlocked before Steam began tracking achievement unlock times (December 2009). The time is provided in Unix epoch format, seconds since January 1, 1970 UTC.
The equivalent function for the local user is [method Steam.getAchievementAndUnlockTime].
The returned dictionary contains the following keys:
[codeblock]
┠╴retrieved (bool)
┠╴name (string)
┠╴achieved (bool)
┖╴unlocked (int)
[/codeblock]
*/
//go:nosplit
func (self class) GetUserAchievementAndUnlockTime(steam_id int64, name String.Readable) Dictionary.Any { //gd:Steam.getUserAchievementAndUnlockTime
	var frame = callframe.New()
	callframe.Arg(frame, steam_id)
	callframe.Arg(frame, pointers.Get(gd.InternalString(name)))
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getUserAchievementAndUnlockTime, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Gets the current value of the a stat for the specified user.
You must have called [method Steam.requestUserStats] and it needs to return successfully via its callback prior to calling this.
The equivalent function for the local user is [method Steam.getStatFloat] or [method Steam.getStatInt].
*/
//go:nosplit
func (self class) GetUserStatFloat(steam_id int64, name String.Readable) float64 { //gd:Steam.getUserStatFloat
	var frame = callframe.New()
	callframe.Arg(frame, steam_id)
	callframe.Arg(frame, pointers.Get(gd.InternalString(name)))
	var r_ret = callframe.Ret[float64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getUserStatFloat, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Gets the current value of the a stat for the specified user.
You must have called [method Steam.requestUserStats] and it needs to return successfully via its callback prior to calling this.
The equivalent function for the local user is [method Steam.getStatInt] or [method Steam.getStatFloat].
*/
//go:nosplit
func (self class) GetUserStatInt(steam_id int64, name String.Readable) int64 { //gd:Steam.getUserStatInt
	var frame = callframe.New()
	callframe.Arg(frame, steam_id)
	callframe.Arg(frame, pointers.Get(gd.InternalString(name)))
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getUserStatInt, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Shows the user a pop-up notification with the current progress of an achievement.
Calling this function will not set the progress or unlock the achievement, the game must do that manually by calling [method Steam.setStatFloat] or [method Steam.setStatInt].
Triggers a [signal Steam.user_stats_stored] callback.
Triggers a [signal Steam.user_achievement_stored] callback.
*/
//go:nosplit
func (self class) IndicateAchievementProgress(name String.Readable, current_progress int64, max_progress int64) bool { //gd:Steam.indicateAchievementProgress
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(name)))
	callframe.Arg(frame, current_progress)
	callframe.Arg(frame, max_progress)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_indicateAchievementProgress, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Asynchronously fetches global stats data, which is available for stats marked as "aggregated" in the App Admin panel of the Steamworks website.
Triggers a [signal Steam.global_achievement_percentages_ready] callback.
*/
//go:nosplit
func (self class) RequestGlobalAchievementPercentages() { //gd:Steam.requestGlobalAchievementPercentages
	var frame = callframe.New()
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_requestGlobalAchievementPercentages, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Asynchronously fetches global stats data, which is available for stats marked as "aggregated" in the App Admin panel of the Steamworks website.
The limit is 60.
Triggers a [signal Steam.global_stats_received] callback.
*/
//go:nosplit
func (self class) RequestGlobalStats(history_days int64) { //gd:Steam.requestGlobalStats
	var frame = callframe.New()
	callframe.Arg(frame, history_days)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_requestGlobalStats, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Asynchronously downloads stats and achievements for the specified user from the server.
These stats are not automatically updated; you'll need to call this function again to refresh any data that may have change.
To keep from using too much memory, an least recently used cache (LRU) is maintained and other user's stats will occasionally be unloaded. When this happens a [signal Steam.user_stats_unloaded] callback is sent. After receiving this callback the user's stats will be unavailable until this function is called again.
Triggers a [signal Steam.user_stats_received] callback.
*/
//go:nosplit
func (self class) RequestUserStats(steam_id int64) { //gd:Steam.requestUserStats
	var frame = callframe.New()
	callframe.Arg(frame, steam_id)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_requestUserStats, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Resets the current users stats and, optionally achievements.
This automatically calls [method Steam.storeStats] to persist the changes to the server. This should typically only be used for testing purposes during development.
*/
//go:nosplit
func (self class) ResetAllStats(achievements_too bool) bool { //gd:Steam.resetAllStats
	var frame = callframe.New()
	callframe.Arg(frame, achievements_too)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_resetAllStats, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Unlocks an achievement.
You can unlock an achievement multiple times so you don't need to worry about only setting achievements that aren't already set. This call only modifies Steam's in-memory state so it is quite cheap. To send the unlock status to the server and to trigger the Steam overlay notification you must call [method Steam.storeStats].
*/
//go:nosplit
func (self class) SetAchievement(name String.Readable) bool { //gd:Steam.setAchievement
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(name)))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setAchievement, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Sets / updates the float value of a given stat for the current user.
This call only modifies Steam's in-memory state and is very cheap. Doing so allows Steam to persist the changes even in the event of a game crash or unexpected shutdown. To submit the stats to the server you must call [method Steam.storeStats].
If this is returning false and everything appears correct, then check to ensure that your changes in the App Admin panel of the Steamworks website are published.
*/
//go:nosplit
func (self class) SetStatFloat(name String.Readable, value float64) bool { //gd:Steam.setStatFloat
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(name)))
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setStatFloat, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Sets / updates the integer value of a given stat for the current user.
This call only modifies Steam's in-memory state and is very cheap. Doing so allows Steam to persist the changes even in the event of a game crash or unexpected shutdown. To submit the stats to the server you must call [method Steam.storeStats].
If this is returning false and everything appears correct, then check to ensure that your changes in the App Admin panel of the Steamworks website are published.
*/
//go:nosplit
func (self class) SetStatInt(name String.Readable, value int64) bool { //gd:Steam.setStatInt
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(name)))
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setStatInt, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Send the changed stats and achievements data to the server for permanent storage.
If this fails then nothing is sent to the server. It's advisable to keep trying until the call is successful.
This call can be rate limited. Call frequency should be on the order of minutes, rather than seconds. You should only be calling this during major state changes such as the end of a round, the map changing, or the user leaving a server. This call is required to display the achievement unlock notification dialog though, so if you have called [method Steam.setAchievement] then it's advisable to call this soon after that.
If you have stats or achievements that you have saved locally but haven't uploaded with this function when your application process ends then this function will automatically be called.
You can find additional debug information written to the [code]%steam_install%\logs\stats_log.txt[/code] file.
Triggers a [signal Steam.user_stats_stored] callback.
Triggers a [signal Steam.user_achievement_stored] callback.
*/
//go:nosplit
func (self class) StoreStats() bool { //gd:Steam.storeStats
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_storeStats, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Updates an AVGRATE stat with new values.
This call only modifies Steam's in-memory state and is very cheap. Doing so allows Steam to persist the changes even in the event of a game crash or unexpected shutdown. To submit the stats to the server you must call [method Steam.storeStats].
If this is returning false and everything appears correct, then check to ensure that your changes in the App Admin panel of the Steamworks website are published.
*/
//go:nosplit
func (self class) UpdateAvgRateStat(name String.Readable, this_session float64, session_length float64) bool { //gd:Steam.updateAvgRateStat
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(name)))
	callframe.Arg(frame, this_session)
	callframe.Arg(frame, session_length)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_updateAvgRateStat, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
If this_leaderboard is not passed, then the function will use the last internally-stored handle.
Uploads a user score to a specified leaderboard.
Details are optional game-defined information which outlines how the user got that score. For example if it's a racing style time based leaderboard you could store the timestamps when the player hits each checkpoint. If you have collectibles along the way you could use bit fields as booleans to store the items the player picked up in the playthrough.
Uploading scores to Steam is rate limited to 10 uploads per 10 minutes and you may only have one outstanding call to this function at a time.
Triggers a [signal Steam.leaderboard_score_uploaded] callback.
*/
//go:nosplit
func (self class) UploadLeaderboardScore(score int64, keep_best bool, details Packed.Array[int32], this_leaderboard int64) { //gd:Steam.uploadLeaderboardScore
	var frame = callframe.New()
	callframe.Arg(frame, score)
	callframe.Arg(frame, keep_best)
	callframe.Arg(frame, pointers.Get(gd.InternalPacked[gd.PackedInt32Array, int32](details)))
	callframe.Arg(frame, this_leaderboard)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_uploadLeaderboardScore, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Dismisses the floating keyboard.
*/
//go:nosplit
func (self class) DismissFloatingGamepadTextInput() bool { //gd:Steam.dismissFloatingGamepadTextInput
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_dismissFloatingGamepadTextInput, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Dismisses the full-screen text input dialog.
*/
//go:nosplit
func (self class) DismissGamepadTextInput() bool { //gd:Steam.dismissGamepadTextInput
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_dismissGamepadTextInput, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Filters the provided input message and returns the filtered result. Legally required filtering is always applied. Additional filtering may occur, based on the context and user settings.
*/
//go:nosplit
func (self class) FilterText(context TextFilteringContext, steam_id int64, message String.Readable) String.Readable { //gd:Steam.filterText
	var frame = callframe.New()
	callframe.Arg(frame, context)
	callframe.Arg(frame, steam_id)
	callframe.Arg(frame, pointers.Get(gd.InternalString(message)))
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_filterText, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Used to get the failure reason of a call result.
The primary usage for this function is debugging. The failure reasons are typically out of your control and tend to not be very important. Just keep retrying your API Call until it works.
*/
//go:nosplit
func (self class) GetAPICallFailureReason() String.Readable { //gd:Steam.getAPICallFailureReason
	var frame = callframe.New()
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getAPICallFailureReason, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Gets the App ID of the current process.
*/
//go:nosplit
func (self class) GetAppID() int64 { //gd:Steam.getAppID
	var frame = callframe.New()
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getAppID, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Gets the current amount of battery power on the computer.
*/
//go:nosplit
func (self class) GetCurrentBatteryPower() int64 { //gd:Steam.getCurrentBatteryPower
	var frame = callframe.New()
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getCurrentBatteryPower, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Gets the image bytes from an image handle.
Prior to calling this you must get the size of the image by calling [method Steam.getImageSize] so that you can create your buffer with an appropriate size. You can then allocate your buffer with the width and height as: width * height * 4. The image is provided in RGBA format. This call can be somewhat expensive as it converts from the compressed type (JPG, PNG, TGA) and provides no internal caching of returned buffer, thus it is highly recommended to only call this once per image handle and cache the result. This function is only used for Steam Avatars and Achievement images and those are not expected to change mid game.
The returned dictionary contains the following keys:
[codeblock]
┠╴buffer (PackedByteArray)
┖╴success (bool)
[/codeblock]
*/
//go:nosplit
func (self class) GetImageRGBA(image int64) Dictionary.Any { //gd:Steam.getImageRGBA
	var frame = callframe.New()
	callframe.Arg(frame, image)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getImageRGBA, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Gets the size of a Steam image handle.
This must be called before calling [method Steam.getImageRGBA] to create an appropriately sized buffer that will be filled with the raw image data.
The returned dictionary contains the following keys:
[codeblock]
┠╴width (int)
┖╴height (int)
[/codeblock]
*/
//go:nosplit
func (self class) GetImageSize(image int64) Dictionary.Any { //gd:Steam.getImageSize
	var frame = callframe.New()
	callframe.Arg(frame, image)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getImageSize, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Returns the number of IPC calls made since the last time this function was called.
Used for perf debugging so you can determine how many IPC (Inter-Process Communication) calls your game makes per frame.
Every IPC call is at minimum a thread context switch if not a process one so you want to rate control how often you do them.
*/
//go:nosplit
func (self class) GetIPCCallCount() int64 { //gd:Steam.getIPCCallCount
	var frame = callframe.New()
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getIPCCallCount, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns the 2 digit ISO 3166-1-alpha-2 format country code which client is running in. e.g "US" or "UK".
This is looked up via an IP-to-location database.
*/
//go:nosplit
func (self class) GetIPCountry() String.Readable { //gd:Steam.getIPCountry
	var frame = callframe.New()
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getIPCountry, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Returns the number of seconds since the application was active.
*/
//go:nosplit
func (self class) GetSecondsSinceAppActive() int64 { //gd:Steam.getSecondsSinceAppActive
	var frame = callframe.New()
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getSecondsSinceAppActive, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns the number of seconds since the user last moved the mouse.
*/
//go:nosplit
func (self class) GetSecondsSinceComputerActive() int64 { //gd:Steam.getSecondsSinceComputerActive
	var frame = callframe.New()
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getSecondsSinceComputerActive, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns the Steam server time in Unix epoch format. (Number of seconds since Jan 1, 1970 UTC).
*/
//go:nosplit
func (self class) GetServerRealTime() int64 { //gd:Steam.getServerRealTime
	var frame = callframe.New()
	var r_ret = callframe.Ret[int64](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getServerRealTime, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns the language the steam client is running in.
You probably want [method Steam.getCurrentGameLanguage] instead, this should only be used in very special cases.
For a full list of languages see Supported Languages in Valve's documentation.
*/
//go:nosplit
func (self class) GetSteamUILanguage() String.Readable { //gd:Steam.getSteamUILanguage
	var frame = callframe.New()
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getSteamUILanguage, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Initializes text filtering, loading dictionaries for the language the game is running in.
Users can customize the text filter behavior in their Steam Account preferences.
*/
//go:nosplit
func (self class) InitFilterText() bool { //gd:Steam.initFilterText
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_initFilterText, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Checks if an API Call is completed. Provides the backend of the CallResult wrapper.
It's generally not recommended that you use this yourself.
The returned dictionary contains the following keys:
[codeblock]
┠╴completed (bool)
┖╴failed (bool)
[/codeblock]
*/
//go:nosplit
func (self class) IsAPICallCompleted() Dictionary.Any { //gd:Steam.isAPICallCompleted
	var frame = callframe.New()
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_isAPICallCompleted, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Checks if the Steam Overlay is running and the user can access it.
The overlay process could take a few seconds to start and hook the game process, so this function will initially return false while the overlay is loading.
*/
//go:nosplit
func (self class) IsOverlayEnabled() bool { //gd:Steam.isOverlayEnabled
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_isOverlayEnabled, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Returns whether the current launcher is a Steam China launcher. You can cause the client to behave as the Steam China launcher by adding [code]-dev -steamchina[/code] to the command line when running Steam.
*/
//go:nosplit
func (self class) IsSteamChinaLauncher() bool { //gd:Steam.isSteamChinaLauncher
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_isSteamChinaLauncher, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Checks if Steam and the Steam Overlay are running in Big Picture mode.
Games must be launched through the Steam client to enable the Big Picture overlay. During development, a game can be added as a non-steam game to the developers library to test this feature.
*/
//go:nosplit
func (self class) IsSteamInBigPictureMode() bool { //gd:Steam.isSteamInBigPictureMode
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_isSteamInBigPictureMode, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Checks if Steam is running in VR mode.
*/
//go:nosplit
func (self class) IsSteamRunningInVR() bool { //gd:Steam.isSteamRunningInVR
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_isSteamRunningInVR, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Checks if Steam is running on a Steam Deck device.
*/
//go:nosplit
func (self class) IsSteamRunningOnSteamDeck() bool { //gd:Steam.isSteamRunningOnSteamDeck
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_isSteamRunningOnSteamDeck, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Checks if the HMD view will be streamed via Steam In-Home Streaming.
*/
//go:nosplit
func (self class) IsVRHeadsetStreamingEnabled() bool { //gd:Steam.isVRHeadsetStreamingEnabled
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_isVRHeadsetStreamingEnabled, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Checks if the Overlay needs a present. Only required if using event driven render updates.
Typically this call is unneeded if your game has a constantly running frame loop that calls the D3D Present API, or OGL SwapBuffers API every frame as is the case in most games. However, if you have a game that only refreshes the screen on an event driven basis then that can break the overlay, as it uses your Present/SwapBuffers calls to drive it's internal frame loop and it may also need to Present() to the screen any time a notification happens or when the overlay is brought up over the game by a user. You can use this API to ask the overlay if it currently need a present in that case, and then you can check for this periodically (roughly 33hz is desirable) and make sure you refresh the screen with Present or SwapBuffers to allow the overlay to do it's work.
*/
//go:nosplit
func (self class) OverlayNeedsPresent() bool { //gd:Steam.overlayNeedsPresent
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_overlayNeedsPresent, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
In game launchers that don't have controller support you can call this to have Steam Input translate the controller input into mouse/kb to navigate the launcher.
*/
//go:nosplit
func (self class) SetGameLauncherMode(mode bool) { //gd:Steam.setGameLauncherMode
	var frame = callframe.New()
	callframe.Arg(frame, mode)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setGameLauncherMode, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Sets the inset of the overlay notification from the corner specified by [method Steam.setOverlayNotificationPosition]. Integer should be number of pixels.
*/
//go:nosplit
func (self class) SetOverlayNotificationInset(horizontal int64, vertical int64) { //gd:Steam.setOverlayNotificationInset
	var frame = callframe.New()
	callframe.Arg(frame, horizontal)
	callframe.Arg(frame, vertical)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setOverlayNotificationInset, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Set the position where overlay shows notifications. Accepts the following integer inputs:
[codeblock]
• 0 / Top Left
• 1 / Top Right
• 2 / Bottom Left
• 3 / Bottom Right
[/codeblock]
*/
//go:nosplit
func (self class) SetOverlayNotificationPosition(pos int64) { //gd:Steam.setOverlayNotificationPosition
	var frame = callframe.New()
	callframe.Arg(frame, pos)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setOverlayNotificationPosition, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Set whether the HMD content will be streamed via Steam In-Home Streaming.
*/
//go:nosplit
func (self class) SetVRHeadsetStreamingEnabled(enabled bool) { //gd:Steam.setVRHeadsetStreamingEnabled
	var frame = callframe.New()
	callframe.Arg(frame, enabled)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_setVRHeadsetStreamingEnabled, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Opens a floating keyboard over the game content and sends OS keyboard keys directly to the game.
The text field position is specified in pixels relative the origin of the game window and is used to position the floating keyboard in a way that doesn't cover the text field.
*/
//go:nosplit
func (self class) ShowFloatingGamepadTextInput(input_mode FloatingGamepadTextInputMode, text_field_x_position int64, text_field_y_position int64, text_field_width int64, text_field_height int64) bool { //gd:Steam.showFloatingGamepadTextInput
	var frame = callframe.New()
	callframe.Arg(frame, input_mode)
	callframe.Arg(frame, text_field_x_position)
	callframe.Arg(frame, text_field_y_position)
	callframe.Arg(frame, text_field_width)
	callframe.Arg(frame, text_field_height)
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_showFloatingGamepadTextInput, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Activates the Big Picture text input dialog which only supports gamepad input.
*/
//go:nosplit
func (self class) ShowGamepadTextInput(input_mode GamepadTextInputMode, line_input_mode GamepadTextInputLineMode, description String.Readable, max_text int64, preset_text String.Readable) bool { //gd:Steam.showGamepadTextInput
	var frame = callframe.New()
	callframe.Arg(frame, input_mode)
	callframe.Arg(frame, line_input_mode)
	callframe.Arg(frame, pointers.Get(gd.InternalString(description)))
	callframe.Arg(frame, max_text)
	callframe.Arg(frame, pointers.Get(gd.InternalString(preset_text)))
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_showGamepadTextInput, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Ask SteamUI to create and render its OpenVR dashboard.
*/
//go:nosplit
func (self class) StartVRDashboard() { //gd:Steam.startVRDashboard
	var frame = callframe.New()
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_startVRDashboard, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) CheckFileSignature(file_name String.Readable) { //gd:Steam.checkFileSignature
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(file_name)))
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_checkFileSignature, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Get the OPF details for 360 video playback.
To retrieve the 360 OPF (open projection format) data to playback a 360 video, start by making a call to this, then the callback will indicate whether the request was successful. If it was successful, the actual OPF JSON data can be retrieved with a call to [method Steam.getOPFStringForApp].
[b]Note:[/b] Triggers a [signal Steam.get_opf_settings_result] callback.
*/
//go:nosplit
func (self class) GetOPFSettings(app_id int64) { //gd:Steam.getOPFSettings
	var frame = callframe.New()
	callframe.Arg(frame, app_id)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getOPFSettings, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Gets the OPF string for the specified video app ID.
Once the callback for [signal Steam.get_opf_settings_result] has been raised and the EResult indicates success, then calling this will return back the actual OPF data in a JSON format. The size of the OPF string varies, but at this time 48,000 bytes should be sufficient to contain the full string.
[b]Note:[/b] The data returned in a successful call to [method Steam.getOPFStringForApp] can only be retrieved once. If you need to retrieve it multiple times, a call to [method Steam.getOPFSettings] will need to be made each time.
*/
//go:nosplit
func (self class) GetOPFStringForApp(app_id int64) String.Readable { //gd:Steam.getOPFStringForApp
	var frame = callframe.New()
	callframe.Arg(frame, app_id)
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getOPFStringForApp, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

/*
Asynchronously gets the URL suitable for streaming the video associated with the specified video app ID.
[b]Note:[/b] Triggers a [signal Steam.get_video_result] callback.
*/
//go:nosplit
func (self class) GetVideoURL(app_id int64) { //gd:Steam.getVideoURL
	var frame = callframe.New()
	callframe.Arg(frame, app_id)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_getVideoURL, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Checks if the user is currently live broadcasting and gets the number of users.
The returned dictionary contains the following keys:
[codeblock]
┠╴broadcasting (bool)
┖╴viewers (int)
[/codeblock]
*/
//go:nosplit
func (self class) IsBroadcasting() Dictionary.Any { //gd:Steam.isBroadcasting
	var frame = callframe.New()
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.Steam.Bind_isBroadcasting, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret.Get())))
	frame.Free()
	return ret
}
func OnFileDetailsResult(cb func(result int, file_size []byte, file_hash int, flags int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("file_details_result"), gd.NewCallable(cb), 0)
}

func OnDlcInstalled(cb func(app int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("dlc_installed"), gd.NewCallable(cb), 0)
}

func OnNewLaunchUrlParameters(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("new_launch_url_parameters"), gd.NewCallable(cb), 0)
}

func OnTimedTrialStatus(cb func(app_id int, is_offline bool, seconds_allowed int, seconds_played int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("timed_trial_status"), gd.NewCallable(cb), 0)
}

func OnAvatarLoaded(cb func(avatar_id int, size int, data []any)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("avatar_loaded"), gd.NewCallable(cb), 0)
}

func OnAvatarImageLoaded(cb func(avatar_id int, avatar_index int, width int, height int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("avatar_image_loaded"), gd.NewCallable(cb), 0)
}

func OnRequestClanOfficerList(cb func(message string, officer_list []any)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("request_clan_officer_list"), gd.NewCallable(cb), 0)
}

func OnClanActivityDownloaded(cb func(activity map[any]any)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("clan_activity_downloaded"), gd.NewCallable(cb), 0)
}

func OnFriendRichPresenceUpdate(cb func(steam_id int, app_id int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("friend_rich_presence_update"), gd.NewCallable(cb), 0)
}

func OnEnumerateFollowingList(cb func(message string, following []any)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("enumerate_following_list"), gd.NewCallable(cb), 0)
}

func OnGetFollowerCount(cb func(result int, steam_id int, count int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("get_follower_count"), gd.NewCallable(cb), 0)
}

func OnIsFollowing(cb func(result int, steam_id int, following bool)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("is_following"), gd.NewCallable(cb), 0)
}

func OnConnectedChatJoin(cb func(chat_id int, steam_id int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("connected_chat_join"), gd.NewCallable(cb), 0)
}

func OnConnectedChatLeave(cb func(chat_id int, steam_id int, kicked bool, dropped bool)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("connected_chat_leave"), gd.NewCallable(cb), 0)
}

func OnConnectedClanChatMessage(cb func(chat map[any]any)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("connected_clan_chat_message"), gd.NewCallable(cb), 0)
}

func OnConnectedFriendChatMessage(cb func(chat map[any]any)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("connected_friend_chat_message"), gd.NewCallable(cb), 0)
}

func OnJoinRequested(cb func(lobby_id int, steam_id int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("join_requested"), gd.NewCallable(cb), 0)
}

func OnOverlayToggled(cb func(active bool, user_initiated bool, app_id int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("overlay_toggled"), gd.NewCallable(cb), 0)
}

func OnJoinGameRequested(cb func(user int, connect string)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("join_game_requested"), gd.NewCallable(cb), 0)
}

func OnChangeServerRequested(cb func(server string, password string)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("change_server_requested"), gd.NewCallable(cb), 0)
}

func OnJoinClanChatComplete(cb func(chat_id int, response int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("join_clan_chat_complete"), gd.NewCallable(cb), 0)
}

func OnPersonaStateChange(cb func(steam_id int, flags int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("persona_state_change"), gd.NewCallable(cb), 0)
}

func OnNameChanged(cb func(success bool, local_success bool, result int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("name_changed"), gd.NewCallable(cb), 0)
}

func OnOverlayBrowserProtocol(cb func(uri string)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("overlay_browser_protocol"), gd.NewCallable(cb), 0)
}

func OnUnreadChatMessagesChanged(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("unread_chat_messages_changed"), gd.NewCallable(cb), 0)
}

func OnEquippedProfileItemsChanged(cb func(steam_id int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("equipped_profile_items_changed"), gd.NewCallable(cb), 0)
}

func OnEquippedProfileItems(cb func(result int, steam_id int, profile_data map[any]any)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("equipped_profile_items"), gd.NewCallable(cb), 0)
}

func OnSearchForGameProgress(cb func(result int, search_id int, search_progress map[any]any)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("search_for_game_progress"), gd.NewCallable(cb), 0)
}

func OnSearchForGameResult(cb func(result int, search_id int, search_result map[any]any)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("search_for_game_result"), gd.NewCallable(cb), 0)
}

func OnRequestPlayersForGameProgress(cb func(result int, search_id int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("request_players_for_game_progress"), gd.NewCallable(cb), 0)
}

func OnRequestPlayersForGameResult(cb func(result int, search_id int, player_data map[any]any)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("request_players_for_game_result"), gd.NewCallable(cb), 0)
}

func OnRequestPlayersForGameFinalResult(cb func(result int, search_id int, game_id int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("request_players_for_game_final_result"), gd.NewCallable(cb), 0)
}

func OnSubmitPlayerResult(cb func(result int, game_id int, player_id int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("submit_player_result"), gd.NewCallable(cb), 0)
}

func OnEndGameResult(cb func(result int, game_id int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("end_game_result"), gd.NewCallable(cb), 0)
}

func OnHtmlBrowserReady(cb func(browser_handle int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("html_browser_ready"), gd.NewCallable(cb), 0)
}

func OnHtmlCanGoBackandforward(cb func(browser_handle int, go_back bool, go_forward bool)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("html_can_go_backandforward"), gd.NewCallable(cb), 0)
}

func OnHtmlChangedTitle(cb func(browser_handle int, title string)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("html_changed_title"), gd.NewCallable(cb), 0)
}

func OnHtmlCloseBrowser(cb func(browser_handle int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("html_close_browser"), gd.NewCallable(cb), 0)
}

func OnHtmlFileOpenDialog(cb func(browser_handle int, title string, initial_file string)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("html_file_open_dialog"), gd.NewCallable(cb), 0)
}

func OnHtmlFinishedRequest(cb func(browser_handle int, url string, title string)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("html_finished_request"), gd.NewCallable(cb), 0)
}

func OnHtmlHideTooltip(cb func(browser_handle int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("html_hide_tooltip"), gd.NewCallable(cb), 0)
}

func OnHtmlHorizontalScroll(cb func(browser_handle int, scroll_data map[any]any)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("html_horizontal_scroll"), gd.NewCallable(cb), 0)
}

func OnHtmlJsAlert(cb func(browser_handle int, message string)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("html_js_alert"), gd.NewCallable(cb), 0)
}

func OnHtmlJsConfirm(cb func(browser_handle int, message string)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("html_js_confirm"), gd.NewCallable(cb), 0)
}

func OnHtmlLinkAtPosition(cb func(browser_handle int, link_data map[any]any)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("html_link_at_position"), gd.NewCallable(cb), 0)
}

func OnHtmlNeedsPaint(cb func(browser_handle int, page_data map[any]any)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("html_needs_paint"), gd.NewCallable(cb), 0)
}

func OnHtmlNewWindow(cb func(browser_handle int, window_data map[any]any)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("html_new_window"), gd.NewCallable(cb), 0)
}

func OnHtmlOpenLinkInNewTab(cb func(browser_handle int, url string)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("html_open_link_in_new_tab"), gd.NewCallable(cb), 0)
}

func OnHtmlSearchResults(cb func(browser_handle int, results int, current_match int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("html_search_results"), gd.NewCallable(cb), 0)
}

func OnHtmlSetCursor(cb func(browser_handle int, mouse_cursor int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("html_set_cursor"), gd.NewCallable(cb), 0)
}

func OnHtmlShowTooltip(cb func(browser_handle int, message string)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("html_show_tooltip"), gd.NewCallable(cb), 0)
}

func OnHtmlStartRequest(cb func(browser_handle int, url string, target string, post_data string, redirect bool)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("html_start_request"), gd.NewCallable(cb), 0)
}

func OnHtmlStatusText(cb func(browser_handle int, message string)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("html_status_text"), gd.NewCallable(cb), 0)
}

func OnHtmlUpdateTooltip(cb func(browser_handle int, message string)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("html_update_tooltip"), gd.NewCallable(cb), 0)
}

func OnHtmlUrlChanged(cb func(browser_handle int, url_data map[any]any)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("html_url_changed"), gd.NewCallable(cb), 0)
}

func OnHtmlVerticalScroll(cb func(browser_handle int, scroll_data map[any]any)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("html_vertical_scroll"), gd.NewCallable(cb), 0)
}

func OnHttpRequestCompleted(cb func(cookie_handle int, context_value int, request_success bool, status_code int, body_size int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("http_request_completed"), gd.NewCallable(cb), 0)
}

func OnHttpRequestDataReceived(cb func(cookie_handle int, context_value int, offset int, bytes_received int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("http_request_data_received"), gd.NewCallable(cb), 0)
}

func OnHttpRequestHeadersReceived(cb func(cookie_handle int, context_value int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("http_request_headers_received"), gd.NewCallable(cb), 0)
}

func OnInputActionEvent(cb func(input_handle int, event_type int, action_handle int, is_active bool, action_data map[any]any)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("input_action_event"), gd.NewCallable(cb), 0)
}

func OnInputDeviceConnected(cb func(input_handle int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("input_device_connected"), gd.NewCallable(cb), 0)
}

func OnInputDeviceDisconnected(cb func(input_handle int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("input_device_disconnected"), gd.NewCallable(cb), 0)
}

func OnInputConfigurationLoaded(cb func(app_id int, device_handle int, config_data map[any]any)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("input_configuration_loaded"), gd.NewCallable(cb), 0)
}

func OnInputGamepadSlotChange(cb func(app_id int, device_handle int, device_type int, old_gamepad_slot int, new_gamepad_slot int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("input_gamepad_slot_change"), gd.NewCallable(cb), 0)
}

func OnInventoryDefinitionUpdate(cb func(definitions []any)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("inventory_definition_update"), gd.NewCallable(cb), 0)
}

func OnInventoryEligiblePromoItem(cb func(result int, cached bool, definitions []any)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("inventory_eligible_promo_item"), gd.NewCallable(cb), 0)
}

func OnInventoryFullUpdate(cb func(inventory_handle int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("inventory_full_update"), gd.NewCallable(cb), 0)
}

func OnInventoryResultReady(cb func(result int, inventory_handle int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("inventory_result_ready"), gd.NewCallable(cb), 0)
}

func OnInventoryStartPurchaseResult(cb func(result string, order_id int, transaction_id int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("inventory_start_purchase_result"), gd.NewCallable(cb), 0)
}

func OnInventoryRequestPricesResult(cb func(result int, currency string)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("inventory_request_prices_result"), gd.NewCallable(cb), 0)
}

func OnFavoritesListAccountsUpdated(cb func(result int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("favorites_list_accounts_updated"), gd.NewCallable(cb), 0)
}

func OnFavoritesListChanged(cb func(favorite map[any]any)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("favorites_list_changed"), gd.NewCallable(cb), 0)
}

func OnLobbyMessage(cb func(lobby_id int, user int, message string, chat_type int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("lobby_message"), gd.NewCallable(cb), 0)
}

func OnLobbyChatUpdate(cb func(lobby_id int, changed_id int, making_change_id int, chat_state int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("lobby_chat_update"), gd.NewCallable(cb), 0)
}

func OnLobbyCreated(cb func(connect int, lobby_id int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("lobby_created"), gd.NewCallable(cb), 0)
}

func OnLobbyDataUpdate(cb func(success int, lobby_id int, member_id int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("lobby_data_update"), gd.NewCallable(cb), 0)
}

func OnLobbyJoined(cb func(lobby int, permissions int, locked bool, response int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("lobby_joined"), gd.NewCallable(cb), 0)
}

func OnLobbyGameCreated(cb func(lobby_id int, server_id int, server_ip string, port int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("lobby_game_created"), gd.NewCallable(cb), 0)
}

func OnLobbyInvite(cb func(inviter int, lobby int, game int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("lobby_invite"), gd.NewCallable(cb), 0)
}

func OnLobbyMatchList(cb func(lobbies []any)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("lobby_match_list"), gd.NewCallable(cb), 0)
}

func OnLobbyKicked(cb func(lobby_id int, admin_id int, due_to_disconnect int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("lobby_kicked"), gd.NewCallable(cb), 0)
}

func OnRequestServerListServerResponded(cb func(request_handle int, server int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("request_server_list_server_responded"), gd.NewCallable(cb), 0)
}

func OnRequestServerListServerFailedToRespond(cb func(request_handle int, server int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("request_server_list_server_failed_to_respond"), gd.NewCallable(cb), 0)
}

func OnRequestServerListRefreshComplete(cb func(request_handle int, response int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("request_server_list_refresh_complete"), gd.NewCallable(cb), 0)
}

func OnPingServerResponded(cb func(server_details map[any]any)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("ping_server_responded"), gd.NewCallable(cb), 0)
}

func OnPingServerFailedToRespond(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("ping_server_failed_to_respond"), gd.NewCallable(cb), 0)
}

func OnPlayerDetailsPlayerAdded(cb func(name string, score int, time_played Float.X)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("player_details_player_added"), gd.NewCallable(cb), 0)
}

func OnPlayerDetailsFailedToRespond(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("player_details_failed_to_respond"), gd.NewCallable(cb), 0)
}

func OnPlayerDetailsRefreshComplete(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("player_details_refresh_complete"), gd.NewCallable(cb), 0)
}

func OnServerRulesResponded(cb func(rule string, value string)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("server_rules_responded"), gd.NewCallable(cb), 0)
}

func OnServerRulesFailedToRespond(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("server_rules_failed_to_respond"), gd.NewCallable(cb), 0)
}

func OnServerRulesRefreshComplete(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("server_rules_refresh_complete"), gd.NewCallable(cb), 0)
}

func OnMusicPlaybackStatusHasChanged(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("music_playback_status_has_changed"), gd.NewCallable(cb), 0)
}

func OnMusicVolumeHasChanged(cb func(new_volume Float.X)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("music_volume_has_changed"), gd.NewCallable(cb), 0)
}

func OnMusicPlayerRemoteToFront(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("music_player_remote_to_front"), gd.NewCallable(cb), 0)
}

func OnMusicPlayerRemoteWillActivate(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("music_player_remote_will_activate"), gd.NewCallable(cb), 0)
}

func OnMusicPlayerRemoteWillDeactivate(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("music_player_remote_will_deactivate"), gd.NewCallable(cb), 0)
}

func OnMusicPlayerSelectsPlaylistEntry(cb func(entry int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("music_player_selects_playlist_entry"), gd.NewCallable(cb), 0)
}

func OnMusicPlayerSelectsQueueEntry(cb func(entry int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("music_player_selects_queue_entry"), gd.NewCallable(cb), 0)
}

func OnMusicPlayerWantsLooped(cb func(looped bool)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("music_player_wants_looped"), gd.NewCallable(cb), 0)
}

func OnMusicPlayerWantsPause(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("music_player_wants_pause"), gd.NewCallable(cb), 0)
}

func OnMusicPlayerWantsPlayingRepeatStatus(cb func(status int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("music_player_wants_playing_repeat_status"), gd.NewCallable(cb), 0)
}

func OnMusicPlayerWantsPlayNext(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("music_player_wants_play_next"), gd.NewCallable(cb), 0)
}

func OnMusicPlayerWantsPlayPrevious(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("music_player_wants_play_previous"), gd.NewCallable(cb), 0)
}

func OnMusicPlayerWantsPlay(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("music_player_wants_play"), gd.NewCallable(cb), 0)
}

func OnMusicPlayerWantsShuffled(cb func(shuffled bool)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("music_player_wants_shuffled"), gd.NewCallable(cb), 0)
}

func OnMusicPlayerWantsVolume(cb func(volume Float.X)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("music_player_wants_volume"), gd.NewCallable(cb), 0)
}

func OnMusicPlayerWillQuit(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("music_player_will_quit"), gd.NewCallable(cb), 0)
}

func OnP2pSessionRequest(cb func(remote_steam_id int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("p2p_session_request"), gd.NewCallable(cb), 0)
}

func OnP2pSessionConnectFail(cb func(remote_steam_id int, session_error int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("p2p_session_connect_fail"), gd.NewCallable(cb), 0)
}

func OnNetworkMessagesSessionRequest(cb func(remote_steam_id int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("network_messages_session_request"), gd.NewCallable(cb), 0)
}

func OnNetworkMessagesSessionFailed(cb func(reason int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("network_messages_session_failed"), gd.NewCallable(cb), 0)
}

func OnNetworkConnectionStatusChanged(cb func(connect_handle int, connection map[any]any, old_state int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("network_connection_status_changed"), gd.NewCallable(cb), 0)
}

func OnNetworkAuthenticationStatus(cb func(available int, debug_message string)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("network_authentication_status"), gd.NewCallable(cb), 0)
}

func OnFakeIpResult(cb func(result int, remote_fake_steam_id int, fake_ip string, port_list []any)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("fake_ip_result"), gd.NewCallable(cb), 0)
}

func OnRelayNetworkStatus(cb func(available int, ping_measurement int, available_config int, available_relay int, debug_message string)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("relay_network_status"), gd.NewCallable(cb), 0)
}

func OnParentalSettingChanged(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("parental_setting_changed"), gd.NewCallable(cb), 0)
}

func OnJoinParty(cb func(result int, beacon_id int, steam_id int, connect_string string)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("join_party"), gd.NewCallable(cb), 0)
}

func OnCreateBeacon(cb func(result int, beacon_id int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("create_beacon"), gd.NewCallable(cb), 0)
}

func OnReservationNotification(cb func(beacon_id int, steam_id int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("reservation_notification"), gd.NewCallable(cb), 0)
}

func OnChangeNumOpenSlots(cb func(result int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("change_num_open_slots"), gd.NewCallable(cb), 0)
}

func OnAvailableBeaconLocationsUpdated(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("available_beacon_locations_updated"), gd.NewCallable(cb), 0)
}

func OnActiveBeaconsUpdated(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("active_beacons_updated"), gd.NewCallable(cb), 0)
}

func OnRemotePlaySessionConnected(cb func(session_id int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("remote_play_session_connected"), gd.NewCallable(cb), 0)
}

func OnRemotePlaySessionDisconnected(cb func(session_id int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("remote_play_session_disconnected"), gd.NewCallable(cb), 0)
}

func OnFileReadAsyncComplete(cb func(file_read map[any]any)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("file_read_async_complete"), gd.NewCallable(cb), 0)
}

func OnFileShareResult(cb func(result int, handle int, name string)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("file_share_result"), gd.NewCallable(cb), 0)
}

func OnFileWriteAsyncComplete(cb func(result int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("file_write_async_complete"), gd.NewCallable(cb), 0)
}

func OnDownloadUgcResult(cb func(result int, download_data map[any]any)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("download_ugc_result"), gd.NewCallable(cb), 0)
}

func OnUnsubscribeItem(cb func(result int, file_id int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("unsubscribe_item"), gd.NewCallable(cb), 0)
}

func OnSubscribeItem(cb func(result int, file_id int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("subscribe_item"), gd.NewCallable(cb), 0)
}

func OnLocalFileChanged(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("local_file_changed"), gd.NewCallable(cb), 0)
}

func OnScreenshotReady(cb func(handle int, result int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("screenshot_ready"), gd.NewCallable(cb), 0)
}

func OnScreenshotRequested(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("screenshot_requested"), gd.NewCallable(cb), 0)
}

func OnTimelineEventRecordingExists(cb func(event_id int, recording_exists bool)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("timeline_event_recording_exists"), gd.NewCallable(cb), 0)
}

func OnTimelineGamePhaseRecordingExists(cb func(phase_id string, recording_ms int, longest_clip_ms int, clip_count int, screenshot_count int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("timeline_game_phase_recording_exists"), gd.NewCallable(cb), 0)
}

func OnAddAppDependencyResult(cb func(result int, file_id int, app_id int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("add_app_dependency_result"), gd.NewCallable(cb), 0)
}

func OnAddUgcDependencyResult(cb func(result int, file_id int, child_id int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("add_ugc_dependency_result"), gd.NewCallable(cb), 0)
}

func OnItemCreated(cb func(result int, file_id int, accept_tos bool)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("item_created"), gd.NewCallable(cb), 0)
}

func OnItemDownloaded(cb func(result int, file_id int, app_id int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("item_downloaded"), gd.NewCallable(cb), 0)
}

func OnGetAppDependenciesResult(cb func(result int, file_id int, app_dependencies int, total_app_dependencies int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("get_app_dependencies_result"), gd.NewCallable(cb), 0)
}

func OnItemDeleted(cb func(result int, file_id int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("item_deleted"), gd.NewCallable(cb), 0)
}

func OnGetItemVoteResult(cb func(result int, file_id int, vote_up bool, vote_down bool, vote_skipped bool)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("get_item_vote_result"), gd.NewCallable(cb), 0)
}

func OnItemInstalled(cb func(app_id int, file_id int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("item_installed"), gd.NewCallable(cb), 0)
}

func OnRemoveAppDependencyResult(cb func(result int, file_id int, app_id int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("remove_app_dependency_result"), gd.NewCallable(cb), 0)
}

func OnRemoveUgcDependencyResult(cb func(result int, file_id int, child_id int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("remove_ugc_dependency_result"), gd.NewCallable(cb), 0)
}

func OnSetUserItemVote(cb func(result int, file_id int, vote_up bool)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("set_user_item_vote"), gd.NewCallable(cb), 0)
}

func OnStartPlaytimeTracking(cb func(result int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("start_playtime_tracking"), gd.NewCallable(cb), 0)
}

func OnUgcQueryCompleted(cb func(handle int, result int, results_returned int, total_matching int, cached bool)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("ugc_query_completed"), gd.NewCallable(cb), 0)
}

func OnStopPlaytimeTracking(cb func(result int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("stop_playtime_tracking"), gd.NewCallable(cb), 0)
}

func OnItemUpdated(cb func(result int, need_to_accept_tos bool)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("item_updated"), gd.NewCallable(cb), 0)
}

func OnUserFavoriteItemsListChanged(cb func(result int, file_id int, was_add_request bool)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("user_favorite_items_list_changed"), gd.NewCallable(cb), 0)
}

func OnWorkshopEulaStatus(cb func(result int, app_id int, eula_data map[any]any)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("workshop_eula_status"), gd.NewCallable(cb), 0)
}

func OnUserSubscribedItemsListChanged(cb func(app_id int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("user_subscribed_items_list_changed"), gd.NewCallable(cb), 0)
}

func OnClientGameServerDeny(cb func(app_id int, ip string, server_port int, secure int, reason int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("client_game_server_deny"), gd.NewCallable(cb), 0)
}

func OnDurationControl(cb func(result int, duration map[any]any)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("duration_control"), gd.NewCallable(cb), 0)
}

func OnEncryptedAppTicketResponse(cb func(result string)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("encrypted_app_ticket_response"), gd.NewCallable(cb), 0)
}

func OnGameWebCallback(cb func(url string)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("game_web_callback"), gd.NewCallable(cb), 0)
}

func OnGetAuthSessionTicketResponse(cb func(auth_ticket int, result int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("get_auth_session_ticket_response"), gd.NewCallable(cb), 0)
}

func OnGetTicketForWebApi(cb func(auth_ticket int, result int, ticket_size int, ticket_buffer []any)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("get_ticket_for_web_api"), gd.NewCallable(cb), 0)
}

func OnIpcFailure(cb func(atype int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("ipc_failure"), gd.NewCallable(cb), 0)
}

func OnLicensesUpdated(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("licenses_updated"), gd.NewCallable(cb), 0)
}

func OnMicrotransactionAuthResponse(cb func(app_id int, order_id int, authorized bool)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("microtransaction_auth_response"), gd.NewCallable(cb), 0)
}

func OnSteamServerConnectFailed(cb func(result int, retrying bool)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("steam_server_connect_failed"), gd.NewCallable(cb), 0)
}

func OnSteamServerConnected(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("steam_server_connected"), gd.NewCallable(cb), 0)
}

func OnSteamServerDisconnected(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("steam_server_disconnected"), gd.NewCallable(cb), 0)
}

func OnStoreAuthUrlResponse(cb func(url string)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("store_auth_url_response"), gd.NewCallable(cb), 0)
}

func OnValidateAuthTicketResponse(cb func(auth_id int, response int, owner_id int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("validate_auth_ticket_response"), gd.NewCallable(cb), 0)
}

func OnCurrentStatsReceived(cb func(game_id int, result int, user_id int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("current_stats_received"), gd.NewCallable(cb), 0)
}

func OnGlobalAchievementPercentagesReady(cb func(game_id int, result int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("global_achievement_percentages_ready"), gd.NewCallable(cb), 0)
}

func OnGlobalStatsReceived(cb func(game_id int, result string)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("global_stats_received"), gd.NewCallable(cb), 0)
}

func OnLeaderboardFindResult(cb func(leaderboard_handle int, found int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("leaderboard_find_result"), gd.NewCallable(cb), 0)
}

func OnLeaderboardScoresDownloaded(cb func(message string, leaderboard_handle int, leaderboard_entries []any)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("leaderboard_scores_downloaded"), gd.NewCallable(cb), 0)
}

func OnLeaderboardScoreUploaded(cb func(success bool, this_handle int, this_score map[any]any)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("leaderboard_score_uploaded"), gd.NewCallable(cb), 0)
}

func OnLeaderboardUgcSet(cb func(leaderboard_handle int, result string)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("leaderboard_ugc_set"), gd.NewCallable(cb), 0)
}

func OnNumberOfCurrentPlayers(cb func(success int, players int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("number_of_current_players"), gd.NewCallable(cb), 0)
}

func OnUserAchievementIconFetched(cb func(game_id int, achievement_name string, was_achieved bool, icon_handle int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("user_achievement_icon_fetched"), gd.NewCallable(cb), 0)
}

func OnUserAchievementStored(cb func(game_id int, group_achieve bool, achievement_name string, current_progress int, max_progress int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("user_achievement_stored"), gd.NewCallable(cb), 0)
}

func OnUserStatsReceived(cb func(game_id int, result int, user_id int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("user_stats_received"), gd.NewCallable(cb), 0)
}

func OnUserStatsStored(cb func(game_id int, result int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("user_stats_stored"), gd.NewCallable(cb), 0)
}

func OnUserStatsUnloaded(cb func(user_id int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("user_stats_unloaded"), gd.NewCallable(cb), 0)
}

func OnCheckFileSignature(cb func(signature string)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("check_file_signature"), gd.NewCallable(cb), 0)
}

func OnGamepadTextInputDismissed(cb func(submitted bool, entered_text string, app_id int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("gamepad_text_input_dismissed"), gd.NewCallable(cb), 0)
}

func OnIpCountry(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("ip_country"), gd.NewCallable(cb), 0)
}

func OnLowPower(cb func(power int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("low_power"), gd.NewCallable(cb), 0)
}

func OnSteamApiCallCompleted(cb func(async_call int, callback int, parameter int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("steam_api_call_completed"), gd.NewCallable(cb), 0)
}

func OnSteamShutdown(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("steam_shutdown"), gd.NewCallable(cb), 0)
}

func OnAppResumingFromSuspend(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("app_resuming_from_suspend"), gd.NewCallable(cb), 0)
}

func OnFloatingGamepadTextInputDismissed(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("floating_gamepad_text_input_dismissed"), gd.NewCallable(cb), 0)
}

func OnFilterTextDictionaryChanged(cb func(language int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("filter_text_dictionary_changed"), gd.NewCallable(cb), 0)
}

func OnGetOpfSettingsResult(cb func(result int, app_id int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("get_opf_settings_result"), gd.NewCallable(cb), 0)
}

func OnGetVideoResult(cb func(result int, app_id int, url string)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("get_video_result"), gd.NewCallable(cb), 0)
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Object.Advanced(self.AsObject()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Object.Instance(self.AsObject()), name)
	}
}
func init() {
	gdclass.Register("Steam", func(ptr gd.Object) any { return [1]gdclass.Steam{*(*gdclass.Steam)(unsafe.Pointer(&ptr))} })
}

type AccountType int //gd:Steam.AccountType

const (
	AccountTypeInvalid        AccountType = 0
	AccountTypeIndividual     AccountType = 1
	AccountTypeMultiseat      AccountType = 2
	AccountTypeGameServer     AccountType = 3
	AccountTypeAnonGameServer AccountType = 4
	AccountTypePending        AccountType = 5
	AccountTypeContentServer  AccountType = 6
	AccountTypeClan           AccountType = 7
	AccountTypeChat           AccountType = 8
	AccountTypeConsoleUser    AccountType = 9
	AccountTypeAnonUser       AccountType = 10
	AccountTypeMax            AccountType = 11
)

type APICallFailure int //gd:Steam.APICallFailure

const (
	SteamApiCallFailureNone               APICallFailure = -1
	SteamApiCallFailureSteamGone          APICallFailure = 0
	SteamApiCallFailureNetworkFailure     APICallFailure = 1
	SteamApiCallFailureInvalidHandle      APICallFailure = 2
	SteamApiCallFailureMismatchedCallback APICallFailure = 3
)

type AudioPlaybackStatus int //gd:Steam.AudioPlaybackStatus

const (
	AudioPlaybackUndefined AudioPlaybackStatus = 0
	AudioPlaybackPlaying   AudioPlaybackStatus = 1
	AudioPlaybackPaused    AudioPlaybackStatus = 2
	AudioPlaybackIdle      AudioPlaybackStatus = 3
)

type AuthSessionResponse int //gd:Steam.AuthSessionResponse

const (
	AuthSessionResponseOk                               AuthSessionResponse = 0
	AuthSessionResponseUserNotConnectedToSteam          AuthSessionResponse = 1
	AuthSessionResponseNoLicenseOrExpired               AuthSessionResponse = 2
	AuthSessionResponseVacBanned                        AuthSessionResponse = 3
	AuthSessionResponseLoggedInElsewhere                AuthSessionResponse = 4
	AuthSessionResponseVacCheckTimedOut                 AuthSessionResponse = 5
	AuthSessionResponseAuthTicketCanceled               AuthSessionResponse = 6
	AuthSessionResponseAuthTicketInvalidAlreadyUsed     AuthSessionResponse = 7
	AuthSessionResponseAuthTicketInvalid                AuthSessionResponse = 8
	AuthSessionResponsePublisherIssuedBan               AuthSessionResponse = 9
	AuthSessionResponseAuthTicketNetworkIdentityFailure AuthSessionResponse = 10
)

type AvatarSizes int //gd:Steam.AvatarSizes

const (
	AvatarSmall  AvatarSizes = 1
	AvatarMedium AvatarSizes = 2
	AvatarLarge  AvatarSizes = 3
)

type BeginAuthSessionResult int //gd:Steam.BeginAuthSessionResult

const (
	BeginAuthSessionResultOk               BeginAuthSessionResult = 0
	BeginAuthSessionResultInvalidTicket    BeginAuthSessionResult = 1
	BeginAuthSessionResultDuplicateRequest BeginAuthSessionResult = 2
	BeginAuthSessionResultInvalidVersion   BeginAuthSessionResult = 3
	BeginAuthSessionResultGameMismatch     BeginAuthSessionResult = 4
	BeginAuthSessionResultExpiredTicket    BeginAuthSessionResult = 5
)

type BetaBranchFlags int //gd:Steam.BetaBranchFlags

const (
	BetaBranchNone      BetaBranchFlags = 0
	BetaBranchDefault   BetaBranchFlags = 1
	BetaBranchAvailable BetaBranchFlags = 2
	BetaBranchPrivate   BetaBranchFlags = 4
	BetaBranchSelected  BetaBranchFlags = 8
	BetaBranchInstalled BetaBranchFlags = 16
)

type BroadcastUploadResult int //gd:Steam.BroadcastUploadResult

const (
	BroadcastUploadResultNone              BroadcastUploadResult = 0
	BroadcastUploadResultOk                BroadcastUploadResult = 1
	BroadcastUploadResultInitFailed        BroadcastUploadResult = 2
	BroadcastUploadResultFrameFailed       BroadcastUploadResult = 3
	BroadcastUploadResultTimeOut           BroadcastUploadResult = 4
	BroadcastUploadResultBandwidthExceeded BroadcastUploadResult = 5
	BroadcastUploadResultLowFps            BroadcastUploadResult = 6
	BroadcastUploadResultMissingKeyframes  BroadcastUploadResult = 7
	BroadcastUploadResultNoConnection      BroadcastUploadResult = 8
	BroadcastUploadResultRelayFailed       BroadcastUploadResult = 9
	BroadcastUploadResultSettingsChanged   BroadcastUploadResult = 10
	BroadcastUploadResultMissingAudio      BroadcastUploadResult = 11
	BroadcastUploadResultTooFarBehind      BroadcastUploadResult = 12
	BroadcastUploadResultTranscodeBehind   BroadcastUploadResult = 13
	BroadcastUploadResultNotAllowedToPlay  BroadcastUploadResult = 14
	BroadcastUploadResultBusy              BroadcastUploadResult = 15
	BroadcastUploadResultBanned            BroadcastUploadResult = 16
	BroadcastUploadResultAlreadyActive     BroadcastUploadResult = 17
	BroadcastUploadResultForcedOff         BroadcastUploadResult = 18
	BroadcastUploadResultAudioBehind       BroadcastUploadResult = 19
	BroadcastUploadResultShutdown          BroadcastUploadResult = 20
	BroadcastUploadResultDisconnect        BroadcastUploadResult = 21
	BroadcastUploadResultVideoInitFailed   BroadcastUploadResult = 22
	BroadcastUploadResultAudioInitFailed   BroadcastUploadResult = 23
)

type ChatEntryType int //gd:Steam.ChatEntryType

const (
	ChatEntryTypeInvalid          ChatEntryType = 0
	ChatEntryTypeChatMsg          ChatEntryType = 1
	ChatEntryTypeTyping           ChatEntryType = 2
	ChatEntryTypeInviteGame       ChatEntryType = 3
	ChatEntryTypeEmote            ChatEntryType = 4
	ChatEntryTypeLeftConversation ChatEntryType = 6
	ChatEntryTypeEntered          ChatEntryType = 7
	ChatEntryTypeWasKicked        ChatEntryType = 8
	ChatEntryTypeWasBanned        ChatEntryType = 9
	ChatEntryTypeDisconnected     ChatEntryType = 10
	ChatEntryTypeHistoricalChat   ChatEntryType = 11
	ChatEntryTypeLinkBlocked      ChatEntryType = 14
)

type ChatMemberStateChange int //gd:Steam.ChatMemberStateChange

const (
	ChatMemberStateChangeEntered      ChatMemberStateChange = 1
	ChatMemberStateChangeLeft         ChatMemberStateChange = 2
	ChatMemberStateChangeDisconnected ChatMemberStateChange = 4
	ChatMemberStateChangeKicked       ChatMemberStateChange = 8
	ChatMemberStateChangeBanned       ChatMemberStateChange = 16
)

type ChatRoomEnterResponse int //gd:Steam.ChatRoomEnterResponse

const (
	ChatRoomEnterResponseSuccess           ChatRoomEnterResponse = 1
	ChatRoomEnterResponseDoesntExist       ChatRoomEnterResponse = 2
	ChatRoomEnterResponseNotAllowed        ChatRoomEnterResponse = 3
	ChatRoomEnterResponseFull              ChatRoomEnterResponse = 4
	ChatRoomEnterResponseError             ChatRoomEnterResponse = 5
	ChatRoomEnterResponseBanned            ChatRoomEnterResponse = 6
	ChatRoomEnterResponseLimited           ChatRoomEnterResponse = 7
	ChatRoomEnterResponseClanDisabled      ChatRoomEnterResponse = 8
	ChatRoomEnterResponseCommunityBan      ChatRoomEnterResponse = 9
	ChatRoomEnterResponseMemberBlockedYou  ChatRoomEnterResponse = 10
	ChatRoomEnterResponseYouBlockedMember  ChatRoomEnterResponse = 11
	ChatRoomEnterResponseRateLimitExceeded ChatRoomEnterResponse = 15
)

type ChatSteamIDInstanceFlags int //gd:Steam.ChatSteamIDInstanceFlags

const (
	ChatAccountInstanceMask  ChatSteamIDInstanceFlags = 4095
	ChatInstanceFlagClan     ChatSteamIDInstanceFlags = 524288
	ChatInstanceFlagLobby    ChatSteamIDInstanceFlags = 262144
	ChatInstanceFlagMmsLobby ChatSteamIDInstanceFlags = 131072
)

type CommunityProfileItemType int //gd:Steam.CommunityProfileItemType

const (
	ProfileItemTypeAnimatedAvatar        CommunityProfileItemType = 0
	ProfileItemTypeAvatarFrame           CommunityProfileItemType = 1
	ProfileItemTypeProfileModifier       CommunityProfileItemType = 2
	ProfileItemTypeProfileBackground     CommunityProfileItemType = 3
	ProfileItemTypeMiniProfileBackground CommunityProfileItemType = 4
)

type CommunityProfileItemProperty int //gd:Steam.CommunityProfileItemProperty

const (
	ProfileItemPropertyImageSmall     CommunityProfileItemProperty = 0
	ProfileItemPropertyImageLarge     CommunityProfileItemProperty = 1
	ProfileItemPropertyInternalName   CommunityProfileItemProperty = 2
	ProfileItemPropertyTitle          CommunityProfileItemProperty = 3
	ProfileItemPropertyDescription    CommunityProfileItemProperty = 4
	ProfileItemPropertyAppId          CommunityProfileItemProperty = 5
	ProfileItemPropertyTypeId         CommunityProfileItemProperty = 6
	ProfileItemPropertyClass          CommunityProfileItemProperty = 7
	ProfileItemPropertyMovieWebm      CommunityProfileItemProperty = 8
	ProfileItemPropertyMovieMp4       CommunityProfileItemProperty = 9
	ProfileItemPropertyMovieWebmSmall CommunityProfileItemProperty = 10
	ProfileItemPropertyMovieMp4Small  CommunityProfileItemProperty = 11
)

type ControllerHapticLocation int //gd:Steam.ControllerHapticLocation

const (
	ControllerHapticLocationLeft  ControllerHapticLocation = 1
	ControllerHapticLocationRight ControllerHapticLocation = 2
	ControllerHapticLocationBoth  ControllerHapticLocation = 3
)

type ControllerHapticType int //gd:Steam.ControllerHapticType

const (
	ControllerHapticTypeOff   ControllerHapticType = 0
	ControllerHapticTypeTick  ControllerHapticType = 1
	ControllerHapticTypeClick ControllerHapticType = 2
)

type ControllerPad int //gd:Steam.ControllerPad

const (
	SteamControllerPadLeft  ControllerPad = 0
	SteamControllerPadRight ControllerPad = 1
)

type DenyReason int //gd:Steam.DenyReason

const (
	DenyInvalid                 DenyReason = 0
	DenyInvalidVersion          DenyReason = 1
	DenyGeneric                 DenyReason = 2
	DenyNotLoggedOn             DenyReason = 3
	DenyNoLicense               DenyReason = 4
	DenyCheater                 DenyReason = 5
	DenyLoggedInElsewhere       DenyReason = 6
	DenyUnknownText             DenyReason = 7
	DenyIncompatibleAntiCheat   DenyReason = 8
	DenyMemoryCorruption        DenyReason = 9
	DenyIncompatibleSoftware    DenyReason = 10
	DenySteamConnectionLost     DenyReason = 11
	DenySteamConnectionError    DenyReason = 12
	DenySteamResponseTimedOut   DenyReason = 13
	DenySteamValidationStalled  DenyReason = 14
	DenySteamOwnerLeftGuestUser DenyReason = 15
)

type DeviceFormFactor int //gd:Steam.DeviceFormFactor

const (
	FormFactorUnknown   DeviceFormFactor = 0
	FormFactorPhone     DeviceFormFactor = 1
	FormFactorTablet    DeviceFormFactor = 2
	FormFactorComputer  DeviceFormFactor = 3
	FormFactorTv        DeviceFormFactor = 4
	FormFactorVrHeadset DeviceFormFactor = 5
)

type DurationControlNotification int //gd:Steam.DurationControlNotification

const (
	DurationControlNotificationNone          DurationControlNotification = 0
	DurationControlNotification1Hour         DurationControlNotification = 1
	DurationControlNotification3Hours        DurationControlNotification = 2
	DurationControlNotificationHalfProgress  DurationControlNotification = 3
	DurationControlNotificationNoProgress    DurationControlNotification = 4
	DurationControlNotificationExitSoon3h    DurationControlNotification = 5
	DurationControlNotificationExitSoon5h    DurationControlNotification = 6
	DurationControlNotificationExitSoonNight DurationControlNotification = 7
)

type DurationControlOnlineState int //gd:Steam.DurationControlOnlineState

const (
	DurationControlOnlineStateInvalid            DurationControlOnlineState = 0
	DurationControlOnlineStateOffline            DurationControlOnlineState = 1
	DurationControlOnlineStateOnline             DurationControlOnlineState = 2
	DurationControlOnlineStateOnlineHighPriority DurationControlOnlineState = 3
)

type DurationControlProgress int //gd:Steam.DurationControlProgress

const (
	DurationControlProgressFull  DurationControlProgress = 0
	DurationControlProgressHalf  DurationControlProgress = 1
	DurationControlProgressNone  DurationControlProgress = 2
	DurationControlExitSoon3h    DurationControlProgress = 3
	DurationControlExitSoon5h    DurationControlProgress = 4
	DurationControlExitSoonNight DurationControlProgress = 5
)

type FilePathType int //gd:Steam.FilePathType

const (
	FilePathTypeInvalid     FilePathType = 0
	FilePathTypeAbsolute    FilePathType = 1
	FilePathTypeApiFilename FilePathType = 2
)

type FloatingGamepadTextInputMode int //gd:Steam.FloatingGamepadTextInputMode

const (
	FloatingGamepadTextInputModeSingleLine    FloatingGamepadTextInputMode = 0
	FloatingGamepadTextInputModeMultipleLines FloatingGamepadTextInputMode = 1
	FloatingGamepadTextInputModeEmail         FloatingGamepadTextInputMode = 2
	FloatingGamepadTextInputModeNumeric       FloatingGamepadTextInputMode = 3
)

type FriendFlags int //gd:Steam.FriendFlags

const (
	FriendFlagNone                 FriendFlags = 0
	FriendFlagBlocked              FriendFlags = 1
	FriendFlagFriendshipRequested  FriendFlags = 2
	FriendFlagImmediate            FriendFlags = 4
	FriendFlagClanMember           FriendFlags = 8
	FriendFlagOnGameServer         FriendFlags = 16
	FriendFlagRequestingFriendship FriendFlags = 128
	FriendFlagRequestingInfo       FriendFlags = 256
	FriendFlagIgnored              FriendFlags = 512
	FriendFlagIgnoredFriend        FriendFlags = 1024
	FriendFlagChatMember           FriendFlags = 4096
	FriendFlagAll                  FriendFlags = 65535
)

type FriendRelationship int //gd:Steam.FriendRelationship

const (
	FriendRelationNone             FriendRelationship = 0
	FriendRelationBlocked          FriendRelationship = 1
	FriendRelationRequestRecipient FriendRelationship = 2
	FriendRelationFriend           FriendRelationship = 3
	FriendRelationRequestInitiator FriendRelationship = 4
	FriendRelationIgnored          FriendRelationship = 5
	FriendRelationIgnoredFriend    FriendRelationship = 6
	FriendRelationSuggested        FriendRelationship = 7
	FriendRelationMax              FriendRelationship = 8
)

type GameIDType int //gd:Steam.GameIDType

const (
	GameTypeApp      GameIDType = 0
	GameTypeGameMod  GameIDType = 1
	GameTypeShortcut GameIDType = 2
	GameTypeP2p      GameIDType = 3
)

type GamepadTextInputLineMode int //gd:Steam.GamepadTextInputLineMode

const (
	GamepadTextInputLineModeSingleLine    GamepadTextInputLineMode = 0
	GamepadTextInputLineModeMultipleLines GamepadTextInputLineMode = 1
)

type GamepadTextInputMode int //gd:Steam.GamepadTextInputMode

const (
	GamepadTextInputModeNormal   GamepadTextInputMode = 0
	GamepadTextInputModePassword GamepadTextInputMode = 1
)

type GameSearchErrorCode int //gd:Steam.GameSearchErrorCode

const (
	GameSearchErrorCodeOk                     GameSearchErrorCode = 1
	GameSearchErrorCodeSearchAreadyInProgress GameSearchErrorCode = 2
	GameSearchErrorCodeNoSearchInProgress     GameSearchErrorCode = 3
	GameSearchErrorCodeNotLobbyLeader         GameSearchErrorCode = 4
	GameSearchErrorCodeNoHostAvailable        GameSearchErrorCode = 5
	GameSearchErrorCodeSearchParamsInvalid    GameSearchErrorCode = 6
	GameSearchErrorCodeOffline                GameSearchErrorCode = 7
	GameSearchErrorCodeNotAuthorized          GameSearchErrorCode = 8
	GameSearchErrorCodeUnknownError           GameSearchErrorCode = 9
)

type HTMLKeyModifiers int //gd:Steam.HTMLKeyModifiers

const (
	HtmlKeyModifierNone      HTMLKeyModifiers = 0
	HtmlKeyModifierAltDown   HTMLKeyModifiers = 1
	HtmlKeyModifierCtrlDown  HTMLKeyModifiers = 2
	HtmlKeyModifierShiftDown HTMLKeyModifiers = 4
)

type HTMLMouseButton int //gd:Steam.HTMLMouseButton

const (
	HtmlMouseButtonLeft   HTMLMouseButton = 0
	HtmlMouseButtonRight  HTMLMouseButton = 1
	HtmlMouseButtonMiddle HTMLMouseButton = 2
)

type HTTPMethod int //gd:Steam.HTTPMethod

const (
	HttpMethodInvalid HTTPMethod = 0
	HttpMethodGet     HTTPMethod = 1
	HttpMethodHead    HTTPMethod = 2
	HttpMethodPost    HTTPMethod = 3
	HttpMethodPut     HTTPMethod = 4
	HttpMethodDelete  HTTPMethod = 5
	HttpMethodOptions HTTPMethod = 6
	HttpMethodPatch   HTTPMethod = 7
)

type HTTPStatusCode int //gd:Steam.HTTPStatusCode

const (
	HttpStatusCodeInvalid                         HTTPStatusCode = 0
	HttpStatusCode100Continue                     HTTPStatusCode = 100
	HttpStatusCode101SwitchingProtocols           HTTPStatusCode = 101
	HttpStatusCode200Ok                           HTTPStatusCode = 200
	HttpStatusCode201Created                      HTTPStatusCode = 201
	HttpStatusCode202Accepted                     HTTPStatusCode = 202
	HttpStatusCode203NonAuthoritative             HTTPStatusCode = 203
	HttpStatusCode204NoContent                    HTTPStatusCode = 204
	HttpStatusCode205ResetContent                 HTTPStatusCode = 205
	HttpStatusCode206PartialContent               HTTPStatusCode = 206
	HttpStatusCode300MultipleChoices              HTTPStatusCode = 300
	HttpStatusCode301MovedPermanently             HTTPStatusCode = 301
	HttpStatusCode302Found                        HTTPStatusCode = 302
	HttpStatusCode303SeeOther                     HTTPStatusCode = 303
	HttpStatusCode304NotModified                  HTTPStatusCode = 304
	HttpStatusCode305UseProxy                     HTTPStatusCode = 305
	HttpStatusCode307TemporaryRedirect            HTTPStatusCode = 307
	HttpStatusCode308PermanentRedirect            HTTPStatusCode = 308
	HttpStatusCode400BadRequest                   HTTPStatusCode = 400
	HttpStatusCode401Unauthorized                 HTTPStatusCode = 401
	HttpStatusCode402PaymentRequired              HTTPStatusCode = 402
	HttpStatusCode403Forbidden                    HTTPStatusCode = 403
	HttpStatusCode404NotFound                     HTTPStatusCode = 404
	HttpStatusCode405MethodNotAllowed             HTTPStatusCode = 405
	HttpStatusCode406NotAcceptable                HTTPStatusCode = 406
	HttpStatusCode407ProxyAuthRequired            HTTPStatusCode = 407
	HttpStatusCode408RequestTimeout               HTTPStatusCode = 408
	HttpStatusCode409Conflict                     HTTPStatusCode = 409
	HttpStatusCode410Gone                         HTTPStatusCode = 410
	HttpStatusCode411LengthRequired               HTTPStatusCode = 411
	HttpStatusCode412PreconditionFailed           HTTPStatusCode = 412
	HttpStatusCode413RequestEntityTooLarge        HTTPStatusCode = 413
	HttpStatusCode414RequestUriTooLong            HTTPStatusCode = 414
	HttpStatusCode415UnsupportedMediaType         HTTPStatusCode = 415
	HttpStatusCode416RequestedRangeNotSatisfiable HTTPStatusCode = 416
	HttpStatusCode417ExpectationFailed            HTTPStatusCode = 417
	HttpStatusCode4xxUnknown                      HTTPStatusCode = 418
	HttpStatusCode429TooManyRequests              HTTPStatusCode = 429
	HttpStatusCode444ConnectionClosed             HTTPStatusCode = 444
	HttpStatusCode500InternalServerError          HTTPStatusCode = 500
	HttpStatusCode501NotImplemented               HTTPStatusCode = 501
	HttpStatusCode502BadGateway                   HTTPStatusCode = 502
	HttpStatusCode503ServiceUnavailable           HTTPStatusCode = 503
	HttpStatusCode504GatewayTimeout               HTTPStatusCode = 504
	HttpStatusCode505HttpVersionNotSupported      HTTPStatusCode = 505
	HttpStatusCode5xxUnknown                      HTTPStatusCode = 599
)

type InputActionEventType int //gd:Steam.InputActionEventType

const (
	InputActionEventTypeDigitalAction InputActionEventType = 0
	InputActionEventTypeAnalogAction  InputActionEventType = 1
)

type InputActionOrigin int //gd:Steam.InputActionOrigin

const (
	InputActionOriginNone                              InputActionOrigin = 0
	InputActionOriginSteamcontrollerA                  InputActionOrigin = 1
	InputActionOriginSteamcontrollerB                  InputActionOrigin = 2
	InputActionOriginSteamcontrollerX                  InputActionOrigin = 3
	InputActionOriginSteamcontrollerY                  InputActionOrigin = 4
	InputActionOriginSteamcontrollerLeftbumper         InputActionOrigin = 5
	InputActionOriginSteamcontrollerRightbumper        InputActionOrigin = 6
	InputActionOriginSteamcontrollerLeftgrip           InputActionOrigin = 7
	InputActionOriginSteamcontrollerRightgrip          InputActionOrigin = 8
	InputActionOriginSteamcontrollerStart              InputActionOrigin = 9
	InputActionOriginSteamcontrollerBack               InputActionOrigin = 10
	InputActionOriginSteamcontrollerLeftpadTouch       InputActionOrigin = 11
	InputActionOriginSteamcontrollerLeftpadSwipe       InputActionOrigin = 12
	InputActionOriginSteamcontrollerLeftpadClick       InputActionOrigin = 13
	InputActionOriginSteamcontrollerLeftpadDpadnorth   InputActionOrigin = 14
	InputActionOriginSteamcontrollerLeftpadDpadsouth   InputActionOrigin = 15
	InputActionOriginSteamcontrollerLeftpadDpadwest    InputActionOrigin = 16
	InputActionOriginSteamcontrollerLeftpadDpadeast    InputActionOrigin = 17
	InputActionOriginSteamcontrollerRightpadTouch      InputActionOrigin = 18
	InputActionOriginSteamcontrollerRightpadSwipe      InputActionOrigin = 19
	InputActionOriginSteamcontrollerRightpadClick      InputActionOrigin = 20
	InputActionOriginSteamcontrollerRightpadDpadnorth  InputActionOrigin = 21
	InputActionOriginSteamcontrollerRightpadDpadsouth  InputActionOrigin = 22
	InputActionOriginSteamcontrollerRightpadDpadwest   InputActionOrigin = 23
	InputActionOriginSteamcontrollerRightpadDpadeast   InputActionOrigin = 24
	InputActionOriginSteamcontrollerLefttriggerPull    InputActionOrigin = 25
	InputActionOriginSteamcontrollerLefttriggerClick   InputActionOrigin = 26
	InputActionOriginSteamcontrollerRighttriggerPull   InputActionOrigin = 27
	InputActionOriginSteamcontrollerRighttriggerClick  InputActionOrigin = 28
	InputActionOriginSteamcontrollerLeftstickMove      InputActionOrigin = 29
	InputActionOriginSteamcontrollerLeftstickClick     InputActionOrigin = 30
	InputActionOriginSteamcontrollerLeftstickDpadnorth InputActionOrigin = 31
	InputActionOriginSteamcontrollerLeftstickDpadsouth InputActionOrigin = 32
	InputActionOriginSteamcontrollerLeftstickDpadwest  InputActionOrigin = 33
	InputActionOriginSteamcontrollerLeftstickDpadeast  InputActionOrigin = 34
	InputActionOriginSteamcontrollerGyroMove           InputActionOrigin = 35
	InputActionOriginSteamcontrollerGyroPitch          InputActionOrigin = 36
	InputActionOriginSteamcontrollerGyroYaw            InputActionOrigin = 37
	InputActionOriginSteamcontrollerGyroRoll           InputActionOrigin = 38
	InputActionOriginSteamcontrollerReserved0          InputActionOrigin = 39
	InputActionOriginSteamcontrollerReserved1          InputActionOrigin = 40
	InputActionOriginSteamcontrollerReserved2          InputActionOrigin = 41
	InputActionOriginSteamcontrollerReserved3          InputActionOrigin = 42
	InputActionOriginSteamcontrollerReserved4          InputActionOrigin = 43
	InputActionOriginSteamcontrollerReserved5          InputActionOrigin = 44
	InputActionOriginSteamcontrollerReserved6          InputActionOrigin = 45
	InputActionOriginSteamcontrollerReserved7          InputActionOrigin = 46
	InputActionOriginSteamcontrollerReserved8          InputActionOrigin = 47
	InputActionOriginSteamcontrollerReserved9          InputActionOrigin = 48
	InputActionOriginSteamcontrollerReserved10         InputActionOrigin = 49
	InputActionOriginPs4X                              InputActionOrigin = 50
	InputActionOriginPs4Circle                         InputActionOrigin = 51
	InputActionOriginPs4Triangle                       InputActionOrigin = 52
	InputActionOriginPs4Square                         InputActionOrigin = 53
	InputActionOriginPs4Leftbumper                     InputActionOrigin = 54
	InputActionOriginPs4Rightbumper                    InputActionOrigin = 55
	InputActionOriginPs4Options                        InputActionOrigin = 56
	InputActionOriginPs4Share                          InputActionOrigin = 57
	InputActionOriginPs4LeftpadTouch                   InputActionOrigin = 58
	InputActionOriginPs4LeftpadSwipe                   InputActionOrigin = 59
	InputActionOriginPs4LeftpadClick                   InputActionOrigin = 60
	InputActionOriginPs4LeftpadDpadnorth               InputActionOrigin = 61
	InputActionOriginPs4LeftpadDpadsouth               InputActionOrigin = 62
	InputActionOriginPs4LeftpadDpadwest                InputActionOrigin = 63
	InputActionOriginPs4LeftpadDpadeast                InputActionOrigin = 64
	InputActionOriginPs4RightpadTouch                  InputActionOrigin = 65
	InputActionOriginPs4RightpadSwipe                  InputActionOrigin = 66
	InputActionOriginPs4RightpadClick                  InputActionOrigin = 67
	InputActionOriginPs4RightpadDpadnorth              InputActionOrigin = 68
	InputActionOriginPs4RightpadDpadsouth              InputActionOrigin = 69
	InputActionOriginPs4RightpadDpadwest               InputActionOrigin = 70
	InputActionOriginPs4RightpadDpadeast               InputActionOrigin = 71
	InputActionOriginPs4CenterpadTouch                 InputActionOrigin = 72
	InputActionOriginPs4CenterpadSwipe                 InputActionOrigin = 73
	InputActionOriginPs4CenterpadClick                 InputActionOrigin = 74
	InputActionOriginPs4CenterpadDpadnorth             InputActionOrigin = 75
	InputActionOriginPs4CenterpadDpadsouth             InputActionOrigin = 76
	InputActionOriginPs4CenterpadDpadwest              InputActionOrigin = 77
	InputActionOriginPs4CenterpadDpadeast              InputActionOrigin = 78
	InputActionOriginPs4LefttriggerPull                InputActionOrigin = 79
	InputActionOriginPs4LefttriggerClick               InputActionOrigin = 80
	InputActionOriginPs4RighttriggerPull               InputActionOrigin = 81
	InputActionOriginPs4RighttriggerClick              InputActionOrigin = 82
	InputActionOriginPs4LeftstickMove                  InputActionOrigin = 83
	InputActionOriginPs4LeftstickClick                 InputActionOrigin = 84
	InputActionOriginPs4LeftstickDpadnorth             InputActionOrigin = 85
	InputActionOriginPs4LeftstickDpadsouth             InputActionOrigin = 86
	InputActionOriginPs4LeftstickDpadwest              InputActionOrigin = 87
	InputActionOriginPs4LeftstickDpadeast              InputActionOrigin = 88
	InputActionOriginPs4RightstickMove                 InputActionOrigin = 89
	InputActionOriginPs4RightstickClick                InputActionOrigin = 90
	InputActionOriginPs4RightstickDpadnorth            InputActionOrigin = 91
	InputActionOriginPs4RightstickDpadsouth            InputActionOrigin = 92
	InputActionOriginPs4RightstickDpadwest             InputActionOrigin = 93
	InputActionOriginPs4RightstickDpadeast             InputActionOrigin = 94
	InputActionOriginPs4DpadNorth                      InputActionOrigin = 95
	InputActionOriginPs4DpadSouth                      InputActionOrigin = 96
	InputActionOriginPs4DpadWest                       InputActionOrigin = 97
	InputActionOriginPs4DpadEast                       InputActionOrigin = 98
	InputActionOriginPs4GyroMove                       InputActionOrigin = 99
	InputActionOriginPs4GyroPitch                      InputActionOrigin = 100
	InputActionOriginPs4GyroYaw                        InputActionOrigin = 101
	InputActionOriginPs4GyroRoll                       InputActionOrigin = 102
	InputActionOriginPs4DpadMove                       InputActionOrigin = 103
	InputActionOriginPs4Reserved1                      InputActionOrigin = 104
	InputActionOriginPs4Reserved2                      InputActionOrigin = 105
	InputActionOriginPs4Reserved3                      InputActionOrigin = 106
	InputActionOriginPs4Reserved4                      InputActionOrigin = 107
	InputActionOriginPs4Reserved5                      InputActionOrigin = 108
	InputActionOriginPs4Reserved6                      InputActionOrigin = 109
	InputActionOriginPs4Reserved7                      InputActionOrigin = 110
	InputActionOriginPs4Reserved8                      InputActionOrigin = 111
	InputActionOriginPs4Reserved9                      InputActionOrigin = 112
	InputActionOriginPs4Reserved10                     InputActionOrigin = 113
	InputActionOriginXboxoneA                          InputActionOrigin = 114
	InputActionOriginXboxoneB                          InputActionOrigin = 115
	InputActionOriginXboxoneX                          InputActionOrigin = 116
	InputActionOriginXboxoneY                          InputActionOrigin = 117
	InputActionOriginXboxoneLeftbumper                 InputActionOrigin = 118
	InputActionOriginXboxoneRightbumper                InputActionOrigin = 119
	InputActionOriginXboxoneMenu                       InputActionOrigin = 120
	InputActionOriginXboxoneView                       InputActionOrigin = 121
	InputActionOriginXboxoneLefttriggerPull            InputActionOrigin = 122
	InputActionOriginXboxoneLefttriggerClick           InputActionOrigin = 123
	InputActionOriginXboxoneRighttriggerPull           InputActionOrigin = 124
	InputActionOriginXboxoneRighttriggerClick          InputActionOrigin = 125
	InputActionOriginXboxoneLeftstickMove              InputActionOrigin = 126
	InputActionOriginXboxoneLeftstickClick             InputActionOrigin = 127
	InputActionOriginXboxoneLeftstickDpadnorth         InputActionOrigin = 128
	InputActionOriginXboxoneLeftstickDpadsouth         InputActionOrigin = 129
	InputActionOriginXboxoneLeftstickDpadwest          InputActionOrigin = 130
	InputActionOriginXboxoneLeftstickDpadeast          InputActionOrigin = 131
	InputActionOriginXboxoneRightstickMove             InputActionOrigin = 132
	InputActionOriginXboxoneRightstickClick            InputActionOrigin = 133
	InputActionOriginXboxoneRightstickDpadnorth        InputActionOrigin = 134
	InputActionOriginXboxoneRightstickDpadsouth        InputActionOrigin = 135
	InputActionOriginXboxoneRightstickDpadwest         InputActionOrigin = 136
	InputActionOriginXboxoneRightstickDpadeast         InputActionOrigin = 137
	InputActionOriginXboxoneDpadNorth                  InputActionOrigin = 138
	InputActionOriginXboxoneDpadSouth                  InputActionOrigin = 139
	InputActionOriginXboxoneDpadWest                   InputActionOrigin = 140
	InputActionOriginXboxoneDpadEast                   InputActionOrigin = 141
	InputActionOriginXboxoneDpadMove                   InputActionOrigin = 142
	InputActionOriginXboxoneLeftgripLower              InputActionOrigin = 143
	InputActionOriginXboxoneLeftgripUpper              InputActionOrigin = 144
	InputActionOriginXboxoneRightgripLower             InputActionOrigin = 145
	InputActionOriginXboxoneRightgripUpper             InputActionOrigin = 146
	InputActionOriginXboxoneShare                      InputActionOrigin = 147
	InputActionOriginXboxoneReserved6                  InputActionOrigin = 148
	InputActionOriginXboxoneReserved7                  InputActionOrigin = 149
	InputActionOriginXboxoneReserved8                  InputActionOrigin = 150
	InputActionOriginXboxoneReserved9                  InputActionOrigin = 151
	InputActionOriginXboxoneReserved10                 InputActionOrigin = 152
	InputActionOriginXbox360A                          InputActionOrigin = 153
	InputActionOriginXbox360B                          InputActionOrigin = 154
	InputActionOriginXbox360X                          InputActionOrigin = 155
	InputActionOriginXbox360Y                          InputActionOrigin = 156
	InputActionOriginXbox360Leftbumper                 InputActionOrigin = 157
	InputActionOriginXbox360Rightbumper                InputActionOrigin = 158
	InputActionOriginXbox360Start                      InputActionOrigin = 159
	InputActionOriginXbox360Back                       InputActionOrigin = 160
	InputActionOriginXbox360LefttriggerPull            InputActionOrigin = 161
	InputActionOriginXbox360LefttriggerClick           InputActionOrigin = 162
	InputActionOriginXbox360RighttriggerPull           InputActionOrigin = 163
	InputActionOriginXbox360RighttriggerClick          InputActionOrigin = 164
	InputActionOriginXbox360LeftstickMove              InputActionOrigin = 165
	InputActionOriginXbox360LeftstickClick             InputActionOrigin = 166
	InputActionOriginXbox360LeftstickDpadnorth         InputActionOrigin = 167
	InputActionOriginXbox360LeftstickDpadsouth         InputActionOrigin = 168
	InputActionOriginXbox360LeftstickDpadwest          InputActionOrigin = 169
	InputActionOriginXbox360LeftstickDpadeast          InputActionOrigin = 170
	InputActionOriginXbox360RightstickMove             InputActionOrigin = 171
	InputActionOriginXbox360RightstickClick            InputActionOrigin = 172
	InputActionOriginXbox360RightstickDpadnorth        InputActionOrigin = 173
	InputActionOriginXbox360RightstickDpadsouth        InputActionOrigin = 174
	InputActionOriginXbox360RightstickDpadwest         InputActionOrigin = 175
	InputActionOriginXbox360RightstickDpadeast         InputActionOrigin = 176
	InputActionOriginXbox360DpadNorth                  InputActionOrigin = 177
	InputActionOriginXbox360DpadSouth                  InputActionOrigin = 178
	InputActionOriginXbox360DpadWest                   InputActionOrigin = 179
	InputActionOriginXbox360DpadEast                   InputActionOrigin = 180
	InputActionOriginXbox360DpadMove                   InputActionOrigin = 181
	InputActionOriginXbox360Reserved1                  InputActionOrigin = 182
	InputActionOriginXbox360Reserved2                  InputActionOrigin = 183
	InputActionOriginXbox360Reserved3                  InputActionOrigin = 184
	InputActionOriginXbox360Reserved4                  InputActionOrigin = 185
	InputActionOriginXbox360Reserved5                  InputActionOrigin = 186
	InputActionOriginXbox360Reserved6                  InputActionOrigin = 187
	InputActionOriginXbox360Reserved7                  InputActionOrigin = 188
	InputActionOriginXbox360Reserved8                  InputActionOrigin = 189
	InputActionOriginXbox360Reserved9                  InputActionOrigin = 190
	InputActionOriginXbox360Reserved10                 InputActionOrigin = 191
	InputActionOriginSwitchA                           InputActionOrigin = 192
	InputActionOriginSwitchB                           InputActionOrigin = 193
	InputActionOriginSwitchX                           InputActionOrigin = 194
	InputActionOriginSwitchY                           InputActionOrigin = 195
	InputActionOriginSwitchLeftbumper                  InputActionOrigin = 196
	InputActionOriginSwitchRightbumper                 InputActionOrigin = 197
	InputActionOriginSwitchPlus                        InputActionOrigin = 198
	InputActionOriginSwitchMinus                       InputActionOrigin = 199
	InputActionOriginSwitchCapture                     InputActionOrigin = 200
	InputActionOriginSwitchLefttriggerPull             InputActionOrigin = 201
	InputActionOriginSwitchLefttriggerClick            InputActionOrigin = 202
	InputActionOriginSwitchRighttriggerPull            InputActionOrigin = 203
	InputActionOriginSwitchRighttriggerClick           InputActionOrigin = 204
	InputActionOriginSwitchLeftstickMove               InputActionOrigin = 205
	InputActionOriginSwitchLeftstickClick              InputActionOrigin = 206
	InputActionOriginSwitchLeftstickDpadnorth          InputActionOrigin = 207
	InputActionOriginSwitchLeftstickDpadsouth          InputActionOrigin = 208
	InputActionOriginSwitchLeftstickDpadwest           InputActionOrigin = 209
	InputActionOriginSwitchLeftstickDpadeast           InputActionOrigin = 210
	InputActionOriginSwitchRightstickMove              InputActionOrigin = 211
	InputActionOriginSwitchRightstickClick             InputActionOrigin = 212
	InputActionOriginSwitchRightstickDpadnorth         InputActionOrigin = 213
	InputActionOriginSwitchRightstickDpadsouth         InputActionOrigin = 214
	InputActionOriginSwitchRightstickDpadwest          InputActionOrigin = 215
	InputActionOriginSwitchRightstickDpadeast          InputActionOrigin = 216
	InputActionOriginSwitchDpadNorth                   InputActionOrigin = 217
	InputActionOriginSwitchDpadSouth                   InputActionOrigin = 218
	InputActionOriginSwitchDpadWest                    InputActionOrigin = 219
	InputActionOriginSwitchDpadEast                    InputActionOrigin = 220
	InputActionOriginSwitchProgyroMove                 InputActionOrigin = 221
	InputActionOriginSwitchProgyroPitch                InputActionOrigin = 222
	InputActionOriginSwitchProgyroYaw                  InputActionOrigin = 223
	InputActionOriginSwitchProgyroRoll                 InputActionOrigin = 224
	InputActionOriginSwitchDpadMove                    InputActionOrigin = 225
	InputActionOriginSwitchReserved1                   InputActionOrigin = 226
	InputActionOriginSwitchReserved2                   InputActionOrigin = 227
	InputActionOriginSwitchReserved3                   InputActionOrigin = 228
	InputActionOriginSwitchReserved4                   InputActionOrigin = 229
	InputActionOriginSwitchReserved5                   InputActionOrigin = 230
	InputActionOriginSwitchReserved6                   InputActionOrigin = 231
	InputActionOriginSwitchReserved7                   InputActionOrigin = 232
	InputActionOriginSwitchReserved8                   InputActionOrigin = 233
	InputActionOriginSwitchReserved9                   InputActionOrigin = 234
	InputActionOriginSwitchReserved10                  InputActionOrigin = 235
	InputActionOriginSwitchRightgyroMove               InputActionOrigin = 236
	InputActionOriginSwitchRightgyroPitch              InputActionOrigin = 237
	InputActionOriginSwitchRightgyroYaw                InputActionOrigin = 238
	InputActionOriginSwitchRightgyroRoll               InputActionOrigin = 239
	InputActionOriginSwitchLeftgyroMove                InputActionOrigin = 240
	InputActionOriginSwitchLeftgyroPitch               InputActionOrigin = 241
	InputActionOriginSwitchLeftgyroYaw                 InputActionOrigin = 242
	InputActionOriginSwitchLeftgyroRoll                InputActionOrigin = 243
	InputActionOriginSwitchLeftgripLower               InputActionOrigin = 244
	InputActionOriginSwitchLeftgripUpper               InputActionOrigin = 245
	InputActionOriginSwitchRightgripLower              InputActionOrigin = 246
	InputActionOriginSwitchRightgripUpper              InputActionOrigin = 247
	InputActionOriginSwitchJoyconButtonN               InputActionOrigin = 248
	InputActionOriginSwitchJoyconButtonE               InputActionOrigin = 249
	InputActionOriginSwitchJoyconButtonS               InputActionOrigin = 250
	InputActionOriginSwitchJoyconButtonW               InputActionOrigin = 251
	InputActionOriginSwitchReserved15                  InputActionOrigin = 252
	InputActionOriginSwitchReserved16                  InputActionOrigin = 253
	InputActionOriginSwitchReserved17                  InputActionOrigin = 254
	InputActionOriginSwitchReserved18                  InputActionOrigin = 255
	InputActionOriginSwitchReserved19                  InputActionOrigin = 256
	InputActionOriginSwitchReserved20                  InputActionOrigin = 257
	InputActionOriginPs5X                              InputActionOrigin = 258
	InputActionOriginPs5Circle                         InputActionOrigin = 259
	InputActionOriginPs5Triangle                       InputActionOrigin = 260
	InputActionOriginPs5Square                         InputActionOrigin = 261
	InputActionOriginPs5Leftbumper                     InputActionOrigin = 262
	InputActionOriginPs5Rightbumper                    InputActionOrigin = 263
	InputActionOriginPs5Option                         InputActionOrigin = 264
	InputActionOriginPs5Create                         InputActionOrigin = 265
	InputActionOriginPs5Mute                           InputActionOrigin = 266
	InputActionOriginPs5LeftpadTouch                   InputActionOrigin = 267
	InputActionOriginPs5LeftpadSwipe                   InputActionOrigin = 268
	InputActionOriginPs5LeftpadClick                   InputActionOrigin = 269
	InputActionOriginPs5LeftpadDpadnorth               InputActionOrigin = 270
	InputActionOriginPs5LeftpadDpadsouth               InputActionOrigin = 271
	InputActionOriginPs5LeftpadDpadwest                InputActionOrigin = 272
	InputActionOriginPs5LeftpadDpadeast                InputActionOrigin = 273
	InputActionOriginPs5RightpadTouch                  InputActionOrigin = 274
	InputActionOriginPs5RightpadSwipe                  InputActionOrigin = 275
	InputActionOriginPs5RightpadClick                  InputActionOrigin = 276
	InputActionOriginPs5RightpadDpadnorth              InputActionOrigin = 277
	InputActionOriginPs5RightpadDpadsouth              InputActionOrigin = 278
	InputActionOriginPs5RightpadDpadwest               InputActionOrigin = 279
	InputActionOriginPs5RightpadDpadeast               InputActionOrigin = 280
	InputActionOriginPs5CenterpadTouch                 InputActionOrigin = 281
	InputActionOriginPs5CenterpadSwipe                 InputActionOrigin = 282
	InputActionOriginPs5CenterpadClick                 InputActionOrigin = 283
	InputActionOriginPs5CenterpadDpadnorth             InputActionOrigin = 284
	InputActionOriginPs5CenterpadDpadsouth             InputActionOrigin = 285
	InputActionOriginPs5CenterpadDpadwest              InputActionOrigin = 286
	InputActionOriginPs5CenterpadDpadeast              InputActionOrigin = 287
	InputActionOriginPs5LefttriggerPull                InputActionOrigin = 288
	InputActionOriginPs5LefttriggerClick               InputActionOrigin = 289
	InputActionOriginPs5RighttriggerPull               InputActionOrigin = 290
	InputActionOriginPs5RighttriggerClick              InputActionOrigin = 291
	InputActionOriginPs5LeftstickMove                  InputActionOrigin = 292
	InputActionOriginPs5LeftstickClick                 InputActionOrigin = 293
	InputActionOriginPs5LeftstickDpadnorth             InputActionOrigin = 294
	InputActionOriginPs5LeftstickDpadsouth             InputActionOrigin = 295
	InputActionOriginPs5LeftstickDpadwest              InputActionOrigin = 296
	InputActionOriginPs5LeftstickDpadeast              InputActionOrigin = 297
	InputActionOriginPs5RightstickMove                 InputActionOrigin = 298
	InputActionOriginPs5RightstickClick                InputActionOrigin = 299
	InputActionOriginPs5RightstickDpadnorth            InputActionOrigin = 300
	InputActionOriginPs5RightstickDpadsouth            InputActionOrigin = 301
	InputActionOriginPs5RightstickDpadwest             InputActionOrigin = 302
	InputActionOriginPs5RightstickDpadeast             InputActionOrigin = 303
	InputActionOriginPs5DpadNorth                      InputActionOrigin = 304
	InputActionOriginPs5DpadSouth                      InputActionOrigin = 305
	InputActionOriginPs5DpadWest                       InputActionOrigin = 306
	InputActionOriginPs5DpadEast                       InputActionOrigin = 307
	InputActionOriginPs5GyroMove                       InputActionOrigin = 308
	InputActionOriginPs5GyroPitch                      InputActionOrigin = 309
	InputActionOriginPs5GyroYaw                        InputActionOrigin = 310
	InputActionOriginPs5GyroRoll                       InputActionOrigin = 311
	InputActionOriginPs5DpadMove                       InputActionOrigin = 312
	InputActionOriginPs5Leftgrip                       InputActionOrigin = 313
	InputActionOriginPs5Rightgrip                      InputActionOrigin = 314
	InputActionOriginPs5Leftfn                         InputActionOrigin = 315
	InputActionOriginPs5Rightfn                        InputActionOrigin = 316
	InputActionOriginPs5Reserved5                      InputActionOrigin = 317
	InputActionOriginPs5Reserved6                      InputActionOrigin = 318
	InputActionOriginPs5Reserved7                      InputActionOrigin = 319
	InputActionOriginPs5Reserved8                      InputActionOrigin = 320
	InputActionOriginPs5Reserved9                      InputActionOrigin = 321
	InputActionOriginPs5Reserved10                     InputActionOrigin = 322
	InputActionOriginPs5Reserved11                     InputActionOrigin = 323
	InputActionOriginPs5Reserved12                     InputActionOrigin = 324
	InputActionOriginPs5Reserved13                     InputActionOrigin = 325
	InputActionOriginPs5Reserved14                     InputActionOrigin = 326
	InputActionOriginPs5Reserved15                     InputActionOrigin = 327
	InputActionOriginPs5Reserved16                     InputActionOrigin = 328
	InputActionOriginPs5Reserved17                     InputActionOrigin = 329
	InputActionOriginPs5Reserved18                     InputActionOrigin = 330
	InputActionOriginPs5Reserved19                     InputActionOrigin = 331
	InputActionOriginPs5Reserved20                     InputActionOrigin = 332
	InputActionOriginSteamdeckA                        InputActionOrigin = 333
	InputActionOriginSteamdeckB                        InputActionOrigin = 334
	InputActionOriginSteamdeckX                        InputActionOrigin = 335
	InputActionOriginSteamdeckY                        InputActionOrigin = 336
	InputActionOriginSteamdeckL1                       InputActionOrigin = 337
	InputActionOriginSteamdeckR1                       InputActionOrigin = 338
	InputActionOriginSteamdeckMenu                     InputActionOrigin = 339
	InputActionOriginSteamdeckView                     InputActionOrigin = 340
	InputActionOriginSteamdeckLeftpadTouch             InputActionOrigin = 341
	InputActionOriginSteamdeckLeftpadSwipe             InputActionOrigin = 342
	InputActionOriginSteamdeckLeftpadClick             InputActionOrigin = 343
	InputActionOriginSteamdeckLeftpadDpadnorth         InputActionOrigin = 344
	InputActionOriginSteamdeckLeftpadDpadsouth         InputActionOrigin = 345
	InputActionOriginSteamdeckLeftpadDpadwest          InputActionOrigin = 346
	InputActionOriginSteamdeckLeftpadDpadeast          InputActionOrigin = 347
	InputActionOriginSteamdeckRightpadTouch            InputActionOrigin = 348
	InputActionOriginSteamdeckRightpadSwipe            InputActionOrigin = 349
	InputActionOriginSteamdeckRightpadClick            InputActionOrigin = 350
	InputActionOriginSteamdeckRightpadDpadnorth        InputActionOrigin = 351
	InputActionOriginSteamdeckRightpadDpadsouth        InputActionOrigin = 352
	InputActionOriginSteamdeckRightpadDpadwest         InputActionOrigin = 353
	InputActionOriginSteamdeckRightpadDpadeast         InputActionOrigin = 354
	InputActionOriginSteamdeckL2Softpull               InputActionOrigin = 355
	InputActionOriginSteamdeckL2                       InputActionOrigin = 356
	InputActionOriginSteamdeckR2Softpull               InputActionOrigin = 357
	InputActionOriginSteamdeckR2                       InputActionOrigin = 358
	InputActionOriginSteamdeckLeftstickMove            InputActionOrigin = 359
	InputActionOriginSteamdeckL3                       InputActionOrigin = 360
	InputActionOriginSteamdeckLeftstickDpadnorth       InputActionOrigin = 361
	InputActionOriginSteamdeckLeftstickDpadsouth       InputActionOrigin = 362
	InputActionOriginSteamdeckLeftstickDpadwest        InputActionOrigin = 363
	InputActionOriginSteamdeckLeftstickDpadeast        InputActionOrigin = 364
	InputActionOriginSteamdeckLeftstickTouch           InputActionOrigin = 365
	InputActionOriginSteamdeckRightstickMove           InputActionOrigin = 366
	InputActionOriginSteamdeckR3                       InputActionOrigin = 367
	InputActionOriginSteamdeckRightstickDpadnorth      InputActionOrigin = 368
	InputActionOriginSteamdeckRightstickDpadsouth      InputActionOrigin = 369
	InputActionOriginSteamdeckRightstickDpadwest       InputActionOrigin = 370
	InputActionOriginSteamdeckRightstickDpadeast       InputActionOrigin = 371
	InputActionOriginSteamdeckRightstickTouch          InputActionOrigin = 372
	InputActionOriginSteamdeckL4                       InputActionOrigin = 373
	InputActionOriginSteamdeckR4                       InputActionOrigin = 374
	InputActionOriginSteamdeckL5                       InputActionOrigin = 375
	InputActionOriginSteamdeckR5                       InputActionOrigin = 376
	InputActionOriginSteamdeckDpadMove                 InputActionOrigin = 377
	InputActionOriginSteamdeckDpadNorth                InputActionOrigin = 378
	InputActionOriginSteamdeckDpadSouth                InputActionOrigin = 379
	InputActionOriginSteamdeckDpadWest                 InputActionOrigin = 380
	InputActionOriginSteamdeckDpadEast                 InputActionOrigin = 381
	InputActionOriginSteamdeckGyroMove                 InputActionOrigin = 382
	InputActionOriginSteamdeckGyroPitch                InputActionOrigin = 383
	InputActionOriginSteamdeckGyroYaw                  InputActionOrigin = 384
	InputActionOriginSteamdeckGyroRoll                 InputActionOrigin = 385
	InputActionOriginSteamdeckReserved1                InputActionOrigin = 386
	InputActionOriginSteamdeckReserved2                InputActionOrigin = 387
	InputActionOriginSteamdeckReserved3                InputActionOrigin = 388
	InputActionOriginSteamdeckReserved4                InputActionOrigin = 389
	InputActionOriginSteamdeckReserved5                InputActionOrigin = 390
	InputActionOriginSteamdeckReserved6                InputActionOrigin = 391
	InputActionOriginSteamdeckReserved7                InputActionOrigin = 392
	InputActionOriginSteamdeckReserved8                InputActionOrigin = 393
	InputActionOriginSteamdeckReserved9                InputActionOrigin = 394
	InputActionOriginSteamdeckReserved10               InputActionOrigin = 395
	InputActionOriginSteamdeckReserved11               InputActionOrigin = 396
	InputActionOriginSteamdeckReserved12               InputActionOrigin = 397
	InputActionOriginSteamdeckReserved13               InputActionOrigin = 398
	InputActionOriginSteamdeckReserved14               InputActionOrigin = 399
	InputActionOriginSteamdeckReserved15               InputActionOrigin = 400
	InputActionOriginSteamdeckReserved16               InputActionOrigin = 401
	InputActionOriginSteamdeckReserved17               InputActionOrigin = 402
	InputActionOriginSteamdeckReserved18               InputActionOrigin = 403
	InputActionOriginSteamdeckReserved19               InputActionOrigin = 404
	InputActionOriginSteamdeckReserved20               InputActionOrigin = 405
	InputActionOriginHoripadM1                         InputActionOrigin = 406
	InputActionOriginHoripadM2                         InputActionOrigin = 407
	InputActionOriginHoripadL4                         InputActionOrigin = 408
	InputActionOriginHoripadR4                         InputActionOrigin = 409
	InputActionOriginCount                             InputActionOrigin = 410
	InputActionOriginMaximumPossibleValue              InputActionOrigin = 32767
)

type InputConfigurationEnableType int //gd:Steam.InputConfigurationEnableType

const (
	InputConfigurationEnableTypeNone        InputConfigurationEnableType = 0
	InputConfigurationEnableTypePlaystation InputConfigurationEnableType = 1
	InputConfigurationEnableTypeXbox        InputConfigurationEnableType = 2
	InputConfigurationEnableTypeGeneric     InputConfigurationEnableType = 4
	InputConfigurationEnableTypeSwitch      InputConfigurationEnableType = 8
)

type InputGlyphSize int //gd:Steam.InputGlyphSize

const (
	InputGlyphSizeSmall  InputGlyphSize = 0
	InputGlyphSizeMedium InputGlyphSize = 1
	InputGlyphSizeLarge  InputGlyphSize = 2
	InputGlyphSizeCount  InputGlyphSize = 3
)

type InputGlyphStyle int //gd:Steam.InputGlyphStyle

const (
	InputGlyphStyleKnockout         InputGlyphStyle = 0
	InputGlyphStyleLight            InputGlyphStyle = 1
	InputGlyphStyleDark             InputGlyphStyle = 2
	InputGlyphStyleNeutralColorAbxy InputGlyphStyle = 16
	InputGlyphStyleSolidAbxy        InputGlyphStyle = 32
)

type InputLEDFlag int //gd:Steam.InputLEDFlag

const (
	InputLedFlagSetColor           InputLEDFlag = 0
	InputLedFlagRestoreUserDefault InputLEDFlag = 1
)

type InputSourceMode int //gd:Steam.InputSourceMode

const (
	InputSourceModeNone           InputSourceMode = 0
	InputSourceModeDpad           InputSourceMode = 1
	InputSourceModeButtons        InputSourceMode = 2
	InputSourceModeFourButtons    InputSourceMode = 3
	InputSourceModeAbsoluteMouse  InputSourceMode = 4
	InputSourceModeRelativeMouse  InputSourceMode = 5
	InputSourceModeJoystickMove   InputSourceMode = 6
	InputSourceModeJoystickMouse  InputSourceMode = 7
	InputSourceModeJoystickCamera InputSourceMode = 8
	InputSourceModeScrollWheel    InputSourceMode = 9
	InputSourceModeTrigger        InputSourceMode = 10
	InputSourceModeTouchMenu      InputSourceMode = 11
	InputSourceModeMouseJoystick  InputSourceMode = 12
	InputSourceModeMouseRegion    InputSourceMode = 13
	InputSourceModeRadialMenu     InputSourceMode = 14
	InputSourceModeSingleButton   InputSourceMode = 15
	InputSourceModeSwitch         InputSourceMode = 16
)

type InputType int //gd:Steam.InputType

const (
	InputTypeUnknown              InputType = 0
	InputTypeSteamController      InputType = 1
	InputTypeXbox360Controller    InputType = 2
	InputTypeXboxoneController    InputType = 3
	InputTypeGenericXinput        InputType = 4
	InputTypePs4Controller        InputType = 5
	InputTypeAppleMfiController   InputType = 6
	InputTypeAndroidController    InputType = 7
	InputTypeSwitchJoyconPair     InputType = 8
	InputTypeSwitchJoyconSingle   InputType = 9
	InputTypeSwitchProController  InputType = 10
	InputTypeMobileTouch          InputType = 11
	InputTypePs3Controller        InputType = 12
	InputTypePs5Controller        InputType = 13
	InputTypeSteamDeckController  InputType = 14
	InputTypeCount                InputType = 15
	InputTypeMaximumPossibleValue InputType = 255
)

type IPType int //gd:Steam.IPType

const (
	IpTypeIpv4 IPType = 0
	IpTypeIpv6 IPType = 1
)

type IPv6ConnectivityProtocol int //gd:Steam.IPv6ConnectivityProtocol

const (
	Ipv6ConnectivityProtocolInvalid IPv6ConnectivityProtocol = 0
	Ipv6ConnectivityProtocolHttp    IPv6ConnectivityProtocol = 1
	Ipv6ConnectivityProtocolUdp     IPv6ConnectivityProtocol = 2
)

type IPv6ConnectivityState int //gd:Steam.IPv6ConnectivityState

const (
	Ipv6ConnectivityStateUnknown IPv6ConnectivityState = 0
	Ipv6ConnectivityStateGood    IPv6ConnectivityState = 1
	Ipv6ConnectivityStateBad     IPv6ConnectivityState = 2
)

type ItemFlags int //gd:Steam.ItemFlags

const (
	SteamItemNoTrade  ItemFlags = 1
	SteamItemRemoved  ItemFlags = 256
	SteamItemConsumed ItemFlags = 512
)

type ItemPreviewType int //gd:Steam.ItemPreviewType

const (
	ItemPreviewTypeImage                         ItemPreviewType = 0
	ItemPreviewTypeYoutubeVideo                  ItemPreviewType = 1
	ItemPreviewTypeSketchfab                     ItemPreviewType = 2
	ItemPreviewTypeEnvironmentmapHorizontalCross ItemPreviewType = 3
	ItemPreviewTypeEnvironmentmapLatLong         ItemPreviewType = 4
	ItemPreviewTypeClip                          ItemPreviewType = 5
	ItemPreviewTypeReservedMax                   ItemPreviewType = 255
)

type ItemState int //gd:Steam.ItemState

const (
	ItemStateNone            ItemState = 0
	ItemStateSubscribed      ItemState = 1
	ItemStateLegacyItem      ItemState = 2
	ItemStateInstalled       ItemState = 4
	ItemStateNeedsUpdate     ItemState = 8
	ItemStateDownloading     ItemState = 16
	ItemStateDownloadPending ItemState = 32
	ItemStateDisabledLocally ItemState = 64
)

type ItemStatistic int //gd:Steam.ItemStatistic

const (
	ItemStatisticNumSubscriptions                    ItemStatistic = 0
	ItemStatisticNumFavorites                        ItemStatistic = 1
	ItemStatisticNumFollowers                        ItemStatistic = 2
	ItemStatisticNumUniqueSubscriptions              ItemStatistic = 3
	ItemStatisticNumUniqueFavorites                  ItemStatistic = 4
	ItemStatisticNumUniqueFollowers                  ItemStatistic = 5
	ItemStatisticNumUniqueWebsiteViews               ItemStatistic = 6
	ItemStatisticReportScore                         ItemStatistic = 7
	ItemStatisticNumSecondsPlayed                    ItemStatistic = 8
	ItemStatisticNumPlaytimeSessions                 ItemStatistic = 9
	ItemStatisticNumComments                         ItemStatistic = 10
	ItemStatisticNumSecondsPlayedDuringTimePeriod    ItemStatistic = 11
	ItemStatisticNumPlaytimeSessionsDuringTimePeriod ItemStatistic = 12
)

type ItemUpdateStatus int //gd:Steam.ItemUpdateStatus

const (
	ItemUpdateStatusInvalid              ItemUpdateStatus = 0
	ItemUpdateStatusPreparingConfig      ItemUpdateStatus = 1
	ItemUpdateStatusPreparingContent     ItemUpdateStatus = 2
	ItemUpdateStatusUploadingContent     ItemUpdateStatus = 3
	ItemUpdateStatusUploadingPreviewFile ItemUpdateStatus = 4
	ItemUpdateStatusCommittingChanges    ItemUpdateStatus = 5
)

type LeaderboardDataRequest int //gd:Steam.LeaderboardDataRequest

const (
	LeaderboardDataRequestGlobal           LeaderboardDataRequest = 0
	LeaderboardDataRequestGlobalAroundUser LeaderboardDataRequest = 1
	LeaderboardDataRequestFriends          LeaderboardDataRequest = 2
	LeaderboardDataRequestUsers            LeaderboardDataRequest = 3
)

type LeaderboardDisplayType int //gd:Steam.LeaderboardDisplayType

const (
	LeaderboardDisplayTypeNone             LeaderboardDisplayType = 0
	LeaderboardDisplayTypeNumeric          LeaderboardDisplayType = 1
	LeaderboardDisplayTypeTimeSeconds      LeaderboardDisplayType = 2
	LeaderboardDisplayTypeTimeMilliseconds LeaderboardDisplayType = 3
)

type LeaderboardSortMethod int //gd:Steam.LeaderboardSortMethod

const (
	LeaderboardSortMethodNone       LeaderboardSortMethod = 0
	LeaderboardSortMethodAscending  LeaderboardSortMethod = 1
	LeaderboardSortMethodDescending LeaderboardSortMethod = 2
)

type LeaderboardUploadScoreMethod int //gd:Steam.LeaderboardUploadScoreMethod

const (
	LeaderboardUploadScoreMethodNone        LeaderboardUploadScoreMethod = 0
	LeaderboardUploadScoreMethodKeepBest    LeaderboardUploadScoreMethod = 1
	LeaderboardUploadScoreMethodForceUpdate LeaderboardUploadScoreMethod = 2
)

type LobbyComparison int //gd:Steam.LobbyComparison

const (
	LobbyComparisonEqualToOrLessThan  LobbyComparison = -2
	LobbyComparisonLessThan           LobbyComparison = -1
	LobbyComparisonEqual              LobbyComparison = 0
	LobbyComparisonGreaterThan        LobbyComparison = 1
	LobbyComparisonEqualToGreaterThan LobbyComparison = 2
	LobbyComparisonNotEqual           LobbyComparison = 3
)

type LobbyDistanceFilter int //gd:Steam.LobbyDistanceFilter

const (
	LobbyDistanceFilterClose     LobbyDistanceFilter = 0
	LobbyDistanceFilterDefault   LobbyDistanceFilter = 1
	LobbyDistanceFilterFar       LobbyDistanceFilter = 2
	LobbyDistanceFilterWorldwide LobbyDistanceFilter = 3
)

type LobbyType int //gd:Steam.LobbyType

const (
	LobbyTypePrivate       LobbyType = 0
	LobbyTypeFriendsOnly   LobbyType = 1
	LobbyTypePublic        LobbyType = 2
	LobbyTypeInvisible     LobbyType = 3
	LobbyTypePrivateUnique LobbyType = 4
)

type LocalFileChange int //gd:Steam.LocalFileChange

const (
	LocalFileChangeInvalid     LocalFileChange = 0
	LocalFileChangeFileUpdated LocalFileChange = 1
	LocalFileChangeFileDeleted LocalFileChange = 2
)

type MarketNotAllowedReasonFlags int //gd:Steam.MarketNotAllowedReasonFlags

const (
	MarketNotAllowedReasonNone                             MarketNotAllowedReasonFlags = 0
	MarketNotAllowedReasonTemporaryFailure                 MarketNotAllowedReasonFlags = 1
	MarketNotAllowedReasonAccountDisabled                  MarketNotAllowedReasonFlags = 2
	MarketNotAllowedReasonAccountLockedDown                MarketNotAllowedReasonFlags = 4
	MarketNotAllowedReasonAccountLimited                   MarketNotAllowedReasonFlags = 8
	MarketNotAllowedReasonTradeBanned                      MarketNotAllowedReasonFlags = 16
	MarketNotAllowedReasonAccountNotTrusted                MarketNotAllowedReasonFlags = 32
	MarketNotAllowedReasonSteamGuardNotEnabled             MarketNotAllowedReasonFlags = 64
	MarketNotAllowedReasonSteamGaurdOnlyRecentlyEnabled    MarketNotAllowedReasonFlags = 128
	MarketNotAllowedReasonRecentPasswordReset              MarketNotAllowedReasonFlags = 256
	MarketNotAllowedReasonNewPaymentMethod                 MarketNotAllowedReasonFlags = 512
	MarketNotAllowedReasonInvalidCookie                    MarketNotAllowedReasonFlags = 1024
	MarketNotAllowedReasonUsingNewDevice                   MarketNotAllowedReasonFlags = 2048
	MarketNotAllowedReasonRecentSelfRefund                 MarketNotAllowedReasonFlags = 4096
	MarketNotAllowedReasonNewPaymentMethodCannotBeVerified MarketNotAllowedReasonFlags = 8192
	MarketNotAllowedReasonNoRecentPurchases                MarketNotAllowedReasonFlags = 16384
	MarketNotAllowedReasonAcceptedWalletGift               MarketNotAllowedReasonFlags = 32768
)

type MatchMakingServerResponse int //gd:Steam.MatchMakingServerResponse

const (
	ServerResponded               MatchMakingServerResponse = 0
	ServerFailedToRespond         MatchMakingServerResponse = 1
	NoServersListedOnMasterServer MatchMakingServerResponse = 2
)

type MouseCursor int //gd:Steam.MouseCursor

const (
	DcUser         MouseCursor = 0
	DcNone         MouseCursor = 1
	DcArrow        MouseCursor = 2
	DcIbeam        MouseCursor = 3
	DcHourGlass    MouseCursor = 4
	DcWaitArrow    MouseCursor = 5
	DcCrosshair    MouseCursor = 6
	DcUp           MouseCursor = 7
	DcSizeNw       MouseCursor = 8
	DcSizeSe       MouseCursor = 9
	DcSizeNe       MouseCursor = 10
	DcSizeSw       MouseCursor = 11
	DcSizeW        MouseCursor = 12
	DcSizeE        MouseCursor = 13
	DcSizeN        MouseCursor = 14
	DcSizeS        MouseCursor = 15
	DcSizeWe       MouseCursor = 16
	DcSizeNs       MouseCursor = 17
	DcSizeAll      MouseCursor = 18
	DcNo           MouseCursor = 19
	DcHand         MouseCursor = 20
	DcBlank        MouseCursor = 21
	DcMiddlePan    MouseCursor = 22
	DcNorthPan     MouseCursor = 23
	DcNorthEastPan MouseCursor = 24
	DcEastPan      MouseCursor = 25
	DcSouthEastPan MouseCursor = 26
	DcSouthPan     MouseCursor = 27
	DcSouthWestPan MouseCursor = 28
	DcWestPan      MouseCursor = 29
	DcNorthWestPan MouseCursor = 30
	DcAlias        MouseCursor = 31
	DcCell         MouseCursor = 32
	DcColResize    MouseCursor = 33
	DcCopyCur      MouseCursor = 34
	DcVerticalText MouseCursor = 35
	DcRowResize    MouseCursor = 36
	DcZoomIn       MouseCursor = 37
	DcZoomOut      MouseCursor = 38
	DcHelp         MouseCursor = 39
	DcCustom       MouseCursor = 40
	DcLast         MouseCursor = 41
)

type NetworkingAvailability int //gd:Steam.NetworkingAvailability

const (
	NetworkingAvailabilityCannotTry  NetworkingAvailability = -102
	NetworkingAvailabilityFailed     NetworkingAvailability = -101
	NetworkingAvailabilityPreviously NetworkingAvailability = -100
	NetworkingAvailabilityRetrying   NetworkingAvailability = -10
	NetworkingAvailabilityNeverTried NetworkingAvailability = 1
	NetworkingAvailabilityWaiting    NetworkingAvailability = 2
	NetworkingAvailabilityAttempting NetworkingAvailability = 3
	NetworkingAvailabilityCurrent    NetworkingAvailability = 100
	NetworkingAvailabilityUnknown    NetworkingAvailability = 0
	NetworkingAvailabilityForce32bit NetworkingAvailability = 2147483647
)

type NetworkingConfigDataType int //gd:Steam.NetworkingConfigDataType

const (
	NetworkingConfigTypeInt32       NetworkingConfigDataType = 1
	NetworkingConfigTypeInt64       NetworkingConfigDataType = 2
	NetworkingConfigTypeFloat       NetworkingConfigDataType = 3
	NetworkingConfigTypeString      NetworkingConfigDataType = 4
	NetworkingConfigTypeFunctionPtr NetworkingConfigDataType = 5
	NetworkingConfigTypeForce32bit  NetworkingConfigDataType = 2147483647
)

type NetworkingConfigScope int //gd:Steam.NetworkingConfigScope

const (
	NetworkingConfigScopeGlobal           NetworkingConfigScope = 1
	NetworkingConfigScopeSocketsInterface NetworkingConfigScope = 2
	NetworkingConfigScopeListenSocket     NetworkingConfigScope = 3
	NetworkingConfigScopeConnection       NetworkingConfigScope = 4
	NetworkingConfigScopeForce32bit       NetworkingConfigScope = 2147483647
)

type NetworkingConfigValue int //gd:Steam.NetworkingConfigValue

const (
	NetworkingConfigInvalid                                NetworkingConfigValue = 0
	NetworkingConfigFakePacketLossSend                     NetworkingConfigValue = 2
	NetworkingConfigFakePacketLossRecv                     NetworkingConfigValue = 3
	NetworkingConfigFakePacketLagSend                      NetworkingConfigValue = 4
	NetworkingConfigFakePacketLagRecv                      NetworkingConfigValue = 5
	NetworkingConfigFakePacketReorderSend                  NetworkingConfigValue = 6
	NetworkingConfigFakePacketReorderRecv                  NetworkingConfigValue = 7
	NetworkingConfigFakePacketReorderTime                  NetworkingConfigValue = 8
	NetworkingConfigFakePacketDupSend                      NetworkingConfigValue = 26
	NetworkingConfigFakePacketDupRevc                      NetworkingConfigValue = 27
	NetworkingConfigFakePacketDupTimeMax                   NetworkingConfigValue = 28
	NetworkingConfigPacketTraceMaxBytes                    NetworkingConfigValue = 41
	NetworkingConfigFakeRateLimitSendRate                  NetworkingConfigValue = 42
	NetworkingConfigFakeRateLimitSendBurst                 NetworkingConfigValue = 43
	NetworkingConfigFakeRateLimitRecvRate                  NetworkingConfigValue = 44
	NetworkingConfigFakeRateLimitRecvBurst                 NetworkingConfigValue = 45
	NetworkingConfigOutOfOrderCorrectionWindowMicroseconds NetworkingConfigValue = 51
	NetworkingConfigConnectionUserData                     NetworkingConfigValue = 40
	NetworkingConfigTimeoutInitial                         NetworkingConfigValue = 24
	NetworkingConfigTimeoutConnected                       NetworkingConfigValue = 25
	NetworkingConfigSendBufferSize                         NetworkingConfigValue = 9
	NetworkingConfigRecvBufferSize                         NetworkingConfigValue = 47
	NetworkingConfigRecvBufferMessages                     NetworkingConfigValue = 48
	NetworkingConfigRecvMaxMessageSize                     NetworkingConfigValue = 49
	NetworkingConfigRecvMaxSegmentsPerPacket               NetworkingConfigValue = 50
	NetworkingConfigSendRateMin                            NetworkingConfigValue = 10
	NetworkingConfigSendRateMax                            NetworkingConfigValue = 11
	NetworkingConfigNagleTime                              NetworkingConfigValue = 12
	NetworkingConfigIpAllowWithoutAuth                     NetworkingConfigValue = 23
	NetworkingConfigIpLocalHostAllowWithoutAuth            NetworkingConfigValue = 52
	NetworkingConfigMtuPacketSize                          NetworkingConfigValue = 32
	NetworkingConfigMtuDataSize                            NetworkingConfigValue = 33
	NetworkingConfigUnencrypted                            NetworkingConfigValue = 34
	NetworkingConfigSymmetricConnect                       NetworkingConfigValue = 37
	NetworkingConfigLocalVirtualPort                       NetworkingConfigValue = 38
	NetworkingConfigDualWifiEnable                         NetworkingConfigValue = 39
	NetworkingConfigEnableDiagnosticsUi                    NetworkingConfigValue = 46
	NetworkingConfigSendTimeSincePreviousPacket            NetworkingConfigValue = 59
	NetworkingConfigSdrClientConsecPingTimeoutFailInitial  NetworkingConfigValue = 19
	NetworkingConfigSdrClientConsecPingTimeoutFail         NetworkingConfigValue = 20
	NetworkingConfigSdrClientMinPingsBeforePingAccurate    NetworkingConfigValue = 21
	NetworkingConfigSdrClientSingleSocket                  NetworkingConfigValue = 22
	NetworkingConfigSdrClientForceRelayCluster             NetworkingConfigValue = 29
	NetworkingConfigSdrClientDevTicket                     NetworkingConfigValue = 30
	NetworkingConfigSdrClientForceProxyAddr                NetworkingConfigValue = 31
	NetworkingConfigSdrClientFakeClusterPing               NetworkingConfigValue = 36
	NetworkingConfigSdrClientLimitPingProbesToNearestN     NetworkingConfigValue = 60
	NetworkingConfigLogLevelAckRtt                         NetworkingConfigValue = 13
	NetworkingConfigLogLevelPacketDecode                   NetworkingConfigValue = 14
	NetworkingConfigLogLevelMessage                        NetworkingConfigValue = 15
	NetworkingConfigLogLevelPacketGaps                     NetworkingConfigValue = 16
	NetworkingConfigLogLevelP2pRendezvous                  NetworkingConfigValue = 17
	NetworkingConfigLogLevelSrdRelayPings                  NetworkingConfigValue = 18
	NetworkingConfigCallbackConnectionStatusChanged        NetworkingConfigValue = 201
	NetworkingConfigCallbackAuthStatusChanged              NetworkingConfigValue = 202
	NetworkingConfigCallbackRelayNetworkStatusChanged      NetworkingConfigValue = 203
	NetworkingConfigCallbackMessageSessionRequest          NetworkingConfigValue = 204
	NetworkingConfigCallbackMessagesSessionFailed          NetworkingConfigValue = 205
	NetworkingConfigCallbackCreateConnectionSignaling      NetworkingConfigValue = 206
	NetworkingConfigCallbackFakeIpResult                   NetworkingConfigValue = 207
	NetworkingConfigP2pStunServerList                      NetworkingConfigValue = 103
	NetworkingConfigP2pTransportIceEnable                  NetworkingConfigValue = 104
	NetworkingConfigP2pTransportIcePenalty                 NetworkingConfigValue = 105
	NetworkingConfigP2pTransportSdrPenalty                 NetworkingConfigValue = 106
	NetworkingConfigP2pTurnServerList                      NetworkingConfigValue = 107
	NetworkingConfigP2pTurnUserList                        NetworkingConfigValue = 108
	NetworkingConfigP2pTurnPassList                        NetworkingConfigValue = 109
	NetworkingConfigP2pTransportIceImplementation          NetworkingConfigValue = 110
	NetworkingConfigEcn                                    NetworkingConfigValue = 999
	NetworkingConfigValueForce32bit                        NetworkingConfigValue = 2147483647
)

type NetworkingConnectionEnd int //gd:Steam.NetworkingConnectionEnd

const (
	ConnectionEndInvalid                       NetworkingConnectionEnd = 0
	ConnectionEndAppMin                        NetworkingConnectionEnd = 1000
	ConnectionEndAppGeneric                    NetworkingConnectionEnd = 1000
	ConnectionEndAppMax                        NetworkingConnectionEnd = 1999
	ConnectionEndAppExceptionMin               NetworkingConnectionEnd = 2000
	ConnectionEndAppExceptionGeneric           NetworkingConnectionEnd = 2000
	ConnectionEndAppExceptionMax               NetworkingConnectionEnd = 2999
	ConnectionEndLocalMin                      NetworkingConnectionEnd = 3000
	ConnectionEndLocalOfflineMode              NetworkingConnectionEnd = 3001
	ConnectionEndLocalManyRelayConnectivity    NetworkingConnectionEnd = 3002
	ConnectionEndLocalHostedServerPrimaryRelay NetworkingConnectionEnd = 3003
	ConnectionEndLocalNetworkConfig            NetworkingConnectionEnd = 3004
	ConnectionEndLocalRights                   NetworkingConnectionEnd = 3005
	ConnectionEndNoPublicAddress               NetworkingConnectionEnd = 3006
	ConnectionEndLocalMax                      NetworkingConnectionEnd = 3999
	ConnectionEndRemoveMin                     NetworkingConnectionEnd = 4000
	ConnectionEndRemoteTimeout                 NetworkingConnectionEnd = 4001
	ConnectionEndRemoteBadCrypt                NetworkingConnectionEnd = 4002
	ConnectionEndRemoteBadCert                 NetworkingConnectionEnd = 4003
	ConnectionEndBadProtocolVersion            NetworkingConnectionEnd = 4006
	ConnectionEndRemoteP2pIceNoPublicAddresses NetworkingConnectionEnd = 4007
	ConnectionEndRemoteMax                     NetworkingConnectionEnd = 4999
	ConnectionEndMiscMin                       NetworkingConnectionEnd = 5000
	ConnectionEndMiscGeneric                   NetworkingConnectionEnd = 5001
	ConnectionEndMiscInternalError             NetworkingConnectionEnd = 5002
	ConnectionEndMiscTimeout                   NetworkingConnectionEnd = 5003
	ConnectionEndMiscSteamConnectivity         NetworkingConnectionEnd = 5005
	ConnectionEndMiscNoRelaySessionsToClient   NetworkingConnectionEnd = 5006
	ConnectionEndMiscP2pRendezvous             NetworkingConnectionEnd = 5008
	ConnectionEndMiscP2pNatFirewall            NetworkingConnectionEnd = 5009
	ConnectionEndMiscPeerSentNoConnection      NetworkingConnectionEnd = 5010
	ConnectionEndMiscMax                       NetworkingConnectionEnd = 5999
	ConnectionEndForce32bit                    NetworkingConnectionEnd = 2147483647
)

type NetworkingConnectionState int //gd:Steam.NetworkingConnectionState

const (
	ConnectionStateNone                   NetworkingConnectionState = 0
	ConnectionStateConnecting             NetworkingConnectionState = 1
	ConnectionStateFindingRoute           NetworkingConnectionState = 2
	ConnectionStateConnected              NetworkingConnectionState = 3
	ConnectionStateClosedByPeer           NetworkingConnectionState = 4
	ConnectionStateProblemDetectedLocally NetworkingConnectionState = 5
	ConnectionStateFinWait                NetworkingConnectionState = -1
	ConnectionStateLinger                 NetworkingConnectionState = -2
	ConnectionStateDead                   NetworkingConnectionState = -3
	ConnectionStateForce32bit             NetworkingConnectionState = 2147483647
)

type NetworkingFakeIPType int //gd:Steam.NetworkingFakeIPType

const (
	FakeIpTypeInvalid    NetworkingFakeIPType = 0
	FakeIpTypeNotFake    NetworkingFakeIPType = 1
	FakeIpTypeGlobalIpv4 NetworkingFakeIPType = 2
	FakeIpTypeLocalIpv4  NetworkingFakeIPType = 3
	FakeIpTypeForce32bit NetworkingFakeIPType = 2147483647
)

type NetworkingGetConfigValueResult int //gd:Steam.NetworkingGetConfigValueResult

const (
	NetworkingGetConfigValueBadValue       NetworkingGetConfigValueResult = -1
	NetworkingGetConfigValueBadScopeObj    NetworkingGetConfigValueResult = -2
	NetworkingGetConfigValueBufferTooSmall NetworkingGetConfigValueResult = -3
	NetworkingGetConfigValueOk             NetworkingGetConfigValueResult = 1
	NetworkingGetConfigValueOkInherited    NetworkingGetConfigValueResult = 2
	NetworkingGetConfigValueForce32bit     NetworkingGetConfigValueResult = 2147483647
)

type NetworkingIdentityType int //gd:Steam.NetworkingIdentityType

const (
	IdentityTypeInvalid       NetworkingIdentityType = 0
	IdentityTypeSteamid       NetworkingIdentityType = 16
	IdentityTypeIpAddress     NetworkingIdentityType = 1
	IdentityTypeGenericString NetworkingIdentityType = 2
	IdentityTypeGenericBytes  NetworkingIdentityType = 3
	IdentityTypeUnknownType   NetworkingIdentityType = 4
	IdentityTypeXboxPairwise  NetworkingIdentityType = 17
	IdentityTypeSonyPsn       NetworkingIdentityType = 18
	IdentityTypeForce32bit    NetworkingIdentityType = 2147483647
)

type NetworkingSocketsDebugOutputType int //gd:Steam.NetworkingSocketsDebugOutputType

const (
	NetworkingSocketDebugOutputTypeNone       NetworkingSocketsDebugOutputType = 0
	NetworkingSocketDebugOutputTypeBug        NetworkingSocketsDebugOutputType = 1
	NetworkingSocketDebugOutputTypeError      NetworkingSocketsDebugOutputType = 2
	NetworkingSocketDebugOutputTypeImportant  NetworkingSocketsDebugOutputType = 3
	NetworkingSocketDebugOutputTypeWarning    NetworkingSocketsDebugOutputType = 4
	NetworkingSocketDebugOutputTypeMsg        NetworkingSocketsDebugOutputType = 5
	NetworkingSocketDebugOutputTypeVerbose    NetworkingSocketsDebugOutputType = 6
	NetworkingSocketDebugOutputTypeDebug      NetworkingSocketsDebugOutputType = 7
	NetworkingSocketDebugOutputTypeEverything NetworkingSocketsDebugOutputType = 8
	NetworkingSocketDebugOutputTypeForce32bit NetworkingSocketsDebugOutputType = 2147483647
)

type NotificationPosition int //gd:Steam.NotificationPosition

const (
	PositionInvalid     NotificationPosition = -1
	PositionTopLeft     NotificationPosition = 0
	PositionTopRight    NotificationPosition = 1
	PositionBottomLeft  NotificationPosition = 2
	PositionBottomRight NotificationPosition = 3
)

type OverlayToStoreFlag int //gd:Steam.OverlayToStoreFlag

const (
	OverlayToStoreFlagNone             OverlayToStoreFlag = 0
	OverlayToStoreFlagAddToCart        OverlayToStoreFlag = 1
	OverlayToStoreFlagAndToCartAndShow OverlayToStoreFlag = 2
)

type OverlayToWebPageMode int //gd:Steam.OverlayToWebPageMode

const (
	OverlayToWebPageModeDefault OverlayToWebPageMode = 0
	OverlayToWebPageModeModal   OverlayToWebPageMode = 1
)

type P2PSend int //gd:Steam.P2PSend

const (
	P2pSendUnreliable            P2PSend = 0
	P2pSendUnreliableNoDelay     P2PSend = 1
	P2pSendReliable              P2PSend = 2
	P2pSendReliableWithBuffering P2PSend = 3
)

type P2PSessionError int //gd:Steam.P2PSessionError

const (
	P2pSessionErrorNone                   P2PSessionError = 0
	P2pSessionErrorNotRunningApp          P2PSessionError = 1
	P2pSessionErrorNoRightsToApp          P2PSessionError = 2
	P2pSessionErrorDestinationNotLoggedOn P2PSessionError = 3
	P2pSessionErrorTimeout                P2PSessionError = 4
	P2pSessionErrorMax                    P2PSessionError = 5
)

type ParentalFeature int //gd:Steam.ParentalFeature

const (
	FeatureInvalid       ParentalFeature = 0
	FeatureStore         ParentalFeature = 1
	FeatureCommunity     ParentalFeature = 2
	FeatureProfile       ParentalFeature = 3
	FeatureFriends       ParentalFeature = 4
	FeatureNews          ParentalFeature = 5
	FeatureTrading       ParentalFeature = 6
	FeatureSettings      ParentalFeature = 7
	FeatureConsole       ParentalFeature = 8
	FeatureBrowser       ParentalFeature = 9
	FeatureParentalSetup ParentalFeature = 10
	FeatureLibrary       ParentalFeature = 11
	FeatureTest          ParentalFeature = 12
	FeatureSiteLicense   ParentalFeature = 13
	FeatureKioskMode     ParentalFeature = 14
	FeatureBlockAlways   ParentalFeature = 15
	FeatureMax           ParentalFeature = 16
)

type PartyBeaconLocationData int //gd:Steam.PartyBeaconLocationData

const (
	SteamPartyBeaconLocationData          PartyBeaconLocationData = 0
	SteamPartyBeaconLocationDataName      PartyBeaconLocationData = 1
	SteamPartyBeaconLocationDataUrlSmall  PartyBeaconLocationData = 2
	SteamPartyBeaconLocationDataUrlMedium PartyBeaconLocationData = 3
	SteamPartyBeaconLocationDataUrlLarge  PartyBeaconLocationData = 4
)

type PartyBeaconLocationType int //gd:Steam.PartyBeaconLocationType

const (
	SteamPartyBeaconLocationtypeInvalid   PartyBeaconLocationType = 0
	SteamPartyBeaconLocationtypeChatGroup PartyBeaconLocationType = 1
	SteamPartyBeaconLocationTypeMax       PartyBeaconLocationType = 2
)

type PersonaChange int //gd:Steam.PersonaChange

const (
	PersonaChangeName                PersonaChange = 1
	PersonaChangeStatus              PersonaChange = 2
	PersonaChangeComeOnline          PersonaChange = 4
	PersonaChangeGoneOffline         PersonaChange = 8
	PersonaChangeGamePlayed          PersonaChange = 16
	PersonaChangeGameServer          PersonaChange = 32
	PersonaChangeAvatar              PersonaChange = 64
	PersonaChangeJoinedSource        PersonaChange = 128
	PersonaChangeLeftSource          PersonaChange = 256
	PersonaChangeRelationshipChanged PersonaChange = 512
	PersonaChangeNameFirstSet        PersonaChange = 1024
	PersonaChangeFacebookInfo        PersonaChange = 2048
	PersonaChangeNickname            PersonaChange = 4096
	PersonaChangeSteamLevel          PersonaChange = 8192
	PersonaChangeRichPresence        PersonaChange = 16384
)

type PersonaState int //gd:Steam.PersonaState

const (
	PersonaStateOffline        PersonaState = 0
	PersonaStateOnline         PersonaState = 1
	PersonaStateBusy           PersonaState = 2
	PersonaStateAway           PersonaState = 3
	PersonaStateSnooze         PersonaState = 4
	PersonaStateLookingToTrade PersonaState = 5
	PersonaStateLookingToPlay  PersonaState = 6
	PersonaStateInvisible      PersonaState = 7
	PersonaStateMax            PersonaState = 8
)

type PlayerResult int //gd:Steam.PlayerResult

const (
	PlayerResultFailedToConnect PlayerResult = 1
	PlayerResultAbandoned       PlayerResult = 2
	PlayerResultKicked          PlayerResult = 3
	PlayerResultIncomplete      PlayerResult = 4
	PlayerResultCompleted       PlayerResult = 5
)

type RemoteStoragePlatform int //gd:Steam.RemoteStoragePlatform

const (
	RemoteStoragePlatformNone    RemoteStoragePlatform = 0
	RemoteStoragePlatformWindows RemoteStoragePlatform = 1
	RemoteStoragePlatformOsx     RemoteStoragePlatform = 2
	RemoteStoragePlatformPs3     RemoteStoragePlatform = 4
	RemoteStoragePlatformLinux   RemoteStoragePlatform = 8
	RemoteStoragePlatformSwitch  RemoteStoragePlatform = 16
	RemoteStoragePlatformAndroid RemoteStoragePlatform = 32
	RemoteStoragePlatformIos     RemoteStoragePlatform = 64
	RemoteStoragePlatformAll     RemoteStoragePlatform = 4294967295
)

type RemoteStoragePublishedFileVisibility int //gd:Steam.RemoteStoragePublishedFileVisibility

const (
	RemoteStoragePublishedVisibilityPublic      RemoteStoragePublishedFileVisibility = 0
	RemoteStoragePublishedVisibilityFriendsOnly RemoteStoragePublishedFileVisibility = 1
	RemoteStoragePublishedVisibilityPrivate     RemoteStoragePublishedFileVisibility = 2
	RemoteStoragePublishedVisibilityUnlisted    RemoteStoragePublishedFileVisibility = 3
)

type Result int //gd:Steam.Result

const (
	ResultNone                                    Result = 0
	ResultOk                                      Result = 1
	ResultFail                                    Result = 2
	ResultNoConnection                            Result = 3
	ResultInvalidPassword                         Result = 5
	ResultLoggedInElsewhere                       Result = 6
	ResultInvalidProtocolVer                      Result = 7
	ResultInvalidParam                            Result = 8
	ResultFileNotFound                            Result = 9
	ResultBusy                                    Result = 10
	ResultInvalidState                            Result = 11
	ResultInvalidName                             Result = 12
	ResultInvalidEmail                            Result = 13
	ResultDuplicateName                           Result = 14
	ResultAccessDenied                            Result = 15
	ResultTimeout                                 Result = 16
	ResultBanned                                  Result = 17
	ResultAccountNotFound                         Result = 18
	ResultInvalidSteamid                          Result = 19
	ResultServiceUnavailable                      Result = 20
	ResultNotLoggedOn                             Result = 21
	ResultPending                                 Result = 22
	ResultEncryptionFailure                       Result = 23
	ResultInsufficientPrivilege                   Result = 24
	ResultLimitExceeded                           Result = 25
	ResultRevoked                                 Result = 26
	ResultExpired                                 Result = 27
	ResultAlreadyRedeemed                         Result = 28
	ResultDuplicateRequest                        Result = 29
	ResultAlreadyOwned                            Result = 30
	ResultIpNotFound                              Result = 31
	ResultPersistFailed                           Result = 32
	ResultLockingFailed                           Result = 33
	ResultLogOnSessionReplaced                    Result = 34
	ResultConnectFailed                           Result = 35
	ResultHandshakeFailed                         Result = 36
	ResultIoFailure                               Result = 37
	ResultRemoteDisconnect                        Result = 38
	ResultShoppingCartNotFound                    Result = 39
	ResultBlocked                                 Result = 40
	ResultIgnored                                 Result = 41
	ResultNoMatch                                 Result = 42
	ResultAccountDisabled                         Result = 43
	ResultServiceReadOnly                         Result = 44
	ResultAccountNotFeatured                      Result = 45
	ResultAdministratorOk                         Result = 46
	ResultContentVersion                          Result = 47
	ResultTryAnotherCm                            Result = 48
	ResultPasswordRequiredToKickSession           Result = 49
	ResultAlreadyLoggedInElsewhere                Result = 50
	ResultSuspended                               Result = 51
	ResultCancelled                               Result = 52
	ResultDataCorruption                          Result = 53
	ResultDiskFull                                Result = 54
	ResultRemoteCallFailed                        Result = 55
	ResultPasswordUnset                           Result = 56
	ResultExternalAccountUnlinked                 Result = 57
	ResultPsnTicketInvalid                        Result = 58
	ResultExternalAccountAlreadyLinked            Result = 59
	ResultRemoteFileConflict                      Result = 60
	ResultIllegalPassword                         Result = 61
	ResultSameAsPreviousValue                     Result = 62
	ResultAccountLogOnDenied                      Result = 63
	ResultCannotUseOldPassword                    Result = 64
	ResultInvalidLogInAuthCode                    Result = 65
	ResultAccountLogOnDeniedNoMail                Result = 66
	ResultHardwareNotCapableOfIpt                 Result = 67
	ResultIptInitError                            Result = 68
	ResultParentalControlRestricted               Result = 69
	ResultFacebookQueryError                      Result = 70
	ResultExpiredLoginAuthCode                    Result = 71
	ResultIpLoginRestrictionFailed                Result = 72
	ResultAccountLockedDown                       Result = 73
	ResultAccountLogOnDeniedVerifiedEmailRequired Result = 74
	ResultNoMatchingUrl                           Result = 75
	ResultBadResponse                             Result = 76
	ResultRequirePasswordReentry                  Result = 77
	ResultValueOutOfRange                         Result = 78
	ResultUnexpectedError                         Result = 79
	ResultDisabled                                Result = 80
	ResultInvalidCegSubmission                    Result = 81
	ResultRestrictedDevice                        Result = 82
	ResultRegionLocked                            Result = 83
	ResultRateLimitExceeded                       Result = 84
	ResultAccountLoginDeniedNeedTwoFactor         Result = 85
	ResultItemDeleted                             Result = 86
	ResultAccountLoginDeniedThrottle              Result = 87
	ResultTwoFactorCodeMismatch                   Result = 88
	ResultTwoFactorActivationCodeMismatch         Result = 89
	ResultAccountAssociatedToMultiplePartners     Result = 90
	ResultNotModified                             Result = 91
	ResultNoMobileDevice                          Result = 92
	ResultTimeNotSynced                           Result = 93
	ResultSmsCodeFailed                           Result = 94
	ResultAccountLimitExceeded                    Result = 95
	ResultAccountActivityLimitExceeded            Result = 96
	ResultPhoneActivityLimitExceeded              Result = 97
	ResultRefundToWallet                          Result = 98
	ResultEmailSendFailure                        Result = 99
	ResultNotSettled                              Result = 100
	ResultNeedCaptcha                             Result = 101
	ResultGsltDenied                              Result = 102
	ResultGsOwnerDenied                           Result = 103
	ResultInvalidItemType                         Result = 104
	ResultIpBanned                                Result = 105
	ResultGsltExpired                             Result = 106
	ResultInsufficientFunds                       Result = 107
	ResultTooManyPending                          Result = 108
	ResultNoSiteLicensesFound                     Result = 109
	ResultWgNetworkSendExceeded                   Result = 110
	ResultAccountNotFriends                       Result = 111
	ResultLimitedUserAccount                      Result = 112
	ResultCantRemoveItem                          Result = 113
	ResultAccountDeleted                          Result = 114
	ResultExistingUserCancelledLicense            Result = 115
	ResultCommunityCooldown                       Result = 116
	ResultNoLauncherSpecified                     Result = 117
	ResultMustAgreeToSsa                          Result = 118
	ResultLauncherMigrated                        Result = 119
	ResultSteamRealmMismatch                      Result = 120
	ResultInvalidSignature                        Result = 121
	ResultParseFailure                            Result = 122
	ResultNoVerifiedPhone                         Result = 123
	ResultInsufficientBattery                     Result = 124
	ResultChargerRequired                         Result = 125
	ResultCachedCredentialInvalid                 Result = 126
	ResultPhoneNumberIsVoip                       Result = 127
	ResultNotSupported                            Result = 128
	ResultFamilySizeLimitExceeded                 Result = 129
	ResultOfflineAppCacheInvalid                  Result = 130
)

type SCEPadTriggerEffectMode int //gd:Steam.SCEPadTriggerEffectMode

const (
	PadTriggerEffectModeOff                       SCEPadTriggerEffectMode = 0
	PadTriggerEffectModeFeedback                  SCEPadTriggerEffectMode = 1
	PadTriggerEffectModeWeapon                    SCEPadTriggerEffectMode = 2
	PadTriggerEffectModeVibration                 SCEPadTriggerEffectMode = 3
	PadTriggerEffectModeMultiplePositionFeedback  SCEPadTriggerEffectMode = 4
	PadTriggerEffectModeSlopeFeedback             SCEPadTriggerEffectMode = 5
	PadTriggerEffectModeMultiplePositionVibration SCEPadTriggerEffectMode = 6
)

type SocketConnectionType int //gd:Steam.SocketConnectionType

const (
	NetSocketConnectionTypeNotConnected SocketConnectionType = 0
	NetSocketConnectionTypeUdp          SocketConnectionType = 1
	NetSocketConnectionTypeUdpRelay     SocketConnectionType = 2
)

type SocketState int //gd:Steam.SocketState

const (
	NetSocketStateInvalid                  SocketState = 0
	NetSocketStateConnected                SocketState = 1
	NetSocketStateInitiated                SocketState = 10
	NetSocketStateLocalCandidateFound      SocketState = 11
	NetSocketStateReceivedRemoteCandidates SocketState = 12
	NetSocketStateChallengeHandshake       SocketState = 15
	NetSocketStateDisconnecting            SocketState = 21
	NetSocketStateLocalDisconnect          SocketState = 22
	NetSocketStateTimeoutDuringConnect     SocketState = 23
	NetSocketStateRemoteEndDisconnected    SocketState = 24
	NetSocketStateBroken                   SocketState = 25
)

type SteamAPIInitResult int //gd:Steam.SteamAPIInitResult

const (
	SteamApiInitResultOk              SteamAPIInitResult = 0
	SteamApiInitResultFailedGeneric   SteamAPIInitResult = 1
	SteamApiInitResultNoSteamClient   SteamAPIInitResult = 2
	SteamApiInitResultVersionMismatch SteamAPIInitResult = 3
)

type TextFilteringContext int //gd:Steam.TextFilteringContext

const (
	TextFilteringContextUnknown     TextFilteringContext = 0
	TextFilteringContextGameContent TextFilteringContext = 1
	TextFilteringContextChat        TextFilteringContext = 2
	TextFilteringContextName        TextFilteringContext = 3
)

type TimelineGameMode int //gd:Steam.TimelineGameMode

const (
	TimelineGameModeInvalid       TimelineGameMode = 0
	TimelineGameModePlaying       TimelineGameMode = 1
	TimelineGameModeStaging       TimelineGameMode = 2
	TimelineGameModeMenus         TimelineGameMode = 3
	TimelineGameModeLoadingScreen TimelineGameMode = 4
	TimelineGameModeMax           TimelineGameMode = 5
)

type TimelineEventClipPriority int //gd:Steam.TimelineEventClipPriority

const (
	TimelineEventClipPriorityInvalid  TimelineEventClipPriority = 0
	TimelineEventClipPriorityNone     TimelineEventClipPriority = 1
	TimelineEventClipPriorityStandard TimelineEventClipPriority = 2
	TimelineEventClipPriorityFeatured TimelineEventClipPriority = 3
)

type Universe int //gd:Steam.Universe

const (
	UniverseInvalid  Universe = 0
	UniversePublic   Universe = 1
	UniverseBeta     Universe = 2
	UniverseInternal Universe = 3
	UniverseDev      Universe = 4
	UniverseMax      Universe = 5
)

type UGCContentDescriptorID int //gd:Steam.UGCContentDescriptorID

const (
	UgcContentDescriptorNudityOrSexualContent   UGCContentDescriptorID = 1
	UgcContentDescriptorFrequentViolenceOrGore  UGCContentDescriptorID = 2
	UgcContentDescriptorAdultOnlySexualContent  UGCContentDescriptorID = 3
	UgcContentDescriptorGratuitousSexualContent UGCContentDescriptorID = 4
	UgcContentDescriptorAnyMatureContent        UGCContentDescriptorID = 5
)

type UGCMatchingUGCType int //gd:Steam.UGCMatchingUGCType

const (
	UgcMatchingUgcTypeItems              UGCMatchingUGCType = 0
	UgcMatchingUgcTypeItemsMtx           UGCMatchingUGCType = 1
	UgcMatchingUgcTypeItemsReadyToUse    UGCMatchingUGCType = 2
	UgcMatchingUgcTypeCollections        UGCMatchingUGCType = 3
	UgcMatchingUgcTypeArtwork            UGCMatchingUGCType = 4
	UgcMatchingUgcTypeVideos             UGCMatchingUGCType = 5
	UgcMatchingUgcTypeScreenshots        UGCMatchingUGCType = 6
	UgcMatchingUgcTypeAllGuides          UGCMatchingUGCType = 7
	UgcMatchingUgcTypeWebGuides          UGCMatchingUGCType = 8
	UgcMatchingUgcTypeIntegratedGuides   UGCMatchingUGCType = 9
	UgcMatchingUgcTypeUsableInGame       UGCMatchingUGCType = 10
	UgcMatchingUgcTypeControllerBindings UGCMatchingUGCType = 11
	UgcMatchingUgcTypeGameManagedItems   UGCMatchingUGCType = 12
	UgcMatchingUgcTypeAll                UGCMatchingUGCType = -1
)

type UGCQuery int //gd:Steam.UGCQuery

const (
	UgcQueryRankedByVote                                  UGCQuery = 0
	UgcQueryRankedByPublicationDate                       UGCQuery = 1
	UgcQueryAcceptedForGameRankedByAcceptanceDate         UGCQuery = 2
	UgcQueryRankedByTrend                                 UGCQuery = 3
	UgcQueryFavoritedByFriendsRankedByPublicationDate     UGCQuery = 4
	UgcQueryCreatedByFriendsRankedByPublicationDate       UGCQuery = 5
	UgcQueryRankedByNumTimesReported                      UGCQuery = 6
	UgcQueryCreatedByFollowedUsersRankedByPublicationDate UGCQuery = 7
	UgcQueryNotYetRated                                   UGCQuery = 8
	UgcQueryRankedByTotalVotesAsc                         UGCQuery = 9
	UgcQueryRankedByVotesUp                               UGCQuery = 10
	UgcQueryRankedByTextSearch                            UGCQuery = 11
	UgcQueryRankedByTotalUniqueSubscriptions              UGCQuery = 12
	UgcQueryRankedByPlaytimeTrend                         UGCQuery = 13
	UgcQueryRankedByTotalPlaytime                         UGCQuery = 14
	UgcQueryRankedByAveragePlaytimeTrend                  UGCQuery = 15
	UgcQueryRankedByLifetimeAveragePlaytime               UGCQuery = 16
	UgcQueryRankedByPlaytimeSessionsTrend                 UGCQuery = 17
	UgcQueryRankedByLifetimePlaytimeSessions              UGCQuery = 18
	UgcQueryRankedByLastUpdatedDate                       UGCQuery = 19
)

type UGCReadAction int //gd:Steam.UGCReadAction

const (
	UgcReadContinueReadingUntilFinished UGCReadAction = 0
	UgcReadContinueReading              UGCReadAction = 1
	UgcReadClose                        UGCReadAction = 2
)

type UserHasLicenseForAppResult int //gd:Steam.UserHasLicenseForAppResult

const (
	UserHasLicenseResultHasLicense         UserHasLicenseForAppResult = 0
	UserHasLicenseResultDoesNotHaveLicense UserHasLicenseForAppResult = 1
	UserHasLicenseResultNoAuth             UserHasLicenseForAppResult = 2
)

type UserRestriction int //gd:Steam.UserRestriction

const (
	UserRestrictionNone        UserRestriction = 0
	UserRestrictionUnknown     UserRestriction = 1
	UserRestrictionAnyChat     UserRestriction = 2
	UserRestrictionVoiceChat   UserRestriction = 4
	UserRestrictionGroupChat   UserRestriction = 8
	UserRestrictionRating      UserRestriction = 16
	UserRestrictionGameInvites UserRestriction = 32
	UserRestrictionTrading     UserRestriction = 64
)

type UserUGCList int //gd:Steam.UserUGCList

const (
	UserUgcListPublished     UserUGCList = 0
	UserUgcListVotedOn       UserUGCList = 1
	UserUgcListVotedUp       UserUGCList = 2
	UserUgcListVotedDown     UserUGCList = 3
	UserUgcListWillVoteLater UserUGCList = 4
	UserUgcListFavorited     UserUGCList = 5
	UserUgcListSubscribed    UserUGCList = 6
	UserUgcListUsedOrPlayed  UserUGCList = 7
	UserUgcListFollowed      UserUGCList = 8
)

type UserUGCListSortOrder int //gd:Steam.UserUGCListSortOrder

const (
	UserUgcListSortOrderCreationOrderDesc    UserUGCListSortOrder = 0
	UserUgcListSortOrderCreationOrderAsc     UserUGCListSortOrder = 1
	UserUgcListSortOrderTitleAsc             UserUGCListSortOrder = 2
	UserUgcListSortOrderLastUpdatedDesc      UserUGCListSortOrder = 3
	UserUgcListSortOrderSubscriptionDateDesc UserUGCListSortOrder = 4
	UserUgcListSortOrderVoteScoreDesc        UserUGCListSortOrder = 5
	UserUgcListSortOrderForModeration        UserUGCListSortOrder = 6
)

type VoiceResult int //gd:Steam.VoiceResult

const (
	VoiceResultOk                   VoiceResult = 0
	VoiceResultNotInitialized       VoiceResult = 1
	VoiceResultNotRecording         VoiceResult = 2
	VoiceResultNoDate               VoiceResult = 3
	VoiceResultBufferTooSmall       VoiceResult = 4
	VoiceResultDataCorrupted        VoiceResult = 5
	VoiceResultRestricted           VoiceResult = 6
	VoiceResultUnsupportedCodec     VoiceResult = 7
	VoiceResultReceiverOutOfDate    VoiceResult = 8
	VoiceResultReceiverDidNotAnswer VoiceResult = 9
)

type VRScreenshotType int //gd:Steam.VRScreenshotType

const (
	VrScreenshotTypeNone           VRScreenshotType = 0
	VrScreenshotTypeMono           VRScreenshotType = 1
	VrScreenshotTypeStereo         VRScreenshotType = 2
	VrScreenshotTypeMonoCubeMap    VRScreenshotType = 3
	VrScreenshotTypeMonoPanorama   VRScreenshotType = 4
	VrScreenshotTypeStereoPanorama VRScreenshotType = 5
)

type WorkshopEnumerationType int //gd:Steam.WorkshopEnumerationType

const (
	WorkshopEnumerationTypeRankedByVote            WorkshopEnumerationType = 0
	WorkshopEnumerationTypeRecent                  WorkshopEnumerationType = 1
	WorkshopEnumerationTypeTrending                WorkshopEnumerationType = 2
	WorkshopEnumerationTypeFavoritesOfFriends      WorkshopEnumerationType = 3
	WorkshopEnumerationTypeVotedByFriends          WorkshopEnumerationType = 4
	WorkshopEnumerationTypeContentByFriends        WorkshopEnumerationType = 5
	WorkshopEnumerationTypeRecentFromFollowedUsers WorkshopEnumerationType = 6
)

type WorkshopFileAction int //gd:Steam.WorkshopFileAction

const (
	WorkshopFileActionPlayed    WorkshopFileAction = 0
	WorkshopFileActionCompleted WorkshopFileAction = 1
)

type WorkshopFileType int //gd:Steam.WorkshopFileType

const (
	WorkshopFileTypeFirst                  WorkshopFileType = 0
	WorkshopFileTypeCommunity              WorkshopFileType = 0
	WorkshopFileTypeMicrotransaction       WorkshopFileType = 1
	WorkshopFileTypeCollection             WorkshopFileType = 2
	WorkshopFileTypeArt                    WorkshopFileType = 3
	WorkshopFileTypeVideo                  WorkshopFileType = 4
	WorkshopFileTypeScreenshot             WorkshopFileType = 5
	WorkshopFileTypeGame                   WorkshopFileType = 6
	WorkshopFileTypeSoftware               WorkshopFileType = 7
	WorkshopFileTypeConcept                WorkshopFileType = 8
	WorkshopFileTypeWebGuide               WorkshopFileType = 9
	WorkshopFileTypeIntegratedGuide        WorkshopFileType = 10
	WorkshopFileTypeMerch                  WorkshopFileType = 11
	WorkshopFileTypeControllerBinding      WorkshopFileType = 12
	WorkshopFileTypeSteamworksAccessInvite WorkshopFileType = 13
	WorkshopFileTypeSteamVideo             WorkshopFileType = 14
	WorkshopFileTypeGameManagedItem        WorkshopFileType = 15
	WorkshopFileTypeClip                   WorkshopFileType = 16
	WorkshopFileTypeMax                    WorkshopFileType = 17
)

type WorkshopVideoProvider int //gd:Steam.WorkshopVideoProvider

const (
	WorkshopVideoProviderNone    WorkshopVideoProvider = 0
	WorkshopVideoProviderYoutube WorkshopVideoProvider = 1
)

type WorkshopVote int //gd:Steam.WorkshopVote

const (
	WorkshopVoteUnvoted WorkshopVote = 0
	WorkshopVoteFor     WorkshopVote = 1
	WorkshopVoteAgainst WorkshopVote = 2
	WorkshopVoteLater   WorkshopVote = 3
)

type XboxOrigin int //gd:Steam.XboxOrigin

const (
	XboxOriginA                   XboxOrigin = 0
	XboxOriginB                   XboxOrigin = 1
	XboxOriginX                   XboxOrigin = 2
	XboxOriginY                   XboxOrigin = 3
	XboxOriginLeftBumper          XboxOrigin = 4
	XboxOriginRightBumper         XboxOrigin = 5
	XboxOriginMenu                XboxOrigin = 6
	XboxOriginView                XboxOrigin = 7
	XboxOriginLeftTriggerPull     XboxOrigin = 8
	XboxOriginLeftTriggerClick    XboxOrigin = 9
	XboxOriginRightTriggerPull    XboxOrigin = 10
	XboxOriginRightTriggerClick   XboxOrigin = 11
	XboxOriginLeftStickMove       XboxOrigin = 12
	XboxOriginLeftStickClick      XboxOrigin = 13
	XboxOriginLeftStickDpadNorth  XboxOrigin = 14
	XboxOriginLeftStickDpadSouth  XboxOrigin = 15
	XboxOriginLeftStickDpadWest   XboxOrigin = 16
	XboxOriginLeftStickDpadEat    XboxOrigin = 17
	XboxOriginRightStickMove      XboxOrigin = 18
	XboxOriginRightStickClick     XboxOrigin = 19
	XboxOriginRightStickDpadNorth XboxOrigin = 20
	XboxOriginRightStickDpadSouth XboxOrigin = 21
	XboxOriginRightStickDpadWest  XboxOrigin = 22
	XboxOriginRightStickDpadEast  XboxOrigin = 23
	XboxOriginDpadNorth           XboxOrigin = 24
	XboxOriginDpadSouth           XboxOrigin = 25
	XboxOriginDpadWest            XboxOrigin = 26
	XboxOriginDpadEast            XboxOrigin = 27
	XboxOriginCount               XboxOrigin = 28
)

type CheckFileSignatureStatus int //gd:Steam.CheckFileSignature

const (
	CheckFileSignatureInvalidSignature             CheckFileSignatureStatus = 0
	CheckFileSignatureValidSignature               CheckFileSignatureStatus = 1
	CheckFileSignatureFileNotFound                 CheckFileSignatureStatus = 2
	CheckFileSignatureNoSignaturesFoundForThisApp  CheckFileSignatureStatus = 3
	CheckFileSignatureNoSignaturesFoundForThisFile CheckFileSignatureStatus = 4
)
const AccountIdInvalid int = 0                                 //gd:Steam.ACCOUNT_ID_INVALID
const ApiCallInvalid int = 0                                   //gd:Steam.API_CALL_INVALID
const AppIdInvalid int = 0                                     //gd:Steam.APP_ID_INVALID
const AuthTicketInvalid int = 0                                //gd:Steam.AUTH_TICKET_INVALID
const DepotIdInvalid int = 0                                   //gd:Steam.DEPOT_ID_INVALID
const GameExtraInfoMax int = 64                                //gd:Steam.GAME_EXTRA_INFO_MAX
const InvalidBreakpadHandle int = 0                            //gd:Steam.INVALID_BREAKPAD_HANDLE
const QueryPortError int = 65534                               //gd:Steam.QUERY_PORT_ERROR
const QueryPortNotInitialized int = 65535                      //gd:Steam.QUERY_PORT_NOT_INITIALIZED
const SteamAccountIdMask int = 4.294967295e+09                 //gd:Steam.STEAM_ACCOUNT_ID_MASK
const SteamAccountInstanceMask int = 1.048575e+06              //gd:Steam.STEAM_ACCOUNT_INSTANCE_MASK
const SteamBufferSize int = 255                                //gd:Steam.STEAM_BUFFER_SIZE
const SteamLargeBufferSize int = 8160                          //gd:Steam.STEAM_LARGE_BUFFER_SIZE
const SteamMaxErrorMessage int = 1024                          //gd:Steam.STEAM_MAX_ERROR_MESSAGE
const SteamUserConsoleInstance int = 2                         //gd:Steam.STEAM_USER_CONSOLE_INSTANCE
const SteamUserDesktopInstance int = 1                         //gd:Steam.STEAM_USER_DESKTOP_INSTANCE
const SteamUserWebInstance int = 4                             //gd:Steam.STEAM_USER_WEB_INSTANCE
const ChatMetadataMax int = 8192                               //gd:Steam.CHAT_METADATA_MAX
const EnumeratedFollowersMax int = 50                          //gd:Steam.ENUMERATED_FOLLOWERS_MAX
const FriendGameInfoQueryPortError int = 65534                 //gd:Steam.FRIEND_GAME_INFO_QUERY_PORT_ERROR
const FriendGameInfoQueryPortNotInitialized int = 65535        //gd:Steam.FRIEND_GAME_INFO_QUERY_PORT_NOT_INITIALIZED
const FriendsGroupLimit int = 100                              //gd:Steam.FRIENDS_GROUP_LIMIT
const InvalidFriendGroupId int = -1                            //gd:Steam.INVALID_FRIEND_GROUP_ID
const MaxFriendsGroupName int = 64                             //gd:Steam.MAX_FRIENDS_GROUP_NAME
const MaxRichPresenceKeyLength int = 64                        //gd:Steam.MAX_RICH_PRESENCE_KEY_LENGTH
const MaxRichPresenceKeys int = 30                             //gd:Steam.MAX_RICH_PRESENCE_KEYS
const MaxRichPresenceValueLenth int = 256                      //gd:Steam.MAX_RICH_PRESENCE_VALUE_LENTH
const PersonaNameMaxUtf8 int = 128                             //gd:Steam.PERSONA_NAME_MAX_UTF8
const PersonaNameMaxUtf16 int = 32                             //gd:Steam.PERSONA_NAME_MAX_UTF16
const InvalidHtmlbrowser int = 0                               //gd:Steam.INVALID_HTMLBROWSER
const HttpcookieInvalidHandle int = 0                          //gd:Steam.HTTPCOOKIE_INVALID_HANDLE
const HttprequestInvalidHandle int = 0                         //gd:Steam.HTTPREQUEST_INVALID_HANDLE
const InputHandleAllControllers int = -1                       //gd:Steam.INPUT_HANDLE_ALL_CONTROLLERS
const InputMaxActiveLayers int = 16                            //gd:Steam.INPUT_MAX_ACTIVE_LAYERS
const InputMaxAnalogActions int = 24                           //gd:Steam.INPUT_MAX_ANALOG_ACTIONS
const InputMaxAnalogActionData int = 1                         //gd:Steam.INPUT_MAX_ANALOG_ACTION_DATA
const InputMaxCount int = 16                                   //gd:Steam.INPUT_MAX_COUNT
const InputMaxDigitalActions int = 256                         //gd:Steam.INPUT_MAX_DIGITAL_ACTIONS
const InputMaxOrigins int = 8                                  //gd:Steam.INPUT_MAX_ORIGINS
const InputMinAnalogActionData int = -1                        //gd:Steam.INPUT_MIN_ANALOG_ACTION_DATA
const InventoryResultInvalid int = -1                          //gd:Steam.INVENTORY_RESULT_INVALID
const ItemInstanceIdInvalid int = -1                           //gd:Steam.ITEM_INSTANCE_ID_INVALID
const FavoriteFlagFavorite int = 1                             //gd:Steam.FAVORITE_FLAG_FAVORITE
const FavoriteFlagHistory int = 2                              //gd:Steam.FAVORITE_FLAG_HISTORY
const FavoriteFlagNone int = 0                                 //gd:Steam.FAVORITE_FLAG_NONE
const MaxLobbyKeyLength int = 255                              //gd:Steam.MAX_LOBBY_KEY_LENGTH
const ServerQueryInvalid int = -1                              //gd:Steam.SERVER_QUERY_INVALID
const MaxGameServerGameData int = 2048                         //gd:Steam.MAX_GAME_SERVER_GAME_DATA
const MaxGameServerGameDescription int = 64                    //gd:Steam.MAX_GAME_SERVER_GAME_DESCRIPTION
const MaxGameServerGameDir int = 32                            //gd:Steam.MAX_GAME_SERVER_GAME_DIR
const MaxGameServerMapName int = 32                            //gd:Steam.MAX_GAME_SERVER_MAP_NAME
const MaxGameServerName int = 64                               //gd:Steam.MAX_GAME_SERVER_NAME
const MaxGameServerTags int = 128                              //gd:Steam.MAX_GAME_SERVER_TAGS
const MusicNameMaxLength int = 255                             //gd:Steam.MUSIC_NAME_MAX_LENGTH
const MusicPngMaxLength int = 65535                            //gd:Steam.MUSIC_PNG_MAX_LENGTH
const MaxSteamPacketSize int = 524288                          //gd:Steam.MAX_STEAM_PACKET_SIZE
const ListenSocketInvalid int = 0                              //gd:Steam.LISTEN_SOCKET_INVALID
const MaxNetworkingErrorMessage int = 1024                     //gd:Steam.MAX_NETWORKING_ERROR_MESSAGE
const MaxNetworkingPingLocationString int = 1024               //gd:Steam.MAX_NETWORKING_PING_LOCATION_STRING
const NetworkingConfigP2pTransportIceDefault int = -1          //gd:Steam.NETWORKING_CONFIG_P2P_TRANSPORT_ICE_DEFAULT
const NetworkingConfigP2pTransportIceDisable int = 0           //gd:Steam.NETWORKING_CONFIG_P2P_TRANSPORT_ICE_DISABLE
const NetworkingConfigP2pTransportIceRelay int = 1             //gd:Steam.NETWORKING_CONFIG_P2P_TRANSPORT_ICE_RELAY
const NetworkingConfigP2pTransportIcePrivate int = 2           //gd:Steam.NETWORKING_CONFIG_P2P_TRANSPORT_ICE_PRIVATE
const NetworkingConfigP2pTransportIcePublic int = 4            //gd:Steam.NETWORKING_CONFIG_P2P_TRANSPORT_ICE_PUBLIC
const NetworkingConfigP2pTransportIceAll int = 2.147483647e+09 //gd:Steam.NETWORKING_CONFIG_P2P_TRANSPORT_ICE_ALL
const NetworkingConnectionInfoFlagUnauthenticated int = 1      //gd:Steam.NETWORKING_CONNECTION_INFO_FLAG_UNAUTHENTICATED
const NetworkingConnectionInfoFlagUnencrypted int = 2          //gd:Steam.NETWORKING_CONNECTION_INFO_FLAG_UNENCRYPTED
const NetworkingConnectionInfoFlagLoopbackBuffers int = 4      //gd:Steam.NETWORKING_CONNECTION_INFO_FLAG_LOOPBACK_BUFFERS
const NetworkingConnectionInfoFlagFast int = 8                 //gd:Steam.NETWORKING_CONNECTION_INFO_FLAG_FAST
const NetworkingConnectionInfoFlagRelayed int = 16             //gd:Steam.NETWORKING_CONNECTION_INFO_FLAG_RELAYED
const NetworkingConnectionInfoFlagDualwifi int = 32            //gd:Steam.NETWORKING_CONNECTION_INFO_FLAG_DUALWIFI
const NetworkingConnectionInvalid int = 0                      //gd:Steam.NETWORKING_CONNECTION_INVALID
const NetworkingMaxConnectionAppName int = 32                  //gd:Steam.NETWORKING_MAX_CONNECTION_APP_NAME
const NetworkingMaxConnectionCloseReason int = 128             //gd:Steam.NETWORKING_MAX_CONNECTION_CLOSE_REASON
const NetworkingMaxConnectionDescription int = 128             //gd:Steam.NETWORKING_MAX_CONNECTION_DESCRIPTION
const NetworkingPingFailed int = -1                            //gd:Steam.NETWORKING_PING_FAILED
const NetworkingPingUnknown int = -2                           //gd:Steam.NETWORKING_PING_UNKNOWN
const NetworkingSendUnreliable int = 0                         //gd:Steam.NETWORKING_SEND_UNRELIABLE
const NetworkingSendNoNagle int = 1                            //gd:Steam.NETWORKING_SEND_NO_NAGLE
const NetworkingSendUreliableNoNagle int = 1                   //gd:Steam.NETWORKING_SEND_URELIABLE_NO_NAGLE
const NetworkingSendNoDelay int = 4                            //gd:Steam.NETWORKING_SEND_NO_DELAY
const NetworkingSendUnreliableNoDelay int = 5                  //gd:Steam.NETWORKING_SEND_UNRELIABLE_NO_DELAY
const NetworkingSendReliable int = 8                           //gd:Steam.NETWORKING_SEND_RELIABLE
const NetworkingSendReliableNoNagle int = 9                    //gd:Steam.NETWORKING_SEND_RELIABLE_NO_NAGLE
const NetworkingSendUseCurrentThread int = 16                  //gd:Steam.NETWORKING_SEND_USE_CURRENT_THREAD
const NetworkingSendAutorestartBrokenSession int = 32          //gd:Steam.NETWORKING_SEND_AUTORESTART_BROKEN_SESSION
const EnumeratePublishedFilesMaxResults int = 50               //gd:Steam.ENUMERATE_PUBLISHED_FILES_MAX_RESULTS
const FileNameMax int = 260                                    //gd:Steam.FILE_NAME_MAX
const MaxCloudFileChunkSize int = 1.048576e+08                 //gd:Steam.MAX_CLOUD_FILE_CHUNK_SIZE
const PublishedDocumentChangeDescriptionMax int = 8000         //gd:Steam.PUBLISHED_DOCUMENT_CHANGE_DESCRIPTION_MAX
const PublishedDocumentDescriptionMax int = 8000               //gd:Steam.PUBLISHED_DOCUMENT_DESCRIPTION_MAX
const PublishedDocumentTitleMax int = 129                      //gd:Steam.PUBLISHED_DOCUMENT_TITLE_MAX
const PublishedFileIdInvalid int = 0                           //gd:Steam.PUBLISHED_FILE_ID_INVALID
const PublishedFileUpdateHandleInvalid int = -1                //gd:Steam.PUBLISHED_FILE_UPDATE_HANDLE_INVALID
const PublishedFileUrlMax int = 256                            //gd:Steam.PUBLISHED_FILE_URL_MAX
const TagListMax int = 1025                                    //gd:Steam.TAG_LIST_MAX
const UgcFileStreamHandleInvalid int = -1                      //gd:Steam.UGC_FILE_STREAM_HANDLE_INVALID
const UgcHandleInvalid int = -1                                //gd:Steam.UGC_HANDLE_INVALID
const MaxTaggedPublishedFiles int = 32                         //gd:Steam.MAX_TAGGED_PUBLISHED_FILES
const MaxTaggedUsers int = 32                                  //gd:Steam.MAX_TAGGED_USERS
const ScreenshotInvalidHandle int = 0                          //gd:Steam.SCREENSHOT_INVALID_HANDLE
const ScreenshotThumbWidth int = 200                           //gd:Steam.SCREENSHOT_THUMB_WIDTH
const UfsTagTypeMax int = 255                                  //gd:Steam.UFS_TAG_TYPE_MAX
const UfsTagValueMax int = 255                                 //gd:Steam.UFS_TAG_VALUE_MAX
const DeveloperMetadataMax int = 5000                          //gd:Steam.DEVELOPER_METADATA_MAX
const NumUgcResultsPerPage int = 50                            //gd:Steam.NUM_UGC_RESULTS_PER_PAGE
const UgcQueryHandleInvalid int = -1                           //gd:Steam.UGC_QUERY_HANDLE_INVALID
const UgcUpdateHandleInvalid int = -1                          //gd:Steam.UGC_UPDATE_HANDLE_INVALID
const LeaderboardDetailMax int = 64                            //gd:Steam.LEADERBOARD_DETAIL_MAX
const LeaderboardNameMax int = 128                             //gd:Steam.LEADERBOARD_NAME_MAX
const StatNameMax int = 128                                    //gd:Steam.STAT_NAME_MAX
