// Code generated by the generate package DO NOT EDIT

// Package TileData provides methods for working with TileData object instances.
package TileData

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/Material"
import "graphics.gd/classdb/NavigationPolygon"
import "graphics.gd/classdb/OccluderPolygon2D"
import "graphics.gd/classdb/TileSet"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Color"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"
import "graphics.gd/variant/Vector2"
import "graphics.gd/variant/Vector2i"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
[TileData] object represents a single tile in a [TileSet]. It is usually edited using the tileset editor, but it can be modified at runtime using [method TileMap._tile_data_runtime_update].
*/
type Instance [1]gdclass.TileData

func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

type Expanded [1]gdclass.TileData

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsTileData() Instance
}

/*
Sets the occluder polygon count in the TileSet occlusion layer with index [param layer_id].
*/
func (self Instance) SetOccluderPolygonsCount(layer_id int, polygons_count int) { //gd:TileData.set_occluder_polygons_count
	Advanced(self).SetOccluderPolygonsCount(int64(layer_id), int64(polygons_count))
}

/*
Returns the number of occluder polygons of the tile in the TileSet occlusion layer with index [param layer_id].
*/
func (self Instance) GetOccluderPolygonsCount(layer_id int) int { //gd:TileData.get_occluder_polygons_count
	return int(int(Advanced(self).GetOccluderPolygonsCount(int64(layer_id))))
}

/*
Adds an occlusion polygon to the tile on the TileSet occlusion layer with index [param layer_id].
*/
func (self Instance) AddOccluderPolygon(layer_id int) { //gd:TileData.add_occluder_polygon
	Advanced(self).AddOccluderPolygon(int64(layer_id))
}

/*
Removes the polygon at index [param polygon_index] for TileSet occlusion layer with index [param layer_id].
*/
func (self Instance) RemoveOccluderPolygon(layer_id int, polygon_index int) { //gd:TileData.remove_occluder_polygon
	Advanced(self).RemoveOccluderPolygon(int64(layer_id), int64(polygon_index))
}

/*
Sets the occluder for polygon with index [param polygon_index] in the TileSet occlusion layer with index [param layer_id].
*/
func (self Instance) SetOccluderPolygon(layer_id int, polygon_index int, polygon OccluderPolygon2D.Instance) { //gd:TileData.set_occluder_polygon
	Advanced(self).SetOccluderPolygon(int64(layer_id), int64(polygon_index), polygon)
}

/*
Returns the occluder polygon at index [param polygon_index] from the TileSet occlusion layer with index [param layer_id].
The [param flip_h], [param flip_v], and [param transpose] parameters can be [code]true[/code] to transform the returned polygon.
*/
func (self Instance) GetOccluderPolygon(layer_id int, polygon_index int) OccluderPolygon2D.Instance { //gd:TileData.get_occluder_polygon
	return OccluderPolygon2D.Instance(Advanced(self).GetOccluderPolygon(int64(layer_id), int64(polygon_index), false, false, false))
}

/*
Returns the occluder polygon at index [param polygon_index] from the TileSet occlusion layer with index [param layer_id].
The [param flip_h], [param flip_v], and [param transpose] parameters can be [code]true[/code] to transform the returned polygon.
*/
func (self Expanded) GetOccluderPolygon(layer_id int, polygon_index int, flip_h bool, flip_v bool, transpose bool) OccluderPolygon2D.Instance { //gd:TileData.get_occluder_polygon
	return OccluderPolygon2D.Instance(Advanced(self).GetOccluderPolygon(int64(layer_id), int64(polygon_index), flip_h, flip_v, transpose))
}

/*
Sets the occluder for the TileSet occlusion layer with index [param layer_id].
*/
func (self Instance) SetOccluder(layer_id int, occluder_polygon OccluderPolygon2D.Instance) { //gd:TileData.set_occluder
	Advanced(self).SetOccluder(int64(layer_id), occluder_polygon)
}

/*
Returns the occluder polygon of the tile for the TileSet occlusion layer with index [param layer_id].
[param flip_h], [param flip_v], and [param transpose] allow transforming the returned polygon.
*/
func (self Instance) GetOccluder(layer_id int) OccluderPolygon2D.Instance { //gd:TileData.get_occluder
	return OccluderPolygon2D.Instance(Advanced(self).GetOccluder(int64(layer_id), false, false, false))
}

/*
Returns the occluder polygon of the tile for the TileSet occlusion layer with index [param layer_id].
[param flip_h], [param flip_v], and [param transpose] allow transforming the returned polygon.
*/
func (self Expanded) GetOccluder(layer_id int, flip_h bool, flip_v bool, transpose bool) OccluderPolygon2D.Instance { //gd:TileData.get_occluder
	return OccluderPolygon2D.Instance(Advanced(self).GetOccluder(int64(layer_id), flip_h, flip_v, transpose))
}

/*
Sets the constant linear velocity. This does not move the tile. This linear velocity is applied to objects colliding with this tile. This is useful to create conveyor belts.
*/
func (self Instance) SetConstantLinearVelocity(layer_id int, velocity Vector2.XY) { //gd:TileData.set_constant_linear_velocity
	Advanced(self).SetConstantLinearVelocity(int64(layer_id), Vector2.XY(velocity))
}

/*
Returns the constant linear velocity applied to objects colliding with this tile.
*/
func (self Instance) GetConstantLinearVelocity(layer_id int) Vector2.XY { //gd:TileData.get_constant_linear_velocity
	return Vector2.XY(Advanced(self).GetConstantLinearVelocity(int64(layer_id)))
}

/*
Sets the constant angular velocity. This does not rotate the tile. This angular velocity is applied to objects colliding with this tile.
*/
func (self Instance) SetConstantAngularVelocity(layer_id int, velocity Float.X) { //gd:TileData.set_constant_angular_velocity
	Advanced(self).SetConstantAngularVelocity(int64(layer_id), float64(velocity))
}

/*
Returns the constant angular velocity applied to objects colliding with this tile.
*/
func (self Instance) GetConstantAngularVelocity(layer_id int) Float.X { //gd:TileData.get_constant_angular_velocity
	return Float.X(Float.X(Advanced(self).GetConstantAngularVelocity(int64(layer_id))))
}

/*
Sets the polygons count for TileSet physics layer with index [param layer_id].
*/
func (self Instance) SetCollisionPolygonsCount(layer_id int, polygons_count int) { //gd:TileData.set_collision_polygons_count
	Advanced(self).SetCollisionPolygonsCount(int64(layer_id), int64(polygons_count))
}

/*
Returns how many polygons the tile has for TileSet physics layer with index [param layer_id].
*/
func (self Instance) GetCollisionPolygonsCount(layer_id int) int { //gd:TileData.get_collision_polygons_count
	return int(int(Advanced(self).GetCollisionPolygonsCount(int64(layer_id))))
}

/*
Adds a collision polygon to the tile on the given TileSet physics layer.
*/
func (self Instance) AddCollisionPolygon(layer_id int) { //gd:TileData.add_collision_polygon
	Advanced(self).AddCollisionPolygon(int64(layer_id))
}

/*
Removes the polygon at index [param polygon_index] for TileSet physics layer with index [param layer_id].
*/
func (self Instance) RemoveCollisionPolygon(layer_id int, polygon_index int) { //gd:TileData.remove_collision_polygon
	Advanced(self).RemoveCollisionPolygon(int64(layer_id), int64(polygon_index))
}

/*
Sets the points of the polygon at index [param polygon_index] for TileSet physics layer with index [param layer_id].
*/
func (self Instance) SetCollisionPolygonPoints(layer_id int, polygon_index int, polygon []Vector2.XY) { //gd:TileData.set_collision_polygon_points
	Advanced(self).SetCollisionPolygonPoints(int64(layer_id), int64(polygon_index), Packed.New(polygon...))
}

/*
Returns the points of the polygon at index [param polygon_index] for TileSet physics layer with index [param layer_id].
*/
func (self Instance) GetCollisionPolygonPoints(layer_id int, polygon_index int) []Vector2.XY { //gd:TileData.get_collision_polygon_points
	return []Vector2.XY(slices.Collect(Advanced(self).GetCollisionPolygonPoints(int64(layer_id), int64(polygon_index)).Values()))
}

/*
Enables/disables one-way collisions on the polygon at index [param polygon_index] for TileSet physics layer with index [param layer_id].
*/
func (self Instance) SetCollisionPolygonOneWay(layer_id int, polygon_index int, one_way bool) { //gd:TileData.set_collision_polygon_one_way
	Advanced(self).SetCollisionPolygonOneWay(int64(layer_id), int64(polygon_index), one_way)
}

/*
Returns whether one-way collisions are enabled for the polygon at index [param polygon_index] for TileSet physics layer with index [param layer_id].
*/
func (self Instance) IsCollisionPolygonOneWay(layer_id int, polygon_index int) bool { //gd:TileData.is_collision_polygon_one_way
	return bool(Advanced(self).IsCollisionPolygonOneWay(int64(layer_id), int64(polygon_index)))
}

/*
Sets the one-way margin (for one-way platforms) of the polygon at index [param polygon_index] for TileSet physics layer with index [param layer_id].
*/
func (self Instance) SetCollisionPolygonOneWayMargin(layer_id int, polygon_index int, one_way_margin Float.X) { //gd:TileData.set_collision_polygon_one_way_margin
	Advanced(self).SetCollisionPolygonOneWayMargin(int64(layer_id), int64(polygon_index), float64(one_way_margin))
}

/*
Returns the one-way margin (for one-way platforms) of the polygon at index [param polygon_index] for TileSet physics layer with index [param layer_id].
*/
func (self Instance) GetCollisionPolygonOneWayMargin(layer_id int, polygon_index int) Float.X { //gd:TileData.get_collision_polygon_one_way_margin
	return Float.X(Float.X(Advanced(self).GetCollisionPolygonOneWayMargin(int64(layer_id), int64(polygon_index))))
}

/*
Sets the tile's terrain bit for the given [param peering_bit] direction. To check that a direction is valid, use [method is_valid_terrain_peering_bit].
*/
func (self Instance) SetTerrainPeeringBit(peering_bit TileSet.CellNeighbor, terrain int) { //gd:TileData.set_terrain_peering_bit
	Advanced(self).SetTerrainPeeringBit(peering_bit, int64(terrain))
}

/*
Returns the tile's terrain bit for the given [param peering_bit] direction. To check that a direction is valid, use [method is_valid_terrain_peering_bit].
*/
func (self Instance) GetTerrainPeeringBit(peering_bit TileSet.CellNeighbor) int { //gd:TileData.get_terrain_peering_bit
	return int(int(Advanced(self).GetTerrainPeeringBit(peering_bit)))
}

/*
Returns whether the given [param peering_bit] direction is valid for this tile.
*/
func (self Instance) IsValidTerrainPeeringBit(peering_bit TileSet.CellNeighbor) bool { //gd:TileData.is_valid_terrain_peering_bit
	return bool(Advanced(self).IsValidTerrainPeeringBit(peering_bit))
}

/*
Sets the navigation polygon for the TileSet navigation layer with index [param layer_id].
*/
func (self Instance) SetNavigationPolygon(layer_id int, navigation_polygon NavigationPolygon.Instance) { //gd:TileData.set_navigation_polygon
	Advanced(self).SetNavigationPolygon(int64(layer_id), navigation_polygon)
}

/*
Returns the navigation polygon of the tile for the TileSet navigation layer with index [param layer_id].
[param flip_h], [param flip_v], and [param transpose] allow transforming the returned polygon.
*/
func (self Instance) GetNavigationPolygon(layer_id int) NavigationPolygon.Instance { //gd:TileData.get_navigation_polygon
	return NavigationPolygon.Instance(Advanced(self).GetNavigationPolygon(int64(layer_id), false, false, false))
}

/*
Returns the navigation polygon of the tile for the TileSet navigation layer with index [param layer_id].
[param flip_h], [param flip_v], and [param transpose] allow transforming the returned polygon.
*/
func (self Expanded) GetNavigationPolygon(layer_id int, flip_h bool, flip_v bool, transpose bool) NavigationPolygon.Instance { //gd:TileData.get_navigation_polygon
	return NavigationPolygon.Instance(Advanced(self).GetNavigationPolygon(int64(layer_id), flip_h, flip_v, transpose))
}

/*
Sets the tile's custom data value for the TileSet custom data layer with name [param layer_name].
*/
func (self Instance) SetCustomData(layer_name string, value any) { //gd:TileData.set_custom_data
	Advanced(self).SetCustomData(String.New(layer_name), variant.New(value))
}

/*
Returns the custom data value for custom data layer named [param layer_name]. To check if a custom data layer exists, use [method has_custom_data].
*/
func (self Instance) GetCustomData(layer_name string) any { //gd:TileData.get_custom_data
	return any(Advanced(self).GetCustomData(String.New(layer_name)).Interface())
}

/*
Returns whether there exists a custom data layer named [param layer_name].
*/
func (self Instance) HasCustomData(layer_name string) bool { //gd:TileData.has_custom_data
	return bool(Advanced(self).HasCustomData(String.New(layer_name)))
}

/*
Sets the tile's custom data value for the TileSet custom data layer with index [param layer_id].
*/
func (self Instance) SetCustomDataByLayerId(layer_id int, value any) { //gd:TileData.set_custom_data_by_layer_id
	Advanced(self).SetCustomDataByLayerId(int64(layer_id), variant.New(value))
}

/*
Returns the custom data value for custom data layer with index [param layer_id].
*/
func (self Instance) GetCustomDataByLayerId(layer_id int) any { //gd:TileData.get_custom_data_by_layer_id
	return any(Advanced(self).GetCustomDataByLayerId(int64(layer_id)).Interface())
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.TileData

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {
	object := [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gdextension.Host.Objects.Make(pointers.Get(gd.NewStringName("TileData"))))})}
	casted := Instance{*(*gdclass.TileData)(unsafe.Pointer(&object))}
	object[0].Notification(0, false)
	return casted
}

func (self Instance) FlipH() bool {
	return bool(class(self).GetFlipH())
}

func (self Instance) SetFlipH(value bool) {
	class(self).SetFlipH(value)
}

func (self Instance) FlipV() bool {
	return bool(class(self).GetFlipV())
}

func (self Instance) SetFlipV(value bool) {
	class(self).SetFlipV(value)
}

func (self Instance) Transpose() bool {
	return bool(class(self).GetTranspose())
}

func (self Instance) SetTranspose(value bool) {
	class(self).SetTranspose(value)
}

func (self Instance) TextureOrigin() Vector2i.XY {
	return Vector2i.XY(class(self).GetTextureOrigin())
}

func (self Instance) SetTextureOrigin(value Vector2i.XY) {
	class(self).SetTextureOrigin(Vector2i.XY(value))
}

func (self Instance) Modulate() Color.RGBA {
	return Color.RGBA(class(self).GetModulate())
}

func (self Instance) SetModulate(value Color.RGBA) {
	class(self).SetModulate(Color.RGBA(value))
}

func (self Instance) Material() Material.Instance {
	return Material.Instance(class(self).GetMaterial())
}

func (self Instance) SetMaterial(value Material.Instance) {
	class(self).SetMaterial(value)
}

func (self Instance) ZIndex() int {
	return int(int(class(self).GetZIndex()))
}

func (self Instance) SetZIndex(value int) {
	class(self).SetZIndex(int64(value))
}

func (self Instance) YSortOrigin() int {
	return int(int(class(self).GetYSortOrigin()))
}

func (self Instance) SetYSortOrigin(value int) {
	class(self).SetYSortOrigin(int64(value))
}

func (self Instance) TerrainSet() int {
	return int(int(class(self).GetTerrainSet()))
}

func (self Instance) SetTerrainSet(value int) {
	class(self).SetTerrainSet(int64(value))
}

func (self Instance) Terrain() int {
	return int(int(class(self).GetTerrain()))
}

func (self Instance) SetTerrain(value int) {
	class(self).SetTerrain(int64(value))
}

func (self Instance) Probability() Float.X {
	return Float.X(Float.X(class(self).GetProbability()))
}

func (self Instance) SetProbability(value Float.X) {
	class(self).SetProbability(float64(value))
}

//go:nosplit
func (self class) SetFlipH(flip_h bool) { //gd:TileData.set_flip_h
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TileData.Bind_set_flip_h), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ flip_h bool }{flip_h}))
}

//go:nosplit
func (self class) GetFlipH() bool { //gd:TileData.get_flip_h
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TileData.Bind_get_flip_h), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetFlipV(flip_v bool) { //gd:TileData.set_flip_v
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TileData.Bind_set_flip_v), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ flip_v bool }{flip_v}))
}

//go:nosplit
func (self class) GetFlipV() bool { //gd:TileData.get_flip_v
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TileData.Bind_get_flip_v), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetTranspose(transpose bool) { //gd:TileData.set_transpose
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TileData.Bind_set_transpose), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ transpose bool }{transpose}))
}

//go:nosplit
func (self class) GetTranspose() bool { //gd:TileData.get_transpose
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TileData.Bind_get_transpose), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetMaterial(material [1]gdclass.Material) { //gd:TileData.set_material
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TileData.Bind_set_material), 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ material gdextension.Object }{gdextension.Object(gd.ObjectChecked(material[0].AsObject()))}))
}

//go:nosplit
func (self class) GetMaterial() [1]gdclass.Material { //gd:TileData.get_material
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TileData.Bind_get_material), gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.Material{gd.PointerWithOwnershipTransferredToGo[gdclass.Material](r_ret)}
	return ret
}

//go:nosplit
func (self class) SetTextureOrigin(texture_origin Vector2i.XY) { //gd:TileData.set_texture_origin
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TileData.Bind_set_texture_origin), 0|(gdextension.SizeVector2i<<4), unsafe.Pointer(&struct{ texture_origin Vector2i.XY }{texture_origin}))
}

//go:nosplit
func (self class) GetTextureOrigin() Vector2i.XY { //gd:TileData.get_texture_origin
	var r_ret = gdextension.Call[Vector2i.XY](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TileData.Bind_get_texture_origin), gdextension.SizeVector2i, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetModulate(modulate Color.RGBA) { //gd:TileData.set_modulate
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TileData.Bind_set_modulate), 0|(gdextension.SizeColor<<4), unsafe.Pointer(&struct{ modulate Color.RGBA }{modulate}))
}

//go:nosplit
func (self class) GetModulate() Color.RGBA { //gd:TileData.get_modulate
	var r_ret = gdextension.Call[Color.RGBA](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TileData.Bind_get_modulate), gdextension.SizeColor, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetZIndex(z_index int64) { //gd:TileData.set_z_index
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TileData.Bind_set_z_index), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ z_index int64 }{z_index}))
}

//go:nosplit
func (self class) GetZIndex() int64 { //gd:TileData.get_z_index
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TileData.Bind_get_z_index), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetYSortOrigin(y_sort_origin int64) { //gd:TileData.set_y_sort_origin
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TileData.Bind_set_y_sort_origin), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ y_sort_origin int64 }{y_sort_origin}))
}

//go:nosplit
func (self class) GetYSortOrigin() int64 { //gd:TileData.get_y_sort_origin
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TileData.Bind_get_y_sort_origin), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Sets the occluder polygon count in the TileSet occlusion layer with index [param layer_id].
*/
//go:nosplit
func (self class) SetOccluderPolygonsCount(layer_id int64, polygons_count int64) { //gd:TileData.set_occluder_polygons_count
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TileData.Bind_set_occluder_polygons_count), 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		layer_id       int64
		polygons_count int64
	}{layer_id, polygons_count}))
}

/*
Returns the number of occluder polygons of the tile in the TileSet occlusion layer with index [param layer_id].
*/
//go:nosplit
func (self class) GetOccluderPolygonsCount(layer_id int64) int64 { //gd:TileData.get_occluder_polygons_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TileData.Bind_get_occluder_polygons_count), gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ layer_id int64 }{layer_id}))
	var ret = r_ret
	return ret
}

/*
Adds an occlusion polygon to the tile on the TileSet occlusion layer with index [param layer_id].
*/
//go:nosplit
func (self class) AddOccluderPolygon(layer_id int64) { //gd:TileData.add_occluder_polygon
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TileData.Bind_add_occluder_polygon), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ layer_id int64 }{layer_id}))
}

/*
Removes the polygon at index [param polygon_index] for TileSet occlusion layer with index [param layer_id].
*/
//go:nosplit
func (self class) RemoveOccluderPolygon(layer_id int64, polygon_index int64) { //gd:TileData.remove_occluder_polygon
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TileData.Bind_remove_occluder_polygon), 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		layer_id      int64
		polygon_index int64
	}{layer_id, polygon_index}))
}

/*
Sets the occluder for polygon with index [param polygon_index] in the TileSet occlusion layer with index [param layer_id].
*/
//go:nosplit
func (self class) SetOccluderPolygon(layer_id int64, polygon_index int64, polygon [1]gdclass.OccluderPolygon2D) { //gd:TileData.set_occluder_polygon
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TileData.Bind_set_occluder_polygon), 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeObject<<12), unsafe.Pointer(&struct {
		layer_id      int64
		polygon_index int64
		polygon       gdextension.Object
	}{layer_id, polygon_index, gdextension.Object(gd.ObjectChecked(polygon[0].AsObject()))}))
}

/*
Returns the occluder polygon at index [param polygon_index] from the TileSet occlusion layer with index [param layer_id].
The [param flip_h], [param flip_v], and [param transpose] parameters can be [code]true[/code] to transform the returned polygon.
*/
//go:nosplit
func (self class) GetOccluderPolygon(layer_id int64, polygon_index int64, flip_h bool, flip_v bool, transpose bool) [1]gdclass.OccluderPolygon2D { //gd:TileData.get_occluder_polygon
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TileData.Bind_get_occluder_polygon), gdextension.SizeObject|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeBool<<12)|(gdextension.SizeBool<<16)|(gdextension.SizeBool<<20), unsafe.Pointer(&struct {
		layer_id      int64
		polygon_index int64
		flip_h        bool
		flip_v        bool
		transpose     bool
	}{layer_id, polygon_index, flip_h, flip_v, transpose}))
	var ret = [1]gdclass.OccluderPolygon2D{gd.PointerWithOwnershipTransferredToGo[gdclass.OccluderPolygon2D](r_ret)}
	return ret
}

/*
Sets the occluder for the TileSet occlusion layer with index [param layer_id].
*/
//go:nosplit
func (self class) SetOccluder(layer_id int64, occluder_polygon [1]gdclass.OccluderPolygon2D) { //gd:TileData.set_occluder
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TileData.Bind_set_occluder), 0|(gdextension.SizeInt<<4)|(gdextension.SizeObject<<8), unsafe.Pointer(&struct {
		layer_id         int64
		occluder_polygon gdextension.Object
	}{layer_id, gdextension.Object(gd.ObjectChecked(occluder_polygon[0].AsObject()))}))
}

/*
Returns the occluder polygon of the tile for the TileSet occlusion layer with index [param layer_id].
[param flip_h], [param flip_v], and [param transpose] allow transforming the returned polygon.
*/
//go:nosplit
func (self class) GetOccluder(layer_id int64, flip_h bool, flip_v bool, transpose bool) [1]gdclass.OccluderPolygon2D { //gd:TileData.get_occluder
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TileData.Bind_get_occluder), gdextension.SizeObject|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8)|(gdextension.SizeBool<<12)|(gdextension.SizeBool<<16), unsafe.Pointer(&struct {
		layer_id  int64
		flip_h    bool
		flip_v    bool
		transpose bool
	}{layer_id, flip_h, flip_v, transpose}))
	var ret = [1]gdclass.OccluderPolygon2D{gd.PointerWithOwnershipTransferredToGo[gdclass.OccluderPolygon2D](r_ret)}
	return ret
}

/*
Sets the constant linear velocity. This does not move the tile. This linear velocity is applied to objects colliding with this tile. This is useful to create conveyor belts.
*/
//go:nosplit
func (self class) SetConstantLinearVelocity(layer_id int64, velocity Vector2.XY) { //gd:TileData.set_constant_linear_velocity
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TileData.Bind_set_constant_linear_velocity), 0|(gdextension.SizeInt<<4)|(gdextension.SizeVector2<<8), unsafe.Pointer(&struct {
		layer_id int64
		velocity Vector2.XY
	}{layer_id, velocity}))
}

/*
Returns the constant linear velocity applied to objects colliding with this tile.
*/
//go:nosplit
func (self class) GetConstantLinearVelocity(layer_id int64) Vector2.XY { //gd:TileData.get_constant_linear_velocity
	var r_ret = gdextension.Call[Vector2.XY](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TileData.Bind_get_constant_linear_velocity), gdextension.SizeVector2|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ layer_id int64 }{layer_id}))
	var ret = r_ret
	return ret
}

/*
Sets the constant angular velocity. This does not rotate the tile. This angular velocity is applied to objects colliding with this tile.
*/
//go:nosplit
func (self class) SetConstantAngularVelocity(layer_id int64, velocity float64) { //gd:TileData.set_constant_angular_velocity
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TileData.Bind_set_constant_angular_velocity), 0|(gdextension.SizeInt<<4)|(gdextension.SizeFloat<<8), unsafe.Pointer(&struct {
		layer_id int64
		velocity float64
	}{layer_id, velocity}))
}

/*
Returns the constant angular velocity applied to objects colliding with this tile.
*/
//go:nosplit
func (self class) GetConstantAngularVelocity(layer_id int64) float64 { //gd:TileData.get_constant_angular_velocity
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TileData.Bind_get_constant_angular_velocity), gdextension.SizeFloat|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ layer_id int64 }{layer_id}))
	var ret = r_ret
	return ret
}

/*
Sets the polygons count for TileSet physics layer with index [param layer_id].
*/
//go:nosplit
func (self class) SetCollisionPolygonsCount(layer_id int64, polygons_count int64) { //gd:TileData.set_collision_polygons_count
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TileData.Bind_set_collision_polygons_count), 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		layer_id       int64
		polygons_count int64
	}{layer_id, polygons_count}))
}

/*
Returns how many polygons the tile has for TileSet physics layer with index [param layer_id].
*/
//go:nosplit
func (self class) GetCollisionPolygonsCount(layer_id int64) int64 { //gd:TileData.get_collision_polygons_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TileData.Bind_get_collision_polygons_count), gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ layer_id int64 }{layer_id}))
	var ret = r_ret
	return ret
}

/*
Adds a collision polygon to the tile on the given TileSet physics layer.
*/
//go:nosplit
func (self class) AddCollisionPolygon(layer_id int64) { //gd:TileData.add_collision_polygon
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TileData.Bind_add_collision_polygon), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ layer_id int64 }{layer_id}))
}

/*
Removes the polygon at index [param polygon_index] for TileSet physics layer with index [param layer_id].
*/
//go:nosplit
func (self class) RemoveCollisionPolygon(layer_id int64, polygon_index int64) { //gd:TileData.remove_collision_polygon
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TileData.Bind_remove_collision_polygon), 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		layer_id      int64
		polygon_index int64
	}{layer_id, polygon_index}))
}

/*
Sets the points of the polygon at index [param polygon_index] for TileSet physics layer with index [param layer_id].
*/
//go:nosplit
func (self class) SetCollisionPolygonPoints(layer_id int64, polygon_index int64, polygon Packed.Array[Vector2.XY]) { //gd:TileData.set_collision_polygon_points
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TileData.Bind_set_collision_polygon_points), 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8)|(gdextension.SizePackedArray<<12), unsafe.Pointer(&struct {
		layer_id      int64
		polygon_index int64
		polygon       gdextension.PackedArray[Vector2.XY]
	}{layer_id, polygon_index, pointers.Get(gd.InternalPacked[gd.PackedVector2Array, Vector2.XY](polygon))}))
}

/*
Returns the points of the polygon at index [param polygon_index] for TileSet physics layer with index [param layer_id].
*/
//go:nosplit
func (self class) GetCollisionPolygonPoints(layer_id int64, polygon_index int64) Packed.Array[Vector2.XY] { //gd:TileData.get_collision_polygon_points
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TileData.Bind_get_collision_polygon_points), gdextension.SizePackedArray|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		layer_id      int64
		polygon_index int64
	}{layer_id, polygon_index}))
	var ret = Packed.Array[Vector2.XY](Array.Through(gd.PackedProxy[gd.PackedVector2Array, Vector2.XY]{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

/*
Enables/disables one-way collisions on the polygon at index [param polygon_index] for TileSet physics layer with index [param layer_id].
*/
//go:nosplit
func (self class) SetCollisionPolygonOneWay(layer_id int64, polygon_index int64, one_way bool) { //gd:TileData.set_collision_polygon_one_way
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TileData.Bind_set_collision_polygon_one_way), 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeBool<<12), unsafe.Pointer(&struct {
		layer_id      int64
		polygon_index int64
		one_way       bool
	}{layer_id, polygon_index, one_way}))
}

/*
Returns whether one-way collisions are enabled for the polygon at index [param polygon_index] for TileSet physics layer with index [param layer_id].
*/
//go:nosplit
func (self class) IsCollisionPolygonOneWay(layer_id int64, polygon_index int64) bool { //gd:TileData.is_collision_polygon_one_way
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TileData.Bind_is_collision_polygon_one_way), gdextension.SizeBool|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		layer_id      int64
		polygon_index int64
	}{layer_id, polygon_index}))
	var ret = r_ret
	return ret
}

/*
Sets the one-way margin (for one-way platforms) of the polygon at index [param polygon_index] for TileSet physics layer with index [param layer_id].
*/
//go:nosplit
func (self class) SetCollisionPolygonOneWayMargin(layer_id int64, polygon_index int64, one_way_margin float64) { //gd:TileData.set_collision_polygon_one_way_margin
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TileData.Bind_set_collision_polygon_one_way_margin), 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeFloat<<12), unsafe.Pointer(&struct {
		layer_id       int64
		polygon_index  int64
		one_way_margin float64
	}{layer_id, polygon_index, one_way_margin}))
}

/*
Returns the one-way margin (for one-way platforms) of the polygon at index [param polygon_index] for TileSet physics layer with index [param layer_id].
*/
//go:nosplit
func (self class) GetCollisionPolygonOneWayMargin(layer_id int64, polygon_index int64) float64 { //gd:TileData.get_collision_polygon_one_way_margin
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TileData.Bind_get_collision_polygon_one_way_margin), gdextension.SizeFloat|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		layer_id      int64
		polygon_index int64
	}{layer_id, polygon_index}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetTerrainSet(terrain_set int64) { //gd:TileData.set_terrain_set
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TileData.Bind_set_terrain_set), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ terrain_set int64 }{terrain_set}))
}

//go:nosplit
func (self class) GetTerrainSet() int64 { //gd:TileData.get_terrain_set
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TileData.Bind_get_terrain_set), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetTerrain(terrain int64) { //gd:TileData.set_terrain
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TileData.Bind_set_terrain), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ terrain int64 }{terrain}))
}

//go:nosplit
func (self class) GetTerrain() int64 { //gd:TileData.get_terrain
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TileData.Bind_get_terrain), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Sets the tile's terrain bit for the given [param peering_bit] direction. To check that a direction is valid, use [method is_valid_terrain_peering_bit].
*/
//go:nosplit
func (self class) SetTerrainPeeringBit(peering_bit TileSet.CellNeighbor, terrain int64) { //gd:TileData.set_terrain_peering_bit
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TileData.Bind_set_terrain_peering_bit), 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		peering_bit TileSet.CellNeighbor
		terrain     int64
	}{peering_bit, terrain}))
}

/*
Returns the tile's terrain bit for the given [param peering_bit] direction. To check that a direction is valid, use [method is_valid_terrain_peering_bit].
*/
//go:nosplit
func (self class) GetTerrainPeeringBit(peering_bit TileSet.CellNeighbor) int64 { //gd:TileData.get_terrain_peering_bit
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TileData.Bind_get_terrain_peering_bit), gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ peering_bit TileSet.CellNeighbor }{peering_bit}))
	var ret = r_ret
	return ret
}

/*
Returns whether the given [param peering_bit] direction is valid for this tile.
*/
//go:nosplit
func (self class) IsValidTerrainPeeringBit(peering_bit TileSet.CellNeighbor) bool { //gd:TileData.is_valid_terrain_peering_bit
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TileData.Bind_is_valid_terrain_peering_bit), gdextension.SizeBool|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ peering_bit TileSet.CellNeighbor }{peering_bit}))
	var ret = r_ret
	return ret
}

/*
Sets the navigation polygon for the TileSet navigation layer with index [param layer_id].
*/
//go:nosplit
func (self class) SetNavigationPolygon(layer_id int64, navigation_polygon [1]gdclass.NavigationPolygon) { //gd:TileData.set_navigation_polygon
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TileData.Bind_set_navigation_polygon), 0|(gdextension.SizeInt<<4)|(gdextension.SizeObject<<8), unsafe.Pointer(&struct {
		layer_id           int64
		navigation_polygon gdextension.Object
	}{layer_id, gdextension.Object(gd.ObjectChecked(navigation_polygon[0].AsObject()))}))
}

/*
Returns the navigation polygon of the tile for the TileSet navigation layer with index [param layer_id].
[param flip_h], [param flip_v], and [param transpose] allow transforming the returned polygon.
*/
//go:nosplit
func (self class) GetNavigationPolygon(layer_id int64, flip_h bool, flip_v bool, transpose bool) [1]gdclass.NavigationPolygon { //gd:TileData.get_navigation_polygon
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TileData.Bind_get_navigation_polygon), gdextension.SizeObject|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8)|(gdextension.SizeBool<<12)|(gdextension.SizeBool<<16), unsafe.Pointer(&struct {
		layer_id  int64
		flip_h    bool
		flip_v    bool
		transpose bool
	}{layer_id, flip_h, flip_v, transpose}))
	var ret = [1]gdclass.NavigationPolygon{gd.PointerWithOwnershipTransferredToGo[gdclass.NavigationPolygon](r_ret)}
	return ret
}

//go:nosplit
func (self class) SetProbability(probability float64) { //gd:TileData.set_probability
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TileData.Bind_set_probability), 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ probability float64 }{probability}))
}

//go:nosplit
func (self class) GetProbability() float64 { //gd:TileData.get_probability
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TileData.Bind_get_probability), gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Sets the tile's custom data value for the TileSet custom data layer with name [param layer_name].
*/
//go:nosplit
func (self class) SetCustomData(layer_name String.Readable, value variant.Any) { //gd:TileData.set_custom_data
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TileData.Bind_set_custom_data), 0|(gdextension.SizeString<<4)|(gdextension.SizeVariant<<8), unsafe.Pointer(&struct {
		layer_name gdextension.String
		value      gdextension.Variant
	}{pointers.Get(gd.InternalString(layer_name)), gdextension.Variant(pointers.Get(gd.InternalVariant(value)))}))
}

/*
Returns the custom data value for custom data layer named [param layer_name]. To check if a custom data layer exists, use [method has_custom_data].
*/
//go:nosplit
func (self class) GetCustomData(layer_name String.Readable) variant.Any { //gd:TileData.get_custom_data
	var r_ret = gdextension.Call[gdextension.Variant](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TileData.Bind_get_custom_data), gdextension.SizeVariant|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ layer_name gdextension.String }{pointers.Get(gd.InternalString(layer_name))}))
	var ret = variant.Implementation(gd.VariantProxy{}, pointers.Pack(pointers.New[gd.Variant](r_ret)))
	return ret
}

/*
Returns whether there exists a custom data layer named [param layer_name].
*/
//go:nosplit
func (self class) HasCustomData(layer_name String.Readable) bool { //gd:TileData.has_custom_data
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TileData.Bind_has_custom_data), gdextension.SizeBool|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ layer_name gdextension.String }{pointers.Get(gd.InternalString(layer_name))}))
	var ret = r_ret
	return ret
}

/*
Sets the tile's custom data value for the TileSet custom data layer with index [param layer_id].
*/
//go:nosplit
func (self class) SetCustomDataByLayerId(layer_id int64, value variant.Any) { //gd:TileData.set_custom_data_by_layer_id
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TileData.Bind_set_custom_data_by_layer_id), 0|(gdextension.SizeInt<<4)|(gdextension.SizeVariant<<8), unsafe.Pointer(&struct {
		layer_id int64
		value    gdextension.Variant
	}{layer_id, gdextension.Variant(pointers.Get(gd.InternalVariant(value)))}))
}

/*
Returns the custom data value for custom data layer with index [param layer_id].
*/
//go:nosplit
func (self class) GetCustomDataByLayerId(layer_id int64) variant.Any { //gd:TileData.get_custom_data_by_layer_id
	var r_ret = gdextension.Call[gdextension.Variant](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.TileData.Bind_get_custom_data_by_layer_id), gdextension.SizeVariant|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ layer_id int64 }{layer_id}))
	var ret = variant.Implementation(gd.VariantProxy{}, pointers.Pack(pointers.New[gd.Variant](r_ret)))
	return ret
}
func (self Instance) OnChanged(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("changed"), gd.NewCallable(cb), 0)
}

func (self class) AsTileData() Advanced         { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsTileData() Instance      { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsTileData() Instance { return self.Super().AsTileData() }

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Object.Advanced(self.AsObject()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Object.Instance(self.AsObject()), name)
	}
}
func init() {
	gdclass.Register("TileData", func(ptr gd.Object) any { return [1]gdclass.TileData{*(*gdclass.TileData)(unsafe.Pointer(&ptr))} })
}
