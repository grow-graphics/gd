// Code generated by the generate package DO NOT EDIT

// Package ItemList provides methods for working with ItemList object instances.
package ItemList

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/CanvasItem"
import "graphics.gd/classdb/Control"
import "graphics.gd/classdb/HScrollBar"
import "graphics.gd/classdb/Node"
import "graphics.gd/classdb/TextServer"
import "graphics.gd/classdb/Texture2D"
import "graphics.gd/classdb/VScrollBar"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Color"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/Rect2"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"
import "graphics.gd/variant/Vector2"
import "graphics.gd/variant/Vector2i"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
This control provides a vertical list of selectable items that may be in a single or in multiple columns, with each item having options for text and an icon. Tooltips are supported and may be different for every item in the list.
Selectable items in the list may be selected or deselected and multiple selection may be enabled. Selection with right mouse button may also be enabled to allow use of popup context menus. Items may also be "activated" by double-clicking them or by pressing [kbd]Enter[/kbd].
Item text only supports single-line strings. Newline characters (e.g. [code]\n[/code]) in the string won't produce a newline. Text wrapping is enabled in [constant ICON_MODE_TOP] mode, but the column's width is adjusted to fully fit its content by default. You need to set [member fixed_column_width] greater than zero to wrap the text.
All [code]set_*[/code] methods allow negative item indices, i.e. [code]-1[/code] to access the last item, [code]-2[/code] to select the second-to-last item, and so on.
[b]Incremental search:[/b] Like [PopupMenu] and [Tree], [ItemList] supports searching within the list while the control is focused. Press a key that matches the first letter of an item's name to select the first item starting with the given letter. After that point, there are two ways to perform incremental search: 1) Press the same key again before the timeout duration to select the next item starting with the same letter. 2) Press letter keys that match the rest of the word before the timeout duration to match to select the item in question directly. Both of these actions will be reset to the beginning of the list if the timeout duration has passed since the last keystroke was registered. You can adjust the timeout duration by changing [member ProjectSettings.gui/timers/incremental_search_max_interval_msec].
*/
type Instance [1]gdclass.ItemList

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	add_item                     gdextension.MethodForClass `hash:"359861678"`
	add_icon_item                gdextension.MethodForClass `hash:"4256579627"`
	set_item_text                gdextension.MethodForClass `hash:"501894301"`
	get_item_text                gdextension.MethodForClass `hash:"844755477"`
	set_item_icon                gdextension.MethodForClass `hash:"666127730"`
	get_item_icon                gdextension.MethodForClass `hash:"3536238170"`
	set_item_text_direction      gdextension.MethodForClass `hash:"1707680378"`
	get_item_text_direction      gdextension.MethodForClass `hash:"4235602388"`
	set_item_language            gdextension.MethodForClass `hash:"501894301"`
	get_item_language            gdextension.MethodForClass `hash:"844755477"`
	set_item_auto_translate_mode gdextension.MethodForClass `hash:"287402019"`
	get_item_auto_translate_mode gdextension.MethodForClass `hash:"906302372"`
	set_item_icon_transposed     gdextension.MethodForClass `hash:"300928843"`
	is_item_icon_transposed      gdextension.MethodForClass `hash:"1116898809"`
	set_item_icon_region         gdextension.MethodForClass `hash:"1356297692"`
	get_item_icon_region         gdextension.MethodForClass `hash:"3327874267"`
	set_item_icon_modulate       gdextension.MethodForClass `hash:"2878471219"`
	get_item_icon_modulate       gdextension.MethodForClass `hash:"3457211756"`
	set_item_selectable          gdextension.MethodForClass `hash:"300928843"`
	is_item_selectable           gdextension.MethodForClass `hash:"1116898809"`
	set_item_disabled            gdextension.MethodForClass `hash:"300928843"`
	is_item_disabled             gdextension.MethodForClass `hash:"1116898809"`
	set_item_metadata            gdextension.MethodForClass `hash:"2152698145"`
	get_item_metadata            gdextension.MethodForClass `hash:"4227898402"`
	set_item_custom_bg_color     gdextension.MethodForClass `hash:"2878471219"`
	get_item_custom_bg_color     gdextension.MethodForClass `hash:"3457211756"`
	set_item_custom_fg_color     gdextension.MethodForClass `hash:"2878471219"`
	get_item_custom_fg_color     gdextension.MethodForClass `hash:"3457211756"`
	get_item_rect                gdextension.MethodForClass `hash:"159227807"`
	set_item_tooltip_enabled     gdextension.MethodForClass `hash:"300928843"`
	is_item_tooltip_enabled      gdextension.MethodForClass `hash:"1116898809"`
	set_item_tooltip             gdextension.MethodForClass `hash:"501894301"`
	get_item_tooltip             gdextension.MethodForClass `hash:"844755477"`
	select_                      gdextension.MethodForClass `hash:"972357352"`
	deselect                     gdextension.MethodForClass `hash:"1286410249"`
	deselect_all                 gdextension.MethodForClass `hash:"3218959716"`
	is_selected                  gdextension.MethodForClass `hash:"1116898809"`
	get_selected_items           gdextension.MethodForClass `hash:"969006518"`
	move_item                    gdextension.MethodForClass `hash:"3937882851"`
	set_item_count               gdextension.MethodForClass `hash:"1286410249"`
	get_item_count               gdextension.MethodForClass `hash:"3905245786"`
	remove_item                  gdextension.MethodForClass `hash:"1286410249"`
	clear                        gdextension.MethodForClass `hash:"3218959716"`
	sort_items_by_text           gdextension.MethodForClass `hash:"3218959716"`
	set_fixed_column_width       gdextension.MethodForClass `hash:"1286410249"`
	get_fixed_column_width       gdextension.MethodForClass `hash:"3905245786"`
	set_same_column_width        gdextension.MethodForClass `hash:"2586408642"`
	is_same_column_width         gdextension.MethodForClass `hash:"36873697"`
	set_max_text_lines           gdextension.MethodForClass `hash:"1286410249"`
	get_max_text_lines           gdextension.MethodForClass `hash:"3905245786"`
	set_max_columns              gdextension.MethodForClass `hash:"1286410249"`
	get_max_columns              gdextension.MethodForClass `hash:"3905245786"`
	set_select_mode              gdextension.MethodForClass `hash:"928267388"`
	get_select_mode              gdextension.MethodForClass `hash:"1191945842"`
	set_icon_mode                gdextension.MethodForClass `hash:"2025053633"`
	get_icon_mode                gdextension.MethodForClass `hash:"3353929232"`
	set_fixed_icon_size          gdextension.MethodForClass `hash:"1130785943"`
	get_fixed_icon_size          gdextension.MethodForClass `hash:"3690982128"`
	set_icon_scale               gdextension.MethodForClass `hash:"373806689"`
	get_icon_scale               gdextension.MethodForClass `hash:"1740695150"`
	set_allow_rmb_select         gdextension.MethodForClass `hash:"2586408642"`
	get_allow_rmb_select         gdextension.MethodForClass `hash:"36873697"`
	set_allow_reselect           gdextension.MethodForClass `hash:"2586408642"`
	get_allow_reselect           gdextension.MethodForClass `hash:"36873697"`
	set_allow_search             gdextension.MethodForClass `hash:"2586408642"`
	get_allow_search             gdextension.MethodForClass `hash:"36873697"`
	set_auto_width               gdextension.MethodForClass `hash:"2586408642"`
	has_auto_width               gdextension.MethodForClass `hash:"36873697"`
	set_auto_height              gdextension.MethodForClass `hash:"2586408642"`
	has_auto_height              gdextension.MethodForClass `hash:"36873697"`
	is_anything_selected         gdextension.MethodForClass `hash:"2240911060"`
	get_item_at_position         gdextension.MethodForClass `hash:"2300324924"`
	ensure_current_is_visible    gdextension.MethodForClass `hash:"3218959716"`
	get_v_scroll_bar             gdextension.MethodForClass `hash:"2630340773"`
	get_h_scroll_bar             gdextension.MethodForClass `hash:"4004517983"`
	set_text_overrun_behavior    gdextension.MethodForClass `hash:"1008890932"`
	get_text_overrun_behavior    gdextension.MethodForClass `hash:"3779142101"`
	set_wraparound_items         gdextension.MethodForClass `hash:"2586408642"`
	has_wraparound_items         gdextension.MethodForClass `hash:"36873697"`
	force_update_list_size       gdextension.MethodForClass `hash:"3218959716"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("ItemList")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		pointers.Raw[gd.StringName](sname).Free()
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

type Expanded [1]gdclass.ItemList

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsItemList() Instance
}

/*
Adds an item to the item list with specified text. Returns the index of an added item.
Specify an [param icon], or use [code]null[/code] as the [param icon] for a list item with no icon.
If [param selectable] is [code]true[/code], the list item will be selectable.
*/
func (self Instance) AddItem(text string) int { //gd:ItemList.add_item
	return int(int(Advanced(self).AddItem(String.New(text), [1]Texture2D.Instance{}[0], true)))
}

/*
Adds an item to the item list with specified text. Returns the index of an added item.
Specify an [param icon], or use [code]null[/code] as the [param icon] for a list item with no icon.
If [param selectable] is [code]true[/code], the list item will be selectable.
*/
func (self Expanded) AddItem(text string, icon Texture2D.Instance, selectable bool) int { //gd:ItemList.add_item
	return int(int(Advanced(self).AddItem(String.New(text), icon, selectable)))
}

/*
Adds an item to the item list with no text, only an icon. Returns the index of an added item.
*/
func (self Instance) AddIconItem(icon Texture2D.Instance) int { //gd:ItemList.add_icon_item
	return int(int(Advanced(self).AddIconItem(icon, true)))
}

/*
Adds an item to the item list with no text, only an icon. Returns the index of an added item.
*/
func (self Expanded) AddIconItem(icon Texture2D.Instance, selectable bool) int { //gd:ItemList.add_icon_item
	return int(int(Advanced(self).AddIconItem(icon, selectable)))
}

/*
Sets text of the item associated with the specified index.
*/
func (self Instance) SetItemText(idx int, text string) { //gd:ItemList.set_item_text
	Advanced(self).SetItemText(int64(idx), String.New(text))
}

/*
Returns the text associated with the specified index.
*/
func (self Instance) GetItemText(idx int) string { //gd:ItemList.get_item_text
	return string(Advanced(self).GetItemText(int64(idx)).String())
}

/*
Sets (or replaces) the icon's [Texture2D] associated with the specified index.
*/
func (self Instance) SetItemIcon(idx int, icon Texture2D.Instance) { //gd:ItemList.set_item_icon
	Advanced(self).SetItemIcon(int64(idx), icon)
}

/*
Returns the icon associated with the specified index.
*/
func (self Instance) GetItemIcon(idx int) Texture2D.Instance { //gd:ItemList.get_item_icon
	return Texture2D.Instance(Advanced(self).GetItemIcon(int64(idx)))
}

/*
Sets item's text base writing direction.
*/
func (self Instance) SetItemTextDirection(idx int, direction Control.TextDirection) { //gd:ItemList.set_item_text_direction
	Advanced(self).SetItemTextDirection(int64(idx), direction)
}

/*
Returns item's text base writing direction.
*/
func (self Instance) GetItemTextDirection(idx int) Control.TextDirection { //gd:ItemList.get_item_text_direction
	return Control.TextDirection(Advanced(self).GetItemTextDirection(int64(idx)))
}

/*
Sets language code of item's text used for line-breaking and text shaping algorithms, if left empty current locale is used instead.
*/
func (self Instance) SetItemLanguage(idx int, language string) { //gd:ItemList.set_item_language
	Advanced(self).SetItemLanguage(int64(idx), String.New(language))
}

/*
Returns item's text language code.
*/
func (self Instance) GetItemLanguage(idx int) string { //gd:ItemList.get_item_language
	return string(Advanced(self).GetItemLanguage(int64(idx)).String())
}

/*
Sets the auto translate mode of the item associated with the specified index.
Items use [constant Node.AUTO_TRANSLATE_MODE_INHERIT] by default, which uses the same auto translate mode as the [ItemList] itself.
*/
func (self Instance) SetItemAutoTranslateMode(idx int, mode Node.AutoTranslateMode) { //gd:ItemList.set_item_auto_translate_mode
	Advanced(self).SetItemAutoTranslateMode(int64(idx), mode)
}

/*
Returns item's auto translate mode.
*/
func (self Instance) GetItemAutoTranslateMode(idx int) Node.AutoTranslateMode { //gd:ItemList.get_item_auto_translate_mode
	return Node.AutoTranslateMode(Advanced(self).GetItemAutoTranslateMode(int64(idx)))
}

/*
Sets whether the item icon will be drawn transposed.
*/
func (self Instance) SetItemIconTransposed(idx int, transposed bool) { //gd:ItemList.set_item_icon_transposed
	Advanced(self).SetItemIconTransposed(int64(idx), transposed)
}

/*
Returns [code]true[/code] if the item icon will be drawn transposed, i.e. the X and Y axes are swapped.
*/
func (self Instance) IsItemIconTransposed(idx int) bool { //gd:ItemList.is_item_icon_transposed
	return bool(Advanced(self).IsItemIconTransposed(int64(idx)))
}

/*
Sets the region of item's icon used. The whole icon will be used if the region has no area.
*/
func (self Instance) SetItemIconRegion(idx int, rect Rect2.PositionSize) { //gd:ItemList.set_item_icon_region
	Advanced(self).SetItemIconRegion(int64(idx), Rect2.PositionSize(rect))
}

/*
Returns the region of item's icon used. The whole icon will be used if the region has no area.
*/
func (self Instance) GetItemIconRegion(idx int) Rect2.PositionSize { //gd:ItemList.get_item_icon_region
	return Rect2.PositionSize(Advanced(self).GetItemIconRegion(int64(idx)))
}

/*
Sets a modulating [Color] of the item associated with the specified index.
*/
func (self Instance) SetItemIconModulate(idx int, modulate Color.RGBA) { //gd:ItemList.set_item_icon_modulate
	Advanced(self).SetItemIconModulate(int64(idx), Color.RGBA(modulate))
}

/*
Returns a [Color] modulating item's icon at the specified index.
*/
func (self Instance) GetItemIconModulate(idx int) Color.RGBA { //gd:ItemList.get_item_icon_modulate
	return Color.RGBA(Advanced(self).GetItemIconModulate(int64(idx)))
}

/*
Allows or disallows selection of the item associated with the specified index.
*/
func (self Instance) SetItemSelectable(idx int, selectable bool) { //gd:ItemList.set_item_selectable
	Advanced(self).SetItemSelectable(int64(idx), selectable)
}

/*
Returns [code]true[/code] if the item at the specified index is selectable.
*/
func (self Instance) IsItemSelectable(idx int) bool { //gd:ItemList.is_item_selectable
	return bool(Advanced(self).IsItemSelectable(int64(idx)))
}

/*
Disables (or enables) the item at the specified index.
Disabled items cannot be selected and do not trigger activation signals (when double-clicking or pressing [kbd]Enter[/kbd]).
*/
func (self Instance) SetItemDisabled(idx int, disabled bool) { //gd:ItemList.set_item_disabled
	Advanced(self).SetItemDisabled(int64(idx), disabled)
}

/*
Returns [code]true[/code] if the item at the specified index is disabled.
*/
func (self Instance) IsItemDisabled(idx int) bool { //gd:ItemList.is_item_disabled
	return bool(Advanced(self).IsItemDisabled(int64(idx)))
}

/*
Sets a value (of any type) to be stored with the item associated with the specified index.
*/
func (self Instance) SetItemMetadata(idx int, metadata any) { //gd:ItemList.set_item_metadata
	Advanced(self).SetItemMetadata(int64(idx), variant.New(metadata))
}

/*
Returns the metadata value of the specified index.
*/
func (self Instance) GetItemMetadata(idx int) any { //gd:ItemList.get_item_metadata
	return any(Advanced(self).GetItemMetadata(int64(idx)).Interface())
}

/*
Sets the background color of the item specified by [param idx] index to the specified [Color].
*/
func (self Instance) SetItemCustomBgColor(idx int, custom_bg_color Color.RGBA) { //gd:ItemList.set_item_custom_bg_color
	Advanced(self).SetItemCustomBgColor(int64(idx), Color.RGBA(custom_bg_color))
}

/*
Returns the custom background color of the item specified by [param idx] index.
*/
func (self Instance) GetItemCustomBgColor(idx int) Color.RGBA { //gd:ItemList.get_item_custom_bg_color
	return Color.RGBA(Advanced(self).GetItemCustomBgColor(int64(idx)))
}

/*
Sets the foreground color of the item specified by [param idx] index to the specified [Color].
*/
func (self Instance) SetItemCustomFgColor(idx int, custom_fg_color Color.RGBA) { //gd:ItemList.set_item_custom_fg_color
	Advanced(self).SetItemCustomFgColor(int64(idx), Color.RGBA(custom_fg_color))
}

/*
Returns the custom foreground color of the item specified by [param idx] index.
*/
func (self Instance) GetItemCustomFgColor(idx int) Color.RGBA { //gd:ItemList.get_item_custom_fg_color
	return Color.RGBA(Advanced(self).GetItemCustomFgColor(int64(idx)))
}

/*
Returns the position and size of the item with the specified index, in the coordinate system of the [ItemList] node. If [param expand] is [code]true[/code] the last column expands to fill the rest of the row.
[b]Note:[/b] The returned value is unreliable if called right after modifying the [ItemList], before it redraws in the next frame.
*/
func (self Instance) GetItemRect(idx int) Rect2.PositionSize { //gd:ItemList.get_item_rect
	return Rect2.PositionSize(Advanced(self).GetItemRect(int64(idx), true))
}

/*
Returns the position and size of the item with the specified index, in the coordinate system of the [ItemList] node. If [param expand] is [code]true[/code] the last column expands to fill the rest of the row.
[b]Note:[/b] The returned value is unreliable if called right after modifying the [ItemList], before it redraws in the next frame.
*/
func (self Expanded) GetItemRect(idx int, expand bool) Rect2.PositionSize { //gd:ItemList.get_item_rect
	return Rect2.PositionSize(Advanced(self).GetItemRect(int64(idx), expand))
}

/*
Sets whether the tooltip hint is enabled for specified item index.
*/
func (self Instance) SetItemTooltipEnabled(idx int, enable bool) { //gd:ItemList.set_item_tooltip_enabled
	Advanced(self).SetItemTooltipEnabled(int64(idx), enable)
}

/*
Returns [code]true[/code] if the tooltip is enabled for specified item index.
*/
func (self Instance) IsItemTooltipEnabled(idx int) bool { //gd:ItemList.is_item_tooltip_enabled
	return bool(Advanced(self).IsItemTooltipEnabled(int64(idx)))
}

/*
Sets the tooltip hint for the item associated with the specified index.
*/
func (self Instance) SetItemTooltip(idx int, tooltip string) { //gd:ItemList.set_item_tooltip
	Advanced(self).SetItemTooltip(int64(idx), String.New(tooltip))
}

/*
Returns the tooltip hint associated with the specified index.
*/
func (self Instance) GetItemTooltip(idx int) string { //gd:ItemList.get_item_tooltip
	return string(Advanced(self).GetItemTooltip(int64(idx)).String())
}

/*
Select the item at the specified index.
[b]Note:[/b] This method does not trigger the item selection signal.
*/
func (self Instance) Select(idx int) { //gd:ItemList.select
	Advanced(self).Select(int64(idx), true)
}

/*
Select the item at the specified index.
[b]Note:[/b] This method does not trigger the item selection signal.
*/
func (self Expanded) Select(idx int, single bool) { //gd:ItemList.select
	Advanced(self).Select(int64(idx), single)
}

/*
Ensures the item associated with the specified index is not selected.
*/
func (self Instance) Deselect(idx int) { //gd:ItemList.deselect
	Advanced(self).Deselect(int64(idx))
}

/*
Ensures there are no items selected.
*/
func (self Instance) DeselectAll() { //gd:ItemList.deselect_all
	Advanced(self).DeselectAll()
}

/*
Returns [code]true[/code] if the item at the specified index is currently selected.
*/
func (self Instance) IsSelected(idx int) bool { //gd:ItemList.is_selected
	return bool(Advanced(self).IsSelected(int64(idx)))
}

/*
Returns an array with the indexes of the selected items.
*/
func (self Instance) GetSelectedItems() []int32 { //gd:ItemList.get_selected_items
	return []int32(slices.Collect(Advanced(self).GetSelectedItems().Values()))
}

/*
Moves item from index [param from_idx] to [param to_idx].
*/
func (self Instance) MoveItem(from_idx int, to_idx int) { //gd:ItemList.move_item
	Advanced(self).MoveItem(int64(from_idx), int64(to_idx))
}

/*
Removes the item specified by [param idx] index from the list.
*/
func (self Instance) RemoveItem(idx int) { //gd:ItemList.remove_item
	Advanced(self).RemoveItem(int64(idx))
}

/*
Removes all items from the list.
*/
func (self Instance) Clear() { //gd:ItemList.clear
	Advanced(self).Clear()
}

/*
Sorts items in the list by their text.
*/
func (self Instance) SortItemsByText() { //gd:ItemList.sort_items_by_text
	Advanced(self).SortItemsByText()
}

/*
Returns [code]true[/code] if one or more items are selected.
*/
func (self Instance) IsAnythingSelected() bool { //gd:ItemList.is_anything_selected
	return bool(Advanced(self).IsAnythingSelected())
}

/*
Returns the item index at the given [param position].
When there is no item at that point, -1 will be returned if [param exact] is [code]true[/code], and the closest item index will be returned otherwise.
[b]Note:[/b] The returned value is unreliable if called right after modifying the [ItemList], before it redraws in the next frame.
*/
func (self Instance) GetItemAtPosition(position Vector2.XY) int { //gd:ItemList.get_item_at_position
	return int(int(Advanced(self).GetItemAtPosition(Vector2.XY(position), false)))
}

/*
Returns the item index at the given [param position].
When there is no item at that point, -1 will be returned if [param exact] is [code]true[/code], and the closest item index will be returned otherwise.
[b]Note:[/b] The returned value is unreliable if called right after modifying the [ItemList], before it redraws in the next frame.
*/
func (self Expanded) GetItemAtPosition(position Vector2.XY, exact bool) int { //gd:ItemList.get_item_at_position
	return int(int(Advanced(self).GetItemAtPosition(Vector2.XY(position), exact)))
}

/*
Ensure current selection is visible, adjusting the scroll position as necessary.
*/
func (self Instance) EnsureCurrentIsVisible() { //gd:ItemList.ensure_current_is_visible
	Advanced(self).EnsureCurrentIsVisible()
}

/*
Returns the vertical scrollbar.
[b]Warning:[/b] This is a required internal node, removing and freeing it may cause a crash. If you wish to hide it or any of its children, use their [member CanvasItem.visible] property.
*/
func (self Instance) GetVScrollBar() VScrollBar.Instance { //gd:ItemList.get_v_scroll_bar
	return VScrollBar.Instance(Advanced(self).GetVScrollBar())
}

/*
Returns the horizontal scrollbar.
[b]Warning:[/b] This is a required internal node, removing and freeing it may cause a crash. If you wish to hide it or any of its children, use their [member CanvasItem.visible] property.
*/
func (self Instance) GetHScrollBar() HScrollBar.Instance { //gd:ItemList.get_h_scroll_bar
	return HScrollBar.Instance(Advanced(self).GetHScrollBar())
}

/*
Forces an update to the list size based on its items. This happens automatically whenever size of the items, or other relevant settings like [member auto_height], change. The method can be used to trigger the update ahead of next drawing pass.
*/
func (self Instance) ForceUpdateListSize() { //gd:ItemList.force_update_list_size
	Advanced(self).ForceUpdateListSize()
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.ItemList

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.ItemList)(unsafe.Pointer(&obj))
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.ItemList)(unsafe.Pointer(&obj))
		return true
	}
	return false
}

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {
	object := [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})}
	casted := Instance{*(*gdclass.ItemList)(unsafe.Pointer(&object))}
	object[0].Notification(0, false)
	return casted
}

func (self Instance) SelectMode() SelectMode {
	return SelectMode(class(self).GetSelectMode())
}

func (self Instance) SetSelectMode(value SelectMode) {
	class(self).SetSelectMode(value)
}

func (self Instance) AllowReselect() bool {
	return bool(class(self).GetAllowReselect())
}

func (self Instance) SetAllowReselect(value bool) {
	class(self).SetAllowReselect(value)
}

func (self Instance) AllowRmbSelect() bool {
	return bool(class(self).GetAllowRmbSelect())
}

func (self Instance) SetAllowRmbSelect(value bool) {
	class(self).SetAllowRmbSelect(value)
}

func (self Instance) AllowSearch() bool {
	return bool(class(self).GetAllowSearch())
}

func (self Instance) SetAllowSearch(value bool) {
	class(self).SetAllowSearch(value)
}

func (self Instance) MaxTextLines() int {
	return int(int(class(self).GetMaxTextLines()))
}

func (self Instance) SetMaxTextLines(value int) {
	class(self).SetMaxTextLines(int64(value))
}

func (self Instance) AutoWidth() bool {
	return bool(class(self).HasAutoWidth())
}

func (self Instance) SetAutoWidth(value bool) {
	class(self).SetAutoWidth(value)
}

func (self Instance) AutoHeight() bool {
	return bool(class(self).HasAutoHeight())
}

func (self Instance) SetAutoHeight(value bool) {
	class(self).SetAutoHeight(value)
}

func (self Instance) TextOverrunBehavior() TextServer.OverrunBehavior {
	return TextServer.OverrunBehavior(class(self).GetTextOverrunBehavior())
}

func (self Instance) SetTextOverrunBehavior(value TextServer.OverrunBehavior) {
	class(self).SetTextOverrunBehavior(value)
}

func (self Instance) WraparoundItems() bool {
	return bool(class(self).HasWraparoundItems())
}

func (self Instance) SetWraparoundItems(value bool) {
	class(self).SetWraparoundItems(value)
}

func (self Instance) ItemCount() int {
	return int(int(class(self).GetItemCount()))
}

func (self Instance) SetItemCount(value int) {
	class(self).SetItemCount(int64(value))
}

func (self Instance) MaxColumns() int {
	return int(int(class(self).GetMaxColumns()))
}

func (self Instance) SetMaxColumns(value int) {
	class(self).SetMaxColumns(int64(value))
}

func (self Instance) SameColumnWidth() bool {
	return bool(class(self).IsSameColumnWidth())
}

func (self Instance) SetSameColumnWidth(value bool) {
	class(self).SetSameColumnWidth(value)
}

func (self Instance) FixedColumnWidth() int {
	return int(int(class(self).GetFixedColumnWidth()))
}

func (self Instance) SetFixedColumnWidth(value int) {
	class(self).SetFixedColumnWidth(int64(value))
}

func (self Instance) IconMode() IconMode {
	return IconMode(class(self).GetIconMode())
}

func (self Instance) SetIconMode(value IconMode) {
	class(self).SetIconMode(value)
}

func (self Instance) IconScale() Float.X {
	return Float.X(Float.X(class(self).GetIconScale()))
}

func (self Instance) SetIconScale(value Float.X) {
	class(self).SetIconScale(float64(value))
}

func (self Instance) FixedIconSize() Vector2i.XY {
	return Vector2i.XY(class(self).GetFixedIconSize())
}

func (self Instance) SetFixedIconSize(value Vector2i.XY) {
	class(self).SetFixedIconSize(Vector2i.XY(value))
}

/*
Adds an item to the item list with specified text. Returns the index of an added item.
Specify an [param icon], or use [code]null[/code] as the [param icon] for a list item with no icon.
If [param selectable] is [code]true[/code], the list item will be selectable.
*/
//go:nosplit
func (self class) AddItem(text String.Readable, icon [1]gdclass.Texture2D, selectable bool) int64 { //gd:ItemList.add_item
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.add_item, gdextension.SizeInt|(gdextension.SizeString<<4)|(gdextension.SizeObject<<8)|(gdextension.SizeBool<<12), unsafe.Pointer(&struct {
		text       gdextension.String
		icon       gdextension.Object
		selectable bool
	}{pointers.Get(gd.InternalString(text)), gdextension.Object(gd.ObjectChecked(icon[0].AsObject())), selectable}))
	var ret = r_ret
	return ret
}

/*
Adds an item to the item list with no text, only an icon. Returns the index of an added item.
*/
//go:nosplit
func (self class) AddIconItem(icon [1]gdclass.Texture2D, selectable bool) int64 { //gd:ItemList.add_icon_item
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.add_icon_item, gdextension.SizeInt|(gdextension.SizeObject<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		icon       gdextension.Object
		selectable bool
	}{gdextension.Object(gd.ObjectChecked(icon[0].AsObject())), selectable}))
	var ret = r_ret
	return ret
}

/*
Sets text of the item associated with the specified index.
*/
//go:nosplit
func (self class) SetItemText(idx int64, text String.Readable) { //gd:ItemList.set_item_text
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_text, 0|(gdextension.SizeInt<<4)|(gdextension.SizeString<<8), unsafe.Pointer(&struct {
		idx  int64
		text gdextension.String
	}{idx, pointers.Get(gd.InternalString(text))}))
}

/*
Returns the text associated with the specified index.
*/
//go:nosplit
func (self class) GetItemText(idx int64) String.Readable { //gd:ItemList.get_item_text
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_item_text, gdextension.SizeString|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ idx int64 }{idx}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Sets (or replaces) the icon's [Texture2D] associated with the specified index.
*/
//go:nosplit
func (self class) SetItemIcon(idx int64, icon [1]gdclass.Texture2D) { //gd:ItemList.set_item_icon
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_icon, 0|(gdextension.SizeInt<<4)|(gdextension.SizeObject<<8), unsafe.Pointer(&struct {
		idx  int64
		icon gdextension.Object
	}{idx, gdextension.Object(gd.ObjectChecked(icon[0].AsObject()))}))
}

/*
Returns the icon associated with the specified index.
*/
//go:nosplit
func (self class) GetItemIcon(idx int64) [1]gdclass.Texture2D { //gd:ItemList.get_item_icon
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_item_icon, gdextension.SizeObject|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ idx int64 }{idx}))
	var ret = [1]gdclass.Texture2D{gd.PointerWithOwnershipTransferredToGo[gdclass.Texture2D](r_ret)}
	return ret
}

/*
Sets item's text base writing direction.
*/
//go:nosplit
func (self class) SetItemTextDirection(idx int64, direction Control.TextDirection) { //gd:ItemList.set_item_text_direction
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_text_direction, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		idx       int64
		direction Control.TextDirection
	}{idx, direction}))
}

/*
Returns item's text base writing direction.
*/
//go:nosplit
func (self class) GetItemTextDirection(idx int64) Control.TextDirection { //gd:ItemList.get_item_text_direction
	var r_ret = gdextension.Call[Control.TextDirection](gd.ObjectChecked(self.AsObject()), methods.get_item_text_direction, gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ idx int64 }{idx}))
	var ret = r_ret
	return ret
}

/*
Sets language code of item's text used for line-breaking and text shaping algorithms, if left empty current locale is used instead.
*/
//go:nosplit
func (self class) SetItemLanguage(idx int64, language String.Readable) { //gd:ItemList.set_item_language
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_language, 0|(gdextension.SizeInt<<4)|(gdextension.SizeString<<8), unsafe.Pointer(&struct {
		idx      int64
		language gdextension.String
	}{idx, pointers.Get(gd.InternalString(language))}))
}

/*
Returns item's text language code.
*/
//go:nosplit
func (self class) GetItemLanguage(idx int64) String.Readable { //gd:ItemList.get_item_language
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_item_language, gdextension.SizeString|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ idx int64 }{idx}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Sets the auto translate mode of the item associated with the specified index.
Items use [constant Node.AUTO_TRANSLATE_MODE_INHERIT] by default, which uses the same auto translate mode as the [ItemList] itself.
*/
//go:nosplit
func (self class) SetItemAutoTranslateMode(idx int64, mode Node.AutoTranslateMode) { //gd:ItemList.set_item_auto_translate_mode
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_auto_translate_mode, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		idx  int64
		mode Node.AutoTranslateMode
	}{idx, mode}))
}

/*
Returns item's auto translate mode.
*/
//go:nosplit
func (self class) GetItemAutoTranslateMode(idx int64) Node.AutoTranslateMode { //gd:ItemList.get_item_auto_translate_mode
	var r_ret = gdextension.Call[Node.AutoTranslateMode](gd.ObjectChecked(self.AsObject()), methods.get_item_auto_translate_mode, gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ idx int64 }{idx}))
	var ret = r_ret
	return ret
}

/*
Sets whether the item icon will be drawn transposed.
*/
//go:nosplit
func (self class) SetItemIconTransposed(idx int64, transposed bool) { //gd:ItemList.set_item_icon_transposed
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_icon_transposed, 0|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		idx        int64
		transposed bool
	}{idx, transposed}))
}

/*
Returns [code]true[/code] if the item icon will be drawn transposed, i.e. the X and Y axes are swapped.
*/
//go:nosplit
func (self class) IsItemIconTransposed(idx int64) bool { //gd:ItemList.is_item_icon_transposed
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_item_icon_transposed, gdextension.SizeBool|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ idx int64 }{idx}))
	var ret = r_ret
	return ret
}

/*
Sets the region of item's icon used. The whole icon will be used if the region has no area.
*/
//go:nosplit
func (self class) SetItemIconRegion(idx int64, rect Rect2.PositionSize) { //gd:ItemList.set_item_icon_region
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_icon_region, 0|(gdextension.SizeInt<<4)|(gdextension.SizeRect2<<8), unsafe.Pointer(&struct {
		idx  int64
		rect Rect2.PositionSize
	}{idx, rect}))
}

/*
Returns the region of item's icon used. The whole icon will be used if the region has no area.
*/
//go:nosplit
func (self class) GetItemIconRegion(idx int64) Rect2.PositionSize { //gd:ItemList.get_item_icon_region
	var r_ret = gdextension.Call[Rect2.PositionSize](gd.ObjectChecked(self.AsObject()), methods.get_item_icon_region, gdextension.SizeRect2|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ idx int64 }{idx}))
	var ret = r_ret
	return ret
}

/*
Sets a modulating [Color] of the item associated with the specified index.
*/
//go:nosplit
func (self class) SetItemIconModulate(idx int64, modulate Color.RGBA) { //gd:ItemList.set_item_icon_modulate
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_icon_modulate, 0|(gdextension.SizeInt<<4)|(gdextension.SizeColor<<8), unsafe.Pointer(&struct {
		idx      int64
		modulate Color.RGBA
	}{idx, modulate}))
}

/*
Returns a [Color] modulating item's icon at the specified index.
*/
//go:nosplit
func (self class) GetItemIconModulate(idx int64) Color.RGBA { //gd:ItemList.get_item_icon_modulate
	var r_ret = gdextension.Call[Color.RGBA](gd.ObjectChecked(self.AsObject()), methods.get_item_icon_modulate, gdextension.SizeColor|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ idx int64 }{idx}))
	var ret = r_ret
	return ret
}

/*
Allows or disallows selection of the item associated with the specified index.
*/
//go:nosplit
func (self class) SetItemSelectable(idx int64, selectable bool) { //gd:ItemList.set_item_selectable
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_selectable, 0|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		idx        int64
		selectable bool
	}{idx, selectable}))
}

/*
Returns [code]true[/code] if the item at the specified index is selectable.
*/
//go:nosplit
func (self class) IsItemSelectable(idx int64) bool { //gd:ItemList.is_item_selectable
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_item_selectable, gdextension.SizeBool|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ idx int64 }{idx}))
	var ret = r_ret
	return ret
}

/*
Disables (or enables) the item at the specified index.
Disabled items cannot be selected and do not trigger activation signals (when double-clicking or pressing [kbd]Enter[/kbd]).
*/
//go:nosplit
func (self class) SetItemDisabled(idx int64, disabled bool) { //gd:ItemList.set_item_disabled
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_disabled, 0|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		idx      int64
		disabled bool
	}{idx, disabled}))
}

/*
Returns [code]true[/code] if the item at the specified index is disabled.
*/
//go:nosplit
func (self class) IsItemDisabled(idx int64) bool { //gd:ItemList.is_item_disabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_item_disabled, gdextension.SizeBool|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ idx int64 }{idx}))
	var ret = r_ret
	return ret
}

/*
Sets a value (of any type) to be stored with the item associated with the specified index.
*/
//go:nosplit
func (self class) SetItemMetadata(idx int64, metadata variant.Any) { //gd:ItemList.set_item_metadata
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_metadata, 0|(gdextension.SizeInt<<4)|(gdextension.SizeVariant<<8), unsafe.Pointer(&struct {
		idx      int64
		metadata gdextension.Variant
	}{idx, gdextension.Variant(pointers.Get(gd.InternalVariant(metadata)))}))
}

/*
Returns the metadata value of the specified index.
*/
//go:nosplit
func (self class) GetItemMetadata(idx int64) variant.Any { //gd:ItemList.get_item_metadata
	var r_ret = gdextension.Call[gdextension.Variant](gd.ObjectChecked(self.AsObject()), methods.get_item_metadata, gdextension.SizeVariant|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ idx int64 }{idx}))
	var ret = variant.Implementation(gd.VariantProxy{}, pointers.Pack(pointers.New[gd.Variant](r_ret)))
	return ret
}

/*
Sets the background color of the item specified by [param idx] index to the specified [Color].
*/
//go:nosplit
func (self class) SetItemCustomBgColor(idx int64, custom_bg_color Color.RGBA) { //gd:ItemList.set_item_custom_bg_color
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_custom_bg_color, 0|(gdextension.SizeInt<<4)|(gdextension.SizeColor<<8), unsafe.Pointer(&struct {
		idx             int64
		custom_bg_color Color.RGBA
	}{idx, custom_bg_color}))
}

/*
Returns the custom background color of the item specified by [param idx] index.
*/
//go:nosplit
func (self class) GetItemCustomBgColor(idx int64) Color.RGBA { //gd:ItemList.get_item_custom_bg_color
	var r_ret = gdextension.Call[Color.RGBA](gd.ObjectChecked(self.AsObject()), methods.get_item_custom_bg_color, gdextension.SizeColor|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ idx int64 }{idx}))
	var ret = r_ret
	return ret
}

/*
Sets the foreground color of the item specified by [param idx] index to the specified [Color].
*/
//go:nosplit
func (self class) SetItemCustomFgColor(idx int64, custom_fg_color Color.RGBA) { //gd:ItemList.set_item_custom_fg_color
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_custom_fg_color, 0|(gdextension.SizeInt<<4)|(gdextension.SizeColor<<8), unsafe.Pointer(&struct {
		idx             int64
		custom_fg_color Color.RGBA
	}{idx, custom_fg_color}))
}

/*
Returns the custom foreground color of the item specified by [param idx] index.
*/
//go:nosplit
func (self class) GetItemCustomFgColor(idx int64) Color.RGBA { //gd:ItemList.get_item_custom_fg_color
	var r_ret = gdextension.Call[Color.RGBA](gd.ObjectChecked(self.AsObject()), methods.get_item_custom_fg_color, gdextension.SizeColor|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ idx int64 }{idx}))
	var ret = r_ret
	return ret
}

/*
Returns the position and size of the item with the specified index, in the coordinate system of the [ItemList] node. If [param expand] is [code]true[/code] the last column expands to fill the rest of the row.
[b]Note:[/b] The returned value is unreliable if called right after modifying the [ItemList], before it redraws in the next frame.
*/
//go:nosplit
func (self class) GetItemRect(idx int64, expand bool) Rect2.PositionSize { //gd:ItemList.get_item_rect
	var r_ret = gdextension.Call[Rect2.PositionSize](gd.ObjectChecked(self.AsObject()), methods.get_item_rect, gdextension.SizeRect2|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		idx    int64
		expand bool
	}{idx, expand}))
	var ret = r_ret
	return ret
}

/*
Sets whether the tooltip hint is enabled for specified item index.
*/
//go:nosplit
func (self class) SetItemTooltipEnabled(idx int64, enable bool) { //gd:ItemList.set_item_tooltip_enabled
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_tooltip_enabled, 0|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		idx    int64
		enable bool
	}{idx, enable}))
}

/*
Returns [code]true[/code] if the tooltip is enabled for specified item index.
*/
//go:nosplit
func (self class) IsItemTooltipEnabled(idx int64) bool { //gd:ItemList.is_item_tooltip_enabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_item_tooltip_enabled, gdextension.SizeBool|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ idx int64 }{idx}))
	var ret = r_ret
	return ret
}

/*
Sets the tooltip hint for the item associated with the specified index.
*/
//go:nosplit
func (self class) SetItemTooltip(idx int64, tooltip String.Readable) { //gd:ItemList.set_item_tooltip
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_tooltip, 0|(gdextension.SizeInt<<4)|(gdextension.SizeString<<8), unsafe.Pointer(&struct {
		idx     int64
		tooltip gdextension.String
	}{idx, pointers.Get(gd.InternalString(tooltip))}))
}

/*
Returns the tooltip hint associated with the specified index.
*/
//go:nosplit
func (self class) GetItemTooltip(idx int64) String.Readable { //gd:ItemList.get_item_tooltip
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_item_tooltip, gdextension.SizeString|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ idx int64 }{idx}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Select the item at the specified index.
[b]Note:[/b] This method does not trigger the item selection signal.
*/
//go:nosplit
func (self class) Select(idx int64, single bool) { //gd:ItemList.select_
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.select_, 0|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		idx    int64
		single bool
	}{idx, single}))
}

/*
Ensures the item associated with the specified index is not selected.
*/
//go:nosplit
func (self class) Deselect(idx int64) { //gd:ItemList.deselect
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.deselect, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ idx int64 }{idx}))
}

/*
Ensures there are no items selected.
*/
//go:nosplit
func (self class) DeselectAll() { //gd:ItemList.deselect_all
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.deselect_all, 0, unsafe.Pointer(&struct{}{}))
}

/*
Returns [code]true[/code] if the item at the specified index is currently selected.
*/
//go:nosplit
func (self class) IsSelected(idx int64) bool { //gd:ItemList.is_selected
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_selected, gdextension.SizeBool|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ idx int64 }{idx}))
	var ret = r_ret
	return ret
}

/*
Returns an array with the indexes of the selected items.
*/
//go:nosplit
func (self class) GetSelectedItems() Packed.Array[int32] { //gd:ItemList.get_selected_items
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.get_selected_items, gdextension.SizePackedArray, unsafe.Pointer(&struct{}{}))
	var ret = Packed.Array[int32](Array.Through(gd.PackedProxy[gd.PackedInt32Array, int32]{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

/*
Moves item from index [param from_idx] to [param to_idx].
*/
//go:nosplit
func (self class) MoveItem(from_idx int64, to_idx int64) { //gd:ItemList.move_item
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.move_item, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		from_idx int64
		to_idx   int64
	}{from_idx, to_idx}))
}

//go:nosplit
func (self class) SetItemCount(count int64) { //gd:ItemList.set_item_count
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_item_count, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ count int64 }{count}))
}

//go:nosplit
func (self class) GetItemCount() int64 { //gd:ItemList.get_item_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_item_count, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Removes the item specified by [param idx] index from the list.
*/
//go:nosplit
func (self class) RemoveItem(idx int64) { //gd:ItemList.remove_item
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.remove_item, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ idx int64 }{idx}))
}

/*
Removes all items from the list.
*/
//go:nosplit
func (self class) Clear() { //gd:ItemList.clear
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.clear, 0, unsafe.Pointer(&struct{}{}))
}

/*
Sorts items in the list by their text.
*/
//go:nosplit
func (self class) SortItemsByText() { //gd:ItemList.sort_items_by_text
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.sort_items_by_text, 0, unsafe.Pointer(&struct{}{}))
}

//go:nosplit
func (self class) SetFixedColumnWidth(width int64) { //gd:ItemList.set_fixed_column_width
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_fixed_column_width, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ width int64 }{width}))
}

//go:nosplit
func (self class) GetFixedColumnWidth() int64 { //gd:ItemList.get_fixed_column_width
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_fixed_column_width, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetSameColumnWidth(enable bool) { //gd:ItemList.set_same_column_width
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_same_column_width, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

//go:nosplit
func (self class) IsSameColumnWidth() bool { //gd:ItemList.is_same_column_width
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_same_column_width, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetMaxTextLines(lines int64) { //gd:ItemList.set_max_text_lines
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_max_text_lines, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ lines int64 }{lines}))
}

//go:nosplit
func (self class) GetMaxTextLines() int64 { //gd:ItemList.get_max_text_lines
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_max_text_lines, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetMaxColumns(amount int64) { //gd:ItemList.set_max_columns
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_max_columns, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ amount int64 }{amount}))
}

//go:nosplit
func (self class) GetMaxColumns() int64 { //gd:ItemList.get_max_columns
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_max_columns, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetSelectMode(mode SelectMode) { //gd:ItemList.set_select_mode
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_select_mode, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ mode SelectMode }{mode}))
}

//go:nosplit
func (self class) GetSelectMode() SelectMode { //gd:ItemList.get_select_mode
	var r_ret = gdextension.Call[SelectMode](gd.ObjectChecked(self.AsObject()), methods.get_select_mode, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetIconMode(mode IconMode) { //gd:ItemList.set_icon_mode
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_icon_mode, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ mode IconMode }{mode}))
}

//go:nosplit
func (self class) GetIconMode() IconMode { //gd:ItemList.get_icon_mode
	var r_ret = gdextension.Call[IconMode](gd.ObjectChecked(self.AsObject()), methods.get_icon_mode, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetFixedIconSize(size Vector2i.XY) { //gd:ItemList.set_fixed_icon_size
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_fixed_icon_size, 0|(gdextension.SizeVector2i<<4), unsafe.Pointer(&struct{ size Vector2i.XY }{size}))
}

//go:nosplit
func (self class) GetFixedIconSize() Vector2i.XY { //gd:ItemList.get_fixed_icon_size
	var r_ret = gdextension.Call[Vector2i.XY](gd.ObjectChecked(self.AsObject()), methods.get_fixed_icon_size, gdextension.SizeVector2i, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetIconScale(scale float64) { //gd:ItemList.set_icon_scale
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_icon_scale, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ scale float64 }{scale}))
}

//go:nosplit
func (self class) GetIconScale() float64 { //gd:ItemList.get_icon_scale
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_icon_scale, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetAllowRmbSelect(allow bool) { //gd:ItemList.set_allow_rmb_select
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_allow_rmb_select, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ allow bool }{allow}))
}

//go:nosplit
func (self class) GetAllowRmbSelect() bool { //gd:ItemList.get_allow_rmb_select
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.get_allow_rmb_select, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetAllowReselect(allow bool) { //gd:ItemList.set_allow_reselect
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_allow_reselect, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ allow bool }{allow}))
}

//go:nosplit
func (self class) GetAllowReselect() bool { //gd:ItemList.get_allow_reselect
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.get_allow_reselect, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetAllowSearch(allow bool) { //gd:ItemList.set_allow_search
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_allow_search, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ allow bool }{allow}))
}

//go:nosplit
func (self class) GetAllowSearch() bool { //gd:ItemList.get_allow_search
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.get_allow_search, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetAutoWidth(enable bool) { //gd:ItemList.set_auto_width
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_auto_width, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

//go:nosplit
func (self class) HasAutoWidth() bool { //gd:ItemList.has_auto_width
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.has_auto_width, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetAutoHeight(enable bool) { //gd:ItemList.set_auto_height
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_auto_height, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

//go:nosplit
func (self class) HasAutoHeight() bool { //gd:ItemList.has_auto_height
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.has_auto_height, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if one or more items are selected.
*/
//go:nosplit
func (self class) IsAnythingSelected() bool { //gd:ItemList.is_anything_selected
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_anything_selected, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the item index at the given [param position].
When there is no item at that point, -1 will be returned if [param exact] is [code]true[/code], and the closest item index will be returned otherwise.
[b]Note:[/b] The returned value is unreliable if called right after modifying the [ItemList], before it redraws in the next frame.
*/
//go:nosplit
func (self class) GetItemAtPosition(position Vector2.XY, exact bool) int64 { //gd:ItemList.get_item_at_position
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_item_at_position, gdextension.SizeInt|(gdextension.SizeVector2<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		position Vector2.XY
		exact    bool
	}{position, exact}))
	var ret = r_ret
	return ret
}

/*
Ensure current selection is visible, adjusting the scroll position as necessary.
*/
//go:nosplit
func (self class) EnsureCurrentIsVisible() { //gd:ItemList.ensure_current_is_visible
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.ensure_current_is_visible, 0, unsafe.Pointer(&struct{}{}))
}

/*
Returns the vertical scrollbar.
[b]Warning:[/b] This is a required internal node, removing and freeing it may cause a crash. If you wish to hide it or any of its children, use their [member CanvasItem.visible] property.
*/
//go:nosplit
func (self class) GetVScrollBar() [1]gdclass.VScrollBar { //gd:ItemList.get_v_scroll_bar
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_v_scroll_bar, gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.VScrollBar{gd.PointerLifetimeBoundTo[gdclass.VScrollBar](self.AsObject(), r_ret)}
	return ret
}

/*
Returns the horizontal scrollbar.
[b]Warning:[/b] This is a required internal node, removing and freeing it may cause a crash. If you wish to hide it or any of its children, use their [member CanvasItem.visible] property.
*/
//go:nosplit
func (self class) GetHScrollBar() [1]gdclass.HScrollBar { //gd:ItemList.get_h_scroll_bar
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_h_scroll_bar, gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.HScrollBar{gd.PointerLifetimeBoundTo[gdclass.HScrollBar](self.AsObject(), r_ret)}
	return ret
}

//go:nosplit
func (self class) SetTextOverrunBehavior(overrun_behavior TextServer.OverrunBehavior) { //gd:ItemList.set_text_overrun_behavior
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_text_overrun_behavior, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ overrun_behavior TextServer.OverrunBehavior }{overrun_behavior}))
}

//go:nosplit
func (self class) GetTextOverrunBehavior() TextServer.OverrunBehavior { //gd:ItemList.get_text_overrun_behavior
	var r_ret = gdextension.Call[TextServer.OverrunBehavior](gd.ObjectChecked(self.AsObject()), methods.get_text_overrun_behavior, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetWraparoundItems(enable bool) { //gd:ItemList.set_wraparound_items
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_wraparound_items, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

//go:nosplit
func (self class) HasWraparoundItems() bool { //gd:ItemList.has_wraparound_items
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.has_wraparound_items, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Forces an update to the list size based on its items. This happens automatically whenever size of the items, or other relevant settings like [member auto_height], change. The method can be used to trigger the update ahead of next drawing pass.
*/
//go:nosplit
func (self class) ForceUpdateListSize() { //gd:ItemList.force_update_list_size
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.force_update_list_size, 0, unsafe.Pointer(&struct{}{}))
}
func (self Instance) OnItemSelected(cb func(index int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("item_selected"), gd.NewCallable(cb), 0)
}

func (self Instance) OnEmptyClicked(cb func(at_position Vector2.XY, mouse_button_index int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("empty_clicked"), gd.NewCallable(cb), 0)
}

func (self Instance) OnItemClicked(cb func(index int, at_position Vector2.XY, mouse_button_index int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("item_clicked"), gd.NewCallable(cb), 0)
}

func (self Instance) OnMultiSelected(cb func(index int, selected bool)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("multi_selected"), gd.NewCallable(cb), 0)
}

func (self Instance) OnItemActivated(cb func(index int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("item_activated"), gd.NewCallable(cb), 0)
}

func (self class) AsItemList() Advanced                { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsItemList() Instance             { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsItemList() Instance        { return self.Super().AsItemList() }
func (self class) AsControl() Control.Advanced         { return *((*Control.Advanced)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsControl() Control.Instance { return self.Super().AsControl() }
func (self Instance) AsControl() Control.Instance {
	return *((*Control.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsCanvasItem() CanvasItem.Advanced {
	return *((*CanvasItem.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsCanvasItem() CanvasItem.Instance { return self.Super().AsCanvasItem() }
func (self Instance) AsCanvasItem() CanvasItem.Instance {
	return *((*CanvasItem.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsNode() Node.Advanced         { return *((*Node.Advanced)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsNode() Node.Instance { return self.Super().AsNode() }
func (self Instance) AsNode() Node.Instance      { return *((*Node.Instance)(unsafe.Pointer(&self))) }

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Control.Advanced(self.AsControl()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Control.Instance(self.AsControl()), name)
	}
}
func init() {
	gdclass.Register("ItemList", func(ptr gd.Object) any { return *(*Instance)(unsafe.Pointer(&ptr)) })
}

type IconMode int //gd:ItemList.IconMode

const (
	/*Icon is drawn above the text.*/
	IconModeTop IconMode = 0
	/*Icon is drawn to the left of the text.*/
	IconModeLeft IconMode = 1
)

type SelectMode int //gd:ItemList.SelectMode

const (
	/*Only allow selecting a single item.*/
	SelectSingle SelectMode = 0
	/*Allows selecting multiple items by holding [kbd]Ctrl[/kbd] or [kbd]Shift[/kbd].*/
	SelectMulti SelectMode = 1
	/*Allows selecting multiple items by toggling them on and off.*/
	SelectToggle SelectMode = 2
)
