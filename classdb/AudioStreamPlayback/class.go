// Code generated by the generate package DO NOT EDIT

// Package AudioStreamPlayback provides methods for working with AudioStreamPlayback object instances.
package AudioStreamPlayback

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/AudioSamplePlayback"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"
import "graphics.gd/variant/Vector2"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
Can play, loop, pause a scroll through audio. See [AudioStream] and [AudioStreamOggVorbis] for usage.

	See [Interface] for methods that can be overridden by a [Class] that extends it.
*/
type Instance [1]gdclass.AudioStreamPlayback

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	set_sample_playback   gdextension.MethodForClass `hash:"3195455091"`
	get_sample_playback   gdextension.MethodForClass `hash:"3482738536"`
	mix_audio             gdextension.MethodForClass `hash:"3341291446"`
	start                 gdextension.MethodForClass `hash:"1958160172"`
	seek                  gdextension.MethodForClass `hash:"1958160172"`
	stop                  gdextension.MethodForClass `hash:"3218959716"`
	get_loop_count        gdextension.MethodForClass `hash:"3905245786"`
	get_playback_position gdextension.MethodForClass `hash:"1740695150"`
	is_playing            gdextension.MethodForClass `hash:"36873697"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("AudioStreamPlayback")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		pointers.Raw[gd.StringName](sname).Free()
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

type Expanded [1]gdclass.AudioStreamPlayback

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsAudioStreamPlayback() Instance
}
type Interface interface {
	//Override this method to customize what happens when the playback starts at the given position, such as by calling [method AudioStreamPlayer.play].
	Start(from_pos Float.X)
	//Override this method to customize what happens when the playback is stopped, such as by calling [method AudioStreamPlayer.stop].
	Stop()
	//Overridable method. Should return [code]true[/code] if this playback is active and playing its audio stream.
	IsPlaying() bool
	//Overridable method. Should return how many times this audio stream has looped. Most built-in playbacks always return [code]0[/code].
	GetLoopCount() int
	//Overridable method. Should return the current progress along the audio stream, in seconds.
	GetPlaybackPosition() Float.X
	//Override this method to customize what happens when seeking this audio stream at the given [param position], such as by calling [method AudioStreamPlayer.seek].
	Seek(position Float.X)
	//Override this method to customize how the audio stream is mixed. This method is called even if the playback is not active.
	//[b]Note:[/b] It is not useful to override this method in GDScript or C#. Only GDExtension can take advantage of it.
	Mix(buffer *AudioFrame, rate_scale Float.X, frames int) int
	//Overridable method. Called whenever the audio stream is mixed if the playback is active and [method AudioServer.set_enable_tagging_used_audio_streams] has been set to [code]true[/code]. Editor plugins may use this method to "tag" the current position along the audio stream and display it in a preview.
	TagUsedStreams()
	//Set the current value of a playback parameter by name (see [method AudioStream._get_parameter_list]).
	SetParameter(name string, value any)
	//Return the current value of a playback parameter by name (see [method AudioStream._get_parameter_list]).
	GetParameter(name string) any
}

// Implementation implements [Interface] with empty methods.
type Implementation = implementation

type implementation struct{}

func (self implementation) Start(from_pos Float.X)                                         { return }
func (self implementation) Stop()                                                          { return }
func (self implementation) IsPlaying() (_ bool)                                            { return }
func (self implementation) GetLoopCount() (_ int)                                          { return }
func (self implementation) GetPlaybackPosition() (_ Float.X)                               { return }
func (self implementation) Seek(position Float.X)                                          { return }
func (self implementation) Mix(buffer *AudioFrame, rate_scale Float.X, frames int) (_ int) { return }
func (self implementation) TagUsedStreams()                                                { return }
func (self implementation) SetParameter(name string, value any)                            { return }
func (self implementation) GetParameter(name string) (_ any)                               { return }

/*
Override this method to customize what happens when the playback starts at the given position, such as by calling [method AudioStreamPlayer.play].
*/
func (Instance) _start(impl func(ptr unsafe.Pointer, from_pos Float.X)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var from_pos = gd.UnsafeGet[float64](p_args, 0)
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, Float.X(from_pos))
	}
}

/*
Override this method to customize what happens when the playback is stopped, such as by calling [method AudioStreamPlayer.stop].
*/
func (Instance) _stop(impl func(ptr unsafe.Pointer)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self)
	}
}

/*
Overridable method. Should return [code]true[/code] if this playback is active and playing its audio stream.
*/
func (Instance) _is_playing(impl func(ptr unsafe.Pointer) bool) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		gd.UnsafeSet(p_back, ret)
	}
}

/*
Overridable method. Should return how many times this audio stream has looped. Most built-in playbacks always return [code]0[/code].
*/
func (Instance) _get_loop_count(impl func(ptr unsafe.Pointer) int) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		gd.UnsafeSet(p_back, int64(ret))
	}
}

/*
Overridable method. Should return the current progress along the audio stream, in seconds.
*/
func (Instance) _get_playback_position(impl func(ptr unsafe.Pointer) Float.X) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		gd.UnsafeSet(p_back, float64(ret))
	}
}

/*
Override this method to customize what happens when seeking this audio stream at the given [param position], such as by calling [method AudioStreamPlayer.seek].
*/
func (Instance) _seek(impl func(ptr unsafe.Pointer, position Float.X)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var position = gd.UnsafeGet[float64](p_args, 0)
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, Float.X(position))
	}
}

/*
Override this method to customize how the audio stream is mixed. This method is called even if the playback is not active.
[b]Note:[/b] It is not useful to override this method in GDScript or C#. Only GDExtension can take advantage of it.
*/
func (Instance) _mix(impl func(ptr unsafe.Pointer, buffer *AudioFrame, rate_scale Float.X, frames int) int) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var buffer = gd.UnsafeGet[*AudioFrame](p_args, 0)
		var rate_scale = gd.UnsafeGet[float64](p_args, 1)
		var frames = gd.UnsafeGet[int64](p_args, 2)
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self, buffer, Float.X(rate_scale), int(frames))
		gd.UnsafeSet(p_back, int64(ret))
	}
}

/*
Overridable method. Called whenever the audio stream is mixed if the playback is active and [method AudioServer.set_enable_tagging_used_audio_streams] has been set to [code]true[/code]. Editor plugins may use this method to "tag" the current position along the audio stream and display it in a preview.
*/
func (Instance) _tag_used_streams(impl func(ptr unsafe.Pointer)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self)
	}
}

/*
Set the current value of a playback parameter by name (see [method AudioStream._get_parameter_list]).
*/
func (Instance) _set_parameter(impl func(ptr unsafe.Pointer, name string, value any)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var name = String.Name(String.Via(gd.StringNameProxy{}, pointers.Pack(pointers.New[gd.StringName](gd.UnsafeGet[gdextension.StringName](p_args, 0)))))
		defer pointers.End(gd.InternalStringName(name))
		var value = variant.Implementation(gd.VariantProxy{}, pointers.Pack(pointers.New[gd.Variant](gd.UnsafeGet[gdextension.Variant](p_args, 1))))
		defer pointers.End(gd.InternalVariant(value))
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, name.String(), value.Interface())
	}
}

/*
Return the current value of a playback parameter by name (see [method AudioStream._get_parameter_list]).
*/
func (Instance) _get_parameter(impl func(ptr unsafe.Pointer, name string) any) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var name = String.Name(String.Via(gd.StringNameProxy{}, pointers.Pack(pointers.New[gd.StringName](gd.UnsafeGet[gdextension.StringName](p_args, 0)))))
		defer pointers.End(gd.InternalStringName(name))
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self, name.String())
		ptr, ok := pointers.End(gd.InternalVariant(variant.New(ret)))

		if !ok {
			return
		}
		gd.UnsafeSet(p_back, ptr)
	}
}

/*
Associates [AudioSamplePlayback] to this [AudioStreamPlayback] for playing back the audio sample of this stream.
*/
func (self Instance) SetSamplePlayback(playback_sample AudioSamplePlayback.Instance) { //gd:AudioStreamPlayback.set_sample_playback
	Advanced(self).SetSamplePlayback(playback_sample)
}

/*
Returns the [AudioSamplePlayback] associated with this [AudioStreamPlayback] for playing back the audio sample of this stream.
*/
func (self Instance) GetSamplePlayback() AudioSamplePlayback.Instance { //gd:AudioStreamPlayback.get_sample_playback
	return AudioSamplePlayback.Instance(Advanced(self).GetSamplePlayback())
}

/*
Mixes up to [param frames] of audio from the stream from the current position, at a rate of [param rate_scale], advancing the stream.
Returns a [PackedVector2Array] where each element holds the left and right channel volume levels of each frame.
[b]Note:[/b] Can return fewer frames than requested, make sure to use the size of the return value.
*/
func (self Instance) MixAudio(rate_scale Float.X, frames int) []Vector2.XY { //gd:AudioStreamPlayback.mix_audio
	return []Vector2.XY(slices.Collect(Advanced(self).MixAudio(float64(rate_scale), int64(frames)).Values()))
}

/*
Starts the stream from the given [param from_pos], in seconds.
*/
func (self Instance) Start() { //gd:AudioStreamPlayback.start
	Advanced(self).Start(float64(0.0))
}

/*
Starts the stream from the given [param from_pos], in seconds.
*/
func (self Expanded) Start(from_pos Float.X) { //gd:AudioStreamPlayback.start
	Advanced(self).Start(float64(from_pos))
}

/*
Seeks the stream at the given [param time], in seconds.
*/
func (self Instance) SeekTo() { //gd:AudioStreamPlayback.seek
	Advanced(self).SeekTo(float64(0.0))
}

/*
Seeks the stream at the given [param time], in seconds.
*/
func (self Expanded) SeekTo(time Float.X) { //gd:AudioStreamPlayback.seek
	Advanced(self).SeekTo(float64(time))
}

/*
Stops the stream.
*/
func (self Instance) Stop() { //gd:AudioStreamPlayback.stop
	Advanced(self).Stop()
}

/*
Returns the number of times the stream has looped.
*/
func (self Instance) GetLoopCount() int { //gd:AudioStreamPlayback.get_loop_count
	return int(int(Advanced(self).GetLoopCount()))
}

/*
Returns the current position in the stream, in seconds.
*/
func (self Instance) GetPlaybackPosition() Float.X { //gd:AudioStreamPlayback.get_playback_position
	return Float.X(Float.X(Advanced(self).GetPlaybackPosition()))
}

/*
Returns [code]true[/code] if the stream is playing.
*/
func (self Instance) IsPlaying() bool { //gd:AudioStreamPlayback.is_playing
	return bool(Advanced(self).IsPlaying())
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.AudioStreamPlayback

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.AudioStreamPlayback)(unsafe.Pointer(&obj))
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.AudioStreamPlayback)(unsafe.Pointer(&obj))
		return true
	}
	return false
}

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {

	if !gd.Linked {
		var placeholder Instance
		*(*gd.Object)(unsafe.Pointer(&placeholder)) = pointers.Add[gd.Object]([3]uint64{})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(*(*gd.Object)(unsafe.Pointer(&placeholder)), raw)
				gd.RegisterCleanup(func() {
					gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
				})
			}
		})
		return placeholder
	}
	object := [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})}
	casted := Instance{*(*gdclass.AudioStreamPlayback)(unsafe.Pointer(&object))}
	casted.AsRefCounted()[0].Reference()
	object[0].Notification(0, false)
	return casted
}

/*
Override this method to customize what happens when the playback starts at the given position, such as by calling [method AudioStreamPlayer.play].
*/
func (class) _start(impl func(ptr unsafe.Pointer, from_pos float64)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var from_pos = gd.UnsafeGet[float64](p_args, 0)
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, from_pos)
	}
}

/*
Override this method to customize what happens when the playback is stopped, such as by calling [method AudioStreamPlayer.stop].
*/
func (class) _stop(impl func(ptr unsafe.Pointer)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self)
	}
}

/*
Overridable method. Should return [code]true[/code] if this playback is active and playing its audio stream.
*/
func (class) _is_playing(impl func(ptr unsafe.Pointer) bool) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		gd.UnsafeSet(p_back, ret)
	}
}

/*
Overridable method. Should return how many times this audio stream has looped. Most built-in playbacks always return [code]0[/code].
*/
func (class) _get_loop_count(impl func(ptr unsafe.Pointer) int64) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		gd.UnsafeSet(p_back, ret)
	}
}

/*
Overridable method. Should return the current progress along the audio stream, in seconds.
*/
func (class) _get_playback_position(impl func(ptr unsafe.Pointer) float64) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		gd.UnsafeSet(p_back, ret)
	}
}

/*
Override this method to customize what happens when seeking this audio stream at the given [param position], such as by calling [method AudioStreamPlayer.seek].
*/
func (class) _seek(impl func(ptr unsafe.Pointer, position float64)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var position = gd.UnsafeGet[float64](p_args, 0)
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, position)
	}
}

/*
Override this method to customize how the audio stream is mixed. This method is called even if the playback is not active.
[b]Note:[/b] It is not useful to override this method in GDScript or C#. Only GDExtension can take advantage of it.
*/
func (class) _mix(impl func(ptr unsafe.Pointer, buffer *AudioFrame, rate_scale float64, frames int64) int64) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var buffer = gd.UnsafeGet[*AudioFrame](p_args, 0)
		var rate_scale = gd.UnsafeGet[float64](p_args, 1)
		var frames = gd.UnsafeGet[int64](p_args, 2)
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self, buffer, rate_scale, frames)
		gd.UnsafeSet(p_back, ret)
	}
}

/*
Overridable method. Called whenever the audio stream is mixed if the playback is active and [method AudioServer.set_enable_tagging_used_audio_streams] has been set to [code]true[/code]. Editor plugins may use this method to "tag" the current position along the audio stream and display it in a preview.
*/
func (class) _tag_used_streams(impl func(ptr unsafe.Pointer)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self)
	}
}

/*
Set the current value of a playback parameter by name (see [method AudioStream._get_parameter_list]).
*/
func (class) _set_parameter(impl func(ptr unsafe.Pointer, name String.Name, value variant.Any)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var name = String.Name(String.Via(gd.StringNameProxy{}, pointers.Pack(pointers.New[gd.StringName](gd.UnsafeGet[gdextension.StringName](p_args, 0)))))
		defer pointers.End(gd.InternalStringName(name))
		var value = variant.Implementation(gd.VariantProxy{}, pointers.Pack(pointers.New[gd.Variant](gd.UnsafeGet[gdextension.Variant](p_args, 1))))
		defer pointers.End(gd.InternalVariant(value))
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, name, value)
	}
}

/*
Return the current value of a playback parameter by name (see [method AudioStream._get_parameter_list]).
*/
func (class) _get_parameter(impl func(ptr unsafe.Pointer, name String.Name) variant.Any) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var name = String.Name(String.Via(gd.StringNameProxy{}, pointers.Pack(pointers.New[gd.StringName](gd.UnsafeGet[gdextension.StringName](p_args, 0)))))
		defer pointers.End(gd.InternalStringName(name))
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self, name)
		ptr, ok := pointers.End(gd.InternalVariant(ret))

		if !ok {
			return
		}
		gd.UnsafeSet(p_back, ptr)
	}
}

/*
Associates [AudioSamplePlayback] to this [AudioStreamPlayback] for playing back the audio sample of this stream.
*/
//go:nosplit
func (self class) SetSamplePlayback(playback_sample [1]gdclass.AudioSamplePlayback) { //gd:AudioStreamPlayback.set_sample_playback
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_sample_playback, 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ playback_sample gdextension.Object }{gdextension.Object(gd.ObjectChecked(playback_sample[0].AsObject()))}))
}

/*
Returns the [AudioSamplePlayback] associated with this [AudioStreamPlayback] for playing back the audio sample of this stream.
*/
//go:nosplit
func (self class) GetSamplePlayback() [1]gdclass.AudioSamplePlayback { //gd:AudioStreamPlayback.get_sample_playback
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_sample_playback, gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.AudioSamplePlayback{gd.PointerWithOwnershipTransferredToGo[gdclass.AudioSamplePlayback](r_ret)}
	return ret
}

/*
Mixes up to [param frames] of audio from the stream from the current position, at a rate of [param rate_scale], advancing the stream.
Returns a [PackedVector2Array] where each element holds the left and right channel volume levels of each frame.
[b]Note:[/b] Can return fewer frames than requested, make sure to use the size of the return value.
*/
//go:nosplit
func (self class) MixAudio(rate_scale float64, frames int64) Packed.Array[Vector2.XY] { //gd:AudioStreamPlayback.mix_audio
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.mix_audio, gdextension.SizePackedArray|(gdextension.SizeFloat<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		rate_scale float64
		frames     int64
	}{rate_scale, frames}))
	var ret = Packed.Array[Vector2.XY](Array.Through(gd.PackedProxy[gd.PackedVector2Array, Vector2.XY]{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

/*
Starts the stream from the given [param from_pos], in seconds.
*/
//go:nosplit
func (self class) Start(from_pos float64) { //gd:AudioStreamPlayback.start
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.start, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ from_pos float64 }{from_pos}))
}

/*
Seeks the stream at the given [param time], in seconds.
*/
//go:nosplit
func (self class) SeekTo(time float64) { //gd:AudioStreamPlayback.seek
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.seek, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ time float64 }{time}))
}

/*
Stops the stream.
*/
//go:nosplit
func (self class) Stop() { //gd:AudioStreamPlayback.stop
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.stop, 0, unsafe.Pointer(&struct{}{}))
}

/*
Returns the number of times the stream has looped.
*/
//go:nosplit
func (self class) GetLoopCount() int64 { //gd:AudioStreamPlayback.get_loop_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_loop_count, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the current position in the stream, in seconds.
*/
//go:nosplit
func (self class) GetPlaybackPosition() float64 { //gd:AudioStreamPlayback.get_playback_position
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_playback_position, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if the stream is playing.
*/
//go:nosplit
func (self class) IsPlaying() bool { //gd:AudioStreamPlayback.is_playing
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_playing, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}
func (self class) AsAudioStreamPlayback() Advanced    { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsAudioStreamPlayback() Instance { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsAudioStreamPlayback() Instance {
	return self.Super().AsAudioStreamPlayback()
}
func (self class) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsRefCounted() [1]gd.RefCounted { return self.Super().AsRefCounted() }
func (self Instance) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	case "_start":
		return reflect.ValueOf(self._start)
	case "_stop":
		return reflect.ValueOf(self._stop)
	case "_is_playing":
		return reflect.ValueOf(self._is_playing)
	case "_get_loop_count":
		return reflect.ValueOf(self._get_loop_count)
	case "_get_playback_position":
		return reflect.ValueOf(self._get_playback_position)
	case "_seek":
		return reflect.ValueOf(self._seek)
	case "_mix":
		return reflect.ValueOf(self._mix)
	case "_tag_used_streams":
		return reflect.ValueOf(self._tag_used_streams)
	case "_set_parameter":
		return reflect.ValueOf(self._set_parameter)
	case "_get_parameter":
		return reflect.ValueOf(self._get_parameter)
	default:
		return gd.VirtualByName(RefCounted.Advanced(self.AsRefCounted()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	case "_start":
		return reflect.ValueOf(self._start)
	case "_stop":
		return reflect.ValueOf(self._stop)
	case "_is_playing":
		return reflect.ValueOf(self._is_playing)
	case "_get_loop_count":
		return reflect.ValueOf(self._get_loop_count)
	case "_get_playback_position":
		return reflect.ValueOf(self._get_playback_position)
	case "_seek":
		return reflect.ValueOf(self._seek)
	case "_mix":
		return reflect.ValueOf(self._mix)
	case "_tag_used_streams":
		return reflect.ValueOf(self._tag_used_streams)
	case "_set_parameter":
		return reflect.ValueOf(self._set_parameter)
	case "_get_parameter":
		return reflect.ValueOf(self._get_parameter)
	default:
		return gd.VirtualByName(RefCounted.Instance(self.AsRefCounted()), name)
	}
}
func init() {
	gdclass.Register("AudioStreamPlayback", func(ptr gd.Object) any { return *(*Instance)(unsafe.Pointer(&ptr)) })
}
