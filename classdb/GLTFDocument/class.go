// Code generated by the generate package DO NOT EDIT

// Package GLTFDocument provides methods for working with GLTFDocument object instances.
package GLTFDocument

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdunsafe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/GLTFDocumentExtension"
import "graphics.gd/classdb/GLTFObjectModelProperty"
import "graphics.gd/classdb/GLTFState"
import "graphics.gd/classdb/Node"
import "graphics.gd/classdb/Resource"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = gdunsafe.Use{}
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
GLTFDocument supports reading data from a glTF file, buffer, or Godot scene. This data can then be written to the filesystem, buffer, or used to create a Godot scene.
All of the data in a glTF scene is stored in the [GLTFState] class. GLTFDocument processes state objects, but does not contain any scene data itself. GLTFDocument has member variables to store export configuration settings such as the image format, but is otherwise stateless. Multiple scenes can be processed with the same settings using the same GLTFDocument object and different [GLTFState] objects.
GLTFDocument can be extended with arbitrary functionality by extending the [GLTFDocumentExtension] class and registering it with GLTFDocument via [method register_gltf_document_extension]. This allows for custom data to be imported and exported.
*/
type Instance [1]gdclass.GLTFDocument

func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

type Expanded [1]gdclass.GLTFDocument

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsGLTFDocument() Instance
}

/*
Takes a path to a glTF file and imports the data at that file path to the given [GLTFState] object through the [param state] parameter.
[b]Note:[/b] The [param base_path] tells [method append_from_file] where to find dependencies and can be empty.
*/
func (self Instance) AppendFromFile(path string, state GLTFState.Instance) error { //gd:GLTFDocument.append_from_file
	return error(gd.ToError(Advanced(self).AppendFromFile(String.New(path), state, int64(0), String.New(""))))
}

/*
Takes a path to a glTF file and imports the data at that file path to the given [GLTFState] object through the [param state] parameter.
[b]Note:[/b] The [param base_path] tells [method append_from_file] where to find dependencies and can be empty.
*/
func (self Expanded) AppendFromFile(path string, state GLTFState.Instance, flags int, base_path string) error { //gd:GLTFDocument.append_from_file
	return error(gd.ToError(Advanced(self).AppendFromFile(String.New(path), state, int64(flags), String.New(base_path))))
}

/*
Takes a [PackedByteArray] defining a glTF and imports the data to the given [GLTFState] object through the [param state] parameter.
[b]Note:[/b] The [param base_path] tells [method append_from_buffer] where to find dependencies and can be empty.
*/
func (self Instance) AppendFromBuffer(bytes []byte, base_path string, state GLTFState.Instance) error { //gd:GLTFDocument.append_from_buffer
	return error(gd.ToError(Advanced(self).AppendFromBuffer(Packed.Bytes(Packed.New(bytes...)), String.New(base_path), state, int64(0))))
}

/*
Takes a [PackedByteArray] defining a glTF and imports the data to the given [GLTFState] object through the [param state] parameter.
[b]Note:[/b] The [param base_path] tells [method append_from_buffer] where to find dependencies and can be empty.
*/
func (self Expanded) AppendFromBuffer(bytes []byte, base_path string, state GLTFState.Instance, flags int) error { //gd:GLTFDocument.append_from_buffer
	return error(gd.ToError(Advanced(self).AppendFromBuffer(Packed.Bytes(Packed.New(bytes...)), String.New(base_path), state, int64(flags))))
}

/*
Takes a Godot Engine scene node and exports it and its descendants to the given [GLTFState] object through the [param state] parameter.
*/
func (self Instance) AppendFromScene(node Node.Instance, state GLTFState.Instance) error { //gd:GLTFDocument.append_from_scene
	return error(gd.ToError(Advanced(self).AppendFromScene(node, state, int64(0))))
}

/*
Takes a Godot Engine scene node and exports it and its descendants to the given [GLTFState] object through the [param state] parameter.
*/
func (self Expanded) AppendFromScene(node Node.Instance, state GLTFState.Instance, flags int) error { //gd:GLTFDocument.append_from_scene
	return error(gd.ToError(Advanced(self).AppendFromScene(node, state, int64(flags))))
}

/*
Takes a [GLTFState] object through the [param state] parameter and returns a Godot Engine scene node.
The [param bake_fps] parameter overrides the bake_fps in [param state].
*/
func (self Instance) GenerateScene(state GLTFState.Instance) Node.Instance { //gd:GLTFDocument.generate_scene
	return Node.Instance(Advanced(self).GenerateScene(state, float64(30), false, true))
}

/*
Takes a [GLTFState] object through the [param state] parameter and returns a Godot Engine scene node.
The [param bake_fps] parameter overrides the bake_fps in [param state].
*/
func (self Expanded) GenerateScene(state GLTFState.Instance, bake_fps Float.X, trimming bool, remove_immutable_tracks bool) Node.Instance { //gd:GLTFDocument.generate_scene
	return Node.Instance(Advanced(self).GenerateScene(state, float64(bake_fps), trimming, remove_immutable_tracks))
}

/*
Takes a [GLTFState] object through the [param state] parameter and returns a glTF [PackedByteArray].
*/
func (self Instance) GenerateBuffer(state GLTFState.Instance) []byte { //gd:GLTFDocument.generate_buffer
	return []byte(Advanced(self).GenerateBuffer(state).Bytes())
}

/*
Takes a [GLTFState] object through the [param state] parameter and writes a glTF file to the filesystem.
[b]Note:[/b] The extension of the glTF file determines if it is a .glb binary file or a .gltf text file.
*/
func (self Instance) WriteToFilesystem(state GLTFState.Instance, path string) error { //gd:GLTFDocument.write_to_filesystem
	return error(gd.ToError(Advanced(self).WriteToFilesystem(state, String.New(path))))
}

/*
Determines a mapping between the given glTF Object Model [param json_pointer] and the corresponding Godot node path(s) in the generated Godot scene. The details of this mapping are returned in a [GLTFObjectModelProperty] object. Additional mappings can be supplied via the [method GLTFDocumentExtension._export_object_model_property] callback method.
*/
func ImportObjectModelProperty(state GLTFState.Instance, json_pointer string) GLTFObjectModelProperty.Instance { //gd:GLTFDocument.import_object_model_property
	self := Instance{}
	return GLTFObjectModelProperty.Instance(Advanced(self).ImportObjectModelProperty(state, String.New(json_pointer)))
}

/*
Determines a mapping between the given Godot [param node_path] and the corresponding glTF Object Model JSON pointer(s) in the generated glTF file. The details of this mapping are returned in a [GLTFObjectModelProperty] object. Additional mappings can be supplied via the [method GLTFDocumentExtension._import_object_model_property] callback method.
*/
func ExportObjectModelProperty(state GLTFState.Instance, node_path string, godot_node Node.Instance, gltf_node_index int) GLTFObjectModelProperty.Instance { //gd:GLTFDocument.export_object_model_property
	self := Instance{}
	return GLTFObjectModelProperty.Instance(Advanced(self).ExportObjectModelProperty(state, Path.ToNode(String.New(node_path)), godot_node, int64(gltf_node_index)))
}

/*
Registers the given [GLTFDocumentExtension] instance with GLTFDocument. If [param first_priority] is [code]true[/code], this extension will be run first. Otherwise, it will be run last.
[b]Note:[/b] Like GLTFDocument itself, all GLTFDocumentExtension classes must be stateless in order to function properly. If you need to store data, use the [code]set_additional_data[/code] and [code]get_additional_data[/code] methods in [GLTFState] or [GLTFNode].
*/
func RegisterGltfDocumentExtension(extension GLTFDocumentExtension.Instance, first_priority bool) { //gd:GLTFDocument.register_gltf_document_extension
	self := Instance{}
	Advanced(self).RegisterGltfDocumentExtension(extension, first_priority)
}

/*
Registers the given [GLTFDocumentExtension] instance with GLTFDocument. If [param first_priority] is [code]true[/code], this extension will be run first. Otherwise, it will be run last.
[b]Note:[/b] Like GLTFDocument itself, all GLTFDocumentExtension classes must be stateless in order to function properly. If you need to store data, use the [code]set_additional_data[/code] and [code]get_additional_data[/code] methods in [GLTFState] or [GLTFNode].
*/
func RegisterGltfDocumentExtensionOptions(extension GLTFDocumentExtension.Instance, first_priority bool) { //gd:GLTFDocument.register_gltf_document_extension
	self := Instance{}
	Advanced(self).RegisterGltfDocumentExtension(extension, first_priority)
}

/*
Unregisters the given [GLTFDocumentExtension] instance.
*/
func UnregisterGltfDocumentExtension(extension GLTFDocumentExtension.Instance) { //gd:GLTFDocument.unregister_gltf_document_extension
	self := Instance{}
	Advanced(self).UnregisterGltfDocumentExtension(extension)
}

/*
Returns a list of all support glTF extensions, including extensions supported directly by the engine, and extensions supported by user plugins registering [GLTFDocumentExtension] classes.
[b]Note:[/b] If this method is run before a GLTFDocumentExtension is registered, its extensions won't be included in the list. Be sure to only run this method after all extensions are registered. If you run this when the engine starts, consider waiting a frame before calling this method to ensure all extensions are registered.
*/
func GetSupportedGltfExtensions() []string { //gd:GLTFDocument.get_supported_gltf_extensions
	self := Instance{}
	return []string(Advanced(self).GetSupportedGltfExtensions().Strings())
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.GLTFDocument

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {
	object := gd.Global.ClassDB.ConstructObject(gd.NewStringName("GLTFDocument"))
	casted := Instance{*(*gdclass.GLTFDocument)(unsafe.Pointer(&object))}
	casted.AsRefCounted()[0].Reference()
	return casted
}

func (self Instance) ImageFormat() string {
	return string(class(self).GetImageFormat().String())
}

func (self Instance) SetImageFormat(value string) {
	class(self).SetImageFormat(String.New(value))
}

func (self Instance) LossyQuality() Float.X {
	return Float.X(Float.X(class(self).GetLossyQuality()))
}

func (self Instance) SetLossyQuality(value Float.X) {
	class(self).SetLossyQuality(float64(value))
}

func (self Instance) RootNodeMode() RootNodeMode {
	return RootNodeMode(class(self).GetRootNodeMode())
}

func (self Instance) SetRootNodeMode(value RootNodeMode) {
	class(self).SetRootNodeMode(value)
}

//go:nosplit
func (self class) SetImageFormat(image_format String.Readable) { //gd:GLTFDocument.set_image_format
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.GLTFDocument.Bind_set_image_format, 0|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ image_format gdextension.String }{gdextension.String(pointers.Get(gd.InternalString(image_format))[0])}))
}

//go:nosplit
func (self class) GetImageFormat() String.Readable { //gd:GLTFDocument.get_image_format
	var r_ret = gdunsafe.Call[[1]gd.EnginePointer](self.AsObject(), gd.Global.Methods.GLTFDocument.Bind_get_image_format, gdextension.SizeString, unsafe.Pointer(&struct{}{}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

//go:nosplit
func (self class) SetLossyQuality(lossy_quality float64) { //gd:GLTFDocument.set_lossy_quality
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.GLTFDocument.Bind_set_lossy_quality, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ lossy_quality float64 }{lossy_quality}))
}

//go:nosplit
func (self class) GetLossyQuality() float64 { //gd:GLTFDocument.get_lossy_quality
	var r_ret = gdunsafe.Call[float64](self.AsObject(), gd.Global.Methods.GLTFDocument.Bind_get_lossy_quality, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetRootNodeMode(root_node_mode RootNodeMode) { //gd:GLTFDocument.set_root_node_mode
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.GLTFDocument.Bind_set_root_node_mode, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ root_node_mode RootNodeMode }{root_node_mode}))
}

//go:nosplit
func (self class) GetRootNodeMode() RootNodeMode { //gd:GLTFDocument.get_root_node_mode
	var r_ret = gdunsafe.Call[RootNodeMode](self.AsObject(), gd.Global.Methods.GLTFDocument.Bind_get_root_node_mode, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Takes a path to a glTF file and imports the data at that file path to the given [GLTFState] object through the [param state] parameter.
[b]Note:[/b] The [param base_path] tells [method append_from_file] where to find dependencies and can be empty.
*/
//go:nosplit
func (self class) AppendFromFile(path String.Readable, state [1]gdclass.GLTFState, flags int64, base_path String.Readable) Error.Code { //gd:GLTFDocument.append_from_file
	var r_ret = gdunsafe.Call[int64](self.AsObject(), gd.Global.Methods.GLTFDocument.Bind_append_from_file, gdextension.SizeInt|(gdextension.SizeString<<4)|(gdextension.SizeObject<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeString<<16), unsafe.Pointer(&struct {
		path      gdextension.String
		state     gdextension.Object
		flags     int64
		base_path gdextension.String
	}{gdextension.String(pointers.Get(gd.InternalString(path))[0]), gdextension.Object(gd.ObjectChecked(state[0].AsObject())), flags, gdextension.String(pointers.Get(gd.InternalString(base_path))[0])}))
	var ret = Error.Code(r_ret)
	return ret
}

/*
Takes a [PackedByteArray] defining a glTF and imports the data to the given [GLTFState] object through the [param state] parameter.
[b]Note:[/b] The [param base_path] tells [method append_from_buffer] where to find dependencies and can be empty.
*/
//go:nosplit
func (self class) AppendFromBuffer(bytes Packed.Bytes, base_path String.Readable, state [1]gdclass.GLTFState, flags int64) Error.Code { //gd:GLTFDocument.append_from_buffer
	var r_ret = gdunsafe.Call[int64](self.AsObject(), gd.Global.Methods.GLTFDocument.Bind_append_from_buffer, gdextension.SizeInt|(gdextension.SizePackedArray<<4)|(gdextension.SizeString<<8)|(gdextension.SizeObject<<12)|(gdextension.SizeInt<<16), unsafe.Pointer(&struct {
		bytes     gdextension.PackedArray
		base_path gdextension.String
		state     gdextension.Object
		flags     int64
	}{gdextension.ToPackedArray(pointers.Get(gd.InternalPacked[gd.PackedByteArray, byte](Packed.Array[byte](bytes)))), gdextension.String(pointers.Get(gd.InternalString(base_path))[0]), gdextension.Object(gd.ObjectChecked(state[0].AsObject())), flags}))
	var ret = Error.Code(r_ret)
	return ret
}

/*
Takes a Godot Engine scene node and exports it and its descendants to the given [GLTFState] object through the [param state] parameter.
*/
//go:nosplit
func (self class) AppendFromScene(node [1]gdclass.Node, state [1]gdclass.GLTFState, flags int64) Error.Code { //gd:GLTFDocument.append_from_scene
	var r_ret = gdunsafe.Call[int64](self.AsObject(), gd.Global.Methods.GLTFDocument.Bind_append_from_scene, gdextension.SizeInt|(gdextension.SizeObject<<4)|(gdextension.SizeObject<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		node  gdextension.Object
		state gdextension.Object
		flags int64
	}{gdextension.Object(gd.ObjectChecked(node[0].AsObject())), gdextension.Object(gd.ObjectChecked(state[0].AsObject())), flags}))
	var ret = Error.Code(r_ret)
	return ret
}

/*
Takes a [GLTFState] object through the [param state] parameter and returns a Godot Engine scene node.
The [param bake_fps] parameter overrides the bake_fps in [param state].
*/
//go:nosplit
func (self class) GenerateScene(state [1]gdclass.GLTFState, bake_fps float64, trimming bool, remove_immutable_tracks bool) [1]gdclass.Node { //gd:GLTFDocument.generate_scene
	var r_ret = gdunsafe.Call[gd.EnginePointer](self.AsObject(), gd.Global.Methods.GLTFDocument.Bind_generate_scene, gdextension.SizeObject|(gdextension.SizeObject<<4)|(gdextension.SizeFloat<<8)|(gdextension.SizeBool<<12)|(gdextension.SizeBool<<16), unsafe.Pointer(&struct {
		state                   gdextension.Object
		bake_fps                float64
		trimming                bool
		remove_immutable_tracks bool
	}{gdextension.Object(gd.ObjectChecked(state[0].AsObject())), bake_fps, trimming, remove_immutable_tracks}))
	var ret = [1]gdclass.Node{gd.PointerWithOwnershipTransferredToGo[gdclass.Node](r_ret)}
	return ret
}

/*
Takes a [GLTFState] object through the [param state] parameter and returns a glTF [PackedByteArray].
*/
//go:nosplit
func (self class) GenerateBuffer(state [1]gdclass.GLTFState) Packed.Bytes { //gd:GLTFDocument.generate_buffer
	var r_ret = gdunsafe.Call[gd.PackedPointers](self.AsObject(), gd.Global.Methods.GLTFDocument.Bind_generate_buffer, gdextension.SizePackedArray|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ state gdextension.Object }{gdextension.Object(gd.ObjectChecked(state[0].AsObject()))}))
	var ret = Packed.Bytes(Array.Through(gd.PackedProxy[gd.PackedByteArray, byte]{}, pointers.Pack(pointers.Let[gd.PackedByteArray](r_ret))))
	return ret
}

/*
Takes a [GLTFState] object through the [param state] parameter and writes a glTF file to the filesystem.
[b]Note:[/b] The extension of the glTF file determines if it is a .glb binary file or a .gltf text file.
*/
//go:nosplit
func (self class) WriteToFilesystem(state [1]gdclass.GLTFState, path String.Readable) Error.Code { //gd:GLTFDocument.write_to_filesystem
	var r_ret = gdunsafe.Call[int64](self.AsObject(), gd.Global.Methods.GLTFDocument.Bind_write_to_filesystem, gdextension.SizeInt|(gdextension.SizeObject<<4)|(gdextension.SizeString<<8), unsafe.Pointer(&struct {
		state gdextension.Object
		path  gdextension.String
	}{gdextension.Object(gd.ObjectChecked(state[0].AsObject())), gdextension.String(pointers.Get(gd.InternalString(path))[0])}))
	var ret = Error.Code(r_ret)
	return ret
}

/*
Determines a mapping between the given glTF Object Model [param json_pointer] and the corresponding Godot node path(s) in the generated Godot scene. The details of this mapping are returned in a [GLTFObjectModelProperty] object. Additional mappings can be supplied via the [method GLTFDocumentExtension._export_object_model_property] callback method.
*/
//go:nosplit
func (self class) ImportObjectModelProperty(state [1]gdclass.GLTFState, json_pointer String.Readable) [1]gdclass.GLTFObjectModelProperty { //gd:GLTFDocument.import_object_model_property
	var r_ret = gdunsafe.CallStatic[gd.EnginePointer](gd.Global.Methods.GLTFDocument.Bind_import_object_model_property, gdextension.SizeObject|(gdextension.SizeObject<<4)|(gdextension.SizeString<<8), unsafe.Pointer(&struct {
		state        gdextension.Object
		json_pointer gdextension.String
	}{gdextension.Object(gd.ObjectChecked(state[0].AsObject())), gdextension.String(pointers.Get(gd.InternalString(json_pointer))[0])}))
	var ret = [1]gdclass.GLTFObjectModelProperty{gd.PointerWithOwnershipTransferredToGo[gdclass.GLTFObjectModelProperty](r_ret)}
	return ret
}

/*
Determines a mapping between the given Godot [param node_path] and the corresponding glTF Object Model JSON pointer(s) in the generated glTF file. The details of this mapping are returned in a [GLTFObjectModelProperty] object. Additional mappings can be supplied via the [method GLTFDocumentExtension._import_object_model_property] callback method.
*/
//go:nosplit
func (self class) ExportObjectModelProperty(state [1]gdclass.GLTFState, node_path Path.ToNode, godot_node [1]gdclass.Node, gltf_node_index int64) [1]gdclass.GLTFObjectModelProperty { //gd:GLTFDocument.export_object_model_property
	var r_ret = gdunsafe.CallStatic[gd.EnginePointer](gd.Global.Methods.GLTFDocument.Bind_export_object_model_property, gdextension.SizeObject|(gdextension.SizeObject<<4)|(gdextension.SizeNodePath<<8)|(gdextension.SizeObject<<12)|(gdextension.SizeInt<<16), unsafe.Pointer(&struct {
		state           gdextension.Object
		node_path       gdextension.NodePath
		godot_node      gdextension.Object
		gltf_node_index int64
	}{gdextension.Object(gd.ObjectChecked(state[0].AsObject())), gdextension.NodePath(pointers.Get(gd.InternalNodePath(node_path))[0]), gdextension.Object(gd.ObjectChecked(godot_node[0].AsObject())), gltf_node_index}))
	var ret = [1]gdclass.GLTFObjectModelProperty{gd.PointerWithOwnershipTransferredToGo[gdclass.GLTFObjectModelProperty](r_ret)}
	return ret
}

/*
Registers the given [GLTFDocumentExtension] instance with GLTFDocument. If [param first_priority] is [code]true[/code], this extension will be run first. Otherwise, it will be run last.
[b]Note:[/b] Like GLTFDocument itself, all GLTFDocumentExtension classes must be stateless in order to function properly. If you need to store data, use the [code]set_additional_data[/code] and [code]get_additional_data[/code] methods in [GLTFState] or [GLTFNode].
*/
//go:nosplit
func (self class) RegisterGltfDocumentExtension(extension [1]gdclass.GLTFDocumentExtension, first_priority bool) { //gd:GLTFDocument.register_gltf_document_extension
	gdunsafe.CallStatic[struct{}](gd.Global.Methods.GLTFDocument.Bind_register_gltf_document_extension, 0|(gdextension.SizeObject<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		extension      gdextension.Object
		first_priority bool
	}{gdextension.Object(gd.ObjectChecked(extension[0].AsObject())), first_priority}))
}

/*
Unregisters the given [GLTFDocumentExtension] instance.
*/
//go:nosplit
func (self class) UnregisterGltfDocumentExtension(extension [1]gdclass.GLTFDocumentExtension) { //gd:GLTFDocument.unregister_gltf_document_extension
	gdunsafe.CallStatic[struct{}](gd.Global.Methods.GLTFDocument.Bind_unregister_gltf_document_extension, 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ extension gdextension.Object }{gdextension.Object(gd.ObjectChecked(extension[0].AsObject()))}))
}

/*
Returns a list of all support glTF extensions, including extensions supported directly by the engine, and extensions supported by user plugins registering [GLTFDocumentExtension] classes.
[b]Note:[/b] If this method is run before a GLTFDocumentExtension is registered, its extensions won't be included in the list. Be sure to only run this method after all extensions are registered. If you run this when the engine starts, consider waiting a frame before calling this method to ensure all extensions are registered.
*/
//go:nosplit
func (self class) GetSupportedGltfExtensions() Packed.Strings { //gd:GLTFDocument.get_supported_gltf_extensions
	var r_ret = gdunsafe.CallStatic[gd.PackedPointers](gd.Global.Methods.GLTFDocument.Bind_get_supported_gltf_extensions, gdextension.SizePackedArray, unsafe.Pointer(&struct{}{}))
	var ret = Packed.Strings(Array.Through(gd.PackedStringArrayProxy{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}
func (self class) AsGLTFDocument() Advanced         { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsGLTFDocument() Instance      { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsGLTFDocument() Instance { return self.Super().AsGLTFDocument() }
func (self class) AsResource() Resource.Advanced {
	return *((*Resource.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsResource() Resource.Instance { return self.Super().AsResource() }
func (self Instance) AsResource() Resource.Instance {
	return *((*Resource.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsRefCounted() [1]gd.RefCounted { return self.Super().AsRefCounted() }
func (self Instance) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Resource.Advanced(self.AsResource()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Resource.Instance(self.AsResource()), name)
	}
}
func init() {
	gdclass.Register("GLTFDocument", func(ptr gd.Object) any {
		return [1]gdclass.GLTFDocument{*(*gdclass.GLTFDocument)(unsafe.Pointer(&ptr))}
	})
}

type RootNodeMode int //gd:GLTFDocument.RootNodeMode

const (
	/*Treat the Godot scene's root node as the root node of the glTF file, and mark it as the single root node via the [code]GODOT_single_root[/code] glTF extension. This will be parsed the same as [constant ROOT_NODE_MODE_KEEP_ROOT] if the implementation does not support [code]GODOT_single_root[/code].*/
	RootNodeModeSingleRoot RootNodeMode = 0
	/*Treat the Godot scene's root node as the root node of the glTF file, but do not mark it as anything special. An extra root node will be generated when importing into Godot. This uses only vanilla glTF features. This is equivalent to the behavior in Godot 4.1 and earlier.*/
	RootNodeModeKeepRoot RootNodeMode = 1
	/*Treat the Godot scene's root node as the name of the glTF scene, and add all of its children as root nodes of the glTF file. This uses only vanilla glTF features. This avoids an extra root node, but only the name of the Godot scene's root node will be preserved, as it will not be saved as a node.*/
	RootNodeModeMultiRoot RootNodeMode = 2
)
