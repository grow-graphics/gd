// Code generated by the generate package DO NOT EDIT

// Package LineEdit provides methods for working with LineEdit object instances.
package LineEdit

import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/variant/Signal"
import "graphics.gd/classdb/CanvasItem"
import "graphics.gd/classdb/Control"
import "graphics.gd/classdb/GUI"
import "graphics.gd/classdb/Node"
import "graphics.gd/classdb/PopupMenu"
import "graphics.gd/classdb/TextServer"
import "graphics.gd/classdb/Texture2D"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Signal.Any
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
[LineEdit] provides an input field for editing a single line of text.
- When the [LineEdit] control is focused using the keyboard arrow keys, it will only gain focus and not enter edit mode.
- To enter edit mode, click on the control with the mouse, see also [member keep_editing_on_text_submit].
- To exit edit mode, press [code]ui_text_submit[/code] or [code]ui_cancel[/code] (by default [kbd]Escape[/kbd]) actions.
- Check [method edit], [method unedit], [method is_editing], and [signal editing_toggled] for more information.
[b]Important:[/b]
- Focusing the [LineEdit] with [code]ui_focus_next[/code] (by default [kbd]Tab[/kbd]) or [code]ui_focus_prev[/code] (by default [kbd]Shift + Tab[/kbd]) or [method Control.grab_focus] still enters edit mode (for compatibility).
[LineEdit] features many built-in shortcuts that are always available ([kbd]Ctrl[/kbd] here maps to [kbd]Cmd[/kbd] on macOS):
- [kbd]Ctrl + C[/kbd]: Copy
- [kbd]Ctrl + X[/kbd]: Cut
- [kbd]Ctrl + V[/kbd] or [kbd]Ctrl + Y[/kbd]: Paste/"yank"
- [kbd]Ctrl + Z[/kbd]: Undo
- [kbd]Ctrl + ~[/kbd]: Swap input direction.
- [kbd]Ctrl + Shift + Z[/kbd]: Redo
- [kbd]Ctrl + U[/kbd]: Delete text from the caret position to the beginning of the line
- [kbd]Ctrl + K[/kbd]: Delete text from the caret position to the end of the line
- [kbd]Ctrl + A[/kbd]: Select all text
- [kbd]Up Arrow[/kbd]/[kbd]Down Arrow[/kbd]: Move the caret to the beginning/end of the line
On macOS, some extra keyboard shortcuts are available:
- [kbd]Cmd + F[/kbd]: Same as [kbd]Right Arrow[/kbd], move the caret one character right
- [kbd]Cmd + B[/kbd]: Same as [kbd]Left Arrow[/kbd], move the caret one character left
- [kbd]Cmd + P[/kbd]: Same as [kbd]Up Arrow[/kbd], move the caret to the previous line
- [kbd]Cmd + N[/kbd]: Same as [kbd]Down Arrow[/kbd], move the caret to the next line
- [kbd]Cmd + D[/kbd]: Same as [kbd]Delete[/kbd], delete the character on the right side of caret
- [kbd]Cmd + H[/kbd]: Same as [kbd]Backspace[/kbd], delete the character on the left side of the caret
- [kbd]Cmd + A[/kbd]: Same as [kbd]Home[/kbd], move the caret to the beginning of the line
- [kbd]Cmd + E[/kbd]: Same as [kbd]End[/kbd], move the caret to the end of the line
- [kbd]Cmd + Left Arrow[/kbd]: Same as [kbd]Home[/kbd], move the caret to the beginning of the line
- [kbd]Cmd + Right Arrow[/kbd]: Same as [kbd]End[/kbd], move the caret to the end of the line
[b]Note:[/b] Caret movement shortcuts listed above are not affected by [member shortcut_keys_enabled].
*/
type Instance [1]gdclass.LineEdit

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	has_ime_text                              gdextension.MethodForClass `hash:"36873697"`
	cancel_ime                                gdextension.MethodForClass `hash:"3218959716"`
	apply_ime                                 gdextension.MethodForClass `hash:"3218959716"`
	set_horizontal_alignment                  gdextension.MethodForClass `hash:"2312603777"`
	get_horizontal_alignment                  gdextension.MethodForClass `hash:"341400642"`
	edit                                      gdextension.MethodForClass `hash:"3218959716"`
	unedit                                    gdextension.MethodForClass `hash:"3218959716"`
	is_editing                                gdextension.MethodForClass `hash:"36873697"`
	set_keep_editing_on_text_submit           gdextension.MethodForClass `hash:"2586408642"`
	is_editing_kept_on_text_submit            gdextension.MethodForClass `hash:"36873697"`
	clear                                     gdextension.MethodForClass `hash:"3218959716"`
	select_                                   gdextension.MethodForClass `hash:"1328111411"`
	select_all                                gdextension.MethodForClass `hash:"3218959716"`
	deselect                                  gdextension.MethodForClass `hash:"3218959716"`
	has_undo                                  gdextension.MethodForClass `hash:"36873697"`
	has_redo                                  gdextension.MethodForClass `hash:"36873697"`
	has_selection                             gdextension.MethodForClass `hash:"36873697"`
	get_selected_text                         gdextension.MethodForClass `hash:"2841200299"`
	get_selection_from_column                 gdextension.MethodForClass `hash:"3905245786"`
	get_selection_to_column                   gdextension.MethodForClass `hash:"3905245786"`
	set_text                                  gdextension.MethodForClass `hash:"83702148"`
	get_text                                  gdextension.MethodForClass `hash:"201670096"`
	get_draw_control_chars                    gdextension.MethodForClass `hash:"36873697"`
	set_draw_control_chars                    gdextension.MethodForClass `hash:"2586408642"`
	set_text_direction                        gdextension.MethodForClass `hash:"119160795"`
	get_text_direction                        gdextension.MethodForClass `hash:"797257663"`
	set_language                              gdextension.MethodForClass `hash:"83702148"`
	get_language                              gdextension.MethodForClass `hash:"201670096"`
	set_structured_text_bidi_override         gdextension.MethodForClass `hash:"55961453"`
	get_structured_text_bidi_override         gdextension.MethodForClass `hash:"3385126229"`
	set_structured_text_bidi_override_options gdextension.MethodForClass `hash:"381264803"`
	get_structured_text_bidi_override_options gdextension.MethodForClass `hash:"3995934104"`
	set_placeholder                           gdextension.MethodForClass `hash:"83702148"`
	get_placeholder                           gdextension.MethodForClass `hash:"201670096"`
	set_caret_column                          gdextension.MethodForClass `hash:"1286410249"`
	get_caret_column                          gdextension.MethodForClass `hash:"3905245786"`
	get_scroll_offset                         gdextension.MethodForClass `hash:"1740695150"`
	set_expand_to_text_length_enabled         gdextension.MethodForClass `hash:"2586408642"`
	is_expand_to_text_length_enabled          gdextension.MethodForClass `hash:"36873697"`
	set_caret_blink_enabled                   gdextension.MethodForClass `hash:"2586408642"`
	is_caret_blink_enabled                    gdextension.MethodForClass `hash:"36873697"`
	set_caret_mid_grapheme_enabled            gdextension.MethodForClass `hash:"2586408642"`
	is_caret_mid_grapheme_enabled             gdextension.MethodForClass `hash:"36873697"`
	set_caret_force_displayed                 gdextension.MethodForClass `hash:"2586408642"`
	is_caret_force_displayed                  gdextension.MethodForClass `hash:"36873697"`
	set_caret_blink_interval                  gdextension.MethodForClass `hash:"373806689"`
	get_caret_blink_interval                  gdextension.MethodForClass `hash:"1740695150"`
	set_max_length                            gdextension.MethodForClass `hash:"1286410249"`
	get_max_length                            gdextension.MethodForClass `hash:"3905245786"`
	insert_text_at_caret                      gdextension.MethodForClass `hash:"83702148"`
	delete_char_at_caret                      gdextension.MethodForClass `hash:"3218959716"`
	delete_text                               gdextension.MethodForClass `hash:"3937882851"`
	set_editable                              gdextension.MethodForClass `hash:"2586408642"`
	is_editable                               gdextension.MethodForClass `hash:"36873697"`
	set_secret                                gdextension.MethodForClass `hash:"2586408642"`
	is_secret                                 gdextension.MethodForClass `hash:"36873697"`
	set_secret_character                      gdextension.MethodForClass `hash:"83702148"`
	get_secret_character                      gdextension.MethodForClass `hash:"201670096"`
	menu_option                               gdextension.MethodForClass `hash:"1286410249"`
	get_menu                                  gdextension.MethodForClass `hash:"229722558"`
	is_menu_visible                           gdextension.MethodForClass `hash:"36873697"`
	set_context_menu_enabled                  gdextension.MethodForClass `hash:"2586408642"`
	is_context_menu_enabled                   gdextension.MethodForClass `hash:"2240911060"`
	set_emoji_menu_enabled                    gdextension.MethodForClass `hash:"2586408642"`
	is_emoji_menu_enabled                     gdextension.MethodForClass `hash:"36873697"`
	set_virtual_keyboard_enabled              gdextension.MethodForClass `hash:"2586408642"`
	is_virtual_keyboard_enabled               gdextension.MethodForClass `hash:"36873697"`
	set_virtual_keyboard_type                 gdextension.MethodForClass `hash:"2696893573"`
	get_virtual_keyboard_type                 gdextension.MethodForClass `hash:"1928699316"`
	set_clear_button_enabled                  gdextension.MethodForClass `hash:"2586408642"`
	is_clear_button_enabled                   gdextension.MethodForClass `hash:"36873697"`
	set_shortcut_keys_enabled                 gdextension.MethodForClass `hash:"2586408642"`
	is_shortcut_keys_enabled                  gdextension.MethodForClass `hash:"36873697"`
	set_middle_mouse_paste_enabled            gdextension.MethodForClass `hash:"2586408642"`
	is_middle_mouse_paste_enabled             gdextension.MethodForClass `hash:"36873697"`
	set_selecting_enabled                     gdextension.MethodForClass `hash:"2586408642"`
	is_selecting_enabled                      gdextension.MethodForClass `hash:"36873697"`
	set_deselect_on_focus_loss_enabled        gdextension.MethodForClass `hash:"2586408642"`
	is_deselect_on_focus_loss_enabled         gdextension.MethodForClass `hash:"36873697"`
	set_drag_and_drop_selection_enabled       gdextension.MethodForClass `hash:"2586408642"`
	is_drag_and_drop_selection_enabled        gdextension.MethodForClass `hash:"36873697"`
	set_right_icon                            gdextension.MethodForClass `hash:"4051416890"`
	get_right_icon                            gdextension.MethodForClass `hash:"255860311"`
	set_flat                                  gdextension.MethodForClass `hash:"2586408642"`
	is_flat                                   gdextension.MethodForClass `hash:"36873697"`
	set_select_all_on_focus                   gdextension.MethodForClass `hash:"2586408642"`
	is_select_all_on_focus                    gdextension.MethodForClass `hash:"36873697"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("LineEdit")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		gdextension.Free(gdextension.TypeStringName, &sname)
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

type Expanded [1]gdclass.LineEdit

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsLineEdit() Instance
}

/*
Returns [code]true[/code] if the user has text in the [url=https://en.wikipedia.org/wiki/Input_method]Input Method Editor[/url] (IME).
*/
func (self Instance) HasImeText() bool { //gd:LineEdit.has_ime_text
	return bool(Advanced(self).HasImeText())
}

/*
Closes the [url=https://en.wikipedia.org/wiki/Input_method]Input Method Editor[/url] (IME) if it is open. Any text in the IME will be lost.
*/
func (self Instance) CancelIme() { //gd:LineEdit.cancel_ime
	Advanced(self).CancelIme()
}

/*
Applies text from the [url=https://en.wikipedia.org/wiki/Input_method]Input Method Editor[/url] (IME) and closes the IME if it is open.
*/
func (self Instance) ApplyIme() { //gd:LineEdit.apply_ime
	Advanced(self).ApplyIme()
}

/*
Allows entering edit mode whether the [LineEdit] is focused or not.
See also [member keep_editing_on_text_submit].
*/
func (self Instance) Edit() { //gd:LineEdit.edit
	Advanced(self).Edit()
}

/*
Allows exiting edit mode while preserving focus.
*/
func (self Instance) Unedit() { //gd:LineEdit.unedit
	Advanced(self).Unedit()
}

/*
Returns whether the [LineEdit] is being edited.
*/
func (self Instance) IsEditing() bool { //gd:LineEdit.is_editing
	return bool(Advanced(self).IsEditing())
}

/*
Erases the [LineEdit]'s [member text].
*/
func (self Instance) Clear() { //gd:LineEdit.clear
	Advanced(self).Clear()
}

/*
Selects characters inside [LineEdit] between [param from] and [param to]. By default, [param from] is at the beginning and [param to] at the end.
[codeblocks]
[gdscript]
text = "Welcome"
select() # Will select "Welcome".
select(4) # Will select "ome".
select(2, 5) # Will select "lco".
[/gdscript]
[csharp]
Text = "Welcome";
Select(); // Will select "Welcome".
Select(4); // Will select "ome".
Select(2, 5); // Will select "lco".
[/csharp]
[/codeblocks]
*/
func (self Instance) Select() { //gd:LineEdit.select
	Advanced(self).Select(int64(0), int64(-1))
}

/*
Selects characters inside [LineEdit] between [param from] and [param to]. By default, [param from] is at the beginning and [param to] at the end.
[codeblocks]
[gdscript]
text = "Welcome"
select() # Will select "Welcome".
select(4) # Will select "ome".
select(2, 5) # Will select "lco".
[/gdscript]
[csharp]
Text = "Welcome";
Select(); // Will select "Welcome".
Select(4); // Will select "ome".
Select(2, 5); // Will select "lco".
[/csharp]
[/codeblocks]
*/
func (self Expanded) Select(from int, to int) { //gd:LineEdit.select
	Advanced(self).Select(int64(from), int64(to))
}

/*
Selects the whole [String].
*/
func (self Instance) SelectAll() { //gd:LineEdit.select_all
	Advanced(self).SelectAll()
}

/*
Clears the current selection.
*/
func (self Instance) Deselect() { //gd:LineEdit.deselect
	Advanced(self).Deselect()
}

/*
Returns [code]true[/code] if an "undo" action is available.
*/
func (self Instance) HasUndo() bool { //gd:LineEdit.has_undo
	return bool(Advanced(self).HasUndo())
}

/*
Returns [code]true[/code] if a "redo" action is available.
*/
func (self Instance) HasRedo() bool { //gd:LineEdit.has_redo
	return bool(Advanced(self).HasRedo())
}

/*
Returns [code]true[/code] if the user has selected text.
*/
func (self Instance) HasSelection() bool { //gd:LineEdit.has_selection
	return bool(Advanced(self).HasSelection())
}

/*
Returns the text inside the selection.
*/
func (self Instance) GetSelectedText() string { //gd:LineEdit.get_selected_text
	return string(Advanced(self).GetSelectedText().String())
}

/*
Returns the selection begin column.
*/
func (self Instance) GetSelectionFromColumn() int { //gd:LineEdit.get_selection_from_column
	return int(int(Advanced(self).GetSelectionFromColumn()))
}

/*
Returns the selection end column.
*/
func (self Instance) GetSelectionToColumn() int { //gd:LineEdit.get_selection_to_column
	return int(int(Advanced(self).GetSelectionToColumn()))
}

/*
Returns the scroll offset due to [member caret_column], as a number of characters.
*/
func (self Instance) GetScrollOffset() Float.X { //gd:LineEdit.get_scroll_offset
	return Float.X(Float.X(Advanced(self).GetScrollOffset()))
}

/*
Inserts [param text] at the caret. If the resulting value is longer than [member max_length], nothing happens.
*/
func (self Instance) InsertTextAtCaret(text string) { //gd:LineEdit.insert_text_at_caret
	Advanced(self).InsertTextAtCaret(String.New(text))
}

/*
Deletes one character at the caret's current position (equivalent to pressing [kbd]Delete[/kbd]).
*/
func (self Instance) DeleteCharAtCaret() { //gd:LineEdit.delete_char_at_caret
	Advanced(self).DeleteCharAtCaret()
}

/*
Deletes a section of the [member text] going from position [param from_column] to [param to_column]. Both parameters should be within the text's length.
*/
func (self Instance) DeleteText(from_column int, to_column int) { //gd:LineEdit.delete_text
	Advanced(self).DeleteText(int64(from_column), int64(to_column))
}

/*
Executes a given action as defined in the [enum MenuItems] enum.
*/
func (self Instance) MenuOption(option int) { //gd:LineEdit.menu_option
	Advanced(self).MenuOption(int64(option))
}

/*
Returns the [PopupMenu] of this [LineEdit]. By default, this menu is displayed when right-clicking on the [LineEdit].
You can add custom menu items or remove standard ones. Make sure your IDs don't conflict with the standard ones (see [enum MenuItems]). For example:
[codeblocks]
[gdscript]
func _ready():

	var menu = get_menu()
	# Remove all items after "Redo".
	menu.item_count = menu.get_item_index(MENU_REDO) + 1
	# Add custom items.
	menu.add_separator()
	menu.add_item("Insert Date", MENU_MAX + 1)
	# Connect callback.
	menu.id_pressed.connect(_on_item_pressed)

func _on_item_pressed(id):

	if id == MENU_MAX + 1:
	    insert_text_at_caret(Time.get_date_string_from_system())

[/gdscript]
[csharp]
public override void _Ready()

	{
	    var menu = GetMenu();
	    // Remove all items after "Redo".
	    menu.ItemCount = menu.GetItemIndex(LineEdit.MenuItems.Redo) + 1;
	    // Add custom items.
	    menu.AddSeparator();
	    menu.AddItem("Insert Date", LineEdit.MenuItems.Max + 1);
	    // Add event handler.
	    menu.IdPressed += OnItemPressed;
	}

public void OnItemPressed(int id)

	{
	    if (id == LineEdit.MenuItems.Max + 1)
	    {
	        InsertTextAtCaret(Time.GetDateStringFromSystem());
	    }
	}

[/csharp]
[/codeblocks]
[b]Warning:[/b] This is a required internal node, removing and freeing it may cause a crash. If you wish to hide it or any of its children, use their [member Window.visible] property.
*/
func (self Instance) GetMenu() PopupMenu.Instance { //gd:LineEdit.get_menu
	return PopupMenu.Instance(Advanced(self).GetMenu())
}

/*
Returns whether the menu is visible. Use this instead of [code]get_menu().visible[/code] to improve performance (so the creation of the menu is avoided).
*/
func (self Instance) IsMenuVisible() bool { //gd:LineEdit.is_menu_visible
	return bool(Advanced(self).IsMenuVisible())
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.LineEdit

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = pointers.AsA[gdclass.LineEdit](obj[0])
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = pointers.AsA[gdclass.LineEdit](obj[0])
		return true
	}
	return false
}
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }
func (self *Extension[T]) AsObject() [1]gd.Object { return self.Super().AsObject() }
func New() Instance {
	if !gd.Linked {
		var placeholder = Instance([1]gdclass.LineEdit{pointers.Add[gdclass.LineEdit]([3]uint64{})})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(pointers.AsA[gd.Object](placeholder[0]), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	casted := Instance([1]gdclass.LineEdit{pointers.New[gdclass.LineEdit]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})})
	casted.AsObject()[0].Notification(0, false)
	return casted
}

func (self Instance) Text() string {
	return string(class(self).GetText().String())
}

func (self Instance) SetText(value string) {
	class(self).SetText(String.New(value))
}

func (self Instance) PlaceholderText() string {
	return string(class(self).GetPlaceholder().String())
}

func (self Instance) SetPlaceholderText(value string) {
	class(self).SetPlaceholder(String.New(value))
}

func (self Instance) Alignment() GUI.HorizontalAlignment {
	return GUI.HorizontalAlignment(class(self).GetHorizontalAlignment())
}

func (self Instance) SetAlignment(value GUI.HorizontalAlignment) {
	class(self).SetHorizontalAlignment(value)
}

func (self Instance) MaxLength() int {
	return int(int(class(self).GetMaxLength()))
}

func (self Instance) SetMaxLength(value int) {
	class(self).SetMaxLength(int64(value))
}

func (self Instance) Editable() bool {
	return bool(class(self).IsEditable())
}

func (self Instance) SetEditable(value bool) {
	class(self).SetEditable(value)
}

func (self Instance) KeepEditingOnTextSubmit() bool {
	return bool(class(self).IsEditingKeptOnTextSubmit())
}

func (self Instance) SetKeepEditingOnTextSubmit(value bool) {
	class(self).SetKeepEditingOnTextSubmit(value)
}

func (self Instance) ExpandToTextLength() bool {
	return bool(class(self).IsExpandToTextLengthEnabled())
}

func (self Instance) SetExpandToTextLength(value bool) {
	class(self).SetExpandToTextLengthEnabled(value)
}

func (self Instance) ContextMenuEnabled() bool {
	return bool(class(self).IsContextMenuEnabled())
}

func (self Instance) SetContextMenuEnabled(value bool) {
	class(self).SetContextMenuEnabled(value)
}

func (self Instance) EmojiMenuEnabled() bool {
	return bool(class(self).IsEmojiMenuEnabled())
}

func (self Instance) SetEmojiMenuEnabled(value bool) {
	class(self).SetEmojiMenuEnabled(value)
}

func (self Instance) VirtualKeyboardEnabled() bool {
	return bool(class(self).IsVirtualKeyboardEnabled())
}

func (self Instance) SetVirtualKeyboardEnabled(value bool) {
	class(self).SetVirtualKeyboardEnabled(value)
}

func (self Instance) VirtualKeyboardType() VirtualKeyboardType {
	return VirtualKeyboardType(class(self).GetVirtualKeyboardType())
}

func (self Instance) SetVirtualKeyboardType(value VirtualKeyboardType) {
	class(self).SetVirtualKeyboardType(value)
}

func (self Instance) ClearButtonEnabled() bool {
	return bool(class(self).IsClearButtonEnabled())
}

func (self Instance) SetClearButtonEnabled(value bool) {
	class(self).SetClearButtonEnabled(value)
}

func (self Instance) ShortcutKeysEnabled() bool {
	return bool(class(self).IsShortcutKeysEnabled())
}

func (self Instance) SetShortcutKeysEnabled(value bool) {
	class(self).SetShortcutKeysEnabled(value)
}

func (self Instance) MiddleMousePasteEnabled() bool {
	return bool(class(self).IsMiddleMousePasteEnabled())
}

func (self Instance) SetMiddleMousePasteEnabled(value bool) {
	class(self).SetMiddleMousePasteEnabled(value)
}

func (self Instance) SelectingEnabled() bool {
	return bool(class(self).IsSelectingEnabled())
}

func (self Instance) SetSelectingEnabled(value bool) {
	class(self).SetSelectingEnabled(value)
}

func (self Instance) DeselectOnFocusLossEnabled() bool {
	return bool(class(self).IsDeselectOnFocusLossEnabled())
}

func (self Instance) SetDeselectOnFocusLossEnabled(value bool) {
	class(self).SetDeselectOnFocusLossEnabled(value)
}

func (self Instance) DragAndDropSelectionEnabled() bool {
	return bool(class(self).IsDragAndDropSelectionEnabled())
}

func (self Instance) SetDragAndDropSelectionEnabled(value bool) {
	class(self).SetDragAndDropSelectionEnabled(value)
}

func (self Instance) RightIcon() Texture2D.Instance {
	return Texture2D.Instance(class(self).GetRightIcon())
}

func (self Instance) SetRightIcon(value Texture2D.Instance) {
	class(self).SetRightIcon(value)
}

func (self Instance) Flat() bool {
	return bool(class(self).IsFlat())
}

func (self Instance) SetFlat(value bool) {
	class(self).SetFlat(value)
}

func (self Instance) DrawControlChars() bool {
	return bool(class(self).GetDrawControlChars())
}

func (self Instance) SetDrawControlChars(value bool) {
	class(self).SetDrawControlChars(value)
}

func (self Instance) SelectAllOnFocus() bool {
	return bool(class(self).IsSelectAllOnFocus())
}

func (self Instance) SetSelectAllOnFocus(value bool) {
	class(self).SetSelectAllOnFocus(value)
}

func (self Instance) CaretBlink() bool {
	return bool(class(self).IsCaretBlinkEnabled())
}

func (self Instance) SetCaretBlink(value bool) {
	class(self).SetCaretBlinkEnabled(value)
}

func (self Instance) CaretBlinkInterval() Float.X {
	return Float.X(Float.X(class(self).GetCaretBlinkInterval()))
}

func (self Instance) SetCaretBlinkInterval(value Float.X) {
	class(self).SetCaretBlinkInterval(float64(value))
}

func (self Instance) CaretColumn() int {
	return int(int(class(self).GetCaretColumn()))
}

func (self Instance) SetCaretColumn(value int) {
	class(self).SetCaretColumn(int64(value))
}

func (self Instance) CaretForceDisplayed() bool {
	return bool(class(self).IsCaretForceDisplayed())
}

func (self Instance) SetCaretForceDisplayed(value bool) {
	class(self).SetCaretForceDisplayed(value)
}

func (self Instance) CaretMidGrapheme() bool {
	return bool(class(self).IsCaretMidGraphemeEnabled())
}

func (self Instance) SetCaretMidGrapheme(value bool) {
	class(self).SetCaretMidGraphemeEnabled(value)
}

func (self Instance) Secret() bool {
	return bool(class(self).IsSecret())
}

func (self Instance) SetSecret(value bool) {
	class(self).SetSecret(value)
}

func (self Instance) SecretCharacter() string {
	return string(class(self).GetSecretCharacter().String())
}

func (self Instance) SetSecretCharacter(value string) {
	class(self).SetSecretCharacter(String.New(value))
}

func (self Instance) TextDirection() Control.TextDirection {
	return Control.TextDirection(class(self).GetTextDirection())
}

func (self Instance) SetTextDirection(value Control.TextDirection) {
	class(self).SetTextDirection(value)
}

func (self Instance) Language() string {
	return string(class(self).GetLanguage().String())
}

func (self Instance) SetLanguage(value string) {
	class(self).SetLanguage(String.New(value))
}

func (self Instance) StructuredTextBidiOverride() TextServer.StructuredTextParser {
	return TextServer.StructuredTextParser(class(self).GetStructuredTextBidiOverride())
}

func (self Instance) SetStructuredTextBidiOverride(value TextServer.StructuredTextParser) {
	class(self).SetStructuredTextBidiOverride(value)
}

func (self Instance) StructuredTextBidiOverrideOptions() []any {
	return []any(gd.ArrayAs[[]any](gd.InternalArray(class(self).GetStructuredTextBidiOverrideOptions())))
}

func (self Instance) SetStructuredTextBidiOverrideOptions(value []any) {
	class(self).SetStructuredTextBidiOverrideOptions(gd.EngineArrayFromSlice(value))
}

/*
Returns [code]true[/code] if the user has text in the [url=https://en.wikipedia.org/wiki/Input_method]Input Method Editor[/url] (IME).
*/
//go:nosplit
func (self class) HasImeText() bool { //gd:LineEdit.has_ime_text
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.has_ime_text, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

/*
Closes the [url=https://en.wikipedia.org/wiki/Input_method]Input Method Editor[/url] (IME) if it is open. Any text in the IME will be lost.
*/
//go:nosplit
func (self class) CancelIme() { //gd:LineEdit.cancel_ime
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.cancel_ime, 0, &struct{}{})
}

/*
Applies text from the [url=https://en.wikipedia.org/wiki/Input_method]Input Method Editor[/url] (IME) and closes the IME if it is open.
*/
//go:nosplit
func (self class) ApplyIme() { //gd:LineEdit.apply_ime
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.apply_ime, 0, &struct{}{})
}

//go:nosplit
func (self class) SetHorizontalAlignment(alignment GUI.HorizontalAlignment) { //gd:LineEdit.set_horizontal_alignment
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_horizontal_alignment, 0|(gdextension.SizeInt<<4), &struct{ alignment GUI.HorizontalAlignment }{alignment})
}

//go:nosplit
func (self class) GetHorizontalAlignment() GUI.HorizontalAlignment { //gd:LineEdit.get_horizontal_alignment
	var r_ret = gdextension.Call[GUI.HorizontalAlignment](gd.ObjectChecked(self.AsObject()), methods.get_horizontal_alignment, gdextension.SizeInt, &struct{}{})
	var ret = r_ret
	return ret
}

/*
Allows entering edit mode whether the [LineEdit] is focused or not.
See also [member keep_editing_on_text_submit].
*/
//go:nosplit
func (self class) Edit() { //gd:LineEdit.edit
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.edit, 0, &struct{}{})
}

/*
Allows exiting edit mode while preserving focus.
*/
//go:nosplit
func (self class) Unedit() { //gd:LineEdit.unedit
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.unedit, 0, &struct{}{})
}

/*
Returns whether the [LineEdit] is being edited.
*/
//go:nosplit
func (self class) IsEditing() bool { //gd:LineEdit.is_editing
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_editing, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetKeepEditingOnTextSubmit(enable bool) { //gd:LineEdit.set_keep_editing_on_text_submit
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_keep_editing_on_text_submit, 0|(gdextension.SizeBool<<4), &struct{ enable bool }{enable})
}

//go:nosplit
func (self class) IsEditingKeptOnTextSubmit() bool { //gd:LineEdit.is_editing_kept_on_text_submit
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_editing_kept_on_text_submit, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

/*
Erases the [LineEdit]'s [member text].
*/
//go:nosplit
func (self class) Clear() { //gd:LineEdit.clear
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.clear, 0, &struct{}{})
}

/*
Selects characters inside [LineEdit] between [param from] and [param to]. By default, [param from] is at the beginning and [param to] at the end.
[codeblocks]
[gdscript]
text = "Welcome"
select() # Will select "Welcome".
select(4) # Will select "ome".
select(2, 5) # Will select "lco".
[/gdscript]
[csharp]
Text = "Welcome";
Select(); // Will select "Welcome".
Select(4); // Will select "ome".
Select(2, 5); // Will select "lco".
[/csharp]
[/codeblocks]
*/
//go:nosplit
func (self class) Select(from int64, to int64) { //gd:LineEdit.select_
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.select_, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), &struct {
		from int64
		to   int64
	}{from, to})
}

/*
Selects the whole [String].
*/
//go:nosplit
func (self class) SelectAll() { //gd:LineEdit.select_all
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.select_all, 0, &struct{}{})
}

/*
Clears the current selection.
*/
//go:nosplit
func (self class) Deselect() { //gd:LineEdit.deselect
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.deselect, 0, &struct{}{})
}

/*
Returns [code]true[/code] if an "undo" action is available.
*/
//go:nosplit
func (self class) HasUndo() bool { //gd:LineEdit.has_undo
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.has_undo, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if a "redo" action is available.
*/
//go:nosplit
func (self class) HasRedo() bool { //gd:LineEdit.has_redo
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.has_redo, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if the user has selected text.
*/
//go:nosplit
func (self class) HasSelection() bool { //gd:LineEdit.has_selection
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.has_selection, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

/*
Returns the text inside the selection.
*/
//go:nosplit
func (self class) GetSelectedText() String.Readable { //gd:LineEdit.get_selected_text
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_selected_text, gdextension.SizeString, &struct{}{})
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Returns the selection begin column.
*/
//go:nosplit
func (self class) GetSelectionFromColumn() int64 { //gd:LineEdit.get_selection_from_column
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_selection_from_column, gdextension.SizeInt, &struct{}{})
	var ret = r_ret
	return ret
}

/*
Returns the selection end column.
*/
//go:nosplit
func (self class) GetSelectionToColumn() int64 { //gd:LineEdit.get_selection_to_column
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_selection_to_column, gdextension.SizeInt, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetText(text String.Readable) { //gd:LineEdit.set_text
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_text, 0|(gdextension.SizeString<<4), &struct{ text gdextension.String }{pointers.Get(gd.InternalString(text))})
}

//go:nosplit
func (self class) GetText() String.Readable { //gd:LineEdit.get_text
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_text, gdextension.SizeString, &struct{}{})
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

//go:nosplit
func (self class) GetDrawControlChars() bool { //gd:LineEdit.get_draw_control_chars
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.get_draw_control_chars, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetDrawControlChars(enable bool) { //gd:LineEdit.set_draw_control_chars
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_draw_control_chars, 0|(gdextension.SizeBool<<4), &struct{ enable bool }{enable})
}

//go:nosplit
func (self class) SetTextDirection(direction Control.TextDirection) { //gd:LineEdit.set_text_direction
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_text_direction, 0|(gdextension.SizeInt<<4), &struct{ direction Control.TextDirection }{direction})
}

//go:nosplit
func (self class) GetTextDirection() Control.TextDirection { //gd:LineEdit.get_text_direction
	var r_ret = gdextension.Call[Control.TextDirection](gd.ObjectChecked(self.AsObject()), methods.get_text_direction, gdextension.SizeInt, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetLanguage(language String.Readable) { //gd:LineEdit.set_language
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_language, 0|(gdextension.SizeString<<4), &struct{ language gdextension.String }{pointers.Get(gd.InternalString(language))})
}

//go:nosplit
func (self class) GetLanguage() String.Readable { //gd:LineEdit.get_language
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_language, gdextension.SizeString, &struct{}{})
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

//go:nosplit
func (self class) SetStructuredTextBidiOverride(parser TextServer.StructuredTextParser) { //gd:LineEdit.set_structured_text_bidi_override
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_structured_text_bidi_override, 0|(gdextension.SizeInt<<4), &struct {
		parser TextServer.StructuredTextParser
	}{parser})
}

//go:nosplit
func (self class) GetStructuredTextBidiOverride() TextServer.StructuredTextParser { //gd:LineEdit.get_structured_text_bidi_override
	var r_ret = gdextension.Call[TextServer.StructuredTextParser](gd.ObjectChecked(self.AsObject()), methods.get_structured_text_bidi_override, gdextension.SizeInt, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetStructuredTextBidiOverrideOptions(args Array.Any) { //gd:LineEdit.set_structured_text_bidi_override_options
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_structured_text_bidi_override_options, 0|(gdextension.SizeArray<<4), &struct{ args gdextension.Array }{pointers.Get(gd.InternalArray(args))})
}

//go:nosplit
func (self class) GetStructuredTextBidiOverrideOptions() Array.Any { //gd:LineEdit.get_structured_text_bidi_override_options
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), methods.get_structured_text_bidi_override_options, gdextension.SizeArray, &struct{}{})
	var ret = Array.Through(gd.ArrayProxy[variant.Any]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

//go:nosplit
func (self class) SetPlaceholder(text String.Readable) { //gd:LineEdit.set_placeholder
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_placeholder, 0|(gdextension.SizeString<<4), &struct{ text gdextension.String }{pointers.Get(gd.InternalString(text))})
}

//go:nosplit
func (self class) GetPlaceholder() String.Readable { //gd:LineEdit.get_placeholder
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_placeholder, gdextension.SizeString, &struct{}{})
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

//go:nosplit
func (self class) SetCaretColumn(position int64) { //gd:LineEdit.set_caret_column
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_caret_column, 0|(gdextension.SizeInt<<4), &struct{ position int64 }{position})
}

//go:nosplit
func (self class) GetCaretColumn() int64 { //gd:LineEdit.get_caret_column
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_caret_column, gdextension.SizeInt, &struct{}{})
	var ret = r_ret
	return ret
}

/*
Returns the scroll offset due to [member caret_column], as a number of characters.
*/
//go:nosplit
func (self class) GetScrollOffset() float64 { //gd:LineEdit.get_scroll_offset
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_scroll_offset, gdextension.SizeFloat, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetExpandToTextLengthEnabled(enabled bool) { //gd:LineEdit.set_expand_to_text_length_enabled
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_expand_to_text_length_enabled, 0|(gdextension.SizeBool<<4), &struct{ enabled bool }{enabled})
}

//go:nosplit
func (self class) IsExpandToTextLengthEnabled() bool { //gd:LineEdit.is_expand_to_text_length_enabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_expand_to_text_length_enabled, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetCaretBlinkEnabled(enabled bool) { //gd:LineEdit.set_caret_blink_enabled
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_caret_blink_enabled, 0|(gdextension.SizeBool<<4), &struct{ enabled bool }{enabled})
}

//go:nosplit
func (self class) IsCaretBlinkEnabled() bool { //gd:LineEdit.is_caret_blink_enabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_caret_blink_enabled, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetCaretMidGraphemeEnabled(enabled bool) { //gd:LineEdit.set_caret_mid_grapheme_enabled
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_caret_mid_grapheme_enabled, 0|(gdextension.SizeBool<<4), &struct{ enabled bool }{enabled})
}

//go:nosplit
func (self class) IsCaretMidGraphemeEnabled() bool { //gd:LineEdit.is_caret_mid_grapheme_enabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_caret_mid_grapheme_enabled, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetCaretForceDisplayed(enabled bool) { //gd:LineEdit.set_caret_force_displayed
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_caret_force_displayed, 0|(gdextension.SizeBool<<4), &struct{ enabled bool }{enabled})
}

//go:nosplit
func (self class) IsCaretForceDisplayed() bool { //gd:LineEdit.is_caret_force_displayed
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_caret_force_displayed, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetCaretBlinkInterval(interval float64) { //gd:LineEdit.set_caret_blink_interval
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_caret_blink_interval, 0|(gdextension.SizeFloat<<4), &struct{ interval float64 }{interval})
}

//go:nosplit
func (self class) GetCaretBlinkInterval() float64 { //gd:LineEdit.get_caret_blink_interval
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_caret_blink_interval, gdextension.SizeFloat, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetMaxLength(chars int64) { //gd:LineEdit.set_max_length
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_max_length, 0|(gdextension.SizeInt<<4), &struct{ chars int64 }{chars})
}

//go:nosplit
func (self class) GetMaxLength() int64 { //gd:LineEdit.get_max_length
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_max_length, gdextension.SizeInt, &struct{}{})
	var ret = r_ret
	return ret
}

/*
Inserts [param text] at the caret. If the resulting value is longer than [member max_length], nothing happens.
*/
//go:nosplit
func (self class) InsertTextAtCaret(text String.Readable) { //gd:LineEdit.insert_text_at_caret
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.insert_text_at_caret, 0|(gdextension.SizeString<<4), &struct{ text gdextension.String }{pointers.Get(gd.InternalString(text))})
}

/*
Deletes one character at the caret's current position (equivalent to pressing [kbd]Delete[/kbd]).
*/
//go:nosplit
func (self class) DeleteCharAtCaret() { //gd:LineEdit.delete_char_at_caret
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.delete_char_at_caret, 0, &struct{}{})
}

/*
Deletes a section of the [member text] going from position [param from_column] to [param to_column]. Both parameters should be within the text's length.
*/
//go:nosplit
func (self class) DeleteText(from_column int64, to_column int64) { //gd:LineEdit.delete_text
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.delete_text, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), &struct {
		from_column int64
		to_column   int64
	}{from_column, to_column})
}

//go:nosplit
func (self class) SetEditable(enabled bool) { //gd:LineEdit.set_editable
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_editable, 0|(gdextension.SizeBool<<4), &struct{ enabled bool }{enabled})
}

//go:nosplit
func (self class) IsEditable() bool { //gd:LineEdit.is_editable
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_editable, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetSecret(enabled bool) { //gd:LineEdit.set_secret
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_secret, 0|(gdextension.SizeBool<<4), &struct{ enabled bool }{enabled})
}

//go:nosplit
func (self class) IsSecret() bool { //gd:LineEdit.is_secret
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_secret, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetSecretCharacter(character String.Readable) { //gd:LineEdit.set_secret_character
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_secret_character, 0|(gdextension.SizeString<<4), &struct{ character gdextension.String }{pointers.Get(gd.InternalString(character))})
}

//go:nosplit
func (self class) GetSecretCharacter() String.Readable { //gd:LineEdit.get_secret_character
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_secret_character, gdextension.SizeString, &struct{}{})
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Executes a given action as defined in the [enum MenuItems] enum.
*/
//go:nosplit
func (self class) MenuOption(option int64) { //gd:LineEdit.menu_option
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.menu_option, 0|(gdextension.SizeInt<<4), &struct{ option int64 }{option})
}

/*
Returns the [PopupMenu] of this [LineEdit]. By default, this menu is displayed when right-clicking on the [LineEdit].
You can add custom menu items or remove standard ones. Make sure your IDs don't conflict with the standard ones (see [enum MenuItems]). For example:
[codeblocks]
[gdscript]
func _ready():
    var menu = get_menu()
    # Remove all items after "Redo".
    menu.item_count = menu.get_item_index(MENU_REDO) + 1
    # Add custom items.
    menu.add_separator()
    menu.add_item("Insert Date", MENU_MAX + 1)
    # Connect callback.
    menu.id_pressed.connect(_on_item_pressed)

func _on_item_pressed(id):
    if id == MENU_MAX + 1:
        insert_text_at_caret(Time.get_date_string_from_system())
[/gdscript]
[csharp]
public override void _Ready()
{
    var menu = GetMenu();
    // Remove all items after "Redo".
    menu.ItemCount = menu.GetItemIndex(LineEdit.MenuItems.Redo) + 1;
    // Add custom items.
    menu.AddSeparator();
    menu.AddItem("Insert Date", LineEdit.MenuItems.Max + 1);
    // Add event handler.
    menu.IdPressed += OnItemPressed;
}

public void OnItemPressed(int id)
{
    if (id == LineEdit.MenuItems.Max + 1)
    {
        InsertTextAtCaret(Time.GetDateStringFromSystem());
    }
}
[/csharp]
[/codeblocks]
[b]Warning:[/b] This is a required internal node, removing and freeing it may cause a crash. If you wish to hide it or any of its children, use their [member Window.visible] property.
*/
//go:nosplit
func (self class) GetMenu() [1]gdclass.PopupMenu { //gd:LineEdit.get_menu
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_menu, gdextension.SizeObject, &struct{}{})
	var ret = [1]gdclass.PopupMenu{gd.PointerLifetimeBoundTo[gdclass.PopupMenu](self.AsObject(), r_ret)}
	return ret
}

/*
Returns whether the menu is visible. Use this instead of [code]get_menu().visible[/code] to improve performance (so the creation of the menu is avoided).
*/
//go:nosplit
func (self class) IsMenuVisible() bool { //gd:LineEdit.is_menu_visible
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_menu_visible, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetContextMenuEnabled(enable bool) { //gd:LineEdit.set_context_menu_enabled
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_context_menu_enabled, 0|(gdextension.SizeBool<<4), &struct{ enable bool }{enable})
}

//go:nosplit
func (self class) IsContextMenuEnabled() bool { //gd:LineEdit.is_context_menu_enabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_context_menu_enabled, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetEmojiMenuEnabled(enable bool) { //gd:LineEdit.set_emoji_menu_enabled
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_emoji_menu_enabled, 0|(gdextension.SizeBool<<4), &struct{ enable bool }{enable})
}

//go:nosplit
func (self class) IsEmojiMenuEnabled() bool { //gd:LineEdit.is_emoji_menu_enabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_emoji_menu_enabled, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetVirtualKeyboardEnabled(enable bool) { //gd:LineEdit.set_virtual_keyboard_enabled
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_virtual_keyboard_enabled, 0|(gdextension.SizeBool<<4), &struct{ enable bool }{enable})
}

//go:nosplit
func (self class) IsVirtualKeyboardEnabled() bool { //gd:LineEdit.is_virtual_keyboard_enabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_virtual_keyboard_enabled, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetVirtualKeyboardType(atype VirtualKeyboardType) { //gd:LineEdit.set_virtual_keyboard_type
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_virtual_keyboard_type, 0|(gdextension.SizeInt<<4), &struct{ atype VirtualKeyboardType }{atype})
}

//go:nosplit
func (self class) GetVirtualKeyboardType() VirtualKeyboardType { //gd:LineEdit.get_virtual_keyboard_type
	var r_ret = gdextension.Call[VirtualKeyboardType](gd.ObjectChecked(self.AsObject()), methods.get_virtual_keyboard_type, gdextension.SizeInt, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetClearButtonEnabled(enable bool) { //gd:LineEdit.set_clear_button_enabled
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_clear_button_enabled, 0|(gdextension.SizeBool<<4), &struct{ enable bool }{enable})
}

//go:nosplit
func (self class) IsClearButtonEnabled() bool { //gd:LineEdit.is_clear_button_enabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_clear_button_enabled, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetShortcutKeysEnabled(enable bool) { //gd:LineEdit.set_shortcut_keys_enabled
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_shortcut_keys_enabled, 0|(gdextension.SizeBool<<4), &struct{ enable bool }{enable})
}

//go:nosplit
func (self class) IsShortcutKeysEnabled() bool { //gd:LineEdit.is_shortcut_keys_enabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_shortcut_keys_enabled, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetMiddleMousePasteEnabled(enable bool) { //gd:LineEdit.set_middle_mouse_paste_enabled
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_middle_mouse_paste_enabled, 0|(gdextension.SizeBool<<4), &struct{ enable bool }{enable})
}

//go:nosplit
func (self class) IsMiddleMousePasteEnabled() bool { //gd:LineEdit.is_middle_mouse_paste_enabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_middle_mouse_paste_enabled, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetSelectingEnabled(enable bool) { //gd:LineEdit.set_selecting_enabled
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_selecting_enabled, 0|(gdextension.SizeBool<<4), &struct{ enable bool }{enable})
}

//go:nosplit
func (self class) IsSelectingEnabled() bool { //gd:LineEdit.is_selecting_enabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_selecting_enabled, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetDeselectOnFocusLossEnabled(enable bool) { //gd:LineEdit.set_deselect_on_focus_loss_enabled
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_deselect_on_focus_loss_enabled, 0|(gdextension.SizeBool<<4), &struct{ enable bool }{enable})
}

//go:nosplit
func (self class) IsDeselectOnFocusLossEnabled() bool { //gd:LineEdit.is_deselect_on_focus_loss_enabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_deselect_on_focus_loss_enabled, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetDragAndDropSelectionEnabled(enable bool) { //gd:LineEdit.set_drag_and_drop_selection_enabled
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_drag_and_drop_selection_enabled, 0|(gdextension.SizeBool<<4), &struct{ enable bool }{enable})
}

//go:nosplit
func (self class) IsDragAndDropSelectionEnabled() bool { //gd:LineEdit.is_drag_and_drop_selection_enabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_drag_and_drop_selection_enabled, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetRightIcon(icon [1]gdclass.Texture2D) { //gd:LineEdit.set_right_icon
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_right_icon, 0|(gdextension.SizeObject<<4), &struct{ icon gdextension.Object }{gdextension.Object(gd.ObjectChecked(icon[0].AsObject()))})
}

//go:nosplit
func (self class) GetRightIcon() [1]gdclass.Texture2D { //gd:LineEdit.get_right_icon
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_right_icon, gdextension.SizeObject, &struct{}{})
	var ret = [1]gdclass.Texture2D{gd.PointerWithOwnershipTransferredToGo[gdclass.Texture2D](r_ret)}
	return ret
}

//go:nosplit
func (self class) SetFlat(enabled bool) { //gd:LineEdit.set_flat
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_flat, 0|(gdextension.SizeBool<<4), &struct{ enabled bool }{enabled})
}

//go:nosplit
func (self class) IsFlat() bool { //gd:LineEdit.is_flat
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_flat, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetSelectAllOnFocus(enabled bool) { //gd:LineEdit.set_select_all_on_focus
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_select_all_on_focus, 0|(gdextension.SizeBool<<4), &struct{ enabled bool }{enabled})
}

//go:nosplit
func (self class) IsSelectAllOnFocus() bool { //gd:LineEdit.is_select_all_on_focus
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_select_all_on_focus, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}
func (self Instance) OnTextChanged(cb func(new_text string), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("text_changed"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) TextChanged() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`TextChanged`))))
}

func (self Instance) OnTextChangeRejected(cb func(rejected_substring string), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("text_change_rejected"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) TextChangeRejected() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`TextChangeRejected`))))
}

func (self Instance) OnTextSubmitted(cb func(new_text string), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("text_submitted"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) TextSubmitted() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`TextSubmitted`))))
}

func (self Instance) OnEditingToggled(cb func(toggled_on bool), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("editing_toggled"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) EditingToggled() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`EditingToggled`))))
}

func (self class) AsLineEdit() Advanced         { return Advanced{pointers.AsA[gdclass.LineEdit](self[0])} }
func (self Instance) AsLineEdit() Instance      { return Instance{pointers.AsA[gdclass.LineEdit](self[0])} }
func (self *Extension[T]) AsLineEdit() Instance { return self.Super().AsLineEdit() }
func (self class) AsControl() Control.Advanced {
	return Control.Advanced{pointers.AsA[gdclass.Control](self[0])}
}
func (self *Extension[T]) AsControl() Control.Instance { return self.Super().AsControl() }
func (self Instance) AsControl() Control.Instance {
	return Control.Instance{pointers.AsA[gdclass.Control](self[0])}
}
func (self class) AsCanvasItem() CanvasItem.Advanced {
	return CanvasItem.Advanced{pointers.AsA[gdclass.CanvasItem](self[0])}
}
func (self *Extension[T]) AsCanvasItem() CanvasItem.Instance { return self.Super().AsCanvasItem() }
func (self Instance) AsCanvasItem() CanvasItem.Instance {
	return CanvasItem.Instance{pointers.AsA[gdclass.CanvasItem](self[0])}
}
func (self class) AsNode() Node.Advanced         { return Node.Advanced{pointers.AsA[gdclass.Node](self[0])} }
func (self *Extension[T]) AsNode() Node.Instance { return self.Super().AsNode() }
func (self Instance) AsNode() Node.Instance {
	return Node.Instance{pointers.AsA[gdclass.Node](self[0])}
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Control.Advanced(self.AsControl()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Control.Instance(self.AsControl()), name)
	}
}
func init() {
	gdclass.Register("LineEdit", func(ptr gd.Object) any { return Instance{pointers.AsA[gdclass.LineEdit](ptr)} })
}

type MenuItems int //gd:LineEdit.MenuItems

const (
	/*Cuts (copies and clears) the selected text.*/
	MenuCut MenuItems = 0
	/*Copies the selected text.*/
	MenuCopy MenuItems = 1
	/*Pastes the clipboard text over the selected text (or at the caret's position).
	  Non-printable escape characters are automatically stripped from the OS clipboard via [method String.strip_escapes].*/
	MenuPaste MenuItems = 2
	/*Erases the whole [LineEdit] text.*/
	MenuClear MenuItems = 3
	/*Selects the whole [LineEdit] text.*/
	MenuSelectAll MenuItems = 4
	/*Undoes the previous action.*/
	MenuUndo MenuItems = 5
	/*Reverse the last undo action.*/
	MenuRedo MenuItems = 6
	/*ID of "Text Writing Direction" submenu.*/
	MenuSubmenuTextDir MenuItems = 7
	/*Sets text direction to inherited.*/
	MenuDirInherited MenuItems = 8
	/*Sets text direction to automatic.*/
	MenuDirAuto MenuItems = 9
	/*Sets text direction to left-to-right.*/
	MenuDirLtr MenuItems = 10
	/*Sets text direction to right-to-left.*/
	MenuDirRtl MenuItems = 11
	/*Toggles control character display.*/
	MenuDisplayUcc MenuItems = 12
	/*ID of "Insert Control Character" submenu.*/
	MenuSubmenuInsertUcc MenuItems = 13
	/*Inserts left-to-right mark (LRM) character.*/
	MenuInsertLrm MenuItems = 14
	/*Inserts right-to-left mark (RLM) character.*/
	MenuInsertRlm MenuItems = 15
	/*Inserts start of left-to-right embedding (LRE) character.*/
	MenuInsertLre MenuItems = 16
	/*Inserts start of right-to-left embedding (RLE) character.*/
	MenuInsertRle MenuItems = 17
	/*Inserts start of left-to-right override (LRO) character.*/
	MenuInsertLro MenuItems = 18
	/*Inserts start of right-to-left override (RLO) character.*/
	MenuInsertRlo MenuItems = 19
	/*Inserts pop direction formatting (PDF) character.*/
	MenuInsertPdf MenuItems = 20
	/*Inserts Arabic letter mark (ALM) character.*/
	MenuInsertAlm MenuItems = 21
	/*Inserts left-to-right isolate (LRI) character.*/
	MenuInsertLri MenuItems = 22
	/*Inserts right-to-left isolate (RLI) character.*/
	MenuInsertRli MenuItems = 23
	/*Inserts first strong isolate (FSI) character.*/
	MenuInsertFsi MenuItems = 24
	/*Inserts pop direction isolate (PDI) character.*/
	MenuInsertPdi MenuItems = 25
	/*Inserts zero width joiner (ZWJ) character.*/
	MenuInsertZwj MenuItems = 26
	/*Inserts zero width non-joiner (ZWNJ) character.*/
	MenuInsertZwnj MenuItems = 27
	/*Inserts word joiner (WJ) character.*/
	MenuInsertWj MenuItems = 28
	/*Inserts soft hyphen (SHY) character.*/
	MenuInsertShy MenuItems = 29
	/*Opens system emoji and symbol picker.*/
	MenuEmojiAndSymbol MenuItems = 30
	/*Represents the size of the [enum MenuItems] enum.*/
	MenuMax MenuItems = 31
)

type VirtualKeyboardType int //gd:LineEdit.VirtualKeyboardType

const (
	/*Default text virtual keyboard.*/
	KeyboardTypeDefault VirtualKeyboardType = 0
	/*Multiline virtual keyboard.*/
	KeyboardTypeMultiline VirtualKeyboardType = 1
	/*Virtual number keypad, useful for PIN entry.*/
	KeyboardTypeNumber VirtualKeyboardType = 2
	/*Virtual number keypad, useful for entering fractional numbers.*/
	KeyboardTypeNumberDecimal VirtualKeyboardType = 3
	/*Virtual phone number keypad.*/
	KeyboardTypePhone VirtualKeyboardType = 4
	/*Virtual keyboard with additional keys to assist with typing email addresses.*/
	KeyboardTypeEmailAddress VirtualKeyboardType = 5
	/*Virtual keyboard for entering a password. On most platforms, this should disable autocomplete and autocapitalization.
	  [b]Note:[/b] This is not supported on Web. Instead, this behaves identically to [constant KEYBOARD_TYPE_DEFAULT].*/
	KeyboardTypePassword VirtualKeyboardType = 6
	/*Virtual keyboard with additional keys to assist with typing URLs.*/
	KeyboardTypeUrl VirtualKeyboardType = 7
)
