// Code generated by the generate package DO NOT EDIT

// Package XRAnchor3D provides methods for working with XRAnchor3D object instances.
package XRAnchor3D

import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/variant/Signal"
import "graphics.gd/classdb/Node"
import "graphics.gd/classdb/Node3D"
import "graphics.gd/classdb/XRNode3D"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/Plane"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"
import "graphics.gd/variant/Vector3"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Signal.Any
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
The [XRAnchor3D] point is an [XRNode3D] that maps a real world location identified by the AR platform to a position within the game world. For example, as long as plane detection in ARKit is on, ARKit will identify and update the position of planes (tables, floors, etc.) and create anchors for them.
This node is mapped to one of the anchors through its unique ID. When you receive a signal that a new anchor is available, you should add this node to your scene for that anchor. You can predefine nodes and set the ID; the nodes will simply remain on 0,0,0 until a plane is recognized.
Keep in mind that, as long as plane detection is enabled, the size, placing and orientation of an anchor will be updated as the detection logic learns more about the real world out there especially if only part of the surface is in view.
*/
type Instance [1]gdclass.XRAnchor3D

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	get_size  gdextension.MethodForClass `hash:"3360562783"`
	get_plane gdextension.MethodForClass `hash:"2753500971"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("XRAnchor3D")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		gdextension.Free(gdextension.TypeStringName, &sname)
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsXRAnchor3D() Instance
}

/*
Returns the estimated size of the plane that was detected. Say when the anchor relates to a table in the real world, this is the estimated size of the surface of that table.
*/
func (self Instance) GetSize() Vector3.XYZ { //gd:XRAnchor3D.get_size
	return Vector3.XYZ(Advanced(self).GetSize())
}

/*
Returns a plane aligned with our anchor; handy for intersection testing.
*/
func (self Instance) GetPlane() Plane.NormalD { //gd:XRAnchor3D.get_plane
	return Plane.NormalD(Advanced(self).GetPlane())
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.XRAnchor3D

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = pointers.AsA[gdclass.XRAnchor3D](obj[0])
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = pointers.AsA[gdclass.XRAnchor3D](obj[0])
		return true
	}
	return false
}
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }
func (self *Extension[T]) AsObject() [1]gd.Object { return self.Super().AsObject() }
func New() Instance {
	if !gd.Linked {
		var placeholder = Instance([1]gdclass.XRAnchor3D{pointers.Add[gdclass.XRAnchor3D]([3]uint64{})})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(pointers.AsA[gd.Object](placeholder[0]), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	casted := Instance([1]gdclass.XRAnchor3D{pointers.New[gdclass.XRAnchor3D]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})})
	casted.AsObject()[0].Notification(0, false)
	return casted
}

/*
Returns the estimated size of the plane that was detected. Say when the anchor relates to a table in the real world, this is the estimated size of the surface of that table.
*/
//go:nosplit
func (self class) GetSize() Vector3.XYZ { //gd:XRAnchor3D.get_size
	var r_ret = gdextension.Call[Vector3.XYZ](gd.ObjectChecked(self.AsObject()), methods.get_size, gdextension.SizeVector3, &struct{}{})
	var ret = r_ret
	return ret
}

/*
Returns a plane aligned with our anchor; handy for intersection testing.
*/
//go:nosplit
func (self class) GetPlane() Plane.NormalD { //gd:XRAnchor3D.get_plane
	var r_ret = gdextension.Call[Plane.NormalD](gd.ObjectChecked(self.AsObject()), methods.get_plane, gdextension.SizePlane, &struct{}{})
	var ret = r_ret
	return ret
}
func (self class) AsXRAnchor3D() Advanced { return Advanced{pointers.AsA[gdclass.XRAnchor3D](self[0])} }
func (self Instance) AsXRAnchor3D() Instance {
	return Instance{pointers.AsA[gdclass.XRAnchor3D](self[0])}
}
func (self *Extension[T]) AsXRAnchor3D() Instance { return self.Super().AsXRAnchor3D() }
func (self class) AsXRNode3D() XRNode3D.Advanced {
	return XRNode3D.Advanced{pointers.AsA[gdclass.XRNode3D](self[0])}
}
func (self *Extension[T]) AsXRNode3D() XRNode3D.Instance { return self.Super().AsXRNode3D() }
func (self Instance) AsXRNode3D() XRNode3D.Instance {
	return XRNode3D.Instance{pointers.AsA[gdclass.XRNode3D](self[0])}
}
func (self class) AsNode3D() Node3D.Advanced {
	return Node3D.Advanced{pointers.AsA[gdclass.Node3D](self[0])}
}
func (self *Extension[T]) AsNode3D() Node3D.Instance { return self.Super().AsNode3D() }
func (self Instance) AsNode3D() Node3D.Instance {
	return Node3D.Instance{pointers.AsA[gdclass.Node3D](self[0])}
}
func (self class) AsNode() Node.Advanced         { return Node.Advanced{pointers.AsA[gdclass.Node](self[0])} }
func (self *Extension[T]) AsNode() Node.Instance { return self.Super().AsNode() }
func (self Instance) AsNode() Node.Instance {
	return Node.Instance{pointers.AsA[gdclass.Node](self[0])}
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(XRNode3D.Advanced(self.AsXRNode3D()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(XRNode3D.Instance(self.AsXRNode3D()), name)
	}
}
func init() {
	gdclass.Register("XRAnchor3D", func(ptr gd.Object) any { return Instance{pointers.AsA[gdclass.XRAnchor3D](ptr)} })
}
