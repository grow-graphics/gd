// Code generated by the generate package DO NOT EDIT

// Package GLTFObjectModelProperty provides methods for working with GLTFObjectModelProperty object instances.
package GLTFObjectModelProperty

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/Expression"
import "graphics.gd/classdb/GLTFAccessor"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
GLTFObjectModelProperty defines a mapping between a property in the glTF object model and a NodePath in the Godot scene tree. This can be used to animate properties in a glTF file using the [code]KHR_animation_pointer[/code] extension, or to access them through an engine-agnostic script such as a behavior graph as defined by the [code]KHR_interactivity[/code] extension.
The glTF property is identified by JSON pointer(s) stored in [member json_pointers], while the Godot property it maps to is defined by [member node_paths]. In most cases [member json_pointers] and [member node_paths] will each only have one item, but in some cases a single glTF JSON pointer will map to multiple Godot properties, or a single Godot property will be mapped to multiple glTF JSON pointers, or it might be a many-to-many relationship.
[Expression] objects can be used to define conversions between the data, such as when glTF defines an angle in radians and Godot uses degrees. The [member object_model_type] property defines the type of data stored in the glTF file as defined by the object model, see [enum GLTFObjectModelType] for possible values.
*/
type Instance [1]gdclass.GLTFObjectModelProperty

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	append_node_path             gdextension.MethodForClass `hash:"1348162250"`
	append_path_to_property      gdextension.MethodForClass `hash:"1331931644"`
	get_accessor_type            gdextension.MethodForClass `hash:"1998183368"`
	get_gltf_to_godot_expression gdextension.MethodForClass `hash:"2240072449"`
	set_gltf_to_godot_expression gdextension.MethodForClass `hash:"1815845073"`
	get_godot_to_gltf_expression gdextension.MethodForClass `hash:"2240072449"`
	set_godot_to_gltf_expression gdextension.MethodForClass `hash:"1815845073"`
	get_node_paths               gdextension.MethodForClass `hash:"3995934104"`
	has_node_paths               gdextension.MethodForClass `hash:"36873697"`
	set_node_paths               gdextension.MethodForClass `hash:"381264803"`
	get_object_model_type        gdextension.MethodForClass `hash:"1094778507"`
	set_object_model_type        gdextension.MethodForClass `hash:"4108684086"`
	get_json_pointers            gdextension.MethodForClass `hash:"3995934104"`
	has_json_pointers            gdextension.MethodForClass `hash:"36873697"`
	set_json_pointers            gdextension.MethodForClass `hash:"381264803"`
	get_variant_type             gdextension.MethodForClass `hash:"3416842102"`
	set_variant_type             gdextension.MethodForClass `hash:"2887708385"`
	set_types                    gdextension.MethodForClass `hash:"4150728237"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("GLTFObjectModelProperty")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		gdextension.Free(gdextension.TypeStringName, &sname)
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsGLTFObjectModelProperty() Instance
}

/*
Appends a [NodePath] to [member node_paths]. This can be used by [GLTFDocumentExtension] classes to define how a glTF object model property maps to a Godot property, or multiple Godot properties. Prefer using [method append_path_to_property] for simple cases. Be sure to also call [method set_types] once (the order does not matter).
*/
func (self Instance) AppendNodePath(node_path string) { //gd:GLTFObjectModelProperty.append_node_path
	Advanced(self).AppendNodePath(Path.ToNode(String.New(node_path)))
}

/*
High-level wrapper over [method append_node_path] that handles the most common cases. It constructs a new [NodePath] using [param node_path] as a base and appends [param prop_name] to the subpath. Be sure to also call [method set_types] once (the order does not matter).
*/
func (self Instance) AppendPathToProperty(node_path string, prop_name string) { //gd:GLTFObjectModelProperty.append_path_to_property
	Advanced(self).AppendPathToProperty(Path.ToNode(String.New(node_path)), String.Name(String.New(prop_name)))
}

/*
The GLTF accessor type associated with this property's [member object_model_type]. See [member GLTFAccessor.accessor_type] for possible values, and see [enum GLTFObjectModelType] for how the object model type maps to accessor types.
*/
func (self Instance) GetAccessorType() GLTFAccessor.GLTFAccessorType { //gd:GLTFObjectModelProperty.get_accessor_type
	return GLTFAccessor.GLTFAccessorType(Advanced(self).GetAccessorType())
}

/*
Returns [code]true[/code] if [member node_paths] is not empty. This is used during import to determine if a [GLTFObjectModelProperty] can handle converting a glTF object model property to a Godot property.
*/
func (self Instance) HasNodePaths() bool { //gd:GLTFObjectModelProperty.has_node_paths
	return bool(Advanced(self).HasNodePaths())
}

/*
Returns [code]true[/code] if [member json_pointers] is not empty. This is used during export to determine if a [GLTFObjectModelProperty] can handle converting a Godot property to a glTF object model property.
*/
func (self Instance) HasJsonPointers() bool { //gd:GLTFObjectModelProperty.has_json_pointers
	return bool(Advanced(self).HasJsonPointers())
}

/*
Sets the [member variant_type] and [member object_model_type] properties. This is a convenience method to set both properties at once, since they are almost always known at the same time. This method should be called once. Calling it again with the same values will have no effect.
*/
func (self Instance) SetTypes(variant_type variant.Type, obj_model_type GLTFObjectModelType) { //gd:GLTFObjectModelProperty.set_types
	Advanced(self).SetTypes(variant_type, obj_model_type)
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.GLTFObjectModelProperty

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.GLTFObjectModelProperty)(unsafe.Pointer(&obj))
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.GLTFObjectModelProperty)(unsafe.Pointer(&obj))
		return true
	}
	return false
}

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {

	if !gd.Linked {
		var placeholder Instance
		*(*gd.Object)(unsafe.Pointer(&placeholder)) = pointers.Add[gd.Object]([3]uint64{})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(*(*gd.Object)(unsafe.Pointer(&placeholder)), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	object := [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})}
	casted := Instance{*(*gdclass.GLTFObjectModelProperty)(unsafe.Pointer(&object))}
	casted.AsRefCounted()[0].InitRef()
	object[0].Notification(0, false)
	return casted
}

func (self Instance) GltfToGodotExpression() Expression.Instance {
	return Expression.Instance(class(self).GetGltfToGodotExpression())
}

func (self Instance) SetGltfToGodotExpression(value Expression.Instance) {
	class(self).SetGltfToGodotExpression(value)
}

func (self Instance) GodotToGltfExpression() Expression.Instance {
	return Expression.Instance(class(self).GetGodotToGltfExpression())
}

func (self Instance) SetGodotToGltfExpression(value Expression.Instance) {
	class(self).SetGodotToGltfExpression(value)
}

func (self Instance) NodePaths() []string {
	return []string(gd.ArrayAs[[]string](gd.InternalArray(class(self).GetNodePaths())))
}

func (self Instance) SetNodePaths(value []string) {
	class(self).SetNodePaths(gd.ArrayFromSlice[Array.Contains[Path.ToNode]](value))
}

func (self Instance) ObjectModelType() GLTFObjectModelType {
	return GLTFObjectModelType(class(self).GetObjectModelType())
}

func (self Instance) SetObjectModelType(value GLTFObjectModelType) {
	class(self).SetObjectModelType(value)
}

func (self Instance) JsonPointers() [][]string {
	return [][]string(gd.ArrayAs[[][]string](gd.InternalArray(class(self).GetJsonPointers())))
}

func (self Instance) SetJsonPointers(value [][]string) {
	class(self).SetJsonPointers(gd.ArrayFromSlice[Array.Contains[Packed.Strings]](value))
}

func (self Instance) VariantType() variant.Type {
	return variant.Type(class(self).GetVariantType())
}

func (self Instance) SetVariantType(value variant.Type) {
	class(self).SetVariantType(value)
}

/*
Appends a [NodePath] to [member node_paths]. This can be used by [GLTFDocumentExtension] classes to define how a glTF object model property maps to a Godot property, or multiple Godot properties. Prefer using [method append_path_to_property] for simple cases. Be sure to also call [method set_types] once (the order does not matter).
*/
//go:nosplit
func (self class) AppendNodePath(node_path Path.ToNode) { //gd:GLTFObjectModelProperty.append_node_path
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.append_node_path, 0|(gdextension.SizeNodePath<<4), unsafe.Pointer(&struct{ node_path gdextension.NodePath }{pointers.Get(gd.InternalNodePath(node_path))}))
}

/*
High-level wrapper over [method append_node_path] that handles the most common cases. It constructs a new [NodePath] using [param node_path] as a base and appends [param prop_name] to the subpath. Be sure to also call [method set_types] once (the order does not matter).
*/
//go:nosplit
func (self class) AppendPathToProperty(node_path Path.ToNode, prop_name String.Name) { //gd:GLTFObjectModelProperty.append_path_to_property
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.append_path_to_property, 0|(gdextension.SizeNodePath<<4)|(gdextension.SizeStringName<<8), unsafe.Pointer(&struct {
		node_path gdextension.NodePath
		prop_name gdextension.StringName
	}{pointers.Get(gd.InternalNodePath(node_path)), pointers.Get(gd.InternalStringName(prop_name))}))
}

/*
The GLTF accessor type associated with this property's [member object_model_type]. See [member GLTFAccessor.accessor_type] for possible values, and see [enum GLTFObjectModelType] for how the object model type maps to accessor types.
*/
//go:nosplit
func (self class) GetAccessorType() GLTFAccessor.GLTFAccessorType { //gd:GLTFObjectModelProperty.get_accessor_type
	var r_ret = gdextension.Call[GLTFAccessor.GLTFAccessorType](gd.ObjectChecked(self.AsObject()), methods.get_accessor_type, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) GetGltfToGodotExpression() [1]gdclass.Expression { //gd:GLTFObjectModelProperty.get_gltf_to_godot_expression
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_gltf_to_godot_expression, gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.Expression{gd.PointerWithOwnershipTransferredToGo[gdclass.Expression](r_ret)}
	return ret
}

//go:nosplit
func (self class) SetGltfToGodotExpression(gltf_to_godot_expr [1]gdclass.Expression) { //gd:GLTFObjectModelProperty.set_gltf_to_godot_expression
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_gltf_to_godot_expression, 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ gltf_to_godot_expr gdextension.Object }{gdextension.Object(gd.ObjectChecked(gltf_to_godot_expr[0].AsObject()))}))
}

//go:nosplit
func (self class) GetGodotToGltfExpression() [1]gdclass.Expression { //gd:GLTFObjectModelProperty.get_godot_to_gltf_expression
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_godot_to_gltf_expression, gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.Expression{gd.PointerWithOwnershipTransferredToGo[gdclass.Expression](r_ret)}
	return ret
}

//go:nosplit
func (self class) SetGodotToGltfExpression(godot_to_gltf_expr [1]gdclass.Expression) { //gd:GLTFObjectModelProperty.set_godot_to_gltf_expression
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_godot_to_gltf_expression, 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ godot_to_gltf_expr gdextension.Object }{gdextension.Object(gd.ObjectChecked(godot_to_gltf_expr[0].AsObject()))}))
}

//go:nosplit
func (self class) GetNodePaths() Array.Contains[Path.ToNode] { //gd:GLTFObjectModelProperty.get_node_paths
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), methods.get_node_paths, gdextension.SizeArray, unsafe.Pointer(&struct{}{}))
	var ret = Array.Through(gd.ArrayProxy[Path.ToNode]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

/*
Returns [code]true[/code] if [member node_paths] is not empty. This is used during import to determine if a [GLTFObjectModelProperty] can handle converting a glTF object model property to a Godot property.
*/
//go:nosplit
func (self class) HasNodePaths() bool { //gd:GLTFObjectModelProperty.has_node_paths
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.has_node_paths, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetNodePaths(node_paths Array.Contains[Path.ToNode]) { //gd:GLTFObjectModelProperty.set_node_paths
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_node_paths, 0|(gdextension.SizeArray<<4), unsafe.Pointer(&struct{ node_paths gdextension.Array }{pointers.Get(gd.InternalArray(node_paths))}))
}

//go:nosplit
func (self class) GetObjectModelType() GLTFObjectModelType { //gd:GLTFObjectModelProperty.get_object_model_type
	var r_ret = gdextension.Call[GLTFObjectModelType](gd.ObjectChecked(self.AsObject()), methods.get_object_model_type, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetObjectModelType(atype GLTFObjectModelType) { //gd:GLTFObjectModelProperty.set_object_model_type
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_object_model_type, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ atype GLTFObjectModelType }{atype}))
}

//go:nosplit
func (self class) GetJsonPointers() Array.Contains[Packed.Strings] { //gd:GLTFObjectModelProperty.get_json_pointers
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), methods.get_json_pointers, gdextension.SizeArray, unsafe.Pointer(&struct{}{}))
	var ret = Array.Through(gd.ArrayProxy[Packed.Strings]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

/*
Returns [code]true[/code] if [member json_pointers] is not empty. This is used during export to determine if a [GLTFObjectModelProperty] can handle converting a Godot property to a glTF object model property.
*/
//go:nosplit
func (self class) HasJsonPointers() bool { //gd:GLTFObjectModelProperty.has_json_pointers
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.has_json_pointers, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetJsonPointers(json_pointers Array.Contains[Packed.Strings]) { //gd:GLTFObjectModelProperty.set_json_pointers
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_json_pointers, 0|(gdextension.SizeArray<<4), unsafe.Pointer(&struct{ json_pointers gdextension.Array }{pointers.Get(gd.InternalArray(json_pointers))}))
}

//go:nosplit
func (self class) GetVariantType() variant.Type { //gd:GLTFObjectModelProperty.get_variant_type
	var r_ret = gdextension.Call[variant.Type](gd.ObjectChecked(self.AsObject()), methods.get_variant_type, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetVariantType(variant_type variant.Type) { //gd:GLTFObjectModelProperty.set_variant_type
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_variant_type, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ variant_type variant.Type }{variant_type}))
}

/*
Sets the [member variant_type] and [member object_model_type] properties. This is a convenience method to set both properties at once, since they are almost always known at the same time. This method should be called once. Calling it again with the same values will have no effect.
*/
//go:nosplit
func (self class) SetTypes(variant_type variant.Type, obj_model_type GLTFObjectModelType) { //gd:GLTFObjectModelProperty.set_types
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_types, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		variant_type   variant.Type
		obj_model_type GLTFObjectModelType
	}{variant_type, obj_model_type}))
}
func (self class) AsGLTFObjectModelProperty() Advanced { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsGLTFObjectModelProperty() Instance {
	return *((*Instance)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsGLTFObjectModelProperty() Instance {
	return self.Super().AsGLTFObjectModelProperty()
}
func (self class) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsRefCounted() [1]gd.RefCounted { return self.Super().AsRefCounted() }
func (self Instance) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(RefCounted.Advanced(self.AsRefCounted()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(RefCounted.Instance(self.AsRefCounted()), name)
	}
}
func init() {
	gdclass.Register("GLTFObjectModelProperty", func(ptr gd.Object) any { return *(*Instance)(unsafe.Pointer(&ptr)) })
}

type GLTFObjectModelType int //gd:GLTFObjectModelProperty.GLTFObjectModelType

const (
	/*Unknown or not set object model type. If the object model type is set to this value, the real type still needs to be determined.*/
	GltfObjectModelTypeUnknown GLTFObjectModelType = 0
	/*Object model type "bool". Represented in the glTF JSON as a boolean, and encoded in a [GLTFAccessor] as "SCALAR". When encoded in an accessor, a value of [code]0[/code] is [code]false[/code], and any other value is [code]true[/code].*/
	GltfObjectModelTypeBool GLTFObjectModelType = 1
	/*Object model type "float". Represented in the glTF JSON as a number, and encoded in a [GLTFAccessor] as "SCALAR".*/
	GltfObjectModelTypeFloat GLTFObjectModelType = 2
	/*Object model type "float[lb][rb]". Represented in the glTF JSON as an array of numbers, and encoded in a [GLTFAccessor] as "SCALAR".*/
	GltfObjectModelTypeFloatArray GLTFObjectModelType = 3
	/*Object model type "float2". Represented in the glTF JSON as an array of two numbers, and encoded in a [GLTFAccessor] as "VEC2".*/
	GltfObjectModelTypeFloat2 GLTFObjectModelType = 4
	/*Object model type "float3". Represented in the glTF JSON as an array of three numbers, and encoded in a [GLTFAccessor] as "VEC3".*/
	GltfObjectModelTypeFloat3 GLTFObjectModelType = 5
	/*Object model type "float4". Represented in the glTF JSON as an array of four numbers, and encoded in a [GLTFAccessor] as "VEC4".*/
	GltfObjectModelTypeFloat4 GLTFObjectModelType = 6
	/*Object model type "float2x2". Represented in the glTF JSON as an array of four numbers, and encoded in a [GLTFAccessor] as "MAT2".*/
	GltfObjectModelTypeFloat2x2 GLTFObjectModelType = 7
	/*Object model type "float3x3". Represented in the glTF JSON as an array of nine numbers, and encoded in a [GLTFAccessor] as "MAT3".*/
	GltfObjectModelTypeFloat3x3 GLTFObjectModelType = 8
	/*Object model type "float4x4". Represented in the glTF JSON as an array of sixteen numbers, and encoded in a [GLTFAccessor] as "MAT4".*/
	GltfObjectModelTypeFloat4x4 GLTFObjectModelType = 9
	/*Object model type "int". Represented in the glTF JSON as a number, and encoded in a [GLTFAccessor] as "SCALAR". The range of values is limited to signed integers. For [code]KHR_interactivity[/code], only 32-bit integers are supported.*/
	GltfObjectModelTypeInt GLTFObjectModelType = 10
)
