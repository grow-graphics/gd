// Code generated by the generate package DO NOT EDIT

// Package SurfaceTool provides methods for working with SurfaceTool object instances.
package SurfaceTool

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/ArrayMesh"
import "graphics.gd/classdb/Material"
import "graphics.gd/classdb/Mesh"
import "graphics.gd/variant/AABB"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Color"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/Plane"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"
import "graphics.gd/variant/Transform3D"
import "graphics.gd/variant/Vector2"
import "graphics.gd/variant/Vector3"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
The [SurfaceTool] is used to construct a [Mesh] by specifying vertex attributes individually. It can be used to construct a [Mesh] from a script. All properties except indices need to be added before calling [method add_vertex]. For example, to add vertex colors and UVs:
[codeblocks]
[gdscript]
var st = SurfaceTool.new()
st.begin(Mesh.PRIMITIVE_TRIANGLES)
st.set_color(Color(1, 0, 0))
st.set_uv(Vector2(0, 0))
st.add_vertex(Vector3(0, 0, 0))
[/gdscript]
[csharp]
var st = new SurfaceTool();
st.Begin(Mesh.PrimitiveType.Triangles);
st.SetColor(new Color(1, 0, 0));
st.SetUV(new Vector2(0, 0));
st.AddVertex(new Vector3(0, 0, 0));
[/csharp]
[/codeblocks]
The above [SurfaceTool] now contains one vertex of a triangle which has a UV coordinate and a specified [Color]. If another vertex were added without calling [method set_uv] or [method set_color], then the last values would be used.
Vertex attributes must be passed [b]before[/b] calling [method add_vertex]. Failure to do so will result in an error when committing the vertex information to a mesh.
Additionally, the attributes used before the first vertex is added determine the format of the mesh. For example, if you only add UVs to the first vertex, you cannot add color to any of the subsequent vertices.
See also [ArrayMesh], [ImmediateMesh] and [MeshDataTool] for procedural geometry generation.
[b]Note:[/b] Godot uses clockwise [url=https://learnopengl.com/Advanced-OpenGL/Face-culling]winding order[/url] for front faces of triangle primitive modes.
*/
type Instance [1]gdclass.SurfaceTool

func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

type Expanded [1]gdclass.SurfaceTool

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsSurfaceTool() Instance
}

/*
Set to [constant SKIN_8_WEIGHTS] to indicate that up to 8 bone influences per vertex may be used.
By default, only 4 bone influences are used ([constant SKIN_4_WEIGHTS]).
[b]Note:[/b] This function takes an enum, not the exact number of weights.
*/
func (self Instance) SetSkinWeightCount(count SkinWeightCount) { //gd:SurfaceTool.set_skin_weight_count
	Advanced(self).SetSkinWeightCount(count)
}

/*
By default, returns [constant SKIN_4_WEIGHTS] to indicate only 4 bone influences per vertex are used.
Returns [constant SKIN_8_WEIGHTS] if up to 8 influences are used.
[b]Note:[/b] This function returns an enum, not the exact number of weights.
*/
func (self Instance) GetSkinWeightCount() SkinWeightCount { //gd:SurfaceTool.get_skin_weight_count
	return SkinWeightCount(Advanced(self).GetSkinWeightCount())
}

/*
Sets the color format for this custom [param channel_index]. Use [constant CUSTOM_MAX] to disable.
Must be invoked after [method begin] and should be set before [method commit] or [method commit_to_arrays].
*/
func (self Instance) SetCustomFormat(channel_index int, format CustomFormat) { //gd:SurfaceTool.set_custom_format
	Advanced(self).SetCustomFormat(int64(channel_index), format)
}

/*
Returns the format for custom [param channel_index] (currently up to 4). Returns [constant CUSTOM_MAX] if this custom channel is unused.
*/
func (self Instance) GetCustomFormat(channel_index int) CustomFormat { //gd:SurfaceTool.get_custom_format
	return CustomFormat(Advanced(self).GetCustomFormat(int64(channel_index)))
}

/*
Called before adding any vertices. Takes the primitive type as an argument (e.g. [constant Mesh.PRIMITIVE_TRIANGLES]).
*/
func (self Instance) Begin(primitive Mesh.PrimitiveType) { //gd:SurfaceTool.begin
	Advanced(self).Begin(primitive)
}

/*
Specifies the position of current vertex. Should be called after specifying other vertex properties (e.g. Color, UV).
*/
func (self Instance) AddVertex(vertex Vector3.XYZ) { //gd:SurfaceTool.add_vertex
	Advanced(self).AddVertex(Vector3.XYZ(vertex))
}

/*
Specifies a [Color] to use for the [i]next[/i] vertex. If every vertex needs to have this information set and you fail to submit it for the first vertex, this information may not be used at all.
[b]Note:[/b] The material must have [member BaseMaterial3D.vertex_color_use_as_albedo] enabled for the vertex color to be visible.
*/
func (self Instance) SetColor(color Color.RGBA) { //gd:SurfaceTool.set_color
	Advanced(self).SetColor(Color.RGBA(color))
}

/*
Specifies a normal to use for the [i]next[/i] vertex. If every vertex needs to have this information set and you fail to submit it for the first vertex, this information may not be used at all.
*/
func (self Instance) SetNormal(normal Vector3.XYZ) { //gd:SurfaceTool.set_normal
	Advanced(self).SetNormal(Vector3.XYZ(normal))
}

/*
Specifies a tangent to use for the [i]next[/i] vertex. If every vertex needs to have this information set and you fail to submit it for the first vertex, this information may not be used at all.
*/
func (self Instance) SetTangent(tangent Plane.NormalD) { //gd:SurfaceTool.set_tangent
	Advanced(self).SetTangent(Plane.NormalD(tangent))
}

/*
Specifies a set of UV coordinates to use for the [i]next[/i] vertex. If every vertex needs to have this information set and you fail to submit it for the first vertex, this information may not be used at all.
*/
func (self Instance) SetUv(uv Vector2.XY) { //gd:SurfaceTool.set_uv
	Advanced(self).SetUv(Vector2.XY(uv))
}

/*
Specifies an optional second set of UV coordinates to use for the [i]next[/i] vertex. If every vertex needs to have this information set and you fail to submit it for the first vertex, this information may not be used at all.
*/
func (self Instance) SetUv2(uv2 Vector2.XY) { //gd:SurfaceTool.set_uv2
	Advanced(self).SetUv2(Vector2.XY(uv2))
}

/*
Specifies an array of bones to use for the [i]next[/i] vertex. [param bones] must contain 4 integers.
*/
func (self Instance) SetBones(bones []int32) { //gd:SurfaceTool.set_bones
	Advanced(self).SetBones(Packed.New(bones...))
}

/*
Specifies weight values to use for the [i]next[/i] vertex. [param weights] must contain 4 values. If every vertex needs to have this information set and you fail to submit it for the first vertex, this information may not be used at all.
*/
func (self Instance) SetWeights(weights []float32) { //gd:SurfaceTool.set_weights
	Advanced(self).SetWeights(Packed.New(weights...))
}

/*
Sets the custom value on this vertex for [param channel_index].
[method set_custom_format] must be called first for this [param channel_index]. Formats which are not RGBA will ignore other color channels.
*/
func (self Instance) SetCustom(channel_index int, custom_color Color.RGBA) { //gd:SurfaceTool.set_custom
	Advanced(self).SetCustom(int64(channel_index), Color.RGBA(custom_color))
}

/*
Specifies the smooth group to use for the [i]next[/i] vertex. If this is never called, all vertices will have the default smooth group of [code]0[/code] and will be smoothed with adjacent vertices of the same group. To produce a mesh with flat normals, set the smooth group to [code]-1[/code].
[b]Note:[/b] This function actually takes a [code]uint32_t[/code], so C# users should use [code]uint32.MaxValue[/code] instead of [code]-1[/code] to produce a mesh with flat normals.
*/
func (self Instance) SetSmoothGroup(index int) { //gd:SurfaceTool.set_smooth_group
	Advanced(self).SetSmoothGroup(int64(index))
}

/*
Inserts a triangle fan made of array data into [Mesh] being constructed.
Requires the primitive type be set to [constant Mesh.PRIMITIVE_TRIANGLES].
*/
func (self Instance) AddTriangleFan(vertices []Vector3.XYZ) { //gd:SurfaceTool.add_triangle_fan
	Advanced(self).AddTriangleFan(Packed.New(vertices...), Packed.New[Vector2.XY](), Packed.New([1][]Color.RGBA{}[0]...), Packed.New[Vector2.XY](), Packed.New([1][]Vector3.XYZ{}[0]...), gd.ArrayFromSlice[Array.Contains[Plane.NormalD]]([1][]Plane.NormalD{}[0]))
}

/*
Inserts a triangle fan made of array data into [Mesh] being constructed.
Requires the primitive type be set to [constant Mesh.PRIMITIVE_TRIANGLES].
*/
func (self Expanded) AddTriangleFan(vertices []Vector3.XYZ, uvs []Vector2.XY, colors []Color.RGBA, uv2s []Vector2.XY, normals []Vector3.XYZ, tangents []Plane.NormalD) { //gd:SurfaceTool.add_triangle_fan
	Advanced(self).AddTriangleFan(Packed.New(vertices...), Packed.New(uvs...), Packed.New(colors...), Packed.New(uv2s...), Packed.New(normals...), gd.ArrayFromSlice[Array.Contains[Plane.NormalD]](tangents))
}

/*
Adds a vertex to index array if you are using indexed vertices. Does not need to be called before adding vertices.
*/
func (self Instance) AddIndex(index int) { //gd:SurfaceTool.add_index
	Advanced(self).AddIndex(int64(index))
}

/*
Shrinks the vertex array by creating an index array. This can improve performance by avoiding vertex reuse.
*/
func (self Instance) Index() { //gd:SurfaceTool.index
	Advanced(self).Index()
}

/*
Removes the index array by expanding the vertex array.
*/
func (self Instance) Deindex() { //gd:SurfaceTool.deindex
	Advanced(self).Deindex()
}

/*
Generates normals from vertices so you do not have to do it manually. If [param flip] is [code]true[/code], the resulting normals will be inverted. [method generate_normals] should be called [i]after[/i] generating geometry and [i]before[/i] committing the mesh using [method commit] or [method commit_to_arrays]. For correct display of normal-mapped surfaces, you will also have to generate tangents using [method generate_tangents].
[b]Note:[/b] [method generate_normals] only works if the primitive type is set to [constant Mesh.PRIMITIVE_TRIANGLES].
[b]Note:[/b] [method generate_normals] takes smooth groups into account. To generate smooth normals, set the smooth group to a value greater than or equal to [code]0[/code] using [method set_smooth_group] or leave the smooth group at the default of [code]0[/code]. To generate flat normals, set the smooth group to [code]-1[/code] using [method set_smooth_group] prior to adding vertices.
*/
func (self Instance) GenerateNormals() { //gd:SurfaceTool.generate_normals
	Advanced(self).GenerateNormals(false)
}

/*
Generates normals from vertices so you do not have to do it manually. If [param flip] is [code]true[/code], the resulting normals will be inverted. [method generate_normals] should be called [i]after[/i] generating geometry and [i]before[/i] committing the mesh using [method commit] or [method commit_to_arrays]. For correct display of normal-mapped surfaces, you will also have to generate tangents using [method generate_tangents].
[b]Note:[/b] [method generate_normals] only works if the primitive type is set to [constant Mesh.PRIMITIVE_TRIANGLES].
[b]Note:[/b] [method generate_normals] takes smooth groups into account. To generate smooth normals, set the smooth group to a value greater than or equal to [code]0[/code] using [method set_smooth_group] or leave the smooth group at the default of [code]0[/code]. To generate flat normals, set the smooth group to [code]-1[/code] using [method set_smooth_group] prior to adding vertices.
*/
func (self Expanded) GenerateNormals(flip bool) { //gd:SurfaceTool.generate_normals
	Advanced(self).GenerateNormals(flip)
}

/*
Generates a tangent vector for each vertex. Requires that each vertex already has UVs and normals set (see [method generate_normals]).
*/
func (self Instance) GenerateTangents() { //gd:SurfaceTool.generate_tangents
	Advanced(self).GenerateTangents()
}

/*
Optimizes triangle sorting for performance. Requires that [method get_primitive_type] is [constant Mesh.PRIMITIVE_TRIANGLES].
*/
func (self Instance) OptimizeIndicesForCache() { //gd:SurfaceTool.optimize_indices_for_cache
	Advanced(self).OptimizeIndicesForCache()
}

/*
Returns the axis-aligned bounding box of the vertex positions.
*/
func (self Instance) GetAabb() AABB.PositionSize { //gd:SurfaceTool.get_aabb
	return AABB.PositionSize(Advanced(self).GetAabb())
}

/*
Generates an LOD for a given [param nd_threshold] in linear units (square root of quadric error metric), using at most [param target_index_count] indices.
*/
func (self Instance) GenerateLod(nd_threshold Float.X) []int32 { //gd:SurfaceTool.generate_lod
	return []int32(slices.Collect(Advanced(self).GenerateLod(float64(nd_threshold), int64(3)).Values()))
}

/*
Generates an LOD for a given [param nd_threshold] in linear units (square root of quadric error metric), using at most [param target_index_count] indices.
*/
func (self Expanded) GenerateLod(nd_threshold Float.X, target_index_count int) []int32 { //gd:SurfaceTool.generate_lod
	return []int32(slices.Collect(Advanced(self).GenerateLod(float64(nd_threshold), int64(target_index_count)).Values()))
}

/*
Sets [Material] to be used by the [Mesh] you are constructing.
*/
func (self Instance) SetMaterial(material Material.Instance) { //gd:SurfaceTool.set_material
	Advanced(self).SetMaterial(material)
}

/*
Returns the type of mesh geometry, such as [constant Mesh.PRIMITIVE_TRIANGLES].
*/
func (self Instance) GetPrimitiveType() Mesh.PrimitiveType { //gd:SurfaceTool.get_primitive_type
	return Mesh.PrimitiveType(Advanced(self).GetPrimitiveType())
}

/*
Clear all information passed into the surface tool so far.
*/
func (self Instance) Clear() { //gd:SurfaceTool.clear
	Advanced(self).Clear()
}

/*
Creates a vertex array from an existing [Mesh].
*/
func (self Instance) CreateFrom(existing Mesh.Instance, surface int) { //gd:SurfaceTool.create_from
	Advanced(self).CreateFrom(existing, int64(surface))
}

/*
Creates this SurfaceTool from existing vertex arrays such as returned by [method commit_to_arrays], [method Mesh.surface_get_arrays], [method Mesh.surface_get_blend_shape_arrays], [method ImporterMesh.get_surface_arrays], and [method ImporterMesh.get_surface_blend_shape_arrays]. [param primitive_type] controls the type of mesh data, defaulting to [constant Mesh.PRIMITIVE_TRIANGLES].
*/
func (self Instance) CreateFromArrays(arrays []any) { //gd:SurfaceTool.create_from_arrays
	Advanced(self).CreateFromArrays(gd.EngineArrayFromSlice(arrays), 3)
}

/*
Creates this SurfaceTool from existing vertex arrays such as returned by [method commit_to_arrays], [method Mesh.surface_get_arrays], [method Mesh.surface_get_blend_shape_arrays], [method ImporterMesh.get_surface_arrays], and [method ImporterMesh.get_surface_blend_shape_arrays]. [param primitive_type] controls the type of mesh data, defaulting to [constant Mesh.PRIMITIVE_TRIANGLES].
*/
func (self Expanded) CreateFromArrays(arrays []any, primitive_type Mesh.PrimitiveType) { //gd:SurfaceTool.create_from_arrays
	Advanced(self).CreateFromArrays(gd.EngineArrayFromSlice(arrays), primitive_type)
}

/*
Creates a vertex array from the specified blend shape of an existing [Mesh]. This can be used to extract a specific pose from a blend shape.
*/
func (self Instance) CreateFromBlendShape(existing Mesh.Instance, surface int, blend_shape string) { //gd:SurfaceTool.create_from_blend_shape
	Advanced(self).CreateFromBlendShape(existing, int64(surface), String.New(blend_shape))
}

/*
Append vertices from a given [Mesh] surface onto the current vertex array with specified [Transform3D].
*/
func (self Instance) AppendFrom(existing Mesh.Instance, surface int, transform Transform3D.BasisOrigin) { //gd:SurfaceTool.append_from
	Advanced(self).AppendFrom(existing, int64(surface), Transform3D.BasisOrigin(transform))
}

/*
Returns a constructed [ArrayMesh] from current information passed in. If an existing [ArrayMesh] is passed in as an argument, will add an extra surface to the existing [ArrayMesh].
The [param flags] argument can be the bitwise OR of [constant Mesh.ARRAY_FLAG_USE_DYNAMIC_UPDATE], [constant Mesh.ARRAY_FLAG_USE_8_BONE_WEIGHTS], or [constant Mesh.ARRAY_FLAG_USES_EMPTY_VERTEX_ARRAY].
*/
func (self Instance) Commit() ArrayMesh.Instance { //gd:SurfaceTool.commit
	return ArrayMesh.Instance(Advanced(self).Commit([1]ArrayMesh.Instance{}[0], int64(0)))
}

/*
Returns a constructed [ArrayMesh] from current information passed in. If an existing [ArrayMesh] is passed in as an argument, will add an extra surface to the existing [ArrayMesh].
The [param flags] argument can be the bitwise OR of [constant Mesh.ARRAY_FLAG_USE_DYNAMIC_UPDATE], [constant Mesh.ARRAY_FLAG_USE_8_BONE_WEIGHTS], or [constant Mesh.ARRAY_FLAG_USES_EMPTY_VERTEX_ARRAY].
*/
func (self Expanded) Commit(existing ArrayMesh.Instance, flags int) ArrayMesh.Instance { //gd:SurfaceTool.commit
	return ArrayMesh.Instance(Advanced(self).Commit(existing, int64(flags)))
}

/*
Commits the data to the same format used by [method ArrayMesh.add_surface_from_arrays], [method ImporterMesh.add_surface], and [method create_from_arrays]. This way you can further process the mesh data using the [ArrayMesh] or [ImporterMesh] APIs.
*/
func (self Instance) CommitToArrays() []any { //gd:SurfaceTool.commit_to_arrays
	return []any(gd.ArrayAs[[]any](gd.InternalArray(Advanced(self).CommitToArrays())))
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.SurfaceTool

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {
	object := gd.Global.ClassDB.ConstructObject(gd.NewStringName("SurfaceTool"))
	casted := Instance{*(*gdclass.SurfaceTool)(unsafe.Pointer(&object))}
	casted.AsRefCounted()[0].Reference()
	return casted
}

/*
Set to [constant SKIN_8_WEIGHTS] to indicate that up to 8 bone influences per vertex may be used.
By default, only 4 bone influences are used ([constant SKIN_4_WEIGHTS]).
[b]Note:[/b] This function takes an enum, not the exact number of weights.
*/
//go:nosplit
func (self class) SetSkinWeightCount(count SkinWeightCount) { //gd:SurfaceTool.set_skin_weight_count
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.SurfaceTool.Bind_set_skin_weight_count), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ count SkinWeightCount }{count}))
}

/*
By default, returns [constant SKIN_4_WEIGHTS] to indicate only 4 bone influences per vertex are used.
Returns [constant SKIN_8_WEIGHTS] if up to 8 influences are used.
[b]Note:[/b] This function returns an enum, not the exact number of weights.
*/
//go:nosplit
func (self class) GetSkinWeightCount() SkinWeightCount { //gd:SurfaceTool.get_skin_weight_count
	var r_ret = gdextension.Call[SkinWeightCount](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.SurfaceTool.Bind_get_skin_weight_count), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Sets the color format for this custom [param channel_index]. Use [constant CUSTOM_MAX] to disable.
Must be invoked after [method begin] and should be set before [method commit] or [method commit_to_arrays].
*/
//go:nosplit
func (self class) SetCustomFormat(channel_index int64, format CustomFormat) { //gd:SurfaceTool.set_custom_format
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.SurfaceTool.Bind_set_custom_format), 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		channel_index int64
		format        CustomFormat
	}{channel_index, format}))
}

/*
Returns the format for custom [param channel_index] (currently up to 4). Returns [constant CUSTOM_MAX] if this custom channel is unused.
*/
//go:nosplit
func (self class) GetCustomFormat(channel_index int64) CustomFormat { //gd:SurfaceTool.get_custom_format
	var r_ret = gdextension.Call[CustomFormat](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.SurfaceTool.Bind_get_custom_format), gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ channel_index int64 }{channel_index}))
	var ret = r_ret
	return ret
}

/*
Called before adding any vertices. Takes the primitive type as an argument (e.g. [constant Mesh.PRIMITIVE_TRIANGLES]).
*/
//go:nosplit
func (self class) Begin(primitive Mesh.PrimitiveType) { //gd:SurfaceTool.begin
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.SurfaceTool.Bind_begin), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ primitive Mesh.PrimitiveType }{primitive}))
}

/*
Specifies the position of current vertex. Should be called after specifying other vertex properties (e.g. Color, UV).
*/
//go:nosplit
func (self class) AddVertex(vertex Vector3.XYZ) { //gd:SurfaceTool.add_vertex
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.SurfaceTool.Bind_add_vertex), 0|(gdextension.SizeVector3<<4), unsafe.Pointer(&struct{ vertex Vector3.XYZ }{vertex}))
}

/*
Specifies a [Color] to use for the [i]next[/i] vertex. If every vertex needs to have this information set and you fail to submit it for the first vertex, this information may not be used at all.
[b]Note:[/b] The material must have [member BaseMaterial3D.vertex_color_use_as_albedo] enabled for the vertex color to be visible.
*/
//go:nosplit
func (self class) SetColor(color Color.RGBA) { //gd:SurfaceTool.set_color
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.SurfaceTool.Bind_set_color), 0|(gdextension.SizeColor<<4), unsafe.Pointer(&struct{ color Color.RGBA }{color}))
}

/*
Specifies a normal to use for the [i]next[/i] vertex. If every vertex needs to have this information set and you fail to submit it for the first vertex, this information may not be used at all.
*/
//go:nosplit
func (self class) SetNormal(normal Vector3.XYZ) { //gd:SurfaceTool.set_normal
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.SurfaceTool.Bind_set_normal), 0|(gdextension.SizeVector3<<4), unsafe.Pointer(&struct{ normal Vector3.XYZ }{normal}))
}

/*
Specifies a tangent to use for the [i]next[/i] vertex. If every vertex needs to have this information set and you fail to submit it for the first vertex, this information may not be used at all.
*/
//go:nosplit
func (self class) SetTangent(tangent Plane.NormalD) { //gd:SurfaceTool.set_tangent
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.SurfaceTool.Bind_set_tangent), 0|(gdextension.SizePlane<<4), unsafe.Pointer(&struct{ tangent Plane.NormalD }{tangent}))
}

/*
Specifies a set of UV coordinates to use for the [i]next[/i] vertex. If every vertex needs to have this information set and you fail to submit it for the first vertex, this information may not be used at all.
*/
//go:nosplit
func (self class) SetUv(uv Vector2.XY) { //gd:SurfaceTool.set_uv
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.SurfaceTool.Bind_set_uv), 0|(gdextension.SizeVector2<<4), unsafe.Pointer(&struct{ uv Vector2.XY }{uv}))
}

/*
Specifies an optional second set of UV coordinates to use for the [i]next[/i] vertex. If every vertex needs to have this information set and you fail to submit it for the first vertex, this information may not be used at all.
*/
//go:nosplit
func (self class) SetUv2(uv2 Vector2.XY) { //gd:SurfaceTool.set_uv2
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.SurfaceTool.Bind_set_uv2), 0|(gdextension.SizeVector2<<4), unsafe.Pointer(&struct{ uv2 Vector2.XY }{uv2}))
}

/*
Specifies an array of bones to use for the [i]next[/i] vertex. [param bones] must contain 4 integers.
*/
//go:nosplit
func (self class) SetBones(bones Packed.Array[int32]) { //gd:SurfaceTool.set_bones
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.SurfaceTool.Bind_set_bones), 0|(gdextension.SizePackedArray<<4), unsafe.Pointer(&struct{ bones gdextension.PackedArray }{gdextension.ToPackedArray(pointers.Get(gd.InternalPacked[gd.PackedInt32Array, int32](bones)))}))
}

/*
Specifies weight values to use for the [i]next[/i] vertex. [param weights] must contain 4 values. If every vertex needs to have this information set and you fail to submit it for the first vertex, this information may not be used at all.
*/
//go:nosplit
func (self class) SetWeights(weights Packed.Array[float32]) { //gd:SurfaceTool.set_weights
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.SurfaceTool.Bind_set_weights), 0|(gdextension.SizePackedArray<<4), unsafe.Pointer(&struct{ weights gdextension.PackedArray }{gdextension.ToPackedArray(pointers.Get(gd.InternalPacked[gd.PackedFloat32Array, float32](weights)))}))
}

/*
Sets the custom value on this vertex for [param channel_index].
[method set_custom_format] must be called first for this [param channel_index]. Formats which are not RGBA will ignore other color channels.
*/
//go:nosplit
func (self class) SetCustom(channel_index int64, custom_color Color.RGBA) { //gd:SurfaceTool.set_custom
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.SurfaceTool.Bind_set_custom), 0|(gdextension.SizeInt<<4)|(gdextension.SizeColor<<8), unsafe.Pointer(&struct {
		channel_index int64
		custom_color  Color.RGBA
	}{channel_index, custom_color}))
}

/*
Specifies the smooth group to use for the [i]next[/i] vertex. If this is never called, all vertices will have the default smooth group of [code]0[/code] and will be smoothed with adjacent vertices of the same group. To produce a mesh with flat normals, set the smooth group to [code]-1[/code].
[b]Note:[/b] This function actually takes a [code]uint32_t[/code], so C# users should use [code]uint32.MaxValue[/code] instead of [code]-1[/code] to produce a mesh with flat normals.
*/
//go:nosplit
func (self class) SetSmoothGroup(index int64) { //gd:SurfaceTool.set_smooth_group
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.SurfaceTool.Bind_set_smooth_group), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ index int64 }{index}))
}

/*
Inserts a triangle fan made of array data into [Mesh] being constructed.
Requires the primitive type be set to [constant Mesh.PRIMITIVE_TRIANGLES].
*/
//go:nosplit
func (self class) AddTriangleFan(vertices Packed.Array[Vector3.XYZ], uvs Packed.Array[Vector2.XY], colors Packed.Array[Color.RGBA], uv2s Packed.Array[Vector2.XY], normals Packed.Array[Vector3.XYZ], tangents Array.Contains[Plane.NormalD]) { //gd:SurfaceTool.add_triangle_fan
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.SurfaceTool.Bind_add_triangle_fan), 0|(gdextension.SizePackedArray<<4)|(gdextension.SizePackedArray<<8)|(gdextension.SizePackedArray<<12)|(gdextension.SizePackedArray<<16)|(gdextension.SizePackedArray<<20)|(gdextension.SizeArray<<24), unsafe.Pointer(&struct {
		vertices gdextension.PackedArray
		uvs      gdextension.PackedArray
		colors   gdextension.PackedArray
		uv2s     gdextension.PackedArray
		normals  gdextension.PackedArray
		tangents gdextension.Array
	}{gdextension.ToPackedArray(pointers.Get(gd.InternalPacked[gd.PackedVector3Array, Vector3.XYZ](vertices))), gdextension.ToPackedArray(pointers.Get(gd.InternalPacked[gd.PackedVector2Array, Vector2.XY](uvs))), gdextension.ToPackedArray(pointers.Get(gd.InternalPacked[gd.PackedColorArray, Color.RGBA](colors))), gdextension.ToPackedArray(pointers.Get(gd.InternalPacked[gd.PackedVector2Array, Vector2.XY](uv2s))), gdextension.ToPackedArray(pointers.Get(gd.InternalPacked[gd.PackedVector3Array, Vector3.XYZ](normals))), gdextension.Array(pointers.Get(gd.InternalArray(tangents))[0])}))
}

/*
Adds a vertex to index array if you are using indexed vertices. Does not need to be called before adding vertices.
*/
//go:nosplit
func (self class) AddIndex(index int64) { //gd:SurfaceTool.add_index
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.SurfaceTool.Bind_add_index), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ index int64 }{index}))
}

/*
Shrinks the vertex array by creating an index array. This can improve performance by avoiding vertex reuse.
*/
//go:nosplit
func (self class) Index() { //gd:SurfaceTool.index
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.SurfaceTool.Bind_index), 0, unsafe.Pointer(&struct{}{}))
}

/*
Removes the index array by expanding the vertex array.
*/
//go:nosplit
func (self class) Deindex() { //gd:SurfaceTool.deindex
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.SurfaceTool.Bind_deindex), 0, unsafe.Pointer(&struct{}{}))
}

/*
Generates normals from vertices so you do not have to do it manually. If [param flip] is [code]true[/code], the resulting normals will be inverted. [method generate_normals] should be called [i]after[/i] generating geometry and [i]before[/i] committing the mesh using [method commit] or [method commit_to_arrays]. For correct display of normal-mapped surfaces, you will also have to generate tangents using [method generate_tangents].
[b]Note:[/b] [method generate_normals] only works if the primitive type is set to [constant Mesh.PRIMITIVE_TRIANGLES].
[b]Note:[/b] [method generate_normals] takes smooth groups into account. To generate smooth normals, set the smooth group to a value greater than or equal to [code]0[/code] using [method set_smooth_group] or leave the smooth group at the default of [code]0[/code]. To generate flat normals, set the smooth group to [code]-1[/code] using [method set_smooth_group] prior to adding vertices.
*/
//go:nosplit
func (self class) GenerateNormals(flip bool) { //gd:SurfaceTool.generate_normals
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.SurfaceTool.Bind_generate_normals), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ flip bool }{flip}))
}

/*
Generates a tangent vector for each vertex. Requires that each vertex already has UVs and normals set (see [method generate_normals]).
*/
//go:nosplit
func (self class) GenerateTangents() { //gd:SurfaceTool.generate_tangents
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.SurfaceTool.Bind_generate_tangents), 0, unsafe.Pointer(&struct{}{}))
}

/*
Optimizes triangle sorting for performance. Requires that [method get_primitive_type] is [constant Mesh.PRIMITIVE_TRIANGLES].
*/
//go:nosplit
func (self class) OptimizeIndicesForCache() { //gd:SurfaceTool.optimize_indices_for_cache
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.SurfaceTool.Bind_optimize_indices_for_cache), 0, unsafe.Pointer(&struct{}{}))
}

/*
Returns the axis-aligned bounding box of the vertex positions.
*/
//go:nosplit
func (self class) GetAabb() AABB.PositionSize { //gd:SurfaceTool.get_aabb
	var r_ret = gdextension.Call[AABB.PositionSize](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.SurfaceTool.Bind_get_aabb), gdextension.SizeAABB, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Generates an LOD for a given [param nd_threshold] in linear units (square root of quadric error metric), using at most [param target_index_count] indices.
*/
//go:nosplit
func (self class) GenerateLod(nd_threshold float64, target_index_count int64) Packed.Array[int32] { //gd:SurfaceTool.generate_lod
	var r_ret = gdextension.Call[gd.PackedPointers](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.SurfaceTool.Bind_generate_lod), gdextension.SizePackedArray|(gdextension.SizeFloat<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		nd_threshold       float64
		target_index_count int64
	}{nd_threshold, target_index_count}))
	var ret = Packed.Array[int32](Array.Through(gd.PackedProxy[gd.PackedInt32Array, int32]{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

/*
Sets [Material] to be used by the [Mesh] you are constructing.
*/
//go:nosplit
func (self class) SetMaterial(material [1]gdclass.Material) { //gd:SurfaceTool.set_material
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.SurfaceTool.Bind_set_material), 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ material gdextension.Object }{gdextension.Object(gd.ObjectChecked(material[0].AsObject()))}))
}

/*
Returns the type of mesh geometry, such as [constant Mesh.PRIMITIVE_TRIANGLES].
*/
//go:nosplit
func (self class) GetPrimitiveType() Mesh.PrimitiveType { //gd:SurfaceTool.get_primitive_type
	var r_ret = gdextension.Call[Mesh.PrimitiveType](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.SurfaceTool.Bind_get_primitive_type), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Clear all information passed into the surface tool so far.
*/
//go:nosplit
func (self class) Clear() { //gd:SurfaceTool.clear
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.SurfaceTool.Bind_clear), 0, unsafe.Pointer(&struct{}{}))
}

/*
Creates a vertex array from an existing [Mesh].
*/
//go:nosplit
func (self class) CreateFrom(existing [1]gdclass.Mesh, surface int64) { //gd:SurfaceTool.create_from
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.SurfaceTool.Bind_create_from), 0|(gdextension.SizeObject<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		existing gdextension.Object
		surface  int64
	}{gdextension.Object(gd.ObjectChecked(existing[0].AsObject())), surface}))
}

/*
Creates this SurfaceTool from existing vertex arrays such as returned by [method commit_to_arrays], [method Mesh.surface_get_arrays], [method Mesh.surface_get_blend_shape_arrays], [method ImporterMesh.get_surface_arrays], and [method ImporterMesh.get_surface_blend_shape_arrays]. [param primitive_type] controls the type of mesh data, defaulting to [constant Mesh.PRIMITIVE_TRIANGLES].
*/
//go:nosplit
func (self class) CreateFromArrays(arrays Array.Any, primitive_type Mesh.PrimitiveType) { //gd:SurfaceTool.create_from_arrays
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.SurfaceTool.Bind_create_from_arrays), 0|(gdextension.SizeArray<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		arrays         gdextension.Array
		primitive_type Mesh.PrimitiveType
	}{gdextension.Array(pointers.Get(gd.InternalArray(arrays))[0]), primitive_type}))
}

/*
Creates a vertex array from the specified blend shape of an existing [Mesh]. This can be used to extract a specific pose from a blend shape.
*/
//go:nosplit
func (self class) CreateFromBlendShape(existing [1]gdclass.Mesh, surface int64, blend_shape String.Readable) { //gd:SurfaceTool.create_from_blend_shape
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.SurfaceTool.Bind_create_from_blend_shape), 0|(gdextension.SizeObject<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeString<<12), unsafe.Pointer(&struct {
		existing    gdextension.Object
		surface     int64
		blend_shape gdextension.String
	}{gdextension.Object(gd.ObjectChecked(existing[0].AsObject())), surface, gdextension.String(pointers.Get(gd.InternalString(blend_shape))[0])}))
}

/*
Append vertices from a given [Mesh] surface onto the current vertex array with specified [Transform3D].
*/
//go:nosplit
func (self class) AppendFrom(existing [1]gdclass.Mesh, surface int64, transform Transform3D.BasisOrigin) { //gd:SurfaceTool.append_from
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.SurfaceTool.Bind_append_from), 0|(gdextension.SizeObject<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeTransform3D<<12), unsafe.Pointer(&struct {
		existing  gdextension.Object
		surface   int64
		transform Transform3D.BasisOrigin
	}{gdextension.Object(gd.ObjectChecked(existing[0].AsObject())), surface, gd.Transposed(transform)}))
}

/*
Returns a constructed [ArrayMesh] from current information passed in. If an existing [ArrayMesh] is passed in as an argument, will add an extra surface to the existing [ArrayMesh].
The [param flags] argument can be the bitwise OR of [constant Mesh.ARRAY_FLAG_USE_DYNAMIC_UPDATE], [constant Mesh.ARRAY_FLAG_USE_8_BONE_WEIGHTS], or [constant Mesh.ARRAY_FLAG_USES_EMPTY_VERTEX_ARRAY].
*/
//go:nosplit
func (self class) Commit(existing [1]gdclass.ArrayMesh, flags int64) [1]gdclass.ArrayMesh { //gd:SurfaceTool.commit
	var r_ret = gdextension.Call[gd.EnginePointer](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.SurfaceTool.Bind_commit), gdextension.SizeObject|(gdextension.SizeObject<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		existing gdextension.Object
		flags    int64
	}{gdextension.Object(gd.ObjectChecked(existing[0].AsObject())), flags}))
	var ret = [1]gdclass.ArrayMesh{gd.PointerWithOwnershipTransferredToGo[gdclass.ArrayMesh](r_ret)}
	return ret
}

/*
Commits the data to the same format used by [method ArrayMesh.add_surface_from_arrays], [method ImporterMesh.add_surface], and [method create_from_arrays]. This way you can further process the mesh data using the [ArrayMesh] or [ImporterMesh] APIs.
*/
//go:nosplit
func (self class) CommitToArrays() Array.Any { //gd:SurfaceTool.commit_to_arrays
	var r_ret = gdextension.Call[[1]gd.EnginePointer](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.SurfaceTool.Bind_commit_to_arrays), gdextension.SizeArray, unsafe.Pointer(&struct{}{}))
	var ret = Array.Through(gd.ArrayProxy[variant.Any]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}
func (self class) AsSurfaceTool() Advanced         { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsSurfaceTool() Instance      { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsSurfaceTool() Instance { return self.Super().AsSurfaceTool() }
func (self class) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsRefCounted() [1]gd.RefCounted { return self.Super().AsRefCounted() }
func (self Instance) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(RefCounted.Advanced(self.AsRefCounted()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(RefCounted.Instance(self.AsRefCounted()), name)
	}
}
func init() {
	gdclass.Register("SurfaceTool", func(ptr gd.Object) any { return [1]gdclass.SurfaceTool{*(*gdclass.SurfaceTool)(unsafe.Pointer(&ptr))} })
}

type CustomFormat int //gd:SurfaceTool.CustomFormat

const (
	/*Limits range of data passed to [method set_custom] to unsigned normalized 0 to 1 stored in 8 bits per channel. See [constant Mesh.ARRAY_CUSTOM_RGBA8_UNORM].*/
	CustomRgba8Unorm CustomFormat = 0
	/*Limits range of data passed to [method set_custom] to signed normalized -1 to 1 stored in 8 bits per channel. See [constant Mesh.ARRAY_CUSTOM_RGBA8_SNORM].*/
	CustomRgba8Snorm CustomFormat = 1
	/*Stores data passed to [method set_custom] as half precision floats, and uses only red and green color channels. See [constant Mesh.ARRAY_CUSTOM_RG_HALF].*/
	CustomRgHalf CustomFormat = 2
	/*Stores data passed to [method set_custom] as half precision floats and uses all color channels. See [constant Mesh.ARRAY_CUSTOM_RGBA_HALF].*/
	CustomRgbaHalf CustomFormat = 3
	/*Stores data passed to [method set_custom] as full precision floats, and uses only red color channel. See [constant Mesh.ARRAY_CUSTOM_R_FLOAT].*/
	CustomRFloat CustomFormat = 4
	/*Stores data passed to [method set_custom] as full precision floats, and uses only red and green color channels. See [constant Mesh.ARRAY_CUSTOM_RG_FLOAT].*/
	CustomRgFloat CustomFormat = 5
	/*Stores data passed to [method set_custom] as full precision floats, and uses only red, green and blue color channels. See [constant Mesh.ARRAY_CUSTOM_RGB_FLOAT].*/
	CustomRgbFloat CustomFormat = 6
	/*Stores data passed to [method set_custom] as full precision floats, and uses all color channels. See [constant Mesh.ARRAY_CUSTOM_RGBA_FLOAT].*/
	CustomRgbaFloat CustomFormat = 7
	/*Used to indicate a disabled custom channel.*/
	CustomMax CustomFormat = 8
)

type SkinWeightCount int //gd:SurfaceTool.SkinWeightCount

const (
	/*Each individual vertex can be influenced by only 4 bone weights.*/
	Skin4Weights SkinWeightCount = 0
	/*Each individual vertex can be influenced by up to 8 bone weights.*/
	Skin8Weights SkinWeightCount = 1
)
