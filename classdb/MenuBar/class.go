// Code generated by the generate package DO NOT EDIT

// Package MenuBar provides methods for working with MenuBar object instances.
package MenuBar

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/CanvasItem"
import "graphics.gd/classdb/Control"
import "graphics.gd/classdb/Node"
import "graphics.gd/classdb/PopupMenu"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
A horizontal menu bar that creates a menu for each [PopupMenu] child. New items are created by adding [PopupMenu]s to this node. Item title is determined by [member Window.title], or node name if [member Window.title] is empty. Item title can be overridden using [method set_menu_title].
*/
type Instance [1]gdclass.MenuBar

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	set_switch_on_hover    gdextension.MethodForClass `hash:"2586408642"`
	is_switch_on_hover     gdextension.MethodForClass `hash:"2240911060"`
	set_disable_shortcuts  gdextension.MethodForClass `hash:"2586408642"`
	set_prefer_global_menu gdextension.MethodForClass `hash:"2586408642"`
	is_prefer_global_menu  gdextension.MethodForClass `hash:"36873697"`
	is_native_menu         gdextension.MethodForClass `hash:"36873697"`
	get_menu_count         gdextension.MethodForClass `hash:"3905245786"`
	set_text_direction     gdextension.MethodForClass `hash:"119160795"`
	get_text_direction     gdextension.MethodForClass `hash:"797257663"`
	set_language           gdextension.MethodForClass `hash:"83702148"`
	get_language           gdextension.MethodForClass `hash:"201670096"`
	set_flat               gdextension.MethodForClass `hash:"2586408642"`
	is_flat                gdextension.MethodForClass `hash:"36873697"`
	set_start_index        gdextension.MethodForClass `hash:"1286410249"`
	get_start_index        gdextension.MethodForClass `hash:"3905245786"`
	set_menu_title         gdextension.MethodForClass `hash:"501894301"`
	get_menu_title         gdextension.MethodForClass `hash:"844755477"`
	set_menu_tooltip       gdextension.MethodForClass `hash:"501894301"`
	get_menu_tooltip       gdextension.MethodForClass `hash:"844755477"`
	set_menu_disabled      gdextension.MethodForClass `hash:"300928843"`
	is_menu_disabled       gdextension.MethodForClass `hash:"1116898809"`
	set_menu_hidden        gdextension.MethodForClass `hash:"300928843"`
	is_menu_hidden         gdextension.MethodForClass `hash:"1116898809"`
	get_menu_popup         gdextension.MethodForClass `hash:"2100501353"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("MenuBar")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		pointers.Raw[gd.StringName](sname).Free()
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsMenuBar() Instance
}

/*
If [code]true[/code], shortcuts are disabled and cannot be used to trigger the button.
*/
func (self Instance) SetDisableShortcuts(disabled bool) { //gd:MenuBar.set_disable_shortcuts
	Advanced(self).SetDisableShortcuts(disabled)
}

/*
Returns [code]true[/code], if system global menu is supported and used by this [MenuBar].
*/
func (self Instance) IsNativeMenu() bool { //gd:MenuBar.is_native_menu
	return bool(Advanced(self).IsNativeMenu())
}

/*
Returns number of menu items.
*/
func (self Instance) GetMenuCount() int { //gd:MenuBar.get_menu_count
	return int(int(Advanced(self).GetMenuCount()))
}

/*
Sets menu item title.
*/
func (self Instance) SetMenuTitle(menu int, title string) { //gd:MenuBar.set_menu_title
	Advanced(self).SetMenuTitle(int64(menu), String.New(title))
}

/*
Returns menu item title.
*/
func (self Instance) GetMenuTitle(menu int) string { //gd:MenuBar.get_menu_title
	return string(Advanced(self).GetMenuTitle(int64(menu)).String())
}

/*
Sets menu item tooltip.
*/
func (self Instance) SetMenuTooltip(menu int, tooltip string) { //gd:MenuBar.set_menu_tooltip
	Advanced(self).SetMenuTooltip(int64(menu), String.New(tooltip))
}

/*
Returns menu item tooltip.
*/
func (self Instance) GetMenuTooltip(menu int) string { //gd:MenuBar.get_menu_tooltip
	return string(Advanced(self).GetMenuTooltip(int64(menu)).String())
}

/*
If [code]true[/code], menu item is disabled.
*/
func (self Instance) SetMenuDisabled(menu int, disabled bool) { //gd:MenuBar.set_menu_disabled
	Advanced(self).SetMenuDisabled(int64(menu), disabled)
}

/*
Returns [code]true[/code], if menu item is disabled.
*/
func (self Instance) IsMenuDisabled(menu int) bool { //gd:MenuBar.is_menu_disabled
	return bool(Advanced(self).IsMenuDisabled(int64(menu)))
}

/*
If [code]true[/code], menu item is hidden.
*/
func (self Instance) SetMenuHidden(menu int, hidden bool) { //gd:MenuBar.set_menu_hidden
	Advanced(self).SetMenuHidden(int64(menu), hidden)
}

/*
Returns [code]true[/code], if menu item is hidden.
*/
func (self Instance) IsMenuHidden(menu int) bool { //gd:MenuBar.is_menu_hidden
	return bool(Advanced(self).IsMenuHidden(int64(menu)))
}

/*
Returns [PopupMenu] associated with menu item.
*/
func (self Instance) GetMenuPopup(menu int) PopupMenu.Instance { //gd:MenuBar.get_menu_popup
	return PopupMenu.Instance(Advanced(self).GetMenuPopup(int64(menu)))
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.MenuBar

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.MenuBar)(unsafe.Pointer(&obj))
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.MenuBar)(unsafe.Pointer(&obj))
		return true
	}
	return false
}

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {

	if !gd.Linked {
		var placeholder Instance
		*(*gd.Object)(unsafe.Pointer(&placeholder)) = pointers.Add[gd.Object]([3]uint64{})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(*(*gd.Object)(unsafe.Pointer(&placeholder)), raw)
				gd.RegisterCleanup(func() {
					gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
				})
			}
		})
		return placeholder
	}
	object := [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})}
	casted := Instance{*(*gdclass.MenuBar)(unsafe.Pointer(&object))}
	object[0].Notification(0, false)
	return casted
}

func (self Instance) Flat() bool {
	return bool(class(self).IsFlat())
}

func (self Instance) SetFlat(value bool) {
	class(self).SetFlat(value)
}

func (self Instance) StartIndex() int {
	return int(int(class(self).GetStartIndex()))
}

func (self Instance) SetStartIndex(value int) {
	class(self).SetStartIndex(int64(value))
}

func (self Instance) SwitchOnHover() bool {
	return bool(class(self).IsSwitchOnHover())
}

func (self Instance) SetSwitchOnHover(value bool) {
	class(self).SetSwitchOnHover(value)
}

func (self Instance) PreferGlobalMenu() bool {
	return bool(class(self).IsPreferGlobalMenu())
}

func (self Instance) SetPreferGlobalMenu(value bool) {
	class(self).SetPreferGlobalMenu(value)
}

func (self Instance) TextDirection() Control.TextDirection {
	return Control.TextDirection(class(self).GetTextDirection())
}

func (self Instance) SetTextDirection(value Control.TextDirection) {
	class(self).SetTextDirection(value)
}

func (self Instance) Language() string {
	return string(class(self).GetLanguage().String())
}

func (self Instance) SetLanguage(value string) {
	class(self).SetLanguage(String.New(value))
}

//go:nosplit
func (self class) SetSwitchOnHover(enable bool) { //gd:MenuBar.set_switch_on_hover
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_switch_on_hover, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

//go:nosplit
func (self class) IsSwitchOnHover() bool { //gd:MenuBar.is_switch_on_hover
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_switch_on_hover, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
If [code]true[/code], shortcuts are disabled and cannot be used to trigger the button.
*/
//go:nosplit
func (self class) SetDisableShortcuts(disabled bool) { //gd:MenuBar.set_disable_shortcuts
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_disable_shortcuts, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ disabled bool }{disabled}))
}

//go:nosplit
func (self class) SetPreferGlobalMenu(enabled bool) { //gd:MenuBar.set_prefer_global_menu
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_prefer_global_menu, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enabled bool }{enabled}))
}

//go:nosplit
func (self class) IsPreferGlobalMenu() bool { //gd:MenuBar.is_prefer_global_menu
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_prefer_global_menu, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code], if system global menu is supported and used by this [MenuBar].
*/
//go:nosplit
func (self class) IsNativeMenu() bool { //gd:MenuBar.is_native_menu
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_native_menu, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns number of menu items.
*/
//go:nosplit
func (self class) GetMenuCount() int64 { //gd:MenuBar.get_menu_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_menu_count, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetTextDirection(direction Control.TextDirection) { //gd:MenuBar.set_text_direction
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_text_direction, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ direction Control.TextDirection }{direction}))
}

//go:nosplit
func (self class) GetTextDirection() Control.TextDirection { //gd:MenuBar.get_text_direction
	var r_ret = gdextension.Call[Control.TextDirection](gd.ObjectChecked(self.AsObject()), methods.get_text_direction, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetLanguage(language String.Readable) { //gd:MenuBar.set_language
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_language, 0|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ language gdextension.String }{pointers.Get(gd.InternalString(language))}))
}

//go:nosplit
func (self class) GetLanguage() String.Readable { //gd:MenuBar.get_language
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_language, gdextension.SizeString, unsafe.Pointer(&struct{}{}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

//go:nosplit
func (self class) SetFlat(enabled bool) { //gd:MenuBar.set_flat
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_flat, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enabled bool }{enabled}))
}

//go:nosplit
func (self class) IsFlat() bool { //gd:MenuBar.is_flat
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_flat, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetStartIndex(enabled int64) { //gd:MenuBar.set_start_index
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_start_index, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ enabled int64 }{enabled}))
}

//go:nosplit
func (self class) GetStartIndex() int64 { //gd:MenuBar.get_start_index
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_start_index, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Sets menu item title.
*/
//go:nosplit
func (self class) SetMenuTitle(menu int64, title String.Readable) { //gd:MenuBar.set_menu_title
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_menu_title, 0|(gdextension.SizeInt<<4)|(gdextension.SizeString<<8), unsafe.Pointer(&struct {
		menu  int64
		title gdextension.String
	}{menu, pointers.Get(gd.InternalString(title))}))
}

/*
Returns menu item title.
*/
//go:nosplit
func (self class) GetMenuTitle(menu int64) String.Readable { //gd:MenuBar.get_menu_title
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_menu_title, gdextension.SizeString|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ menu int64 }{menu}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Sets menu item tooltip.
*/
//go:nosplit
func (self class) SetMenuTooltip(menu int64, tooltip String.Readable) { //gd:MenuBar.set_menu_tooltip
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_menu_tooltip, 0|(gdextension.SizeInt<<4)|(gdextension.SizeString<<8), unsafe.Pointer(&struct {
		menu    int64
		tooltip gdextension.String
	}{menu, pointers.Get(gd.InternalString(tooltip))}))
}

/*
Returns menu item tooltip.
*/
//go:nosplit
func (self class) GetMenuTooltip(menu int64) String.Readable { //gd:MenuBar.get_menu_tooltip
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_menu_tooltip, gdextension.SizeString|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ menu int64 }{menu}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
If [code]true[/code], menu item is disabled.
*/
//go:nosplit
func (self class) SetMenuDisabled(menu int64, disabled bool) { //gd:MenuBar.set_menu_disabled
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_menu_disabled, 0|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		menu     int64
		disabled bool
	}{menu, disabled}))
}

/*
Returns [code]true[/code], if menu item is disabled.
*/
//go:nosplit
func (self class) IsMenuDisabled(menu int64) bool { //gd:MenuBar.is_menu_disabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_menu_disabled, gdextension.SizeBool|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ menu int64 }{menu}))
	var ret = r_ret
	return ret
}

/*
If [code]true[/code], menu item is hidden.
*/
//go:nosplit
func (self class) SetMenuHidden(menu int64, hidden bool) { //gd:MenuBar.set_menu_hidden
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_menu_hidden, 0|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		menu   int64
		hidden bool
	}{menu, hidden}))
}

/*
Returns [code]true[/code], if menu item is hidden.
*/
//go:nosplit
func (self class) IsMenuHidden(menu int64) bool { //gd:MenuBar.is_menu_hidden
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_menu_hidden, gdextension.SizeBool|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ menu int64 }{menu}))
	var ret = r_ret
	return ret
}

/*
Returns [PopupMenu] associated with menu item.
*/
//go:nosplit
func (self class) GetMenuPopup(menu int64) [1]gdclass.PopupMenu { //gd:MenuBar.get_menu_popup
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_menu_popup, gdextension.SizeObject|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ menu int64 }{menu}))
	var ret = [1]gdclass.PopupMenu{gd.PointerLifetimeBoundTo[gdclass.PopupMenu](self.AsObject(), r_ret)}
	return ret
}
func (self class) AsMenuBar() Advanced                 { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsMenuBar() Instance              { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsMenuBar() Instance         { return self.Super().AsMenuBar() }
func (self class) AsControl() Control.Advanced         { return *((*Control.Advanced)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsControl() Control.Instance { return self.Super().AsControl() }
func (self Instance) AsControl() Control.Instance {
	return *((*Control.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsCanvasItem() CanvasItem.Advanced {
	return *((*CanvasItem.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsCanvasItem() CanvasItem.Instance { return self.Super().AsCanvasItem() }
func (self Instance) AsCanvasItem() CanvasItem.Instance {
	return *((*CanvasItem.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsNode() Node.Advanced         { return *((*Node.Advanced)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsNode() Node.Instance { return self.Super().AsNode() }
func (self Instance) AsNode() Node.Instance      { return *((*Node.Instance)(unsafe.Pointer(&self))) }

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Control.Advanced(self.AsControl()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Control.Instance(self.AsControl()), name)
	}
}
func init() {
	gdclass.Register("MenuBar", func(ptr gd.Object) any { return *(*Instance)(unsafe.Pointer(&ptr)) })
}
