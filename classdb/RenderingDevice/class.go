// Code generated by the generate package DO NOT EDIT

// Package RenderingDevice provides methods for working with RenderingDevice object instances.
package RenderingDevice

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/RDAttachmentFormat"
import "graphics.gd/classdb/RDFramebufferPass"
import "graphics.gd/classdb/RDPipelineColorBlendState"
import "graphics.gd/classdb/RDPipelineDepthStencilState"
import "graphics.gd/classdb/RDPipelineMultisampleState"
import "graphics.gd/classdb/RDPipelineRasterizationState"
import "graphics.gd/classdb/RDPipelineSpecializationConstant"
import "graphics.gd/classdb/RDSamplerState"
import "graphics.gd/classdb/RDShaderSPIRV"
import "graphics.gd/classdb/RDShaderSource"
import "graphics.gd/classdb/RDTextureFormat"
import "graphics.gd/classdb/RDTextureView"
import "graphics.gd/classdb/RDUniform"
import "graphics.gd/classdb/RDVertexAttribute"
import "graphics.gd/classdb/Rendering"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Color"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/Rect2"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"
import "graphics.gd/variant/Vector2i"
import "graphics.gd/variant/Vector3"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
[RenderingDevice] is an abstraction for working with modern low-level graphics APIs such as Vulkan. Compared to [RenderingServer] (which works with Godot's own rendering subsystems), [RenderingDevice] is much lower-level and allows working more directly with the underlying graphics APIs. [RenderingDevice] is used in Godot to provide support for several modern low-level graphics APIs while reducing the amount of code duplication required. [RenderingDevice] can also be used in your own projects to perform things that are not exposed by [RenderingServer] or high-level nodes, such as using compute shaders.
On startup, Godot creates a global [RenderingDevice] which can be retrieved using [method RenderingServer.get_rendering_device]. This global [RenderingDevice] performs drawing to the screen.
[b]Local RenderingDevices:[/b] Using [method RenderingServer.create_local_rendering_device], you can create "secondary" rendering devices to perform drawing and GPU compute operations on separate threads.
[b]Note:[/b] [RenderingDevice] assumes intermediate knowledge of modern graphics APIs such as Vulkan, Direct3D 12, Metal or WebGPU. These graphics APIs are lower-level than OpenGL or Direct3D 11, requiring you to perform what was previously done by the graphics driver itself. If you have difficulty understanding the concepts used in this class, follow the [url=https://vulkan-tutorial.com/]Vulkan Tutorial[/url] or [url=https://vkguide.dev/]Vulkan Guide[/url]. It's recommended to have existing modern OpenGL or Direct3D 11 knowledge before attempting to learn a low-level graphics API.
[b]Note:[/b] [RenderingDevice] is not available when running in headless mode or when using the Compatibility rendering method.
*/
type Instance [1]gdclass.RenderingDevice

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	texture_create                         gdextension.MethodForClass `hash:"3709173589"`
	texture_create_shared                  gdextension.MethodForClass `hash:"3178156134"`
	texture_create_shared_from_slice       gdextension.MethodForClass `hash:"1808971279"`
	texture_create_from_extension          gdextension.MethodForClass `hash:"1397171480"`
	texture_update                         gdextension.MethodForClass `hash:"1349464008"`
	texture_get_data                       gdextension.MethodForClass `hash:"1859412099"`
	texture_get_data_async                 gdextension.MethodForClass `hash:"498832090"`
	texture_is_format_supported_for_usage  gdextension.MethodForClass `hash:"2592520478"`
	texture_is_shared                      gdextension.MethodForClass `hash:"3521089500"`
	texture_is_valid                       gdextension.MethodForClass `hash:"3521089500"`
	texture_set_discardable                gdextension.MethodForClass `hash:"1265174801"`
	texture_is_discardable                 gdextension.MethodForClass `hash:"3521089500"`
	texture_copy                           gdextension.MethodForClass `hash:"2859522160"`
	texture_clear                          gdextension.MethodForClass `hash:"3477703247"`
	texture_resolve_multisample            gdextension.MethodForClass `hash:"3181288260"`
	texture_get_format                     gdextension.MethodForClass `hash:"1374471690"`
	texture_get_native_handle              gdextension.MethodForClass `hash:"3917799429"`
	framebuffer_format_create              gdextension.MethodForClass `hash:"697032759"`
	framebuffer_format_create_multipass    gdextension.MethodForClass `hash:"2647479094"`
	framebuffer_format_create_empty        gdextension.MethodForClass `hash:"555930169"`
	framebuffer_format_get_texture_samples gdextension.MethodForClass `hash:"4223391010"`
	framebuffer_create                     gdextension.MethodForClass `hash:"3284231055"`
	framebuffer_create_multipass           gdextension.MethodForClass `hash:"1750306695"`
	framebuffer_create_empty               gdextension.MethodForClass `hash:"3058360618"`
	framebuffer_get_format                 gdextension.MethodForClass `hash:"3917799429"`
	framebuffer_is_valid                   gdextension.MethodForClass `hash:"4155700596"`
	sampler_create                         gdextension.MethodForClass `hash:"2327892535"`
	sampler_is_format_supported_for_filter gdextension.MethodForClass `hash:"2247922238"`
	vertex_buffer_create                   gdextension.MethodForClass `hash:"2089548973"`
	vertex_format_create                   gdextension.MethodForClass `hash:"1242678479"`
	vertex_array_create                    gdextension.MethodForClass `hash:"3799816279"`
	index_buffer_create                    gdextension.MethodForClass `hash:"2368684885"`
	index_array_create                     gdextension.MethodForClass `hash:"2256026069"`
	shader_compile_spirv_from_source       gdextension.MethodForClass `hash:"1178973306"`
	shader_compile_binary_from_spirv       gdextension.MethodForClass `hash:"134910450"`
	shader_create_from_spirv               gdextension.MethodForClass `hash:"342949005"`
	shader_create_from_bytecode            gdextension.MethodForClass `hash:"1687031350"`
	shader_create_placeholder              gdextension.MethodForClass `hash:"529393457"`
	shader_get_vertex_input_attribute_mask gdextension.MethodForClass `hash:"3917799429"`
	uniform_buffer_create                  gdextension.MethodForClass `hash:"2089548973"`
	storage_buffer_create                  gdextension.MethodForClass `hash:"1609052553"`
	texture_buffer_create                  gdextension.MethodForClass `hash:"1470338698"`
	uniform_set_create                     gdextension.MethodForClass `hash:"2280795797"`
	uniform_set_is_valid                   gdextension.MethodForClass `hash:"3521089500"`
	buffer_copy                            gdextension.MethodForClass `hash:"864257779"`
	buffer_update                          gdextension.MethodForClass `hash:"3454956949"`
	buffer_clear                           gdextension.MethodForClass `hash:"2452320800"`
	buffer_get_data                        gdextension.MethodForClass `hash:"3101830688"`
	buffer_get_data_async                  gdextension.MethodForClass `hash:"2370287848"`
	buffer_get_device_address              gdextension.MethodForClass `hash:"3917799429"`
	render_pipeline_create                 gdextension.MethodForClass `hash:"2385451958"`
	render_pipeline_is_valid               gdextension.MethodForClass `hash:"3521089500"`
	compute_pipeline_create                gdextension.MethodForClass `hash:"1448838280"`
	compute_pipeline_is_valid              gdextension.MethodForClass `hash:"3521089500"`
	screen_get_width                       gdextension.MethodForClass `hash:"1591665591"`
	screen_get_height                      gdextension.MethodForClass `hash:"1591665591"`
	screen_get_framebuffer_format          gdextension.MethodForClass `hash:"1591665591"`
	draw_list_begin_for_screen             gdextension.MethodForClass `hash:"3988079995"`
	draw_list_begin                        gdextension.MethodForClass `hash:"1317926357"`
	draw_list_begin_split                  gdextension.MethodForClass `hash:"2406300660"`
	draw_list_set_blend_constants          gdextension.MethodForClass `hash:"2878471219"`
	draw_list_bind_render_pipeline         gdextension.MethodForClass `hash:"4040184819"`
	draw_list_bind_uniform_set             gdextension.MethodForClass `hash:"749655778"`
	draw_list_bind_vertex_array            gdextension.MethodForClass `hash:"4040184819"`
	draw_list_bind_index_array             gdextension.MethodForClass `hash:"4040184819"`
	draw_list_set_push_constant            gdextension.MethodForClass `hash:"2772371345"`
	draw_list_draw                         gdextension.MethodForClass `hash:"4230067973"`
	draw_list_draw_indirect                gdextension.MethodForClass `hash:"1092133571"`
	draw_list_enable_scissor               gdextension.MethodForClass `hash:"244650101"`
	draw_list_disable_scissor              gdextension.MethodForClass `hash:"1286410249"`
	draw_list_switch_to_next_pass          gdextension.MethodForClass `hash:"2455072627"`
	draw_list_switch_to_next_pass_split    gdextension.MethodForClass `hash:"2865087369"`
	draw_list_end                          gdextension.MethodForClass `hash:"3218959716"`
	compute_list_begin                     gdextension.MethodForClass `hash:"2455072627"`
	compute_list_bind_compute_pipeline     gdextension.MethodForClass `hash:"4040184819"`
	compute_list_set_push_constant         gdextension.MethodForClass `hash:"2772371345"`
	compute_list_bind_uniform_set          gdextension.MethodForClass `hash:"749655778"`
	compute_list_dispatch                  gdextension.MethodForClass `hash:"4275841770"`
	compute_list_dispatch_indirect         gdextension.MethodForClass `hash:"749655778"`
	compute_list_add_barrier               gdextension.MethodForClass `hash:"1286410249"`
	compute_list_end                       gdextension.MethodForClass `hash:"3218959716"`
	free_rid                               gdextension.MethodForClass `hash:"2722037293"`
	capture_timestamp                      gdextension.MethodForClass `hash:"83702148"`
	get_captured_timestamps_count          gdextension.MethodForClass `hash:"3905245786"`
	get_captured_timestamps_frame          gdextension.MethodForClass `hash:"3905245786"`
	get_captured_timestamp_gpu_time        gdextension.MethodForClass `hash:"923996154"`
	get_captured_timestamp_cpu_time        gdextension.MethodForClass `hash:"923996154"`
	get_captured_timestamp_name            gdextension.MethodForClass `hash:"844755477"`
	has_feature                            gdextension.MethodForClass `hash:"1772728326"`
	limit_get                              gdextension.MethodForClass `hash:"1559202131"`
	get_frame_delay                        gdextension.MethodForClass `hash:"3905245786"`
	submit                                 gdextension.MethodForClass `hash:"3218959716"`
	sync                                   gdextension.MethodForClass `hash:"3218959716"`
	barrier                                gdextension.MethodForClass `hash:"3718155691"`
	full_barrier                           gdextension.MethodForClass `hash:"3218959716"`
	create_local_device                    gdextension.MethodForClass `hash:"2846302423"`
	set_resource_name                      gdextension.MethodForClass `hash:"2726140452"`
	draw_command_begin_label               gdextension.MethodForClass `hash:"1636512886"`
	draw_command_insert_label              gdextension.MethodForClass `hash:"1636512886"`
	draw_command_end_label                 gdextension.MethodForClass `hash:"3218959716"`
	get_device_vendor_name                 gdextension.MethodForClass `hash:"201670096"`
	get_device_name                        gdextension.MethodForClass `hash:"201670096"`
	get_device_pipeline_cache_uuid         gdextension.MethodForClass `hash:"201670096"`
	get_memory_usage                       gdextension.MethodForClass `hash:"251690689"`
	get_driver_resource                    gdextension.MethodForClass `hash:"501815484"`
	get_perf_report                        gdextension.MethodForClass `hash:"201670096"`
	get_driver_and_device_memory_report    gdextension.MethodForClass `hash:"201670096"`
	get_tracked_object_name                gdextension.MethodForClass `hash:"844755477"`
	get_tracked_object_type_count          gdextension.MethodForClass `hash:"3905245786"`
	get_driver_total_memory                gdextension.MethodForClass `hash:"3905245786"`
	get_driver_allocation_count            gdextension.MethodForClass `hash:"3905245786"`
	get_driver_memory_by_object_type       gdextension.MethodForClass `hash:"923996154"`
	get_driver_allocs_by_object_type       gdextension.MethodForClass `hash:"923996154"`
	get_device_total_memory                gdextension.MethodForClass `hash:"3905245786"`
	get_device_allocation_count            gdextension.MethodForClass `hash:"3905245786"`
	get_device_memory_by_object_type       gdextension.MethodForClass `hash:"923996154"`
	get_device_allocs_by_object_type       gdextension.MethodForClass `hash:"923996154"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("RenderingDevice")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		pointers.Raw[gd.StringName](sname).Free()
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

type Expanded [1]gdclass.RenderingDevice

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsRenderingDevice() Instance
}

/*
Creates a new texture. It can be accessed with the RID that is returned.
Once finished with your RID, you will want to free the RID using the RenderingDevice's [method free_rid] method.
[b]Note:[/b] Not to be confused with [method RenderingServer.texture_2d_create], which creates the Godot-specific [Texture2D] resource as opposed to the graphics API's own texture type.
*/
func (self Instance) TextureCreate(format RDTextureFormat.Instance, view RDTextureView.Instance) RID.Texture { //gd:RenderingDevice.texture_create
	return RID.Texture(Advanced(self).TextureCreate(format, view, gd.ArrayFromSlice[Array.Contains[Packed.Bytes]]([1][][]byte{}[0])))
}

/*
Creates a new texture. It can be accessed with the RID that is returned.
Once finished with your RID, you will want to free the RID using the RenderingDevice's [method free_rid] method.
[b]Note:[/b] Not to be confused with [method RenderingServer.texture_2d_create], which creates the Godot-specific [Texture2D] resource as opposed to the graphics API's own texture type.
*/
func (self Expanded) TextureCreate(format RDTextureFormat.Instance, view RDTextureView.Instance, data [][]byte) RID.Texture { //gd:RenderingDevice.texture_create
	return RID.Texture(Advanced(self).TextureCreate(format, view, gd.ArrayFromSlice[Array.Contains[Packed.Bytes]](data)))
}

/*
Creates a shared texture using the specified [param view] and the texture information from [param with_texture].
*/
func (self Instance) TextureCreateShared(view RDTextureView.Instance, with_texture RID.Texture) RID.Texture { //gd:RenderingDevice.texture_create_shared
	return RID.Texture(Advanced(self).TextureCreateShared(view, RID.Any(with_texture)))
}

/*
Creates a shared texture using the specified [param view] and the texture information from [param with_texture]'s [param layer] and [param mipmap]. The number of included mipmaps from the original texture can be controlled using the [param mipmaps] parameter. Only relevant for textures with multiple layers, such as 3D textures, texture arrays and cubemaps. For single-layer textures, use [method texture_create_shared].
For 2D textures (which only have one layer), [param layer] must be [code]0[/code].
[b]Note:[/b] Layer slicing is only supported for 2D texture arrays, not 3D textures or cubemaps.
*/
func (self Instance) TextureCreateSharedFromSlice(view RDTextureView.Instance, with_texture RID.Texture, layer int, mipmap int) RID.Texture { //gd:RenderingDevice.texture_create_shared_from_slice
	return RID.Texture(Advanced(self).TextureCreateSharedFromSlice(view, RID.Any(with_texture), int64(layer), int64(mipmap), int64(1), 0))
}

/*
Creates a shared texture using the specified [param view] and the texture information from [param with_texture]'s [param layer] and [param mipmap]. The number of included mipmaps from the original texture can be controlled using the [param mipmaps] parameter. Only relevant for textures with multiple layers, such as 3D textures, texture arrays and cubemaps. For single-layer textures, use [method texture_create_shared].
For 2D textures (which only have one layer), [param layer] must be [code]0[/code].
[b]Note:[/b] Layer slicing is only supported for 2D texture arrays, not 3D textures or cubemaps.
*/
func (self Expanded) TextureCreateSharedFromSlice(view RDTextureView.Instance, with_texture RID.Texture, layer int, mipmap int, mipmaps int, slice_type Rendering.TextureSliceType) RID.Texture { //gd:RenderingDevice.texture_create_shared_from_slice
	return RID.Texture(Advanced(self).TextureCreateSharedFromSlice(view, RID.Any(with_texture), int64(layer), int64(mipmap), int64(mipmaps), slice_type))
}

/*
Returns an RID for an existing [param image] ([code]VkImage[/code]) with the given [param type], [param format], [param samples], [param usage_flags], [param width], [param height], [param depth], and [param layers]. This can be used to allow Godot to render onto foreign images.
*/
func (self Instance) TextureCreateFromExtension(atype Rendering.TextureType, format Rendering.DataFormat, samples Rendering.TextureSamples, usage_flags Rendering.TextureUsageBits, image int, width int, height int, depth int, layers int) RID.Texture { //gd:RenderingDevice.texture_create_from_extension
	return RID.Texture(Advanced(self).TextureCreateFromExtension(atype, format, samples, usage_flags, int64(image), int64(width), int64(height), int64(depth), int64(layers)))
}

/*
Updates texture data with new data, replacing the previous data in place. The updated texture data must have the same dimensions and format. For 2D textures (which only have one layer), [param layer] must be [code]0[/code]. Returns [constant @GlobalScope.OK] if the update was successful, [constant @GlobalScope.ERR_INVALID_PARAMETER] otherwise.
[b]Note:[/b] Updating textures is forbidden during creation of a draw or compute list.
[b]Note:[/b] The existing [param texture] can't be updated while a draw list that uses it as part of a framebuffer is being created. Ensure the draw list is finalized (and that the color/depth texture using it is not set to [constant FINAL_ACTION_CONTINUE]) to update this texture.
[b]Note:[/b] The existing [param texture] requires the [constant TEXTURE_USAGE_CAN_UPDATE_BIT] to be updatable.
*/
func (self Instance) TextureUpdate(texture RID.Texture, layer int, data []byte) error { //gd:RenderingDevice.texture_update
	return error(gd.ToError(Advanced(self).TextureUpdate(RID.Any(texture), int64(layer), Packed.Bytes(Packed.New(data...)))))
}

/*
Returns the [param texture] data for the specified [param layer] as raw binary data. For 2D textures (which only have one layer), [param layer] must be [code]0[/code].
[b]Note:[/b] [param texture] can't be retrieved while a draw list that uses it as part of a framebuffer is being created. Ensure the draw list is finalized (and that the color/depth texture using it is not set to [constant FINAL_ACTION_CONTINUE]) to retrieve this texture. Otherwise, an error is printed and a empty [PackedByteArray] is returned.
[b]Note:[/b] [param texture] requires the [constant TEXTURE_USAGE_CAN_COPY_FROM_BIT] to be retrieved. Otherwise, an error is printed and a empty [PackedByteArray] is returned.
[b]Note:[/b] This method will block the GPU from working until the data is retrieved. Refer to [method texture_get_data_async] for an alternative that returns the data in more performant way.
*/
func (self Instance) TextureGetData(texture RID.Texture, layer int) []byte { //gd:RenderingDevice.texture_get_data
	return []byte(Advanced(self).TextureGetData(RID.Any(texture), int64(layer)).Bytes())
}

/*
Asynchronous version of [method texture_get_data]. RenderingDevice will call [param callback] in a certain amount of frames with the data the texture had at the time of the request.
[b]Note:[/b] At the moment, the delay corresponds to the amount of frames specified by [member ProjectSettings.rendering/rendering_device/vsync/frame_queue_size].
[b]Note:[/b] Downloading large textures can have a prohibitive cost for real-time even when using the asynchronous method due to hardware bandwidth limitations. When dealing with large resources, you can adjust settings such as [member ProjectSettings.rendering/rendering_device/staging_buffer/texture_download_region_size_px] and [member ProjectSettings.rendering/rendering_device/staging_buffer/block_size_kb] to improve the transfer speed at the cost of extra memory.
[codeblock]
func _texture_get_data_callback(array):

	value = array.decode_u32(0)

...

rd.texture_get_data_async(texture, 0, _texture_get_data_callback)
[/codeblock]
*/
func (self Instance) TextureGetDataAsync(texture RID.Texture, layer int, callback func(data []byte)) error { //gd:RenderingDevice.texture_get_data_async
	return error(gd.ToError(Advanced(self).TextureGetDataAsync(RID.Any(texture), int64(layer), Callable.New(callback))))
}

/*
Returns [code]true[/code] if the specified [param format] is supported for the given [param usage_flags], [code]false[/code] otherwise.
*/
func (self Instance) TextureIsFormatSupportedForUsage(format Rendering.DataFormat, usage_flags Rendering.TextureUsageBits) bool { //gd:RenderingDevice.texture_is_format_supported_for_usage
	return bool(Advanced(self).TextureIsFormatSupportedForUsage(format, usage_flags))
}

/*
Returns [code]true[/code] if the [param texture] is shared, [code]false[/code] otherwise. See [RDTextureView].
*/
func (self Instance) TextureIsShared(texture RID.Texture) bool { //gd:RenderingDevice.texture_is_shared
	return bool(Advanced(self).TextureIsShared(RID.Any(texture)))
}

/*
Returns [code]true[/code] if the [param texture] is valid, [code]false[/code] otherwise.
*/
func (self Instance) TextureIsValid(texture RID.Texture) bool { //gd:RenderingDevice.texture_is_valid
	return bool(Advanced(self).TextureIsValid(RID.Any(texture)))
}

/*
Updates the discardable property of [param texture].
If a texture is discardable, its contents do not need to be preserved between frames. This flag is only relevant when the texture is used as target in a draw list.
This information is used by [RenderingDevice] to figure out if a texture's contents can be discarded, eliminating unnecessary writes to memory and boosting performance.
*/
func (self Instance) TextureSetDiscardable(texture RID.Texture, discardable bool) { //gd:RenderingDevice.texture_set_discardable
	Advanced(self).TextureSetDiscardable(RID.Any(texture), discardable)
}

/*
Returns [code]true[/code] if the [param texture] is discardable, [code]false[/code] otherwise. See [RDTextureFormat] or [method texture_set_discardable].
*/
func (self Instance) TextureIsDiscardable(texture RID.Texture) bool { //gd:RenderingDevice.texture_is_discardable
	return bool(Advanced(self).TextureIsDiscardable(RID.Any(texture)))
}

/*
Copies the [param from_texture] to [param to_texture] with the specified [param from_pos], [param to_pos] and [param size] coordinates. The Z axis of the [param from_pos], [param to_pos] and [param size] must be [code]0[/code] for 2-dimensional textures. Source and destination mipmaps/layers must also be specified, with these parameters being [code]0[/code] for textures without mipmaps or single-layer textures. Returns [constant @GlobalScope.OK] if the texture copy was successful or [constant @GlobalScope.ERR_INVALID_PARAMETER] otherwise.
[b]Note:[/b] [param from_texture] texture can't be copied while a draw list that uses it as part of a framebuffer is being created. Ensure the draw list is finalized (and that the color/depth texture using it is not set to [constant FINAL_ACTION_CONTINUE]) to copy this texture.
[b]Note:[/b] [param from_texture] texture requires the [constant TEXTURE_USAGE_CAN_COPY_FROM_BIT] to be retrieved.
[b]Note:[/b] [param to_texture] can't be copied while a draw list that uses it as part of a framebuffer is being created. Ensure the draw list is finalized (and that the color/depth texture using it is not set to [constant FINAL_ACTION_CONTINUE]) to copy this texture.
[b]Note:[/b] [param to_texture] requires the [constant TEXTURE_USAGE_CAN_COPY_TO_BIT] to be retrieved.
[b]Note:[/b] [param from_texture] and [param to_texture] must be of the same type (color or depth).
*/
func (self Instance) TextureCopy(from_texture RID.Texture, to_texture RID.Texture, from_pos Vector3.XYZ, to_pos Vector3.XYZ, size Vector3.XYZ, src_mipmap int, dst_mipmap int, src_layer int, dst_layer int) error { //gd:RenderingDevice.texture_copy
	return error(gd.ToError(Advanced(self).TextureCopy(RID.Any(from_texture), RID.Any(to_texture), Vector3.XYZ(from_pos), Vector3.XYZ(to_pos), Vector3.XYZ(size), int64(src_mipmap), int64(dst_mipmap), int64(src_layer), int64(dst_layer))))
}

/*
Clears the specified [param texture] by replacing all of its pixels with the specified [param color]. [param base_mipmap] and [param mipmap_count] determine which mipmaps of the texture are affected by this clear operation, while [param base_layer] and [param layer_count] determine which layers of a 3D texture (or texture array) are affected by this clear operation. For 2D textures (which only have one layer by design), [param base_layer] must be [code]0[/code] and [param layer_count] must be [code]1[/code].
[b]Note:[/b] [param texture] can't be cleared while a draw list that uses it as part of a framebuffer is being created. Ensure the draw list is finalized (and that the color/depth texture using it is not set to [constant FINAL_ACTION_CONTINUE]) to clear this texture.
*/
func (self Instance) TextureClear(texture RID.Texture, color Color.RGBA, base_mipmap int, mipmap_count int, base_layer int, layer_count int) error { //gd:RenderingDevice.texture_clear
	return error(gd.ToError(Advanced(self).TextureClear(RID.Any(texture), Color.RGBA(color), int64(base_mipmap), int64(mipmap_count), int64(base_layer), int64(layer_count))))
}

/*
Resolves the [param from_texture] texture onto [param to_texture] with multisample antialiasing enabled. This must be used when rendering a framebuffer for MSAA to work. Returns [constant @GlobalScope.OK] if successful, [constant @GlobalScope.ERR_INVALID_PARAMETER] otherwise.
[b]Note:[/b] [param from_texture] and [param to_texture] textures must have the same dimension, format and type (color or depth).
[b]Note:[/b] [param from_texture] can't be copied while a draw list that uses it as part of a framebuffer is being created. Ensure the draw list is finalized (and that the color/depth texture using it is not set to [constant FINAL_ACTION_CONTINUE]) to resolve this texture.
[b]Note:[/b] [param from_texture] requires the [constant TEXTURE_USAGE_CAN_COPY_FROM_BIT] to be retrieved.
[b]Note:[/b] [param from_texture] must be multisampled and must also be 2D (or a slice of a 3D/cubemap texture).
[b]Note:[/b] [param to_texture] can't be copied while a draw list that uses it as part of a framebuffer is being created. Ensure the draw list is finalized (and that the color/depth texture using it is not set to [constant FINAL_ACTION_CONTINUE]) to resolve this texture.
[b]Note:[/b] [param to_texture] texture requires the [constant TEXTURE_USAGE_CAN_COPY_TO_BIT] to be retrieved.
[b]Note:[/b] [param to_texture] texture must [b]not[/b] be multisampled and must also be 2D (or a slice of a 3D/cubemap texture).
*/
func (self Instance) TextureResolveMultisample(from_texture RID.Texture, to_texture RID.Texture) error { //gd:RenderingDevice.texture_resolve_multisample
	return error(gd.ToError(Advanced(self).TextureResolveMultisample(RID.Any(from_texture), RID.Any(to_texture))))
}

/*
Returns the data format used to create this texture.
*/
func (self Instance) TextureGetFormat(texture RID.Texture) RDTextureFormat.Instance { //gd:RenderingDevice.texture_get_format
	return RDTextureFormat.Instance(Advanced(self).TextureGetFormat(RID.Any(texture)))
}

/*
Returns the internal graphics handle for this texture object. For use when communicating with third-party APIs mostly with GDExtension.
[b]Note:[/b] This function returns a [code]uint64_t[/code] which internally maps to a [code]GLuint[/code] (OpenGL) or [code]VkImage[/code] (Vulkan).
*/
func (self Instance) TextureGetNativeHandle(texture RID.Texture) int { //gd:RenderingDevice.texture_get_native_handle
	return int(int(Advanced(self).TextureGetNativeHandle(RID.Any(texture))))
}

/*
Creates a new framebuffer format with the specified [param attachments] and [param view_count]. Returns the new framebuffer's unique framebuffer format ID.
If [param view_count] is greater than or equal to [code]2[/code], enables multiview which is used for VR rendering. This requires support for the Vulkan multiview extension.
*/
func (self Instance) FramebufferFormatCreate(attachments []RDAttachmentFormat.Instance) int { //gd:RenderingDevice.framebuffer_format_create
	return int(int(Advanced(self).FramebufferFormatCreate(gd.ArrayFromSlice[Array.Contains[[1]gdclass.RDAttachmentFormat]](attachments), int64(1))))
}

/*
Creates a new framebuffer format with the specified [param attachments] and [param view_count]. Returns the new framebuffer's unique framebuffer format ID.
If [param view_count] is greater than or equal to [code]2[/code], enables multiview which is used for VR rendering. This requires support for the Vulkan multiview extension.
*/
func (self Expanded) FramebufferFormatCreate(attachments []RDAttachmentFormat.Instance, view_count int) int { //gd:RenderingDevice.framebuffer_format_create
	return int(int(Advanced(self).FramebufferFormatCreate(gd.ArrayFromSlice[Array.Contains[[1]gdclass.RDAttachmentFormat]](attachments), int64(view_count))))
}

/*
Creates a multipass framebuffer format with the specified [param attachments], [param passes] and [param view_count] and returns its ID. If [param view_count] is greater than or equal to [code]2[/code], enables multiview which is used for VR rendering. This requires support for the Vulkan multiview extension.
*/
func (self Instance) FramebufferFormatCreateMultipass(attachments []RDAttachmentFormat.Instance, passes []RDFramebufferPass.Instance) int { //gd:RenderingDevice.framebuffer_format_create_multipass
	return int(int(Advanced(self).FramebufferFormatCreateMultipass(gd.ArrayFromSlice[Array.Contains[[1]gdclass.RDAttachmentFormat]](attachments), gd.ArrayFromSlice[Array.Contains[[1]gdclass.RDFramebufferPass]](passes), int64(1))))
}

/*
Creates a multipass framebuffer format with the specified [param attachments], [param passes] and [param view_count] and returns its ID. If [param view_count] is greater than or equal to [code]2[/code], enables multiview which is used for VR rendering. This requires support for the Vulkan multiview extension.
*/
func (self Expanded) FramebufferFormatCreateMultipass(attachments []RDAttachmentFormat.Instance, passes []RDFramebufferPass.Instance, view_count int) int { //gd:RenderingDevice.framebuffer_format_create_multipass
	return int(int(Advanced(self).FramebufferFormatCreateMultipass(gd.ArrayFromSlice[Array.Contains[[1]gdclass.RDAttachmentFormat]](attachments), gd.ArrayFromSlice[Array.Contains[[1]gdclass.RDFramebufferPass]](passes), int64(view_count))))
}

/*
Creates a new empty framebuffer format with the specified number of [param samples] and returns its ID.
*/
func (self Instance) FramebufferFormatCreateEmpty() int { //gd:RenderingDevice.framebuffer_format_create_empty
	return int(int(Advanced(self).FramebufferFormatCreateEmpty(0)))
}

/*
Creates a new empty framebuffer format with the specified number of [param samples] and returns its ID.
*/
func (self Expanded) FramebufferFormatCreateEmpty(samples Rendering.TextureSamples) int { //gd:RenderingDevice.framebuffer_format_create_empty
	return int(int(Advanced(self).FramebufferFormatCreateEmpty(samples)))
}

/*
Returns the number of texture samples used for the given framebuffer [param format] ID (returned by [method framebuffer_get_format]).
*/
func (self Instance) FramebufferFormatGetTextureSamples(format int) Rendering.TextureSamples { //gd:RenderingDevice.framebuffer_format_get_texture_samples
	return Rendering.TextureSamples(Advanced(self).FramebufferFormatGetTextureSamples(int64(format), int64(0)))
}

/*
Returns the number of texture samples used for the given framebuffer [param format] ID (returned by [method framebuffer_get_format]).
*/
func (self Expanded) FramebufferFormatGetTextureSamples(format int, render_pass int) Rendering.TextureSamples { //gd:RenderingDevice.framebuffer_format_get_texture_samples
	return Rendering.TextureSamples(Advanced(self).FramebufferFormatGetTextureSamples(int64(format), int64(render_pass)))
}

/*
Creates a new framebuffer. It can be accessed with the RID that is returned.
Once finished with your RID, you will want to free the RID using the RenderingDevice's [method free_rid] method.
*/
func (self Instance) FramebufferCreate(textures [][]RID.Texture) RID.Framebuffer { //gd:RenderingDevice.framebuffer_create
	return RID.Framebuffer(Advanced(self).FramebufferCreate(gd.ArrayFromSlice[Array.Contains[RID.Any]](textures), int64(-1), int64(1)))
}

/*
Creates a new framebuffer. It can be accessed with the RID that is returned.
Once finished with your RID, you will want to free the RID using the RenderingDevice's [method free_rid] method.
*/
func (self Expanded) FramebufferCreate(textures [][]RID.Texture, validate_with_format int, view_count int) RID.Framebuffer { //gd:RenderingDevice.framebuffer_create
	return RID.Framebuffer(Advanced(self).FramebufferCreate(gd.ArrayFromSlice[Array.Contains[RID.Any]](textures), int64(validate_with_format), int64(view_count)))
}

/*
Creates a new multipass framebuffer. It can be accessed with the RID that is returned.
Once finished with your RID, you will want to free the RID using the RenderingDevice's [method free_rid] method.
*/
func (self Instance) FramebufferCreateMultipass(textures [][]RID.Texture, passes []RDFramebufferPass.Instance) RID.Framebuffer { //gd:RenderingDevice.framebuffer_create_multipass
	return RID.Framebuffer(Advanced(self).FramebufferCreateMultipass(gd.ArrayFromSlice[Array.Contains[RID.Any]](textures), gd.ArrayFromSlice[Array.Contains[[1]gdclass.RDFramebufferPass]](passes), int64(-1), int64(1)))
}

/*
Creates a new multipass framebuffer. It can be accessed with the RID that is returned.
Once finished with your RID, you will want to free the RID using the RenderingDevice's [method free_rid] method.
*/
func (self Expanded) FramebufferCreateMultipass(textures [][]RID.Texture, passes []RDFramebufferPass.Instance, validate_with_format int, view_count int) RID.Framebuffer { //gd:RenderingDevice.framebuffer_create_multipass
	return RID.Framebuffer(Advanced(self).FramebufferCreateMultipass(gd.ArrayFromSlice[Array.Contains[RID.Any]](textures), gd.ArrayFromSlice[Array.Contains[[1]gdclass.RDFramebufferPass]](passes), int64(validate_with_format), int64(view_count)))
}

/*
Creates a new empty framebuffer. It can be accessed with the RID that is returned.
Once finished with your RID, you will want to free the RID using the RenderingDevice's [method free_rid] method.
*/
func (self Instance) FramebufferCreateEmpty(size Vector2i.XY) RID.Framebuffer { //gd:RenderingDevice.framebuffer_create_empty
	return RID.Framebuffer(Advanced(self).FramebufferCreateEmpty(Vector2i.XY(size), 0, int64(-1)))
}

/*
Creates a new empty framebuffer. It can be accessed with the RID that is returned.
Once finished with your RID, you will want to free the RID using the RenderingDevice's [method free_rid] method.
*/
func (self Expanded) FramebufferCreateEmpty(size Vector2i.XY, samples Rendering.TextureSamples, validate_with_format int) RID.Framebuffer { //gd:RenderingDevice.framebuffer_create_empty
	return RID.Framebuffer(Advanced(self).FramebufferCreateEmpty(Vector2i.XY(size), samples, int64(validate_with_format)))
}

/*
Returns the format ID of the framebuffer specified by the [param framebuffer] RID. This ID is guaranteed to be unique for the same formats and does not need to be freed.
*/
func (self Instance) FramebufferGetFormat(framebuffer RID.Framebuffer) int { //gd:RenderingDevice.framebuffer_get_format
	return int(int(Advanced(self).FramebufferGetFormat(RID.Any(framebuffer))))
}

/*
Returns [code]true[/code] if the framebuffer specified by the [param framebuffer] RID is valid, [code]false[/code] otherwise.
*/
func (self Instance) FramebufferIsValid(framebuffer RID.Framebuffer) bool { //gd:RenderingDevice.framebuffer_is_valid
	return bool(Advanced(self).FramebufferIsValid(RID.Any(framebuffer)))
}

/*
Creates a new sampler. It can be accessed with the RID that is returned.
Once finished with your RID, you will want to free the RID using the RenderingDevice's [method free_rid] method.
*/
func (self Instance) SamplerCreate(state RDSamplerState.Instance) RID.Sampler { //gd:RenderingDevice.sampler_create
	return RID.Sampler(Advanced(self).SamplerCreate(state))
}

/*
Returns [code]true[/code] if implementation supports using a texture of [param format] with the given [param sampler_filter].
*/
func (self Instance) SamplerIsFormatSupportedForFilter(format Rendering.DataFormat, sampler_filter Rendering.SamplerFilter) bool { //gd:RenderingDevice.sampler_is_format_supported_for_filter
	return bool(Advanced(self).SamplerIsFormatSupportedForFilter(format, sampler_filter))
}

/*
It can be accessed with the RID that is returned.
Once finished with your RID, you will want to free the RID using the RenderingDevice's [method free_rid] method.
*/
func (self Instance) VertexBufferCreate(size_bytes int) RID.VertexBuffer { //gd:RenderingDevice.vertex_buffer_create
	return RID.VertexBuffer(Advanced(self).VertexBufferCreate(int64(size_bytes), Packed.Bytes(Packed.New([1][]byte{}[0]...)), 0))
}

/*
It can be accessed with the RID that is returned.
Once finished with your RID, you will want to free the RID using the RenderingDevice's [method free_rid] method.
*/
func (self Expanded) VertexBufferCreate(size_bytes int, data []byte, creation_bits Rendering.BufferCreationBits) RID.VertexBuffer { //gd:RenderingDevice.vertex_buffer_create
	return RID.VertexBuffer(Advanced(self).VertexBufferCreate(int64(size_bytes), Packed.Bytes(Packed.New(data...)), creation_bits))
}

/*
Creates a new vertex format with the specified [param vertex_descriptions]. Returns a unique vertex format ID corresponding to the newly created vertex format.
*/
func (self Instance) VertexFormatCreate(vertex_descriptions []RDVertexAttribute.Instance) int { //gd:RenderingDevice.vertex_format_create
	return int(int(Advanced(self).VertexFormatCreate(gd.ArrayFromSlice[Array.Contains[[1]gdclass.RDVertexAttribute]](vertex_descriptions))))
}

/*
Creates a vertex array based on the specified buffers. Optionally, [param offsets] (in bytes) may be defined for each buffer.
*/
func (self Instance) VertexArrayCreate(vertex_count int, vertex_format int, src_buffers [][]RID.VertexBuffer) RID.VertexArray { //gd:RenderingDevice.vertex_array_create
	return RID.VertexArray(Advanced(self).VertexArrayCreate(int64(vertex_count), int64(vertex_format), gd.ArrayFromSlice[Array.Contains[RID.Any]](src_buffers), Packed.New([1][]int64{}[0]...)))
}

/*
Creates a vertex array based on the specified buffers. Optionally, [param offsets] (in bytes) may be defined for each buffer.
*/
func (self Expanded) VertexArrayCreate(vertex_count int, vertex_format int, src_buffers [][]RID.VertexBuffer, offsets []int64) RID.VertexArray { //gd:RenderingDevice.vertex_array_create
	return RID.VertexArray(Advanced(self).VertexArrayCreate(int64(vertex_count), int64(vertex_format), gd.ArrayFromSlice[Array.Contains[RID.Any]](src_buffers), Packed.New(offsets...)))
}

/*
Creates a new index buffer. It can be accessed with the RID that is returned.
Once finished with your RID, you will want to free the RID using the RenderingDevice's [method free_rid] method.
*/
func (self Instance) IndexBufferCreate(size_indices int, format Rendering.IndexBufferFormat) RID.IndexBuffer { //gd:RenderingDevice.index_buffer_create
	return RID.IndexBuffer(Advanced(self).IndexBufferCreate(int64(size_indices), format, Packed.Bytes(Packed.New([1][]byte{}[0]...)), false, 0))
}

/*
Creates a new index buffer. It can be accessed with the RID that is returned.
Once finished with your RID, you will want to free the RID using the RenderingDevice's [method free_rid] method.
*/
func (self Expanded) IndexBufferCreate(size_indices int, format Rendering.IndexBufferFormat, data []byte, use_restart_indices bool, creation_bits Rendering.BufferCreationBits) RID.IndexBuffer { //gd:RenderingDevice.index_buffer_create
	return RID.IndexBuffer(Advanced(self).IndexBufferCreate(int64(size_indices), format, Packed.Bytes(Packed.New(data...)), use_restart_indices, creation_bits))
}

/*
Creates a new index array. It can be accessed with the RID that is returned.
Once finished with your RID, you will want to free the RID using the RenderingDevice's [method free_rid] method.
*/
func (self Instance) IndexArrayCreate(index_buffer RID.IndexBuffer, index_offset int, index_count int) RID.IndexArray { //gd:RenderingDevice.index_array_create
	return RID.IndexArray(Advanced(self).IndexArrayCreate(RID.Any(index_buffer), int64(index_offset), int64(index_count)))
}

/*
Compiles a SPIR-V from the shader source code in [param shader_source] and returns the SPIR-V as a [RDShaderSPIRV]. This intermediate language shader is portable across different GPU models and driver versions, but cannot be run directly by GPUs until compiled into a binary shader using [method shader_compile_binary_from_spirv].
If [param allow_cache] is [code]true[/code], make use of the shader cache generated by Godot. This avoids a potentially lengthy shader compilation step if the shader is already in cache. If [param allow_cache] is [code]false[/code], Godot's shader cache is ignored and the shader will always be recompiled.
*/
func (self Instance) ShaderCompileSpirvFromSource(shader_source RDShaderSource.Instance) RDShaderSPIRV.Instance { //gd:RenderingDevice.shader_compile_spirv_from_source
	return RDShaderSPIRV.Instance(Advanced(self).ShaderCompileSpirvFromSource(shader_source, true))
}

/*
Compiles a SPIR-V from the shader source code in [param shader_source] and returns the SPIR-V as a [RDShaderSPIRV]. This intermediate language shader is portable across different GPU models and driver versions, but cannot be run directly by GPUs until compiled into a binary shader using [method shader_compile_binary_from_spirv].
If [param allow_cache] is [code]true[/code], make use of the shader cache generated by Godot. This avoids a potentially lengthy shader compilation step if the shader is already in cache. If [param allow_cache] is [code]false[/code], Godot's shader cache is ignored and the shader will always be recompiled.
*/
func (self Expanded) ShaderCompileSpirvFromSource(shader_source RDShaderSource.Instance, allow_cache bool) RDShaderSPIRV.Instance { //gd:RenderingDevice.shader_compile_spirv_from_source
	return RDShaderSPIRV.Instance(Advanced(self).ShaderCompileSpirvFromSource(shader_source, allow_cache))
}

/*
Compiles a binary shader from [param spirv_data] and returns the compiled binary data as a [PackedByteArray]. This compiled shader is specific to the GPU model and driver version used; it will not work on different GPU models or even different driver versions. See also [method shader_compile_spirv_from_source].
[param name] is an optional human-readable name that can be given to the compiled shader for organizational purposes.
*/
func (self Instance) ShaderCompileBinaryFromSpirv(spirv_data RDShaderSPIRV.Instance) []byte { //gd:RenderingDevice.shader_compile_binary_from_spirv
	return []byte(Advanced(self).ShaderCompileBinaryFromSpirv(spirv_data, String.New("")).Bytes())
}

/*
Compiles a binary shader from [param spirv_data] and returns the compiled binary data as a [PackedByteArray]. This compiled shader is specific to the GPU model and driver version used; it will not work on different GPU models or even different driver versions. See also [method shader_compile_spirv_from_source].
[param name] is an optional human-readable name that can be given to the compiled shader for organizational purposes.
*/
func (self Expanded) ShaderCompileBinaryFromSpirv(spirv_data RDShaderSPIRV.Instance, name string) []byte { //gd:RenderingDevice.shader_compile_binary_from_spirv
	return []byte(Advanced(self).ShaderCompileBinaryFromSpirv(spirv_data, String.New(name)).Bytes())
}

/*
Creates a new shader instance from SPIR-V intermediate code. It can be accessed with the RID that is returned.
Once finished with your RID, you will want to free the RID using the RenderingDevice's [method free_rid] method. See also [method shader_compile_spirv_from_source] and [method shader_create_from_bytecode].
*/
func (self Instance) ShaderCreateFromSpirv(spirv_data RDShaderSPIRV.Instance) RID.Shader { //gd:RenderingDevice.shader_create_from_spirv
	return RID.Shader(Advanced(self).ShaderCreateFromSpirv(spirv_data, String.New("")))
}

/*
Creates a new shader instance from SPIR-V intermediate code. It can be accessed with the RID that is returned.
Once finished with your RID, you will want to free the RID using the RenderingDevice's [method free_rid] method. See also [method shader_compile_spirv_from_source] and [method shader_create_from_bytecode].
*/
func (self Expanded) ShaderCreateFromSpirv(spirv_data RDShaderSPIRV.Instance, name string) RID.Shader { //gd:RenderingDevice.shader_create_from_spirv
	return RID.Shader(Advanced(self).ShaderCreateFromSpirv(spirv_data, String.New(name)))
}

/*
Creates a new shader instance from a binary compiled shader. It can be accessed with the RID that is returned.
Once finished with your RID, you will want to free the RID using the RenderingDevice's [method free_rid] method. See also [method shader_compile_binary_from_spirv] and [method shader_create_from_spirv].
*/
func (self Instance) ShaderCreateFromBytecode(binary_data []byte) RID.Shader { //gd:RenderingDevice.shader_create_from_bytecode
	return RID.Shader(Advanced(self).ShaderCreateFromBytecode(Packed.Bytes(Packed.New(binary_data...)), RID.Any([1]RID.Any{}[0])))
}

/*
Creates a new shader instance from a binary compiled shader. It can be accessed with the RID that is returned.
Once finished with your RID, you will want to free the RID using the RenderingDevice's [method free_rid] method. See also [method shader_compile_binary_from_spirv] and [method shader_create_from_spirv].
*/
func (self Expanded) ShaderCreateFromBytecode(binary_data []byte, placeholder_rid RID.ShaderPlaceholder) RID.Shader { //gd:RenderingDevice.shader_create_from_bytecode
	return RID.Shader(Advanced(self).ShaderCreateFromBytecode(Packed.Bytes(Packed.New(binary_data...)), RID.Any(placeholder_rid)))
}

/*
Create a placeholder RID by allocating an RID without initializing it for use in [method shader_create_from_bytecode]. This allows you to create an RID for a shader and pass it around, but defer compiling the shader to a later time.
*/
func (self Instance) ShaderCreatePlaceholder() RID.ShaderPlaceholder { //gd:RenderingDevice.shader_create_placeholder
	return RID.ShaderPlaceholder(Advanced(self).ShaderCreatePlaceholder())
}

/*
Returns the internal vertex input mask. Internally, the vertex input mask is an unsigned integer consisting of the locations (specified in GLSL via. [code]layout(location = ...)[/code]) of the input variables (specified in GLSL by the [code]in[/code] keyword).
*/
func (self Instance) ShaderGetVertexInputAttributeMask(shader RID.Shader) int { //gd:RenderingDevice.shader_get_vertex_input_attribute_mask
	return int(int(Advanced(self).ShaderGetVertexInputAttributeMask(RID.Any(shader))))
}

/*
Creates a new uniform buffer. It can be accessed with the RID that is returned.
Once finished with your RID, you will want to free the RID using the RenderingDevice's [method free_rid] method.
*/
func (self Instance) UniformBufferCreate(size_bytes int) RID.UniformBuffer { //gd:RenderingDevice.uniform_buffer_create
	return RID.UniformBuffer(Advanced(self).UniformBufferCreate(int64(size_bytes), Packed.Bytes(Packed.New([1][]byte{}[0]...)), 0))
}

/*
Creates a new uniform buffer. It can be accessed with the RID that is returned.
Once finished with your RID, you will want to free the RID using the RenderingDevice's [method free_rid] method.
*/
func (self Expanded) UniformBufferCreate(size_bytes int, data []byte, creation_bits Rendering.BufferCreationBits) RID.UniformBuffer { //gd:RenderingDevice.uniform_buffer_create
	return RID.UniformBuffer(Advanced(self).UniformBufferCreate(int64(size_bytes), Packed.Bytes(Packed.New(data...)), creation_bits))
}

/*
Creates a [url=https://vkguide.dev/docs/chapter-4/storage_buffers/]storage buffer[/url] with the specified [param data] and [param usage]. It can be accessed with the RID that is returned.
Once finished with your RID, you will want to free the RID using the RenderingDevice's [method free_rid] method.
*/
func (self Instance) StorageBufferCreate(size_bytes int) RID.StorageBuffer { //gd:RenderingDevice.storage_buffer_create
	return RID.StorageBuffer(Advanced(self).StorageBufferCreate(int64(size_bytes), Packed.Bytes(Packed.New([1][]byte{}[0]...)), 0, 0))
}

/*
Creates a [url=https://vkguide.dev/docs/chapter-4/storage_buffers/]storage buffer[/url] with the specified [param data] and [param usage]. It can be accessed with the RID that is returned.
Once finished with your RID, you will want to free the RID using the RenderingDevice's [method free_rid] method.
*/
func (self Expanded) StorageBufferCreate(size_bytes int, data []byte, usage Rendering.StorageBufferUsage, creation_bits Rendering.BufferCreationBits) RID.StorageBuffer { //gd:RenderingDevice.storage_buffer_create
	return RID.StorageBuffer(Advanced(self).StorageBufferCreate(int64(size_bytes), Packed.Bytes(Packed.New(data...)), usage, creation_bits))
}

/*
Creates a new texture buffer. It can be accessed with the RID that is returned.
Once finished with your RID, you will want to free the RID using the RenderingDevice's [method free_rid] method.
*/
func (self Instance) TextureBufferCreate(size_bytes int, format Rendering.DataFormat) RID.TextureBuffer { //gd:RenderingDevice.texture_buffer_create
	return RID.TextureBuffer(Advanced(self).TextureBufferCreate(int64(size_bytes), format, Packed.Bytes(Packed.New([1][]byte{}[0]...))))
}

/*
Creates a new texture buffer. It can be accessed with the RID that is returned.
Once finished with your RID, you will want to free the RID using the RenderingDevice's [method free_rid] method.
*/
func (self Expanded) TextureBufferCreate(size_bytes int, format Rendering.DataFormat, data []byte) RID.TextureBuffer { //gd:RenderingDevice.texture_buffer_create
	return RID.TextureBuffer(Advanced(self).TextureBufferCreate(int64(size_bytes), format, Packed.Bytes(Packed.New(data...))))
}

/*
Creates a new uniform set. It can be accessed with the RID that is returned.
Once finished with your RID, you will want to free the RID using the RenderingDevice's [method free_rid] method.
*/
func (self Instance) UniformSetCreate(uniforms []RDUniform.Instance, shader RID.Shader, shader_set int) RID.UniformSet { //gd:RenderingDevice.uniform_set_create
	return RID.UniformSet(Advanced(self).UniformSetCreate(gd.ArrayFromSlice[Array.Contains[[1]gdclass.RDUniform]](uniforms), RID.Any(shader), int64(shader_set)))
}

/*
Checks if the [param uniform_set] is valid, i.e. is owned.
*/
func (self Instance) UniformSetIsValid(uniform_set RID.UniformSet) bool { //gd:RenderingDevice.uniform_set_is_valid
	return bool(Advanced(self).UniformSetIsValid(RID.Any(uniform_set)))
}

/*
Copies [param size] bytes from the [param src_buffer] at [param src_offset] into [param dst_buffer] at [param dst_offset].
Prints an error if:
- [param size] exceeds the size of either [param src_buffer] or [param dst_buffer] at their corresponding offsets
- a draw list is currently active (created by [method draw_list_begin])
- a compute list is currently active (created by [method compute_list_begin])
*/
func (self Instance) BufferCopy(src_buffer RID.Buffer, dst_buffer RID.Buffer, src_offset int, dst_offset int, size int) error { //gd:RenderingDevice.buffer_copy
	return error(gd.ToError(Advanced(self).BufferCopy(RID.Any(src_buffer), RID.Any(dst_buffer), int64(src_offset), int64(dst_offset), int64(size))))
}

/*
Updates a region of [param size_bytes] bytes, starting at [param offset], in the buffer, with the specified [param data].
Prints an error if:
- the region specified by [param offset] + [param size_bytes] exceeds the buffer
- a draw list is currently active (created by [method draw_list_begin])
- a compute list is currently active (created by [method compute_list_begin])
*/
func (self Instance) BufferUpdate(buffer RID.Buffer, offset int, size_bytes int, data []byte) error { //gd:RenderingDevice.buffer_update
	return error(gd.ToError(Advanced(self).BufferUpdate(RID.Any(buffer), int64(offset), int64(size_bytes), Packed.Bytes(Packed.New(data...)))))
}

/*
Clears the contents of the [param buffer], clearing [param size_bytes] bytes, starting at [param offset].
Prints an error if:
- the size isn't a multiple of four
- the region specified by [param offset] + [param size_bytes] exceeds the buffer
- a draw list is currently active (created by [method draw_list_begin])
- a compute list is currently active (created by [method compute_list_begin])
*/
func (self Instance) BufferClear(buffer RID.Buffer, offset int, size_bytes int) error { //gd:RenderingDevice.buffer_clear
	return error(gd.ToError(Advanced(self).BufferClear(RID.Any(buffer), int64(offset), int64(size_bytes))))
}

/*
Returns a copy of the data of the specified [param buffer], optionally [param offset_bytes] and [param size_bytes] can be set to copy only a portion of the buffer.
[b]Note:[/b] This method will block the GPU from working until the data is retrieved. Refer to [method buffer_get_data_async] for an alternative that returns the data in more performant way.
*/
func (self Instance) BufferGetData(buffer RID.Buffer) []byte { //gd:RenderingDevice.buffer_get_data
	return []byte(Advanced(self).BufferGetData(RID.Any(buffer), int64(0), int64(0)).Bytes())
}

/*
Returns a copy of the data of the specified [param buffer], optionally [param offset_bytes] and [param size_bytes] can be set to copy only a portion of the buffer.
[b]Note:[/b] This method will block the GPU from working until the data is retrieved. Refer to [method buffer_get_data_async] for an alternative that returns the data in more performant way.
*/
func (self Expanded) BufferGetData(buffer RID.Buffer, offset_bytes int, size_bytes int) []byte { //gd:RenderingDevice.buffer_get_data
	return []byte(Advanced(self).BufferGetData(RID.Any(buffer), int64(offset_bytes), int64(size_bytes)).Bytes())
}

/*
Asynchronous version of [method buffer_get_data]. RenderingDevice will call [param callback] in a certain amount of frames with the data the buffer had at the time of the request.
[b]Note:[/b] At the moment, the delay corresponds to the amount of frames specified by [member ProjectSettings.rendering/rendering_device/vsync/frame_queue_size].
[b]Note:[/b] Downloading large buffers can have a prohibitive cost for real-time even when using the asynchronous method due to hardware bandwidth limitations. When dealing with large resources, you can adjust settings such as [member ProjectSettings.rendering/rendering_device/staging_buffer/block_size_kb] to improve the transfer speed at the cost of extra memory.
[codeblock]
func _buffer_get_data_callback(array):

	value = array.decode_u32(0)

...

rd.buffer_get_data_async(buffer, _buffer_get_data_callback)
[/codeblock]
*/
func (self Instance) BufferGetDataAsync(buffer RID.Buffer, callback func(data []byte)) error { //gd:RenderingDevice.buffer_get_data_async
	return error(gd.ToError(Advanced(self).BufferGetDataAsync(RID.Any(buffer), Callable.New(callback), int64(0), int64(0))))
}

/*
Asynchronous version of [method buffer_get_data]. RenderingDevice will call [param callback] in a certain amount of frames with the data the buffer had at the time of the request.
[b]Note:[/b] At the moment, the delay corresponds to the amount of frames specified by [member ProjectSettings.rendering/rendering_device/vsync/frame_queue_size].
[b]Note:[/b] Downloading large buffers can have a prohibitive cost for real-time even when using the asynchronous method due to hardware bandwidth limitations. When dealing with large resources, you can adjust settings such as [member ProjectSettings.rendering/rendering_device/staging_buffer/block_size_kb] to improve the transfer speed at the cost of extra memory.
[codeblock]
func _buffer_get_data_callback(array):

	value = array.decode_u32(0)

...

rd.buffer_get_data_async(buffer, _buffer_get_data_callback)
[/codeblock]
*/
func (self Expanded) BufferGetDataAsync(buffer RID.Buffer, callback func(data []byte), offset_bytes int, size_bytes int) error { //gd:RenderingDevice.buffer_get_data_async
	return error(gd.ToError(Advanced(self).BufferGetDataAsync(RID.Any(buffer), Callable.New(callback), int64(offset_bytes), int64(size_bytes))))
}

/*
Returns the address of the given [param buffer] which can be passed to shaders in any way to access underlying data. Buffer must have been created with this feature enabled.
[b]Note:[/b] You must check that the GPU supports this functionality by calling [method has_feature] with [constant SUPPORTS_BUFFER_DEVICE_ADDRESS] as a parameter.
*/
func (self Instance) BufferGetDeviceAddress(buffer RID.Buffer) int { //gd:RenderingDevice.buffer_get_device_address
	return int(int(Advanced(self).BufferGetDeviceAddress(RID.Any(buffer))))
}

/*
Creates a new render pipeline. It can be accessed with the RID that is returned.
Once finished with your RID, you will want to free the RID using the RenderingDevice's [method free_rid] method.
*/
func (self Instance) RenderPipelineCreate(shader RID.Shader, framebuffer_format int, vertex_format int, primitive Rendering.RenderPrimitive, rasterization_state RDPipelineRasterizationState.Instance, multisample_state RDPipelineMultisampleState.Instance, stencil_state RDPipelineDepthStencilState.Instance, color_blend_state RDPipelineColorBlendState.Instance) RID.RenderPipeline { //gd:RenderingDevice.render_pipeline_create
	return RID.RenderPipeline(Advanced(self).RenderPipelineCreate(RID.Any(shader), int64(framebuffer_format), int64(vertex_format), primitive, rasterization_state, multisample_state, stencil_state, color_blend_state, 0, int64(0), gd.ArrayFromSlice[Array.Contains[[1]gdclass.RDPipelineSpecializationConstant]]([1][]RDPipelineSpecializationConstant.Instance{}[0])))
}

/*
Creates a new render pipeline. It can be accessed with the RID that is returned.
Once finished with your RID, you will want to free the RID using the RenderingDevice's [method free_rid] method.
*/
func (self Expanded) RenderPipelineCreate(shader RID.Shader, framebuffer_format int, vertex_format int, primitive Rendering.RenderPrimitive, rasterization_state RDPipelineRasterizationState.Instance, multisample_state RDPipelineMultisampleState.Instance, stencil_state RDPipelineDepthStencilState.Instance, color_blend_state RDPipelineColorBlendState.Instance, dynamic_state_flags Rendering.PipelineDynamicStateFlags, for_render_pass int, specialization_constants []RDPipelineSpecializationConstant.Instance) RID.RenderPipeline { //gd:RenderingDevice.render_pipeline_create
	return RID.RenderPipeline(Advanced(self).RenderPipelineCreate(RID.Any(shader), int64(framebuffer_format), int64(vertex_format), primitive, rasterization_state, multisample_state, stencil_state, color_blend_state, dynamic_state_flags, int64(for_render_pass), gd.ArrayFromSlice[Array.Contains[[1]gdclass.RDPipelineSpecializationConstant]](specialization_constants)))
}

/*
Returns [code]true[/code] if the render pipeline specified by the [param render_pipeline] RID is valid, [code]false[/code] otherwise.
*/
func (self Instance) RenderPipelineIsValid(render_pipeline RID.RenderPipeline) bool { //gd:RenderingDevice.render_pipeline_is_valid
	return bool(Advanced(self).RenderPipelineIsValid(RID.Any(render_pipeline)))
}

/*
Creates a new compute pipeline. It can be accessed with the RID that is returned.
Once finished with your RID, you will want to free the RID using the RenderingDevice's [method free_rid] method.
*/
func (self Instance) ComputePipelineCreate(shader RID.Shader) RID.ComputePipeline { //gd:RenderingDevice.compute_pipeline_create
	return RID.ComputePipeline(Advanced(self).ComputePipelineCreate(RID.Any(shader), gd.ArrayFromSlice[Array.Contains[[1]gdclass.RDPipelineSpecializationConstant]]([1][]RDPipelineSpecializationConstant.Instance{}[0])))
}

/*
Creates a new compute pipeline. It can be accessed with the RID that is returned.
Once finished with your RID, you will want to free the RID using the RenderingDevice's [method free_rid] method.
*/
func (self Expanded) ComputePipelineCreate(shader RID.Shader, specialization_constants []RDPipelineSpecializationConstant.Instance) RID.ComputePipeline { //gd:RenderingDevice.compute_pipeline_create
	return RID.ComputePipeline(Advanced(self).ComputePipelineCreate(RID.Any(shader), gd.ArrayFromSlice[Array.Contains[[1]gdclass.RDPipelineSpecializationConstant]](specialization_constants)))
}

/*
Returns [code]true[/code] if the compute pipeline specified by the [param compute_pipeline] RID is valid, [code]false[/code] otherwise.
*/
func (self Instance) ComputePipelineIsValid(compute_pipeline RID.ComputePipeline) bool { //gd:RenderingDevice.compute_pipeline_is_valid
	return bool(Advanced(self).ComputePipelineIsValid(RID.Any(compute_pipeline)))
}

/*
Returns the window width matching the graphics API context for the given window ID (in pixels). Despite the parameter being named [param screen], this returns the [i]window[/i] size. See also [method screen_get_height].
[b]Note:[/b] Only the main [RenderingDevice] returned by [method RenderingServer.get_rendering_device] has a width. If called on a local [RenderingDevice], this method prints an error and returns [constant INVALID_ID].
*/
func (self Instance) ScreenGetWidth() int { //gd:RenderingDevice.screen_get_width
	return int(int(Advanced(self).ScreenGetWidth(int64(0))))
}

/*
Returns the window width matching the graphics API context for the given window ID (in pixels). Despite the parameter being named [param screen], this returns the [i]window[/i] size. See also [method screen_get_height].
[b]Note:[/b] Only the main [RenderingDevice] returned by [method RenderingServer.get_rendering_device] has a width. If called on a local [RenderingDevice], this method prints an error and returns [constant INVALID_ID].
*/
func (self Expanded) ScreenGetWidth(screen int) int { //gd:RenderingDevice.screen_get_width
	return int(int(Advanced(self).ScreenGetWidth(int64(screen))))
}

/*
Returns the window height matching the graphics API context for the given window ID (in pixels). Despite the parameter being named [param screen], this returns the [i]window[/i] size. See also [method screen_get_width].
[b]Note:[/b] Only the main [RenderingDevice] returned by [method RenderingServer.get_rendering_device] has a height. If called on a local [RenderingDevice], this method prints an error and returns [constant INVALID_ID].
*/
func (self Instance) ScreenGetHeight() int { //gd:RenderingDevice.screen_get_height
	return int(int(Advanced(self).ScreenGetHeight(int64(0))))
}

/*
Returns the window height matching the graphics API context for the given window ID (in pixels). Despite the parameter being named [param screen], this returns the [i]window[/i] size. See also [method screen_get_width].
[b]Note:[/b] Only the main [RenderingDevice] returned by [method RenderingServer.get_rendering_device] has a height. If called on a local [RenderingDevice], this method prints an error and returns [constant INVALID_ID].
*/
func (self Expanded) ScreenGetHeight(screen int) int { //gd:RenderingDevice.screen_get_height
	return int(int(Advanced(self).ScreenGetHeight(int64(screen))))
}

/*
Returns the framebuffer format of the given screen.
[b]Note:[/b] Only the main [RenderingDevice] returned by [method RenderingServer.get_rendering_device] has a format. If called on a local [RenderingDevice], this method prints an error and returns [constant INVALID_ID].
*/
func (self Instance) ScreenGetFramebufferFormat() int { //gd:RenderingDevice.screen_get_framebuffer_format
	return int(int(Advanced(self).ScreenGetFramebufferFormat(int64(0))))
}

/*
Returns the framebuffer format of the given screen.
[b]Note:[/b] Only the main [RenderingDevice] returned by [method RenderingServer.get_rendering_device] has a format. If called on a local [RenderingDevice], this method prints an error and returns [constant INVALID_ID].
*/
func (self Expanded) ScreenGetFramebufferFormat(screen int) int { //gd:RenderingDevice.screen_get_framebuffer_format
	return int(int(Advanced(self).ScreenGetFramebufferFormat(int64(screen))))
}

/*
High-level variant of [method draw_list_begin], with the parameters automatically being adjusted for drawing onto the window specified by the [param screen] ID.
[b]Note:[/b] Cannot be used with local RenderingDevices, as these don't have a screen. If called on a local RenderingDevice, [method draw_list_begin_for_screen] returns [constant INVALID_ID].
*/
func (self Instance) DrawListBeginForScreen() int { //gd:RenderingDevice.draw_list_begin_for_screen
	return int(int(Advanced(self).DrawListBeginForScreen(int64(0), Color.RGBA(gd.Color{0, 0, 0, 1}))))
}

/*
High-level variant of [method draw_list_begin], with the parameters automatically being adjusted for drawing onto the window specified by the [param screen] ID.
[b]Note:[/b] Cannot be used with local RenderingDevices, as these don't have a screen. If called on a local RenderingDevice, [method draw_list_begin_for_screen] returns [constant INVALID_ID].
*/
func (self Expanded) DrawListBeginForScreen(screen int, clear_color Color.RGBA) int { //gd:RenderingDevice.draw_list_begin_for_screen
	return int(int(Advanced(self).DrawListBeginForScreen(int64(screen), Color.RGBA(clear_color))))
}

/*
Starts a list of raster drawing commands created with the [code]draw_*[/code] methods. The returned value should be passed to other [code]draw_list_*[/code] functions.
Multiple draw lists cannot be created at the same time; you must finish the previous draw list first using [method draw_list_end].
A simple drawing operation might look like this (code is not a complete example):
[codeblock]
var rd = RenderingDevice.new()
var clear_colors = PackedColorArray([Color(0, 0, 0, 0), Color(0, 0, 0, 0), Color(0, 0, 0, 0)])
var draw_list = rd.draw_list_begin(framebuffers[i], RenderingDevice.CLEAR_COLOR_ALL, clear_colors, true, 1.0f, true, 0, Rect2(), RenderingDevice.OPAQUE_PASS)

# Draw opaque.
rd.draw_list_bind_render_pipeline(draw_list, raster_pipeline)
rd.draw_list_bind_uniform_set(draw_list, raster_base_uniform, 0)
rd.draw_list_set_push_constant(draw_list, raster_push_constant, raster_push_constant.size())
rd.draw_list_draw(draw_list, false, 1, slice_triangle_count[i] * 3)
# Draw wire.
rd.draw_list_bind_render_pipeline(draw_list, raster_pipeline_wire)
rd.draw_list_bind_uniform_set(draw_list, raster_base_uniform, 0)
rd.draw_list_set_push_constant(draw_list, raster_push_constant, raster_push_constant.size())
rd.draw_list_draw(draw_list, false, 1, slice_triangle_count[i] * 3)

rd.draw_list_end()
[/codeblock]
The [param draw_flags] indicates if the texture attachments of the framebuffer should be cleared or ignored. Only one of the two flags can be used for each individual attachment. Ignoring an attachment means that any contents that existed before the draw list will be completely discarded, reducing the memory bandwidth used by the render pass but producing garbage results if the pixels aren't replaced. The default behavior allows the engine to figure out the right operation to use if the texture is discardable, which can result in increased performance. See [RDTextureFormat] or [method texture_set_discardable].
The [param breadcrumb] parameter can be an arbitrary 32-bit integer that is useful to diagnose GPU crashes. If Godot is built in dev or debug mode; when the GPU crashes Godot will dump all shaders that were being executed at the time of the crash and the breadcrumb is useful to diagnose what passes did those shaders belong to.
It does not affect rendering behavior and can be set to 0. It is recommended to use [enum BreadcrumbMarker] enumerations for consistency but it's not required. It is also possible to use bitwise operations to add extra data. e.g.
[codeblock]
rd.draw_list_begin(fb[i], RenderingDevice.CLEAR_COLOR_ALL, clear_colors, true, 1.0f, true, 0, Rect2(), RenderingDevice.OPAQUE_PASS | 5)
[/codeblock]
*/
func (self Instance) DrawListBegin(framebuffer RID.Framebuffer) int { //gd:RenderingDevice.draw_list_begin
	return int(int(Advanced(self).DrawListBegin(RID.Any(framebuffer), 0, Packed.New([1][]Color.RGBA{}[0]...), float64(1.0), int64(0), Rect2.PositionSize(gd.NewRect2(0, 0, 0, 0)), int64(0))))
}

/*
Starts a list of raster drawing commands created with the [code]draw_*[/code] methods. The returned value should be passed to other [code]draw_list_*[/code] functions.
Multiple draw lists cannot be created at the same time; you must finish the previous draw list first using [method draw_list_end].
A simple drawing operation might look like this (code is not a complete example):
[codeblock]
var rd = RenderingDevice.new()
var clear_colors = PackedColorArray([Color(0, 0, 0, 0), Color(0, 0, 0, 0), Color(0, 0, 0, 0)])
var draw_list = rd.draw_list_begin(framebuffers[i], RenderingDevice.CLEAR_COLOR_ALL, clear_colors, true, 1.0f, true, 0, Rect2(), RenderingDevice.OPAQUE_PASS)

# Draw opaque.
rd.draw_list_bind_render_pipeline(draw_list, raster_pipeline)
rd.draw_list_bind_uniform_set(draw_list, raster_base_uniform, 0)
rd.draw_list_set_push_constant(draw_list, raster_push_constant, raster_push_constant.size())
rd.draw_list_draw(draw_list, false, 1, slice_triangle_count[i] * 3)
# Draw wire.
rd.draw_list_bind_render_pipeline(draw_list, raster_pipeline_wire)
rd.draw_list_bind_uniform_set(draw_list, raster_base_uniform, 0)
rd.draw_list_set_push_constant(draw_list, raster_push_constant, raster_push_constant.size())
rd.draw_list_draw(draw_list, false, 1, slice_triangle_count[i] * 3)

rd.draw_list_end()
[/codeblock]
The [param draw_flags] indicates if the texture attachments of the framebuffer should be cleared or ignored. Only one of the two flags can be used for each individual attachment. Ignoring an attachment means that any contents that existed before the draw list will be completely discarded, reducing the memory bandwidth used by the render pass but producing garbage results if the pixels aren't replaced. The default behavior allows the engine to figure out the right operation to use if the texture is discardable, which can result in increased performance. See [RDTextureFormat] or [method texture_set_discardable].
The [param breadcrumb] parameter can be an arbitrary 32-bit integer that is useful to diagnose GPU crashes. If Godot is built in dev or debug mode; when the GPU crashes Godot will dump all shaders that were being executed at the time of the crash and the breadcrumb is useful to diagnose what passes did those shaders belong to.
It does not affect rendering behavior and can be set to 0. It is recommended to use [enum BreadcrumbMarker] enumerations for consistency but it's not required. It is also possible to use bitwise operations to add extra data. e.g.
[codeblock]
rd.draw_list_begin(fb[i], RenderingDevice.CLEAR_COLOR_ALL, clear_colors, true, 1.0f, true, 0, Rect2(), RenderingDevice.OPAQUE_PASS | 5)
[/codeblock]
*/
func (self Expanded) DrawListBegin(framebuffer RID.Framebuffer, draw_flags Rendering.DrawFlags, clear_color_values []Color.RGBA, clear_depth_value Float.X, clear_stencil_value int, region Rect2.PositionSize, breadcrumb int) int { //gd:RenderingDevice.draw_list_begin
	return int(int(Advanced(self).DrawListBegin(RID.Any(framebuffer), draw_flags, Packed.New(clear_color_values...), float64(clear_depth_value), int64(clear_stencil_value), Rect2.PositionSize(region), int64(breadcrumb))))
}

/*
This method does nothing and always returns an empty [PackedInt64Array].
*/
func (self Instance) DrawListBeginSplit(framebuffer RID.Framebuffer, splits int, initial_color_action Rendering.InitialAction, final_color_action Rendering.FinalAction, initial_depth_action Rendering.InitialAction, final_depth_action Rendering.FinalAction) []int64 { //gd:RenderingDevice.draw_list_begin_split
	return []int64(slices.Collect(Advanced(self).DrawListBeginSplit(RID.Any(framebuffer), int64(splits), initial_color_action, final_color_action, initial_depth_action, final_depth_action, Packed.New([1][]Color.RGBA{}[0]...), float64(1.0), int64(0), Rect2.PositionSize(gd.NewRect2(0, 0, 0, 0)), gd.ArrayFromSlice[Array.Contains[RID.Any]]([1][]RID.Any{}[0])).Values()))
}

/*
This method does nothing and always returns an empty [PackedInt64Array].
*/
func (self Expanded) DrawListBeginSplit(framebuffer RID.Framebuffer, splits int, initial_color_action Rendering.InitialAction, final_color_action Rendering.FinalAction, initial_depth_action Rendering.InitialAction, final_depth_action Rendering.FinalAction, clear_color_values []Color.RGBA, clear_depth Float.X, clear_stencil int, region Rect2.PositionSize, storage_textures [][]RID.Texture) []int64 { //gd:RenderingDevice.draw_list_begin_split
	return []int64(slices.Collect(Advanced(self).DrawListBeginSplit(RID.Any(framebuffer), int64(splits), initial_color_action, final_color_action, initial_depth_action, final_depth_action, Packed.New(clear_color_values...), float64(clear_depth), int64(clear_stencil), Rect2.PositionSize(region), gd.ArrayFromSlice[Array.Contains[RID.Any]](storage_textures)).Values()))
}

/*
Sets blend constants for the specified [param draw_list] to [param color]. Blend constants are used only if the graphics pipeline is created with [constant DYNAMIC_STATE_BLEND_CONSTANTS] flag set.
*/
func (self Instance) DrawListSetBlendConstants(draw_list int, color Color.RGBA) { //gd:RenderingDevice.draw_list_set_blend_constants
	Advanced(self).DrawListSetBlendConstants(int64(draw_list), Color.RGBA(color))
}

/*
Binds [param render_pipeline] to the specified [param draw_list].
*/
func (self Instance) DrawListBindRenderPipeline(draw_list int, render_pipeline RID.RenderPipeline) { //gd:RenderingDevice.draw_list_bind_render_pipeline
	Advanced(self).DrawListBindRenderPipeline(int64(draw_list), RID.Any(render_pipeline))
}

/*
Binds [param uniform_set] to the specified [param draw_list]. A [param set_index] must also be specified, which is an identifier starting from [code]0[/code] that must match the one expected by the draw list.
*/
func (self Instance) DrawListBindUniformSet(draw_list int, uniform_set RID.UniformSet, set_index int) { //gd:RenderingDevice.draw_list_bind_uniform_set
	Advanced(self).DrawListBindUniformSet(int64(draw_list), RID.Any(uniform_set), int64(set_index))
}

/*
Binds [param vertex_array] to the specified [param draw_list].
*/
func (self Instance) DrawListBindVertexArray(draw_list int, vertex_array RID.VertexArray) { //gd:RenderingDevice.draw_list_bind_vertex_array
	Advanced(self).DrawListBindVertexArray(int64(draw_list), RID.Any(vertex_array))
}

/*
Binds [param index_array] to the specified [param draw_list].
*/
func (self Instance) DrawListBindIndexArray(draw_list int, index_array RID.IndexArray) { //gd:RenderingDevice.draw_list_bind_index_array
	Advanced(self).DrawListBindIndexArray(int64(draw_list), RID.Any(index_array))
}

/*
Sets the push constant data to [param buffer] for the specified [param draw_list]. The shader determines how this binary data is used. The buffer's size in bytes must also be specified in [param size_bytes] (this can be obtained by calling the [method PackedByteArray.size] method on the passed [param buffer]).
*/
func (self Instance) DrawListSetPushConstant(draw_list int, buffer []byte, size_bytes int) { //gd:RenderingDevice.draw_list_set_push_constant
	Advanced(self).DrawListSetPushConstant(int64(draw_list), Packed.Bytes(Packed.New(buffer...)), int64(size_bytes))
}

/*
Submits [param draw_list] for rendering on the GPU. This is the raster equivalent to [method compute_list_dispatch].
*/
func (self Instance) DrawListDraw(draw_list int, use_indices bool, instances int) { //gd:RenderingDevice.draw_list_draw
	Advanced(self).DrawListDraw(int64(draw_list), use_indices, int64(instances), int64(0))
}

/*
Submits [param draw_list] for rendering on the GPU. This is the raster equivalent to [method compute_list_dispatch].
*/
func (self Expanded) DrawListDraw(draw_list int, use_indices bool, instances int, procedural_vertex_count int) { //gd:RenderingDevice.draw_list_draw
	Advanced(self).DrawListDraw(int64(draw_list), use_indices, int64(instances), int64(procedural_vertex_count))
}

/*
Submits [param draw_list] for rendering on the GPU with the given parameters stored in the [param buffer] at [param offset]. Parameters being integers: vertex count, instance count, first vertex, first instance. And when using indices: index count, instance count, first index, vertex offset, first instance. Buffer must have been created with [constant STORAGE_BUFFER_USAGE_DISPATCH_INDIRECT] flag.
*/
func (self Instance) DrawListDrawIndirect(draw_list int, use_indices bool, buffer RID.Buffer) { //gd:RenderingDevice.draw_list_draw_indirect
	Advanced(self).DrawListDrawIndirect(int64(draw_list), use_indices, RID.Any(buffer), int64(0), int64(1), int64(0))
}

/*
Submits [param draw_list] for rendering on the GPU with the given parameters stored in the [param buffer] at [param offset]. Parameters being integers: vertex count, instance count, first vertex, first instance. And when using indices: index count, instance count, first index, vertex offset, first instance. Buffer must have been created with [constant STORAGE_BUFFER_USAGE_DISPATCH_INDIRECT] flag.
*/
func (self Expanded) DrawListDrawIndirect(draw_list int, use_indices bool, buffer RID.Buffer, offset int, draw_count int, stride int) { //gd:RenderingDevice.draw_list_draw_indirect
	Advanced(self).DrawListDrawIndirect(int64(draw_list), use_indices, RID.Any(buffer), int64(offset), int64(draw_count), int64(stride))
}

/*
Creates a scissor rectangle and enables it for the specified [param draw_list]. Scissor rectangles are used for clipping by discarding fragments that fall outside a specified rectangular portion of the screen. See also [method draw_list_disable_scissor].
[b]Note:[/b] The specified [param rect] is automatically intersected with the screen's dimensions, which means it cannot exceed the screen's dimensions.
*/
func (self Instance) DrawListEnableScissor(draw_list int) { //gd:RenderingDevice.draw_list_enable_scissor
	Advanced(self).DrawListEnableScissor(int64(draw_list), Rect2.PositionSize(gd.NewRect2(0, 0, 0, 0)))
}

/*
Creates a scissor rectangle and enables it for the specified [param draw_list]. Scissor rectangles are used for clipping by discarding fragments that fall outside a specified rectangular portion of the screen. See also [method draw_list_disable_scissor].
[b]Note:[/b] The specified [param rect] is automatically intersected with the screen's dimensions, which means it cannot exceed the screen's dimensions.
*/
func (self Expanded) DrawListEnableScissor(draw_list int, rect Rect2.PositionSize) { //gd:RenderingDevice.draw_list_enable_scissor
	Advanced(self).DrawListEnableScissor(int64(draw_list), Rect2.PositionSize(rect))
}

/*
Removes and disables the scissor rectangle for the specified [param draw_list]. See also [method draw_list_enable_scissor].
*/
func (self Instance) DrawListDisableScissor(draw_list int) { //gd:RenderingDevice.draw_list_disable_scissor
	Advanced(self).DrawListDisableScissor(int64(draw_list))
}

/*
Switches to the next draw pass.
*/
func (self Instance) DrawListSwitchToNextPass() int { //gd:RenderingDevice.draw_list_switch_to_next_pass
	return int(int(Advanced(self).DrawListSwitchToNextPass()))
}

/*
This method does nothing and always returns an empty [PackedInt64Array].
*/
func (self Instance) DrawListSwitchToNextPassSplit(splits int) []int64 { //gd:RenderingDevice.draw_list_switch_to_next_pass_split
	return []int64(slices.Collect(Advanced(self).DrawListSwitchToNextPassSplit(int64(splits)).Values()))
}

/*
Finishes a list of raster drawing commands created with the [code]draw_*[/code] methods.
*/
func (self Instance) DrawListEnd() { //gd:RenderingDevice.draw_list_end
	Advanced(self).DrawListEnd()
}

/*
Starts a list of compute commands created with the [code]compute_*[/code] methods. The returned value should be passed to other [code]compute_list_*[/code] functions.
Multiple compute lists cannot be created at the same time; you must finish the previous compute list first using [method compute_list_end].
A simple compute operation might look like this (code is not a complete example):
[codeblock]
var rd = RenderingDevice.new()
var compute_list = rd.compute_list_begin()

rd.compute_list_bind_compute_pipeline(compute_list, compute_shader_dilate_pipeline)
rd.compute_list_bind_uniform_set(compute_list, compute_base_uniform_set, 0)
rd.compute_list_bind_uniform_set(compute_list, dilate_uniform_set, 1)

for i in atlas_slices:

	rd.compute_list_set_push_constant(compute_list, push_constant, push_constant.size())
	rd.compute_list_dispatch(compute_list, group_size.x, group_size.y, group_size.z)
	# No barrier, let them run all together.

rd.compute_list_end()
[/codeblock]
*/
func (self Instance) ComputeListBegin() int { //gd:RenderingDevice.compute_list_begin
	return int(int(Advanced(self).ComputeListBegin()))
}

/*
Tells the GPU what compute pipeline to use when processing the compute list. If the shader has changed since the last time this function was called, Godot will unbind all descriptor sets and will re-bind them inside [method compute_list_dispatch].
*/
func (self Instance) ComputeListBindComputePipeline(compute_list int, compute_pipeline RID.ComputePipeline) { //gd:RenderingDevice.compute_list_bind_compute_pipeline
	Advanced(self).ComputeListBindComputePipeline(int64(compute_list), RID.Any(compute_pipeline))
}

/*
Sets the push constant data to [param buffer] for the specified [param compute_list]. The shader determines how this binary data is used. The buffer's size in bytes must also be specified in [param size_bytes] (this can be obtained by calling the [method PackedByteArray.size] method on the passed [param buffer]).
*/
func (self Instance) ComputeListSetPushConstant(compute_list int, buffer []byte, size_bytes int) { //gd:RenderingDevice.compute_list_set_push_constant
	Advanced(self).ComputeListSetPushConstant(int64(compute_list), Packed.Bytes(Packed.New(buffer...)), int64(size_bytes))
}

/*
Binds the [param uniform_set] to this [param compute_list]. Godot ensures that all textures in the uniform set have the correct Vulkan access masks. If Godot had to change access masks of textures, it will raise a Vulkan image memory barrier.
*/
func (self Instance) ComputeListBindUniformSet(compute_list int, uniform_set RID.UniformSet, set_index int) { //gd:RenderingDevice.compute_list_bind_uniform_set
	Advanced(self).ComputeListBindUniformSet(int64(compute_list), RID.Any(uniform_set), int64(set_index))
}

/*
Submits the compute list for processing on the GPU. This is the compute equivalent to [method draw_list_draw].
*/
func (self Instance) ComputeListDispatch(compute_list int, x_groups int, y_groups int, z_groups int) { //gd:RenderingDevice.compute_list_dispatch
	Advanced(self).ComputeListDispatch(int64(compute_list), int64(x_groups), int64(y_groups), int64(z_groups))
}

/*
Submits the compute list for processing on the GPU with the given group counts stored in the [param buffer] at [param offset]. Buffer must have been created with [constant STORAGE_BUFFER_USAGE_DISPATCH_INDIRECT] flag.
*/
func (self Instance) ComputeListDispatchIndirect(compute_list int, buffer RID.Buffer, offset int) { //gd:RenderingDevice.compute_list_dispatch_indirect
	Advanced(self).ComputeListDispatchIndirect(int64(compute_list), RID.Any(buffer), int64(offset))
}

/*
Raises a Vulkan compute barrier in the specified [param compute_list].
*/
func (self Instance) ComputeListAddBarrier(compute_list int) { //gd:RenderingDevice.compute_list_add_barrier
	Advanced(self).ComputeListAddBarrier(int64(compute_list))
}

/*
Finishes a list of compute commands created with the [code]compute_*[/code] methods.
*/
func (self Instance) ComputeListEnd() { //gd:RenderingDevice.compute_list_end
	Advanced(self).ComputeListEnd()
}

/*
Tries to free an object in the RenderingDevice. To avoid memory leaks, this should be called after using an object as memory management does not occur automatically when using RenderingDevice directly.
*/
func (self Instance) FreeRid(rid RID.Any) { //gd:RenderingDevice.free_rid
	Advanced(self).FreeRid(RID.Any(rid))
}

/*
Creates a timestamp marker with the specified [param name]. This is used for performance reporting with the [method get_captured_timestamp_cpu_time], [method get_captured_timestamp_gpu_time] and [method get_captured_timestamp_name] methods.
*/
func (self Instance) CaptureTimestamp(name string) { //gd:RenderingDevice.capture_timestamp
	Advanced(self).CaptureTimestamp(String.New(name))
}

/*
Returns the total number of timestamps (rendering steps) available for profiling.
*/
func (self Instance) GetCapturedTimestampsCount() int { //gd:RenderingDevice.get_captured_timestamps_count
	return int(int(Advanced(self).GetCapturedTimestampsCount()))
}

/*
Returns the index of the last frame rendered that has rendering timestamps available for querying.
*/
func (self Instance) GetCapturedTimestampsFrame() int { //gd:RenderingDevice.get_captured_timestamps_frame
	return int(int(Advanced(self).GetCapturedTimestampsFrame()))
}

/*
Returns the timestamp in GPU time for the rendering step specified by [param index] (in microseconds since the engine started). See also [method get_captured_timestamp_cpu_time] and [method capture_timestamp].
*/
func (self Instance) GetCapturedTimestampGpuTime(index int) int { //gd:RenderingDevice.get_captured_timestamp_gpu_time
	return int(int(Advanced(self).GetCapturedTimestampGpuTime(int64(index))))
}

/*
Returns the timestamp in CPU time for the rendering step specified by [param index] (in microseconds since the engine started). See also [method get_captured_timestamp_gpu_time] and [method capture_timestamp].
*/
func (self Instance) GetCapturedTimestampCpuTime(index int) int { //gd:RenderingDevice.get_captured_timestamp_cpu_time
	return int(int(Advanced(self).GetCapturedTimestampCpuTime(int64(index))))
}

/*
Returns the timestamp's name for the rendering step specified by [param index]. See also [method capture_timestamp].
*/
func (self Instance) GetCapturedTimestampName(index int) string { //gd:RenderingDevice.get_captured_timestamp_name
	return string(Advanced(self).GetCapturedTimestampName(int64(index)).String())
}

/*
Returns [code]true[/code] if the [param feature] is supported by the GPU.
*/
func (self Instance) HasFeature(feature Rendering.Features) bool { //gd:RenderingDevice.has_feature
	return bool(Advanced(self).HasFeature(feature))
}

/*
Returns the value of the specified [param limit]. This limit varies depending on the current graphics hardware (and sometimes the driver version). If the given limit is exceeded, rendering errors will occur.
Limits for various graphics hardware can be found in the [url=https://vulkan.gpuinfo.org/]Vulkan Hardware Database[/url].
*/
func (self Instance) LimitGet(limit Rendering.Limit) int { //gd:RenderingDevice.limit_get
	return int(int(Advanced(self).LimitGet(limit)))
}

/*
Returns the frame count kept by the graphics API. Higher values result in higher input lag, but with more consistent throughput. For the main [RenderingDevice], frames are cycled (usually 3 with triple-buffered V-Sync enabled). However, local [RenderingDevice]s only have 1 frame.
*/
func (self Instance) GetFrameDelay() int { //gd:RenderingDevice.get_frame_delay
	return int(int(Advanced(self).GetFrameDelay()))
}

/*
Pushes the frame setup and draw command buffers then marks the local device as currently processing (which allows calling [method sync]).
[b]Note:[/b] Only available in local RenderingDevices.
*/
func (self Instance) Submit() { //gd:RenderingDevice.submit
	Advanced(self).Submit()
}

/*
Forces a synchronization between the CPU and GPU, which may be required in certain cases. Only call this when needed, as CPU-GPU synchronization has a performance cost.
[b]Note:[/b] Only available in local RenderingDevices.
[b]Note:[/b] [method sync] can only be called after a [method submit].
*/
func (self Instance) Sync() { //gd:RenderingDevice.sync
	Advanced(self).Sync()
}

/*
This method does nothing.
*/
func (self Instance) Barrier() { //gd:RenderingDevice.barrier
	Advanced(self).Barrier(32767, 32767)
}

/*
This method does nothing.
*/
func (self Expanded) Barrier(from Rendering.BarrierMask, to Rendering.BarrierMask) { //gd:RenderingDevice.barrier
	Advanced(self).Barrier(from, to)
}

/*
This method does nothing.
*/
func (self Instance) FullBarrier() { //gd:RenderingDevice.full_barrier
	Advanced(self).FullBarrier()
}

/*
Create a new local [RenderingDevice]. This is most useful for performing compute operations on the GPU independently from the rest of the engine.
*/
func (self Instance) CreateLocalDevice() Instance { //gd:RenderingDevice.create_local_device
	return Instance(Advanced(self).CreateLocalDevice())
}

/*
Sets the resource name for [param id] to [param name]. This is used for debugging with third-party tools such as [url=https://renderdoc.org/]RenderDoc[/url].
The following types of resources can be named: texture, sampler, vertex buffer, index buffer, uniform buffer, texture buffer, storage buffer, uniform set buffer, shader, render pipeline and compute pipeline. Framebuffers cannot be named. Attempting to name an incompatible resource type will print an error.
[b]Note:[/b] Resource names are only set when the engine runs in verbose mode ([method OS.is_stdout_verbose] = [code]true[/code]), or when using an engine build compiled with the [code]dev_mode=yes[/code] SCons option. The graphics driver must also support the [code]VK_EXT_DEBUG_UTILS_EXTENSION_NAME[/code] Vulkan extension for named resources to work.
*/
func (self Instance) SetResourceName(id RID.Any, name string) { //gd:RenderingDevice.set_resource_name
	Advanced(self).SetResourceName(RID.Any(id), String.New(name))
}

/*
Create a command buffer debug label region that can be displayed in third-party tools such as [url=https://renderdoc.org/]RenderDoc[/url]. All regions must be ended with a [method draw_command_end_label] call. When viewed from the linear series of submissions to a single queue, calls to [method draw_command_begin_label] and [method draw_command_end_label] must be matched and balanced.
The [code]VK_EXT_DEBUG_UTILS_EXTENSION_NAME[/code] Vulkan extension must be available and enabled for command buffer debug label region to work. See also [method draw_command_end_label].
*/
func (self Instance) DrawCommandBeginLabel(name string, color Color.RGBA) { //gd:RenderingDevice.draw_command_begin_label
	Advanced(self).DrawCommandBeginLabel(String.New(name), Color.RGBA(color))
}

/*
This method does nothing.
*/
func (self Instance) DrawCommandInsertLabel(name string, color Color.RGBA) { //gd:RenderingDevice.draw_command_insert_label
	Advanced(self).DrawCommandInsertLabel(String.New(name), Color.RGBA(color))
}

/*
Ends the command buffer debug label region started by a [method draw_command_begin_label] call.
*/
func (self Instance) DrawCommandEndLabel() { //gd:RenderingDevice.draw_command_end_label
	Advanced(self).DrawCommandEndLabel()
}

/*
Returns the vendor of the video adapter (e.g. "NVIDIA Corporation"). Equivalent to [method RenderingServer.get_video_adapter_vendor]. See also [method get_device_name].
*/
func (self Instance) GetDeviceVendorName() string { //gd:RenderingDevice.get_device_vendor_name
	return string(Advanced(self).GetDeviceVendorName().String())
}

/*
Returns the name of the video adapter (e.g. "GeForce GTX 1080/PCIe/SSE2"). Equivalent to [method RenderingServer.get_video_adapter_name]. See also [method get_device_vendor_name].
*/
func (self Instance) GetDeviceName() string { //gd:RenderingDevice.get_device_name
	return string(Advanced(self).GetDeviceName().String())
}

/*
Returns the universally unique identifier for the pipeline cache. This is used to cache shader files on disk, which avoids shader recompilations on subsequent engine runs. This UUID varies depending on the graphics card model, but also the driver version. Therefore, updating graphics drivers will invalidate the shader cache.
*/
func (self Instance) GetDevicePipelineCacheUuid() string { //gd:RenderingDevice.get_device_pipeline_cache_uuid
	return string(Advanced(self).GetDevicePipelineCacheUuid().String())
}

/*
Returns the memory usage in bytes corresponding to the given [param type]. When using Vulkan, these statistics are calculated by [url=https://github.com/GPUOpen-LibrariesAndSDKs/VulkanMemoryAllocator]Vulkan Memory Allocator[/url].
*/
func (self Instance) GetMemoryUsage(atype Rendering.MemoryType) int { //gd:RenderingDevice.get_memory_usage
	return int(int(Advanced(self).GetMemoryUsage(atype)))
}

/*
Returns the unique identifier of the driver [param resource] for the specified [param rid]. Some driver resource types ignore the specified [param rid] (see [enum DriverResource] descriptions). [param index] is always ignored but must be specified anyway.
*/
func (self Instance) GetDriverResource(resource Rendering.DriverResource, rid RID.Any, index int) int { //gd:RenderingDevice.get_driver_resource
	return int(int(Advanced(self).GetDriverResource(resource, RID.Any(rid), int64(index))))
}

/*
Returns a string with a performance report from the past frame. Updates every frame.
*/
func (self Instance) GetPerfReport() string { //gd:RenderingDevice.get_perf_report
	return string(Advanced(self).GetPerfReport().String())
}

/*
Returns string report in CSV format using the following methods:
- [method get_tracked_object_name]
- [method get_tracked_object_type_count]
- [method get_driver_total_memory]
- [method get_driver_allocation_count]
- [method get_driver_memory_by_object_type]
- [method get_driver_allocs_by_object_type]
- [method get_device_total_memory]
- [method get_device_allocation_count]
- [method get_device_memory_by_object_type]
- [method get_device_allocs_by_object_type]
This is only used by Vulkan in debug builds. Godot must also be started with the [code]--extra-gpu-memory-tracking[/code] [url=$DOCS_URL/tutorials/editor/command_line_tutorial.html]command line argument[/url].
*/
func (self Instance) GetDriverAndDeviceMemoryReport() string { //gd:RenderingDevice.get_driver_and_device_memory_report
	return string(Advanced(self).GetDriverAndDeviceMemoryReport().String())
}

/*
Returns the name of the type of object for the given [param type_index]. This value must be in range [code][0; get_tracked_object_type_count - 1][/code]. If [method get_tracked_object_type_count] is 0, then type argument is ignored and always returns the same string.
The return value is important because it gives meaning to the types passed to [method get_driver_memory_by_object_type], [method get_driver_allocs_by_object_type], [method get_device_memory_by_object_type], and [method get_device_allocs_by_object_type]. Examples of strings it can return (not exhaustive):
- DEVICE_MEMORY
- PIPELINE_CACHE
- SWAPCHAIN_KHR
- COMMAND_POOL
Thus if e.g. [code]get_tracked_object_name(5)[/code] returns "COMMAND_POOL", then [code]get_device_memory_by_object_type(5)[/code] returns the bytes used by the GPU for command pools.
This is only used by Vulkan in debug builds. Godot must also be started with the [code]--extra-gpu-memory-tracking[/code] [url=$DOCS_URL/tutorials/editor/command_line_tutorial.html]command line argument[/url].
*/
func (self Instance) GetTrackedObjectName(type_index int) string { //gd:RenderingDevice.get_tracked_object_name
	return string(Advanced(self).GetTrackedObjectName(int64(type_index)).String())
}

/*
Returns how many types of trackable objects are.
This is only used by Vulkan in debug builds. Godot must also be started with the [code]--extra-gpu-memory-tracking[/code] [url=$DOCS_URL/tutorials/editor/command_line_tutorial.html]command line argument[/url].
*/
func (self Instance) GetTrackedObjectTypeCount() int { //gd:RenderingDevice.get_tracked_object_type_count
	return int(int(Advanced(self).GetTrackedObjectTypeCount()))
}

/*
Returns how much bytes the GPU driver is using for internal driver structures.
This is only used by Vulkan in debug builds and can return 0 when this information is not tracked or unknown.
*/
func (self Instance) GetDriverTotalMemory() int { //gd:RenderingDevice.get_driver_total_memory
	return int(int(Advanced(self).GetDriverTotalMemory()))
}

/*
Returns how many allocations the GPU driver has performed for internal driver structures.
This is only used by Vulkan in debug builds and can return 0 when this information is not tracked or unknown.
*/
func (self Instance) GetDriverAllocationCount() int { //gd:RenderingDevice.get_driver_allocation_count
	return int(int(Advanced(self).GetDriverAllocationCount()))
}

/*
Same as [method get_driver_total_memory] but filtered for a given object type.
The type argument must be in range [code][0; get_tracked_object_type_count - 1][/code]. If [method get_tracked_object_type_count] is 0, then type argument is ignored and always returns 0.
This is only used by Vulkan in debug builds and can return 0 when this information is not tracked or unknown.
*/
func (self Instance) GetDriverMemoryByObjectType(atype int) int { //gd:RenderingDevice.get_driver_memory_by_object_type
	return int(int(Advanced(self).GetDriverMemoryByObjectType(int64(atype))))
}

/*
Same as [method get_driver_allocation_count] but filtered for a given object type.
The type argument must be in range [code][0; get_tracked_object_type_count - 1][/code]. If [method get_tracked_object_type_count] is 0, then type argument is ignored and always returns 0.
This is only used by Vulkan in debug builds and can return 0 when this information is not tracked or unknown.
*/
func (self Instance) GetDriverAllocsByObjectType(atype int) int { //gd:RenderingDevice.get_driver_allocs_by_object_type
	return int(int(Advanced(self).GetDriverAllocsByObjectType(int64(atype))))
}

/*
Returns how much bytes the GPU is using.
This is only used by Vulkan in debug builds and can return 0 when this information is not tracked or unknown.
*/
func (self Instance) GetDeviceTotalMemory() int { //gd:RenderingDevice.get_device_total_memory
	return int(int(Advanced(self).GetDeviceTotalMemory()))
}

/*
Returns how many allocations the GPU has performed for internal driver structures.
This is only used by Vulkan in debug builds and can return 0 when this information is not tracked or unknown.
*/
func (self Instance) GetDeviceAllocationCount() int { //gd:RenderingDevice.get_device_allocation_count
	return int(int(Advanced(self).GetDeviceAllocationCount()))
}

/*
Same as [method get_device_total_memory] but filtered for a given object type.
The type argument must be in range [code][0; get_tracked_object_type_count - 1][/code]. If [method get_tracked_object_type_count] is 0, then type argument is ignored and always returns 0.
This is only used by Vulkan in debug builds and can return 0 when this information is not tracked or unknown.
*/
func (self Instance) GetDeviceMemoryByObjectType(atype int) int { //gd:RenderingDevice.get_device_memory_by_object_type
	return int(int(Advanced(self).GetDeviceMemoryByObjectType(int64(atype))))
}

/*
Same as [method get_device_allocation_count] but filtered for a given object type.
The type argument must be in range [code][0; get_tracked_object_type_count - 1][/code]. If [method get_tracked_object_type_count] is 0, then type argument is ignored and always returns 0.
This is only used by Vulkan in debug builds and can return 0 when this information is not tracked or unknown.
*/
func (self Instance) GetDeviceAllocsByObjectType(atype int) int { //gd:RenderingDevice.get_device_allocs_by_object_type
	return int(int(Advanced(self).GetDeviceAllocsByObjectType(int64(atype))))
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.RenderingDevice

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.RenderingDevice)(unsafe.Pointer(&obj))
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.RenderingDevice)(unsafe.Pointer(&obj))
		return true
	}
	return false
}

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {

	if !gd.Linked {
		var placeholder Instance
		*(*gd.Object)(unsafe.Pointer(&placeholder)) = pointers.Add[gd.Object]([3]uint64{})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(*(*gd.Object)(unsafe.Pointer(&placeholder)), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	object := [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})}
	casted := Instance{*(*gdclass.RenderingDevice)(unsafe.Pointer(&object))}
	object[0].Notification(0, false)
	return casted
}

/*
Creates a new texture. It can be accessed with the RID that is returned.
Once finished with your RID, you will want to free the RID using the RenderingDevice's [method free_rid] method.
[b]Note:[/b] Not to be confused with [method RenderingServer.texture_2d_create], which creates the Godot-specific [Texture2D] resource as opposed to the graphics API's own texture type.
*/
//go:nosplit
func (self class) TextureCreate(format [1]gdclass.RDTextureFormat, view [1]gdclass.RDTextureView, data Array.Contains[Packed.Bytes]) RID.Any { //gd:RenderingDevice.texture_create
	var r_ret = gdextension.Call[RID.Any](gd.ObjectChecked(self.AsObject()), methods.texture_create, gdextension.SizeRID|(gdextension.SizeObject<<4)|(gdextension.SizeObject<<8)|(gdextension.SizeArray<<12), unsafe.Pointer(&struct {
		format gdextension.Object
		view   gdextension.Object
		data   gdextension.Array
	}{gdextension.Object(gd.ObjectChecked(format[0].AsObject())), gdextension.Object(gd.ObjectChecked(view[0].AsObject())), pointers.Get(gd.InternalArray(data))}))
	var ret = r_ret
	return ret
}

/*
Creates a shared texture using the specified [param view] and the texture information from [param with_texture].
*/
//go:nosplit
func (self class) TextureCreateShared(view [1]gdclass.RDTextureView, with_texture RID.Any) RID.Any { //gd:RenderingDevice.texture_create_shared
	var r_ret = gdextension.Call[RID.Any](gd.ObjectChecked(self.AsObject()), methods.texture_create_shared, gdextension.SizeRID|(gdextension.SizeObject<<4)|(gdextension.SizeRID<<8), unsafe.Pointer(&struct {
		view         gdextension.Object
		with_texture RID.Any
	}{gdextension.Object(gd.ObjectChecked(view[0].AsObject())), with_texture}))
	var ret = r_ret
	return ret
}

/*
Creates a shared texture using the specified [param view] and the texture information from [param with_texture]'s [param layer] and [param mipmap]. The number of included mipmaps from the original texture can be controlled using the [param mipmaps] parameter. Only relevant for textures with multiple layers, such as 3D textures, texture arrays and cubemaps. For single-layer textures, use [method texture_create_shared].
For 2D textures (which only have one layer), [param layer] must be [code]0[/code].
[b]Note:[/b] Layer slicing is only supported for 2D texture arrays, not 3D textures or cubemaps.
*/
//go:nosplit
func (self class) TextureCreateSharedFromSlice(view [1]gdclass.RDTextureView, with_texture RID.Any, layer int64, mipmap int64, mipmaps int64, slice_type Rendering.TextureSliceType) RID.Any { //gd:RenderingDevice.texture_create_shared_from_slice
	var r_ret = gdextension.Call[RID.Any](gd.ObjectChecked(self.AsObject()), methods.texture_create_shared_from_slice, gdextension.SizeRID|(gdextension.SizeObject<<4)|(gdextension.SizeRID<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeInt<<16)|(gdextension.SizeInt<<20)|(gdextension.SizeInt<<24), unsafe.Pointer(&struct {
		view         gdextension.Object
		with_texture RID.Any
		layer        int64
		mipmap       int64
		mipmaps      int64
		slice_type   Rendering.TextureSliceType
	}{gdextension.Object(gd.ObjectChecked(view[0].AsObject())), with_texture, layer, mipmap, mipmaps, slice_type}))
	var ret = r_ret
	return ret
}

/*
Returns an RID for an existing [param image] ([code]VkImage[/code]) with the given [param type], [param format], [param samples], [param usage_flags], [param width], [param height], [param depth], and [param layers]. This can be used to allow Godot to render onto foreign images.
*/
//go:nosplit
func (self class) TextureCreateFromExtension(atype Rendering.TextureType, format Rendering.DataFormat, samples Rendering.TextureSamples, usage_flags Rendering.TextureUsageBits, image int64, width int64, height int64, depth int64, layers int64) RID.Any { //gd:RenderingDevice.texture_create_from_extension
	var r_ret = gdextension.Call[RID.Any](gd.ObjectChecked(self.AsObject()), methods.texture_create_from_extension, gdextension.SizeRID|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeInt<<16)|(gdextension.SizeInt<<20)|(gdextension.SizeInt<<24)|(gdextension.SizeInt<<28)|(gdextension.SizeInt<<32)|(gdextension.SizeInt<<36), unsafe.Pointer(&struct {
		atype       Rendering.TextureType
		format      Rendering.DataFormat
		samples     Rendering.TextureSamples
		usage_flags Rendering.TextureUsageBits
		image       int64
		width       int64
		height      int64
		depth       int64
		layers      int64
	}{atype, format, samples, usage_flags, image, width, height, depth, layers}))
	var ret = r_ret
	return ret
}

/*
Updates texture data with new data, replacing the previous data in place. The updated texture data must have the same dimensions and format. For 2D textures (which only have one layer), [param layer] must be [code]0[/code]. Returns [constant @GlobalScope.OK] if the update was successful, [constant @GlobalScope.ERR_INVALID_PARAMETER] otherwise.
[b]Note:[/b] Updating textures is forbidden during creation of a draw or compute list.
[b]Note:[/b] The existing [param texture] can't be updated while a draw list that uses it as part of a framebuffer is being created. Ensure the draw list is finalized (and that the color/depth texture using it is not set to [constant FINAL_ACTION_CONTINUE]) to update this texture.
[b]Note:[/b] The existing [param texture] requires the [constant TEXTURE_USAGE_CAN_UPDATE_BIT] to be updatable.
*/
//go:nosplit
func (self class) TextureUpdate(texture RID.Any, layer int64, data Packed.Bytes) Error.Code { //gd:RenderingDevice.texture_update
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.texture_update, gdextension.SizeInt|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8)|(gdextension.SizePackedArray<<12), unsafe.Pointer(&struct {
		texture RID.Any
		layer   int64
		data    gdextension.PackedArray[byte]
	}{texture, layer, pointers.Get(gd.InternalPacked[gd.PackedByteArray, byte](Packed.Array[byte](data)))}))
	var ret = Error.Code(r_ret)
	return ret
}

/*
Returns the [param texture] data for the specified [param layer] as raw binary data. For 2D textures (which only have one layer), [param layer] must be [code]0[/code].
[b]Note:[/b] [param texture] can't be retrieved while a draw list that uses it as part of a framebuffer is being created. Ensure the draw list is finalized (and that the color/depth texture using it is not set to [constant FINAL_ACTION_CONTINUE]) to retrieve this texture. Otherwise, an error is printed and a empty [PackedByteArray] is returned.
[b]Note:[/b] [param texture] requires the [constant TEXTURE_USAGE_CAN_COPY_FROM_BIT] to be retrieved. Otherwise, an error is printed and a empty [PackedByteArray] is returned.
[b]Note:[/b] This method will block the GPU from working until the data is retrieved. Refer to [method texture_get_data_async] for an alternative that returns the data in more performant way.
*/
//go:nosplit
func (self class) TextureGetData(texture RID.Any, layer int64) Packed.Bytes { //gd:RenderingDevice.texture_get_data
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.texture_get_data, gdextension.SizePackedArray|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		texture RID.Any
		layer   int64
	}{texture, layer}))
	var ret = Packed.Bytes(Array.Through(gd.PackedProxy[gd.PackedByteArray, byte]{}, pointers.Pack(pointers.Let[gd.PackedByteArray](r_ret))))
	return ret
}

/*
Asynchronous version of [method texture_get_data]. RenderingDevice will call [param callback] in a certain amount of frames with the data the texture had at the time of the request.
[b]Note:[/b] At the moment, the delay corresponds to the amount of frames specified by [member ProjectSettings.rendering/rendering_device/vsync/frame_queue_size].
[b]Note:[/b] Downloading large textures can have a prohibitive cost for real-time even when using the asynchronous method due to hardware bandwidth limitations. When dealing with large resources, you can adjust settings such as [member ProjectSettings.rendering/rendering_device/staging_buffer/texture_download_region_size_px] and [member ProjectSettings.rendering/rendering_device/staging_buffer/block_size_kb] to improve the transfer speed at the cost of extra memory.
[codeblock]
func _texture_get_data_callback(array):
    value = array.decode_u32(0)

...

rd.texture_get_data_async(texture, 0, _texture_get_data_callback)
[/codeblock]
*/
//go:nosplit
func (self class) TextureGetDataAsync(texture RID.Any, layer int64, callback Callable.Function) Error.Code { //gd:RenderingDevice.texture_get_data_async
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.texture_get_data_async, gdextension.SizeInt|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeCallable<<12), unsafe.Pointer(&struct {
		texture  RID.Any
		layer    int64
		callback gdextension.Callable
	}{texture, layer, pointers.Get(gd.InternalCallable(callback))}))
	var ret = Error.Code(r_ret)
	return ret
}

/*
Returns [code]true[/code] if the specified [param format] is supported for the given [param usage_flags], [code]false[/code] otherwise.
*/
//go:nosplit
func (self class) TextureIsFormatSupportedForUsage(format Rendering.DataFormat, usage_flags Rendering.TextureUsageBits) bool { //gd:RenderingDevice.texture_is_format_supported_for_usage
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.texture_is_format_supported_for_usage, gdextension.SizeBool|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		format      Rendering.DataFormat
		usage_flags Rendering.TextureUsageBits
	}{format, usage_flags}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if the [param texture] is shared, [code]false[/code] otherwise. See [RDTextureView].
*/
//go:nosplit
func (self class) TextureIsShared(texture RID.Any) bool { //gd:RenderingDevice.texture_is_shared
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.texture_is_shared, gdextension.SizeBool|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ texture RID.Any }{texture}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if the [param texture] is valid, [code]false[/code] otherwise.
*/
//go:nosplit
func (self class) TextureIsValid(texture RID.Any) bool { //gd:RenderingDevice.texture_is_valid
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.texture_is_valid, gdextension.SizeBool|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ texture RID.Any }{texture}))
	var ret = r_ret
	return ret
}

/*
Updates the discardable property of [param texture].
If a texture is discardable, its contents do not need to be preserved between frames. This flag is only relevant when the texture is used as target in a draw list.
This information is used by [RenderingDevice] to figure out if a texture's contents can be discarded, eliminating unnecessary writes to memory and boosting performance.
*/
//go:nosplit
func (self class) TextureSetDiscardable(texture RID.Any, discardable bool) { //gd:RenderingDevice.texture_set_discardable
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.texture_set_discardable, 0|(gdextension.SizeRID<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		texture     RID.Any
		discardable bool
	}{texture, discardable}))
}

/*
Returns [code]true[/code] if the [param texture] is discardable, [code]false[/code] otherwise. See [RDTextureFormat] or [method texture_set_discardable].
*/
//go:nosplit
func (self class) TextureIsDiscardable(texture RID.Any) bool { //gd:RenderingDevice.texture_is_discardable
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.texture_is_discardable, gdextension.SizeBool|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ texture RID.Any }{texture}))
	var ret = r_ret
	return ret
}

/*
Copies the [param from_texture] to [param to_texture] with the specified [param from_pos], [param to_pos] and [param size] coordinates. The Z axis of the [param from_pos], [param to_pos] and [param size] must be [code]0[/code] for 2-dimensional textures. Source and destination mipmaps/layers must also be specified, with these parameters being [code]0[/code] for textures without mipmaps or single-layer textures. Returns [constant @GlobalScope.OK] if the texture copy was successful or [constant @GlobalScope.ERR_INVALID_PARAMETER] otherwise.
[b]Note:[/b] [param from_texture] texture can't be copied while a draw list that uses it as part of a framebuffer is being created. Ensure the draw list is finalized (and that the color/depth texture using it is not set to [constant FINAL_ACTION_CONTINUE]) to copy this texture.
[b]Note:[/b] [param from_texture] texture requires the [constant TEXTURE_USAGE_CAN_COPY_FROM_BIT] to be retrieved.
[b]Note:[/b] [param to_texture] can't be copied while a draw list that uses it as part of a framebuffer is being created. Ensure the draw list is finalized (and that the color/depth texture using it is not set to [constant FINAL_ACTION_CONTINUE]) to copy this texture.
[b]Note:[/b] [param to_texture] requires the [constant TEXTURE_USAGE_CAN_COPY_TO_BIT] to be retrieved.
[b]Note:[/b] [param from_texture] and [param to_texture] must be of the same type (color or depth).
*/
//go:nosplit
func (self class) TextureCopy(from_texture RID.Any, to_texture RID.Any, from_pos Vector3.XYZ, to_pos Vector3.XYZ, size Vector3.XYZ, src_mipmap int64, dst_mipmap int64, src_layer int64, dst_layer int64) Error.Code { //gd:RenderingDevice.texture_copy
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.texture_copy, gdextension.SizeInt|(gdextension.SizeRID<<4)|(gdextension.SizeRID<<8)|(gdextension.SizeVector3<<12)|(gdextension.SizeVector3<<16)|(gdextension.SizeVector3<<20)|(gdextension.SizeInt<<24)|(gdextension.SizeInt<<28)|(gdextension.SizeInt<<32)|(gdextension.SizeInt<<36), unsafe.Pointer(&struct {
		from_texture RID.Any
		to_texture   RID.Any
		from_pos     Vector3.XYZ
		to_pos       Vector3.XYZ
		size         Vector3.XYZ
		src_mipmap   int64
		dst_mipmap   int64
		src_layer    int64
		dst_layer    int64
	}{from_texture, to_texture, from_pos, to_pos, size, src_mipmap, dst_mipmap, src_layer, dst_layer}))
	var ret = Error.Code(r_ret)
	return ret
}

/*
Clears the specified [param texture] by replacing all of its pixels with the specified [param color]. [param base_mipmap] and [param mipmap_count] determine which mipmaps of the texture are affected by this clear operation, while [param base_layer] and [param layer_count] determine which layers of a 3D texture (or texture array) are affected by this clear operation. For 2D textures (which only have one layer by design), [param base_layer] must be [code]0[/code] and [param layer_count] must be [code]1[/code].
[b]Note:[/b] [param texture] can't be cleared while a draw list that uses it as part of a framebuffer is being created. Ensure the draw list is finalized (and that the color/depth texture using it is not set to [constant FINAL_ACTION_CONTINUE]) to clear this texture.
*/
//go:nosplit
func (self class) TextureClear(texture RID.Any, color Color.RGBA, base_mipmap int64, mipmap_count int64, base_layer int64, layer_count int64) Error.Code { //gd:RenderingDevice.texture_clear
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.texture_clear, gdextension.SizeInt|(gdextension.SizeRID<<4)|(gdextension.SizeColor<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeInt<<16)|(gdextension.SizeInt<<20)|(gdextension.SizeInt<<24), unsafe.Pointer(&struct {
		texture      RID.Any
		color        Color.RGBA
		base_mipmap  int64
		mipmap_count int64
		base_layer   int64
		layer_count  int64
	}{texture, color, base_mipmap, mipmap_count, base_layer, layer_count}))
	var ret = Error.Code(r_ret)
	return ret
}

/*
Resolves the [param from_texture] texture onto [param to_texture] with multisample antialiasing enabled. This must be used when rendering a framebuffer for MSAA to work. Returns [constant @GlobalScope.OK] if successful, [constant @GlobalScope.ERR_INVALID_PARAMETER] otherwise.
[b]Note:[/b] [param from_texture] and [param to_texture] textures must have the same dimension, format and type (color or depth).
[b]Note:[/b] [param from_texture] can't be copied while a draw list that uses it as part of a framebuffer is being created. Ensure the draw list is finalized (and that the color/depth texture using it is not set to [constant FINAL_ACTION_CONTINUE]) to resolve this texture.
[b]Note:[/b] [param from_texture] requires the [constant TEXTURE_USAGE_CAN_COPY_FROM_BIT] to be retrieved.
[b]Note:[/b] [param from_texture] must be multisampled and must also be 2D (or a slice of a 3D/cubemap texture).
[b]Note:[/b] [param to_texture] can't be copied while a draw list that uses it as part of a framebuffer is being created. Ensure the draw list is finalized (and that the color/depth texture using it is not set to [constant FINAL_ACTION_CONTINUE]) to resolve this texture.
[b]Note:[/b] [param to_texture] texture requires the [constant TEXTURE_USAGE_CAN_COPY_TO_BIT] to be retrieved.
[b]Note:[/b] [param to_texture] texture must [b]not[/b] be multisampled and must also be 2D (or a slice of a 3D/cubemap texture).
*/
//go:nosplit
func (self class) TextureResolveMultisample(from_texture RID.Any, to_texture RID.Any) Error.Code { //gd:RenderingDevice.texture_resolve_multisample
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.texture_resolve_multisample, gdextension.SizeInt|(gdextension.SizeRID<<4)|(gdextension.SizeRID<<8), unsafe.Pointer(&struct {
		from_texture RID.Any
		to_texture   RID.Any
	}{from_texture, to_texture}))
	var ret = Error.Code(r_ret)
	return ret
}

/*
Returns the data format used to create this texture.
*/
//go:nosplit
func (self class) TextureGetFormat(texture RID.Any) [1]gdclass.RDTextureFormat { //gd:RenderingDevice.texture_get_format
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.texture_get_format, gdextension.SizeObject|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ texture RID.Any }{texture}))
	var ret = [1]gdclass.RDTextureFormat{gd.PointerWithOwnershipTransferredToGo[gdclass.RDTextureFormat](r_ret)}
	return ret
}

/*
Returns the internal graphics handle for this texture object. For use when communicating with third-party APIs mostly with GDExtension.
[b]Note:[/b] This function returns a [code]uint64_t[/code] which internally maps to a [code]GLuint[/code] (OpenGL) or [code]VkImage[/code] (Vulkan).
*/
//go:nosplit
func (self class) TextureGetNativeHandle(texture RID.Any) int64 { //gd:RenderingDevice.texture_get_native_handle
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.texture_get_native_handle, gdextension.SizeInt|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ texture RID.Any }{texture}))
	var ret = r_ret
	return ret
}

/*
Creates a new framebuffer format with the specified [param attachments] and [param view_count]. Returns the new framebuffer's unique framebuffer format ID.
If [param view_count] is greater than or equal to [code]2[/code], enables multiview which is used for VR rendering. This requires support for the Vulkan multiview extension.
*/
//go:nosplit
func (self class) FramebufferFormatCreate(attachments Array.Contains[[1]gdclass.RDAttachmentFormat], view_count int64) int64 { //gd:RenderingDevice.framebuffer_format_create
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.framebuffer_format_create, gdextension.SizeInt|(gdextension.SizeArray<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		attachments gdextension.Array
		view_count  int64
	}{pointers.Get(gd.InternalArray(attachments)), view_count}))
	var ret = r_ret
	return ret
}

/*
Creates a multipass framebuffer format with the specified [param attachments], [param passes] and [param view_count] and returns its ID. If [param view_count] is greater than or equal to [code]2[/code], enables multiview which is used for VR rendering. This requires support for the Vulkan multiview extension.
*/
//go:nosplit
func (self class) FramebufferFormatCreateMultipass(attachments Array.Contains[[1]gdclass.RDAttachmentFormat], passes Array.Contains[[1]gdclass.RDFramebufferPass], view_count int64) int64 { //gd:RenderingDevice.framebuffer_format_create_multipass
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.framebuffer_format_create_multipass, gdextension.SizeInt|(gdextension.SizeArray<<4)|(gdextension.SizeArray<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		attachments gdextension.Array
		passes      gdextension.Array
		view_count  int64
	}{pointers.Get(gd.InternalArray(attachments)), pointers.Get(gd.InternalArray(passes)), view_count}))
	var ret = r_ret
	return ret
}

/*
Creates a new empty framebuffer format with the specified number of [param samples] and returns its ID.
*/
//go:nosplit
func (self class) FramebufferFormatCreateEmpty(samples Rendering.TextureSamples) int64 { //gd:RenderingDevice.framebuffer_format_create_empty
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.framebuffer_format_create_empty, gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ samples Rendering.TextureSamples }{samples}))
	var ret = r_ret
	return ret
}

/*
Returns the number of texture samples used for the given framebuffer [param format] ID (returned by [method framebuffer_get_format]).
*/
//go:nosplit
func (self class) FramebufferFormatGetTextureSamples(format int64, render_pass int64) Rendering.TextureSamples { //gd:RenderingDevice.framebuffer_format_get_texture_samples
	var r_ret = gdextension.Call[Rendering.TextureSamples](gd.ObjectChecked(self.AsObject()), methods.framebuffer_format_get_texture_samples, gdextension.SizeInt|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		format      int64
		render_pass int64
	}{format, render_pass}))
	var ret = r_ret
	return ret
}

/*
Creates a new framebuffer. It can be accessed with the RID that is returned.
Once finished with your RID, you will want to free the RID using the RenderingDevice's [method free_rid] method.
*/
//go:nosplit
func (self class) FramebufferCreate(textures Array.Contains[RID.Any], validate_with_format int64, view_count int64) RID.Any { //gd:RenderingDevice.framebuffer_create
	var r_ret = gdextension.Call[RID.Any](gd.ObjectChecked(self.AsObject()), methods.framebuffer_create, gdextension.SizeRID|(gdextension.SizeArray<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		textures             gdextension.Array
		validate_with_format int64
		view_count           int64
	}{pointers.Get(gd.InternalArray(textures)), validate_with_format, view_count}))
	var ret = r_ret
	return ret
}

/*
Creates a new multipass framebuffer. It can be accessed with the RID that is returned.
Once finished with your RID, you will want to free the RID using the RenderingDevice's [method free_rid] method.
*/
//go:nosplit
func (self class) FramebufferCreateMultipass(textures Array.Contains[RID.Any], passes Array.Contains[[1]gdclass.RDFramebufferPass], validate_with_format int64, view_count int64) RID.Any { //gd:RenderingDevice.framebuffer_create_multipass
	var r_ret = gdextension.Call[RID.Any](gd.ObjectChecked(self.AsObject()), methods.framebuffer_create_multipass, gdextension.SizeRID|(gdextension.SizeArray<<4)|(gdextension.SizeArray<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeInt<<16), unsafe.Pointer(&struct {
		textures             gdextension.Array
		passes               gdextension.Array
		validate_with_format int64
		view_count           int64
	}{pointers.Get(gd.InternalArray(textures)), pointers.Get(gd.InternalArray(passes)), validate_with_format, view_count}))
	var ret = r_ret
	return ret
}

/*
Creates a new empty framebuffer. It can be accessed with the RID that is returned.
Once finished with your RID, you will want to free the RID using the RenderingDevice's [method free_rid] method.
*/
//go:nosplit
func (self class) FramebufferCreateEmpty(size Vector2i.XY, samples Rendering.TextureSamples, validate_with_format int64) RID.Any { //gd:RenderingDevice.framebuffer_create_empty
	var r_ret = gdextension.Call[RID.Any](gd.ObjectChecked(self.AsObject()), methods.framebuffer_create_empty, gdextension.SizeRID|(gdextension.SizeVector2i<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		size                 Vector2i.XY
		samples              Rendering.TextureSamples
		validate_with_format int64
	}{size, samples, validate_with_format}))
	var ret = r_ret
	return ret
}

/*
Returns the format ID of the framebuffer specified by the [param framebuffer] RID. This ID is guaranteed to be unique for the same formats and does not need to be freed.
*/
//go:nosplit
func (self class) FramebufferGetFormat(framebuffer RID.Any) int64 { //gd:RenderingDevice.framebuffer_get_format
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.framebuffer_get_format, gdextension.SizeInt|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ framebuffer RID.Any }{framebuffer}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if the framebuffer specified by the [param framebuffer] RID is valid, [code]false[/code] otherwise.
*/
//go:nosplit
func (self class) FramebufferIsValid(framebuffer RID.Any) bool { //gd:RenderingDevice.framebuffer_is_valid
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.framebuffer_is_valid, gdextension.SizeBool|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ framebuffer RID.Any }{framebuffer}))
	var ret = r_ret
	return ret
}

/*
Creates a new sampler. It can be accessed with the RID that is returned.
Once finished with your RID, you will want to free the RID using the RenderingDevice's [method free_rid] method.
*/
//go:nosplit
func (self class) SamplerCreate(state [1]gdclass.RDSamplerState) RID.Any { //gd:RenderingDevice.sampler_create
	var r_ret = gdextension.Call[RID.Any](gd.ObjectChecked(self.AsObject()), methods.sampler_create, gdextension.SizeRID|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ state gdextension.Object }{gdextension.Object(gd.ObjectChecked(state[0].AsObject()))}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if implementation supports using a texture of [param format] with the given [param sampler_filter].
*/
//go:nosplit
func (self class) SamplerIsFormatSupportedForFilter(format Rendering.DataFormat, sampler_filter Rendering.SamplerFilter) bool { //gd:RenderingDevice.sampler_is_format_supported_for_filter
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.sampler_is_format_supported_for_filter, gdextension.SizeBool|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		format         Rendering.DataFormat
		sampler_filter Rendering.SamplerFilter
	}{format, sampler_filter}))
	var ret = r_ret
	return ret
}

/*
It can be accessed with the RID that is returned.
Once finished with your RID, you will want to free the RID using the RenderingDevice's [method free_rid] method.
*/
//go:nosplit
func (self class) VertexBufferCreate(size_bytes int64, data Packed.Bytes, creation_bits Rendering.BufferCreationBits) RID.Any { //gd:RenderingDevice.vertex_buffer_create
	var r_ret = gdextension.Call[RID.Any](gd.ObjectChecked(self.AsObject()), methods.vertex_buffer_create, gdextension.SizeRID|(gdextension.SizeInt<<4)|(gdextension.SizePackedArray<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		size_bytes    int64
		data          gdextension.PackedArray[byte]
		creation_bits Rendering.BufferCreationBits
	}{size_bytes, pointers.Get(gd.InternalPacked[gd.PackedByteArray, byte](Packed.Array[byte](data))), creation_bits}))
	var ret = r_ret
	return ret
}

/*
Creates a new vertex format with the specified [param vertex_descriptions]. Returns a unique vertex format ID corresponding to the newly created vertex format.
*/
//go:nosplit
func (self class) VertexFormatCreate(vertex_descriptions Array.Contains[[1]gdclass.RDVertexAttribute]) int64 { //gd:RenderingDevice.vertex_format_create
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.vertex_format_create, gdextension.SizeInt|(gdextension.SizeArray<<4), unsafe.Pointer(&struct{ vertex_descriptions gdextension.Array }{pointers.Get(gd.InternalArray(vertex_descriptions))}))
	var ret = r_ret
	return ret
}

/*
Creates a vertex array based on the specified buffers. Optionally, [param offsets] (in bytes) may be defined for each buffer.
*/
//go:nosplit
func (self class) VertexArrayCreate(vertex_count int64, vertex_format int64, src_buffers Array.Contains[RID.Any], offsets Packed.Array[int64]) RID.Any { //gd:RenderingDevice.vertex_array_create
	var r_ret = gdextension.Call[RID.Any](gd.ObjectChecked(self.AsObject()), methods.vertex_array_create, gdextension.SizeRID|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeArray<<12)|(gdextension.SizePackedArray<<16), unsafe.Pointer(&struct {
		vertex_count  int64
		vertex_format int64
		src_buffers   gdextension.Array
		offsets       gdextension.PackedArray[int64]
	}{vertex_count, vertex_format, pointers.Get(gd.InternalArray(src_buffers)), pointers.Get(gd.InternalPacked[gd.PackedInt64Array, int64](offsets))}))
	var ret = r_ret
	return ret
}

/*
Creates a new index buffer. It can be accessed with the RID that is returned.
Once finished with your RID, you will want to free the RID using the RenderingDevice's [method free_rid] method.
*/
//go:nosplit
func (self class) IndexBufferCreate(size_indices int64, format Rendering.IndexBufferFormat, data Packed.Bytes, use_restart_indices bool, creation_bits Rendering.BufferCreationBits) RID.Any { //gd:RenderingDevice.index_buffer_create
	var r_ret = gdextension.Call[RID.Any](gd.ObjectChecked(self.AsObject()), methods.index_buffer_create, gdextension.SizeRID|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8)|(gdextension.SizePackedArray<<12)|(gdextension.SizeBool<<16)|(gdextension.SizeInt<<20), unsafe.Pointer(&struct {
		size_indices        int64
		format              Rendering.IndexBufferFormat
		data                gdextension.PackedArray[byte]
		use_restart_indices bool
		creation_bits       Rendering.BufferCreationBits
	}{size_indices, format, pointers.Get(gd.InternalPacked[gd.PackedByteArray, byte](Packed.Array[byte](data))), use_restart_indices, creation_bits}))
	var ret = r_ret
	return ret
}

/*
Creates a new index array. It can be accessed with the RID that is returned.
Once finished with your RID, you will want to free the RID using the RenderingDevice's [method free_rid] method.
*/
//go:nosplit
func (self class) IndexArrayCreate(index_buffer RID.Any, index_offset int64, index_count int64) RID.Any { //gd:RenderingDevice.index_array_create
	var r_ret = gdextension.Call[RID.Any](gd.ObjectChecked(self.AsObject()), methods.index_array_create, gdextension.SizeRID|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		index_buffer RID.Any
		index_offset int64
		index_count  int64
	}{index_buffer, index_offset, index_count}))
	var ret = r_ret
	return ret
}

/*
Compiles a SPIR-V from the shader source code in [param shader_source] and returns the SPIR-V as a [RDShaderSPIRV]. This intermediate language shader is portable across different GPU models and driver versions, but cannot be run directly by GPUs until compiled into a binary shader using [method shader_compile_binary_from_spirv].
If [param allow_cache] is [code]true[/code], make use of the shader cache generated by Godot. This avoids a potentially lengthy shader compilation step if the shader is already in cache. If [param allow_cache] is [code]false[/code], Godot's shader cache is ignored and the shader will always be recompiled.
*/
//go:nosplit
func (self class) ShaderCompileSpirvFromSource(shader_source [1]gdclass.RDShaderSource, allow_cache bool) [1]gdclass.RDShaderSPIRV { //gd:RenderingDevice.shader_compile_spirv_from_source
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.shader_compile_spirv_from_source, gdextension.SizeObject|(gdextension.SizeObject<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		shader_source gdextension.Object
		allow_cache   bool
	}{gdextension.Object(gd.ObjectChecked(shader_source[0].AsObject())), allow_cache}))
	var ret = [1]gdclass.RDShaderSPIRV{gd.PointerWithOwnershipTransferredToGo[gdclass.RDShaderSPIRV](r_ret)}
	return ret
}

/*
Compiles a binary shader from [param spirv_data] and returns the compiled binary data as a [PackedByteArray]. This compiled shader is specific to the GPU model and driver version used; it will not work on different GPU models or even different driver versions. See also [method shader_compile_spirv_from_source].
[param name] is an optional human-readable name that can be given to the compiled shader for organizational purposes.
*/
//go:nosplit
func (self class) ShaderCompileBinaryFromSpirv(spirv_data [1]gdclass.RDShaderSPIRV, name String.Readable) Packed.Bytes { //gd:RenderingDevice.shader_compile_binary_from_spirv
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.shader_compile_binary_from_spirv, gdextension.SizePackedArray|(gdextension.SizeObject<<4)|(gdextension.SizeString<<8), unsafe.Pointer(&struct {
		spirv_data gdextension.Object
		name       gdextension.String
	}{gdextension.Object(gd.ObjectChecked(spirv_data[0].AsObject())), pointers.Get(gd.InternalString(name))}))
	var ret = Packed.Bytes(Array.Through(gd.PackedProxy[gd.PackedByteArray, byte]{}, pointers.Pack(pointers.Let[gd.PackedByteArray](r_ret))))
	return ret
}

/*
Creates a new shader instance from SPIR-V intermediate code. It can be accessed with the RID that is returned.
Once finished with your RID, you will want to free the RID using the RenderingDevice's [method free_rid] method. See also [method shader_compile_spirv_from_source] and [method shader_create_from_bytecode].
*/
//go:nosplit
func (self class) ShaderCreateFromSpirv(spirv_data [1]gdclass.RDShaderSPIRV, name String.Readable) RID.Any { //gd:RenderingDevice.shader_create_from_spirv
	var r_ret = gdextension.Call[RID.Any](gd.ObjectChecked(self.AsObject()), methods.shader_create_from_spirv, gdextension.SizeRID|(gdextension.SizeObject<<4)|(gdextension.SizeString<<8), unsafe.Pointer(&struct {
		spirv_data gdextension.Object
		name       gdextension.String
	}{gdextension.Object(gd.ObjectChecked(spirv_data[0].AsObject())), pointers.Get(gd.InternalString(name))}))
	var ret = r_ret
	return ret
}

/*
Creates a new shader instance from a binary compiled shader. It can be accessed with the RID that is returned.
Once finished with your RID, you will want to free the RID using the RenderingDevice's [method free_rid] method. See also [method shader_compile_binary_from_spirv] and [method shader_create_from_spirv].
*/
//go:nosplit
func (self class) ShaderCreateFromBytecode(binary_data Packed.Bytes, placeholder_rid RID.Any) RID.Any { //gd:RenderingDevice.shader_create_from_bytecode
	var r_ret = gdextension.Call[RID.Any](gd.ObjectChecked(self.AsObject()), methods.shader_create_from_bytecode, gdextension.SizeRID|(gdextension.SizePackedArray<<4)|(gdextension.SizeRID<<8), unsafe.Pointer(&struct {
		binary_data     gdextension.PackedArray[byte]
		placeholder_rid RID.Any
	}{pointers.Get(gd.InternalPacked[gd.PackedByteArray, byte](Packed.Array[byte](binary_data))), placeholder_rid}))
	var ret = r_ret
	return ret
}

/*
Create a placeholder RID by allocating an RID without initializing it for use in [method shader_create_from_bytecode]. This allows you to create an RID for a shader and pass it around, but defer compiling the shader to a later time.
*/
//go:nosplit
func (self class) ShaderCreatePlaceholder() RID.Any { //gd:RenderingDevice.shader_create_placeholder
	var r_ret = gdextension.Call[RID.Any](gd.ObjectChecked(self.AsObject()), methods.shader_create_placeholder, gdextension.SizeRID, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the internal vertex input mask. Internally, the vertex input mask is an unsigned integer consisting of the locations (specified in GLSL via. [code]layout(location = ...)[/code]) of the input variables (specified in GLSL by the [code]in[/code] keyword).
*/
//go:nosplit
func (self class) ShaderGetVertexInputAttributeMask(shader RID.Any) int64 { //gd:RenderingDevice.shader_get_vertex_input_attribute_mask
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.shader_get_vertex_input_attribute_mask, gdextension.SizeInt|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ shader RID.Any }{shader}))
	var ret = r_ret
	return ret
}

/*
Creates a new uniform buffer. It can be accessed with the RID that is returned.
Once finished with your RID, you will want to free the RID using the RenderingDevice's [method free_rid] method.
*/
//go:nosplit
func (self class) UniformBufferCreate(size_bytes int64, data Packed.Bytes, creation_bits Rendering.BufferCreationBits) RID.Any { //gd:RenderingDevice.uniform_buffer_create
	var r_ret = gdextension.Call[RID.Any](gd.ObjectChecked(self.AsObject()), methods.uniform_buffer_create, gdextension.SizeRID|(gdextension.SizeInt<<4)|(gdextension.SizePackedArray<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		size_bytes    int64
		data          gdextension.PackedArray[byte]
		creation_bits Rendering.BufferCreationBits
	}{size_bytes, pointers.Get(gd.InternalPacked[gd.PackedByteArray, byte](Packed.Array[byte](data))), creation_bits}))
	var ret = r_ret
	return ret
}

/*
Creates a [url=https://vkguide.dev/docs/chapter-4/storage_buffers/]storage buffer[/url] with the specified [param data] and [param usage]. It can be accessed with the RID that is returned.
Once finished with your RID, you will want to free the RID using the RenderingDevice's [method free_rid] method.
*/
//go:nosplit
func (self class) StorageBufferCreate(size_bytes int64, data Packed.Bytes, usage Rendering.StorageBufferUsage, creation_bits Rendering.BufferCreationBits) RID.Any { //gd:RenderingDevice.storage_buffer_create
	var r_ret = gdextension.Call[RID.Any](gd.ObjectChecked(self.AsObject()), methods.storage_buffer_create, gdextension.SizeRID|(gdextension.SizeInt<<4)|(gdextension.SizePackedArray<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeInt<<16), unsafe.Pointer(&struct {
		size_bytes    int64
		data          gdextension.PackedArray[byte]
		usage         Rendering.StorageBufferUsage
		creation_bits Rendering.BufferCreationBits
	}{size_bytes, pointers.Get(gd.InternalPacked[gd.PackedByteArray, byte](Packed.Array[byte](data))), usage, creation_bits}))
	var ret = r_ret
	return ret
}

/*
Creates a new texture buffer. It can be accessed with the RID that is returned.
Once finished with your RID, you will want to free the RID using the RenderingDevice's [method free_rid] method.
*/
//go:nosplit
func (self class) TextureBufferCreate(size_bytes int64, format Rendering.DataFormat, data Packed.Bytes) RID.Any { //gd:RenderingDevice.texture_buffer_create
	var r_ret = gdextension.Call[RID.Any](gd.ObjectChecked(self.AsObject()), methods.texture_buffer_create, gdextension.SizeRID|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8)|(gdextension.SizePackedArray<<12), unsafe.Pointer(&struct {
		size_bytes int64
		format     Rendering.DataFormat
		data       gdextension.PackedArray[byte]
	}{size_bytes, format, pointers.Get(gd.InternalPacked[gd.PackedByteArray, byte](Packed.Array[byte](data)))}))
	var ret = r_ret
	return ret
}

/*
Creates a new uniform set. It can be accessed with the RID that is returned.
Once finished with your RID, you will want to free the RID using the RenderingDevice's [method free_rid] method.
*/
//go:nosplit
func (self class) UniformSetCreate(uniforms Array.Contains[[1]gdclass.RDUniform], shader RID.Any, shader_set int64) RID.Any { //gd:RenderingDevice.uniform_set_create
	var r_ret = gdextension.Call[RID.Any](gd.ObjectChecked(self.AsObject()), methods.uniform_set_create, gdextension.SizeRID|(gdextension.SizeArray<<4)|(gdextension.SizeRID<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		uniforms   gdextension.Array
		shader     RID.Any
		shader_set int64
	}{pointers.Get(gd.InternalArray(uniforms)), shader, shader_set}))
	var ret = r_ret
	return ret
}

/*
Checks if the [param uniform_set] is valid, i.e. is owned.
*/
//go:nosplit
func (self class) UniformSetIsValid(uniform_set RID.Any) bool { //gd:RenderingDevice.uniform_set_is_valid
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.uniform_set_is_valid, gdextension.SizeBool|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ uniform_set RID.Any }{uniform_set}))
	var ret = r_ret
	return ret
}

/*
Copies [param size] bytes from the [param src_buffer] at [param src_offset] into [param dst_buffer] at [param dst_offset].
Prints an error if:
- [param size] exceeds the size of either [param src_buffer] or [param dst_buffer] at their corresponding offsets
- a draw list is currently active (created by [method draw_list_begin])
- a compute list is currently active (created by [method compute_list_begin])
*/
//go:nosplit
func (self class) BufferCopy(src_buffer RID.Any, dst_buffer RID.Any, src_offset int64, dst_offset int64, size int64) Error.Code { //gd:RenderingDevice.buffer_copy
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.buffer_copy, gdextension.SizeInt|(gdextension.SizeRID<<4)|(gdextension.SizeRID<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeInt<<16)|(gdextension.SizeInt<<20), unsafe.Pointer(&struct {
		src_buffer RID.Any
		dst_buffer RID.Any
		src_offset int64
		dst_offset int64
		size       int64
	}{src_buffer, dst_buffer, src_offset, dst_offset, size}))
	var ret = Error.Code(r_ret)
	return ret
}

/*
Updates a region of [param size_bytes] bytes, starting at [param offset], in the buffer, with the specified [param data].
Prints an error if:
- the region specified by [param offset] + [param size_bytes] exceeds the buffer
- a draw list is currently active (created by [method draw_list_begin])
- a compute list is currently active (created by [method compute_list_begin])
*/
//go:nosplit
func (self class) BufferUpdate(buffer RID.Any, offset int64, size_bytes int64, data Packed.Bytes) Error.Code { //gd:RenderingDevice.buffer_update
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.buffer_update, gdextension.SizeInt|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeInt<<12)|(gdextension.SizePackedArray<<16), unsafe.Pointer(&struct {
		buffer     RID.Any
		offset     int64
		size_bytes int64
		data       gdextension.PackedArray[byte]
	}{buffer, offset, size_bytes, pointers.Get(gd.InternalPacked[gd.PackedByteArray, byte](Packed.Array[byte](data)))}))
	var ret = Error.Code(r_ret)
	return ret
}

/*
Clears the contents of the [param buffer], clearing [param size_bytes] bytes, starting at [param offset].
Prints an error if:
- the size isn't a multiple of four
- the region specified by [param offset] + [param size_bytes] exceeds the buffer
- a draw list is currently active (created by [method draw_list_begin])
- a compute list is currently active (created by [method compute_list_begin])
*/
//go:nosplit
func (self class) BufferClear(buffer RID.Any, offset int64, size_bytes int64) Error.Code { //gd:RenderingDevice.buffer_clear
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.buffer_clear, gdextension.SizeInt|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		buffer     RID.Any
		offset     int64
		size_bytes int64
	}{buffer, offset, size_bytes}))
	var ret = Error.Code(r_ret)
	return ret
}

/*
Returns a copy of the data of the specified [param buffer], optionally [param offset_bytes] and [param size_bytes] can be set to copy only a portion of the buffer.
[b]Note:[/b] This method will block the GPU from working until the data is retrieved. Refer to [method buffer_get_data_async] for an alternative that returns the data in more performant way.
*/
//go:nosplit
func (self class) BufferGetData(buffer RID.Any, offset_bytes int64, size_bytes int64) Packed.Bytes { //gd:RenderingDevice.buffer_get_data
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.buffer_get_data, gdextension.SizePackedArray|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		buffer       RID.Any
		offset_bytes int64
		size_bytes   int64
	}{buffer, offset_bytes, size_bytes}))
	var ret = Packed.Bytes(Array.Through(gd.PackedProxy[gd.PackedByteArray, byte]{}, pointers.Pack(pointers.Let[gd.PackedByteArray](r_ret))))
	return ret
}

/*
Asynchronous version of [method buffer_get_data]. RenderingDevice will call [param callback] in a certain amount of frames with the data the buffer had at the time of the request.
[b]Note:[/b] At the moment, the delay corresponds to the amount of frames specified by [member ProjectSettings.rendering/rendering_device/vsync/frame_queue_size].
[b]Note:[/b] Downloading large buffers can have a prohibitive cost for real-time even when using the asynchronous method due to hardware bandwidth limitations. When dealing with large resources, you can adjust settings such as [member ProjectSettings.rendering/rendering_device/staging_buffer/block_size_kb] to improve the transfer speed at the cost of extra memory.
[codeblock]
func _buffer_get_data_callback(array):
    value = array.decode_u32(0)

...

rd.buffer_get_data_async(buffer, _buffer_get_data_callback)
[/codeblock]
*/
//go:nosplit
func (self class) BufferGetDataAsync(buffer RID.Any, callback Callable.Function, offset_bytes int64, size_bytes int64) Error.Code { //gd:RenderingDevice.buffer_get_data_async
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.buffer_get_data_async, gdextension.SizeInt|(gdextension.SizeRID<<4)|(gdextension.SizeCallable<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeInt<<16), unsafe.Pointer(&struct {
		buffer       RID.Any
		callback     gdextension.Callable
		offset_bytes int64
		size_bytes   int64
	}{buffer, pointers.Get(gd.InternalCallable(callback)), offset_bytes, size_bytes}))
	var ret = Error.Code(r_ret)
	return ret
}

/*
Returns the address of the given [param buffer] which can be passed to shaders in any way to access underlying data. Buffer must have been created with this feature enabled.
[b]Note:[/b] You must check that the GPU supports this functionality by calling [method has_feature] with [constant SUPPORTS_BUFFER_DEVICE_ADDRESS] as a parameter.
*/
//go:nosplit
func (self class) BufferGetDeviceAddress(buffer RID.Any) int64 { //gd:RenderingDevice.buffer_get_device_address
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.buffer_get_device_address, gdextension.SizeInt|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ buffer RID.Any }{buffer}))
	var ret = r_ret
	return ret
}

/*
Creates a new render pipeline. It can be accessed with the RID that is returned.
Once finished with your RID, you will want to free the RID using the RenderingDevice's [method free_rid] method.
*/
//go:nosplit
func (self class) RenderPipelineCreate(shader RID.Any, framebuffer_format int64, vertex_format int64, primitive Rendering.RenderPrimitive, rasterization_state [1]gdclass.RDPipelineRasterizationState, multisample_state [1]gdclass.RDPipelineMultisampleState, stencil_state [1]gdclass.RDPipelineDepthStencilState, color_blend_state [1]gdclass.RDPipelineColorBlendState, dynamic_state_flags Rendering.PipelineDynamicStateFlags, for_render_pass int64, specialization_constants Array.Contains[[1]gdclass.RDPipelineSpecializationConstant]) RID.Any { //gd:RenderingDevice.render_pipeline_create
	var r_ret = gdextension.Call[RID.Any](gd.ObjectChecked(self.AsObject()), methods.render_pipeline_create, gdextension.SizeRID|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeInt<<16)|(gdextension.SizeObject<<20)|(gdextension.SizeObject<<24)|(gdextension.SizeObject<<28)|(gdextension.SizeObject<<32)|(gdextension.SizeInt<<36)|(gdextension.SizeInt<<40)|(gdextension.SizeArray<<44), unsafe.Pointer(&struct {
		shader                   RID.Any
		framebuffer_format       int64
		vertex_format            int64
		primitive                Rendering.RenderPrimitive
		rasterization_state      gdextension.Object
		multisample_state        gdextension.Object
		stencil_state            gdextension.Object
		color_blend_state        gdextension.Object
		dynamic_state_flags      Rendering.PipelineDynamicStateFlags
		for_render_pass          int64
		specialization_constants gdextension.Array
	}{shader, framebuffer_format, vertex_format, primitive, gdextension.Object(gd.ObjectChecked(rasterization_state[0].AsObject())), gdextension.Object(gd.ObjectChecked(multisample_state[0].AsObject())), gdextension.Object(gd.ObjectChecked(stencil_state[0].AsObject())), gdextension.Object(gd.ObjectChecked(color_blend_state[0].AsObject())), dynamic_state_flags, for_render_pass, pointers.Get(gd.InternalArray(specialization_constants))}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if the render pipeline specified by the [param render_pipeline] RID is valid, [code]false[/code] otherwise.
*/
//go:nosplit
func (self class) RenderPipelineIsValid(render_pipeline RID.Any) bool { //gd:RenderingDevice.render_pipeline_is_valid
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.render_pipeline_is_valid, gdextension.SizeBool|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ render_pipeline RID.Any }{render_pipeline}))
	var ret = r_ret
	return ret
}

/*
Creates a new compute pipeline. It can be accessed with the RID that is returned.
Once finished with your RID, you will want to free the RID using the RenderingDevice's [method free_rid] method.
*/
//go:nosplit
func (self class) ComputePipelineCreate(shader RID.Any, specialization_constants Array.Contains[[1]gdclass.RDPipelineSpecializationConstant]) RID.Any { //gd:RenderingDevice.compute_pipeline_create
	var r_ret = gdextension.Call[RID.Any](gd.ObjectChecked(self.AsObject()), methods.compute_pipeline_create, gdextension.SizeRID|(gdextension.SizeRID<<4)|(gdextension.SizeArray<<8), unsafe.Pointer(&struct {
		shader                   RID.Any
		specialization_constants gdextension.Array
	}{shader, pointers.Get(gd.InternalArray(specialization_constants))}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if the compute pipeline specified by the [param compute_pipeline] RID is valid, [code]false[/code] otherwise.
*/
//go:nosplit
func (self class) ComputePipelineIsValid(compute_pipeline RID.Any) bool { //gd:RenderingDevice.compute_pipeline_is_valid
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.compute_pipeline_is_valid, gdextension.SizeBool|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ compute_pipeline RID.Any }{compute_pipeline}))
	var ret = r_ret
	return ret
}

/*
Returns the window width matching the graphics API context for the given window ID (in pixels). Despite the parameter being named [param screen], this returns the [i]window[/i] size. See also [method screen_get_height].
[b]Note:[/b] Only the main [RenderingDevice] returned by [method RenderingServer.get_rendering_device] has a width. If called on a local [RenderingDevice], this method prints an error and returns [constant INVALID_ID].
*/
//go:nosplit
func (self class) ScreenGetWidth(screen int64) int64 { //gd:RenderingDevice.screen_get_width
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.screen_get_width, gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ screen int64 }{screen}))
	var ret = r_ret
	return ret
}

/*
Returns the window height matching the graphics API context for the given window ID (in pixels). Despite the parameter being named [param screen], this returns the [i]window[/i] size. See also [method screen_get_width].
[b]Note:[/b] Only the main [RenderingDevice] returned by [method RenderingServer.get_rendering_device] has a height. If called on a local [RenderingDevice], this method prints an error and returns [constant INVALID_ID].
*/
//go:nosplit
func (self class) ScreenGetHeight(screen int64) int64 { //gd:RenderingDevice.screen_get_height
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.screen_get_height, gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ screen int64 }{screen}))
	var ret = r_ret
	return ret
}

/*
Returns the framebuffer format of the given screen.
[b]Note:[/b] Only the main [RenderingDevice] returned by [method RenderingServer.get_rendering_device] has a format. If called on a local [RenderingDevice], this method prints an error and returns [constant INVALID_ID].
*/
//go:nosplit
func (self class) ScreenGetFramebufferFormat(screen int64) int64 { //gd:RenderingDevice.screen_get_framebuffer_format
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.screen_get_framebuffer_format, gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ screen int64 }{screen}))
	var ret = r_ret
	return ret
}

/*
High-level variant of [method draw_list_begin], with the parameters automatically being adjusted for drawing onto the window specified by the [param screen] ID.
[b]Note:[/b] Cannot be used with local RenderingDevices, as these don't have a screen. If called on a local RenderingDevice, [method draw_list_begin_for_screen] returns [constant INVALID_ID].
*/
//go:nosplit
func (self class) DrawListBeginForScreen(screen int64, clear_color Color.RGBA) int64 { //gd:RenderingDevice.draw_list_begin_for_screen
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.draw_list_begin_for_screen, gdextension.SizeInt|(gdextension.SizeInt<<4)|(gdextension.SizeColor<<8), unsafe.Pointer(&struct {
		screen      int64
		clear_color Color.RGBA
	}{screen, clear_color}))
	var ret = r_ret
	return ret
}

/*
Starts a list of raster drawing commands created with the [code]draw_*[/code] methods. The returned value should be passed to other [code]draw_list_*[/code] functions.
Multiple draw lists cannot be created at the same time; you must finish the previous draw list first using [method draw_list_end].
A simple drawing operation might look like this (code is not a complete example):
[codeblock]
var rd = RenderingDevice.new()
var clear_colors = PackedColorArray([Color(0, 0, 0, 0), Color(0, 0, 0, 0), Color(0, 0, 0, 0)])
var draw_list = rd.draw_list_begin(framebuffers[i], RenderingDevice.CLEAR_COLOR_ALL, clear_colors, true, 1.0f, true, 0, Rect2(), RenderingDevice.OPAQUE_PASS)

# Draw opaque.
rd.draw_list_bind_render_pipeline(draw_list, raster_pipeline)
rd.draw_list_bind_uniform_set(draw_list, raster_base_uniform, 0)
rd.draw_list_set_push_constant(draw_list, raster_push_constant, raster_push_constant.size())
rd.draw_list_draw(draw_list, false, 1, slice_triangle_count[i] * 3)
# Draw wire.
rd.draw_list_bind_render_pipeline(draw_list, raster_pipeline_wire)
rd.draw_list_bind_uniform_set(draw_list, raster_base_uniform, 0)
rd.draw_list_set_push_constant(draw_list, raster_push_constant, raster_push_constant.size())
rd.draw_list_draw(draw_list, false, 1, slice_triangle_count[i] * 3)

rd.draw_list_end()
[/codeblock]
The [param draw_flags] indicates if the texture attachments of the framebuffer should be cleared or ignored. Only one of the two flags can be used for each individual attachment. Ignoring an attachment means that any contents that existed before the draw list will be completely discarded, reducing the memory bandwidth used by the render pass but producing garbage results if the pixels aren't replaced. The default behavior allows the engine to figure out the right operation to use if the texture is discardable, which can result in increased performance. See [RDTextureFormat] or [method texture_set_discardable].
The [param breadcrumb] parameter can be an arbitrary 32-bit integer that is useful to diagnose GPU crashes. If Godot is built in dev or debug mode; when the GPU crashes Godot will dump all shaders that were being executed at the time of the crash and the breadcrumb is useful to diagnose what passes did those shaders belong to.
It does not affect rendering behavior and can be set to 0. It is recommended to use [enum BreadcrumbMarker] enumerations for consistency but it's not required. It is also possible to use bitwise operations to add extra data. e.g.
[codeblock]
rd.draw_list_begin(fb[i], RenderingDevice.CLEAR_COLOR_ALL, clear_colors, true, 1.0f, true, 0, Rect2(), RenderingDevice.OPAQUE_PASS | 5)
[/codeblock]
*/
//go:nosplit
func (self class) DrawListBegin(framebuffer RID.Any, draw_flags Rendering.DrawFlags, clear_color_values Packed.Array[Color.RGBA], clear_depth_value float64, clear_stencil_value int64, region Rect2.PositionSize, breadcrumb int64) int64 { //gd:RenderingDevice.draw_list_begin
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.draw_list_begin, gdextension.SizeInt|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8)|(gdextension.SizePackedArray<<12)|(gdextension.SizeFloat<<16)|(gdextension.SizeInt<<20)|(gdextension.SizeRect2<<24)|(gdextension.SizeInt<<28), unsafe.Pointer(&struct {
		framebuffer         RID.Any
		draw_flags          Rendering.DrawFlags
		clear_color_values  gdextension.PackedArray[Color.RGBA]
		clear_depth_value   float64
		clear_stencil_value int64
		region              Rect2.PositionSize
		breadcrumb          int64
	}{framebuffer, draw_flags, pointers.Get(gd.InternalPacked[gd.PackedColorArray, Color.RGBA](clear_color_values)), clear_depth_value, clear_stencil_value, region, breadcrumb}))
	var ret = r_ret
	return ret
}

/*
This method does nothing and always returns an empty [PackedInt64Array].
*/
//go:nosplit
func (self class) DrawListBeginSplit(framebuffer RID.Any, splits int64, initial_color_action Rendering.InitialAction, final_color_action Rendering.FinalAction, initial_depth_action Rendering.InitialAction, final_depth_action Rendering.FinalAction, clear_color_values Packed.Array[Color.RGBA], clear_depth float64, clear_stencil int64, region Rect2.PositionSize, storage_textures Array.Contains[RID.Any]) Packed.Array[int64] { //gd:RenderingDevice.draw_list_begin_split
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.draw_list_begin_split, gdextension.SizePackedArray|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeInt<<16)|(gdextension.SizeInt<<20)|(gdextension.SizeInt<<24)|(gdextension.SizePackedArray<<28)|(gdextension.SizeFloat<<32)|(gdextension.SizeInt<<36)|(gdextension.SizeRect2<<40)|(gdextension.SizeArray<<44), unsafe.Pointer(&struct {
		framebuffer          RID.Any
		splits               int64
		initial_color_action Rendering.InitialAction
		final_color_action   Rendering.FinalAction
		initial_depth_action Rendering.InitialAction
		final_depth_action   Rendering.FinalAction
		clear_color_values   gdextension.PackedArray[Color.RGBA]
		clear_depth          float64
		clear_stencil        int64
		region               Rect2.PositionSize
		storage_textures     gdextension.Array
	}{framebuffer, splits, initial_color_action, final_color_action, initial_depth_action, final_depth_action, pointers.Get(gd.InternalPacked[gd.PackedColorArray, Color.RGBA](clear_color_values)), clear_depth, clear_stencil, region, pointers.Get(gd.InternalArray(storage_textures))}))
	var ret = Packed.Array[int64](Array.Through(gd.PackedProxy[gd.PackedInt64Array, int64]{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

/*
Sets blend constants for the specified [param draw_list] to [param color]. Blend constants are used only if the graphics pipeline is created with [constant DYNAMIC_STATE_BLEND_CONSTANTS] flag set.
*/
//go:nosplit
func (self class) DrawListSetBlendConstants(draw_list int64, color Color.RGBA) { //gd:RenderingDevice.draw_list_set_blend_constants
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.draw_list_set_blend_constants, 0|(gdextension.SizeInt<<4)|(gdextension.SizeColor<<8), unsafe.Pointer(&struct {
		draw_list int64
		color     Color.RGBA
	}{draw_list, color}))
}

/*
Binds [param render_pipeline] to the specified [param draw_list].
*/
//go:nosplit
func (self class) DrawListBindRenderPipeline(draw_list int64, render_pipeline RID.Any) { //gd:RenderingDevice.draw_list_bind_render_pipeline
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.draw_list_bind_render_pipeline, 0|(gdextension.SizeInt<<4)|(gdextension.SizeRID<<8), unsafe.Pointer(&struct {
		draw_list       int64
		render_pipeline RID.Any
	}{draw_list, render_pipeline}))
}

/*
Binds [param uniform_set] to the specified [param draw_list]. A [param set_index] must also be specified, which is an identifier starting from [code]0[/code] that must match the one expected by the draw list.
*/
//go:nosplit
func (self class) DrawListBindUniformSet(draw_list int64, uniform_set RID.Any, set_index int64) { //gd:RenderingDevice.draw_list_bind_uniform_set
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.draw_list_bind_uniform_set, 0|(gdextension.SizeInt<<4)|(gdextension.SizeRID<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		draw_list   int64
		uniform_set RID.Any
		set_index   int64
	}{draw_list, uniform_set, set_index}))
}

/*
Binds [param vertex_array] to the specified [param draw_list].
*/
//go:nosplit
func (self class) DrawListBindVertexArray(draw_list int64, vertex_array RID.Any) { //gd:RenderingDevice.draw_list_bind_vertex_array
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.draw_list_bind_vertex_array, 0|(gdextension.SizeInt<<4)|(gdextension.SizeRID<<8), unsafe.Pointer(&struct {
		draw_list    int64
		vertex_array RID.Any
	}{draw_list, vertex_array}))
}

/*
Binds [param index_array] to the specified [param draw_list].
*/
//go:nosplit
func (self class) DrawListBindIndexArray(draw_list int64, index_array RID.Any) { //gd:RenderingDevice.draw_list_bind_index_array
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.draw_list_bind_index_array, 0|(gdextension.SizeInt<<4)|(gdextension.SizeRID<<8), unsafe.Pointer(&struct {
		draw_list   int64
		index_array RID.Any
	}{draw_list, index_array}))
}

/*
Sets the push constant data to [param buffer] for the specified [param draw_list]. The shader determines how this binary data is used. The buffer's size in bytes must also be specified in [param size_bytes] (this can be obtained by calling the [method PackedByteArray.size] method on the passed [param buffer]).
*/
//go:nosplit
func (self class) DrawListSetPushConstant(draw_list int64, buffer Packed.Bytes, size_bytes int64) { //gd:RenderingDevice.draw_list_set_push_constant
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.draw_list_set_push_constant, 0|(gdextension.SizeInt<<4)|(gdextension.SizePackedArray<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		draw_list  int64
		buffer     gdextension.PackedArray[byte]
		size_bytes int64
	}{draw_list, pointers.Get(gd.InternalPacked[gd.PackedByteArray, byte](Packed.Array[byte](buffer))), size_bytes}))
}

/*
Submits [param draw_list] for rendering on the GPU. This is the raster equivalent to [method compute_list_dispatch].
*/
//go:nosplit
func (self class) DrawListDraw(draw_list int64, use_indices bool, instances int64, procedural_vertex_count int64) { //gd:RenderingDevice.draw_list_draw
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.draw_list_draw, 0|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeInt<<16), unsafe.Pointer(&struct {
		draw_list               int64
		use_indices             bool
		instances               int64
		procedural_vertex_count int64
	}{draw_list, use_indices, instances, procedural_vertex_count}))
}

/*
Submits [param draw_list] for rendering on the GPU with the given parameters stored in the [param buffer] at [param offset]. Parameters being integers: vertex count, instance count, first vertex, first instance. And when using indices: index count, instance count, first index, vertex offset, first instance. Buffer must have been created with [constant STORAGE_BUFFER_USAGE_DISPATCH_INDIRECT] flag.
*/
//go:nosplit
func (self class) DrawListDrawIndirect(draw_list int64, use_indices bool, buffer RID.Any, offset int64, draw_count int64, stride int64) { //gd:RenderingDevice.draw_list_draw_indirect
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.draw_list_draw_indirect, 0|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8)|(gdextension.SizeRID<<12)|(gdextension.SizeInt<<16)|(gdextension.SizeInt<<20)|(gdextension.SizeInt<<24), unsafe.Pointer(&struct {
		draw_list   int64
		use_indices bool
		buffer      RID.Any
		offset      int64
		draw_count  int64
		stride      int64
	}{draw_list, use_indices, buffer, offset, draw_count, stride}))
}

/*
Creates a scissor rectangle and enables it for the specified [param draw_list]. Scissor rectangles are used for clipping by discarding fragments that fall outside a specified rectangular portion of the screen. See also [method draw_list_disable_scissor].
[b]Note:[/b] The specified [param rect] is automatically intersected with the screen's dimensions, which means it cannot exceed the screen's dimensions.
*/
//go:nosplit
func (self class) DrawListEnableScissor(draw_list int64, rect Rect2.PositionSize) { //gd:RenderingDevice.draw_list_enable_scissor
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.draw_list_enable_scissor, 0|(gdextension.SizeInt<<4)|(gdextension.SizeRect2<<8), unsafe.Pointer(&struct {
		draw_list int64
		rect      Rect2.PositionSize
	}{draw_list, rect}))
}

/*
Removes and disables the scissor rectangle for the specified [param draw_list]. See also [method draw_list_enable_scissor].
*/
//go:nosplit
func (self class) DrawListDisableScissor(draw_list int64) { //gd:RenderingDevice.draw_list_disable_scissor
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.draw_list_disable_scissor, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ draw_list int64 }{draw_list}))
}

/*
Switches to the next draw pass.
*/
//go:nosplit
func (self class) DrawListSwitchToNextPass() int64 { //gd:RenderingDevice.draw_list_switch_to_next_pass
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.draw_list_switch_to_next_pass, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
This method does nothing and always returns an empty [PackedInt64Array].
*/
//go:nosplit
func (self class) DrawListSwitchToNextPassSplit(splits int64) Packed.Array[int64] { //gd:RenderingDevice.draw_list_switch_to_next_pass_split
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.draw_list_switch_to_next_pass_split, gdextension.SizePackedArray|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ splits int64 }{splits}))
	var ret = Packed.Array[int64](Array.Through(gd.PackedProxy[gd.PackedInt64Array, int64]{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

/*
Finishes a list of raster drawing commands created with the [code]draw_*[/code] methods.
*/
//go:nosplit
func (self class) DrawListEnd() { //gd:RenderingDevice.draw_list_end
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.draw_list_end, 0, unsafe.Pointer(&struct{}{}))
}

/*
Starts a list of compute commands created with the [code]compute_*[/code] methods. The returned value should be passed to other [code]compute_list_*[/code] functions.
Multiple compute lists cannot be created at the same time; you must finish the previous compute list first using [method compute_list_end].
A simple compute operation might look like this (code is not a complete example):
[codeblock]
var rd = RenderingDevice.new()
var compute_list = rd.compute_list_begin()

rd.compute_list_bind_compute_pipeline(compute_list, compute_shader_dilate_pipeline)
rd.compute_list_bind_uniform_set(compute_list, compute_base_uniform_set, 0)
rd.compute_list_bind_uniform_set(compute_list, dilate_uniform_set, 1)

for i in atlas_slices:
    rd.compute_list_set_push_constant(compute_list, push_constant, push_constant.size())
    rd.compute_list_dispatch(compute_list, group_size.x, group_size.y, group_size.z)
    # No barrier, let them run all together.

rd.compute_list_end()
[/codeblock]
*/
//go:nosplit
func (self class) ComputeListBegin() int64 { //gd:RenderingDevice.compute_list_begin
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.compute_list_begin, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Tells the GPU what compute pipeline to use when processing the compute list. If the shader has changed since the last time this function was called, Godot will unbind all descriptor sets and will re-bind them inside [method compute_list_dispatch].
*/
//go:nosplit
func (self class) ComputeListBindComputePipeline(compute_list int64, compute_pipeline RID.Any) { //gd:RenderingDevice.compute_list_bind_compute_pipeline
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.compute_list_bind_compute_pipeline, 0|(gdextension.SizeInt<<4)|(gdextension.SizeRID<<8), unsafe.Pointer(&struct {
		compute_list     int64
		compute_pipeline RID.Any
	}{compute_list, compute_pipeline}))
}

/*
Sets the push constant data to [param buffer] for the specified [param compute_list]. The shader determines how this binary data is used. The buffer's size in bytes must also be specified in [param size_bytes] (this can be obtained by calling the [method PackedByteArray.size] method on the passed [param buffer]).
*/
//go:nosplit
func (self class) ComputeListSetPushConstant(compute_list int64, buffer Packed.Bytes, size_bytes int64) { //gd:RenderingDevice.compute_list_set_push_constant
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.compute_list_set_push_constant, 0|(gdextension.SizeInt<<4)|(gdextension.SizePackedArray<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		compute_list int64
		buffer       gdextension.PackedArray[byte]
		size_bytes   int64
	}{compute_list, pointers.Get(gd.InternalPacked[gd.PackedByteArray, byte](Packed.Array[byte](buffer))), size_bytes}))
}

/*
Binds the [param uniform_set] to this [param compute_list]. Godot ensures that all textures in the uniform set have the correct Vulkan access masks. If Godot had to change access masks of textures, it will raise a Vulkan image memory barrier.
*/
//go:nosplit
func (self class) ComputeListBindUniformSet(compute_list int64, uniform_set RID.Any, set_index int64) { //gd:RenderingDevice.compute_list_bind_uniform_set
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.compute_list_bind_uniform_set, 0|(gdextension.SizeInt<<4)|(gdextension.SizeRID<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		compute_list int64
		uniform_set  RID.Any
		set_index    int64
	}{compute_list, uniform_set, set_index}))
}

/*
Submits the compute list for processing on the GPU. This is the compute equivalent to [method draw_list_draw].
*/
//go:nosplit
func (self class) ComputeListDispatch(compute_list int64, x_groups int64, y_groups int64, z_groups int64) { //gd:RenderingDevice.compute_list_dispatch
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.compute_list_dispatch, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeInt<<16), unsafe.Pointer(&struct {
		compute_list int64
		x_groups     int64
		y_groups     int64
		z_groups     int64
	}{compute_list, x_groups, y_groups, z_groups}))
}

/*
Submits the compute list for processing on the GPU with the given group counts stored in the [param buffer] at [param offset]. Buffer must have been created with [constant STORAGE_BUFFER_USAGE_DISPATCH_INDIRECT] flag.
*/
//go:nosplit
func (self class) ComputeListDispatchIndirect(compute_list int64, buffer RID.Any, offset int64) { //gd:RenderingDevice.compute_list_dispatch_indirect
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.compute_list_dispatch_indirect, 0|(gdextension.SizeInt<<4)|(gdextension.SizeRID<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		compute_list int64
		buffer       RID.Any
		offset       int64
	}{compute_list, buffer, offset}))
}

/*
Raises a Vulkan compute barrier in the specified [param compute_list].
*/
//go:nosplit
func (self class) ComputeListAddBarrier(compute_list int64) { //gd:RenderingDevice.compute_list_add_barrier
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.compute_list_add_barrier, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ compute_list int64 }{compute_list}))
}

/*
Finishes a list of compute commands created with the [code]compute_*[/code] methods.
*/
//go:nosplit
func (self class) ComputeListEnd() { //gd:RenderingDevice.compute_list_end
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.compute_list_end, 0, unsafe.Pointer(&struct{}{}))
}

/*
Tries to free an object in the RenderingDevice. To avoid memory leaks, this should be called after using an object as memory management does not occur automatically when using RenderingDevice directly.
*/
//go:nosplit
func (self class) FreeRid(rid RID.Any) { //gd:RenderingDevice.free_rid
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.free_rid, 0|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ rid RID.Any }{rid}))
}

/*
Creates a timestamp marker with the specified [param name]. This is used for performance reporting with the [method get_captured_timestamp_cpu_time], [method get_captured_timestamp_gpu_time] and [method get_captured_timestamp_name] methods.
*/
//go:nosplit
func (self class) CaptureTimestamp(name String.Readable) { //gd:RenderingDevice.capture_timestamp
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.capture_timestamp, 0|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ name gdextension.String }{pointers.Get(gd.InternalString(name))}))
}

/*
Returns the total number of timestamps (rendering steps) available for profiling.
*/
//go:nosplit
func (self class) GetCapturedTimestampsCount() int64 { //gd:RenderingDevice.get_captured_timestamps_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_captured_timestamps_count, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the index of the last frame rendered that has rendering timestamps available for querying.
*/
//go:nosplit
func (self class) GetCapturedTimestampsFrame() int64 { //gd:RenderingDevice.get_captured_timestamps_frame
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_captured_timestamps_frame, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the timestamp in GPU time for the rendering step specified by [param index] (in microseconds since the engine started). See also [method get_captured_timestamp_cpu_time] and [method capture_timestamp].
*/
//go:nosplit
func (self class) GetCapturedTimestampGpuTime(index int64) int64 { //gd:RenderingDevice.get_captured_timestamp_gpu_time
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_captured_timestamp_gpu_time, gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ index int64 }{index}))
	var ret = r_ret
	return ret
}

/*
Returns the timestamp in CPU time for the rendering step specified by [param index] (in microseconds since the engine started). See also [method get_captured_timestamp_gpu_time] and [method capture_timestamp].
*/
//go:nosplit
func (self class) GetCapturedTimestampCpuTime(index int64) int64 { //gd:RenderingDevice.get_captured_timestamp_cpu_time
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_captured_timestamp_cpu_time, gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ index int64 }{index}))
	var ret = r_ret
	return ret
}

/*
Returns the timestamp's name for the rendering step specified by [param index]. See also [method capture_timestamp].
*/
//go:nosplit
func (self class) GetCapturedTimestampName(index int64) String.Readable { //gd:RenderingDevice.get_captured_timestamp_name
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_captured_timestamp_name, gdextension.SizeString|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ index int64 }{index}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Returns [code]true[/code] if the [param feature] is supported by the GPU.
*/
//go:nosplit
func (self class) HasFeature(feature Rendering.Features) bool { //gd:RenderingDevice.has_feature
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.has_feature, gdextension.SizeBool|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ feature Rendering.Features }{feature}))
	var ret = r_ret
	return ret
}

/*
Returns the value of the specified [param limit]. This limit varies depending on the current graphics hardware (and sometimes the driver version). If the given limit is exceeded, rendering errors will occur.
Limits for various graphics hardware can be found in the [url=https://vulkan.gpuinfo.org/]Vulkan Hardware Database[/url].
*/
//go:nosplit
func (self class) LimitGet(limit Rendering.Limit) int64 { //gd:RenderingDevice.limit_get
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.limit_get, gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ limit Rendering.Limit }{limit}))
	var ret = r_ret
	return ret
}

/*
Returns the frame count kept by the graphics API. Higher values result in higher input lag, but with more consistent throughput. For the main [RenderingDevice], frames are cycled (usually 3 with triple-buffered V-Sync enabled). However, local [RenderingDevice]s only have 1 frame.
*/
//go:nosplit
func (self class) GetFrameDelay() int64 { //gd:RenderingDevice.get_frame_delay
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_frame_delay, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Pushes the frame setup and draw command buffers then marks the local device as currently processing (which allows calling [method sync]).
[b]Note:[/b] Only available in local RenderingDevices.
*/
//go:nosplit
func (self class) Submit() { //gd:RenderingDevice.submit
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.submit, 0, unsafe.Pointer(&struct{}{}))
}

/*
Forces a synchronization between the CPU and GPU, which may be required in certain cases. Only call this when needed, as CPU-GPU synchronization has a performance cost.
[b]Note:[/b] Only available in local RenderingDevices.
[b]Note:[/b] [method sync] can only be called after a [method submit].
*/
//go:nosplit
func (self class) Sync() { //gd:RenderingDevice.sync
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.sync, 0, unsafe.Pointer(&struct{}{}))
}

/*
This method does nothing.
*/
//go:nosplit
func (self class) Barrier(from Rendering.BarrierMask, to Rendering.BarrierMask) { //gd:RenderingDevice.barrier
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.barrier, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		from Rendering.BarrierMask
		to   Rendering.BarrierMask
	}{from, to}))
}

/*
This method does nothing.
*/
//go:nosplit
func (self class) FullBarrier() { //gd:RenderingDevice.full_barrier
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.full_barrier, 0, unsafe.Pointer(&struct{}{}))
}

/*
Create a new local [RenderingDevice]. This is most useful for performing compute operations on the GPU independently from the rest of the engine.
*/
//go:nosplit
func (self class) CreateLocalDevice() [1]gdclass.RenderingDevice { //gd:RenderingDevice.create_local_device
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.create_local_device, gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.RenderingDevice{gd.PointerWithOwnershipTransferredToGo[gdclass.RenderingDevice](r_ret)}
	return ret
}

/*
Sets the resource name for [param id] to [param name]. This is used for debugging with third-party tools such as [url=https://renderdoc.org/]RenderDoc[/url].
The following types of resources can be named: texture, sampler, vertex buffer, index buffer, uniform buffer, texture buffer, storage buffer, uniform set buffer, shader, render pipeline and compute pipeline. Framebuffers cannot be named. Attempting to name an incompatible resource type will print an error.
[b]Note:[/b] Resource names are only set when the engine runs in verbose mode ([method OS.is_stdout_verbose] = [code]true[/code]), or when using an engine build compiled with the [code]dev_mode=yes[/code] SCons option. The graphics driver must also support the [code]VK_EXT_DEBUG_UTILS_EXTENSION_NAME[/code] Vulkan extension for named resources to work.
*/
//go:nosplit
func (self class) SetResourceName(id RID.Any, name String.Readable) { //gd:RenderingDevice.set_resource_name
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_resource_name, 0|(gdextension.SizeRID<<4)|(gdextension.SizeString<<8), unsafe.Pointer(&struct {
		id   RID.Any
		name gdextension.String
	}{id, pointers.Get(gd.InternalString(name))}))
}

/*
Create a command buffer debug label region that can be displayed in third-party tools such as [url=https://renderdoc.org/]RenderDoc[/url]. All regions must be ended with a [method draw_command_end_label] call. When viewed from the linear series of submissions to a single queue, calls to [method draw_command_begin_label] and [method draw_command_end_label] must be matched and balanced.
The [code]VK_EXT_DEBUG_UTILS_EXTENSION_NAME[/code] Vulkan extension must be available and enabled for command buffer debug label region to work. See also [method draw_command_end_label].
*/
//go:nosplit
func (self class) DrawCommandBeginLabel(name String.Readable, color Color.RGBA) { //gd:RenderingDevice.draw_command_begin_label
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.draw_command_begin_label, 0|(gdextension.SizeString<<4)|(gdextension.SizeColor<<8), unsafe.Pointer(&struct {
		name  gdextension.String
		color Color.RGBA
	}{pointers.Get(gd.InternalString(name)), color}))
}

/*
This method does nothing.
*/
//go:nosplit
func (self class) DrawCommandInsertLabel(name String.Readable, color Color.RGBA) { //gd:RenderingDevice.draw_command_insert_label
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.draw_command_insert_label, 0|(gdextension.SizeString<<4)|(gdextension.SizeColor<<8), unsafe.Pointer(&struct {
		name  gdextension.String
		color Color.RGBA
	}{pointers.Get(gd.InternalString(name)), color}))
}

/*
Ends the command buffer debug label region started by a [method draw_command_begin_label] call.
*/
//go:nosplit
func (self class) DrawCommandEndLabel() { //gd:RenderingDevice.draw_command_end_label
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.draw_command_end_label, 0, unsafe.Pointer(&struct{}{}))
}

/*
Returns the vendor of the video adapter (e.g. "NVIDIA Corporation"). Equivalent to [method RenderingServer.get_video_adapter_vendor]. See also [method get_device_name].
*/
//go:nosplit
func (self class) GetDeviceVendorName() String.Readable { //gd:RenderingDevice.get_device_vendor_name
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_device_vendor_name, gdextension.SizeString, unsafe.Pointer(&struct{}{}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Returns the name of the video adapter (e.g. "GeForce GTX 1080/PCIe/SSE2"). Equivalent to [method RenderingServer.get_video_adapter_name]. See also [method get_device_vendor_name].
*/
//go:nosplit
func (self class) GetDeviceName() String.Readable { //gd:RenderingDevice.get_device_name
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_device_name, gdextension.SizeString, unsafe.Pointer(&struct{}{}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Returns the universally unique identifier for the pipeline cache. This is used to cache shader files on disk, which avoids shader recompilations on subsequent engine runs. This UUID varies depending on the graphics card model, but also the driver version. Therefore, updating graphics drivers will invalidate the shader cache.
*/
//go:nosplit
func (self class) GetDevicePipelineCacheUuid() String.Readable { //gd:RenderingDevice.get_device_pipeline_cache_uuid
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_device_pipeline_cache_uuid, gdextension.SizeString, unsafe.Pointer(&struct{}{}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Returns the memory usage in bytes corresponding to the given [param type]. When using Vulkan, these statistics are calculated by [url=https://github.com/GPUOpen-LibrariesAndSDKs/VulkanMemoryAllocator]Vulkan Memory Allocator[/url].
*/
//go:nosplit
func (self class) GetMemoryUsage(atype Rendering.MemoryType) int64 { //gd:RenderingDevice.get_memory_usage
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_memory_usage, gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ atype Rendering.MemoryType }{atype}))
	var ret = r_ret
	return ret
}

/*
Returns the unique identifier of the driver [param resource] for the specified [param rid]. Some driver resource types ignore the specified [param rid] (see [enum DriverResource] descriptions). [param index] is always ignored but must be specified anyway.
*/
//go:nosplit
func (self class) GetDriverResource(resource Rendering.DriverResource, rid RID.Any, index int64) int64 { //gd:RenderingDevice.get_driver_resource
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_driver_resource, gdextension.SizeInt|(gdextension.SizeInt<<4)|(gdextension.SizeRID<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		resource Rendering.DriverResource
		rid      RID.Any
		index    int64
	}{resource, rid, index}))
	var ret = r_ret
	return ret
}

/*
Returns a string with a performance report from the past frame. Updates every frame.
*/
//go:nosplit
func (self class) GetPerfReport() String.Readable { //gd:RenderingDevice.get_perf_report
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_perf_report, gdextension.SizeString, unsafe.Pointer(&struct{}{}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Returns string report in CSV format using the following methods:
- [method get_tracked_object_name]
- [method get_tracked_object_type_count]
- [method get_driver_total_memory]
- [method get_driver_allocation_count]
- [method get_driver_memory_by_object_type]
- [method get_driver_allocs_by_object_type]
- [method get_device_total_memory]
- [method get_device_allocation_count]
- [method get_device_memory_by_object_type]
- [method get_device_allocs_by_object_type]
This is only used by Vulkan in debug builds. Godot must also be started with the [code]--extra-gpu-memory-tracking[/code] [url=$DOCS_URL/tutorials/editor/command_line_tutorial.html]command line argument[/url].
*/
//go:nosplit
func (self class) GetDriverAndDeviceMemoryReport() String.Readable { //gd:RenderingDevice.get_driver_and_device_memory_report
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_driver_and_device_memory_report, gdextension.SizeString, unsafe.Pointer(&struct{}{}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Returns the name of the type of object for the given [param type_index]. This value must be in range [code][0; get_tracked_object_type_count - 1][/code]. If [method get_tracked_object_type_count] is 0, then type argument is ignored and always returns the same string.
The return value is important because it gives meaning to the types passed to [method get_driver_memory_by_object_type], [method get_driver_allocs_by_object_type], [method get_device_memory_by_object_type], and [method get_device_allocs_by_object_type]. Examples of strings it can return (not exhaustive):
- DEVICE_MEMORY
- PIPELINE_CACHE
- SWAPCHAIN_KHR
- COMMAND_POOL
Thus if e.g. [code]get_tracked_object_name(5)[/code] returns "COMMAND_POOL", then [code]get_device_memory_by_object_type(5)[/code] returns the bytes used by the GPU for command pools.
This is only used by Vulkan in debug builds. Godot must also be started with the [code]--extra-gpu-memory-tracking[/code] [url=$DOCS_URL/tutorials/editor/command_line_tutorial.html]command line argument[/url].
*/
//go:nosplit
func (self class) GetTrackedObjectName(type_index int64) String.Readable { //gd:RenderingDevice.get_tracked_object_name
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_tracked_object_name, gdextension.SizeString|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ type_index int64 }{type_index}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Returns how many types of trackable objects are.
This is only used by Vulkan in debug builds. Godot must also be started with the [code]--extra-gpu-memory-tracking[/code] [url=$DOCS_URL/tutorials/editor/command_line_tutorial.html]command line argument[/url].
*/
//go:nosplit
func (self class) GetTrackedObjectTypeCount() int64 { //gd:RenderingDevice.get_tracked_object_type_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_tracked_object_type_count, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns how much bytes the GPU driver is using for internal driver structures.
This is only used by Vulkan in debug builds and can return 0 when this information is not tracked or unknown.
*/
//go:nosplit
func (self class) GetDriverTotalMemory() int64 { //gd:RenderingDevice.get_driver_total_memory
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_driver_total_memory, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns how many allocations the GPU driver has performed for internal driver structures.
This is only used by Vulkan in debug builds and can return 0 when this information is not tracked or unknown.
*/
//go:nosplit
func (self class) GetDriverAllocationCount() int64 { //gd:RenderingDevice.get_driver_allocation_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_driver_allocation_count, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Same as [method get_driver_total_memory] but filtered for a given object type.
The type argument must be in range [code][0; get_tracked_object_type_count - 1][/code]. If [method get_tracked_object_type_count] is 0, then type argument is ignored and always returns 0.
This is only used by Vulkan in debug builds and can return 0 when this information is not tracked or unknown.
*/
//go:nosplit
func (self class) GetDriverMemoryByObjectType(atype int64) int64 { //gd:RenderingDevice.get_driver_memory_by_object_type
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_driver_memory_by_object_type, gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ atype int64 }{atype}))
	var ret = r_ret
	return ret
}

/*
Same as [method get_driver_allocation_count] but filtered for a given object type.
The type argument must be in range [code][0; get_tracked_object_type_count - 1][/code]. If [method get_tracked_object_type_count] is 0, then type argument is ignored and always returns 0.
This is only used by Vulkan in debug builds and can return 0 when this information is not tracked or unknown.
*/
//go:nosplit
func (self class) GetDriverAllocsByObjectType(atype int64) int64 { //gd:RenderingDevice.get_driver_allocs_by_object_type
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_driver_allocs_by_object_type, gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ atype int64 }{atype}))
	var ret = r_ret
	return ret
}

/*
Returns how much bytes the GPU is using.
This is only used by Vulkan in debug builds and can return 0 when this information is not tracked or unknown.
*/
//go:nosplit
func (self class) GetDeviceTotalMemory() int64 { //gd:RenderingDevice.get_device_total_memory
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_device_total_memory, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns how many allocations the GPU has performed for internal driver structures.
This is only used by Vulkan in debug builds and can return 0 when this information is not tracked or unknown.
*/
//go:nosplit
func (self class) GetDeviceAllocationCount() int64 { //gd:RenderingDevice.get_device_allocation_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_device_allocation_count, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Same as [method get_device_total_memory] but filtered for a given object type.
The type argument must be in range [code][0; get_tracked_object_type_count - 1][/code]. If [method get_tracked_object_type_count] is 0, then type argument is ignored and always returns 0.
This is only used by Vulkan in debug builds and can return 0 when this information is not tracked or unknown.
*/
//go:nosplit
func (self class) GetDeviceMemoryByObjectType(atype int64) int64 { //gd:RenderingDevice.get_device_memory_by_object_type
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_device_memory_by_object_type, gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ atype int64 }{atype}))
	var ret = r_ret
	return ret
}

/*
Same as [method get_device_allocation_count] but filtered for a given object type.
The type argument must be in range [code][0; get_tracked_object_type_count - 1][/code]. If [method get_tracked_object_type_count] is 0, then type argument is ignored and always returns 0.
This is only used by Vulkan in debug builds and can return 0 when this information is not tracked or unknown.
*/
//go:nosplit
func (self class) GetDeviceAllocsByObjectType(atype int64) int64 { //gd:RenderingDevice.get_device_allocs_by_object_type
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_device_allocs_by_object_type, gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ atype int64 }{atype}))
	var ret = r_ret
	return ret
}
func (self class) AsRenderingDevice() Advanced         { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsRenderingDevice() Instance      { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsRenderingDevice() Instance { return self.Super().AsRenderingDevice() }

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Object.Advanced(self.AsObject()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Object.Instance(self.AsObject()), name)
	}
}
func init() {
	gdclass.Register("RenderingDevice", func(ptr gd.Object) any { return *(*Instance)(unsafe.Pointer(&ptr)) })
}

const InvalidId = -1       //gd:RenderingDevice.INVALID_ID
const InvalidFormatId = -1 //gd:RenderingDevice.INVALID_FORMAT_ID
