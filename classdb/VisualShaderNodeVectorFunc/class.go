// Code generated by the generate package DO NOT EDIT

// Package VisualShaderNodeVectorFunc provides methods for working with VisualShaderNodeVectorFunc object instances.
package VisualShaderNodeVectorFunc

import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/variant/Signal"
import "graphics.gd/classdb/Resource"
import "graphics.gd/classdb/VisualShaderNode"
import "graphics.gd/classdb/VisualShaderNodeVectorBase"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Signal.Any
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
A visual shader node able to perform different functions using vectors.
*/
type Instance [1]gdclass.VisualShaderNodeVectorFunc

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	set_function gdextension.MethodForClass `hash:"629964457"`
	get_function gdextension.MethodForClass `hash:"4047776843"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("VisualShaderNodeVectorFunc")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		gdextension.Free(gdextension.TypeStringName, &sname)
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsVisualShaderNodeVectorFunc() Instance
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.VisualShaderNodeVectorFunc

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = pointers.AsA[gdclass.VisualShaderNodeVectorFunc](obj[0])
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = pointers.AsA[gdclass.VisualShaderNodeVectorFunc](obj[0])
		return true
	}
	return false
}
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }
func (self *Extension[T]) AsObject() [1]gd.Object { return self.Super().AsObject() }
func New() Instance {
	if !gd.Linked {
		var placeholder = Instance([1]gdclass.VisualShaderNodeVectorFunc{pointers.Add[gdclass.VisualShaderNodeVectorFunc]([3]uint64{})})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(pointers.AsA[gd.Object](placeholder[0]), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	casted := Instance([1]gdclass.VisualShaderNodeVectorFunc{pointers.New[gdclass.VisualShaderNodeVectorFunc]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})})
	casted.AsRefCounted()[0].InitRef()
	casted.AsObject()[0].Notification(0, false)
	return casted
}

func (self Instance) Function() Function {
	return Function(class(self).GetFunction())
}

func (self Instance) SetFunction(value Function) {
	class(self).SetFunction(value)
}

//go:nosplit
func (self class) SetFunction(fn Function) { //gd:VisualShaderNodeVectorFunc.set_function
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_function, 0|(gdextension.SizeInt<<4), &struct{ fn Function }{fn})
}

//go:nosplit
func (self class) GetFunction() Function { //gd:VisualShaderNodeVectorFunc.get_function
	var r_ret = gdextension.Call[Function](gd.ObjectChecked(self.AsObject()), methods.get_function, gdextension.SizeInt, &struct{}{})
	var ret = r_ret
	return ret
}
func (self class) AsVisualShaderNodeVectorFunc() Advanced {
	return Advanced{pointers.AsA[gdclass.VisualShaderNodeVectorFunc](self[0])}
}
func (self Instance) AsVisualShaderNodeVectorFunc() Instance {
	return Instance{pointers.AsA[gdclass.VisualShaderNodeVectorFunc](self[0])}
}
func (self *Extension[T]) AsVisualShaderNodeVectorFunc() Instance {
	return self.Super().AsVisualShaderNodeVectorFunc()
}
func (self class) AsVisualShaderNodeVectorBase() VisualShaderNodeVectorBase.Advanced {
	return VisualShaderNodeVectorBase.Advanced{pointers.AsA[gdclass.VisualShaderNodeVectorBase](self[0])}
}
func (self *Extension[T]) AsVisualShaderNodeVectorBase() VisualShaderNodeVectorBase.Instance {
	return self.Super().AsVisualShaderNodeVectorBase()
}
func (self Instance) AsVisualShaderNodeVectorBase() VisualShaderNodeVectorBase.Instance {
	return VisualShaderNodeVectorBase.Instance{pointers.AsA[gdclass.VisualShaderNodeVectorBase](self[0])}
}
func (self class) AsVisualShaderNode() VisualShaderNode.Advanced {
	return VisualShaderNode.Advanced{pointers.AsA[gdclass.VisualShaderNode](self[0])}
}
func (self *Extension[T]) AsVisualShaderNode() VisualShaderNode.Instance {
	return self.Super().AsVisualShaderNode()
}
func (self Instance) AsVisualShaderNode() VisualShaderNode.Instance {
	return VisualShaderNode.Instance{pointers.AsA[gdclass.VisualShaderNode](self[0])}
}
func (self class) AsResource() Resource.Advanced {
	return Resource.Advanced{pointers.AsA[gdclass.Resource](self[0])}
}
func (self *Extension[T]) AsResource() Resource.Instance { return self.Super().AsResource() }
func (self Instance) AsResource() Resource.Instance {
	return Resource.Instance{pointers.AsA[gdclass.Resource](self[0])}
}
func (self class) AsRefCounted() [1]gd.RefCounted {
	return [1]gd.RefCounted{gd.RefCounted(pointers.AsA[gd.Object](self[0]))}
}
func (self *Extension[T]) AsRefCounted() [1]gd.RefCounted { return self.Super().AsRefCounted() }
func (self Instance) AsRefCounted() [1]gd.RefCounted {
	return [1]gd.RefCounted{gd.RefCounted(pointers.AsA[gd.Object](self[0]))}
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(VisualShaderNodeVectorBase.Advanced(self.AsVisualShaderNodeVectorBase()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(VisualShaderNodeVectorBase.Instance(self.AsVisualShaderNodeVectorBase()), name)
	}
}
func init() {
	gdclass.Register("VisualShaderNodeVectorFunc", func(ptr gd.Object) any { return Instance{pointers.AsA[gdclass.VisualShaderNodeVectorFunc](ptr)} })
}

type Function int //gd:VisualShaderNodeVectorFunc.Function

const (
	/*Normalizes the vector so that it has a length of [code]1[/code] but points in the same direction.*/
	FuncNormalize Function = 0
	/*Clamps the value between [code]0.0[/code] and [code]1.0[/code].*/
	FuncSaturate Function = 1
	/*Returns the opposite value of the parameter.*/
	FuncNegate Function = 2
	/*Returns [code]1/vector[/code].*/
	FuncReciprocal Function = 3
	/*Returns the absolute value of the parameter.*/
	FuncAbs Function = 4
	/*Returns the arc-cosine of the parameter.*/
	FuncAcos Function = 5
	/*Returns the inverse hyperbolic cosine of the parameter.*/
	FuncAcosh Function = 6
	/*Returns the arc-sine of the parameter.*/
	FuncAsin Function = 7
	/*Returns the inverse hyperbolic sine of the parameter.*/
	FuncAsinh Function = 8
	/*Returns the arc-tangent of the parameter.*/
	FuncAtan Function = 9
	/*Returns the inverse hyperbolic tangent of the parameter.*/
	FuncAtanh Function = 10
	/*Finds the nearest integer that is greater than or equal to the parameter.*/
	FuncCeil Function = 11
	/*Returns the cosine of the parameter.*/
	FuncCos Function = 12
	/*Returns the hyperbolic cosine of the parameter.*/
	FuncCosh Function = 13
	/*Converts a quantity in radians to degrees.*/
	FuncDegrees Function = 14
	/*Base-e Exponential.*/
	FuncExp Function = 15
	/*Base-2 Exponential.*/
	FuncExp2 Function = 16
	/*Finds the nearest integer less than or equal to the parameter.*/
	FuncFloor Function = 17
	/*Computes the fractional part of the argument.*/
	FuncFract Function = 18
	/*Returns the inverse of the square root of the parameter.*/
	FuncInverseSqrt Function = 19
	/*Natural logarithm.*/
	FuncLog Function = 20
	/*Base-2 logarithm.*/
	FuncLog2 Function = 21
	/*Converts a quantity in degrees to radians.*/
	FuncRadians Function = 22
	/*Finds the nearest integer to the parameter.*/
	FuncRound Function = 23
	/*Finds the nearest even integer to the parameter.*/
	FuncRoundeven Function = 24
	/*Extracts the sign of the parameter, i.e. returns [code]-1[/code] if the parameter is negative, [code]1[/code] if it's positive and [code]0[/code] otherwise.*/
	FuncSign Function = 25
	/*Returns the sine of the parameter.*/
	FuncSin Function = 26
	/*Returns the hyperbolic sine of the parameter.*/
	FuncSinh Function = 27
	/*Returns the square root of the parameter.*/
	FuncSqrt Function = 28
	/*Returns the tangent of the parameter.*/
	FuncTan Function = 29
	/*Returns the hyperbolic tangent of the parameter.*/
	FuncTanh Function = 30
	/*Returns a value equal to the nearest integer to the parameter whose absolute value is not larger than the absolute value of the parameter.*/
	FuncTrunc Function = 31
	/*Returns [code]1.0 - vector[/code].*/
	FuncOneminus Function = 32
	/*Represents the size of the [enum Function] enum.*/
	FuncMax Function = 33
)
