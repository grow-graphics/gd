// Code generated by the generate package DO NOT EDIT

// Package FoldableContainer provides methods for working with FoldableContainer object instances.
package FoldableContainer

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/CanvasItem"
import "graphics.gd/classdb/Container"
import "graphics.gd/classdb/Control"
import "graphics.gd/classdb/GUI"
import "graphics.gd/classdb/Node"
import "graphics.gd/classdb/TextServer"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
A container that can be expanded/collapsed, with a title that can be filled with controls, such as buttons.
The title can be positioned at the top or bottom of the container.
The container can be expanded or collapsed by clicking the title or by pressing [code]ui_accept[/code] when focused.
Child control nodes are hidden when the container is collapsed. Ignores non-control children.
Can allow grouping with other FoldableContainers, check [member foldable_group] and [FoldableGroup].
*/
type Instance [1]gdclass.FoldableContainer

func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsFoldableContainer() Instance
}

/*
Folds the container and emits [signal folding_changed].
*/
func (self Instance) Fold() { //gd:FoldableContainer.fold
	Advanced(self).Fold()
}

/*
Expands the container and emits [signal folding_changed].
*/
func (self Instance) Expand() { //gd:FoldableContainer.expand
	Advanced(self).Expand()
}

/*
Adds a [Control] that will be placed next to the container's title, obscuring the clickable area. Prime usage is adding [Button] nodes, but it can be any [Control].
The control will be added as a child of this container and removed from previous parent if necessary. The controls will be placed aligned to the right, with the first added control being the leftmost one.
*/
func (self Instance) AddTitleBarControl(control Control.Instance) { //gd:FoldableContainer.add_title_bar_control
	Advanced(self).AddTitleBarControl(control)
}

/*
Removes a [Control] added with [method add_title_bar_control]. The node is not freed automatically, you need to use [method Node.queue_free].
*/
func (self Instance) RemoveTitleBarControl(control Control.Instance) { //gd:FoldableContainer.remove_title_bar_control
	Advanced(self).RemoveTitleBarControl(control)
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.FoldableContainer

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {
	object := gd.Global.ClassDB.ConstructObject(gd.NewStringName("FoldableContainer"))
	casted := Instance{*(*gdclass.FoldableContainer)(unsafe.Pointer(&object))}
	return casted
}

func (self Instance) Folded() bool {
	return bool(class(self).IsFolded())
}

func (self Instance) SetFolded(value bool) {
	class(self).SetFolded(value)
}

func (self Instance) Text() string {
	return string(class(self).GetText().String())
}

func (self Instance) SetText(value string) {
	class(self).SetText(String.New(value))
}

func (self Instance) TitleAlignment() GUI.HorizontalAlignment {
	return GUI.HorizontalAlignment(class(self).GetTitleAlignment())
}

func (self Instance) SetTitleAlignment(value GUI.HorizontalAlignment) {
	class(self).SetTitleAlignment(value)
}

func (self Instance) TitlePosition() TitlePosition {
	return TitlePosition(class(self).GetTitlePosition())
}

func (self Instance) SetTitlePosition(value TitlePosition) {
	class(self).SetTitlePosition(value)
}

func (self Instance) TextOverrunBehavior() TextServer.OverrunBehavior {
	return TextServer.OverrunBehavior(class(self).GetTextOverrunBehavior())
}

func (self Instance) SetTextOverrunBehavior(value TextServer.OverrunBehavior) {
	class(self).SetTextOverrunBehavior(value)
}

func (self Instance) TextDirection() Control.TextDirection {
	return Control.TextDirection(class(self).GetTextDirection())
}

func (self Instance) SetTextDirection(value Control.TextDirection) {
	class(self).SetTextDirection(value)
}

func (self Instance) Language() string {
	return string(class(self).GetLanguage().String())
}

func (self Instance) SetLanguage(value string) {
	class(self).SetLanguage(String.New(value))
}

/*
Folds the container and emits [signal folding_changed].
*/
//go:nosplit
func (self class) Fold() { //gd:FoldableContainer.fold
	var frame = callframe.New()
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.FoldableContainer.Bind_fold, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Expands the container and emits [signal folding_changed].
*/
//go:nosplit
func (self class) Expand() { //gd:FoldableContainer.expand
	var frame = callframe.New()
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.FoldableContainer.Bind_expand, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) SetFolded(folded bool) { //gd:FoldableContainer.set_folded
	var frame = callframe.New()
	callframe.Arg(frame, folded)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.FoldableContainer.Bind_set_folded, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) IsFolded() bool { //gd:FoldableContainer.is_folded
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.FoldableContainer.Bind_is_folded, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

//go:nosplit
func (self class) SetFoldableGroup(button_group [1]gdclass.FoldableGroup) { //gd:FoldableContainer.set_foldable_group
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(button_group[0])[0])
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.FoldableContainer.Bind_set_foldable_group, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) GetFoldableGroup() [1]gdclass.FoldableGroup { //gd:FoldableContainer.get_foldable_group
	var frame = callframe.New()
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.FoldableContainer.Bind_get_foldable_group, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.FoldableGroup{gd.PointerWithOwnershipTransferredToGo[gdclass.FoldableGroup](r_ret.Get())}
	frame.Free()
	return ret
}

//go:nosplit
func (self class) SetText(text String.Readable) { //gd:FoldableContainer.set_text
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(text)))
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.FoldableContainer.Bind_set_text, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) GetText() String.Readable { //gd:FoldableContainer.get_text
	var frame = callframe.New()
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.FoldableContainer.Bind_get_text, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

//go:nosplit
func (self class) SetTitleAlignment(alignment GUI.HorizontalAlignment) { //gd:FoldableContainer.set_title_alignment
	var frame = callframe.New()
	callframe.Arg(frame, alignment)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.FoldableContainer.Bind_set_title_alignment, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) GetTitleAlignment() GUI.HorizontalAlignment { //gd:FoldableContainer.get_title_alignment
	var frame = callframe.New()
	var r_ret = callframe.Ret[GUI.HorizontalAlignment](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.FoldableContainer.Bind_get_title_alignment, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

//go:nosplit
func (self class) SetLanguage(language String.Readable) { //gd:FoldableContainer.set_language
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(language)))
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.FoldableContainer.Bind_set_language, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) GetLanguage() String.Readable { //gd:FoldableContainer.get_language
	var frame = callframe.New()
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.FoldableContainer.Bind_get_language, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

//go:nosplit
func (self class) SetTextDirection(text_direction Control.TextDirection) { //gd:FoldableContainer.set_text_direction
	var frame = callframe.New()
	callframe.Arg(frame, text_direction)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.FoldableContainer.Bind_set_text_direction, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) GetTextDirection() Control.TextDirection { //gd:FoldableContainer.get_text_direction
	var frame = callframe.New()
	var r_ret = callframe.Ret[Control.TextDirection](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.FoldableContainer.Bind_get_text_direction, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

//go:nosplit
func (self class) SetTextOverrunBehavior(overrun_behavior TextServer.OverrunBehavior) { //gd:FoldableContainer.set_text_overrun_behavior
	var frame = callframe.New()
	callframe.Arg(frame, overrun_behavior)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.FoldableContainer.Bind_set_text_overrun_behavior, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) GetTextOverrunBehavior() TextServer.OverrunBehavior { //gd:FoldableContainer.get_text_overrun_behavior
	var frame = callframe.New()
	var r_ret = callframe.Ret[TextServer.OverrunBehavior](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.FoldableContainer.Bind_get_text_overrun_behavior, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

//go:nosplit
func (self class) SetTitlePosition(title_position TitlePosition) { //gd:FoldableContainer.set_title_position
	var frame = callframe.New()
	callframe.Arg(frame, title_position)
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.FoldableContainer.Bind_set_title_position, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) GetTitlePosition() TitlePosition { //gd:FoldableContainer.get_title_position
	var frame = callframe.New()
	var r_ret = callframe.Ret[TitlePosition](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.FoldableContainer.Bind_get_title_position, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

/*
Adds a [Control] that will be placed next to the container's title, obscuring the clickable area. Prime usage is adding [Button] nodes, but it can be any [Control].
The control will be added as a child of this container and removed from previous parent if necessary. The controls will be placed aligned to the right, with the first added control being the leftmost one.
*/
//go:nosplit
func (self class) AddTitleBarControl(control [1]gdclass.Control) { //gd:FoldableContainer.add_title_bar_control
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(control[0])[0])
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.FoldableContainer.Bind_add_title_bar_control, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Removes a [Control] added with [method add_title_bar_control]. The node is not freed automatically, you need to use [method Node.queue_free].
*/
//go:nosplit
func (self class) RemoveTitleBarControl(control [1]gdclass.Control) { //gd:FoldableContainer.remove_title_bar_control
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(control[0])[0])
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.FoldableContainer.Bind_remove_title_bar_control, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}
func (self Instance) OnFoldingChanged(cb func(is_folded bool)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("folding_changed"), gd.NewCallable(cb), 0)
}

func (self class) AsFoldableContainer() Advanced         { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsFoldableContainer() Instance      { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsFoldableContainer() Instance { return self.Super().AsFoldableContainer() }
func (self class) AsContainer() Container.Advanced {
	return *((*Container.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsContainer() Container.Instance { return self.Super().AsContainer() }
func (self Instance) AsContainer() Container.Instance {
	return *((*Container.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsControl() Control.Advanced         { return *((*Control.Advanced)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsControl() Control.Instance { return self.Super().AsControl() }
func (self Instance) AsControl() Control.Instance {
	return *((*Control.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsCanvasItem() CanvasItem.Advanced {
	return *((*CanvasItem.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsCanvasItem() CanvasItem.Instance { return self.Super().AsCanvasItem() }
func (self Instance) AsCanvasItem() CanvasItem.Instance {
	return *((*CanvasItem.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsNode() Node.Advanced         { return *((*Node.Advanced)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsNode() Node.Instance { return self.Super().AsNode() }
func (self Instance) AsNode() Node.Instance      { return *((*Node.Instance)(unsafe.Pointer(&self))) }

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Container.Advanced(self.AsContainer()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Container.Instance(self.AsContainer()), name)
	}
}
func init() {
	gdclass.Register("FoldableContainer", func(ptr gd.Object) any {
		return [1]gdclass.FoldableContainer{*(*gdclass.FoldableContainer)(unsafe.Pointer(&ptr))}
	})
}

type TitlePosition int //gd:FoldableContainer.TitlePosition

const (
	/*Makes the title appear at the top of the container.*/
	PositionTop TitlePosition = 0
	/*Makes the title appear at the bottom of the container. Also makes all StyleBoxes flipped vertically.*/
	PositionBottom TitlePosition = 1
)
