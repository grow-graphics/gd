// Code generated by the generate package DO NOT EDIT

// Package Curve provides methods for working with Curve object instances.
package Curve

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/Resource"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"
import "graphics.gd/variant/Vector2"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
This resource describes a mathematical curve by defining a set of points and tangents at each point. By default, it ranges between [code]0[/code] and [code]1[/code] on the X and Y axes, but these ranges can be changed.
Please note that many resources and nodes assume they are given [i]unit curves[/i]. A unit curve is a curve whose domain (the X axis) is between [code]0[/code] and [code]1[/code]. Some examples of unit curve usage are [member CPUParticles2D.angle_curve] and [member Line2D.width_curve].
*/
type Instance [1]gdclass.Curve

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	get_point_count         gdextension.MethodForClass `hash:"3905245786"`
	set_point_count         gdextension.MethodForClass `hash:"1286410249"`
	add_point               gdextension.MethodForClass `hash:"434072736"`
	remove_point            gdextension.MethodForClass `hash:"1286410249"`
	clear_points            gdextension.MethodForClass `hash:"3218959716"`
	get_point_position      gdextension.MethodForClass `hash:"2299179447"`
	set_point_value         gdextension.MethodForClass `hash:"1602489585"`
	set_point_offset        gdextension.MethodForClass `hash:"3780573764"`
	sample                  gdextension.MethodForClass `hash:"3919130443"`
	sample_baked            gdextension.MethodForClass `hash:"3919130443"`
	get_point_left_tangent  gdextension.MethodForClass `hash:"2339986948"`
	get_point_right_tangent gdextension.MethodForClass `hash:"2339986948"`
	get_point_left_mode     gdextension.MethodForClass `hash:"426950354"`
	get_point_right_mode    gdextension.MethodForClass `hash:"426950354"`
	set_point_left_tangent  gdextension.MethodForClass `hash:"1602489585"`
	set_point_right_tangent gdextension.MethodForClass `hash:"1602489585"`
	set_point_left_mode     gdextension.MethodForClass `hash:"1217242874"`
	set_point_right_mode    gdextension.MethodForClass `hash:"1217242874"`
	get_min_value           gdextension.MethodForClass `hash:"1740695150"`
	set_min_value           gdextension.MethodForClass `hash:"373806689"`
	get_max_value           gdextension.MethodForClass `hash:"1740695150"`
	set_max_value           gdextension.MethodForClass `hash:"373806689"`
	get_value_range         gdextension.MethodForClass `hash:"1740695150"`
	get_min_domain          gdextension.MethodForClass `hash:"1740695150"`
	set_min_domain          gdextension.MethodForClass `hash:"373806689"`
	get_max_domain          gdextension.MethodForClass `hash:"1740695150"`
	set_max_domain          gdextension.MethodForClass `hash:"373806689"`
	get_domain_range        gdextension.MethodForClass `hash:"1740695150"`
	clean_dupes             gdextension.MethodForClass `hash:"3218959716"`
	bake                    gdextension.MethodForClass `hash:"3218959716"`
	get_bake_resolution     gdextension.MethodForClass `hash:"3905245786"`
	set_bake_resolution     gdextension.MethodForClass `hash:"1286410249"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("Curve")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		gdextension.Free(gdextension.TypeStringName, &sname)
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

type Expanded [1]gdclass.Curve

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsCurve() Instance
}

/*
Adds a point to the curve. For each side, if the [code]*_mode[/code] is [constant TANGENT_LINEAR], the [code]*_tangent[/code] angle (in degrees) uses the slope of the curve halfway to the adjacent point. Allows custom assignments to the [code]*_tangent[/code] angle if [code]*_mode[/code] is set to [constant TANGENT_FREE].
*/
func (self Instance) AddPoint(position Vector2.XY) int { //gd:Curve.add_point
	return int(int(Advanced(self).AddPoint(Vector2.XY(position), float64(0), float64(0), 0, 0)))
}

/*
Adds a point to the curve. For each side, if the [code]*_mode[/code] is [constant TANGENT_LINEAR], the [code]*_tangent[/code] angle (in degrees) uses the slope of the curve halfway to the adjacent point. Allows custom assignments to the [code]*_tangent[/code] angle if [code]*_mode[/code] is set to [constant TANGENT_FREE].
*/
func (self Expanded) AddPoint(position Vector2.XY, left_tangent Float.X, right_tangent Float.X, left_mode TangentMode, right_mode TangentMode) int { //gd:Curve.add_point
	return int(int(Advanced(self).AddPoint(Vector2.XY(position), float64(left_tangent), float64(right_tangent), left_mode, right_mode)))
}

/*
Removes the point at [param index] from the curve.
*/
func (self Instance) RemovePoint(index int) { //gd:Curve.remove_point
	Advanced(self).RemovePoint(int64(index))
}

/*
Removes all points from the curve.
*/
func (self Instance) ClearPoints() { //gd:Curve.clear_points
	Advanced(self).ClearPoints()
}

/*
Returns the curve coordinates for the point at [param index].
*/
func (self Instance) GetPointPosition(index int) Vector2.XY { //gd:Curve.get_point_position
	return Vector2.XY(Advanced(self).GetPointPosition(int64(index)))
}

/*
Assigns the vertical position [param y] to the point at [param index].
*/
func (self Instance) SetPointValue(index int, y Float.X) { //gd:Curve.set_point_value
	Advanced(self).SetPointValue(int64(index), float64(y))
}

/*
Sets the offset from [code]0.5[/code].
*/
func (self Instance) SetPointOffset(index int, offset Float.X) int { //gd:Curve.set_point_offset
	return int(int(Advanced(self).SetPointOffset(int64(index), float64(offset))))
}

/*
Returns the Y value for the point that would exist at the X position [param offset] along the curve.
*/
func (self Instance) Sample(offset Float.X) Float.X { //gd:Curve.sample
	return Float.X(Float.X(Advanced(self).Sample(float64(offset))))
}

/*
Returns the Y value for the point that would exist at the X position [param offset] along the curve using the baked cache. Bakes the curve's points if not already baked.
*/
func (self Instance) SampleBaked(offset Float.X) Float.X { //gd:Curve.sample_baked
	return Float.X(Float.X(Advanced(self).SampleBaked(float64(offset))))
}

/*
Returns the left tangent angle (in degrees) for the point at [param index].
*/
func (self Instance) GetPointLeftTangent(index int) Float.X { //gd:Curve.get_point_left_tangent
	return Float.X(Float.X(Advanced(self).GetPointLeftTangent(int64(index))))
}

/*
Returns the right tangent angle (in degrees) for the point at [param index].
*/
func (self Instance) GetPointRightTangent(index int) Float.X { //gd:Curve.get_point_right_tangent
	return Float.X(Float.X(Advanced(self).GetPointRightTangent(int64(index))))
}

/*
Returns the left [enum TangentMode] for the point at [param index].
*/
func (self Instance) GetPointLeftMode(index int) TangentMode { //gd:Curve.get_point_left_mode
	return TangentMode(Advanced(self).GetPointLeftMode(int64(index)))
}

/*
Returns the right [enum TangentMode] for the point at [param index].
*/
func (self Instance) GetPointRightMode(index int) TangentMode { //gd:Curve.get_point_right_mode
	return TangentMode(Advanced(self).GetPointRightMode(int64(index)))
}

/*
Sets the left tangent angle for the point at [param index] to [param tangent].
*/
func (self Instance) SetPointLeftTangent(index int, tangent Float.X) { //gd:Curve.set_point_left_tangent
	Advanced(self).SetPointLeftTangent(int64(index), float64(tangent))
}

/*
Sets the right tangent angle for the point at [param index] to [param tangent].
*/
func (self Instance) SetPointRightTangent(index int, tangent Float.X) { //gd:Curve.set_point_right_tangent
	Advanced(self).SetPointRightTangent(int64(index), float64(tangent))
}

/*
Sets the left [enum TangentMode] for the point at [param index] to [param mode].
*/
func (self Instance) SetPointLeftMode(index int, mode TangentMode) { //gd:Curve.set_point_left_mode
	Advanced(self).SetPointLeftMode(int64(index), mode)
}

/*
Sets the right [enum TangentMode] for the point at [param index] to [param mode].
*/
func (self Instance) SetPointRightMode(index int, mode TangentMode) { //gd:Curve.set_point_right_mode
	Advanced(self).SetPointRightMode(int64(index), mode)
}

/*
Returns the difference between [member min_value] and [member max_value].
*/
func (self Instance) GetValueRange() Float.X { //gd:Curve.get_value_range
	return Float.X(Float.X(Advanced(self).GetValueRange()))
}

/*
Returns the difference between [member min_domain] and [member max_domain].
*/
func (self Instance) GetDomainRange() Float.X { //gd:Curve.get_domain_range
	return Float.X(Float.X(Advanced(self).GetDomainRange()))
}

/*
Removes duplicate points, i.e. points that are less than 0.00001 units (engine epsilon value) away from their neighbor on the curve.
*/
func (self Instance) CleanDupes() { //gd:Curve.clean_dupes
	Advanced(self).CleanDupes()
}

/*
Recomputes the baked cache of points for the curve.
*/
func (self Instance) Bake() { //gd:Curve.bake
	Advanced(self).Bake()
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.Curve

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.Curve)(unsafe.Pointer(&obj))
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.Curve)(unsafe.Pointer(&obj))
		return true
	}
	return false
}

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {

	if !gd.Linked {
		var placeholder Instance
		*(*gd.Object)(unsafe.Pointer(&placeholder)) = pointers.Add[gd.Object]([3]uint64{})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(*(*gd.Object)(unsafe.Pointer(&placeholder)), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	object := [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})}
	casted := Instance{*(*gdclass.Curve)(unsafe.Pointer(&object))}
	object[0].Notification(0, false)
	return casted
}

func (self Instance) MinDomain() Float.X {
	return Float.X(Float.X(class(self).GetMinDomain()))
}

func (self Instance) SetMinDomain(value Float.X) {
	class(self).SetMinDomain(float64(value))
}

func (self Instance) MaxDomain() Float.X {
	return Float.X(Float.X(class(self).GetMaxDomain()))
}

func (self Instance) SetMaxDomain(value Float.X) {
	class(self).SetMaxDomain(float64(value))
}

func (self Instance) MinValue() Float.X {
	return Float.X(Float.X(class(self).GetMinValue()))
}

func (self Instance) SetMinValue(value Float.X) {
	class(self).SetMinValue(float64(value))
}

func (self Instance) MaxValue() Float.X {
	return Float.X(Float.X(class(self).GetMaxValue()))
}

func (self Instance) SetMaxValue(value Float.X) {
	class(self).SetMaxValue(float64(value))
}

func (self Instance) BakeResolution() int {
	return int(int(class(self).GetBakeResolution()))
}

func (self Instance) SetBakeResolution(value int) {
	class(self).SetBakeResolution(int64(value))
}

func (self Instance) PointCount() int {
	return int(int(class(self).GetPointCount()))
}

func (self Instance) SetPointCount(value int) {
	class(self).SetPointCount(int64(value))
}

//go:nosplit
func (self class) GetPointCount() int64 { //gd:Curve.get_point_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_point_count, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetPointCount(count int64) { //gd:Curve.set_point_count
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_point_count, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ count int64 }{count}))
}

/*
Adds a point to the curve. For each side, if the [code]*_mode[/code] is [constant TANGENT_LINEAR], the [code]*_tangent[/code] angle (in degrees) uses the slope of the curve halfway to the adjacent point. Allows custom assignments to the [code]*_tangent[/code] angle if [code]*_mode[/code] is set to [constant TANGENT_FREE].
*/
//go:nosplit
func (self class) AddPoint(position Vector2.XY, left_tangent float64, right_tangent float64, left_mode TangentMode, right_mode TangentMode) int64 { //gd:Curve.add_point
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.add_point, gdextension.SizeInt|(gdextension.SizeVector2<<4)|(gdextension.SizeFloat<<8)|(gdextension.SizeFloat<<12)|(gdextension.SizeInt<<16)|(gdextension.SizeInt<<20), unsafe.Pointer(&struct {
		position      Vector2.XY
		left_tangent  float64
		right_tangent float64
		left_mode     TangentMode
		right_mode    TangentMode
	}{position, left_tangent, right_tangent, left_mode, right_mode}))
	var ret = r_ret
	return ret
}

/*
Removes the point at [param index] from the curve.
*/
//go:nosplit
func (self class) RemovePoint(index int64) { //gd:Curve.remove_point
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.remove_point, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ index int64 }{index}))
}

/*
Removes all points from the curve.
*/
//go:nosplit
func (self class) ClearPoints() { //gd:Curve.clear_points
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.clear_points, 0, unsafe.Pointer(&struct{}{}))
}

/*
Returns the curve coordinates for the point at [param index].
*/
//go:nosplit
func (self class) GetPointPosition(index int64) Vector2.XY { //gd:Curve.get_point_position
	var r_ret = gdextension.Call[Vector2.XY](gd.ObjectChecked(self.AsObject()), methods.get_point_position, gdextension.SizeVector2|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ index int64 }{index}))
	var ret = r_ret
	return ret
}

/*
Assigns the vertical position [param y] to the point at [param index].
*/
//go:nosplit
func (self class) SetPointValue(index int64, y float64) { //gd:Curve.set_point_value
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_point_value, 0|(gdextension.SizeInt<<4)|(gdextension.SizeFloat<<8), unsafe.Pointer(&struct {
		index int64
		y     float64
	}{index, y}))
}

/*
Sets the offset from [code]0.5[/code].
*/
//go:nosplit
func (self class) SetPointOffset(index int64, offset float64) int64 { //gd:Curve.set_point_offset
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.set_point_offset, gdextension.SizeInt|(gdextension.SizeInt<<4)|(gdextension.SizeFloat<<8), unsafe.Pointer(&struct {
		index  int64
		offset float64
	}{index, offset}))
	var ret = r_ret
	return ret
}

/*
Returns the Y value for the point that would exist at the X position [param offset] along the curve.
*/
//go:nosplit
func (self class) Sample(offset float64) float64 { //gd:Curve.sample
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.sample, gdextension.SizeFloat|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ offset float64 }{offset}))
	var ret = r_ret
	return ret
}

/*
Returns the Y value for the point that would exist at the X position [param offset] along the curve using the baked cache. Bakes the curve's points if not already baked.
*/
//go:nosplit
func (self class) SampleBaked(offset float64) float64 { //gd:Curve.sample_baked
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.sample_baked, gdextension.SizeFloat|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ offset float64 }{offset}))
	var ret = r_ret
	return ret
}

/*
Returns the left tangent angle (in degrees) for the point at [param index].
*/
//go:nosplit
func (self class) GetPointLeftTangent(index int64) float64 { //gd:Curve.get_point_left_tangent
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_point_left_tangent, gdextension.SizeFloat|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ index int64 }{index}))
	var ret = r_ret
	return ret
}

/*
Returns the right tangent angle (in degrees) for the point at [param index].
*/
//go:nosplit
func (self class) GetPointRightTangent(index int64) float64 { //gd:Curve.get_point_right_tangent
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_point_right_tangent, gdextension.SizeFloat|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ index int64 }{index}))
	var ret = r_ret
	return ret
}

/*
Returns the left [enum TangentMode] for the point at [param index].
*/
//go:nosplit
func (self class) GetPointLeftMode(index int64) TangentMode { //gd:Curve.get_point_left_mode
	var r_ret = gdextension.Call[TangentMode](gd.ObjectChecked(self.AsObject()), methods.get_point_left_mode, gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ index int64 }{index}))
	var ret = r_ret
	return ret
}

/*
Returns the right [enum TangentMode] for the point at [param index].
*/
//go:nosplit
func (self class) GetPointRightMode(index int64) TangentMode { //gd:Curve.get_point_right_mode
	var r_ret = gdextension.Call[TangentMode](gd.ObjectChecked(self.AsObject()), methods.get_point_right_mode, gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ index int64 }{index}))
	var ret = r_ret
	return ret
}

/*
Sets the left tangent angle for the point at [param index] to [param tangent].
*/
//go:nosplit
func (self class) SetPointLeftTangent(index int64, tangent float64) { //gd:Curve.set_point_left_tangent
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_point_left_tangent, 0|(gdextension.SizeInt<<4)|(gdextension.SizeFloat<<8), unsafe.Pointer(&struct {
		index   int64
		tangent float64
	}{index, tangent}))
}

/*
Sets the right tangent angle for the point at [param index] to [param tangent].
*/
//go:nosplit
func (self class) SetPointRightTangent(index int64, tangent float64) { //gd:Curve.set_point_right_tangent
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_point_right_tangent, 0|(gdextension.SizeInt<<4)|(gdextension.SizeFloat<<8), unsafe.Pointer(&struct {
		index   int64
		tangent float64
	}{index, tangent}))
}

/*
Sets the left [enum TangentMode] for the point at [param index] to [param mode].
*/
//go:nosplit
func (self class) SetPointLeftMode(index int64, mode TangentMode) { //gd:Curve.set_point_left_mode
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_point_left_mode, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		index int64
		mode  TangentMode
	}{index, mode}))
}

/*
Sets the right [enum TangentMode] for the point at [param index] to [param mode].
*/
//go:nosplit
func (self class) SetPointRightMode(index int64, mode TangentMode) { //gd:Curve.set_point_right_mode
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_point_right_mode, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		index int64
		mode  TangentMode
	}{index, mode}))
}

//go:nosplit
func (self class) GetMinValue() float64 { //gd:Curve.get_min_value
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_min_value, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetMinValue(min float64) { //gd:Curve.set_min_value
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_min_value, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ min float64 }{min}))
}

//go:nosplit
func (self class) GetMaxValue() float64 { //gd:Curve.get_max_value
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_max_value, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetMaxValue(max float64) { //gd:Curve.set_max_value
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_max_value, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ max float64 }{max}))
}

/*
Returns the difference between [member min_value] and [member max_value].
*/
//go:nosplit
func (self class) GetValueRange() float64 { //gd:Curve.get_value_range
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_value_range, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) GetMinDomain() float64 { //gd:Curve.get_min_domain
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_min_domain, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetMinDomain(min float64) { //gd:Curve.set_min_domain
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_min_domain, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ min float64 }{min}))
}

//go:nosplit
func (self class) GetMaxDomain() float64 { //gd:Curve.get_max_domain
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_max_domain, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetMaxDomain(max float64) { //gd:Curve.set_max_domain
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_max_domain, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ max float64 }{max}))
}

/*
Returns the difference between [member min_domain] and [member max_domain].
*/
//go:nosplit
func (self class) GetDomainRange() float64 { //gd:Curve.get_domain_range
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_domain_range, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Removes duplicate points, i.e. points that are less than 0.00001 units (engine epsilon value) away from their neighbor on the curve.
*/
//go:nosplit
func (self class) CleanDupes() { //gd:Curve.clean_dupes
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.clean_dupes, 0, unsafe.Pointer(&struct{}{}))
}

/*
Recomputes the baked cache of points for the curve.
*/
//go:nosplit
func (self class) Bake() { //gd:Curve.bake
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.bake, 0, unsafe.Pointer(&struct{}{}))
}

//go:nosplit
func (self class) GetBakeResolution() int64 { //gd:Curve.get_bake_resolution
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_bake_resolution, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetBakeResolution(resolution int64) { //gd:Curve.set_bake_resolution
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_bake_resolution, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ resolution int64 }{resolution}))
}
func (self Instance) OnRangeChanged(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("range_changed"), gd.NewCallable(cb), 0)
}

func (self Instance) OnDomainChanged(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("domain_changed"), gd.NewCallable(cb), 0)
}

func (self class) AsCurve() Advanced         { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsCurve() Instance      { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsCurve() Instance { return self.Super().AsCurve() }
func (self class) AsResource() Resource.Advanced {
	return *((*Resource.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsResource() Resource.Instance { return self.Super().AsResource() }
func (self Instance) AsResource() Resource.Instance {
	return *((*Resource.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsRefCounted() [1]gd.RefCounted { return self.Super().AsRefCounted() }
func (self Instance) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Resource.Advanced(self.AsResource()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Resource.Instance(self.AsResource()), name)
	}
}
func init() {
	gdclass.Register("Curve", func(ptr gd.Object) any { return *(*Instance)(unsafe.Pointer(&ptr)) })
}

type TangentMode int //gd:Curve.TangentMode

const (
	/*The tangent on this side of the point is user-defined.*/
	TangentFree TangentMode = 0
	/*The curve calculates the tangent on this side of the point as the slope halfway towards the adjacent point.*/
	TangentLinear TangentMode = 1
	/*The total number of available tangent modes.*/
	TangentModeCount TangentMode = 2
)
