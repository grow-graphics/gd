// Code generated by the generate package DO NOT EDIT

// Package EditorVCSInterface provides methods for working with EditorVCSInterface object instances.
package EditorVCSInterface

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/variant/Signal"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Signal.Any
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
Defines the API that the editor uses to extract information from the underlying VCS. The implementation of this API is included in VCS plugins, which are GDExtension plugins that inherit [EditorVCSInterface] and are attached (on demand) to the singleton instance of [EditorVCSInterface]. Instead of performing the task themselves, all the virtual functions listed below are calling the internally overridden functions in the VCS plugins to provide a plug-n-play experience. A custom VCS plugin is supposed to inherit from [EditorVCSInterface] and override each of these virtual functions.

	See [Interface] for methods that can be overridden by a [Class] that extends it.
*/
type Instance [1]gdclass.EditorVCSInterface

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	create_diff_line              gdextension.MethodForClass `hash:"2901184053"`
	create_diff_hunk              gdextension.MethodForClass `hash:"3784842090"`
	create_diff_file              gdextension.MethodForClass `hash:"2723227684"`
	create_commit                 gdextension.MethodForClass `hash:"1075983584"`
	create_status_file            gdextension.MethodForClass `hash:"1083471673"`
	add_diff_hunks_into_diff_file gdextension.MethodForClass `hash:"4015243225"`
	add_line_diffs_into_diff_hunk gdextension.MethodForClass `hash:"4015243225"`
	popup_error                   gdextension.MethodForClass `hash:"83702148"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("EditorVCSInterface")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, true)
	})
	gd.RegisterCleanup(func() {
		gdextension.Free(gdextension.TypeStringName, &sname)
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsEditorVCSInterface() Instance
}
type Interface interface {
	//Initializes the VCS plugin when called from the editor. Returns whether or not the plugin was successfully initialized. A VCS project is initialized at [param project_path].
	Initialize(project_path string) bool
	//Set user credentials in the underlying VCS. [param username] and [param password] are used only during HTTPS authentication unless not already mentioned in the remote URL. [param ssh_public_key_path], [param ssh_private_key_path], and [param ssh_passphrase] are only used during SSH authentication.
	SetCredentials(username string, password string, ssh_public_key_path string, ssh_private_key_path string, ssh_passphrase string)
	//Returns an [Array] of [Dictionary] items (see [method create_status_file]), each containing the status data of every modified file in the project folder.
	GetModifiedFilesData() []map[any]any
	//Stages the file present at [param file_path] to the staged area.
	StageFile(file_path string)
	//Unstages the file present at [param file_path] from the staged area to the unstaged area.
	UnstageFile(file_path string)
	//Discards the changes made in a file present at [param file_path].
	DiscardFile(file_path string)
	//Commits the currently staged changes and applies the commit [param msg] to the resulting commit.
	Commit(msg string)
	//Returns an array of [Dictionary] items (see [method create_diff_file], [method create_diff_hunk], [method create_diff_line], [method add_line_diffs_into_diff_hunk] and [method add_diff_hunks_into_diff_file]), each containing information about a diff. If [param identifier] is a file path, returns a file diff, and if it is a commit identifier, then returns a commit diff.
	GetDiff(identifier string, area int) []map[any]any
	//Shuts down VCS plugin instance. Called when the user either closes the editor or shuts down the VCS plugin through the editor UI.
	ShutDown() bool
	//Returns the name of the underlying VCS provider.
	GetVcsName() string
	//Returns an [Array] of [Dictionary] items (see [method create_commit]), each containing the data for a past commit.
	GetPreviousCommits(max_commits int) []map[any]any
	//Gets an instance of an [Array] of [String]s containing available branch names in the VCS.
	GetBranchList() []string
	//Returns an [Array] of [String]s, each containing the name of a remote configured in the VCS.
	GetRemotes() []string
	//Creates a new branch named [param branch_name] in the VCS.
	CreateBranch(branch_name string)
	//Remove a branch from the local VCS.
	RemoveBranch(branch_name string)
	//Creates a new remote destination with name [param remote_name] and points it to [param remote_url]. This can be an HTTPS remote or an SSH remote.
	CreateRemote(remote_name string, remote_url string)
	//Remove a remote from the local VCS.
	RemoveRemote(remote_name string)
	//Gets the current branch name defined in the VCS.
	GetCurrentBranchName() string
	//Checks out a [param branch_name] in the VCS.
	CheckoutBranch(branch_name string) bool
	//Pulls changes from the remote. This can give rise to merge conflicts.
	Pull(remote string)
	//Pushes changes to the [param remote]. If [param force] is [code]true[/code], a force push will override the change history already present on the remote.
	Push(remote string, force bool)
	//Fetches new changes from the [param remote], but doesn't write changes to the current working directory. Equivalent to [code]git fetch[/code].
	Fetch(remote string)
	//Returns an [Array] of [Dictionary] items (see [method create_diff_hunk]), each containing a line diff between a file at [param file_path] and the [param text] which is passed in.
	GetLineDiff(file_path string, text string) []map[any]any
}

// Implementation implements [Interface] with empty methods.
type Implementation = implementation

type implementation struct{}

func (self implementation) Initialize(project_path string) (_ bool) { return }
func (self implementation) SetCredentials(username string, password string, ssh_public_key_path string, ssh_private_key_path string, ssh_passphrase string) {
	return
}
func (self implementation) GetModifiedFilesData() (_ []map[any]any)                     { return }
func (self implementation) StageFile(file_path string)                                  { return }
func (self implementation) UnstageFile(file_path string)                                { return }
func (self implementation) DiscardFile(file_path string)                                { return }
func (self implementation) Commit(msg string)                                           { return }
func (self implementation) GetDiff(identifier string, area int) (_ []map[any]any)       { return }
func (self implementation) ShutDown() (_ bool)                                          { return }
func (self implementation) GetVcsName() (_ string)                                      { return }
func (self implementation) GetPreviousCommits(max_commits int) (_ []map[any]any)        { return }
func (self implementation) GetBranchList() (_ []string)                                 { return }
func (self implementation) GetRemotes() (_ []string)                                    { return }
func (self implementation) CreateBranch(branch_name string)                             { return }
func (self implementation) RemoveBranch(branch_name string)                             { return }
func (self implementation) CreateRemote(remote_name string, remote_url string)          { return }
func (self implementation) RemoveRemote(remote_name string)                             { return }
func (self implementation) GetCurrentBranchName() (_ string)                            { return }
func (self implementation) CheckoutBranch(branch_name string) (_ bool)                  { return }
func (self implementation) Pull(remote string)                                          { return }
func (self implementation) Push(remote string, force bool)                              { return }
func (self implementation) Fetch(remote string)                                         { return }
func (self implementation) GetLineDiff(file_path string, text string) (_ []map[any]any) { return }

/*
Initializes the VCS plugin when called from the editor. Returns whether or not the plugin was successfully initialized. A VCS project is initialized at [param project_path].
*/
func (Instance) _initialize(impl func(ptr unsafe.Pointer, project_path string) bool) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var project_path = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](gd.UnsafeGet[gdextension.String](p_args, 0))))
		defer pointers.End(gd.InternalString(project_path))
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self, project_path.String())
		gd.UnsafeSet(p_back, ret)
	}
}

/*
Set user credentials in the underlying VCS. [param username] and [param password] are used only during HTTPS authentication unless not already mentioned in the remote URL. [param ssh_public_key_path], [param ssh_private_key_path], and [param ssh_passphrase] are only used during SSH authentication.
*/
func (Instance) _set_credentials(impl func(ptr unsafe.Pointer, username string, password string, ssh_public_key_path string, ssh_private_key_path string, ssh_passphrase string)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var username = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](gd.UnsafeGet[gdextension.String](p_args, 0))))
		defer pointers.End(gd.InternalString(username))
		var password = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](gd.UnsafeGet[gdextension.String](p_args, 1))))
		defer pointers.End(gd.InternalString(password))
		var ssh_public_key_path = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](gd.UnsafeGet[gdextension.String](p_args, 2))))
		defer pointers.End(gd.InternalString(ssh_public_key_path))
		var ssh_private_key_path = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](gd.UnsafeGet[gdextension.String](p_args, 3))))
		defer pointers.End(gd.InternalString(ssh_private_key_path))
		var ssh_passphrase = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](gd.UnsafeGet[gdextension.String](p_args, 4))))
		defer pointers.End(gd.InternalString(ssh_passphrase))
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, username.String(), password.String(), ssh_public_key_path.String(), ssh_private_key_path.String(), ssh_passphrase.String())
	}
}

/*
Returns an [Array] of [Dictionary] items (see [method create_status_file]), each containing the status data of every modified file in the project folder.
*/
func (Instance) _get_modified_files_data(impl func(ptr unsafe.Pointer) []map[any]any) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		ptr, ok := pointers.End(gd.InternalArray(gd.ArrayFromSlice[Array.Contains[Dictionary.Any]](ret)))

		if !ok {
			return
		}
		gd.UnsafeSet(p_back, ptr)
	}
}

/*
Stages the file present at [param file_path] to the staged area.
*/
func (Instance) _stage_file(impl func(ptr unsafe.Pointer, file_path string)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var file_path = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](gd.UnsafeGet[gdextension.String](p_args, 0))))
		defer pointers.End(gd.InternalString(file_path))
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, file_path.String())
	}
}

/*
Unstages the file present at [param file_path] from the staged area to the unstaged area.
*/
func (Instance) _unstage_file(impl func(ptr unsafe.Pointer, file_path string)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var file_path = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](gd.UnsafeGet[gdextension.String](p_args, 0))))
		defer pointers.End(gd.InternalString(file_path))
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, file_path.String())
	}
}

/*
Discards the changes made in a file present at [param file_path].
*/
func (Instance) _discard_file(impl func(ptr unsafe.Pointer, file_path string)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var file_path = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](gd.UnsafeGet[gdextension.String](p_args, 0))))
		defer pointers.End(gd.InternalString(file_path))
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, file_path.String())
	}
}

/*
Commits the currently staged changes and applies the commit [param msg] to the resulting commit.
*/
func (Instance) _commit(impl func(ptr unsafe.Pointer, msg string)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var msg = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](gd.UnsafeGet[gdextension.String](p_args, 0))))
		defer pointers.End(gd.InternalString(msg))
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, msg.String())
	}
}

/*
Returns an array of [Dictionary] items (see [method create_diff_file], [method create_diff_hunk], [method create_diff_line], [method add_line_diffs_into_diff_hunk] and [method add_diff_hunks_into_diff_file]), each containing information about a diff. If [param identifier] is a file path, returns a file diff, and if it is a commit identifier, then returns a commit diff.
*/
func (Instance) _get_diff(impl func(ptr unsafe.Pointer, identifier string, area int) []map[any]any) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var identifier = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](gd.UnsafeGet[gdextension.String](p_args, 0))))
		defer pointers.End(gd.InternalString(identifier))
		var area = gd.UnsafeGet[int64](p_args, 1)
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self, identifier.String(), int(area))
		ptr, ok := pointers.End(gd.InternalArray(gd.ArrayFromSlice[Array.Contains[Dictionary.Any]](ret)))

		if !ok {
			return
		}
		gd.UnsafeSet(p_back, ptr)
	}
}

/*
Shuts down VCS plugin instance. Called when the user either closes the editor or shuts down the VCS plugin through the editor UI.
*/
func (Instance) _shut_down(impl func(ptr unsafe.Pointer) bool) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		gd.UnsafeSet(p_back, ret)
	}
}

/*
Returns the name of the underlying VCS provider.
*/
func (Instance) _get_vcs_name(impl func(ptr unsafe.Pointer) string) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		ptr, ok := pointers.End(gd.InternalString(String.New(ret)))

		if !ok {
			return
		}
		gd.UnsafeSet(p_back, ptr)
	}
}

/*
Returns an [Array] of [Dictionary] items (see [method create_commit]), each containing the data for a past commit.
*/
func (Instance) _get_previous_commits(impl func(ptr unsafe.Pointer, max_commits int) []map[any]any) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var max_commits = gd.UnsafeGet[int64](p_args, 0)
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self, int(max_commits))
		ptr, ok := pointers.End(gd.InternalArray(gd.ArrayFromSlice[Array.Contains[Dictionary.Any]](ret)))

		if !ok {
			return
		}
		gd.UnsafeSet(p_back, ptr)
	}
}

/*
Gets an instance of an [Array] of [String]s containing available branch names in the VCS.
*/
func (Instance) _get_branch_list(impl func(ptr unsafe.Pointer) []string) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		ptr, ok := pointers.End(gd.InternalArray(gd.ArrayFromSlice[Array.Contains[String.Readable]](ret)))

		if !ok {
			return
		}
		gd.UnsafeSet(p_back, ptr)
	}
}

/*
Returns an [Array] of [String]s, each containing the name of a remote configured in the VCS.
*/
func (Instance) _get_remotes(impl func(ptr unsafe.Pointer) []string) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		ptr, ok := pointers.End(gd.InternalArray(gd.ArrayFromSlice[Array.Contains[String.Readable]](ret)))

		if !ok {
			return
		}
		gd.UnsafeSet(p_back, ptr)
	}
}

/*
Creates a new branch named [param branch_name] in the VCS.
*/
func (Instance) _create_branch(impl func(ptr unsafe.Pointer, branch_name string)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var branch_name = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](gd.UnsafeGet[gdextension.String](p_args, 0))))
		defer pointers.End(gd.InternalString(branch_name))
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, branch_name.String())
	}
}

/*
Remove a branch from the local VCS.
*/
func (Instance) _remove_branch(impl func(ptr unsafe.Pointer, branch_name string)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var branch_name = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](gd.UnsafeGet[gdextension.String](p_args, 0))))
		defer pointers.End(gd.InternalString(branch_name))
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, branch_name.String())
	}
}

/*
Creates a new remote destination with name [param remote_name] and points it to [param remote_url]. This can be an HTTPS remote or an SSH remote.
*/
func (Instance) _create_remote(impl func(ptr unsafe.Pointer, remote_name string, remote_url string)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var remote_name = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](gd.UnsafeGet[gdextension.String](p_args, 0))))
		defer pointers.End(gd.InternalString(remote_name))
		var remote_url = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](gd.UnsafeGet[gdextension.String](p_args, 1))))
		defer pointers.End(gd.InternalString(remote_url))
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, remote_name.String(), remote_url.String())
	}
}

/*
Remove a remote from the local VCS.
*/
func (Instance) _remove_remote(impl func(ptr unsafe.Pointer, remote_name string)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var remote_name = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](gd.UnsafeGet[gdextension.String](p_args, 0))))
		defer pointers.End(gd.InternalString(remote_name))
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, remote_name.String())
	}
}

/*
Gets the current branch name defined in the VCS.
*/
func (Instance) _get_current_branch_name(impl func(ptr unsafe.Pointer) string) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		ptr, ok := pointers.End(gd.InternalString(String.New(ret)))

		if !ok {
			return
		}
		gd.UnsafeSet(p_back, ptr)
	}
}

/*
Checks out a [param branch_name] in the VCS.
*/
func (Instance) _checkout_branch(impl func(ptr unsafe.Pointer, branch_name string) bool) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var branch_name = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](gd.UnsafeGet[gdextension.String](p_args, 0))))
		defer pointers.End(gd.InternalString(branch_name))
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self, branch_name.String())
		gd.UnsafeSet(p_back, ret)
	}
}

/*
Pulls changes from the remote. This can give rise to merge conflicts.
*/
func (Instance) _pull(impl func(ptr unsafe.Pointer, remote string)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var remote = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](gd.UnsafeGet[gdextension.String](p_args, 0))))
		defer pointers.End(gd.InternalString(remote))
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, remote.String())
	}
}

/*
Pushes changes to the [param remote]. If [param force] is [code]true[/code], a force push will override the change history already present on the remote.
*/
func (Instance) _push(impl func(ptr unsafe.Pointer, remote string, force bool)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var remote = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](gd.UnsafeGet[gdextension.String](p_args, 0))))
		defer pointers.End(gd.InternalString(remote))
		var force = gd.UnsafeGet[bool](p_args, 1)
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, remote.String(), force)
	}
}

/*
Fetches new changes from the [param remote], but doesn't write changes to the current working directory. Equivalent to [code]git fetch[/code].
*/
func (Instance) _fetch(impl func(ptr unsafe.Pointer, remote string)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var remote = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](gd.UnsafeGet[gdextension.String](p_args, 0))))
		defer pointers.End(gd.InternalString(remote))
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, remote.String())
	}
}

/*
Returns an [Array] of [Dictionary] items (see [method create_diff_hunk]), each containing a line diff between a file at [param file_path] and the [param text] which is passed in.
*/
func (Instance) _get_line_diff(impl func(ptr unsafe.Pointer, file_path string, text string) []map[any]any) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var file_path = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](gd.UnsafeGet[gdextension.String](p_args, 0))))
		defer pointers.End(gd.InternalString(file_path))
		var text = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](gd.UnsafeGet[gdextension.String](p_args, 1))))
		defer pointers.End(gd.InternalString(text))
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self, file_path.String(), text.String())
		ptr, ok := pointers.End(gd.InternalArray(gd.ArrayFromSlice[Array.Contains[Dictionary.Any]](ret)))

		if !ok {
			return
		}
		gd.UnsafeSet(p_back, ptr)
	}
}

/*
Helper function to create a [Dictionary] for storing a line diff. [param new_line_no] is the line number in the new file (can be [code]-1[/code] if the line is deleted). [param old_line_no] is the line number in the old file (can be [code]-1[/code] if the line is added). [param content] is the diff text. [param status] is a single character string which stores the line origin.
*/
func (self Instance) CreateDiffLine(new_line_no int, old_line_no int, content string, status string) DiffLine { //gd:EditorVCSInterface.create_diff_line
	return DiffLine(gd.DictionaryAs[DiffLine](Advanced(self).CreateDiffLine(int64(new_line_no), int64(old_line_no), String.New(content), String.New(status))))
}

/*
Helper function to create a [Dictionary] for storing diff hunk data. [param old_start] is the starting line number in old file. [param new_start] is the starting line number in new file. [param old_lines] is the number of lines in the old file. [param new_lines] is the number of lines in the new file.
*/
func (self Instance) CreateDiffHunk(old_start int, new_start int, old_lines int, new_lines int) DiffHunk { //gd:EditorVCSInterface.create_diff_hunk
	return DiffHunk(gd.DictionaryAs[DiffHunk](Advanced(self).CreateDiffHunk(int64(old_start), int64(new_start), int64(old_lines), int64(new_lines))))
}

/*
Helper function to create a [Dictionary] for storing old and new diff file paths.
*/
func (self Instance) CreateDiffFile(new_file string, old_file string) DiffFile { //gd:EditorVCSInterface.create_diff_file
	return DiffFile(gd.DictionaryAs[DiffFile](Advanced(self).CreateDiffFile(String.New(new_file), String.New(old_file))))
}

/*
Helper function to create a commit [Dictionary] item. [param msg] is the commit message of the commit. [param author] is a single human-readable string containing all the author's details, e.g. the email and name configured in the VCS. [param id] is the identifier of the commit, in whichever format your VCS may provide an identifier to commits. [param unix_timestamp] is the UTC Unix timestamp of when the commit was created. [param offset_minutes] is the timezone offset in minutes, recorded from the system timezone where the commit was created.
*/
func (self Instance) CreateCommit(msg string, author string, id string, unix_timestamp int, offset_minutes int) Commit { //gd:EditorVCSInterface.create_commit
	return Commit(gd.DictionaryAs[Commit](Advanced(self).CreateCommit(String.New(msg), String.New(author), String.New(id), int64(unix_timestamp), int64(offset_minutes))))
}

/*
Helper function to create a [Dictionary] used by editor to read the status of a file.
*/
func (self Instance) CreateStatusFile(file_path string, change_type ChangeType, area TreeArea) StatusFile { //gd:EditorVCSInterface.create_status_file
	return StatusFile(gd.DictionaryAs[StatusFile](Advanced(self).CreateStatusFile(String.New(file_path), change_type, area)))
}

/*
Helper function to add an array of [param diff_hunks] into a [param diff_file].
*/
func (self Instance) AddDiffHunksIntoDiffFile(diff_file DiffFile, diff_hunks []DiffHunk) DiffFile { //gd:EditorVCSInterface.add_diff_hunks_into_diff_file
	return DiffFile(gd.DictionaryAs[DiffFile](Advanced(self).AddDiffHunksIntoDiffFile(gd.DictionaryFromMap(diff_file), gd.ArrayFromSlice[Array.Contains[Dictionary.Any]](diff_hunks))))
}

/*
Helper function to add an array of [param line_diffs] into a [param diff_hunk].
*/
func (self Instance) AddLineDiffsIntoDiffHunk(diff_hunk DiffHunk, line_diffs []DiffLine) DiffHunk { //gd:EditorVCSInterface.add_line_diffs_into_diff_hunk
	return DiffHunk(gd.DictionaryAs[DiffHunk](Advanced(self).AddLineDiffsIntoDiffHunk(gd.DictionaryFromMap(diff_hunk), gd.ArrayFromSlice[Array.Contains[Dictionary.Any]](line_diffs))))
}

/*
Pops up an error message in the editor which is shown as coming from the underlying VCS. Use this to show VCS specific error messages.
*/
func (self Instance) PopupError(msg string) { //gd:EditorVCSInterface.popup_error
	Advanced(self).PopupError(String.New(msg))
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.EditorVCSInterface

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.EditorVCSInterface)(unsafe.Pointer(&obj))
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.EditorVCSInterface)(unsafe.Pointer(&obj))
		return true
	}
	return false
}

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {

	if !gd.Linked {
		var placeholder Instance
		*(*gd.Object)(unsafe.Pointer(&placeholder)) = pointers.Add[gd.Object]([3]uint64{})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(*(*gd.Object)(unsafe.Pointer(&placeholder)), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	object := [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})}
	casted := Instance{*(*gdclass.EditorVCSInterface)(unsafe.Pointer(&object))}
	object[0].Notification(0, false)
	return casted
}

/*
Initializes the VCS plugin when called from the editor. Returns whether or not the plugin was successfully initialized. A VCS project is initialized at [param project_path].
*/
func (class) _initialize(impl func(ptr unsafe.Pointer, project_path String.Readable) bool) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var project_path = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](gd.UnsafeGet[gdextension.String](p_args, 0))))
		defer pointers.End(gd.InternalString(project_path))
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self, project_path)
		gd.UnsafeSet(p_back, ret)
	}
}

/*
Set user credentials in the underlying VCS. [param username] and [param password] are used only during HTTPS authentication unless not already mentioned in the remote URL. [param ssh_public_key_path], [param ssh_private_key_path], and [param ssh_passphrase] are only used during SSH authentication.
*/
func (class) _set_credentials(impl func(ptr unsafe.Pointer, username String.Readable, password String.Readable, ssh_public_key_path String.Readable, ssh_private_key_path String.Readable, ssh_passphrase String.Readable)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var username = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](gd.UnsafeGet[gdextension.String](p_args, 0))))
		defer pointers.End(gd.InternalString(username))
		var password = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](gd.UnsafeGet[gdextension.String](p_args, 1))))
		defer pointers.End(gd.InternalString(password))
		var ssh_public_key_path = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](gd.UnsafeGet[gdextension.String](p_args, 2))))
		defer pointers.End(gd.InternalString(ssh_public_key_path))
		var ssh_private_key_path = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](gd.UnsafeGet[gdextension.String](p_args, 3))))
		defer pointers.End(gd.InternalString(ssh_private_key_path))
		var ssh_passphrase = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](gd.UnsafeGet[gdextension.String](p_args, 4))))
		defer pointers.End(gd.InternalString(ssh_passphrase))
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, username, password, ssh_public_key_path, ssh_private_key_path, ssh_passphrase)
	}
}

/*
Returns an [Array] of [Dictionary] items (see [method create_status_file]), each containing the status data of every modified file in the project folder.
*/
func (class) _get_modified_files_data(impl func(ptr unsafe.Pointer) Array.Contains[Dictionary.Any]) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		ptr, ok := pointers.End(gd.InternalArray(ret))

		if !ok {
			return
		}
		gd.UnsafeSet(p_back, ptr)
	}
}

/*
Stages the file present at [param file_path] to the staged area.
*/
func (class) _stage_file(impl func(ptr unsafe.Pointer, file_path String.Readable)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var file_path = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](gd.UnsafeGet[gdextension.String](p_args, 0))))
		defer pointers.End(gd.InternalString(file_path))
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, file_path)
	}
}

/*
Unstages the file present at [param file_path] from the staged area to the unstaged area.
*/
func (class) _unstage_file(impl func(ptr unsafe.Pointer, file_path String.Readable)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var file_path = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](gd.UnsafeGet[gdextension.String](p_args, 0))))
		defer pointers.End(gd.InternalString(file_path))
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, file_path)
	}
}

/*
Discards the changes made in a file present at [param file_path].
*/
func (class) _discard_file(impl func(ptr unsafe.Pointer, file_path String.Readable)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var file_path = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](gd.UnsafeGet[gdextension.String](p_args, 0))))
		defer pointers.End(gd.InternalString(file_path))
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, file_path)
	}
}

/*
Commits the currently staged changes and applies the commit [param msg] to the resulting commit.
*/
func (class) _commit(impl func(ptr unsafe.Pointer, msg String.Readable)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var msg = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](gd.UnsafeGet[gdextension.String](p_args, 0))))
		defer pointers.End(gd.InternalString(msg))
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, msg)
	}
}

/*
Returns an array of [Dictionary] items (see [method create_diff_file], [method create_diff_hunk], [method create_diff_line], [method add_line_diffs_into_diff_hunk] and [method add_diff_hunks_into_diff_file]), each containing information about a diff. If [param identifier] is a file path, returns a file diff, and if it is a commit identifier, then returns a commit diff.
*/
func (class) _get_diff(impl func(ptr unsafe.Pointer, identifier String.Readable, area int64) Array.Contains[Dictionary.Any]) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var identifier = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](gd.UnsafeGet[gdextension.String](p_args, 0))))
		defer pointers.End(gd.InternalString(identifier))
		var area = gd.UnsafeGet[int64](p_args, 1)
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self, identifier, area)
		ptr, ok := pointers.End(gd.InternalArray(ret))

		if !ok {
			return
		}
		gd.UnsafeSet(p_back, ptr)
	}
}

/*
Shuts down VCS plugin instance. Called when the user either closes the editor or shuts down the VCS plugin through the editor UI.
*/
func (class) _shut_down(impl func(ptr unsafe.Pointer) bool) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		gd.UnsafeSet(p_back, ret)
	}
}

/*
Returns the name of the underlying VCS provider.
*/
func (class) _get_vcs_name(impl func(ptr unsafe.Pointer) String.Readable) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		ptr, ok := pointers.End(gd.InternalString(ret))

		if !ok {
			return
		}
		gd.UnsafeSet(p_back, ptr)
	}
}

/*
Returns an [Array] of [Dictionary] items (see [method create_commit]), each containing the data for a past commit.
*/
func (class) _get_previous_commits(impl func(ptr unsafe.Pointer, max_commits int64) Array.Contains[Dictionary.Any]) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var max_commits = gd.UnsafeGet[int64](p_args, 0)
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self, max_commits)
		ptr, ok := pointers.End(gd.InternalArray(ret))

		if !ok {
			return
		}
		gd.UnsafeSet(p_back, ptr)
	}
}

/*
Gets an instance of an [Array] of [String]s containing available branch names in the VCS.
*/
func (class) _get_branch_list(impl func(ptr unsafe.Pointer) Array.Contains[String.Readable]) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		ptr, ok := pointers.End(gd.InternalArray(ret))

		if !ok {
			return
		}
		gd.UnsafeSet(p_back, ptr)
	}
}

/*
Returns an [Array] of [String]s, each containing the name of a remote configured in the VCS.
*/
func (class) _get_remotes(impl func(ptr unsafe.Pointer) Array.Contains[String.Readable]) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		ptr, ok := pointers.End(gd.InternalArray(ret))

		if !ok {
			return
		}
		gd.UnsafeSet(p_back, ptr)
	}
}

/*
Creates a new branch named [param branch_name] in the VCS.
*/
func (class) _create_branch(impl func(ptr unsafe.Pointer, branch_name String.Readable)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var branch_name = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](gd.UnsafeGet[gdextension.String](p_args, 0))))
		defer pointers.End(gd.InternalString(branch_name))
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, branch_name)
	}
}

/*
Remove a branch from the local VCS.
*/
func (class) _remove_branch(impl func(ptr unsafe.Pointer, branch_name String.Readable)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var branch_name = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](gd.UnsafeGet[gdextension.String](p_args, 0))))
		defer pointers.End(gd.InternalString(branch_name))
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, branch_name)
	}
}

/*
Creates a new remote destination with name [param remote_name] and points it to [param remote_url]. This can be an HTTPS remote or an SSH remote.
*/
func (class) _create_remote(impl func(ptr unsafe.Pointer, remote_name String.Readable, remote_url String.Readable)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var remote_name = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](gd.UnsafeGet[gdextension.String](p_args, 0))))
		defer pointers.End(gd.InternalString(remote_name))
		var remote_url = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](gd.UnsafeGet[gdextension.String](p_args, 1))))
		defer pointers.End(gd.InternalString(remote_url))
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, remote_name, remote_url)
	}
}

/*
Remove a remote from the local VCS.
*/
func (class) _remove_remote(impl func(ptr unsafe.Pointer, remote_name String.Readable)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var remote_name = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](gd.UnsafeGet[gdextension.String](p_args, 0))))
		defer pointers.End(gd.InternalString(remote_name))
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, remote_name)
	}
}

/*
Gets the current branch name defined in the VCS.
*/
func (class) _get_current_branch_name(impl func(ptr unsafe.Pointer) String.Readable) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		ptr, ok := pointers.End(gd.InternalString(ret))

		if !ok {
			return
		}
		gd.UnsafeSet(p_back, ptr)
	}
}

/*
Checks out a [param branch_name] in the VCS.
*/
func (class) _checkout_branch(impl func(ptr unsafe.Pointer, branch_name String.Readable) bool) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var branch_name = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](gd.UnsafeGet[gdextension.String](p_args, 0))))
		defer pointers.End(gd.InternalString(branch_name))
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self, branch_name)
		gd.UnsafeSet(p_back, ret)
	}
}

/*
Pulls changes from the remote. This can give rise to merge conflicts.
*/
func (class) _pull(impl func(ptr unsafe.Pointer, remote String.Readable)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var remote = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](gd.UnsafeGet[gdextension.String](p_args, 0))))
		defer pointers.End(gd.InternalString(remote))
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, remote)
	}
}

/*
Pushes changes to the [param remote]. If [param force] is [code]true[/code], a force push will override the change history already present on the remote.
*/
func (class) _push(impl func(ptr unsafe.Pointer, remote String.Readable, force bool)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var remote = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](gd.UnsafeGet[gdextension.String](p_args, 0))))
		defer pointers.End(gd.InternalString(remote))
		var force = gd.UnsafeGet[bool](p_args, 1)
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, remote, force)
	}
}

/*
Fetches new changes from the [param remote], but doesn't write changes to the current working directory. Equivalent to [code]git fetch[/code].
*/
func (class) _fetch(impl func(ptr unsafe.Pointer, remote String.Readable)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var remote = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](gd.UnsafeGet[gdextension.String](p_args, 0))))
		defer pointers.End(gd.InternalString(remote))
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, remote)
	}
}

/*
Returns an [Array] of [Dictionary] items (see [method create_diff_hunk]), each containing a line diff between a file at [param file_path] and the [param text] which is passed in.
*/
func (class) _get_line_diff(impl func(ptr unsafe.Pointer, file_path String.Readable, text String.Readable) Array.Contains[Dictionary.Any]) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var file_path = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](gd.UnsafeGet[gdextension.String](p_args, 0))))
		defer pointers.End(gd.InternalString(file_path))
		var text = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](gd.UnsafeGet[gdextension.String](p_args, 1))))
		defer pointers.End(gd.InternalString(text))
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self, file_path, text)
		ptr, ok := pointers.End(gd.InternalArray(ret))

		if !ok {
			return
		}
		gd.UnsafeSet(p_back, ptr)
	}
}

/*
Helper function to create a [Dictionary] for storing a line diff. [param new_line_no] is the line number in the new file (can be [code]-1[/code] if the line is deleted). [param old_line_no] is the line number in the old file (can be [code]-1[/code] if the line is added). [param content] is the diff text. [param status] is a single character string which stores the line origin.
*/
//go:nosplit
func (self class) CreateDiffLine(new_line_no int64, old_line_no int64, content String.Readable, status String.Readable) Dictionary.Any { //gd:EditorVCSInterface.create_diff_line
	var r_ret = gdextension.Call[gdextension.Dictionary](gd.ObjectChecked(self.AsObject()), methods.create_diff_line, gdextension.SizeDictionary|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeString<<12)|(gdextension.SizeString<<16), unsafe.Pointer(&struct {
		new_line_no int64
		old_line_no int64
		content     gdextension.String
		status      gdextension.String
	}{new_line_no, old_line_no, pointers.Get(gd.InternalString(content)), pointers.Get(gd.InternalString(status))}))
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret)))
	return ret
}

/*
Helper function to create a [Dictionary] for storing diff hunk data. [param old_start] is the starting line number in old file. [param new_start] is the starting line number in new file. [param old_lines] is the number of lines in the old file. [param new_lines] is the number of lines in the new file.
*/
//go:nosplit
func (self class) CreateDiffHunk(old_start int64, new_start int64, old_lines int64, new_lines int64) Dictionary.Any { //gd:EditorVCSInterface.create_diff_hunk
	var r_ret = gdextension.Call[gdextension.Dictionary](gd.ObjectChecked(self.AsObject()), methods.create_diff_hunk, gdextension.SizeDictionary|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeInt<<16), unsafe.Pointer(&struct {
		old_start int64
		new_start int64
		old_lines int64
		new_lines int64
	}{old_start, new_start, old_lines, new_lines}))
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret)))
	return ret
}

/*
Helper function to create a [Dictionary] for storing old and new diff file paths.
*/
//go:nosplit
func (self class) CreateDiffFile(new_file String.Readable, old_file String.Readable) Dictionary.Any { //gd:EditorVCSInterface.create_diff_file
	var r_ret = gdextension.Call[gdextension.Dictionary](gd.ObjectChecked(self.AsObject()), methods.create_diff_file, gdextension.SizeDictionary|(gdextension.SizeString<<4)|(gdextension.SizeString<<8), unsafe.Pointer(&struct {
		new_file gdextension.String
		old_file gdextension.String
	}{pointers.Get(gd.InternalString(new_file)), pointers.Get(gd.InternalString(old_file))}))
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret)))
	return ret
}

/*
Helper function to create a commit [Dictionary] item. [param msg] is the commit message of the commit. [param author] is a single human-readable string containing all the author's details, e.g. the email and name configured in the VCS. [param id] is the identifier of the commit, in whichever format your VCS may provide an identifier to commits. [param unix_timestamp] is the UTC Unix timestamp of when the commit was created. [param offset_minutes] is the timezone offset in minutes, recorded from the system timezone where the commit was created.
*/
//go:nosplit
func (self class) CreateCommit(msg String.Readable, author String.Readable, id String.Readable, unix_timestamp int64, offset_minutes int64) Dictionary.Any { //gd:EditorVCSInterface.create_commit
	var r_ret = gdextension.Call[gdextension.Dictionary](gd.ObjectChecked(self.AsObject()), methods.create_commit, gdextension.SizeDictionary|(gdextension.SizeString<<4)|(gdextension.SizeString<<8)|(gdextension.SizeString<<12)|(gdextension.SizeInt<<16)|(gdextension.SizeInt<<20), unsafe.Pointer(&struct {
		msg            gdextension.String
		author         gdextension.String
		id             gdextension.String
		unix_timestamp int64
		offset_minutes int64
	}{pointers.Get(gd.InternalString(msg)), pointers.Get(gd.InternalString(author)), pointers.Get(gd.InternalString(id)), unix_timestamp, offset_minutes}))
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret)))
	return ret
}

/*
Helper function to create a [Dictionary] used by editor to read the status of a file.
*/
//go:nosplit
func (self class) CreateStatusFile(file_path String.Readable, change_type ChangeType, area TreeArea) Dictionary.Any { //gd:EditorVCSInterface.create_status_file
	var r_ret = gdextension.Call[gdextension.Dictionary](gd.ObjectChecked(self.AsObject()), methods.create_status_file, gdextension.SizeDictionary|(gdextension.SizeString<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		file_path   gdextension.String
		change_type ChangeType
		area        TreeArea
	}{pointers.Get(gd.InternalString(file_path)), change_type, area}))
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret)))
	return ret
}

/*
Helper function to add an array of [param diff_hunks] into a [param diff_file].
*/
//go:nosplit
func (self class) AddDiffHunksIntoDiffFile(diff_file Dictionary.Any, diff_hunks Array.Contains[Dictionary.Any]) Dictionary.Any { //gd:EditorVCSInterface.add_diff_hunks_into_diff_file
	var r_ret = gdextension.Call[gdextension.Dictionary](gd.ObjectChecked(self.AsObject()), methods.add_diff_hunks_into_diff_file, gdextension.SizeDictionary|(gdextension.SizeDictionary<<4)|(gdextension.SizeArray<<8), unsafe.Pointer(&struct {
		diff_file  gdextension.Dictionary
		diff_hunks gdextension.Array
	}{pointers.Get(gd.InternalDictionary(diff_file)), pointers.Get(gd.InternalArray(diff_hunks))}))
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret)))
	return ret
}

/*
Helper function to add an array of [param line_diffs] into a [param diff_hunk].
*/
//go:nosplit
func (self class) AddLineDiffsIntoDiffHunk(diff_hunk Dictionary.Any, line_diffs Array.Contains[Dictionary.Any]) Dictionary.Any { //gd:EditorVCSInterface.add_line_diffs_into_diff_hunk
	var r_ret = gdextension.Call[gdextension.Dictionary](gd.ObjectChecked(self.AsObject()), methods.add_line_diffs_into_diff_hunk, gdextension.SizeDictionary|(gdextension.SizeDictionary<<4)|(gdextension.SizeArray<<8), unsafe.Pointer(&struct {
		diff_hunk  gdextension.Dictionary
		line_diffs gdextension.Array
	}{pointers.Get(gd.InternalDictionary(diff_hunk)), pointers.Get(gd.InternalArray(line_diffs))}))
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret)))
	return ret
}

/*
Pops up an error message in the editor which is shown as coming from the underlying VCS. Use this to show VCS specific error messages.
*/
//go:nosplit
func (self class) PopupError(msg String.Readable) { //gd:EditorVCSInterface.popup_error
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.popup_error, 0|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ msg gdextension.String }{pointers.Get(gd.InternalString(msg))}))
}
func (self class) AsEditorVCSInterface() Advanced         { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsEditorVCSInterface() Instance      { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsEditorVCSInterface() Instance { return self.Super().AsEditorVCSInterface() }

func (self class) Virtual(name string) reflect.Value {
	switch name {
	case "_initialize":
		return reflect.ValueOf(self._initialize)
	case "_set_credentials":
		return reflect.ValueOf(self._set_credentials)
	case "_get_modified_files_data":
		return reflect.ValueOf(self._get_modified_files_data)
	case "_stage_file":
		return reflect.ValueOf(self._stage_file)
	case "_unstage_file":
		return reflect.ValueOf(self._unstage_file)
	case "_discard_file":
		return reflect.ValueOf(self._discard_file)
	case "_commit":
		return reflect.ValueOf(self._commit)
	case "_get_diff":
		return reflect.ValueOf(self._get_diff)
	case "_shut_down":
		return reflect.ValueOf(self._shut_down)
	case "_get_vcs_name":
		return reflect.ValueOf(self._get_vcs_name)
	case "_get_previous_commits":
		return reflect.ValueOf(self._get_previous_commits)
	case "_get_branch_list":
		return reflect.ValueOf(self._get_branch_list)
	case "_get_remotes":
		return reflect.ValueOf(self._get_remotes)
	case "_create_branch":
		return reflect.ValueOf(self._create_branch)
	case "_remove_branch":
		return reflect.ValueOf(self._remove_branch)
	case "_create_remote":
		return reflect.ValueOf(self._create_remote)
	case "_remove_remote":
		return reflect.ValueOf(self._remove_remote)
	case "_get_current_branch_name":
		return reflect.ValueOf(self._get_current_branch_name)
	case "_checkout_branch":
		return reflect.ValueOf(self._checkout_branch)
	case "_pull":
		return reflect.ValueOf(self._pull)
	case "_push":
		return reflect.ValueOf(self._push)
	case "_fetch":
		return reflect.ValueOf(self._fetch)
	case "_get_line_diff":
		return reflect.ValueOf(self._get_line_diff)
	default:
		return gd.VirtualByName(Object.Advanced(self.AsObject()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	case "_initialize":
		return reflect.ValueOf(self._initialize)
	case "_set_credentials":
		return reflect.ValueOf(self._set_credentials)
	case "_get_modified_files_data":
		return reflect.ValueOf(self._get_modified_files_data)
	case "_stage_file":
		return reflect.ValueOf(self._stage_file)
	case "_unstage_file":
		return reflect.ValueOf(self._unstage_file)
	case "_discard_file":
		return reflect.ValueOf(self._discard_file)
	case "_commit":
		return reflect.ValueOf(self._commit)
	case "_get_diff":
		return reflect.ValueOf(self._get_diff)
	case "_shut_down":
		return reflect.ValueOf(self._shut_down)
	case "_get_vcs_name":
		return reflect.ValueOf(self._get_vcs_name)
	case "_get_previous_commits":
		return reflect.ValueOf(self._get_previous_commits)
	case "_get_branch_list":
		return reflect.ValueOf(self._get_branch_list)
	case "_get_remotes":
		return reflect.ValueOf(self._get_remotes)
	case "_create_branch":
		return reflect.ValueOf(self._create_branch)
	case "_remove_branch":
		return reflect.ValueOf(self._remove_branch)
	case "_create_remote":
		return reflect.ValueOf(self._create_remote)
	case "_remove_remote":
		return reflect.ValueOf(self._remove_remote)
	case "_get_current_branch_name":
		return reflect.ValueOf(self._get_current_branch_name)
	case "_checkout_branch":
		return reflect.ValueOf(self._checkout_branch)
	case "_pull":
		return reflect.ValueOf(self._pull)
	case "_push":
		return reflect.ValueOf(self._push)
	case "_fetch":
		return reflect.ValueOf(self._fetch)
	case "_get_line_diff":
		return reflect.ValueOf(self._get_line_diff)
	default:
		return gd.VirtualByName(Object.Instance(self.AsObject()), name)
	}
}
func init() {
	gdclass.Register("EditorVCSInterface", func(ptr gd.Object) any { return *(*Instance)(unsafe.Pointer(&ptr)) })
}

type ChangeType int //gd:EditorVCSInterface.ChangeType

const (
	/*A new file has been added.*/
	ChangeTypeNew ChangeType = 0
	/*An earlier added file has been modified.*/
	ChangeTypeModified ChangeType = 1
	/*An earlier added file has been renamed.*/
	ChangeTypeRenamed ChangeType = 2
	/*An earlier added file has been deleted.*/
	ChangeTypeDeleted ChangeType = 3
	/*An earlier added file has been typechanged.*/
	ChangeTypeTypechange ChangeType = 4
	/*A file is left unmerged.*/
	ChangeTypeUnmerged ChangeType = 5
)

type TreeArea int //gd:EditorVCSInterface.TreeArea

const (
	/*A commit is encountered from the commit area.*/
	TreeAreaCommit TreeArea = 0
	/*A file is encountered from the staged area.*/
	TreeAreaStaged TreeArea = 1
	/*A file is encountered from the unstaged area.*/
	TreeAreaUnstaged TreeArea = 2
)

type Commit map[interface{}]interface{}
type DiffFile map[interface{}]interface{}
type DiffHunk map[interface{}]interface{}
type DiffLine map[interface{}]interface{}
type StatusFile map[interface{}]interface{}
