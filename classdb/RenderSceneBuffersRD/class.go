// Code generated by the generate package DO NOT EDIT

// Package RenderSceneBuffersRD provides methods for working with RenderSceneBuffersRD object instances.
package RenderSceneBuffersRD

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/RDTextureFormat"
import "graphics.gd/classdb/RDTextureView"
import "graphics.gd/classdb/RenderSceneBuffers"
import "graphics.gd/classdb/Rendering"
import "graphics.gd/classdb/RenderingServer"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"
import "graphics.gd/variant/Vector2i"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
This object manages all 3D rendering buffers for the rendering device based renderers. An instance of this object is created for every viewport that has 3D rendering enabled.
All buffers are organized in [b]contexts[/b]. The default context is called [b]render_buffers[/b] and can contain amongst others the color buffer, depth buffer, velocity buffers, VRS density map and MSAA variants of these buffers.
Buffers are only guaranteed to exist during rendering of the viewport.
[b]Note:[/b] This is an internal rendering server object, do not instantiate this from script.
*/
type Instance [1]gdclass.RenderSceneBuffersRD

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	has_texture                gdextension.MethodForClass `hash:"471820014"`
	create_texture             gdextension.MethodForClass `hash:"2950875024"`
	create_texture_from_format gdextension.MethodForClass `hash:"3344669382"`
	create_texture_view        gdextension.MethodForClass `hash:"283055834"`
	get_texture                gdextension.MethodForClass `hash:"750006389"`
	get_texture_format         gdextension.MethodForClass `hash:"371461758"`
	get_texture_slice          gdextension.MethodForClass `hash:"588440706"`
	get_texture_slice_view     gdextension.MethodForClass `hash:"682451778"`
	get_texture_slice_size     gdextension.MethodForClass `hash:"2617625368"`
	clear_context              gdextension.MethodForClass `hash:"3304788590"`
	get_color_texture          gdextension.MethodForClass `hash:"3050822880"`
	get_color_layer            gdextension.MethodForClass `hash:"3087988589"`
	get_depth_texture          gdextension.MethodForClass `hash:"3050822880"`
	get_depth_layer            gdextension.MethodForClass `hash:"3087988589"`
	get_velocity_texture       gdextension.MethodForClass `hash:"3050822880"`
	get_velocity_layer         gdextension.MethodForClass `hash:"3087988589"`
	get_render_target          gdextension.MethodForClass `hash:"2944877500"`
	get_view_count             gdextension.MethodForClass `hash:"3905245786"`
	get_internal_size          gdextension.MethodForClass `hash:"3690982128"`
	get_target_size            gdextension.MethodForClass `hash:"3690982128"`
	get_scaling_3d_mode        gdextension.MethodForClass `hash:"976778074"`
	get_fsr_sharpness          gdextension.MethodForClass `hash:"1740695150"`
	get_msaa_3d                gdextension.MethodForClass `hash:"3109158617"`
	get_texture_samples        gdextension.MethodForClass `hash:"407791724"`
	get_screen_space_aa        gdextension.MethodForClass `hash:"641513172"`
	get_use_taa                gdextension.MethodForClass `hash:"36873697"`
	get_use_debanding          gdextension.MethodForClass `hash:"36873697"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("RenderSceneBuffersRD")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		gdextension.Free(gdextension.TypeStringName, &sname)
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

type Expanded [1]gdclass.RenderSceneBuffersRD

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsRenderSceneBuffersRD() Instance
}

/*
Returns [code]true[/code] if a cached texture exists for this name.
*/
func (self Instance) HasTexture(context string, name string) bool { //gd:RenderSceneBuffersRD.has_texture
	return bool(Advanced(self).HasTexture(String.Name(String.New(context)), String.Name(String.New(name))))
}

/*
Create a new texture with the given definition and cache this under the given name. Will return the existing texture if it already exists.
*/
func (self Instance) CreateTexture(context string, name string, data_format Rendering.DataFormat, usage_bits int, texture_samples Rendering.TextureSamples, size Vector2i.XY, layers int, mipmaps int, unique bool, discardable bool) RID.Texture { //gd:RenderSceneBuffersRD.create_texture
	return RID.Texture(Advanced(self).CreateTexture(String.Name(String.New(context)), String.Name(String.New(name)), data_format, int64(usage_bits), texture_samples, Vector2i.XY(size), int64(layers), int64(mipmaps), unique, discardable))
}

/*
Create a new texture using the given format and view and cache this under the given name. Will return the existing texture if it already exists.
*/
func (self Instance) CreateTextureFromFormat(context string, name string, format RDTextureFormat.Instance, view RDTextureView.Instance, unique bool) RID.Texture { //gd:RenderSceneBuffersRD.create_texture_from_format
	return RID.Texture(Advanced(self).CreateTextureFromFormat(String.Name(String.New(context)), String.Name(String.New(name)), format, view, unique))
}

/*
Create a new texture view for an existing texture and cache this under the given [param view_name]. Will return the existing texture view if it already exists. Will error if the source texture doesn't exist.
*/
func (self Instance) CreateTextureView(context string, name string, view_name string, view RDTextureView.Instance) RID.Texture { //gd:RenderSceneBuffersRD.create_texture_view
	return RID.Texture(Advanced(self).CreateTextureView(String.Name(String.New(context)), String.Name(String.New(name)), String.Name(String.New(view_name)), view))
}

/*
Returns a cached texture with this name.
*/
func (self Instance) GetTexture(context string, name string) RID.Texture { //gd:RenderSceneBuffersRD.get_texture
	return RID.Texture(Advanced(self).GetTexture(String.Name(String.New(context)), String.Name(String.New(name))))
}

/*
Returns the texture format information with which a cached texture was created.
*/
func (self Instance) GetTextureFormat(context string, name string) RDTextureFormat.Instance { //gd:RenderSceneBuffersRD.get_texture_format
	return RDTextureFormat.Instance(Advanced(self).GetTextureFormat(String.Name(String.New(context)), String.Name(String.New(name))))
}

/*
Returns a specific slice (layer or mipmap) for a cached texture.
*/
func (self Instance) GetTextureSlice(context string, name string, layer int, mipmap int, layers int, mipmaps int) RID.Texture { //gd:RenderSceneBuffersRD.get_texture_slice
	return RID.Texture(Advanced(self).GetTextureSlice(String.Name(String.New(context)), String.Name(String.New(name)), int64(layer), int64(mipmap), int64(layers), int64(mipmaps)))
}

/*
Returns a specific view of a slice (layer or mipmap) for a cached texture.
*/
func (self Instance) GetTextureSliceView(context string, name string, layer int, mipmap int, layers int, mipmaps int, view RDTextureView.Instance) RID.Texture { //gd:RenderSceneBuffersRD.get_texture_slice_view
	return RID.Texture(Advanced(self).GetTextureSliceView(String.Name(String.New(context)), String.Name(String.New(name)), int64(layer), int64(mipmap), int64(layers), int64(mipmaps), view))
}

/*
Returns the texture size of a given slice of a cached texture.
*/
func (self Instance) GetTextureSliceSize(context string, name string, mipmap int) Vector2i.XY { //gd:RenderSceneBuffersRD.get_texture_slice_size
	return Vector2i.XY(Advanced(self).GetTextureSliceSize(String.Name(String.New(context)), String.Name(String.New(name)), int64(mipmap)))
}

/*
Frees all buffers related to this context.
*/
func (self Instance) ClearContext(context string) { //gd:RenderSceneBuffersRD.clear_context
	Advanced(self).ClearContext(String.Name(String.New(context)))
}

/*
Returns the color texture we are rendering 3D content to. If multiview is used this will be a texture array with all views.
If [param msaa] is [code]true[/code] and MSAA is enabled, this returns the MSAA variant of the buffer.
*/
func (self Instance) GetColorTexture() RID.Texture { //gd:RenderSceneBuffersRD.get_color_texture
	return RID.Texture(Advanced(self).GetColorTexture(false))
}

/*
Returns the color texture we are rendering 3D content to. If multiview is used this will be a texture array with all views.
If [param msaa] is [code]true[/code] and MSAA is enabled, this returns the MSAA variant of the buffer.
*/
func (self Expanded) GetColorTexture(msaa bool) RID.Texture { //gd:RenderSceneBuffersRD.get_color_texture
	return RID.Texture(Advanced(self).GetColorTexture(msaa))
}

/*
Returns the specified layer from the color texture we are rendering 3D content to.
If [param msaa] is [code]true[/code] and MSAA is enabled, this returns the MSAA variant of the buffer.
*/
func (self Instance) GetColorLayer(layer int) RID.Texture { //gd:RenderSceneBuffersRD.get_color_layer
	return RID.Texture(Advanced(self).GetColorLayer(int64(layer), false))
}

/*
Returns the specified layer from the color texture we are rendering 3D content to.
If [param msaa] is [code]true[/code] and MSAA is enabled, this returns the MSAA variant of the buffer.
*/
func (self Expanded) GetColorLayer(layer int, msaa bool) RID.Texture { //gd:RenderSceneBuffersRD.get_color_layer
	return RID.Texture(Advanced(self).GetColorLayer(int64(layer), msaa))
}

/*
Returns the depth texture we are rendering 3D content to. If multiview is used this will be a texture array with all views.
If [param msaa] is [code]true[/code] and MSAA is enabled, this returns the MSAA variant of the buffer.
*/
func (self Instance) GetDepthTexture() RID.Texture { //gd:RenderSceneBuffersRD.get_depth_texture
	return RID.Texture(Advanced(self).GetDepthTexture(false))
}

/*
Returns the depth texture we are rendering 3D content to. If multiview is used this will be a texture array with all views.
If [param msaa] is [code]true[/code] and MSAA is enabled, this returns the MSAA variant of the buffer.
*/
func (self Expanded) GetDepthTexture(msaa bool) RID.Texture { //gd:RenderSceneBuffersRD.get_depth_texture
	return RID.Texture(Advanced(self).GetDepthTexture(msaa))
}

/*
Returns the specified layer from the depth texture we are rendering 3D content to.
If [param msaa] is [code]true[/code] and MSAA is enabled, this returns the MSAA variant of the buffer.
*/
func (self Instance) GetDepthLayer(layer int) RID.Texture { //gd:RenderSceneBuffersRD.get_depth_layer
	return RID.Texture(Advanced(self).GetDepthLayer(int64(layer), false))
}

/*
Returns the specified layer from the depth texture we are rendering 3D content to.
If [param msaa] is [code]true[/code] and MSAA is enabled, this returns the MSAA variant of the buffer.
*/
func (self Expanded) GetDepthLayer(layer int, msaa bool) RID.Texture { //gd:RenderSceneBuffersRD.get_depth_layer
	return RID.Texture(Advanced(self).GetDepthLayer(int64(layer), msaa))
}

/*
Returns the velocity texture we are rendering 3D content to. If multiview is used this will be a texture array with all views.
If [param msaa] is [b]true[/b] and MSAA is enabled, this returns the MSAA variant of the buffer.
*/
func (self Instance) GetVelocityTexture() RID.Texture { //gd:RenderSceneBuffersRD.get_velocity_texture
	return RID.Texture(Advanced(self).GetVelocityTexture(false))
}

/*
Returns the velocity texture we are rendering 3D content to. If multiview is used this will be a texture array with all views.
If [param msaa] is [b]true[/b] and MSAA is enabled, this returns the MSAA variant of the buffer.
*/
func (self Expanded) GetVelocityTexture(msaa bool) RID.Texture { //gd:RenderSceneBuffersRD.get_velocity_texture
	return RID.Texture(Advanced(self).GetVelocityTexture(msaa))
}

/*
Returns the specified layer from the velocity texture we are rendering 3D content to.
*/
func (self Instance) GetVelocityLayer(layer int) RID.Texture { //gd:RenderSceneBuffersRD.get_velocity_layer
	return RID.Texture(Advanced(self).GetVelocityLayer(int64(layer), false))
}

/*
Returns the specified layer from the velocity texture we are rendering 3D content to.
*/
func (self Expanded) GetVelocityLayer(layer int, msaa bool) RID.Texture { //gd:RenderSceneBuffersRD.get_velocity_layer
	return RID.Texture(Advanced(self).GetVelocityLayer(int64(layer), msaa))
}

/*
Returns the render target associated with this buffers object.
*/
func (self Instance) GetRenderTarget() RID.Framebuffer { //gd:RenderSceneBuffersRD.get_render_target
	return RID.Framebuffer(Advanced(self).GetRenderTarget())
}

/*
Returns the view count for the associated viewport.
*/
func (self Instance) GetViewCount() int { //gd:RenderSceneBuffersRD.get_view_count
	return int(int(Advanced(self).GetViewCount()))
}

/*
Returns the internal size of the render buffer (size before upscaling) with which textures are created by default.
*/
func (self Instance) GetInternalSize() Vector2i.XY { //gd:RenderSceneBuffersRD.get_internal_size
	return Vector2i.XY(Advanced(self).GetInternalSize())
}

/*
Returns the target size of the render buffer (size after upscaling).
*/
func (self Instance) GetTargetSize() Vector2i.XY { //gd:RenderSceneBuffersRD.get_target_size
	return Vector2i.XY(Advanced(self).GetTargetSize())
}

/*
Returns the scaling mode used for upscaling.
*/
func (self Instance) GetScaling3dMode() RenderingServer.ViewportScaling3DMode { //gd:RenderSceneBuffersRD.get_scaling_3d_mode
	return RenderingServer.ViewportScaling3DMode(Advanced(self).GetScaling3dMode())
}

/*
Returns the FSR sharpness value used while rendering the 3D content (if [method get_scaling_3d_mode] is an FSR mode).
*/
func (self Instance) GetFsrSharpness() Float.X { //gd:RenderSceneBuffersRD.get_fsr_sharpness
	return Float.X(Float.X(Advanced(self).GetFsrSharpness()))
}

/*
Returns the applied 3D MSAA mode for this viewport.
*/
func (self Instance) GetMsaa3d() RenderingServer.ViewportMSAA { //gd:RenderSceneBuffersRD.get_msaa_3d
	return RenderingServer.ViewportMSAA(Advanced(self).GetMsaa3d())
}

/*
Returns the number of MSAA samples used.
*/
func (self Instance) GetTextureSamples() Rendering.TextureSamples { //gd:RenderSceneBuffersRD.get_texture_samples
	return Rendering.TextureSamples(Advanced(self).GetTextureSamples())
}

/*
Returns the screen-space antialiasing method applied.
*/
func (self Instance) GetScreenSpaceAa() RenderingServer.ViewportScreenSpaceAA { //gd:RenderSceneBuffersRD.get_screen_space_aa
	return RenderingServer.ViewportScreenSpaceAA(Advanced(self).GetScreenSpaceAa())
}

/*
Returns [code]true[/code] if TAA is enabled.
*/
func (self Instance) GetUseTaa() bool { //gd:RenderSceneBuffersRD.get_use_taa
	return bool(Advanced(self).GetUseTaa())
}

/*
Returns [code]true[/code] if debanding is enabled.
*/
func (self Instance) GetUseDebanding() bool { //gd:RenderSceneBuffersRD.get_use_debanding
	return bool(Advanced(self).GetUseDebanding())
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.RenderSceneBuffersRD

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.RenderSceneBuffersRD)(unsafe.Pointer(&obj))
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.RenderSceneBuffersRD)(unsafe.Pointer(&obj))
		return true
	}
	return false
}

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {

	if !gd.Linked {
		var placeholder Instance
		*(*gd.Object)(unsafe.Pointer(&placeholder)) = pointers.Add[gd.Object]([3]uint64{})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(*(*gd.Object)(unsafe.Pointer(&placeholder)), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	object := [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})}
	casted := Instance{*(*gdclass.RenderSceneBuffersRD)(unsafe.Pointer(&object))}
	casted.AsRefCounted()[0].InitRef()
	object[0].Notification(0, false)
	return casted
}

/*
Returns [code]true[/code] if a cached texture exists for this name.
*/
//go:nosplit
func (self class) HasTexture(context String.Name, name String.Name) bool { //gd:RenderSceneBuffersRD.has_texture
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.has_texture, gdextension.SizeBool|(gdextension.SizeStringName<<4)|(gdextension.SizeStringName<<8), unsafe.Pointer(&struct {
		context gdextension.StringName
		name    gdextension.StringName
	}{pointers.Get(gd.InternalStringName(context)), pointers.Get(gd.InternalStringName(name))}))
	var ret = r_ret
	return ret
}

/*
Create a new texture with the given definition and cache this under the given name. Will return the existing texture if it already exists.
*/
//go:nosplit
func (self class) CreateTexture(context String.Name, name String.Name, data_format Rendering.DataFormat, usage_bits int64, texture_samples Rendering.TextureSamples, size Vector2i.XY, layers int64, mipmaps int64, unique bool, discardable bool) RID.Any { //gd:RenderSceneBuffersRD.create_texture
	var r_ret = gdextension.Call[RID.Any](gd.ObjectChecked(self.AsObject()), methods.create_texture, gdextension.SizeRID|(gdextension.SizeStringName<<4)|(gdextension.SizeStringName<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeInt<<16)|(gdextension.SizeInt<<20)|(gdextension.SizeVector2i<<24)|(gdextension.SizeInt<<28)|(gdextension.SizeInt<<32)|(gdextension.SizeBool<<36)|(gdextension.SizeBool<<40), unsafe.Pointer(&struct {
		context         gdextension.StringName
		name            gdextension.StringName
		data_format     Rendering.DataFormat
		usage_bits      int64
		texture_samples Rendering.TextureSamples
		size            Vector2i.XY
		layers          int64
		mipmaps         int64
		unique          bool
		discardable     bool
	}{pointers.Get(gd.InternalStringName(context)), pointers.Get(gd.InternalStringName(name)), data_format, usage_bits, texture_samples, size, layers, mipmaps, unique, discardable}))
	var ret = r_ret
	return ret
}

/*
Create a new texture using the given format and view and cache this under the given name. Will return the existing texture if it already exists.
*/
//go:nosplit
func (self class) CreateTextureFromFormat(context String.Name, name String.Name, format [1]gdclass.RDTextureFormat, view [1]gdclass.RDTextureView, unique bool) RID.Any { //gd:RenderSceneBuffersRD.create_texture_from_format
	var r_ret = gdextension.Call[RID.Any](gd.ObjectChecked(self.AsObject()), methods.create_texture_from_format, gdextension.SizeRID|(gdextension.SizeStringName<<4)|(gdextension.SizeStringName<<8)|(gdextension.SizeObject<<12)|(gdextension.SizeObject<<16)|(gdextension.SizeBool<<20), unsafe.Pointer(&struct {
		context gdextension.StringName
		name    gdextension.StringName
		format  gdextension.Object
		view    gdextension.Object
		unique  bool
	}{pointers.Get(gd.InternalStringName(context)), pointers.Get(gd.InternalStringName(name)), gdextension.Object(gd.ObjectChecked(format[0].AsObject())), gdextension.Object(gd.ObjectChecked(view[0].AsObject())), unique}))
	var ret = r_ret
	return ret
}

/*
Create a new texture view for an existing texture and cache this under the given [param view_name]. Will return the existing texture view if it already exists. Will error if the source texture doesn't exist.
*/
//go:nosplit
func (self class) CreateTextureView(context String.Name, name String.Name, view_name String.Name, view [1]gdclass.RDTextureView) RID.Any { //gd:RenderSceneBuffersRD.create_texture_view
	var r_ret = gdextension.Call[RID.Any](gd.ObjectChecked(self.AsObject()), methods.create_texture_view, gdextension.SizeRID|(gdextension.SizeStringName<<4)|(gdextension.SizeStringName<<8)|(gdextension.SizeStringName<<12)|(gdextension.SizeObject<<16), unsafe.Pointer(&struct {
		context   gdextension.StringName
		name      gdextension.StringName
		view_name gdextension.StringName
		view      gdextension.Object
	}{pointers.Get(gd.InternalStringName(context)), pointers.Get(gd.InternalStringName(name)), pointers.Get(gd.InternalStringName(view_name)), gdextension.Object(gd.ObjectChecked(view[0].AsObject()))}))
	var ret = r_ret
	return ret
}

/*
Returns a cached texture with this name.
*/
//go:nosplit
func (self class) GetTexture(context String.Name, name String.Name) RID.Any { //gd:RenderSceneBuffersRD.get_texture
	var r_ret = gdextension.Call[RID.Any](gd.ObjectChecked(self.AsObject()), methods.get_texture, gdextension.SizeRID|(gdextension.SizeStringName<<4)|(gdextension.SizeStringName<<8), unsafe.Pointer(&struct {
		context gdextension.StringName
		name    gdextension.StringName
	}{pointers.Get(gd.InternalStringName(context)), pointers.Get(gd.InternalStringName(name))}))
	var ret = r_ret
	return ret
}

/*
Returns the texture format information with which a cached texture was created.
*/
//go:nosplit
func (self class) GetTextureFormat(context String.Name, name String.Name) [1]gdclass.RDTextureFormat { //gd:RenderSceneBuffersRD.get_texture_format
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_texture_format, gdextension.SizeObject|(gdextension.SizeStringName<<4)|(gdextension.SizeStringName<<8), unsafe.Pointer(&struct {
		context gdextension.StringName
		name    gdextension.StringName
	}{pointers.Get(gd.InternalStringName(context)), pointers.Get(gd.InternalStringName(name))}))
	var ret = [1]gdclass.RDTextureFormat{gd.PointerWithOwnershipTransferredToGo[gdclass.RDTextureFormat](r_ret)}
	return ret
}

/*
Returns a specific slice (layer or mipmap) for a cached texture.
*/
//go:nosplit
func (self class) GetTextureSlice(context String.Name, name String.Name, layer int64, mipmap int64, layers int64, mipmaps int64) RID.Any { //gd:RenderSceneBuffersRD.get_texture_slice
	var r_ret = gdextension.Call[RID.Any](gd.ObjectChecked(self.AsObject()), methods.get_texture_slice, gdextension.SizeRID|(gdextension.SizeStringName<<4)|(gdextension.SizeStringName<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeInt<<16)|(gdextension.SizeInt<<20)|(gdextension.SizeInt<<24), unsafe.Pointer(&struct {
		context gdextension.StringName
		name    gdextension.StringName
		layer   int64
		mipmap  int64
		layers  int64
		mipmaps int64
	}{pointers.Get(gd.InternalStringName(context)), pointers.Get(gd.InternalStringName(name)), layer, mipmap, layers, mipmaps}))
	var ret = r_ret
	return ret
}

/*
Returns a specific view of a slice (layer or mipmap) for a cached texture.
*/
//go:nosplit
func (self class) GetTextureSliceView(context String.Name, name String.Name, layer int64, mipmap int64, layers int64, mipmaps int64, view [1]gdclass.RDTextureView) RID.Any { //gd:RenderSceneBuffersRD.get_texture_slice_view
	var r_ret = gdextension.Call[RID.Any](gd.ObjectChecked(self.AsObject()), methods.get_texture_slice_view, gdextension.SizeRID|(gdextension.SizeStringName<<4)|(gdextension.SizeStringName<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeInt<<16)|(gdextension.SizeInt<<20)|(gdextension.SizeInt<<24)|(gdextension.SizeObject<<28), unsafe.Pointer(&struct {
		context gdextension.StringName
		name    gdextension.StringName
		layer   int64
		mipmap  int64
		layers  int64
		mipmaps int64
		view    gdextension.Object
	}{pointers.Get(gd.InternalStringName(context)), pointers.Get(gd.InternalStringName(name)), layer, mipmap, layers, mipmaps, gdextension.Object(gd.ObjectChecked(view[0].AsObject()))}))
	var ret = r_ret
	return ret
}

/*
Returns the texture size of a given slice of a cached texture.
*/
//go:nosplit
func (self class) GetTextureSliceSize(context String.Name, name String.Name, mipmap int64) Vector2i.XY { //gd:RenderSceneBuffersRD.get_texture_slice_size
	var r_ret = gdextension.Call[Vector2i.XY](gd.ObjectChecked(self.AsObject()), methods.get_texture_slice_size, gdextension.SizeVector2i|(gdextension.SizeStringName<<4)|(gdextension.SizeStringName<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		context gdextension.StringName
		name    gdextension.StringName
		mipmap  int64
	}{pointers.Get(gd.InternalStringName(context)), pointers.Get(gd.InternalStringName(name)), mipmap}))
	var ret = r_ret
	return ret
}

/*
Frees all buffers related to this context.
*/
//go:nosplit
func (self class) ClearContext(context String.Name) { //gd:RenderSceneBuffersRD.clear_context
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.clear_context, 0|(gdextension.SizeStringName<<4), unsafe.Pointer(&struct{ context gdextension.StringName }{pointers.Get(gd.InternalStringName(context))}))
}

/*
Returns the color texture we are rendering 3D content to. If multiview is used this will be a texture array with all views.
If [param msaa] is [code]true[/code] and MSAA is enabled, this returns the MSAA variant of the buffer.
*/
//go:nosplit
func (self class) GetColorTexture(msaa bool) RID.Any { //gd:RenderSceneBuffersRD.get_color_texture
	var r_ret = gdextension.Call[RID.Any](gd.ObjectChecked(self.AsObject()), methods.get_color_texture, gdextension.SizeRID|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ msaa bool }{msaa}))
	var ret = r_ret
	return ret
}

/*
Returns the specified layer from the color texture we are rendering 3D content to.
If [param msaa] is [code]true[/code] and MSAA is enabled, this returns the MSAA variant of the buffer.
*/
//go:nosplit
func (self class) GetColorLayer(layer int64, msaa bool) RID.Any { //gd:RenderSceneBuffersRD.get_color_layer
	var r_ret = gdextension.Call[RID.Any](gd.ObjectChecked(self.AsObject()), methods.get_color_layer, gdextension.SizeRID|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		layer int64
		msaa  bool
	}{layer, msaa}))
	var ret = r_ret
	return ret
}

/*
Returns the depth texture we are rendering 3D content to. If multiview is used this will be a texture array with all views.
If [param msaa] is [code]true[/code] and MSAA is enabled, this returns the MSAA variant of the buffer.
*/
//go:nosplit
func (self class) GetDepthTexture(msaa bool) RID.Any { //gd:RenderSceneBuffersRD.get_depth_texture
	var r_ret = gdextension.Call[RID.Any](gd.ObjectChecked(self.AsObject()), methods.get_depth_texture, gdextension.SizeRID|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ msaa bool }{msaa}))
	var ret = r_ret
	return ret
}

/*
Returns the specified layer from the depth texture we are rendering 3D content to.
If [param msaa] is [code]true[/code] and MSAA is enabled, this returns the MSAA variant of the buffer.
*/
//go:nosplit
func (self class) GetDepthLayer(layer int64, msaa bool) RID.Any { //gd:RenderSceneBuffersRD.get_depth_layer
	var r_ret = gdextension.Call[RID.Any](gd.ObjectChecked(self.AsObject()), methods.get_depth_layer, gdextension.SizeRID|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		layer int64
		msaa  bool
	}{layer, msaa}))
	var ret = r_ret
	return ret
}

/*
Returns the velocity texture we are rendering 3D content to. If multiview is used this will be a texture array with all views.
If [param msaa] is [b]true[/b] and MSAA is enabled, this returns the MSAA variant of the buffer.
*/
//go:nosplit
func (self class) GetVelocityTexture(msaa bool) RID.Any { //gd:RenderSceneBuffersRD.get_velocity_texture
	var r_ret = gdextension.Call[RID.Any](gd.ObjectChecked(self.AsObject()), methods.get_velocity_texture, gdextension.SizeRID|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ msaa bool }{msaa}))
	var ret = r_ret
	return ret
}

/*
Returns the specified layer from the velocity texture we are rendering 3D content to.
*/
//go:nosplit
func (self class) GetVelocityLayer(layer int64, msaa bool) RID.Any { //gd:RenderSceneBuffersRD.get_velocity_layer
	var r_ret = gdextension.Call[RID.Any](gd.ObjectChecked(self.AsObject()), methods.get_velocity_layer, gdextension.SizeRID|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		layer int64
		msaa  bool
	}{layer, msaa}))
	var ret = r_ret
	return ret
}

/*
Returns the render target associated with this buffers object.
*/
//go:nosplit
func (self class) GetRenderTarget() RID.Any { //gd:RenderSceneBuffersRD.get_render_target
	var r_ret = gdextension.Call[RID.Any](gd.ObjectChecked(self.AsObject()), methods.get_render_target, gdextension.SizeRID, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the view count for the associated viewport.
*/
//go:nosplit
func (self class) GetViewCount() int64 { //gd:RenderSceneBuffersRD.get_view_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_view_count, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the internal size of the render buffer (size before upscaling) with which textures are created by default.
*/
//go:nosplit
func (self class) GetInternalSize() Vector2i.XY { //gd:RenderSceneBuffersRD.get_internal_size
	var r_ret = gdextension.Call[Vector2i.XY](gd.ObjectChecked(self.AsObject()), methods.get_internal_size, gdextension.SizeVector2i, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the target size of the render buffer (size after upscaling).
*/
//go:nosplit
func (self class) GetTargetSize() Vector2i.XY { //gd:RenderSceneBuffersRD.get_target_size
	var r_ret = gdextension.Call[Vector2i.XY](gd.ObjectChecked(self.AsObject()), methods.get_target_size, gdextension.SizeVector2i, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the scaling mode used for upscaling.
*/
//go:nosplit
func (self class) GetScaling3dMode() RenderingServer.ViewportScaling3DMode { //gd:RenderSceneBuffersRD.get_scaling_3d_mode
	var r_ret = gdextension.Call[RenderingServer.ViewportScaling3DMode](gd.ObjectChecked(self.AsObject()), methods.get_scaling_3d_mode, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the FSR sharpness value used while rendering the 3D content (if [method get_scaling_3d_mode] is an FSR mode).
*/
//go:nosplit
func (self class) GetFsrSharpness() float64 { //gd:RenderSceneBuffersRD.get_fsr_sharpness
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_fsr_sharpness, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the applied 3D MSAA mode for this viewport.
*/
//go:nosplit
func (self class) GetMsaa3d() RenderingServer.ViewportMSAA { //gd:RenderSceneBuffersRD.get_msaa_3d
	var r_ret = gdextension.Call[RenderingServer.ViewportMSAA](gd.ObjectChecked(self.AsObject()), methods.get_msaa_3d, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the number of MSAA samples used.
*/
//go:nosplit
func (self class) GetTextureSamples() Rendering.TextureSamples { //gd:RenderSceneBuffersRD.get_texture_samples
	var r_ret = gdextension.Call[Rendering.TextureSamples](gd.ObjectChecked(self.AsObject()), methods.get_texture_samples, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the screen-space antialiasing method applied.
*/
//go:nosplit
func (self class) GetScreenSpaceAa() RenderingServer.ViewportScreenSpaceAA { //gd:RenderSceneBuffersRD.get_screen_space_aa
	var r_ret = gdextension.Call[RenderingServer.ViewportScreenSpaceAA](gd.ObjectChecked(self.AsObject()), methods.get_screen_space_aa, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if TAA is enabled.
*/
//go:nosplit
func (self class) GetUseTaa() bool { //gd:RenderSceneBuffersRD.get_use_taa
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.get_use_taa, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if debanding is enabled.
*/
//go:nosplit
func (self class) GetUseDebanding() bool { //gd:RenderSceneBuffersRD.get_use_debanding
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.get_use_debanding, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}
func (self class) AsRenderSceneBuffersRD() Advanced    { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsRenderSceneBuffersRD() Instance { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsRenderSceneBuffersRD() Instance {
	return self.Super().AsRenderSceneBuffersRD()
}
func (self class) AsRenderSceneBuffers() RenderSceneBuffers.Advanced {
	return *((*RenderSceneBuffers.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsRenderSceneBuffers() RenderSceneBuffers.Instance {
	return self.Super().AsRenderSceneBuffers()
}
func (self Instance) AsRenderSceneBuffers() RenderSceneBuffers.Instance {
	return *((*RenderSceneBuffers.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsRefCounted() [1]gd.RefCounted { return self.Super().AsRefCounted() }
func (self Instance) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(RenderSceneBuffers.Advanced(self.AsRenderSceneBuffers()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(RenderSceneBuffers.Instance(self.AsRenderSceneBuffers()), name)
	}
}
func init() {
	gdclass.Register("RenderSceneBuffersRD", func(ptr gd.Object) any { return *(*Instance)(unsafe.Pointer(&ptr)) })
}
