// Code generated by the generate package DO NOT EDIT

// Package DiscordEmbeddedAppClient provides methods for working with DiscordEmbeddedAppClient object instances.
package DiscordEmbeddedAppClient

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/DiscordEmbeddedAppResponse"
import "graphics.gd/classdb/Node"
import "graphics.gd/classdb/ThirdPartyClient"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
Implementation based on the official Discord Embedded App SDK for JS. Official documentation for this service on [url=https://discord.com/developers/docs/developer-tools/embedded-app-sdk]discord.com/developers/docs/developer-tools/embedded-app-sdk[/url].
*/
type Instance [1]gdclass.DiscordEmbeddedAppClient

func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsDiscordEmbeddedAppClient() Instance
}

/*
Close an Embedded App. Wait for [method DiscordEmbeddedAppClient.is_ready] first.
Discord docs [url=Discord docs [url=https://discord.com/developers/docs/developer-tools/embedded-app-sdk#close]discord.com/developers/docs/developer-tools/embedded-app-sdk#close[/url]
[codeblocks]
[gdscript]
var res :DiscordEmbeddedAppResult = await close(1000, "You exited app.").finished
if res.has_error():

	print(res.error)

else:

	print(res.data)

[/gdscript]
[/codeblocks]
*/
func (self Instance) Close(code int, message string) { //gd:DiscordEmbeddedAppClient.close
	Advanced(self).Close(int64(code), String.New(message))
}

/*
Authenticate an existing client with your app. Wait for [method DiscordEmbeddedAppClient.is_ready] first.
Discord docs [url=https://discord.com/developers/docs/developer-tools/embedded-app-sdk#authenticate]discord.com/developers/docs/developer-tools/embedded-app-sdk#authenticate[/url]
[codeblocks]
[gdscript]
var res :DiscordEmbeddedAppResult = await authenticate("ACCESS_TOKEN").finished
if res.has_error():

	print(res.error)

else:

	print(res.data)

[/gdscript]
[/codeblocks]
Returns a [DiscordEmbeddedAppResponse] object that has a [signal DiscordEmbeddedAppResponse.finished] signal that is emitted when finished.
*/
func (self Instance) Authenticate(access_token string) DiscordEmbeddedAppResponse.Instance { //gd:DiscordEmbeddedAppClient.authenticate
	return DiscordEmbeddedAppResponse.Instance(Advanced(self).Authenticate(String.New(access_token)))
}

/*
Authorize a new client with your app. Needs [member client_id] to be set.
Discord docs [url=https://discord.com/developers/docs/developer-tools/embedded-app-sdk#authorize]discord.com/developers/docs/developer-tools/embedded-app-sdk#authorize[/url]
[codeblocks]
[gdscript]
var res :DiscordEmbeddedAppResult = await authorize("code", "", "none", ["identity", "guilds"]).finished
if res.has_error():

	print(res.error)

else:

	print(res.data)

[/gdscript]
[/codeblocks]
Returns a [DiscordEmbeddedAppResponse] object that has a [signal DiscordEmbeddedAppResponse.finished] signal that is emitted when finished.
*/
func (self Instance) Authorize(response_type string, state string, prompt string, scope []any) DiscordEmbeddedAppResponse.Instance { //gd:DiscordEmbeddedAppClient.authorize
	return DiscordEmbeddedAppResponse.Instance(Advanced(self).Authorize(String.New(response_type), String.New(state), String.New(prompt), gd.EngineArrayFromSlice(scope)))
}

/*
Forward logs to your own logger. Wait for [method DiscordEmbeddedAppClient.is_ready] first.
Discord docs [url=Discord docs [url=https://discord.com/developers/docs/developer-tools/embedded-app-sdk#capturelog]discord.com/developers/docs/developer-tools/embedded-app-sdk#capturelog[/url]
[codeblocks]
[gdscript]
var res :DiscordEmbeddedAppResult = await capture_log("log", "This is my log message!").finished
if res.has_error():

	print(res.error)

else:

	print(res.data)

[/gdscript]
[/codeblocks]
Returns a [DiscordEmbeddedAppResponse] object that has a [signal DiscordEmbeddedAppResponse.finished] signal that is emitted when finished.
*/
func (self Instance) CaptureLog(level string, message string) DiscordEmbeddedAppResponse.Instance { //gd:DiscordEmbeddedAppClient.capture_log
	return DiscordEmbeddedAppResponse.Instance(Advanced(self).CaptureLog(String.New(level), String.New(message)))
}

/*
Presents a modal dialog to allow enabling of hardware acceleration. Wait for [method DiscordEmbeddedAppClient.is_ready] first.
Discord docs [url=Discord docs [url=https://discord.com/developers/docs/developer-tools/embedded-app-sdk#encouragehardwareacceleration]discord.com/developers/docs/developer-tools/embedded-app-sdk#encouragehardwareacceleration[/url]
[codeblocks]
[gdscript]
var res :DiscordEmbeddedAppResult = await encourage_hardware_acceleration().finished
if res.has_error():

	print(res.error)

else:

	print(res.data)

[/gdscript]
[/codeblocks]
Returns a [DiscordEmbeddedAppResponse] object that has a [signal DiscordEmbeddedAppResponse.finished] signal that is emitted when finished.
*/
func (self Instance) EncourageHardwareAcceleration() DiscordEmbeddedAppResponse.Instance { //gd:DiscordEmbeddedAppClient.encourage_hardware_acceleration
	return DiscordEmbeddedAppResponse.Instance(Advanced(self).EncourageHardwareAcceleration())
}

/*
Returns information about the channel, per the channel_id. Wait for [method DiscordEmbeddedAppClient.is_ready] first.
Discord docs [url=Discord docs [url=https://discord.com/developers/docs/developer-tools/embedded-app-sdk#getchannel]discord.com/developers/docs/developer-tools/embedded-app-sdk#getchannel[/url]
[codeblocks]
[gdscript]
var res :DiscordEmbeddedAppResult = await get_channel("channel_id").finished
if res.has_error():

	print(res.error)

else:

	print(res.data)

[/gdscript]
[/codeblocks]
Returns a [DiscordEmbeddedAppResponse] object that has a [signal DiscordEmbeddedAppResponse.finished] signal that is emitted when finished.
*/
func (self Instance) GetChannel(channel_id string) DiscordEmbeddedAppResponse.Instance { //gd:DiscordEmbeddedAppClient.get_channel
	return DiscordEmbeddedAppResponse.Instance(Advanced(self).GetChannel(String.New(channel_id)))
}

/*
Returns permissions for the current user in the currently connected channel. Wait for [method DiscordEmbeddedAppClient.is_ready] first.
Discord docs [url=Discord docs [url=https://discord.com/developers/docs/developer-tools/embedded-app-sdk#getchannelpermissions]discord.com/developers/docs/developer-tools/embedded-app-sdk#getchannelpermissions[/url]
[codeblocks]
[gdscript]
var res :DiscordEmbeddedAppResult = await get_channel_permissions().finished
if res.has_error():

	print(res.error)

else:

	print(res.data)

[/gdscript]
[/codeblocks]
Returns a [DiscordEmbeddedAppResponse] object that has a [signal DiscordEmbeddedAppResponse.finished] signal that is emitted when finished.
*/
func (self Instance) GetChannelPermissions() DiscordEmbeddedAppResponse.Instance { //gd:DiscordEmbeddedAppClient.get_channel_permissions
	return DiscordEmbeddedAppResponse.Instance(Advanced(self).GetChannelPermissions())
}

/*
Returns a list of entitlements for the current user. Wait for [method DiscordEmbeddedAppClient.is_ready] first.
Discord docs [url=Discord docs [url=https://discord.com/developers/docs/developer-tools/embedded-app-sdk#getentitlements]discord.com/developers/docs/developer-tools/embedded-app-sdk#getentitlements[/url]
[codeblocks]
[gdscript]
var res :DiscordEmbeddedAppResult = await get_entitlements().finished
if res.has_error():

	print(res.error)

else:

	print(res.data)

[/gdscript]
[/codeblocks]
Returns a [DiscordEmbeddedAppResponse] object that has a [signal DiscordEmbeddedAppResponse.finished] signal that is emitted when finished.
*/
func (self Instance) GetEntitlements() DiscordEmbeddedAppResponse.Instance { //gd:DiscordEmbeddedAppClient.get_entitlements
	return DiscordEmbeddedAppResponse.Instance(Advanced(self).GetEntitlements())
}

/*
Returns all participants connected to the instance. Wait for [method DiscordEmbeddedAppClient.is_ready] first.
Discord docs [url=Discord docs [url=https://discord.com/developers/docs/developer-tools/embedded-app-sdk#getinstanceconnectedparticipants]discord.com/developers/docs/developer-tools/embedded-app-sdk#getinstanceconnectedparticipants[/url]
[codeblocks]
[gdscript]
var res :DiscordEmbeddedAppResult = await get_instance_connected_participants().finished
if res.has_error():

	print(res.error)

else:

	print(res.data)

[/gdscript]
[/codeblocks]
Returns a [DiscordEmbeddedAppResponse] object that has a [signal DiscordEmbeddedAppResponse.finished] signal that is emitted when finished.
*/
func (self Instance) GetInstanceConnectedParticipants() DiscordEmbeddedAppResponse.Instance { //gd:DiscordEmbeddedAppClient.get_instance_connected_participants
	return DiscordEmbeddedAppResponse.Instance(Advanced(self).GetInstanceConnectedParticipants())
}

/*
Returns information about supported platform behaviors. Wait for [method DiscordEmbeddedAppClient.is_ready] first.
Discord docs [url=Discord docs [url=https://discord.com/developers/docs/developer-tools/embedded-app-sdk#getplatformbehaviors]discord.com/developers/docs/developer-tools/embedded-app-sdk#getplatformbehaviors[/url]
[codeblocks]
[gdscript]
var res :DiscordEmbeddedAppResult = await get_platform_behaviours().finished
if res.has_error():

	print(res.error)

else:

	print(res.data)

[/gdscript]
[/codeblocks]
Returns a [DiscordEmbeddedAppResponse] object that has a [signal DiscordEmbeddedAppResponse.finished] signal that is emitted when finished.
*/
func (self Instance) GetPlatformBehaviours() DiscordEmbeddedAppResponse.Instance { //gd:DiscordEmbeddedAppClient.get_platform_behaviours
	return DiscordEmbeddedAppResponse.Instance(Advanced(self).GetPlatformBehaviours())
}

/*
Returns a list of your app's SKUs. Wait for [method DiscordEmbeddedAppClient.is_ready] first.
Discord docs [url=Discord docs [url=https://discord.com/developers/docs/developer-tools/embedded-app-sdk#getskus]discord.com/developers/docs/developer-tools/embedded-app-sdk#getskus[/url]
[codeblocks]
[gdscript]
var res :DiscordEmbeddedAppResult = await get_skus().finished
if res.has_error():

	print(res.error)

else:

	print(res.data)

[/gdscript]
[/codeblocks]
Returns a [DiscordEmbeddedAppResponse] object that has a [signal DiscordEmbeddedAppResponse.finished] signal that is emitted when finished.
*/
func (self Instance) GetSkus() DiscordEmbeddedAppResponse.Instance { //gd:DiscordEmbeddedAppClient.get_skus
	return DiscordEmbeddedAppResponse.Instance(Advanced(self).GetSkus())
}

/*
Presents the file upload flow in the Discord client. Wait for [method DiscordEmbeddedAppClient.is_ready] first.
Discord docs [url=Discord docs [url=https://discord.com/developers/docs/developer-tools/embedded-app-sdk#initiateimageupload]discord.com/developers/docs/developer-tools/embedded-app-sdk#initiateimageupload[/url]
[codeblocks]
[gdscript]
var res :DiscordEmbeddedAppResult = await initiate_image_upload().finished
if res.has_error():

	print(res.error)

else:

	print(res.data)

[/gdscript]
[/codeblocks]
Returns a [DiscordEmbeddedAppResponse] object that has a [signal DiscordEmbeddedAppResponse.finished] signal that is emitted when finished.
*/
func (self Instance) InitiateImageUpload() DiscordEmbeddedAppResponse.Instance { //gd:DiscordEmbeddedAppClient.initiate_image_upload
	return DiscordEmbeddedAppResponse.Instance(Advanced(self).InitiateImageUpload())
}

/*
Allows for opening an external link from within the Discord client. Wait for [method DiscordEmbeddedAppClient.is_ready] first.
Discord docs [url=Discord docs [url=https://discord.com/developers/docs/developer-tools/embedded-app-sdk#openexternallink]discord.com/developers/docs/developer-tools/embedded-app-sdk#openexternallink[/url]
[codeblocks]
[gdscript]
var res :DiscordEmbeddedAppResult = await open_external_link("url").finished
if res.has_error():

	print(res.error)

else:

	print(res.data)

[/gdscript]
[/codeblocks]
Returns a [DiscordEmbeddedAppResponse] object that has a [signal DiscordEmbeddedAppResponse.finished] signal that is emitted when finished.
*/
func (self Instance) OpenExternalLink(url string) DiscordEmbeddedAppResponse.Instance { //gd:DiscordEmbeddedAppClient.open_external_link
	return DiscordEmbeddedAppResponse.Instance(Advanced(self).OpenExternalLink(String.New(url)))
}

/*
Presents a modal dialog with Channel Invite UI without requiring additional OAuth scopes. Wait for [method DiscordEmbeddedAppClient.is_ready] first.
Discord docs [url=Discord docs [url=https://discord.com/developers/docs/developer-tools/embedded-app-sdk#openinvitedialog]discord.com/developers/docs/developer-tools/embedded-app-sdk#openinvitedialog[/url]
[codeblocks]
[gdscript]
var res :DiscordEmbeddedAppResult = await open_invite_dialog().finished
if res.has_error():

	print(res.error)

else:

	print(res.data)

[/gdscript]
[/codeblocks]
Returns a [DiscordEmbeddedAppResponse] object that has a [signal DiscordEmbeddedAppResponse.finished] signal that is emitted when finished.
*/
func (self Instance) OpenInviteDialog() DiscordEmbeddedAppResponse.Instance { //gd:DiscordEmbeddedAppClient.open_invite_dialog
	return DiscordEmbeddedAppResponse.Instance(Advanced(self).OpenInviteDialog())
}

/*
Presents a modal dialog to share media to a channel or DM. Wait for [method DiscordEmbeddedAppClient.is_ready] first.
Discord docs [url=Discord docs [url=https://discord.com/developers/docs/developer-tools/embedded-app-sdk#opensharemomentdialog]discord.com/developers/docs/developer-tools/embedded-app-sdk#opensharemomentdialog[/url]
[codeblocks]
[gdscript]
var res :DiscordEmbeddedAppResult = await open_share_moment_dialog().finished
if res.has_error():

	print(res.error)

else:

	print(res.data)

[/gdscript]
[/codeblocks]
Returns a [DiscordEmbeddedAppResponse] object that has a [signal DiscordEmbeddedAppResponse.finished] signal that is emitted when finished.
*/
func (self Instance) OpenShareMomentDialog(media_url string) DiscordEmbeddedAppResponse.Instance { //gd:DiscordEmbeddedAppClient.open_share_moment_dialog
	return DiscordEmbeddedAppResponse.Instance(Advanced(self).OpenShareMomentDialog(String.New(media_url)))
}

/*
Modifies how your activity's rich presence is displayed in the Discord client. Wait for [method DiscordEmbeddedAppClient.is_ready] first.
Discord docs [url=Discord docs [url=https://discord.com/developers/docs/developer-tools/embedded-app-sdk#setactivity]discord.com/developers/docs/developer-tools/embedded-app-sdk#setactivity[/url]
[codeblocks]
[gdscript]
var res :DiscordEmbeddedAppResult = await set_activity({"type": 0, "details": "Details", "state": "Playing"}).finished
if res.has_error():

	print(res.error)

else:

	print(res.data)

[/gdscript]
[/codeblocks]
Returns a [DiscordEmbeddedAppResponse] object that has a [signal DiscordEmbeddedAppResponse.finished] signal that is emitted when finished.
*/
func (self Instance) SetActivity(activity map[any]any) DiscordEmbeddedAppResponse.Instance { //gd:DiscordEmbeddedAppClient.set_activity
	return DiscordEmbeddedAppResponse.Instance(Advanced(self).SetActivity(gd.DictionaryFromMap(activity)))
}

/*
Set whether or not the PIP (picture-in-picture) is interactive. Wait for [method DiscordEmbeddedAppClient.is_ready] first.
Discord docs [url=Discord docs [url=https://discord.com/developers/docs/developer-tools/embedded-app-sdk#setconfig]discord.com/developers/docs/developer-tools/embedded-app-sdk#setconfig[/url]
[codeblocks]
[gdscript]
var res :DiscordEmbeddedAppResult = await set_config(true).finished
if res.has_error():

	print(res.error)

else:

	print(res.data)

[/gdscript]
[/codeblocks]
Returns a [DiscordEmbeddedAppResponse] object that has a [signal DiscordEmbeddedAppResponse.finished] signal that is emitted when finished.
*/
func (self Instance) SetConfig(use_interactive_pip bool) DiscordEmbeddedAppResponse.Instance { //gd:DiscordEmbeddedAppClient.set_config
	return DiscordEmbeddedAppResponse.Instance(Advanced(self).SetConfig(use_interactive_pip))
}

/*
Set options for orientation and picture-in-picture (PIP) modes. Wait for [method DiscordEmbeddedAppClient.is_ready] first.
Discord docs [url=Discord docs [url=https://discord.com/developers/docs/developer-tools/embedded-app-sdk#setorientationlockstate]discord.com/developers/docs/developer-tools/embedded-app-sdk#setorientationlockstate[/url]
[codeblocks]
[gdscript]
var res :DiscordEmbeddedAppResult = await set_orientation_lock_state(DiscordEmbeddedAppClient.DISCORD_EMBEDDED_APP_ORIENTATION_LOCK_STATE_UNLOCKED, DiscordEmbeddedAppClient.DISCORD_EMBEDDED_APP_ORIENTATION_LOCK_STATE_UNLOCKED, DiscordEmbeddedAppClient.DISCORD_EMBEDDED_APP_ORIENTATION_LOCK_STATE_UNLOCKED).finished
if res.has_error():

	print(res.error)

else:

	print(res.data)

[/gdscript]
[/codeblocks]
Returns a [DiscordEmbeddedAppResponse] object that has a [signal DiscordEmbeddedAppResponse.finished] signal that is emitted when finished.
*/
func (self Instance) SetOrientationLockState(lock_state DiscordEmbeddedAppOrientationLockState, picture_in_picture_lock_state DiscordEmbeddedAppOrientationLockState, grid_lock_state DiscordEmbeddedAppOrientationLockState) DiscordEmbeddedAppResponse.Instance { //gd:DiscordEmbeddedAppClient.set_orientation_lock_state
	return DiscordEmbeddedAppResponse.Instance(Advanced(self).SetOrientationLockState(lock_state, picture_in_picture_lock_state, grid_lock_state))
}

/*
Launches the purchase flow for a specific SKU, per the sku_id. Wait for [method DiscordEmbeddedAppClient.is_ready] first.
Discord docs [url=Discord docs [url=https://discord.com/developers/docs/developer-tools/embedded-app-sdk#startpurchase]discord.com/developers/docs/developer-tools/embedded-app-sdk#startpurchase[/url]
[codeblocks]
[gdscript]
var res :DiscordEmbeddedAppResult = await start_purchase("sku_id", "pid").finished
if res.has_error():

	print(res.error)

else:

	print(res.data)

[/gdscript]
[/codeblocks]
Returns a [DiscordEmbeddedAppResponse] object that has a [signal DiscordEmbeddedAppResponse.finished] signal that is emitted when finished.
*/
func (self Instance) StartPurchase(sku_id string, pid string) DiscordEmbeddedAppResponse.Instance { //gd:DiscordEmbeddedAppClient.start_purchase
	return DiscordEmbeddedAppResponse.Instance(Advanced(self).StartPurchase(String.New(sku_id), String.New(pid)))
}

/*
Returns the current user's locale. Wait for [method DiscordEmbeddedAppClient.is_ready] first.
Discord docs [url=Discord docs [url=https://discord.com/developers/docs/developer-tools/embedded-app-sdk#usersettingsgetlocale]discord.com/developers/docs/developer-tools/embedded-app-sdk#usersettingsgetlocale[/url]
[codeblocks]
[gdscript]
var res :DiscordEmbeddedAppResult = await user_settings_get_locale().finished
if res.has_error():

	print(res.error)

else:

	print(res.data)

[/gdscript]
[/codeblocks]
Returns a [DiscordEmbeddedAppResponse] object that has a [signal DiscordEmbeddedAppResponse.finished] signal that is emitted when finished.
*/
func (self Instance) UserSettingsGetLocale() DiscordEmbeddedAppResponse.Instance { //gd:DiscordEmbeddedAppClient.user_settings_get_locale
	return DiscordEmbeddedAppResponse.Instance(Advanced(self).UserSettingsGetLocale())
}

/*
Subscribes to all events. Needs to be done after [method authenticate]. Wait for [method DiscordEmbeddedAppClient.is_ready] first.
[codeblocks]
[gdscript]
subscribe_to_all_events()
[/gdscript]
[/codeblocks]
*/
func (self Instance) SubscribeToAllEvents() { //gd:DiscordEmbeddedAppClient.subscribe_to_all_events
	Advanced(self).SubscribeToAllEvents()
}

/*
Returns whether or not the client is ready.
Discord docs [url=https://discord.com/developers/docs/developer-tools/embedded-app-sdk#ready]discord.com/developers/docs/developer-tools/embedded-app-sdk#ready[/url]
[codeblocks]
[gdscript]
var res :DiscordEmbeddedAppResult = await is_ready().finished
if res.has_error():

	print(res.error)

else:

	print(res.data)

[/gdscript]
[/codeblocks]
Returns a [DiscordEmbeddedAppResponse] object that has a [signal DiscordEmbeddedAppResponse.finished] signal that is emitted when finished.
*/
func (self Instance) IsReady() DiscordEmbeddedAppResponse.Instance { //gd:DiscordEmbeddedAppClient.is_ready
	return DiscordEmbeddedAppResponse.Instance(Advanced(self).IsReady())
}

/*
Returns whether or not the current environment is Discord environment.
[codeblocks]
[gdscript]
if is_discord_environment():

	print("This is discord environment")

[/gdscript]
[/codeblocks]
*/
func (self Instance) IsDiscordEnvironment() bool { //gd:DiscordEmbeddedAppClient.is_discord_environment
	return bool(Advanced(self).IsDiscordEnvironment())
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.DiscordEmbeddedAppClient

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {
	object := gd.Global.ClassDB.ConstructObject(gd.NewStringName("DiscordEmbeddedAppClient"))
	casted := Instance{*(*gdclass.DiscordEmbeddedAppClient)(unsafe.Pointer(&object))}
	return casted
}

func (self Instance) UserId() string {
	return string(class(self).GetUserId().String())
}

func (self Instance) ClientId() string {
	return string(class(self).GetClientId().String())
}

func (self Instance) UserInstanceId() string {
	return string(class(self).GetUserInstanceId().String())
}

func (self Instance) CustomId() string {
	return string(class(self).GetCustomId().String())
}

func (self Instance) ReferrerId() string {
	return string(class(self).GetReferrerId().String())
}

func (self Instance) Platform() string {
	return string(class(self).GetPlatform().String())
}

func (self Instance) GuildId() string {
	return string(class(self).GetGuildId().String())
}

func (self Instance) ChannelId() string {
	return string(class(self).GetChannelId().String())
}

func (self Instance) LocationId() string {
	return string(class(self).GetLocationId().String())
}

func (self Instance) SdkVersion() string {
	return string(class(self).GetSdkVersion().String())
}

func (self Instance) MobileAppVersion() string {
	return string(class(self).GetMobileAppVersion().String())
}

func (self Instance) FrameId() string {
	return string(class(self).GetFrameId().String())
}

/*
Close an Embedded App. Wait for [method DiscordEmbeddedAppClient.is_ready] first.
Discord docs [url=Discord docs [url=https://discord.com/developers/docs/developer-tools/embedded-app-sdk#close]discord.com/developers/docs/developer-tools/embedded-app-sdk#close[/url]
[codeblocks]
[gdscript]
var res :DiscordEmbeddedAppResult = await close(1000, "You exited app.").finished
if res.has_error():
    print(res.error)
else:
    print(res.data)
[/gdscript]
[/codeblocks]
*/
//go:nosplit
func (self class) Close(code int64, message String.Readable) { //gd:DiscordEmbeddedAppClient.close
	var frame = callframe.New()
	callframe.Arg(frame, code)
	callframe.Arg(frame, pointers.Get(gd.InternalString(message)))
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.DiscordEmbeddedAppClient.Bind_close, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Authenticate an existing client with your app. Wait for [method DiscordEmbeddedAppClient.is_ready] first.
Discord docs [url=https://discord.com/developers/docs/developer-tools/embedded-app-sdk#authenticate]discord.com/developers/docs/developer-tools/embedded-app-sdk#authenticate[/url]
[codeblocks]
[gdscript]
var res :DiscordEmbeddedAppResult = await authenticate("ACCESS_TOKEN").finished
if res.has_error():
    print(res.error)
else:
    print(res.data)
[/gdscript]
[/codeblocks]
Returns a [DiscordEmbeddedAppResponse] object that has a [signal DiscordEmbeddedAppResponse.finished] signal that is emitted when finished.
*/
//go:nosplit
func (self class) Authenticate(access_token String.Readable) [1]gdclass.DiscordEmbeddedAppResponse { //gd:DiscordEmbeddedAppClient.authenticate
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(access_token)))
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.DiscordEmbeddedAppClient.Bind_authenticate, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.DiscordEmbeddedAppResponse{gd.PointerWithOwnershipTransferredToGo[gdclass.DiscordEmbeddedAppResponse](r_ret.Get())}
	frame.Free()
	return ret
}

/*
Authorize a new client with your app. Needs [member client_id] to be set.
Discord docs [url=https://discord.com/developers/docs/developer-tools/embedded-app-sdk#authorize]discord.com/developers/docs/developer-tools/embedded-app-sdk#authorize[/url]
[codeblocks]
[gdscript]
var res :DiscordEmbeddedAppResult = await authorize("code", "", "none", ["identity", "guilds"]).finished
if res.has_error():
    print(res.error)
else:
    print(res.data)
[/gdscript]
[/codeblocks]
Returns a [DiscordEmbeddedAppResponse] object that has a [signal DiscordEmbeddedAppResponse.finished] signal that is emitted when finished.
*/
//go:nosplit
func (self class) Authorize(response_type String.Readable, state String.Readable, prompt String.Readable, scope Array.Any) [1]gdclass.DiscordEmbeddedAppResponse { //gd:DiscordEmbeddedAppClient.authorize
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(response_type)))
	callframe.Arg(frame, pointers.Get(gd.InternalString(state)))
	callframe.Arg(frame, pointers.Get(gd.InternalString(prompt)))
	callframe.Arg(frame, pointers.Get(gd.InternalArray(scope)))
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.DiscordEmbeddedAppClient.Bind_authorize, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.DiscordEmbeddedAppResponse{gd.PointerWithOwnershipTransferredToGo[gdclass.DiscordEmbeddedAppResponse](r_ret.Get())}
	frame.Free()
	return ret
}

/*
Forward logs to your own logger. Wait for [method DiscordEmbeddedAppClient.is_ready] first.
Discord docs [url=Discord docs [url=https://discord.com/developers/docs/developer-tools/embedded-app-sdk#capturelog]discord.com/developers/docs/developer-tools/embedded-app-sdk#capturelog[/url]
[codeblocks]
[gdscript]
var res :DiscordEmbeddedAppResult = await capture_log("log", "This is my log message!").finished
if res.has_error():
    print(res.error)
else:
    print(res.data)
[/gdscript]
[/codeblocks]
Returns a [DiscordEmbeddedAppResponse] object that has a [signal DiscordEmbeddedAppResponse.finished] signal that is emitted when finished.
*/
//go:nosplit
func (self class) CaptureLog(level String.Readable, message String.Readable) [1]gdclass.DiscordEmbeddedAppResponse { //gd:DiscordEmbeddedAppClient.capture_log
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(level)))
	callframe.Arg(frame, pointers.Get(gd.InternalString(message)))
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.DiscordEmbeddedAppClient.Bind_capture_log, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.DiscordEmbeddedAppResponse{gd.PointerWithOwnershipTransferredToGo[gdclass.DiscordEmbeddedAppResponse](r_ret.Get())}
	frame.Free()
	return ret
}

/*
Presents a modal dialog to allow enabling of hardware acceleration. Wait for [method DiscordEmbeddedAppClient.is_ready] first.
Discord docs [url=Discord docs [url=https://discord.com/developers/docs/developer-tools/embedded-app-sdk#encouragehardwareacceleration]discord.com/developers/docs/developer-tools/embedded-app-sdk#encouragehardwareacceleration[/url]
[codeblocks]
[gdscript]
var res :DiscordEmbeddedAppResult = await encourage_hardware_acceleration().finished
if res.has_error():
    print(res.error)
else:
    print(res.data)
[/gdscript]
[/codeblocks]
Returns a [DiscordEmbeddedAppResponse] object that has a [signal DiscordEmbeddedAppResponse.finished] signal that is emitted when finished.
*/
//go:nosplit
func (self class) EncourageHardwareAcceleration() [1]gdclass.DiscordEmbeddedAppResponse { //gd:DiscordEmbeddedAppClient.encourage_hardware_acceleration
	var frame = callframe.New()
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.DiscordEmbeddedAppClient.Bind_encourage_hardware_acceleration, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.DiscordEmbeddedAppResponse{gd.PointerWithOwnershipTransferredToGo[gdclass.DiscordEmbeddedAppResponse](r_ret.Get())}
	frame.Free()
	return ret
}

/*
Returns information about the channel, per the channel_id. Wait for [method DiscordEmbeddedAppClient.is_ready] first.
Discord docs [url=Discord docs [url=https://discord.com/developers/docs/developer-tools/embedded-app-sdk#getchannel]discord.com/developers/docs/developer-tools/embedded-app-sdk#getchannel[/url]
[codeblocks]
[gdscript]
var res :DiscordEmbeddedAppResult = await get_channel("channel_id").finished
if res.has_error():
    print(res.error)
else:
    print(res.data)
[/gdscript]
[/codeblocks]
Returns a [DiscordEmbeddedAppResponse] object that has a [signal DiscordEmbeddedAppResponse.finished] signal that is emitted when finished.
*/
//go:nosplit
func (self class) GetChannel(channel_id String.Readable) [1]gdclass.DiscordEmbeddedAppResponse { //gd:DiscordEmbeddedAppClient.get_channel
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(channel_id)))
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.DiscordEmbeddedAppClient.Bind_get_channel, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.DiscordEmbeddedAppResponse{gd.PointerWithOwnershipTransferredToGo[gdclass.DiscordEmbeddedAppResponse](r_ret.Get())}
	frame.Free()
	return ret
}

/*
Returns permissions for the current user in the currently connected channel. Wait for [method DiscordEmbeddedAppClient.is_ready] first.
Discord docs [url=Discord docs [url=https://discord.com/developers/docs/developer-tools/embedded-app-sdk#getchannelpermissions]discord.com/developers/docs/developer-tools/embedded-app-sdk#getchannelpermissions[/url]
[codeblocks]
[gdscript]
var res :DiscordEmbeddedAppResult = await get_channel_permissions().finished
if res.has_error():
    print(res.error)
else:
    print(res.data)
[/gdscript]
[/codeblocks]
Returns a [DiscordEmbeddedAppResponse] object that has a [signal DiscordEmbeddedAppResponse.finished] signal that is emitted when finished.
*/
//go:nosplit
func (self class) GetChannelPermissions() [1]gdclass.DiscordEmbeddedAppResponse { //gd:DiscordEmbeddedAppClient.get_channel_permissions
	var frame = callframe.New()
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.DiscordEmbeddedAppClient.Bind_get_channel_permissions, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.DiscordEmbeddedAppResponse{gd.PointerWithOwnershipTransferredToGo[gdclass.DiscordEmbeddedAppResponse](r_ret.Get())}
	frame.Free()
	return ret
}

/*
Returns a list of entitlements for the current user. Wait for [method DiscordEmbeddedAppClient.is_ready] first.
Discord docs [url=Discord docs [url=https://discord.com/developers/docs/developer-tools/embedded-app-sdk#getentitlements]discord.com/developers/docs/developer-tools/embedded-app-sdk#getentitlements[/url]
[codeblocks]
[gdscript]
var res :DiscordEmbeddedAppResult = await get_entitlements().finished
if res.has_error():
    print(res.error)
else:
    print(res.data)
[/gdscript]
[/codeblocks]
Returns a [DiscordEmbeddedAppResponse] object that has a [signal DiscordEmbeddedAppResponse.finished] signal that is emitted when finished.
*/
//go:nosplit
func (self class) GetEntitlements() [1]gdclass.DiscordEmbeddedAppResponse { //gd:DiscordEmbeddedAppClient.get_entitlements
	var frame = callframe.New()
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.DiscordEmbeddedAppClient.Bind_get_entitlements, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.DiscordEmbeddedAppResponse{gd.PointerWithOwnershipTransferredToGo[gdclass.DiscordEmbeddedAppResponse](r_ret.Get())}
	frame.Free()
	return ret
}

/*
Returns all participants connected to the instance. Wait for [method DiscordEmbeddedAppClient.is_ready] first.
Discord docs [url=Discord docs [url=https://discord.com/developers/docs/developer-tools/embedded-app-sdk#getinstanceconnectedparticipants]discord.com/developers/docs/developer-tools/embedded-app-sdk#getinstanceconnectedparticipants[/url]
[codeblocks]
[gdscript]
var res :DiscordEmbeddedAppResult = await get_instance_connected_participants().finished
if res.has_error():
    print(res.error)
else:
    print(res.data)
[/gdscript]
[/codeblocks]
Returns a [DiscordEmbeddedAppResponse] object that has a [signal DiscordEmbeddedAppResponse.finished] signal that is emitted when finished.
*/
//go:nosplit
func (self class) GetInstanceConnectedParticipants() [1]gdclass.DiscordEmbeddedAppResponse { //gd:DiscordEmbeddedAppClient.get_instance_connected_participants
	var frame = callframe.New()
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.DiscordEmbeddedAppClient.Bind_get_instance_connected_participants, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.DiscordEmbeddedAppResponse{gd.PointerWithOwnershipTransferredToGo[gdclass.DiscordEmbeddedAppResponse](r_ret.Get())}
	frame.Free()
	return ret
}

/*
Returns information about supported platform behaviors. Wait for [method DiscordEmbeddedAppClient.is_ready] first.
Discord docs [url=Discord docs [url=https://discord.com/developers/docs/developer-tools/embedded-app-sdk#getplatformbehaviors]discord.com/developers/docs/developer-tools/embedded-app-sdk#getplatformbehaviors[/url]
[codeblocks]
[gdscript]
var res :DiscordEmbeddedAppResult = await get_platform_behaviours().finished
if res.has_error():
    print(res.error)
else:
    print(res.data)
[/gdscript]
[/codeblocks]
Returns a [DiscordEmbeddedAppResponse] object that has a [signal DiscordEmbeddedAppResponse.finished] signal that is emitted when finished.
*/
//go:nosplit
func (self class) GetPlatformBehaviours() [1]gdclass.DiscordEmbeddedAppResponse { //gd:DiscordEmbeddedAppClient.get_platform_behaviours
	var frame = callframe.New()
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.DiscordEmbeddedAppClient.Bind_get_platform_behaviours, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.DiscordEmbeddedAppResponse{gd.PointerWithOwnershipTransferredToGo[gdclass.DiscordEmbeddedAppResponse](r_ret.Get())}
	frame.Free()
	return ret
}

/*
Returns a list of your app's SKUs. Wait for [method DiscordEmbeddedAppClient.is_ready] first.
Discord docs [url=Discord docs [url=https://discord.com/developers/docs/developer-tools/embedded-app-sdk#getskus]discord.com/developers/docs/developer-tools/embedded-app-sdk#getskus[/url]
[codeblocks]
[gdscript]
var res :DiscordEmbeddedAppResult = await get_skus().finished
if res.has_error():
    print(res.error)
else:
    print(res.data)
[/gdscript]
[/codeblocks]
Returns a [DiscordEmbeddedAppResponse] object that has a [signal DiscordEmbeddedAppResponse.finished] signal that is emitted when finished.
*/
//go:nosplit
func (self class) GetSkus() [1]gdclass.DiscordEmbeddedAppResponse { //gd:DiscordEmbeddedAppClient.get_skus
	var frame = callframe.New()
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.DiscordEmbeddedAppClient.Bind_get_skus, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.DiscordEmbeddedAppResponse{gd.PointerWithOwnershipTransferredToGo[gdclass.DiscordEmbeddedAppResponse](r_ret.Get())}
	frame.Free()
	return ret
}

/*
Presents the file upload flow in the Discord client. Wait for [method DiscordEmbeddedAppClient.is_ready] first.
Discord docs [url=Discord docs [url=https://discord.com/developers/docs/developer-tools/embedded-app-sdk#initiateimageupload]discord.com/developers/docs/developer-tools/embedded-app-sdk#initiateimageupload[/url]
[codeblocks]
[gdscript]
var res :DiscordEmbeddedAppResult = await initiate_image_upload().finished
if res.has_error():
    print(res.error)
else:
    print(res.data)
[/gdscript]
[/codeblocks]
Returns a [DiscordEmbeddedAppResponse] object that has a [signal DiscordEmbeddedAppResponse.finished] signal that is emitted when finished.
*/
//go:nosplit
func (self class) InitiateImageUpload() [1]gdclass.DiscordEmbeddedAppResponse { //gd:DiscordEmbeddedAppClient.initiate_image_upload
	var frame = callframe.New()
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.DiscordEmbeddedAppClient.Bind_initiate_image_upload, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.DiscordEmbeddedAppResponse{gd.PointerWithOwnershipTransferredToGo[gdclass.DiscordEmbeddedAppResponse](r_ret.Get())}
	frame.Free()
	return ret
}

/*
Allows for opening an external link from within the Discord client. Wait for [method DiscordEmbeddedAppClient.is_ready] first.
Discord docs [url=Discord docs [url=https://discord.com/developers/docs/developer-tools/embedded-app-sdk#openexternallink]discord.com/developers/docs/developer-tools/embedded-app-sdk#openexternallink[/url]
[codeblocks]
[gdscript]
var res :DiscordEmbeddedAppResult = await open_external_link("url").finished
if res.has_error():
    print(res.error)
else:
    print(res.data)
[/gdscript]
[/codeblocks]
Returns a [DiscordEmbeddedAppResponse] object that has a [signal DiscordEmbeddedAppResponse.finished] signal that is emitted when finished.
*/
//go:nosplit
func (self class) OpenExternalLink(url String.Readable) [1]gdclass.DiscordEmbeddedAppResponse { //gd:DiscordEmbeddedAppClient.open_external_link
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(url)))
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.DiscordEmbeddedAppClient.Bind_open_external_link, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.DiscordEmbeddedAppResponse{gd.PointerWithOwnershipTransferredToGo[gdclass.DiscordEmbeddedAppResponse](r_ret.Get())}
	frame.Free()
	return ret
}

/*
Presents a modal dialog with Channel Invite UI without requiring additional OAuth scopes. Wait for [method DiscordEmbeddedAppClient.is_ready] first.
Discord docs [url=Discord docs [url=https://discord.com/developers/docs/developer-tools/embedded-app-sdk#openinvitedialog]discord.com/developers/docs/developer-tools/embedded-app-sdk#openinvitedialog[/url]
[codeblocks]
[gdscript]
var res :DiscordEmbeddedAppResult = await open_invite_dialog().finished
if res.has_error():
    print(res.error)
else:
    print(res.data)
[/gdscript]
[/codeblocks]
Returns a [DiscordEmbeddedAppResponse] object that has a [signal DiscordEmbeddedAppResponse.finished] signal that is emitted when finished.
*/
//go:nosplit
func (self class) OpenInviteDialog() [1]gdclass.DiscordEmbeddedAppResponse { //gd:DiscordEmbeddedAppClient.open_invite_dialog
	var frame = callframe.New()
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.DiscordEmbeddedAppClient.Bind_open_invite_dialog, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.DiscordEmbeddedAppResponse{gd.PointerWithOwnershipTransferredToGo[gdclass.DiscordEmbeddedAppResponse](r_ret.Get())}
	frame.Free()
	return ret
}

/*
Presents a modal dialog to share media to a channel or DM. Wait for [method DiscordEmbeddedAppClient.is_ready] first.
Discord docs [url=Discord docs [url=https://discord.com/developers/docs/developer-tools/embedded-app-sdk#opensharemomentdialog]discord.com/developers/docs/developer-tools/embedded-app-sdk#opensharemomentdialog[/url]
[codeblocks]
[gdscript]
var res :DiscordEmbeddedAppResult = await open_share_moment_dialog().finished
if res.has_error():
    print(res.error)
else:
    print(res.data)
[/gdscript]
[/codeblocks]
Returns a [DiscordEmbeddedAppResponse] object that has a [signal DiscordEmbeddedAppResponse.finished] signal that is emitted when finished.
*/
//go:nosplit
func (self class) OpenShareMomentDialog(media_url String.Readable) [1]gdclass.DiscordEmbeddedAppResponse { //gd:DiscordEmbeddedAppClient.open_share_moment_dialog
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(media_url)))
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.DiscordEmbeddedAppClient.Bind_open_share_moment_dialog, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.DiscordEmbeddedAppResponse{gd.PointerWithOwnershipTransferredToGo[gdclass.DiscordEmbeddedAppResponse](r_ret.Get())}
	frame.Free()
	return ret
}

/*
Modifies how your activity's rich presence is displayed in the Discord client. Wait for [method DiscordEmbeddedAppClient.is_ready] first.
Discord docs [url=Discord docs [url=https://discord.com/developers/docs/developer-tools/embedded-app-sdk#setactivity]discord.com/developers/docs/developer-tools/embedded-app-sdk#setactivity[/url]
[codeblocks]
[gdscript]
var res :DiscordEmbeddedAppResult = await set_activity({"type": 0, "details": "Details", "state": "Playing"}).finished
if res.has_error():
    print(res.error)
else:
    print(res.data)
[/gdscript]
[/codeblocks]
Returns a [DiscordEmbeddedAppResponse] object that has a [signal DiscordEmbeddedAppResponse.finished] signal that is emitted when finished.
*/
//go:nosplit
func (self class) SetActivity(activity Dictionary.Any) [1]gdclass.DiscordEmbeddedAppResponse { //gd:DiscordEmbeddedAppClient.set_activity
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalDictionary(activity)))
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.DiscordEmbeddedAppClient.Bind_set_activity, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.DiscordEmbeddedAppResponse{gd.PointerWithOwnershipTransferredToGo[gdclass.DiscordEmbeddedAppResponse](r_ret.Get())}
	frame.Free()
	return ret
}

/*
Set whether or not the PIP (picture-in-picture) is interactive. Wait for [method DiscordEmbeddedAppClient.is_ready] first.
Discord docs [url=Discord docs [url=https://discord.com/developers/docs/developer-tools/embedded-app-sdk#setconfig]discord.com/developers/docs/developer-tools/embedded-app-sdk#setconfig[/url]
[codeblocks]
[gdscript]
var res :DiscordEmbeddedAppResult = await set_config(true).finished
if res.has_error():
    print(res.error)
else:
    print(res.data)
[/gdscript]
[/codeblocks]
Returns a [DiscordEmbeddedAppResponse] object that has a [signal DiscordEmbeddedAppResponse.finished] signal that is emitted when finished.
*/
//go:nosplit
func (self class) SetConfig(use_interactive_pip bool) [1]gdclass.DiscordEmbeddedAppResponse { //gd:DiscordEmbeddedAppClient.set_config
	var frame = callframe.New()
	callframe.Arg(frame, use_interactive_pip)
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.DiscordEmbeddedAppClient.Bind_set_config, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.DiscordEmbeddedAppResponse{gd.PointerWithOwnershipTransferredToGo[gdclass.DiscordEmbeddedAppResponse](r_ret.Get())}
	frame.Free()
	return ret
}

/*
Set options for orientation and picture-in-picture (PIP) modes. Wait for [method DiscordEmbeddedAppClient.is_ready] first.
Discord docs [url=Discord docs [url=https://discord.com/developers/docs/developer-tools/embedded-app-sdk#setorientationlockstate]discord.com/developers/docs/developer-tools/embedded-app-sdk#setorientationlockstate[/url]
[codeblocks]
[gdscript]
var res :DiscordEmbeddedAppResult = await set_orientation_lock_state(DiscordEmbeddedAppClient.DISCORD_EMBEDDED_APP_ORIENTATION_LOCK_STATE_UNLOCKED, DiscordEmbeddedAppClient.DISCORD_EMBEDDED_APP_ORIENTATION_LOCK_STATE_UNLOCKED, DiscordEmbeddedAppClient.DISCORD_EMBEDDED_APP_ORIENTATION_LOCK_STATE_UNLOCKED).finished
if res.has_error():
    print(res.error)
else:
    print(res.data)
[/gdscript]
[/codeblocks]
Returns a [DiscordEmbeddedAppResponse] object that has a [signal DiscordEmbeddedAppResponse.finished] signal that is emitted when finished.
*/
//go:nosplit
func (self class) SetOrientationLockState(lock_state DiscordEmbeddedAppOrientationLockState, picture_in_picture_lock_state DiscordEmbeddedAppOrientationLockState, grid_lock_state DiscordEmbeddedAppOrientationLockState) [1]gdclass.DiscordEmbeddedAppResponse { //gd:DiscordEmbeddedAppClient.set_orientation_lock_state
	var frame = callframe.New()
	callframe.Arg(frame, lock_state)
	callframe.Arg(frame, picture_in_picture_lock_state)
	callframe.Arg(frame, grid_lock_state)
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.DiscordEmbeddedAppClient.Bind_set_orientation_lock_state, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.DiscordEmbeddedAppResponse{gd.PointerWithOwnershipTransferredToGo[gdclass.DiscordEmbeddedAppResponse](r_ret.Get())}
	frame.Free()
	return ret
}

/*
Launches the purchase flow for a specific SKU, per the sku_id. Wait for [method DiscordEmbeddedAppClient.is_ready] first.
Discord docs [url=Discord docs [url=https://discord.com/developers/docs/developer-tools/embedded-app-sdk#startpurchase]discord.com/developers/docs/developer-tools/embedded-app-sdk#startpurchase[/url]
[codeblocks]
[gdscript]
var res :DiscordEmbeddedAppResult = await start_purchase("sku_id", "pid").finished
if res.has_error():
    print(res.error)
else:
    print(res.data)
[/gdscript]
[/codeblocks]
Returns a [DiscordEmbeddedAppResponse] object that has a [signal DiscordEmbeddedAppResponse.finished] signal that is emitted when finished.
*/
//go:nosplit
func (self class) StartPurchase(sku_id String.Readable, pid String.Readable) [1]gdclass.DiscordEmbeddedAppResponse { //gd:DiscordEmbeddedAppClient.start_purchase
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(sku_id)))
	callframe.Arg(frame, pointers.Get(gd.InternalString(pid)))
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.DiscordEmbeddedAppClient.Bind_start_purchase, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.DiscordEmbeddedAppResponse{gd.PointerWithOwnershipTransferredToGo[gdclass.DiscordEmbeddedAppResponse](r_ret.Get())}
	frame.Free()
	return ret
}

/*
Returns the current user's locale. Wait for [method DiscordEmbeddedAppClient.is_ready] first.
Discord docs [url=Discord docs [url=https://discord.com/developers/docs/developer-tools/embedded-app-sdk#usersettingsgetlocale]discord.com/developers/docs/developer-tools/embedded-app-sdk#usersettingsgetlocale[/url]
[codeblocks]
[gdscript]
var res :DiscordEmbeddedAppResult = await user_settings_get_locale().finished
if res.has_error():
    print(res.error)
else:
    print(res.data)
[/gdscript]
[/codeblocks]
Returns a [DiscordEmbeddedAppResponse] object that has a [signal DiscordEmbeddedAppResponse.finished] signal that is emitted when finished.
*/
//go:nosplit
func (self class) UserSettingsGetLocale() [1]gdclass.DiscordEmbeddedAppResponse { //gd:DiscordEmbeddedAppClient.user_settings_get_locale
	var frame = callframe.New()
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.DiscordEmbeddedAppClient.Bind_user_settings_get_locale, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.DiscordEmbeddedAppResponse{gd.PointerWithOwnershipTransferredToGo[gdclass.DiscordEmbeddedAppResponse](r_ret.Get())}
	frame.Free()
	return ret
}

/*
Subscribes to all events. Needs to be done after [method authenticate]. Wait for [method DiscordEmbeddedAppClient.is_ready] first.
[codeblocks]
[gdscript]
subscribe_to_all_events()
[/gdscript]
[/codeblocks]
*/
//go:nosplit
func (self class) SubscribeToAllEvents() { //gd:DiscordEmbeddedAppClient.subscribe_to_all_events
	var frame = callframe.New()
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.DiscordEmbeddedAppClient.Bind_subscribe_to_all_events, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Returns whether or not the client is ready.
Discord docs [url=https://discord.com/developers/docs/developer-tools/embedded-app-sdk#ready]discord.com/developers/docs/developer-tools/embedded-app-sdk#ready[/url]
[codeblocks]
[gdscript]
var res :DiscordEmbeddedAppResult = await is_ready().finished
if res.has_error():
    print(res.error)
else:
    print(res.data)
[/gdscript]
[/codeblocks]
Returns a [DiscordEmbeddedAppResponse] object that has a [signal DiscordEmbeddedAppResponse.finished] signal that is emitted when finished.
*/
//go:nosplit
func (self class) IsReady() [1]gdclass.DiscordEmbeddedAppResponse { //gd:DiscordEmbeddedAppClient.is_ready
	var frame = callframe.New()
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.DiscordEmbeddedAppClient.Bind_is_ready, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.DiscordEmbeddedAppResponse{gd.PointerWithOwnershipTransferredToGo[gdclass.DiscordEmbeddedAppResponse](r_ret.Get())}
	frame.Free()
	return ret
}

/*
Returns whether or not the current environment is Discord environment.
[codeblocks]
[gdscript]
if is_discord_environment():
    print("This is discord environment")
[/gdscript]
[/codeblocks]
*/
//go:nosplit
func (self class) IsDiscordEnvironment() bool { //gd:DiscordEmbeddedAppClient.is_discord_environment
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.DiscordEmbeddedAppClient.Bind_is_discord_environment, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

//go:nosplit
func (self class) GetUserId() String.Readable { //gd:DiscordEmbeddedAppClient.get_user_id
	var frame = callframe.New()
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.DiscordEmbeddedAppClient.Bind_get_user_id, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

//go:nosplit
func (self class) GetClientId() String.Readable { //gd:DiscordEmbeddedAppClient.get_client_id
	var frame = callframe.New()
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.DiscordEmbeddedAppClient.Bind_get_client_id, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

//go:nosplit
func (self class) GetUserInstanceId() String.Readable { //gd:DiscordEmbeddedAppClient.get_user_instance_id
	var frame = callframe.New()
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.DiscordEmbeddedAppClient.Bind_get_user_instance_id, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

//go:nosplit
func (self class) GetCustomId() String.Readable { //gd:DiscordEmbeddedAppClient.get_custom_id
	var frame = callframe.New()
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.DiscordEmbeddedAppClient.Bind_get_custom_id, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

//go:nosplit
func (self class) GetReferrerId() String.Readable { //gd:DiscordEmbeddedAppClient.get_referrer_id
	var frame = callframe.New()
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.DiscordEmbeddedAppClient.Bind_get_referrer_id, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

//go:nosplit
func (self class) GetPlatform() String.Readable { //gd:DiscordEmbeddedAppClient.get_platform
	var frame = callframe.New()
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.DiscordEmbeddedAppClient.Bind_get_platform, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

//go:nosplit
func (self class) GetGuildId() String.Readable { //gd:DiscordEmbeddedAppClient.get_guild_id
	var frame = callframe.New()
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.DiscordEmbeddedAppClient.Bind_get_guild_id, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

//go:nosplit
func (self class) GetChannelId() String.Readable { //gd:DiscordEmbeddedAppClient.get_channel_id
	var frame = callframe.New()
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.DiscordEmbeddedAppClient.Bind_get_channel_id, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

//go:nosplit
func (self class) GetLocationId() String.Readable { //gd:DiscordEmbeddedAppClient.get_location_id
	var frame = callframe.New()
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.DiscordEmbeddedAppClient.Bind_get_location_id, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

//go:nosplit
func (self class) GetSdkVersion() String.Readable { //gd:DiscordEmbeddedAppClient.get_sdk_version
	var frame = callframe.New()
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.DiscordEmbeddedAppClient.Bind_get_sdk_version, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

//go:nosplit
func (self class) GetMobileAppVersion() String.Readable { //gd:DiscordEmbeddedAppClient.get_mobile_app_version
	var frame = callframe.New()
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.DiscordEmbeddedAppClient.Bind_get_mobile_app_version, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

//go:nosplit
func (self class) GetFrameId() String.Readable { //gd:DiscordEmbeddedAppClient.get_frame_id
	var frame = callframe.New()
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.DiscordEmbeddedAppClient.Bind_get_frame_id, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}
func (self Instance) OnLogUpdated(cb func(command string, logs string)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("log_updated"), gd.NewCallable(cb), 0)
}

func (self Instance) OnError(cb func(data map[any]any)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("error"), gd.NewCallable(cb), 0)
}

func (self Instance) OnVoiceStateUpdate(cb func(data map[any]any)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("voice_state_update"), gd.NewCallable(cb), 0)
}

func (self Instance) OnSpeakingStart(cb func(data map[any]any)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("speaking_start"), gd.NewCallable(cb), 0)
}

func (self Instance) OnSpeakingStop(cb func(data map[any]any)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("speaking_stop"), gd.NewCallable(cb), 0)
}

func (self Instance) OnActivityLayoutModeUpdate(cb func(data map[any]any)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("activity_layout_mode_update"), gd.NewCallable(cb), 0)
}

func (self Instance) OnOrientationUpdate(cb func(data map[any]any)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("orientation_update"), gd.NewCallable(cb), 0)
}

func (self Instance) OnThermalStateUpdate(cb func(data map[any]any)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("thermal_state_update"), gd.NewCallable(cb), 0)
}

func (self Instance) OnActivityInstanceParticipantsUpdate(cb func(data map[any]any)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("activity_instance_participants_update"), gd.NewCallable(cb), 0)
}

func (self Instance) OnEntitlementCreate(cb func(data map[any]any)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("entitlement_create"), gd.NewCallable(cb), 0)
}

func (self Instance) OnCurrentGuildMemberUpdate(cb func(data map[any]any)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("current_guild_member_update"), gd.NewCallable(cb), 0)
}

func (self Instance) OnCurrentUserUpdate(cb func(data map[any]any)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("current_user_update"), gd.NewCallable(cb), 0)
}

func (self class) AsDiscordEmbeddedAppClient() Advanced { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsDiscordEmbeddedAppClient() Instance {
	return *((*Instance)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsDiscordEmbeddedAppClient() Instance {
	return self.Super().AsDiscordEmbeddedAppClient()
}
func (self class) AsThirdPartyClient() ThirdPartyClient.Advanced {
	return *((*ThirdPartyClient.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsThirdPartyClient() ThirdPartyClient.Instance {
	return self.Super().AsThirdPartyClient()
}
func (self Instance) AsThirdPartyClient() ThirdPartyClient.Instance {
	return *((*ThirdPartyClient.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsNode() Node.Advanced         { return *((*Node.Advanced)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsNode() Node.Instance { return self.Super().AsNode() }
func (self Instance) AsNode() Node.Instance      { return *((*Node.Instance)(unsafe.Pointer(&self))) }

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(ThirdPartyClient.Advanced(self.AsThirdPartyClient()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(ThirdPartyClient.Instance(self.AsThirdPartyClient()), name)
	}
}
func init() {
	gdclass.Register("DiscordEmbeddedAppClient", func(ptr gd.Object) any {
		return [1]gdclass.DiscordEmbeddedAppClient{*(*gdclass.DiscordEmbeddedAppClient)(unsafe.Pointer(&ptr))}
	})
}

type DiscordEmbeddedAppOrientationLockState int //gd:DiscordEmbeddedAppClient.DiscordEmbeddedAppOrientationLockState

const (
	/*Unhandled orientation lock state.*/
	DiscordEmbeddedAppOrientationLockStateUnhandled DiscordEmbeddedAppOrientationLockState = -1
	/*Unlocked orientation lock state.*/
	DiscordEmbeddedAppOrientationLockStateUnlocked DiscordEmbeddedAppOrientationLockState = 1
	/*Locked portrait orientation lock state.*/
	DiscordEmbeddedAppOrientationLockStatePortrait DiscordEmbeddedAppOrientationLockState = 2
	/*Locked landscape orientation lock state.*/
	DiscordEmbeddedAppOrientationLockStateLandscape DiscordEmbeddedAppOrientationLockState = 3
)
