// Code generated by the generate package DO NOT EDIT

// Package EditorInterface provides methods for working with EditorInterface object instances.
package EditorInterface

import "unsafe"
import "sync"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/Control"
import "graphics.gd/classdb/EditorCommandPalette"
import "graphics.gd/classdb/EditorFileSystem"
import "graphics.gd/classdb/EditorInspector"
import "graphics.gd/classdb/EditorPaths"
import "graphics.gd/classdb/EditorResourcePreview"
import "graphics.gd/classdb/EditorSelection"
import "graphics.gd/classdb/EditorSettings"
import "graphics.gd/classdb/EditorToaster"
import "graphics.gd/classdb/EditorUndoRedoManager"
import "graphics.gd/classdb/FileSystemDock"
import "graphics.gd/classdb/Mesh"
import "graphics.gd/classdb/Node"
import "graphics.gd/classdb/Resource"
import "graphics.gd/classdb/Script"
import "graphics.gd/classdb/ScriptEditor"
import "graphics.gd/classdb/SubViewport"
import "graphics.gd/classdb/Texture2D"
import "graphics.gd/classdb/Theme"
import "graphics.gd/classdb/VBoxContainer"
import "graphics.gd/classdb/Window"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/Rect2i"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"
import "graphics.gd/variant/Vector2i"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
[EditorInterface] gives you control over Godot editor's window. It allows customizing the window, saving and (re-)loading scenes, rendering mesh previews, inspecting and editing resources and objects, and provides access to [EditorSettings], [EditorFileSystem], [EditorResourcePreview], [ScriptEditor], the editor viewport, and information about scenes.
[b]Note:[/b] This class shouldn't be instantiated directly. Instead, access the singleton directly by its name.
[codeblocks]
[gdscript]
var editor_settings = EditorInterface.get_editor_settings()
[/gdscript]
[csharp]
// In C# you can access it via the static Singleton property.
EditorSettings settings = EditorInterface.Singleton.GetEditorSettings();
[/csharp]
[/codeblocks]
*/
type Instance [1]gdclass.EditorInterface

func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

var self [1]gdclass.EditorInterface
var once sync.Once

func singleton() {
	obj := gd.Global.Object.GetSingleton(gd.Global.Singletons.EditorInterface)
	self = *(*[1]gdclass.EditorInterface)(unsafe.Pointer(&obj))
}

/*
Restarts the editor. This closes the editor and then opens the same project. If [param save] is [code]true[/code], the project will be saved before restarting.
*/
func RestartEditor() { //gd:EditorInterface.restart_editor
	once.Do(singleton)
	Advanced().RestartEditor(true)
}

/*
Restarts the editor. This closes the editor and then opens the same project. If [param save] is [code]true[/code], the project will be saved before restarting.
*/
func RestartEditorOptions(save bool) { //gd:EditorInterface.restart_editor
	once.Do(singleton)
	Advanced().RestartEditor(save)
}

/*
Returns the editor's [EditorCommandPalette] instance.
[b]Warning:[/b] Removing and freeing this node will render a part of the editor useless and may cause a crash.
*/
func GetCommandPalette() EditorCommandPalette.Instance { //gd:EditorInterface.get_command_palette
	once.Do(singleton)
	return EditorCommandPalette.Instance(Advanced().GetCommandPalette())
}

/*
Returns the editor's [EditorFileSystem] instance.
*/
func GetResourceFilesystem() EditorFileSystem.Instance { //gd:EditorInterface.get_resource_filesystem
	once.Do(singleton)
	return EditorFileSystem.Instance(Advanced().GetResourceFilesystem())
}

/*
Returns the [EditorPaths] singleton.
*/
func GetEditorPaths() EditorPaths.Instance { //gd:EditorInterface.get_editor_paths
	once.Do(singleton)
	return EditorPaths.Instance(Advanced().GetEditorPaths())
}

/*
Returns the editor's [EditorResourcePreview] instance.
*/
func GetResourcePreviewer() EditorResourcePreview.Instance { //gd:EditorInterface.get_resource_previewer
	once.Do(singleton)
	return EditorResourcePreview.Instance(Advanced().GetResourcePreviewer())
}

/*
Returns the editor's [EditorSelection] instance.
*/
func GetSelection() EditorSelection.Instance { //gd:EditorInterface.get_selection
	once.Do(singleton)
	return EditorSelection.Instance(Advanced().GetSelection())
}

/*
Returns the editor's [EditorSettings] instance.
*/
func GetEditorSettings() EditorSettings.Instance { //gd:EditorInterface.get_editor_settings
	once.Do(singleton)
	return EditorSettings.Instance(Advanced().GetEditorSettings())
}

/*
Returns the editor's [EditorToaster].
*/
func GetEditorToaster() EditorToaster.Instance { //gd:EditorInterface.get_editor_toaster
	once.Do(singleton)
	return EditorToaster.Instance(Advanced().GetEditorToaster())
}

/*
Returns the editor's [EditorUndoRedoManager].
*/
func GetEditorUndoRedo() EditorUndoRedoManager.Instance { //gd:EditorInterface.get_editor_undo_redo
	once.Do(singleton)
	return EditorUndoRedoManager.Instance(Advanced().GetEditorUndoRedo())
}

/*
Returns mesh previews rendered at the given size as an [Array] of [Texture2D]s.
*/
func MakeMeshPreviews(meshes []Mesh.Instance, preview_size int) []Texture2D.Instance { //gd:EditorInterface.make_mesh_previews
	once.Do(singleton)
	return []Texture2D.Instance(gd.ArrayAs[[]Texture2D.Instance](gd.InternalArray(Advanced().MakeMeshPreviews(gd.ArrayFromSlice[Array.Contains[[1]gdclass.Mesh]](meshes), int64(preview_size)))))
}

/*
Sets the enabled status of a plugin. The plugin name is the same as its directory name.
*/
func SetPluginEnabled(plugin string, enabled bool) { //gd:EditorInterface.set_plugin_enabled
	once.Do(singleton)
	Advanced().SetPluginEnabled(String.New(plugin), enabled)
}

/*
Returns [code]true[/code] if the specified [param plugin] is enabled. The plugin name is the same as its directory name.
*/
func IsPluginEnabled(plugin string) bool { //gd:EditorInterface.is_plugin_enabled
	once.Do(singleton)
	return bool(Advanced().IsPluginEnabled(String.New(plugin)))
}

/*
Returns the editor's [Theme].
[b]Note:[/b] When creating custom editor UI, prefer accessing theme items directly from your GUI nodes using the [code]get_theme_*[/code] methods.
*/
func GetEditorTheme() Theme.Instance { //gd:EditorInterface.get_editor_theme
	once.Do(singleton)
	return Theme.Instance(Advanced().GetEditorTheme())
}

/*
Returns the main container of Godot editor's window. For example, you can use it to retrieve the size of the container and place your controls accordingly.
[b]Warning:[/b] Removing and freeing this node will render the editor useless and may cause a crash.
*/
func GetBaseControl() Control.Instance { //gd:EditorInterface.get_base_control
	once.Do(singleton)
	return Control.Instance(Advanced().GetBaseControl())
}

/*
Returns the editor control responsible for main screen plugins and tools. Use it with plugins that implement [method EditorPlugin._has_main_screen].
[b]Note:[/b] This node is a [VBoxContainer], which means that if you add a [Control] child to it, you need to set the child's [member Control.size_flags_vertical] to [constant Control.SIZE_EXPAND_FILL] to make it use the full available space.
[b]Warning:[/b] Removing and freeing this node will render a part of the editor useless and may cause a crash.
*/
func GetEditorMainScreen() VBoxContainer.Instance { //gd:EditorInterface.get_editor_main_screen
	once.Do(singleton)
	return VBoxContainer.Instance(Advanced().GetEditorMainScreen())
}

/*
Returns the editor's [ScriptEditor] instance.
[b]Warning:[/b] Removing and freeing this node will render a part of the editor useless and may cause a crash.
*/
func GetScriptEditor() ScriptEditor.Instance { //gd:EditorInterface.get_script_editor
	once.Do(singleton)
	return ScriptEditor.Instance(Advanced().GetScriptEditor())
}

/*
Returns the 2D editor [SubViewport]. It does not have a camera. Instead, the view transforms are done directly and can be accessed with [member Viewport.global_canvas_transform].
*/
func GetEditorViewport2d() SubViewport.Instance { //gd:EditorInterface.get_editor_viewport_2d
	once.Do(singleton)
	return SubViewport.Instance(Advanced().GetEditorViewport2d())
}

/*
Returns the specified 3D editor [SubViewport], from [code]0[/code] to [code]3[/code]. The viewport can be used to access the active editor cameras with [method Viewport.get_camera_3d].
*/
func GetEditorViewport3d(idx int) SubViewport.Instance { //gd:EditorInterface.get_editor_viewport_3d
	once.Do(singleton)
	return SubViewport.Instance(Advanced().GetEditorViewport3d(int64(idx)))
}

/*
Returns the specified 3D editor [SubViewport], from [code]0[/code] to [code]3[/code]. The viewport can be used to access the active editor cameras with [method Viewport.get_camera_3d].
*/
func GetEditorViewport3dOptions(idx int) SubViewport.Instance { //gd:EditorInterface.get_editor_viewport_3d
	once.Do(singleton)
	return SubViewport.Instance(Advanced().GetEditorViewport3d(int64(idx)))
}

/*
Sets the editor's current main screen to the one specified in [param name]. [param name] must match the title of the tab in question exactly (e.g. [code]2D[/code], [code]3D[/code], [code skip-lint]Script[/code], or [code]AssetLib[/code] for default tabs).
*/
func SetMainScreenEditor(name string) { //gd:EditorInterface.set_main_screen_editor
	once.Do(singleton)
	Advanced().SetMainScreenEditor(String.New(name))
}

/*
Returns [code]true[/code] if multiple window support is enabled in the editor. Multiple window support is enabled if [i]all[/i] of these statements are true:
- [member EditorSettings.interface/multi_window/enable] is [code]true[/code].
- [member EditorSettings.interface/editor/single_window_mode] is [code]false[/code].
- [member Viewport.gui_embed_subwindows] is [code]false[/code]. This is forced to [code]true[/code] on platforms that don't support multiple windows such as Web, or when the [code]--single-window[/code] [url=$DOCS_URL/tutorials/editor/command_line_tutorial.html]command line argument[/url] is used.
*/
func IsMultiWindowEnabled() bool { //gd:EditorInterface.is_multi_window_enabled
	once.Do(singleton)
	return bool(Advanced().IsMultiWindowEnabled())
}

/*
Returns the actual scale of the editor UI ([code]1.0[/code] being 100% scale). This can be used to adjust position and dimensions of the UI added by plugins.
[b]Note:[/b] This value is set via the [code]interface/editor/display_scale[/code] and [code]interface/editor/custom_display_scale[/code] editor settings. Editor must be restarted for changes to be properly applied.
*/
func GetEditorScale() Float.X { //gd:EditorInterface.get_editor_scale
	once.Do(singleton)
	return Float.X(Float.X(Advanced().GetEditorScale()))
}

/*
Pops up the [param dialog] in the editor UI with [method Window.popup_exclusive]. The dialog must have no current parent, otherwise the method fails.
See also [method Window.set_unparent_when_invisible].
*/
func PopupDialog(dialog Window.Instance, rect Rect2i.PositionSize) { //gd:EditorInterface.popup_dialog
	once.Do(singleton)
	Advanced().PopupDialog(dialog, Rect2i.PositionSize(rect))
}

/*
Pops up the [param dialog] in the editor UI with [method Window.popup_exclusive]. The dialog must have no current parent, otherwise the method fails.
See also [method Window.set_unparent_when_invisible].
*/
func PopupDialogOptions(dialog Window.Instance, rect Rect2i.PositionSize) { //gd:EditorInterface.popup_dialog
	once.Do(singleton)
	Advanced().PopupDialog(dialog, Rect2i.PositionSize(rect))
}

/*
Pops up the [param dialog] in the editor UI with [method Window.popup_exclusive_centered]. The dialog must have no current parent, otherwise the method fails.
See also [method Window.set_unparent_when_invisible].
*/
func PopupDialogCentered(dialog Window.Instance, minsize Vector2i.XY) { //gd:EditorInterface.popup_dialog_centered
	once.Do(singleton)
	Advanced().PopupDialogCentered(dialog, Vector2i.XY(minsize))
}

/*
Pops up the [param dialog] in the editor UI with [method Window.popup_exclusive_centered]. The dialog must have no current parent, otherwise the method fails.
See also [method Window.set_unparent_when_invisible].
*/
func PopupDialogCenteredOptions(dialog Window.Instance, minsize Vector2i.XY) { //gd:EditorInterface.popup_dialog_centered
	once.Do(singleton)
	Advanced().PopupDialogCentered(dialog, Vector2i.XY(minsize))
}

/*
Pops up the [param dialog] in the editor UI with [method Window.popup_exclusive_centered_ratio]. The dialog must have no current parent, otherwise the method fails.
See also [method Window.set_unparent_when_invisible].
*/
func PopupDialogCenteredRatio(dialog Window.Instance) { //gd:EditorInterface.popup_dialog_centered_ratio
	once.Do(singleton)
	Advanced().PopupDialogCenteredRatio(dialog, float64(0.8))
}

/*
Pops up the [param dialog] in the editor UI with [method Window.popup_exclusive_centered_ratio]. The dialog must have no current parent, otherwise the method fails.
See also [method Window.set_unparent_when_invisible].
*/
func PopupDialogCenteredRatioOptions(dialog Window.Instance, ratio Float.X) { //gd:EditorInterface.popup_dialog_centered_ratio
	once.Do(singleton)
	Advanced().PopupDialogCenteredRatio(dialog, float64(ratio))
}

/*
Pops up the [param dialog] in the editor UI with [method Window.popup_exclusive_centered_clamped]. The dialog must have no current parent, otherwise the method fails.
See also [method Window.set_unparent_when_invisible].
*/
func PopupDialogCenteredClamped(dialog Window.Instance, minsize Vector2i.XY) { //gd:EditorInterface.popup_dialog_centered_clamped
	once.Do(singleton)
	Advanced().PopupDialogCenteredClamped(dialog, Vector2i.XY(minsize), float64(0.75))
}

/*
Pops up the [param dialog] in the editor UI with [method Window.popup_exclusive_centered_clamped]. The dialog must have no current parent, otherwise the method fails.
See also [method Window.set_unparent_when_invisible].
*/
func PopupDialogCenteredClampedOptions(dialog Window.Instance, minsize Vector2i.XY, fallback_ratio Float.X) { //gd:EditorInterface.popup_dialog_centered_clamped
	once.Do(singleton)
	Advanced().PopupDialogCenteredClamped(dialog, Vector2i.XY(minsize), float64(fallback_ratio))
}

/*
Returns the name of the currently activated feature profile. If the default profile is currently active, an empty string is returned instead.
In order to get a reference to the [EditorFeatureProfile], you must load the feature profile using [method EditorFeatureProfile.load_from_file].
[b]Note:[/b] Feature profiles created via the user interface are loaded from the [code]feature_profiles[/code] directory, as a file with the [code].profile[/code] extension. The editor configuration folder can be found by using [method EditorPaths.get_config_dir].
*/
func GetCurrentFeatureProfile() string { //gd:EditorInterface.get_current_feature_profile
	once.Do(singleton)
	return string(Advanced().GetCurrentFeatureProfile().String())
}

/*
Selects and activates the specified feature profile with the given [param profile_name]. Set [param profile_name] to an empty string to reset to the default feature profile.
A feature profile can be created programmatically using the [EditorFeatureProfile] class.
[b]Note:[/b] The feature profile that gets activated must be located in the [code]feature_profiles[/code] directory, as a file with the [code].profile[/code] extension. If a profile could not be found, an error occurs. The editor configuration folder can be found by using [method EditorPaths.get_config_dir].
*/
func SetCurrentFeatureProfile(profile_name string) { //gd:EditorInterface.set_current_feature_profile
	once.Do(singleton)
	Advanced().SetCurrentFeatureProfile(String.New(profile_name))
}

/*
Pops up an editor dialog for selecting a [Node] from the edited scene. The [param callback] must take a single argument of type [NodePath]. It is called on the selected [NodePath] or the empty path [code]^""[/code] if the dialog is canceled. If [param valid_types] is provided, the dialog will only show Nodes that match one of the listed Node types. If [param current_value] is provided, the Node will be automatically selected in the tree, if it exists.
[b]Example:[/b] Display the node selection dialog as soon as this node is added to the tree for the first time:
[codeblock]
func _ready():

	if Engine.is_editor_hint():
	    EditorInterface.popup_node_selector(_on_node_selected, ["Button"])

func _on_node_selected(node_path):

	if node_path.is_empty():
	    print("node selection canceled")
	else:
	    print("selected ", node_path)

[/codeblock]
*/
func PopupNodeSelector(callback func(selected string), valid_types []string, current_value Node.Instance) { //gd:EditorInterface.popup_node_selector
	once.Do(singleton)
	Advanced().PopupNodeSelector(Callable.New(callback), gd.ArrayFromSlice[Array.Contains[String.Name]](valid_types), current_value)
}

/*
Pops up an editor dialog for selecting a [Node] from the edited scene. The [param callback] must take a single argument of type [NodePath]. It is called on the selected [NodePath] or the empty path [code]^""[/code] if the dialog is canceled. If [param valid_types] is provided, the dialog will only show Nodes that match one of the listed Node types. If [param current_value] is provided, the Node will be automatically selected in the tree, if it exists.
[b]Example:[/b] Display the node selection dialog as soon as this node is added to the tree for the first time:
[codeblock]
func _ready():

	if Engine.is_editor_hint():
	    EditorInterface.popup_node_selector(_on_node_selected, ["Button"])

func _on_node_selected(node_path):

	if node_path.is_empty():
	    print("node selection canceled")
	else:
	    print("selected ", node_path)

[/codeblock]
*/
func PopupNodeSelectorOptions(callback func(selected string), valid_types []string, current_value Node.Instance) { //gd:EditorInterface.popup_node_selector
	once.Do(singleton)
	Advanced().PopupNodeSelector(Callable.New(callback), gd.ArrayFromSlice[Array.Contains[String.Name]](valid_types), current_value)
}

/*
Pops up an editor dialog for selecting properties from [param object]. The [param callback] must take a single argument of type [NodePath]. It is called on the selected property path (see [method NodePath.get_as_property_path]) or the empty path [code]^""[/code] if the dialog is canceled. If [param type_filter] is provided, the dialog will only show properties that match one of the listed [enum Variant.Type] values. If [param current_value] is provided, the property will be selected automatically in the property list, if it exists.
[codeblock]
func _ready():

	if Engine.is_editor_hint():
	    EditorInterface.popup_property_selector(this, _on_property_selected, [TYPE_INT])

func _on_property_selected(property_path):

	if property_path.is_empty():
	    print("property selection canceled")
	else:
	    print("selected ", property_path)

[/codeblock]
*/
func PopupPropertySelector(obj Object.Instance, callback func(selected string), type_filter []int32, current_value string) { //gd:EditorInterface.popup_property_selector
	once.Do(singleton)
	Advanced().PopupPropertySelector(obj, Callable.New(callback), Packed.New(type_filter...), String.New(current_value))
}

/*
Pops up an editor dialog for selecting properties from [param object]. The [param callback] must take a single argument of type [NodePath]. It is called on the selected property path (see [method NodePath.get_as_property_path]) or the empty path [code]^""[/code] if the dialog is canceled. If [param type_filter] is provided, the dialog will only show properties that match one of the listed [enum Variant.Type] values. If [param current_value] is provided, the property will be selected automatically in the property list, if it exists.
[codeblock]
func _ready():

	if Engine.is_editor_hint():
	    EditorInterface.popup_property_selector(this, _on_property_selected, [TYPE_INT])

func _on_property_selected(property_path):

	if property_path.is_empty():
	    print("property selection canceled")
	else:
	    print("selected ", property_path)

[/codeblock]
*/
func PopupPropertySelectorOptions(obj Object.Instance, callback func(selected string), type_filter []int32, current_value string) { //gd:EditorInterface.popup_property_selector
	once.Do(singleton)
	Advanced().PopupPropertySelector(obj, Callable.New(callback), Packed.New(type_filter...), String.New(current_value))
}

/*
Pops up an editor dialog for selecting a method from [param object]. The [param callback] must take a single argument of type [String] which will contain the name of the selected method or be empty if the dialog is canceled. If [param current_value] is provided, the method will be selected automatically in the method list, if it exists.
*/
func PopupMethodSelector(obj Object.Instance, callback func(selected string), current_value string) { //gd:EditorInterface.popup_method_selector
	once.Do(singleton)
	Advanced().PopupMethodSelector(obj, Callable.New(callback), String.New(current_value))
}

/*
Pops up an editor dialog for selecting a method from [param object]. The [param callback] must take a single argument of type [String] which will contain the name of the selected method or be empty if the dialog is canceled. If [param current_value] is provided, the method will be selected automatically in the method list, if it exists.
*/
func PopupMethodSelectorOptions(obj Object.Instance, callback func(selected string), current_value string) { //gd:EditorInterface.popup_method_selector
	once.Do(singleton)
	Advanced().PopupMethodSelector(obj, Callable.New(callback), String.New(current_value))
}

/*
Pops up an editor dialog for quick selecting a resource file. The [param callback] must take a single argument of type [String] which will contain the path of the selected resource or be empty if the dialog is canceled. If [param base_types] is provided, the dialog will only show resources that match these types. Only types deriving from [Resource] are supported.
*/
func PopupQuickOpen(callback func(selected string), base_types []string) { //gd:EditorInterface.popup_quick_open
	once.Do(singleton)
	Advanced().PopupQuickOpen(Callable.New(callback), gd.ArrayFromSlice[Array.Contains[String.Name]](base_types))
}

/*
Pops up an editor dialog for quick selecting a resource file. The [param callback] must take a single argument of type [String] which will contain the path of the selected resource or be empty if the dialog is canceled. If [param base_types] is provided, the dialog will only show resources that match these types. Only types deriving from [Resource] are supported.
*/
func PopupQuickOpenOptions(callback func(selected string), base_types []string) { //gd:EditorInterface.popup_quick_open
	once.Do(singleton)
	Advanced().PopupQuickOpen(Callable.New(callback), gd.ArrayFromSlice[Array.Contains[String.Name]](base_types))
}

/*
Pops up an editor dialog for creating an object.
The [param callback] must take a single argument of type [StringName] which will contain the type name of the selected object or be empty if no item is selected.
The [param base_type] specifies the base type of objects to display. For example, if you set this to "Resource", all types derived from [Resource] will display in the create dialog.
The [param current_type] will be passed in the search box of the create dialog, and the specified type can be immediately selected when the dialog pops up. If the [param current_type] is not derived from [param base_type], there will be no result of the type in the dialog.
The [param dialog_title] allows you to define a custom title for the dialog. This is useful if you want to accurately hint the usage of the dialog. If the [param dialog_title] is an empty string, the dialog will use "Create New 'Base Type'" as the default title.
The [param type_blocklist] contains a list of type names, and the types in the blocklist will be hidden from the create dialog.
[b]Note:[/b] Trying to list the base type in the [param type_blocklist] will hide all types derived from the base type from the create dialog.
*/
func PopupCreateDialog(callback func(selected string), base_type string, current_type string, dialog_title string, type_blocklist []string) { //gd:EditorInterface.popup_create_dialog
	once.Do(singleton)
	Advanced().PopupCreateDialog(Callable.New(callback), String.Name(String.New(base_type)), String.New(current_type), String.New(dialog_title), gd.ArrayFromSlice[Array.Contains[String.Name]](type_blocklist))
}

/*
Pops up an editor dialog for creating an object.
The [param callback] must take a single argument of type [StringName] which will contain the type name of the selected object or be empty if no item is selected.
The [param base_type] specifies the base type of objects to display. For example, if you set this to "Resource", all types derived from [Resource] will display in the create dialog.
The [param current_type] will be passed in the search box of the create dialog, and the specified type can be immediately selected when the dialog pops up. If the [param current_type] is not derived from [param base_type], there will be no result of the type in the dialog.
The [param dialog_title] allows you to define a custom title for the dialog. This is useful if you want to accurately hint the usage of the dialog. If the [param dialog_title] is an empty string, the dialog will use "Create New 'Base Type'" as the default title.
The [param type_blocklist] contains a list of type names, and the types in the blocklist will be hidden from the create dialog.
[b]Note:[/b] Trying to list the base type in the [param type_blocklist] will hide all types derived from the base type from the create dialog.
*/
func PopupCreateDialogOptions(callback func(selected string), base_type string, current_type string, dialog_title string, type_blocklist []string) { //gd:EditorInterface.popup_create_dialog
	once.Do(singleton)
	Advanced().PopupCreateDialog(Callable.New(callback), String.Name(String.New(base_type)), String.New(current_type), String.New(dialog_title), gd.ArrayFromSlice[Array.Contains[String.Name]](type_blocklist))
}

/*
Returns the editor's [FileSystemDock] instance.
[b]Warning:[/b] Removing and freeing this node will render a part of the editor useless and may cause a crash.
*/
func GetFileSystemDock() FileSystemDock.Instance { //gd:EditorInterface.get_file_system_dock
	once.Do(singleton)
	return FileSystemDock.Instance(Advanced().GetFileSystemDock())
}

/*
Selects the file, with the path provided by [param file], in the FileSystem dock.
*/
func SelectFile(file string) { //gd:EditorInterface.select_file
	once.Do(singleton)
	Advanced().SelectFile(String.New(file))
}

/*
Returns an array containing the paths of the currently selected files (and directories) in the [FileSystemDock].
*/
func GetSelectedPaths() []string { //gd:EditorInterface.get_selected_paths
	once.Do(singleton)
	return []string(Advanced().GetSelectedPaths().Strings())
}

/*
Returns the current path being viewed in the [FileSystemDock].
*/
func GetCurrentPath() string { //gd:EditorInterface.get_current_path
	once.Do(singleton)
	return string(Advanced().GetCurrentPath().String())
}

/*
Returns the current directory being viewed in the [FileSystemDock]. If a file is selected, its base directory will be returned using [method String.get_base_dir] instead.
*/
func GetCurrentDirectory() string { //gd:EditorInterface.get_current_directory
	once.Do(singleton)
	return string(Advanced().GetCurrentDirectory().String())
}

/*
Returns the editor's [EditorInspector] instance.
[b]Warning:[/b] Removing and freeing this node will render a part of the editor useless and may cause a crash.
*/
func GetInspector() EditorInspector.Instance { //gd:EditorInterface.get_inspector
	once.Do(singleton)
	return EditorInspector.Instance(Advanced().GetInspector())
}

/*
Shows the given property on the given [param object] in the editor's Inspector dock. If [param inspector_only] is [code]true[/code], plugins will not attempt to edit [param object].
*/
func InspectObject(obj Object.Instance, for_property string, inspector_only bool) { //gd:EditorInterface.inspect_object
	once.Do(singleton)
	Advanced().InspectObject(obj, String.New(for_property), inspector_only)
}

/*
Shows the given property on the given [param object] in the editor's Inspector dock. If [param inspector_only] is [code]true[/code], plugins will not attempt to edit [param object].
*/
func InspectObjectOptions(obj Object.Instance, for_property string, inspector_only bool) { //gd:EditorInterface.inspect_object
	once.Do(singleton)
	Advanced().InspectObject(obj, String.New(for_property), inspector_only)
}

/*
Edits the given [Resource]. If the resource is a [Script] you can also edit it with [method edit_script] to specify the line and column position.
*/
func EditResource(resource Resource.Instance) { //gd:EditorInterface.edit_resource
	once.Do(singleton)
	Advanced().EditResource(resource)
}

/*
Edits the given [Node]. The node will be also selected if it's inside the scene tree.
*/
func EditNode(node Node.Instance) { //gd:EditorInterface.edit_node
	once.Do(singleton)
	Advanced().EditNode(node)
}

/*
Edits the given [Script]. The line and column on which to open the script can also be specified. The script will be open with the user-configured editor for the script's language which may be an external editor.
*/
func EditScript(script Script.Instance, column int) { //gd:EditorInterface.edit_script
	once.Do(singleton)
	Advanced().EditScript(script, int64(-1), int64(column), true)
}

/*
Edits the given [Script]. The line and column on which to open the script can also be specified. The script will be open with the user-configured editor for the script's language which may be an external editor.
*/
func EditScriptOptions(script Script.Instance, line int, column int, grab_focus bool) { //gd:EditorInterface.edit_script
	once.Do(singleton)
	Advanced().EditScript(script, int64(line), int64(column), grab_focus)
}

/*
Opens the scene at the given path. If [param set_inherited] is [code]true[/code], creates a new inherited scene.
*/
func OpenSceneFromPath(scene_filepath string, set_inherited bool) { //gd:EditorInterface.open_scene_from_path
	once.Do(singleton)
	Advanced().OpenSceneFromPath(String.New(scene_filepath), set_inherited)
}

/*
Opens the scene at the given path. If [param set_inherited] is [code]true[/code], creates a new inherited scene.
*/
func OpenSceneFromPathOptions(scene_filepath string, set_inherited bool) { //gd:EditorInterface.open_scene_from_path
	once.Do(singleton)
	Advanced().OpenSceneFromPath(String.New(scene_filepath), set_inherited)
}

/*
Reloads the scene at the given path.
*/
func ReloadSceneFromPath(scene_filepath string) { //gd:EditorInterface.reload_scene_from_path
	once.Do(singleton)
	Advanced().ReloadSceneFromPath(String.New(scene_filepath))
}

/*
Returns an [Array] with the file paths of the currently opened scenes.
*/
func GetOpenScenes() []string { //gd:EditorInterface.get_open_scenes
	once.Do(singleton)
	return []string(Advanced().GetOpenScenes().Strings())
}

/*
Returns the edited (current) scene's root [Node].
*/
func GetEditedSceneRoot() Node.Instance { //gd:EditorInterface.get_edited_scene_root
	once.Do(singleton)
	return Node.Instance(Advanced().GetEditedSceneRoot())
}

/*
Saves the currently active scene. Returns either [constant OK] or [constant ERR_CANT_CREATE].
*/
func SaveScene() error { //gd:EditorInterface.save_scene
	once.Do(singleton)
	return error(gd.ToError(Advanced().SaveScene()))
}

/*
Saves the currently active scene as a file at [param path].
*/
func SaveSceneAs(path string) { //gd:EditorInterface.save_scene_as
	once.Do(singleton)
	Advanced().SaveSceneAs(String.New(path), true)
}

/*
Saves the currently active scene as a file at [param path].
*/
func SaveSceneAsOptions(path string, with_preview bool) { //gd:EditorInterface.save_scene_as
	once.Do(singleton)
	Advanced().SaveSceneAs(String.New(path), with_preview)
}

/*
Saves all opened scenes in the editor.
*/
func SaveAllScenes() { //gd:EditorInterface.save_all_scenes
	once.Do(singleton)
	Advanced().SaveAllScenes()
}

/*
Marks the current scene tab as unsaved.
*/
func MarkSceneAsUnsaved() { //gd:EditorInterface.mark_scene_as_unsaved
	once.Do(singleton)
	Advanced().MarkSceneAsUnsaved()
}

/*
Plays the main scene.
*/
func PlayMainScene() { //gd:EditorInterface.play_main_scene
	once.Do(singleton)
	Advanced().PlayMainScene()
}

/*
Plays the currently active scene.
*/
func PlayCurrentScene() { //gd:EditorInterface.play_current_scene
	once.Do(singleton)
	Advanced().PlayCurrentScene()
}

/*
Plays the scene specified by its filepath.
*/
func PlayCustomScene(scene_filepath string) { //gd:EditorInterface.play_custom_scene
	once.Do(singleton)
	Advanced().PlayCustomScene(String.New(scene_filepath))
}

/*
Stops the scene that is currently playing.
*/
func StopPlayingScene() { //gd:EditorInterface.stop_playing_scene
	once.Do(singleton)
	Advanced().StopPlayingScene()
}

/*
Returns [code]true[/code] if a scene is currently being played, [code]false[/code] otherwise. Paused scenes are considered as being played.
*/
func IsPlayingScene() bool { //gd:EditorInterface.is_playing_scene
	once.Do(singleton)
	return bool(Advanced().IsPlayingScene())
}

/*
Returns the name of the scene that is being played. If no scene is currently being played, returns an empty string.
*/
func GetPlayingScene() string { //gd:EditorInterface.get_playing_scene
	once.Do(singleton)
	return string(Advanced().GetPlayingScene().String())
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
func Advanced() class { once.Do(singleton); return self }

type class [1]gdclass.EditorInterface

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }

func DistractionFreeMode() bool {
	once.Do(singleton)
	return bool(class(self).IsDistractionFreeModeEnabled())
}

func SetDistractionFreeMode(value bool) {
	once.Do(singleton)
	class(self).SetDistractionFreeMode(value)
}

func MovieMakerEnabled() bool {
	once.Do(singleton)
	return bool(class(self).IsMovieMakerEnabled())
}

func SetMovieMakerEnabled(value bool) {
	once.Do(singleton)
	class(self).SetMovieMakerEnabled(value)
}

/*
Restarts the editor. This closes the editor and then opens the same project. If [param save] is [code]true[/code], the project will be saved before restarting.
*/
//go:nosplit
func (self class) RestartEditor(save bool) { //gd:EditorInterface.restart_editor
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.EditorInterface.Bind_restart_editor), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ save bool }{save}))
}

/*
Returns the editor's [EditorCommandPalette] instance.
[b]Warning:[/b] Removing and freeing this node will render a part of the editor useless and may cause a crash.
*/
//go:nosplit
func (self class) GetCommandPalette() [1]gdclass.EditorCommandPalette { //gd:EditorInterface.get_command_palette
	var r_ret = gdextension.Call[gd.EnginePointer](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.EditorInterface.Bind_get_command_palette), gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.EditorCommandPalette{gd.PointerLifetimeBoundTo[gdclass.EditorCommandPalette](self.AsObject(), r_ret)}
	return ret
}

/*
Returns the editor's [EditorFileSystem] instance.
*/
//go:nosplit
func (self class) GetResourceFilesystem() [1]gdclass.EditorFileSystem { //gd:EditorInterface.get_resource_filesystem
	var r_ret = gdextension.Call[gd.EnginePointer](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.EditorInterface.Bind_get_resource_filesystem), gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.EditorFileSystem{gd.PointerLifetimeBoundTo[gdclass.EditorFileSystem](self.AsObject(), r_ret)}
	return ret
}

/*
Returns the [EditorPaths] singleton.
*/
//go:nosplit
func (self class) GetEditorPaths() [1]gdclass.EditorPaths { //gd:EditorInterface.get_editor_paths
	var r_ret = gdextension.Call[gd.EnginePointer](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.EditorInterface.Bind_get_editor_paths), gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.EditorPaths{gd.PointerLifetimeBoundTo[gdclass.EditorPaths](self.AsObject(), r_ret)}
	return ret
}

/*
Returns the editor's [EditorResourcePreview] instance.
*/
//go:nosplit
func (self class) GetResourcePreviewer() [1]gdclass.EditorResourcePreview { //gd:EditorInterface.get_resource_previewer
	var r_ret = gdextension.Call[gd.EnginePointer](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.EditorInterface.Bind_get_resource_previewer), gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.EditorResourcePreview{gd.PointerLifetimeBoundTo[gdclass.EditorResourcePreview](self.AsObject(), r_ret)}
	return ret
}

/*
Returns the editor's [EditorSelection] instance.
*/
//go:nosplit
func (self class) GetSelection() [1]gdclass.EditorSelection { //gd:EditorInterface.get_selection
	var r_ret = gdextension.Call[gd.EnginePointer](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.EditorInterface.Bind_get_selection), gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.EditorSelection{gd.PointerLifetimeBoundTo[gdclass.EditorSelection](self.AsObject(), r_ret)}
	return ret
}

/*
Returns the editor's [EditorSettings] instance.
*/
//go:nosplit
func (self class) GetEditorSettings() [1]gdclass.EditorSettings { //gd:EditorInterface.get_editor_settings
	var r_ret = gdextension.Call[gd.EnginePointer](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.EditorInterface.Bind_get_editor_settings), gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.EditorSettings{gd.PointerWithOwnershipTransferredToGo[gdclass.EditorSettings](r_ret)}
	return ret
}

/*
Returns the editor's [EditorToaster].
*/
//go:nosplit
func (self class) GetEditorToaster() [1]gdclass.EditorToaster { //gd:EditorInterface.get_editor_toaster
	var r_ret = gdextension.Call[gd.EnginePointer](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.EditorInterface.Bind_get_editor_toaster), gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.EditorToaster{gd.PointerLifetimeBoundTo[gdclass.EditorToaster](self.AsObject(), r_ret)}
	return ret
}

/*
Returns the editor's [EditorUndoRedoManager].
*/
//go:nosplit
func (self class) GetEditorUndoRedo() [1]gdclass.EditorUndoRedoManager { //gd:EditorInterface.get_editor_undo_redo
	var r_ret = gdextension.Call[gd.EnginePointer](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.EditorInterface.Bind_get_editor_undo_redo), gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.EditorUndoRedoManager{gd.PointerLifetimeBoundTo[gdclass.EditorUndoRedoManager](self.AsObject(), r_ret)}
	return ret
}

/*
Returns mesh previews rendered at the given size as an [Array] of [Texture2D]s.
*/
//go:nosplit
func (self class) MakeMeshPreviews(meshes Array.Contains[[1]gdclass.Mesh], preview_size int64) Array.Contains[[1]gdclass.Texture2D] { //gd:EditorInterface.make_mesh_previews
	var r_ret = gdextension.Call[[1]gd.EnginePointer](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.EditorInterface.Bind_make_mesh_previews), gdextension.SizeArray|(gdextension.SizeArray<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		meshes       gdextension.Array
		preview_size int64
	}{gdextension.Array(pointers.Get(gd.InternalArray(meshes))[0]), preview_size}))
	var ret = Array.Through(gd.ArrayProxy[[1]gdclass.Texture2D]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

/*
Sets the enabled status of a plugin. The plugin name is the same as its directory name.
*/
//go:nosplit
func (self class) SetPluginEnabled(plugin String.Readable, enabled bool) { //gd:EditorInterface.set_plugin_enabled
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.EditorInterface.Bind_set_plugin_enabled), 0|(gdextension.SizeString<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		plugin  gdextension.String
		enabled bool
	}{gdextension.String(pointers.Get(gd.InternalString(plugin))[0]), enabled}))
}

/*
Returns [code]true[/code] if the specified [param plugin] is enabled. The plugin name is the same as its directory name.
*/
//go:nosplit
func (self class) IsPluginEnabled(plugin String.Readable) bool { //gd:EditorInterface.is_plugin_enabled
	var r_ret = gdextension.Call[bool](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.EditorInterface.Bind_is_plugin_enabled), gdextension.SizeBool|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ plugin gdextension.String }{gdextension.String(pointers.Get(gd.InternalString(plugin))[0])}))
	var ret = r_ret
	return ret
}

/*
Returns the editor's [Theme].
[b]Note:[/b] When creating custom editor UI, prefer accessing theme items directly from your GUI nodes using the [code]get_theme_*[/code] methods.
*/
//go:nosplit
func (self class) GetEditorTheme() [1]gdclass.Theme { //gd:EditorInterface.get_editor_theme
	var r_ret = gdextension.Call[gd.EnginePointer](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.EditorInterface.Bind_get_editor_theme), gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.Theme{gd.PointerWithOwnershipTransferredToGo[gdclass.Theme](r_ret)}
	return ret
}

/*
Returns the main container of Godot editor's window. For example, you can use it to retrieve the size of the container and place your controls accordingly.
[b]Warning:[/b] Removing and freeing this node will render the editor useless and may cause a crash.
*/
//go:nosplit
func (self class) GetBaseControl() [1]gdclass.Control { //gd:EditorInterface.get_base_control
	var r_ret = gdextension.Call[gd.EnginePointer](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.EditorInterface.Bind_get_base_control), gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.Control{gd.PointerLifetimeBoundTo[gdclass.Control](self.AsObject(), r_ret)}
	return ret
}

/*
Returns the editor control responsible for main screen plugins and tools. Use it with plugins that implement [method EditorPlugin._has_main_screen].
[b]Note:[/b] This node is a [VBoxContainer], which means that if you add a [Control] child to it, you need to set the child's [member Control.size_flags_vertical] to [constant Control.SIZE_EXPAND_FILL] to make it use the full available space.
[b]Warning:[/b] Removing and freeing this node will render a part of the editor useless and may cause a crash.
*/
//go:nosplit
func (self class) GetEditorMainScreen() [1]gdclass.VBoxContainer { //gd:EditorInterface.get_editor_main_screen
	var r_ret = gdextension.Call[gd.EnginePointer](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.EditorInterface.Bind_get_editor_main_screen), gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.VBoxContainer{gd.PointerLifetimeBoundTo[gdclass.VBoxContainer](self.AsObject(), r_ret)}
	return ret
}

/*
Returns the editor's [ScriptEditor] instance.
[b]Warning:[/b] Removing and freeing this node will render a part of the editor useless and may cause a crash.
*/
//go:nosplit
func (self class) GetScriptEditor() [1]gdclass.ScriptEditor { //gd:EditorInterface.get_script_editor
	var r_ret = gdextension.Call[gd.EnginePointer](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.EditorInterface.Bind_get_script_editor), gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.ScriptEditor{gd.PointerLifetimeBoundTo[gdclass.ScriptEditor](self.AsObject(), r_ret)}
	return ret
}

/*
Returns the 2D editor [SubViewport]. It does not have a camera. Instead, the view transforms are done directly and can be accessed with [member Viewport.global_canvas_transform].
*/
//go:nosplit
func (self class) GetEditorViewport2d() [1]gdclass.SubViewport { //gd:EditorInterface.get_editor_viewport_2d
	var r_ret = gdextension.Call[gd.EnginePointer](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.EditorInterface.Bind_get_editor_viewport_2d), gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.SubViewport{gd.PointerLifetimeBoundTo[gdclass.SubViewport](self.AsObject(), r_ret)}
	return ret
}

/*
Returns the specified 3D editor [SubViewport], from [code]0[/code] to [code]3[/code]. The viewport can be used to access the active editor cameras with [method Viewport.get_camera_3d].
*/
//go:nosplit
func (self class) GetEditorViewport3d(idx int64) [1]gdclass.SubViewport { //gd:EditorInterface.get_editor_viewport_3d
	var r_ret = gdextension.Call[gd.EnginePointer](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.EditorInterface.Bind_get_editor_viewport_3d), gdextension.SizeObject|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ idx int64 }{idx}))
	var ret = [1]gdclass.SubViewport{gd.PointerLifetimeBoundTo[gdclass.SubViewport](self.AsObject(), r_ret)}
	return ret
}

/*
Sets the editor's current main screen to the one specified in [param name]. [param name] must match the title of the tab in question exactly (e.g. [code]2D[/code], [code]3D[/code], [code skip-lint]Script[/code], or [code]AssetLib[/code] for default tabs).
*/
//go:nosplit
func (self class) SetMainScreenEditor(name String.Readable) { //gd:EditorInterface.set_main_screen_editor
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.EditorInterface.Bind_set_main_screen_editor), 0|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ name gdextension.String }{gdextension.String(pointers.Get(gd.InternalString(name))[0])}))
}

//go:nosplit
func (self class) SetDistractionFreeMode(enter bool) { //gd:EditorInterface.set_distraction_free_mode
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.EditorInterface.Bind_set_distraction_free_mode), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enter bool }{enter}))
}

//go:nosplit
func (self class) IsDistractionFreeModeEnabled() bool { //gd:EditorInterface.is_distraction_free_mode_enabled
	var r_ret = gdextension.Call[bool](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.EditorInterface.Bind_is_distraction_free_mode_enabled), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if multiple window support is enabled in the editor. Multiple window support is enabled if [i]all[/i] of these statements are true:
- [member EditorSettings.interface/multi_window/enable] is [code]true[/code].
- [member EditorSettings.interface/editor/single_window_mode] is [code]false[/code].
- [member Viewport.gui_embed_subwindows] is [code]false[/code]. This is forced to [code]true[/code] on platforms that don't support multiple windows such as Web, or when the [code]--single-window[/code] [url=$DOCS_URL/tutorials/editor/command_line_tutorial.html]command line argument[/url] is used.
*/
//go:nosplit
func (self class) IsMultiWindowEnabled() bool { //gd:EditorInterface.is_multi_window_enabled
	var r_ret = gdextension.Call[bool](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.EditorInterface.Bind_is_multi_window_enabled), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the actual scale of the editor UI ([code]1.0[/code] being 100% scale). This can be used to adjust position and dimensions of the UI added by plugins.
[b]Note:[/b] This value is set via the [code]interface/editor/display_scale[/code] and [code]interface/editor/custom_display_scale[/code] editor settings. Editor must be restarted for changes to be properly applied.
*/
//go:nosplit
func (self class) GetEditorScale() float64 { //gd:EditorInterface.get_editor_scale
	var r_ret = gdextension.Call[float64](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.EditorInterface.Bind_get_editor_scale), gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Pops up the [param dialog] in the editor UI with [method Window.popup_exclusive]. The dialog must have no current parent, otherwise the method fails.
See also [method Window.set_unparent_when_invisible].
*/
//go:nosplit
func (self class) PopupDialog(dialog [1]gdclass.Window, rect Rect2i.PositionSize) { //gd:EditorInterface.popup_dialog
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.EditorInterface.Bind_popup_dialog), 0|(gdextension.SizeObject<<4)|(gdextension.SizeRect2i<<8), unsafe.Pointer(&struct {
		dialog gdextension.Object
		rect   Rect2i.PositionSize
	}{gdextension.Object(gd.ObjectChecked(dialog[0].AsObject())), rect}))
}

/*
Pops up the [param dialog] in the editor UI with [method Window.popup_exclusive_centered]. The dialog must have no current parent, otherwise the method fails.
See also [method Window.set_unparent_when_invisible].
*/
//go:nosplit
func (self class) PopupDialogCentered(dialog [1]gdclass.Window, minsize Vector2i.XY) { //gd:EditorInterface.popup_dialog_centered
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.EditorInterface.Bind_popup_dialog_centered), 0|(gdextension.SizeObject<<4)|(gdextension.SizeVector2i<<8), unsafe.Pointer(&struct {
		dialog  gdextension.Object
		minsize Vector2i.XY
	}{gdextension.Object(gd.ObjectChecked(dialog[0].AsObject())), minsize}))
}

/*
Pops up the [param dialog] in the editor UI with [method Window.popup_exclusive_centered_ratio]. The dialog must have no current parent, otherwise the method fails.
See also [method Window.set_unparent_when_invisible].
*/
//go:nosplit
func (self class) PopupDialogCenteredRatio(dialog [1]gdclass.Window, ratio float64) { //gd:EditorInterface.popup_dialog_centered_ratio
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.EditorInterface.Bind_popup_dialog_centered_ratio), 0|(gdextension.SizeObject<<4)|(gdextension.SizeFloat<<8), unsafe.Pointer(&struct {
		dialog gdextension.Object
		ratio  float64
	}{gdextension.Object(gd.ObjectChecked(dialog[0].AsObject())), ratio}))
}

/*
Pops up the [param dialog] in the editor UI with [method Window.popup_exclusive_centered_clamped]. The dialog must have no current parent, otherwise the method fails.
See also [method Window.set_unparent_when_invisible].
*/
//go:nosplit
func (self class) PopupDialogCenteredClamped(dialog [1]gdclass.Window, minsize Vector2i.XY, fallback_ratio float64) { //gd:EditorInterface.popup_dialog_centered_clamped
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.EditorInterface.Bind_popup_dialog_centered_clamped), 0|(gdextension.SizeObject<<4)|(gdextension.SizeVector2i<<8)|(gdextension.SizeFloat<<12), unsafe.Pointer(&struct {
		dialog         gdextension.Object
		minsize        Vector2i.XY
		fallback_ratio float64
	}{gdextension.Object(gd.ObjectChecked(dialog[0].AsObject())), minsize, fallback_ratio}))
}

/*
Returns the name of the currently activated feature profile. If the default profile is currently active, an empty string is returned instead.
In order to get a reference to the [EditorFeatureProfile], you must load the feature profile using [method EditorFeatureProfile.load_from_file].
[b]Note:[/b] Feature profiles created via the user interface are loaded from the [code]feature_profiles[/code] directory, as a file with the [code].profile[/code] extension. The editor configuration folder can be found by using [method EditorPaths.get_config_dir].
*/
//go:nosplit
func (self class) GetCurrentFeatureProfile() String.Readable { //gd:EditorInterface.get_current_feature_profile
	var r_ret = gdextension.Call[[1]gd.EnginePointer](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.EditorInterface.Bind_get_current_feature_profile), gdextension.SizeString, unsafe.Pointer(&struct{}{}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Selects and activates the specified feature profile with the given [param profile_name]. Set [param profile_name] to an empty string to reset to the default feature profile.
A feature profile can be created programmatically using the [EditorFeatureProfile] class.
[b]Note:[/b] The feature profile that gets activated must be located in the [code]feature_profiles[/code] directory, as a file with the [code].profile[/code] extension. If a profile could not be found, an error occurs. The editor configuration folder can be found by using [method EditorPaths.get_config_dir].
*/
//go:nosplit
func (self class) SetCurrentFeatureProfile(profile_name String.Readable) { //gd:EditorInterface.set_current_feature_profile
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.EditorInterface.Bind_set_current_feature_profile), 0|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ profile_name gdextension.String }{gdextension.String(pointers.Get(gd.InternalString(profile_name))[0])}))
}

/*
Pops up an editor dialog for selecting a [Node] from the edited scene. The [param callback] must take a single argument of type [NodePath]. It is called on the selected [NodePath] or the empty path [code]^""[/code] if the dialog is canceled. If [param valid_types] is provided, the dialog will only show Nodes that match one of the listed Node types. If [param current_value] is provided, the Node will be automatically selected in the tree, if it exists.
[b]Example:[/b] Display the node selection dialog as soon as this node is added to the tree for the first time:
[codeblock]
func _ready():
    if Engine.is_editor_hint():
        EditorInterface.popup_node_selector(_on_node_selected, ["Button"])

func _on_node_selected(node_path):
    if node_path.is_empty():
        print("node selection canceled")
    else:
        print("selected ", node_path)
[/codeblock]
*/
//go:nosplit
func (self class) PopupNodeSelector(callback Callable.Function, valid_types Array.Contains[String.Name], current_value [1]gdclass.Node) { //gd:EditorInterface.popup_node_selector
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.EditorInterface.Bind_popup_node_selector), 0|(gdextension.SizeCallable<<4)|(gdextension.SizeArray<<8)|(gdextension.SizeObject<<12), unsafe.Pointer(&struct {
		callback      gdextension.Callable
		valid_types   gdextension.Array
		current_value gdextension.Object
	}{gdextension.Callable(pointers.Get(gd.InternalCallable(callback))), gdextension.Array(pointers.Get(gd.InternalArray(valid_types))[0]), gdextension.Object(gd.ObjectChecked(current_value[0].AsObject()))}))
}

/*
Pops up an editor dialog for selecting properties from [param object]. The [param callback] must take a single argument of type [NodePath]. It is called on the selected property path (see [method NodePath.get_as_property_path]) or the empty path [code]^""[/code] if the dialog is canceled. If [param type_filter] is provided, the dialog will only show properties that match one of the listed [enum Variant.Type] values. If [param current_value] is provided, the property will be selected automatically in the property list, if it exists.
[codeblock]
func _ready():
    if Engine.is_editor_hint():
        EditorInterface.popup_property_selector(this, _on_property_selected, [TYPE_INT])

func _on_property_selected(property_path):
    if property_path.is_empty():
        print("property selection canceled")
    else:
        print("selected ", property_path)
[/codeblock]
*/
//go:nosplit
func (self class) PopupPropertySelector(obj [1]gd.Object, callback Callable.Function, type_filter Packed.Array[int32], current_value String.Readable) { //gd:EditorInterface.popup_property_selector
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.EditorInterface.Bind_popup_property_selector), 0|(gdextension.SizeObject<<4)|(gdextension.SizeCallable<<8)|(gdextension.SizePackedArray<<12)|(gdextension.SizeString<<16), unsafe.Pointer(&struct {
		obj           gdextension.Object
		callback      gdextension.Callable
		type_filter   gdextension.PackedArray
		current_value gdextension.String
	}{gdextension.Object(gd.ObjectChecked(obj[0].AsObject())), gdextension.Callable(pointers.Get(gd.InternalCallable(callback))), gdextension.ToPackedArray(pointers.Get(gd.InternalPacked[gd.PackedInt32Array, int32](type_filter))), gdextension.String(pointers.Get(gd.InternalString(current_value))[0])}))
}

/*
Pops up an editor dialog for selecting a method from [param object]. The [param callback] must take a single argument of type [String] which will contain the name of the selected method or be empty if the dialog is canceled. If [param current_value] is provided, the method will be selected automatically in the method list, if it exists.
*/
//go:nosplit
func (self class) PopupMethodSelector(obj [1]gd.Object, callback Callable.Function, current_value String.Readable) { //gd:EditorInterface.popup_method_selector
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.EditorInterface.Bind_popup_method_selector), 0|(gdextension.SizeObject<<4)|(gdextension.SizeCallable<<8)|(gdextension.SizeString<<12), unsafe.Pointer(&struct {
		obj           gdextension.Object
		callback      gdextension.Callable
		current_value gdextension.String
	}{gdextension.Object(gd.ObjectChecked(obj[0].AsObject())), gdextension.Callable(pointers.Get(gd.InternalCallable(callback))), gdextension.String(pointers.Get(gd.InternalString(current_value))[0])}))
}

/*
Pops up an editor dialog for quick selecting a resource file. The [param callback] must take a single argument of type [String] which will contain the path of the selected resource or be empty if the dialog is canceled. If [param base_types] is provided, the dialog will only show resources that match these types. Only types deriving from [Resource] are supported.
*/
//go:nosplit
func (self class) PopupQuickOpen(callback Callable.Function, base_types Array.Contains[String.Name]) { //gd:EditorInterface.popup_quick_open
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.EditorInterface.Bind_popup_quick_open), 0|(gdextension.SizeCallable<<4)|(gdextension.SizeArray<<8), unsafe.Pointer(&struct {
		callback   gdextension.Callable
		base_types gdextension.Array
	}{gdextension.Callable(pointers.Get(gd.InternalCallable(callback))), gdextension.Array(pointers.Get(gd.InternalArray(base_types))[0])}))
}

/*
Pops up an editor dialog for creating an object.
The [param callback] must take a single argument of type [StringName] which will contain the type name of the selected object or be empty if no item is selected.
The [param base_type] specifies the base type of objects to display. For example, if you set this to "Resource", all types derived from [Resource] will display in the create dialog.
The [param current_type] will be passed in the search box of the create dialog, and the specified type can be immediately selected when the dialog pops up. If the [param current_type] is not derived from [param base_type], there will be no result of the type in the dialog.
The [param dialog_title] allows you to define a custom title for the dialog. This is useful if you want to accurately hint the usage of the dialog. If the [param dialog_title] is an empty string, the dialog will use "Create New 'Base Type'" as the default title.
The [param type_blocklist] contains a list of type names, and the types in the blocklist will be hidden from the create dialog.
[b]Note:[/b] Trying to list the base type in the [param type_blocklist] will hide all types derived from the base type from the create dialog.
*/
//go:nosplit
func (self class) PopupCreateDialog(callback Callable.Function, base_type String.Name, current_type String.Readable, dialog_title String.Readable, type_blocklist Array.Contains[String.Name]) { //gd:EditorInterface.popup_create_dialog
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.EditorInterface.Bind_popup_create_dialog), 0|(gdextension.SizeCallable<<4)|(gdextension.SizeStringName<<8)|(gdextension.SizeString<<12)|(gdextension.SizeString<<16)|(gdextension.SizeArray<<20), unsafe.Pointer(&struct {
		callback       gdextension.Callable
		base_type      gdextension.StringName
		current_type   gdextension.String
		dialog_title   gdextension.String
		type_blocklist gdextension.Array
	}{gdextension.Callable(pointers.Get(gd.InternalCallable(callback))), gdextension.StringName(pointers.Get(gd.InternalStringName(base_type))[0]), gdextension.String(pointers.Get(gd.InternalString(current_type))[0]), gdextension.String(pointers.Get(gd.InternalString(dialog_title))[0]), gdextension.Array(pointers.Get(gd.InternalArray(type_blocklist))[0])}))
}

/*
Returns the editor's [FileSystemDock] instance.
[b]Warning:[/b] Removing and freeing this node will render a part of the editor useless and may cause a crash.
*/
//go:nosplit
func (self class) GetFileSystemDock() [1]gdclass.FileSystemDock { //gd:EditorInterface.get_file_system_dock
	var r_ret = gdextension.Call[gd.EnginePointer](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.EditorInterface.Bind_get_file_system_dock), gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.FileSystemDock{gd.PointerLifetimeBoundTo[gdclass.FileSystemDock](self.AsObject(), r_ret)}
	return ret
}

/*
Selects the file, with the path provided by [param file], in the FileSystem dock.
*/
//go:nosplit
func (self class) SelectFile(file String.Readable) { //gd:EditorInterface.select_file
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.EditorInterface.Bind_select_file), 0|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ file gdextension.String }{gdextension.String(pointers.Get(gd.InternalString(file))[0])}))
}

/*
Returns an array containing the paths of the currently selected files (and directories) in the [FileSystemDock].
*/
//go:nosplit
func (self class) GetSelectedPaths() Packed.Strings { //gd:EditorInterface.get_selected_paths
	var r_ret = gdextension.Call[gd.PackedPointers](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.EditorInterface.Bind_get_selected_paths), gdextension.SizePackedArray, unsafe.Pointer(&struct{}{}))
	var ret = Packed.Strings(Array.Through(gd.PackedStringArrayProxy{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

/*
Returns the current path being viewed in the [FileSystemDock].
*/
//go:nosplit
func (self class) GetCurrentPath() String.Readable { //gd:EditorInterface.get_current_path
	var r_ret = gdextension.Call[[1]gd.EnginePointer](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.EditorInterface.Bind_get_current_path), gdextension.SizeString, unsafe.Pointer(&struct{}{}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Returns the current directory being viewed in the [FileSystemDock]. If a file is selected, its base directory will be returned using [method String.get_base_dir] instead.
*/
//go:nosplit
func (self class) GetCurrentDirectory() String.Readable { //gd:EditorInterface.get_current_directory
	var r_ret = gdextension.Call[[1]gd.EnginePointer](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.EditorInterface.Bind_get_current_directory), gdextension.SizeString, unsafe.Pointer(&struct{}{}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Returns the editor's [EditorInspector] instance.
[b]Warning:[/b] Removing and freeing this node will render a part of the editor useless and may cause a crash.
*/
//go:nosplit
func (self class) GetInspector() [1]gdclass.EditorInspector { //gd:EditorInterface.get_inspector
	var r_ret = gdextension.Call[gd.EnginePointer](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.EditorInterface.Bind_get_inspector), gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.EditorInspector{gd.PointerLifetimeBoundTo[gdclass.EditorInspector](self.AsObject(), r_ret)}
	return ret
}

/*
Shows the given property on the given [param object] in the editor's Inspector dock. If [param inspector_only] is [code]true[/code], plugins will not attempt to edit [param object].
*/
//go:nosplit
func (self class) InspectObject(obj [1]gd.Object, for_property String.Readable, inspector_only bool) { //gd:EditorInterface.inspect_object
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.EditorInterface.Bind_inspect_object), 0|(gdextension.SizeObject<<4)|(gdextension.SizeString<<8)|(gdextension.SizeBool<<12), unsafe.Pointer(&struct {
		obj            gdextension.Object
		for_property   gdextension.String
		inspector_only bool
	}{gdextension.Object(gd.ObjectChecked(obj[0].AsObject())), gdextension.String(pointers.Get(gd.InternalString(for_property))[0]), inspector_only}))
}

/*
Edits the given [Resource]. If the resource is a [Script] you can also edit it with [method edit_script] to specify the line and column position.
*/
//go:nosplit
func (self class) EditResource(resource [1]gdclass.Resource) { //gd:EditorInterface.edit_resource
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.EditorInterface.Bind_edit_resource), 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ resource gdextension.Object }{gdextension.Object(gd.ObjectChecked(resource[0].AsObject()))}))
}

/*
Edits the given [Node]. The node will be also selected if it's inside the scene tree.
*/
//go:nosplit
func (self class) EditNode(node [1]gdclass.Node) { //gd:EditorInterface.edit_node
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.EditorInterface.Bind_edit_node), 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ node gdextension.Object }{gdextension.Object(gd.ObjectChecked(node[0].AsObject()))}))
}

/*
Edits the given [Script]. The line and column on which to open the script can also be specified. The script will be open with the user-configured editor for the script's language which may be an external editor.
*/
//go:nosplit
func (self class) EditScript(script [1]gdclass.Script, line int64, column int64, grab_focus bool) { //gd:EditorInterface.edit_script
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.EditorInterface.Bind_edit_script), 0|(gdextension.SizeObject<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeBool<<16), unsafe.Pointer(&struct {
		script     gdextension.Object
		line       int64
		column     int64
		grab_focus bool
	}{gdextension.Object(gd.ObjectChecked(script[0].AsObject())), line, column, grab_focus}))
}

/*
Opens the scene at the given path. If [param set_inherited] is [code]true[/code], creates a new inherited scene.
*/
//go:nosplit
func (self class) OpenSceneFromPath(scene_filepath String.Readable, set_inherited bool) { //gd:EditorInterface.open_scene_from_path
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.EditorInterface.Bind_open_scene_from_path), 0|(gdextension.SizeString<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		scene_filepath gdextension.String
		set_inherited  bool
	}{gdextension.String(pointers.Get(gd.InternalString(scene_filepath))[0]), set_inherited}))
}

/*
Reloads the scene at the given path.
*/
//go:nosplit
func (self class) ReloadSceneFromPath(scene_filepath String.Readable) { //gd:EditorInterface.reload_scene_from_path
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.EditorInterface.Bind_reload_scene_from_path), 0|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ scene_filepath gdextension.String }{gdextension.String(pointers.Get(gd.InternalString(scene_filepath))[0])}))
}

/*
Returns an [Array] with the file paths of the currently opened scenes.
*/
//go:nosplit
func (self class) GetOpenScenes() Packed.Strings { //gd:EditorInterface.get_open_scenes
	var r_ret = gdextension.Call[gd.PackedPointers](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.EditorInterface.Bind_get_open_scenes), gdextension.SizePackedArray, unsafe.Pointer(&struct{}{}))
	var ret = Packed.Strings(Array.Through(gd.PackedStringArrayProxy{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

/*
Returns the edited (current) scene's root [Node].
*/
//go:nosplit
func (self class) GetEditedSceneRoot() [1]gdclass.Node { //gd:EditorInterface.get_edited_scene_root
	var r_ret = gdextension.Call[gd.EnginePointer](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.EditorInterface.Bind_get_edited_scene_root), gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.Node{gd.PointerMustAssertInstanceID[gdclass.Node](r_ret)}
	return ret
}

/*
Saves the currently active scene. Returns either [constant OK] or [constant ERR_CANT_CREATE].
*/
//go:nosplit
func (self class) SaveScene() Error.Code { //gd:EditorInterface.save_scene
	var r_ret = gdextension.Call[int64](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.EditorInterface.Bind_save_scene), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = Error.Code(r_ret)
	return ret
}

/*
Saves the currently active scene as a file at [param path].
*/
//go:nosplit
func (self class) SaveSceneAs(path String.Readable, with_preview bool) { //gd:EditorInterface.save_scene_as
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.EditorInterface.Bind_save_scene_as), 0|(gdextension.SizeString<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		path         gdextension.String
		with_preview bool
	}{gdextension.String(pointers.Get(gd.InternalString(path))[0]), with_preview}))
}

/*
Saves all opened scenes in the editor.
*/
//go:nosplit
func (self class) SaveAllScenes() { //gd:EditorInterface.save_all_scenes
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.EditorInterface.Bind_save_all_scenes), 0, unsafe.Pointer(&struct{}{}))
}

/*
Marks the current scene tab as unsaved.
*/
//go:nosplit
func (self class) MarkSceneAsUnsaved() { //gd:EditorInterface.mark_scene_as_unsaved
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.EditorInterface.Bind_mark_scene_as_unsaved), 0, unsafe.Pointer(&struct{}{}))
}

/*
Plays the main scene.
*/
//go:nosplit
func (self class) PlayMainScene() { //gd:EditorInterface.play_main_scene
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.EditorInterface.Bind_play_main_scene), 0, unsafe.Pointer(&struct{}{}))
}

/*
Plays the currently active scene.
*/
//go:nosplit
func (self class) PlayCurrentScene() { //gd:EditorInterface.play_current_scene
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.EditorInterface.Bind_play_current_scene), 0, unsafe.Pointer(&struct{}{}))
}

/*
Plays the scene specified by its filepath.
*/
//go:nosplit
func (self class) PlayCustomScene(scene_filepath String.Readable) { //gd:EditorInterface.play_custom_scene
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.EditorInterface.Bind_play_custom_scene), 0|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ scene_filepath gdextension.String }{gdextension.String(pointers.Get(gd.InternalString(scene_filepath))[0])}))
}

/*
Stops the scene that is currently playing.
*/
//go:nosplit
func (self class) StopPlayingScene() { //gd:EditorInterface.stop_playing_scene
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.EditorInterface.Bind_stop_playing_scene), 0, unsafe.Pointer(&struct{}{}))
}

/*
Returns [code]true[/code] if a scene is currently being played, [code]false[/code] otherwise. Paused scenes are considered as being played.
*/
//go:nosplit
func (self class) IsPlayingScene() bool { //gd:EditorInterface.is_playing_scene
	var r_ret = gdextension.Call[bool](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.EditorInterface.Bind_is_playing_scene), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the name of the scene that is being played. If no scene is currently being played, returns an empty string.
*/
//go:nosplit
func (self class) GetPlayingScene() String.Readable { //gd:EditorInterface.get_playing_scene
	var r_ret = gdextension.Call[[1]gd.EnginePointer](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.EditorInterface.Bind_get_playing_scene), gdextension.SizeString, unsafe.Pointer(&struct{}{}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

//go:nosplit
func (self class) SetMovieMakerEnabled(enabled bool) { //gd:EditorInterface.set_movie_maker_enabled
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.EditorInterface.Bind_set_movie_maker_enabled), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enabled bool }{enabled}))
}

//go:nosplit
func (self class) IsMovieMakerEnabled() bool { //gd:EditorInterface.is_movie_maker_enabled
	var r_ret = gdextension.Call[bool](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.EditorInterface.Bind_is_movie_maker_enabled), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}
func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Object.Advanced(self.AsObject()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Object.Instance(self.AsObject()), name)
	}
}
func init() {
	gdclass.Register("EditorInterface", func(ptr gd.Object) any {
		return [1]gdclass.EditorInterface{*(*gdclass.EditorInterface)(unsafe.Pointer(&ptr))}
	})
}
