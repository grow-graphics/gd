// Code generated by the generate package DO NOT EDIT

// Package TileMapLayer provides methods for working with TileMapLayer object instances.
package TileMapLayer

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/CanvasItem"
import "graphics.gd/classdb/Node"
import "graphics.gd/classdb/Node2D"
import "graphics.gd/classdb/TileData"
import "graphics.gd/classdb/TileMapPattern"
import "graphics.gd/classdb/TileSet"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/Rect2i"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"
import "graphics.gd/variant/Vector2"
import "graphics.gd/variant/Vector2i"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
Node for 2D tile-based maps. A [TileMapLayer] uses a [TileSet] which contain a list of tiles which are used to create grid-based maps. Unlike the [TileMap] node, which is deprecated, [TileMapLayer] has only one layer of tiles. You can use several [TileMapLayer] to achieve the same result as a [TileMap] node.
For performance reasons, all TileMap updates are batched at the end of a frame. Notably, this means that scene tiles from a [TileSetScenesCollectionSource] may be initialized after their parent. This is only queued when inside the scene tree.
To force an update earlier on, call [method update_internals].
[b]Note:[/b] For performance and compatibility reasons, the coordinates serialized by [TileMapLayer] are limited to 16-bit signed integers, i.e. the range for X and Y coordinates is from [code]-32768[/code] to [code]32767[/code]. When saving tile data, tiles outside this range are wrapped.

	See [Interface] for methods that can be overridden by a [Class] that extends it.
*/
type Instance [1]gdclass.TileMapLayer

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	set_cell                        gdextension.MethodForClass `hash:"2428518503"`
	erase_cell                      gdextension.MethodForClass `hash:"1130785943"`
	fix_invalid_tiles               gdextension.MethodForClass `hash:"3218959716"`
	clear                           gdextension.MethodForClass `hash:"3218959716"`
	get_cell_source_id              gdextension.MethodForClass `hash:"2485466453"`
	get_cell_atlas_coords           gdextension.MethodForClass `hash:"3050897911"`
	get_cell_alternative_tile       gdextension.MethodForClass `hash:"2485466453"`
	get_cell_tile_data              gdextension.MethodForClass `hash:"205084707"`
	is_cell_flipped_h               gdextension.MethodForClass `hash:"3900751641"`
	is_cell_flipped_v               gdextension.MethodForClass `hash:"3900751641"`
	is_cell_transposed              gdextension.MethodForClass `hash:"3900751641"`
	get_used_cells                  gdextension.MethodForClass `hash:"3995934104"`
	get_used_cells_by_id            gdextension.MethodForClass `hash:"4175304538"`
	get_used_rect                   gdextension.MethodForClass `hash:"410525958"`
	get_pattern                     gdextension.MethodForClass `hash:"3820813253"`
	set_pattern                     gdextension.MethodForClass `hash:"1491151770"`
	set_cells_terrain_connect       gdextension.MethodForClass `hash:"748968311"`
	set_cells_terrain_path          gdextension.MethodForClass `hash:"748968311"`
	has_body_rid                    gdextension.MethodForClass `hash:"4155700596"`
	get_coords_for_body_rid         gdextension.MethodForClass `hash:"733700038"`
	update_internals                gdextension.MethodForClass `hash:"3218959716"`
	notify_runtime_tile_data_update gdextension.MethodForClass `hash:"3218959716"`
	map_pattern                     gdextension.MethodForClass `hash:"1864516957"`
	get_surrounding_cells           gdextension.MethodForClass `hash:"2673526557"`
	get_neighbor_cell               gdextension.MethodForClass `hash:"986575103"`
	map_to_local                    gdextension.MethodForClass `hash:"108438297"`
	local_to_map                    gdextension.MethodForClass `hash:"837806996"`
	set_tile_map_data_from_array    gdextension.MethodForClass `hash:"2971499966"`
	get_tile_map_data_as_array      gdextension.MethodForClass `hash:"2362200018"`
	set_enabled                     gdextension.MethodForClass `hash:"2586408642"`
	is_enabled                      gdextension.MethodForClass `hash:"36873697"`
	set_tile_set                    gdextension.MethodForClass `hash:"774531446"`
	get_tile_set                    gdextension.MethodForClass `hash:"2678226422"`
	set_y_sort_origin               gdextension.MethodForClass `hash:"1286410249"`
	get_y_sort_origin               gdextension.MethodForClass `hash:"3905245786"`
	set_x_draw_order_reversed       gdextension.MethodForClass `hash:"2586408642"`
	is_x_draw_order_reversed        gdextension.MethodForClass `hash:"36873697"`
	set_rendering_quadrant_size     gdextension.MethodForClass `hash:"1286410249"`
	get_rendering_quadrant_size     gdextension.MethodForClass `hash:"3905245786"`
	set_collision_enabled           gdextension.MethodForClass `hash:"2586408642"`
	is_collision_enabled            gdextension.MethodForClass `hash:"36873697"`
	set_use_kinematic_bodies        gdextension.MethodForClass `hash:"2586408642"`
	is_using_kinematic_bodies       gdextension.MethodForClass `hash:"36873697"`
	set_collision_visibility_mode   gdextension.MethodForClass `hash:"3508099847"`
	get_collision_visibility_mode   gdextension.MethodForClass `hash:"338220793"`
	set_occlusion_enabled           gdextension.MethodForClass `hash:"2586408642"`
	is_occlusion_enabled            gdextension.MethodForClass `hash:"36873697"`
	set_navigation_enabled          gdextension.MethodForClass `hash:"2586408642"`
	is_navigation_enabled           gdextension.MethodForClass `hash:"36873697"`
	set_navigation_map              gdextension.MethodForClass `hash:"2722037293"`
	get_navigation_map              gdextension.MethodForClass `hash:"2944877500"`
	set_navigation_visibility_mode  gdextension.MethodForClass `hash:"3508099847"`
	get_navigation_visibility_mode  gdextension.MethodForClass `hash:"338220793"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("TileMapLayer")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		gdextension.Free(gdextension.TypeStringName, &sname)
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

type Expanded [1]gdclass.TileMapLayer

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsTileMapLayer() Instance
}
type Interface interface {
	//Should return [code]true[/code] if the tile at coordinates [param coords] requires a runtime update.
	//[b]Warning:[/b] Make sure this function only returns [code]true[/code] when needed. Any tile processed at runtime without a need for it will imply a significant performance penalty.
	//[b]Note:[/b] If the result of this function should change, use [method notify_runtime_tile_data_update] to notify the [TileMapLayer] it needs an update.
	UseTileDataRuntimeUpdate(coords Vector2i.XY) bool
	//Called with a [TileData] object about to be used internally by the [TileMapLayer], allowing its modification at runtime.
	//This method is only called if [method _use_tile_data_runtime_update] is implemented and returns [code]true[/code] for the given tile [param coords].
	//[b]Warning:[/b] The [param tile_data] object's sub-resources are the same as the one in the TileSet. Modifying them might impact the whole TileSet. Instead, make sure to duplicate those resources.
	//[b]Note:[/b] If the properties of [param tile_data] object should change over time, use [method notify_runtime_tile_data_update] to notify the [TileMapLayer] it needs an update.
	TileDataRuntimeUpdate(coords Vector2i.XY, tile_data TileData.Instance)
	//Called when this [TileMapLayer]'s cells need an internal update. This update may be caused from individual cells being modified or by a change in the [member tile_set] (causing all cells to be queued for an update). The first call to this function is always for initializing all the [TileMapLayer]'s cells. [param coords] contains the coordinates of all modified cells, roughly in the order they were modified. [param forced_cleanup] is [code]true[/code] when the [TileMapLayer]'s internals should be fully cleaned up. This is the case when:
	//- The layer is disabled;
	//- The layer is not visible;
	//- [member tile_set] is set to [code]null[/code];
	//- The node is removed from the tree;
	//- The node is freed.
	//Note that any internal update happening while one of these conditions is verified is considered to be a "cleanup". See also [method update_internals].
	//[b]Warning:[/b] Implementing this method may degrade the [TileMapLayer]'s performance.
	UpdateCells(coords []Vector2i.XY, forced_cleanup bool)
}

// Implementation implements [Interface] with empty methods.
type Implementation = implementation

type implementation struct{}

func (self implementation) UseTileDataRuntimeUpdate(coords Vector2i.XY) (_ bool) { return }
func (self implementation) TileDataRuntimeUpdate(coords Vector2i.XY, tile_data TileData.Instance) {
	return
}
func (self implementation) UpdateCells(coords []Vector2i.XY, forced_cleanup bool) { return }

/*
Should return [code]true[/code] if the tile at coordinates [param coords] requires a runtime update.
[b]Warning:[/b] Make sure this function only returns [code]true[/code] when needed. Any tile processed at runtime without a need for it will imply a significant performance penalty.
[b]Note:[/b] If the result of this function should change, use [method notify_runtime_tile_data_update] to notify the [TileMapLayer] it needs an update.
*/
func (Instance) _use_tile_data_runtime_update(impl func(ptr unsafe.Pointer, coords Vector2i.XY) bool) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var coords = gd.UnsafeGet[Vector2i.XY](p_args, 0)
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self, coords)
		gd.UnsafeSet(p_back, ret)
	}
}

/*
Called with a [TileData] object about to be used internally by the [TileMapLayer], allowing its modification at runtime.
This method is only called if [method _use_tile_data_runtime_update] is implemented and returns [code]true[/code] for the given tile [param coords].
[b]Warning:[/b] The [param tile_data] object's sub-resources are the same as the one in the TileSet. Modifying them might impact the whole TileSet. Instead, make sure to duplicate those resources.
[b]Note:[/b] If the properties of [param tile_data] object should change over time, use [method notify_runtime_tile_data_update] to notify the [TileMapLayer] it needs an update.
*/
func (Instance) _tile_data_runtime_update(impl func(ptr unsafe.Pointer, coords Vector2i.XY, tile_data TileData.Instance)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var coords = gd.UnsafeGet[Vector2i.XY](p_args, 0)
		var tile_data = [1]gdclass.TileData{pointers.New[gdclass.TileData]([3]uint64{uint64(gd.UnsafeGet[gdextension.Object](p_args, 1))})}

		defer pointers.End(tile_data[0])
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, coords, tile_data)
	}
}

/*
Called when this [TileMapLayer]'s cells need an internal update. This update may be caused from individual cells being modified or by a change in the [member tile_set] (causing all cells to be queued for an update). The first call to this function is always for initializing all the [TileMapLayer]'s cells. [param coords] contains the coordinates of all modified cells, roughly in the order they were modified. [param forced_cleanup] is [code]true[/code] when the [TileMapLayer]'s internals should be fully cleaned up. This is the case when:
- The layer is disabled;
- The layer is not visible;
- [member tile_set] is set to [code]null[/code];
- The node is removed from the tree;
- The node is freed.
Note that any internal update happening while one of these conditions is verified is considered to be a "cleanup". See also [method update_internals].
[b]Warning:[/b] Implementing this method may degrade the [TileMapLayer]'s performance.
*/
func (Instance) _update_cells(impl func(ptr unsafe.Pointer, coords []Vector2i.XY, forced_cleanup bool)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var coords = Array.Through(gd.ArrayProxy[Vector2i.XY]{}, pointers.Pack(pointers.New[gd.Array](gd.UnsafeGet[gdextension.Array](p_args, 0))))
		defer pointers.End(gd.InternalArray(coords))
		var forced_cleanup = gd.UnsafeGet[bool](p_args, 1)
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, gd.ArrayAs[[]Vector2i.XY](gd.InternalArray(coords)), forced_cleanup)
	}
}

/*
Sets the tile identifiers for the cell at coordinates [param coords]. Each tile of the [TileSet] is identified using three parts:
- The source identifier [param source_id] identifies a [TileSetSource] identifier. See [method TileSet.set_source_id],
- The atlas coordinate identifier [param atlas_coords] identifies a tile coordinates in the atlas (if the source is a [TileSetAtlasSource]). For [TileSetScenesCollectionSource] it should always be [code]Vector2i(0, 0)[/code],
- The alternative tile identifier [param alternative_tile] identifies a tile alternative in the atlas (if the source is a [TileSetAtlasSource]), and the scene for a [TileSetScenesCollectionSource].
If [param source_id] is set to [code]-1[/code], [param atlas_coords] to [code]Vector2i(-1, -1)[/code], or [param alternative_tile] to [code]-1[/code], the cell will be erased. An erased cell gets [b]all[/b] its identifiers automatically set to their respective invalid values, namely [code]-1[/code], [code]Vector2i(-1, -1)[/code] and [code]-1[/code].
*/
func (self Instance) SetCell(coords Vector2i.XY) { //gd:TileMapLayer.set_cell
	Advanced(self).SetCell(Vector2i.XY(coords), int64(-1), Vector2i.XY(gd.Vector2i{-1, -1}), int64(0))
}

/*
Sets the tile identifiers for the cell at coordinates [param coords]. Each tile of the [TileSet] is identified using three parts:
- The source identifier [param source_id] identifies a [TileSetSource] identifier. See [method TileSet.set_source_id],
- The atlas coordinate identifier [param atlas_coords] identifies a tile coordinates in the atlas (if the source is a [TileSetAtlasSource]). For [TileSetScenesCollectionSource] it should always be [code]Vector2i(0, 0)[/code],
- The alternative tile identifier [param alternative_tile] identifies a tile alternative in the atlas (if the source is a [TileSetAtlasSource]), and the scene for a [TileSetScenesCollectionSource].
If [param source_id] is set to [code]-1[/code], [param atlas_coords] to [code]Vector2i(-1, -1)[/code], or [param alternative_tile] to [code]-1[/code], the cell will be erased. An erased cell gets [b]all[/b] its identifiers automatically set to their respective invalid values, namely [code]-1[/code], [code]Vector2i(-1, -1)[/code] and [code]-1[/code].
*/
func (self Expanded) SetCell(coords Vector2i.XY, source_id int, atlas_coords Vector2i.XY, alternative_tile int) { //gd:TileMapLayer.set_cell
	Advanced(self).SetCell(Vector2i.XY(coords), int64(source_id), Vector2i.XY(atlas_coords), int64(alternative_tile))
}

/*
Erases the cell at coordinates [param coords].
*/
func (self Instance) EraseCell(coords Vector2i.XY) { //gd:TileMapLayer.erase_cell
	Advanced(self).EraseCell(Vector2i.XY(coords))
}

/*
Clears cells containing tiles that do not exist in the [member tile_set].
*/
func (self Instance) FixInvalidTiles() { //gd:TileMapLayer.fix_invalid_tiles
	Advanced(self).FixInvalidTiles()
}

/*
Clears all cells.
*/
func (self Instance) Clear() { //gd:TileMapLayer.clear
	Advanced(self).Clear()
}

/*
Returns the tile source ID of the cell at coordinates [param coords]. Returns [code]-1[/code] if the cell does not exist.
*/
func (self Instance) GetCellSourceId(coords Vector2i.XY) int { //gd:TileMapLayer.get_cell_source_id
	return int(int(Advanced(self).GetCellSourceId(Vector2i.XY(coords))))
}

/*
Returns the tile atlas coordinates ID of the cell at coordinates [param coords]. Returns [code]Vector2i(-1, -1)[/code] if the cell does not exist.
*/
func (self Instance) GetCellAtlasCoords(coords Vector2i.XY) Vector2i.XY { //gd:TileMapLayer.get_cell_atlas_coords
	return Vector2i.XY(Advanced(self).GetCellAtlasCoords(Vector2i.XY(coords)))
}

/*
Returns the tile alternative ID of the cell at coordinates [param coords].
*/
func (self Instance) GetCellAlternativeTile(coords Vector2i.XY) int { //gd:TileMapLayer.get_cell_alternative_tile
	return int(int(Advanced(self).GetCellAlternativeTile(Vector2i.XY(coords))))
}

/*
Returns the [TileData] object associated with the given cell, or [code]null[/code] if the cell does not exist or is not a [TileSetAtlasSource].
[codeblock]
func get_clicked_tile_power():

	var clicked_cell = tile_map_layer.local_to_map(tile_map_layer.get_local_mouse_position())
	var data = tile_map_layer.get_cell_tile_data(clicked_cell)
	if data:
	    return data.get_custom_data("power")
	else:
	    return 0

[/codeblock]
*/
func (self Instance) GetCellTileData(coords Vector2i.XY) TileData.Instance { //gd:TileMapLayer.get_cell_tile_data
	return TileData.Instance(Advanced(self).GetCellTileData(Vector2i.XY(coords)))
}

/*
Returns [code]true[/code] if the cell at coordinates [param coords] is flipped horizontally. The result is valid only for atlas sources.
*/
func (self Instance) IsCellFlippedH(coords Vector2i.XY) bool { //gd:TileMapLayer.is_cell_flipped_h
	return bool(Advanced(self).IsCellFlippedH(Vector2i.XY(coords)))
}

/*
Returns [code]true[/code] if the cell at coordinates [param coords] is flipped vertically. The result is valid only for atlas sources.
*/
func (self Instance) IsCellFlippedV(coords Vector2i.XY) bool { //gd:TileMapLayer.is_cell_flipped_v
	return bool(Advanced(self).IsCellFlippedV(Vector2i.XY(coords)))
}

/*
Returns [code]true[/code] if the cell at coordinates [param coords] is transposed. The result is valid only for atlas sources.
*/
func (self Instance) IsCellTransposed(coords Vector2i.XY) bool { //gd:TileMapLayer.is_cell_transposed
	return bool(Advanced(self).IsCellTransposed(Vector2i.XY(coords)))
}

/*
Returns a [Vector2i] array with the positions of all cells containing a tile. A cell is considered empty if its source identifier equals [code]-1[/code], its atlas coordinate identifier is [code]Vector2(-1, -1)[/code] and its alternative identifier is [code]-1[/code].
*/
func (self Instance) GetUsedCells() []Vector2i.XY { //gd:TileMapLayer.get_used_cells
	return []Vector2i.XY(gd.ArrayAs[[]Vector2i.XY](gd.InternalArray(Advanced(self).GetUsedCells())))
}

/*
Returns a [Vector2i] array with the positions of all cells containing a tile. Tiles may be filtered according to their source ([param source_id]), their atlas coordinates ([param atlas_coords]), or alternative id ([param alternative_tile]).
If a parameter has its value set to the default one, this parameter is not used to filter a cell. Thus, if all parameters have their respective default values, this method returns the same result as [method get_used_cells].
A cell is considered empty if its source identifier equals [code]-1[/code], its atlas coordinate identifier is [code]Vector2(-1, -1)[/code] and its alternative identifier is [code]-1[/code].
*/
func (self Instance) GetUsedCellsById() []Vector2i.XY { //gd:TileMapLayer.get_used_cells_by_id
	return []Vector2i.XY(gd.ArrayAs[[]Vector2i.XY](gd.InternalArray(Advanced(self).GetUsedCellsById(int64(-1), Vector2i.XY(gd.Vector2i{-1, -1}), int64(-1)))))
}

/*
Returns a [Vector2i] array with the positions of all cells containing a tile. Tiles may be filtered according to their source ([param source_id]), their atlas coordinates ([param atlas_coords]), or alternative id ([param alternative_tile]).
If a parameter has its value set to the default one, this parameter is not used to filter a cell. Thus, if all parameters have their respective default values, this method returns the same result as [method get_used_cells].
A cell is considered empty if its source identifier equals [code]-1[/code], its atlas coordinate identifier is [code]Vector2(-1, -1)[/code] and its alternative identifier is [code]-1[/code].
*/
func (self Expanded) GetUsedCellsById(source_id int, atlas_coords Vector2i.XY, alternative_tile int) []Vector2i.XY { //gd:TileMapLayer.get_used_cells_by_id
	return []Vector2i.XY(gd.ArrayAs[[]Vector2i.XY](gd.InternalArray(Advanced(self).GetUsedCellsById(int64(source_id), Vector2i.XY(atlas_coords), int64(alternative_tile)))))
}

/*
Returns a rectangle enclosing the used (non-empty) tiles of the map.
*/
func (self Instance) GetUsedRect() Rect2i.PositionSize { //gd:TileMapLayer.get_used_rect
	return Rect2i.PositionSize(Advanced(self).GetUsedRect())
}

/*
Creates and returns a new [TileMapPattern] from the given array of cells. See also [method set_pattern].
*/
func (self Instance) GetPattern(coords_array []Vector2i.XY) TileMapPattern.Instance { //gd:TileMapLayer.get_pattern
	return TileMapPattern.Instance(Advanced(self).GetPattern(gd.ArrayFromSlice[Array.Contains[Vector2i.XY]](coords_array)))
}

/*
Pastes the [TileMapPattern] at the given [param position] in the tile map. See also [method get_pattern].
*/
func (self Instance) SetPattern(position Vector2i.XY, pattern TileMapPattern.Instance) { //gd:TileMapLayer.set_pattern
	Advanced(self).SetPattern(Vector2i.XY(position), pattern)
}

/*
Update all the cells in the [param cells] coordinates array so that they use the given [param terrain] for the given [param terrain_set]. If an updated cell has the same terrain as one of its neighboring cells, this function tries to join the two. This function might update neighboring tiles if needed to create correct terrain transitions.
If [param ignore_empty_terrains] is [code]true[/code], empty terrains will be ignored when trying to find the best fitting tile for the given terrain constraints.
[b]Note:[/b] To work correctly, this method requires the [TileMapLayer]'s TileSet to have terrains set up with all required terrain combinations. Otherwise, it may produce unexpected results.
*/
func (self Instance) SetCellsTerrainConnect(cells []Vector2i.XY, terrain_set int, terrain int) { //gd:TileMapLayer.set_cells_terrain_connect
	Advanced(self).SetCellsTerrainConnect(gd.ArrayFromSlice[Array.Contains[Vector2i.XY]](cells), int64(terrain_set), int64(terrain), true)
}

/*
Update all the cells in the [param cells] coordinates array so that they use the given [param terrain] for the given [param terrain_set]. If an updated cell has the same terrain as one of its neighboring cells, this function tries to join the two. This function might update neighboring tiles if needed to create correct terrain transitions.
If [param ignore_empty_terrains] is [code]true[/code], empty terrains will be ignored when trying to find the best fitting tile for the given terrain constraints.
[b]Note:[/b] To work correctly, this method requires the [TileMapLayer]'s TileSet to have terrains set up with all required terrain combinations. Otherwise, it may produce unexpected results.
*/
func (self Expanded) SetCellsTerrainConnect(cells []Vector2i.XY, terrain_set int, terrain int, ignore_empty_terrains bool) { //gd:TileMapLayer.set_cells_terrain_connect
	Advanced(self).SetCellsTerrainConnect(gd.ArrayFromSlice[Array.Contains[Vector2i.XY]](cells), int64(terrain_set), int64(terrain), ignore_empty_terrains)
}

/*
Update all the cells in the [param path] coordinates array so that they use the given [param terrain] for the given [param terrain_set]. The function will also connect two successive cell in the path with the same terrain. This function might update neighboring tiles if needed to create correct terrain transitions.
If [param ignore_empty_terrains] is [code]true[/code], empty terrains will be ignored when trying to find the best fitting tile for the given terrain constraints.
[b]Note:[/b] To work correctly, this method requires the [TileMapLayer]'s TileSet to have terrains set up with all required terrain combinations. Otherwise, it may produce unexpected results.
*/
func (self Instance) SetCellsTerrainPath(path []Vector2i.XY, terrain_set int, terrain int) { //gd:TileMapLayer.set_cells_terrain_path
	Advanced(self).SetCellsTerrainPath(gd.ArrayFromSlice[Array.Contains[Vector2i.XY]](path), int64(terrain_set), int64(terrain), true)
}

/*
Update all the cells in the [param path] coordinates array so that they use the given [param terrain] for the given [param terrain_set]. The function will also connect two successive cell in the path with the same terrain. This function might update neighboring tiles if needed to create correct terrain transitions.
If [param ignore_empty_terrains] is [code]true[/code], empty terrains will be ignored when trying to find the best fitting tile for the given terrain constraints.
[b]Note:[/b] To work correctly, this method requires the [TileMapLayer]'s TileSet to have terrains set up with all required terrain combinations. Otherwise, it may produce unexpected results.
*/
func (self Expanded) SetCellsTerrainPath(path []Vector2i.XY, terrain_set int, terrain int, ignore_empty_terrains bool) { //gd:TileMapLayer.set_cells_terrain_path
	Advanced(self).SetCellsTerrainPath(gd.ArrayFromSlice[Array.Contains[Vector2i.XY]](path), int64(terrain_set), int64(terrain), ignore_empty_terrains)
}

/*
Returns whether the provided [param body] [RID] belongs to one of this [TileMapLayer]'s cells.
*/
func (self Instance) HasBodyRid(body RID.Body2D) bool { //gd:TileMapLayer.has_body_rid
	return bool(Advanced(self).HasBodyRid(RID.Any(body)))
}

/*
Returns the coordinates of the tile for given physics body [RID]. Such an [RID] can be retrieved from [method KinematicCollision2D.get_collider_rid], when colliding with a tile.
*/
func (self Instance) GetCoordsForBodyRid(body RID.Body2D) Vector2i.XY { //gd:TileMapLayer.get_coords_for_body_rid
	return Vector2i.XY(Advanced(self).GetCoordsForBodyRid(RID.Any(body)))
}

/*
Triggers a direct update of the [TileMapLayer]. Usually, calling this function is not needed, as [TileMapLayer] node updates automatically when one of its properties or cells is modified.
However, for performance reasons, those updates are batched and delayed to the end of the frame. Calling this function will force the [TileMapLayer] to update right away instead.
[b]Warning:[/b] Updating the [TileMapLayer] is computationally expensive and may impact performance. Try to limit the number of updates and how many tiles they impact.
*/
func (self Instance) UpdateInternals() { //gd:TileMapLayer.update_internals
	Advanced(self).UpdateInternals()
}

/*
Notifies the [TileMapLayer] node that calls to [method _use_tile_data_runtime_update] or [method _tile_data_runtime_update] will lead to different results. This will thus trigger a [TileMapLayer] update.
[b]Warning:[/b] Updating the [TileMapLayer] is computationally expensive and may impact performance. Try to limit the number of calls to this function to avoid unnecessary update.
[b]Note:[/b] This does not trigger a direct update of the [TileMapLayer], the update will be done at the end of the frame as usual (unless you call [method update_internals]).
*/
func (self Instance) NotifyRuntimeTileDataUpdate() { //gd:TileMapLayer.notify_runtime_tile_data_update
	Advanced(self).NotifyRuntimeTileDataUpdate()
}

/*
Returns for the given coordinates [param coords_in_pattern] in a [TileMapPattern] the corresponding cell coordinates if the pattern was pasted at the [param position_in_tilemap] coordinates (see [method set_pattern]). This mapping is required as in half-offset tile shapes, the mapping might not work by calculating [code]position_in_tile_map + coords_in_pattern[/code].
*/
func (self Instance) MapPattern(position_in_tilemap Vector2i.XY, coords_in_pattern Vector2i.XY, pattern TileMapPattern.Instance) Vector2i.XY { //gd:TileMapLayer.map_pattern
	return Vector2i.XY(Advanced(self).MapPattern(Vector2i.XY(position_in_tilemap), Vector2i.XY(coords_in_pattern), pattern))
}

/*
Returns the list of all neighboring cells to the one at [param coords]. Any neighboring cell is one that is touching edges, so for a square cell 4 cells would be returned, for a hexagon 6 cells are returned.
*/
func (self Instance) GetSurroundingCells(coords Vector2i.XY) []Vector2i.XY { //gd:TileMapLayer.get_surrounding_cells
	return []Vector2i.XY(gd.ArrayAs[[]Vector2i.XY](gd.InternalArray(Advanced(self).GetSurroundingCells(Vector2i.XY(coords)))))
}

/*
Returns the neighboring cell to the one at coordinates [param coords], identified by the [param neighbor] direction. This method takes into account the different layouts a TileMap can take.
*/
func (self Instance) GetNeighborCell(coords Vector2i.XY, neighbor TileSet.CellNeighbor) Vector2i.XY { //gd:TileMapLayer.get_neighbor_cell
	return Vector2i.XY(Advanced(self).GetNeighborCell(Vector2i.XY(coords), neighbor))
}

/*
Returns the centered position of a cell in the [TileMapLayer]'s local coordinate space. To convert the returned value into global coordinates, use [method Node2D.to_global]. See also [method local_to_map].
[b]Note:[/b] This may not correspond to the visual position of the tile, i.e. it ignores the [member TileData.texture_origin] property of individual tiles.
*/
func (self Instance) MapToLocal(map_position Vector2i.XY) Vector2.XY { //gd:TileMapLayer.map_to_local
	return Vector2.XY(Advanced(self).MapToLocal(Vector2i.XY(map_position)))
}

/*
Returns the map coordinates of the cell containing the given [param local_position]. If [param local_position] is in global coordinates, consider using [method Node2D.to_local] before passing it to this method. See also [method map_to_local].
*/
func (self Instance) LocalToMap(local_position Vector2.XY) Vector2i.XY { //gd:TileMapLayer.local_to_map
	return Vector2i.XY(Advanced(self).LocalToMap(Vector2.XY(local_position)))
}

/*
Sets a custom [param map] as a [NavigationServer2D] navigation map. If not set, uses the default [World2D] navigation map instead.
*/
func (self Instance) SetNavigationMap(map_ RID.NavigationMap2D) { //gd:TileMapLayer.set_navigation_map
	Advanced(self).SetNavigationMap(RID.Any(map_))
}

/*
Returns the [RID] of the [NavigationServer2D] navigation used by this [TileMapLayer].
By default this returns the default [World2D] navigation map, unless a custom map was provided using [method set_navigation_map].
*/
func (self Instance) GetNavigationMap() RID.NavigationMap2D { //gd:TileMapLayer.get_navigation_map
	return RID.NavigationMap2D(Advanced(self).GetNavigationMap())
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.TileMapLayer

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.TileMapLayer)(unsafe.Pointer(&obj))
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.TileMapLayer)(unsafe.Pointer(&obj))
		return true
	}
	return false
}

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {

	if !gd.Linked {
		var placeholder Instance
		*(*gd.Object)(unsafe.Pointer(&placeholder)) = pointers.Add[gd.Object]([3]uint64{})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(*(*gd.Object)(unsafe.Pointer(&placeholder)), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	object := [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})}
	casted := Instance{*(*gdclass.TileMapLayer)(unsafe.Pointer(&object))}
	object[0].Notification(0, false)
	return casted
}

func (self Instance) TileMapData() []byte {
	return []byte(class(self).GetTileMapDataAsArray().Bytes())
}

func (self Instance) SetTileMapData(value []byte) {
	class(self).SetTileMapDataFromArray(Packed.Bytes(Packed.New(value...)))
}

func (self Instance) Enabled() bool {
	return bool(class(self).IsEnabled())
}

func (self Instance) SetEnabled(value bool) {
	class(self).SetEnabled(value)
}

func (self Instance) TileSet() TileSet.Instance {
	return TileSet.Instance(class(self).GetTileSet())
}

func (self Instance) SetTileSet(value TileSet.Instance) {
	class(self).SetTileSet(value)
}

func (self Instance) OcclusionEnabled() bool {
	return bool(class(self).IsOcclusionEnabled())
}

func (self Instance) SetOcclusionEnabled(value bool) {
	class(self).SetOcclusionEnabled(value)
}

func (self Instance) YSortOrigin() int {
	return int(int(class(self).GetYSortOrigin()))
}

func (self Instance) SetYSortOrigin(value int) {
	class(self).SetYSortOrigin(int64(value))
}

func (self Instance) XDrawOrderReversed() bool {
	return bool(class(self).IsXDrawOrderReversed())
}

func (self Instance) SetXDrawOrderReversed(value bool) {
	class(self).SetXDrawOrderReversed(value)
}

func (self Instance) RenderingQuadrantSize() int {
	return int(int(class(self).GetRenderingQuadrantSize()))
}

func (self Instance) SetRenderingQuadrantSize(value int) {
	class(self).SetRenderingQuadrantSize(int64(value))
}

func (self Instance) CollisionEnabled() bool {
	return bool(class(self).IsCollisionEnabled())
}

func (self Instance) SetCollisionEnabled(value bool) {
	class(self).SetCollisionEnabled(value)
}

func (self Instance) UseKinematicBodies() bool {
	return bool(class(self).IsUsingKinematicBodies())
}

func (self Instance) SetUseKinematicBodies(value bool) {
	class(self).SetUseKinematicBodies(value)
}

func (self Instance) CollisionVisibilityMode() DebugVisibilityMode {
	return DebugVisibilityMode(class(self).GetCollisionVisibilityMode())
}

func (self Instance) SetCollisionVisibilityMode(value DebugVisibilityMode) {
	class(self).SetCollisionVisibilityMode(value)
}

func (self Instance) NavigationEnabled() bool {
	return bool(class(self).IsNavigationEnabled())
}

func (self Instance) SetNavigationEnabled(value bool) {
	class(self).SetNavigationEnabled(value)
}

func (self Instance) NavigationVisibilityMode() DebugVisibilityMode {
	return DebugVisibilityMode(class(self).GetNavigationVisibilityMode())
}

func (self Instance) SetNavigationVisibilityMode(value DebugVisibilityMode) {
	class(self).SetNavigationVisibilityMode(value)
}

/*
Should return [code]true[/code] if the tile at coordinates [param coords] requires a runtime update.
[b]Warning:[/b] Make sure this function only returns [code]true[/code] when needed. Any tile processed at runtime without a need for it will imply a significant performance penalty.
[b]Note:[/b] If the result of this function should change, use [method notify_runtime_tile_data_update] to notify the [TileMapLayer] it needs an update.
*/
func (class) _use_tile_data_runtime_update(impl func(ptr unsafe.Pointer, coords Vector2i.XY) bool) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var coords = gd.UnsafeGet[Vector2i.XY](p_args, 0)
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self, coords)
		gd.UnsafeSet(p_back, ret)
	}
}

/*
Called with a [TileData] object about to be used internally by the [TileMapLayer], allowing its modification at runtime.
This method is only called if [method _use_tile_data_runtime_update] is implemented and returns [code]true[/code] for the given tile [param coords].
[b]Warning:[/b] The [param tile_data] object's sub-resources are the same as the one in the TileSet. Modifying them might impact the whole TileSet. Instead, make sure to duplicate those resources.
[b]Note:[/b] If the properties of [param tile_data] object should change over time, use [method notify_runtime_tile_data_update] to notify the [TileMapLayer] it needs an update.
*/
func (class) _tile_data_runtime_update(impl func(ptr unsafe.Pointer, coords Vector2i.XY, tile_data [1]gdclass.TileData)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var coords = gd.UnsafeGet[Vector2i.XY](p_args, 0)
		var tile_data = [1]gdclass.TileData{pointers.New[gdclass.TileData]([3]uint64{uint64(gd.UnsafeGet[gdextension.Object](p_args, 1))})}

		defer pointers.End(tile_data[0])
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, coords, tile_data)
	}
}

/*
Called when this [TileMapLayer]'s cells need an internal update. This update may be caused from individual cells being modified or by a change in the [member tile_set] (causing all cells to be queued for an update). The first call to this function is always for initializing all the [TileMapLayer]'s cells. [param coords] contains the coordinates of all modified cells, roughly in the order they were modified. [param forced_cleanup] is [code]true[/code] when the [TileMapLayer]'s internals should be fully cleaned up. This is the case when:
- The layer is disabled;
- The layer is not visible;
- [member tile_set] is set to [code]null[/code];
- The node is removed from the tree;
- The node is freed.
Note that any internal update happening while one of these conditions is verified is considered to be a "cleanup". See also [method update_internals].
[b]Warning:[/b] Implementing this method may degrade the [TileMapLayer]'s performance.
*/
func (class) _update_cells(impl func(ptr unsafe.Pointer, coords Array.Contains[Vector2i.XY], forced_cleanup bool)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var coords = Array.Through(gd.ArrayProxy[Vector2i.XY]{}, pointers.Pack(pointers.New[gd.Array](gd.UnsafeGet[gdextension.Array](p_args, 0))))
		defer pointers.End(gd.InternalArray(coords))
		var forced_cleanup = gd.UnsafeGet[bool](p_args, 1)
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, coords, forced_cleanup)
	}
}

/*
Sets the tile identifiers for the cell at coordinates [param coords]. Each tile of the [TileSet] is identified using three parts:
- The source identifier [param source_id] identifies a [TileSetSource] identifier. See [method TileSet.set_source_id],
- The atlas coordinate identifier [param atlas_coords] identifies a tile coordinates in the atlas (if the source is a [TileSetAtlasSource]). For [TileSetScenesCollectionSource] it should always be [code]Vector2i(0, 0)[/code],
- The alternative tile identifier [param alternative_tile] identifies a tile alternative in the atlas (if the source is a [TileSetAtlasSource]), and the scene for a [TileSetScenesCollectionSource].
If [param source_id] is set to [code]-1[/code], [param atlas_coords] to [code]Vector2i(-1, -1)[/code], or [param alternative_tile] to [code]-1[/code], the cell will be erased. An erased cell gets [b]all[/b] its identifiers automatically set to their respective invalid values, namely [code]-1[/code], [code]Vector2i(-1, -1)[/code] and [code]-1[/code].
*/
//go:nosplit
func (self class) SetCell(coords Vector2i.XY, source_id int64, atlas_coords Vector2i.XY, alternative_tile int64) { //gd:TileMapLayer.set_cell
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_cell, 0|(gdextension.SizeVector2i<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeVector2i<<12)|(gdextension.SizeInt<<16), unsafe.Pointer(&struct {
		coords           Vector2i.XY
		source_id        int64
		atlas_coords     Vector2i.XY
		alternative_tile int64
	}{coords, source_id, atlas_coords, alternative_tile}))
}

/*
Erases the cell at coordinates [param coords].
*/
//go:nosplit
func (self class) EraseCell(coords Vector2i.XY) { //gd:TileMapLayer.erase_cell
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.erase_cell, 0|(gdextension.SizeVector2i<<4), unsafe.Pointer(&struct{ coords Vector2i.XY }{coords}))
}

/*
Clears cells containing tiles that do not exist in the [member tile_set].
*/
//go:nosplit
func (self class) FixInvalidTiles() { //gd:TileMapLayer.fix_invalid_tiles
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.fix_invalid_tiles, 0, unsafe.Pointer(&struct{}{}))
}

/*
Clears all cells.
*/
//go:nosplit
func (self class) Clear() { //gd:TileMapLayer.clear
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.clear, 0, unsafe.Pointer(&struct{}{}))
}

/*
Returns the tile source ID of the cell at coordinates [param coords]. Returns [code]-1[/code] if the cell does not exist.
*/
//go:nosplit
func (self class) GetCellSourceId(coords Vector2i.XY) int64 { //gd:TileMapLayer.get_cell_source_id
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_cell_source_id, gdextension.SizeInt|(gdextension.SizeVector2i<<4), unsafe.Pointer(&struct{ coords Vector2i.XY }{coords}))
	var ret = r_ret
	return ret
}

/*
Returns the tile atlas coordinates ID of the cell at coordinates [param coords]. Returns [code]Vector2i(-1, -1)[/code] if the cell does not exist.
*/
//go:nosplit
func (self class) GetCellAtlasCoords(coords Vector2i.XY) Vector2i.XY { //gd:TileMapLayer.get_cell_atlas_coords
	var r_ret = gdextension.Call[Vector2i.XY](gd.ObjectChecked(self.AsObject()), methods.get_cell_atlas_coords, gdextension.SizeVector2i|(gdextension.SizeVector2i<<4), unsafe.Pointer(&struct{ coords Vector2i.XY }{coords}))
	var ret = r_ret
	return ret
}

/*
Returns the tile alternative ID of the cell at coordinates [param coords].
*/
//go:nosplit
func (self class) GetCellAlternativeTile(coords Vector2i.XY) int64 { //gd:TileMapLayer.get_cell_alternative_tile
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_cell_alternative_tile, gdextension.SizeInt|(gdextension.SizeVector2i<<4), unsafe.Pointer(&struct{ coords Vector2i.XY }{coords}))
	var ret = r_ret
	return ret
}

/*
Returns the [TileData] object associated with the given cell, or [code]null[/code] if the cell does not exist or is not a [TileSetAtlasSource].
[codeblock]
func get_clicked_tile_power():
    var clicked_cell = tile_map_layer.local_to_map(tile_map_layer.get_local_mouse_position())
    var data = tile_map_layer.get_cell_tile_data(clicked_cell)
    if data:
        return data.get_custom_data("power")
    else:
        return 0
[/codeblock]
*/
//go:nosplit
func (self class) GetCellTileData(coords Vector2i.XY) [1]gdclass.TileData { //gd:TileMapLayer.get_cell_tile_data
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_cell_tile_data, gdextension.SizeObject|(gdextension.SizeVector2i<<4), unsafe.Pointer(&struct{ coords Vector2i.XY }{coords}))
	var ret = [1]gdclass.TileData{gd.PointerMustAssertInstanceID[gdclass.TileData](r_ret)}
	return ret
}

/*
Returns [code]true[/code] if the cell at coordinates [param coords] is flipped horizontally. The result is valid only for atlas sources.
*/
//go:nosplit
func (self class) IsCellFlippedH(coords Vector2i.XY) bool { //gd:TileMapLayer.is_cell_flipped_h
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_cell_flipped_h, gdextension.SizeBool|(gdextension.SizeVector2i<<4), unsafe.Pointer(&struct{ coords Vector2i.XY }{coords}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if the cell at coordinates [param coords] is flipped vertically. The result is valid only for atlas sources.
*/
//go:nosplit
func (self class) IsCellFlippedV(coords Vector2i.XY) bool { //gd:TileMapLayer.is_cell_flipped_v
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_cell_flipped_v, gdextension.SizeBool|(gdextension.SizeVector2i<<4), unsafe.Pointer(&struct{ coords Vector2i.XY }{coords}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if the cell at coordinates [param coords] is transposed. The result is valid only for atlas sources.
*/
//go:nosplit
func (self class) IsCellTransposed(coords Vector2i.XY) bool { //gd:TileMapLayer.is_cell_transposed
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_cell_transposed, gdextension.SizeBool|(gdextension.SizeVector2i<<4), unsafe.Pointer(&struct{ coords Vector2i.XY }{coords}))
	var ret = r_ret
	return ret
}

/*
Returns a [Vector2i] array with the positions of all cells containing a tile. A cell is considered empty if its source identifier equals [code]-1[/code], its atlas coordinate identifier is [code]Vector2(-1, -1)[/code] and its alternative identifier is [code]-1[/code].
*/
//go:nosplit
func (self class) GetUsedCells() Array.Contains[Vector2i.XY] { //gd:TileMapLayer.get_used_cells
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), methods.get_used_cells, gdextension.SizeArray, unsafe.Pointer(&struct{}{}))
	var ret = Array.Through(gd.ArrayProxy[Vector2i.XY]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

/*
Returns a [Vector2i] array with the positions of all cells containing a tile. Tiles may be filtered according to their source ([param source_id]), their atlas coordinates ([param atlas_coords]), or alternative id ([param alternative_tile]).
If a parameter has its value set to the default one, this parameter is not used to filter a cell. Thus, if all parameters have their respective default values, this method returns the same result as [method get_used_cells].
A cell is considered empty if its source identifier equals [code]-1[/code], its atlas coordinate identifier is [code]Vector2(-1, -1)[/code] and its alternative identifier is [code]-1[/code].
*/
//go:nosplit
func (self class) GetUsedCellsById(source_id int64, atlas_coords Vector2i.XY, alternative_tile int64) Array.Contains[Vector2i.XY] { //gd:TileMapLayer.get_used_cells_by_id
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), methods.get_used_cells_by_id, gdextension.SizeArray|(gdextension.SizeInt<<4)|(gdextension.SizeVector2i<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		source_id        int64
		atlas_coords     Vector2i.XY
		alternative_tile int64
	}{source_id, atlas_coords, alternative_tile}))
	var ret = Array.Through(gd.ArrayProxy[Vector2i.XY]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

/*
Returns a rectangle enclosing the used (non-empty) tiles of the map.
*/
//go:nosplit
func (self class) GetUsedRect() Rect2i.PositionSize { //gd:TileMapLayer.get_used_rect
	var r_ret = gdextension.Call[Rect2i.PositionSize](gd.ObjectChecked(self.AsObject()), methods.get_used_rect, gdextension.SizeRect2i, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Creates and returns a new [TileMapPattern] from the given array of cells. See also [method set_pattern].
*/
//go:nosplit
func (self class) GetPattern(coords_array Array.Contains[Vector2i.XY]) [1]gdclass.TileMapPattern { //gd:TileMapLayer.get_pattern
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_pattern, gdextension.SizeObject|(gdextension.SizeArray<<4), unsafe.Pointer(&struct{ coords_array gdextension.Array }{pointers.Get(gd.InternalArray(coords_array))}))
	var ret = [1]gdclass.TileMapPattern{gd.PointerWithOwnershipTransferredToGo[gdclass.TileMapPattern](r_ret)}
	return ret
}

/*
Pastes the [TileMapPattern] at the given [param position] in the tile map. See also [method get_pattern].
*/
//go:nosplit
func (self class) SetPattern(position Vector2i.XY, pattern [1]gdclass.TileMapPattern) { //gd:TileMapLayer.set_pattern
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_pattern, 0|(gdextension.SizeVector2i<<4)|(gdextension.SizeObject<<8), unsafe.Pointer(&struct {
		position Vector2i.XY
		pattern  gdextension.Object
	}{position, gdextension.Object(gd.ObjectChecked(pattern[0].AsObject()))}))
}

/*
Update all the cells in the [param cells] coordinates array so that they use the given [param terrain] for the given [param terrain_set]. If an updated cell has the same terrain as one of its neighboring cells, this function tries to join the two. This function might update neighboring tiles if needed to create correct terrain transitions.
If [param ignore_empty_terrains] is [code]true[/code], empty terrains will be ignored when trying to find the best fitting tile for the given terrain constraints.
[b]Note:[/b] To work correctly, this method requires the [TileMapLayer]'s TileSet to have terrains set up with all required terrain combinations. Otherwise, it may produce unexpected results.
*/
//go:nosplit
func (self class) SetCellsTerrainConnect(cells Array.Contains[Vector2i.XY], terrain_set int64, terrain int64, ignore_empty_terrains bool) { //gd:TileMapLayer.set_cells_terrain_connect
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_cells_terrain_connect, 0|(gdextension.SizeArray<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeBool<<16), unsafe.Pointer(&struct {
		cells                 gdextension.Array
		terrain_set           int64
		terrain               int64
		ignore_empty_terrains bool
	}{pointers.Get(gd.InternalArray(cells)), terrain_set, terrain, ignore_empty_terrains}))
}

/*
Update all the cells in the [param path] coordinates array so that they use the given [param terrain] for the given [param terrain_set]. The function will also connect two successive cell in the path with the same terrain. This function might update neighboring tiles if needed to create correct terrain transitions.
If [param ignore_empty_terrains] is [code]true[/code], empty terrains will be ignored when trying to find the best fitting tile for the given terrain constraints.
[b]Note:[/b] To work correctly, this method requires the [TileMapLayer]'s TileSet to have terrains set up with all required terrain combinations. Otherwise, it may produce unexpected results.
*/
//go:nosplit
func (self class) SetCellsTerrainPath(path Array.Contains[Vector2i.XY], terrain_set int64, terrain int64, ignore_empty_terrains bool) { //gd:TileMapLayer.set_cells_terrain_path
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_cells_terrain_path, 0|(gdextension.SizeArray<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeBool<<16), unsafe.Pointer(&struct {
		path                  gdextension.Array
		terrain_set           int64
		terrain               int64
		ignore_empty_terrains bool
	}{pointers.Get(gd.InternalArray(path)), terrain_set, terrain, ignore_empty_terrains}))
}

/*
Returns whether the provided [param body] [RID] belongs to one of this [TileMapLayer]'s cells.
*/
//go:nosplit
func (self class) HasBodyRid(body RID.Any) bool { //gd:TileMapLayer.has_body_rid
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.has_body_rid, gdextension.SizeBool|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ body RID.Any }{body}))
	var ret = r_ret
	return ret
}

/*
Returns the coordinates of the tile for given physics body [RID]. Such an [RID] can be retrieved from [method KinematicCollision2D.get_collider_rid], when colliding with a tile.
*/
//go:nosplit
func (self class) GetCoordsForBodyRid(body RID.Any) Vector2i.XY { //gd:TileMapLayer.get_coords_for_body_rid
	var r_ret = gdextension.Call[Vector2i.XY](gd.ObjectChecked(self.AsObject()), methods.get_coords_for_body_rid, gdextension.SizeVector2i|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ body RID.Any }{body}))
	var ret = r_ret
	return ret
}

/*
Triggers a direct update of the [TileMapLayer]. Usually, calling this function is not needed, as [TileMapLayer] node updates automatically when one of its properties or cells is modified.
However, for performance reasons, those updates are batched and delayed to the end of the frame. Calling this function will force the [TileMapLayer] to update right away instead.
[b]Warning:[/b] Updating the [TileMapLayer] is computationally expensive and may impact performance. Try to limit the number of updates and how many tiles they impact.
*/
//go:nosplit
func (self class) UpdateInternals() { //gd:TileMapLayer.update_internals
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.update_internals, 0, unsafe.Pointer(&struct{}{}))
}

/*
Notifies the [TileMapLayer] node that calls to [method _use_tile_data_runtime_update] or [method _tile_data_runtime_update] will lead to different results. This will thus trigger a [TileMapLayer] update.
[b]Warning:[/b] Updating the [TileMapLayer] is computationally expensive and may impact performance. Try to limit the number of calls to this function to avoid unnecessary update.
[b]Note:[/b] This does not trigger a direct update of the [TileMapLayer], the update will be done at the end of the frame as usual (unless you call [method update_internals]).
*/
//go:nosplit
func (self class) NotifyRuntimeTileDataUpdate() { //gd:TileMapLayer.notify_runtime_tile_data_update
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.notify_runtime_tile_data_update, 0, unsafe.Pointer(&struct{}{}))
}

/*
Returns for the given coordinates [param coords_in_pattern] in a [TileMapPattern] the corresponding cell coordinates if the pattern was pasted at the [param position_in_tilemap] coordinates (see [method set_pattern]). This mapping is required as in half-offset tile shapes, the mapping might not work by calculating [code]position_in_tile_map + coords_in_pattern[/code].
*/
//go:nosplit
func (self class) MapPattern(position_in_tilemap Vector2i.XY, coords_in_pattern Vector2i.XY, pattern [1]gdclass.TileMapPattern) Vector2i.XY { //gd:TileMapLayer.map_pattern
	var r_ret = gdextension.Call[Vector2i.XY](gd.ObjectChecked(self.AsObject()), methods.map_pattern, gdextension.SizeVector2i|(gdextension.SizeVector2i<<4)|(gdextension.SizeVector2i<<8)|(gdextension.SizeObject<<12), unsafe.Pointer(&struct {
		position_in_tilemap Vector2i.XY
		coords_in_pattern   Vector2i.XY
		pattern             gdextension.Object
	}{position_in_tilemap, coords_in_pattern, gdextension.Object(gd.ObjectChecked(pattern[0].AsObject()))}))
	var ret = r_ret
	return ret
}

/*
Returns the list of all neighboring cells to the one at [param coords]. Any neighboring cell is one that is touching edges, so for a square cell 4 cells would be returned, for a hexagon 6 cells are returned.
*/
//go:nosplit
func (self class) GetSurroundingCells(coords Vector2i.XY) Array.Contains[Vector2i.XY] { //gd:TileMapLayer.get_surrounding_cells
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), methods.get_surrounding_cells, gdextension.SizeArray|(gdextension.SizeVector2i<<4), unsafe.Pointer(&struct{ coords Vector2i.XY }{coords}))
	var ret = Array.Through(gd.ArrayProxy[Vector2i.XY]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

/*
Returns the neighboring cell to the one at coordinates [param coords], identified by the [param neighbor] direction. This method takes into account the different layouts a TileMap can take.
*/
//go:nosplit
func (self class) GetNeighborCell(coords Vector2i.XY, neighbor TileSet.CellNeighbor) Vector2i.XY { //gd:TileMapLayer.get_neighbor_cell
	var r_ret = gdextension.Call[Vector2i.XY](gd.ObjectChecked(self.AsObject()), methods.get_neighbor_cell, gdextension.SizeVector2i|(gdextension.SizeVector2i<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		coords   Vector2i.XY
		neighbor TileSet.CellNeighbor
	}{coords, neighbor}))
	var ret = r_ret
	return ret
}

/*
Returns the centered position of a cell in the [TileMapLayer]'s local coordinate space. To convert the returned value into global coordinates, use [method Node2D.to_global]. See also [method local_to_map].
[b]Note:[/b] This may not correspond to the visual position of the tile, i.e. it ignores the [member TileData.texture_origin] property of individual tiles.
*/
//go:nosplit
func (self class) MapToLocal(map_position Vector2i.XY) Vector2.XY { //gd:TileMapLayer.map_to_local
	var r_ret = gdextension.Call[Vector2.XY](gd.ObjectChecked(self.AsObject()), methods.map_to_local, gdextension.SizeVector2|(gdextension.SizeVector2i<<4), unsafe.Pointer(&struct{ map_position Vector2i.XY }{map_position}))
	var ret = r_ret
	return ret
}

/*
Returns the map coordinates of the cell containing the given [param local_position]. If [param local_position] is in global coordinates, consider using [method Node2D.to_local] before passing it to this method. See also [method map_to_local].
*/
//go:nosplit
func (self class) LocalToMap(local_position Vector2.XY) Vector2i.XY { //gd:TileMapLayer.local_to_map
	var r_ret = gdextension.Call[Vector2i.XY](gd.ObjectChecked(self.AsObject()), methods.local_to_map, gdextension.SizeVector2i|(gdextension.SizeVector2<<4), unsafe.Pointer(&struct{ local_position Vector2.XY }{local_position}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetTileMapDataFromArray(tile_map_layer_data Packed.Bytes) { //gd:TileMapLayer.set_tile_map_data_from_array
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_tile_map_data_from_array, 0|(gdextension.SizePackedArray<<4), unsafe.Pointer(&struct{ tile_map_layer_data gdextension.PackedArray[byte] }{pointers.Get(gd.InternalPacked[gd.PackedByteArray, byte](Packed.Array[byte](tile_map_layer_data)))}))
}

//go:nosplit
func (self class) GetTileMapDataAsArray() Packed.Bytes { //gd:TileMapLayer.get_tile_map_data_as_array
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.get_tile_map_data_as_array, gdextension.SizePackedArray, unsafe.Pointer(&struct{}{}))
	var ret = Packed.Bytes(Array.Through(gd.PackedProxy[gd.PackedByteArray, byte]{}, pointers.Pack(pointers.Let[gd.PackedByteArray](r_ret))))
	return ret
}

//go:nosplit
func (self class) SetEnabled(enabled bool) { //gd:TileMapLayer.set_enabled
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_enabled, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enabled bool }{enabled}))
}

//go:nosplit
func (self class) IsEnabled() bool { //gd:TileMapLayer.is_enabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_enabled, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetTileSet(tile_set [1]gdclass.TileSet) { //gd:TileMapLayer.set_tile_set
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_tile_set, 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ tile_set gdextension.Object }{gdextension.Object(gd.ObjectChecked(tile_set[0].AsObject()))}))
}

//go:nosplit
func (self class) GetTileSet() [1]gdclass.TileSet { //gd:TileMapLayer.get_tile_set
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_tile_set, gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.TileSet{gd.PointerWithOwnershipTransferredToGo[gdclass.TileSet](r_ret)}
	return ret
}

//go:nosplit
func (self class) SetYSortOrigin(y_sort_origin int64) { //gd:TileMapLayer.set_y_sort_origin
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_y_sort_origin, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ y_sort_origin int64 }{y_sort_origin}))
}

//go:nosplit
func (self class) GetYSortOrigin() int64 { //gd:TileMapLayer.get_y_sort_origin
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_y_sort_origin, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetXDrawOrderReversed(x_draw_order_reversed bool) { //gd:TileMapLayer.set_x_draw_order_reversed
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_x_draw_order_reversed, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ x_draw_order_reversed bool }{x_draw_order_reversed}))
}

//go:nosplit
func (self class) IsXDrawOrderReversed() bool { //gd:TileMapLayer.is_x_draw_order_reversed
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_x_draw_order_reversed, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetRenderingQuadrantSize(size int64) { //gd:TileMapLayer.set_rendering_quadrant_size
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_rendering_quadrant_size, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ size int64 }{size}))
}

//go:nosplit
func (self class) GetRenderingQuadrantSize() int64 { //gd:TileMapLayer.get_rendering_quadrant_size
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_rendering_quadrant_size, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetCollisionEnabled(enabled bool) { //gd:TileMapLayer.set_collision_enabled
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_collision_enabled, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enabled bool }{enabled}))
}

//go:nosplit
func (self class) IsCollisionEnabled() bool { //gd:TileMapLayer.is_collision_enabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_collision_enabled, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetUseKinematicBodies(use_kinematic_bodies bool) { //gd:TileMapLayer.set_use_kinematic_bodies
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_use_kinematic_bodies, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ use_kinematic_bodies bool }{use_kinematic_bodies}))
}

//go:nosplit
func (self class) IsUsingKinematicBodies() bool { //gd:TileMapLayer.is_using_kinematic_bodies
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_using_kinematic_bodies, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetCollisionVisibilityMode(visibility_mode DebugVisibilityMode) { //gd:TileMapLayer.set_collision_visibility_mode
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_collision_visibility_mode, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ visibility_mode DebugVisibilityMode }{visibility_mode}))
}

//go:nosplit
func (self class) GetCollisionVisibilityMode() DebugVisibilityMode { //gd:TileMapLayer.get_collision_visibility_mode
	var r_ret = gdextension.Call[DebugVisibilityMode](gd.ObjectChecked(self.AsObject()), methods.get_collision_visibility_mode, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetOcclusionEnabled(enabled bool) { //gd:TileMapLayer.set_occlusion_enabled
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_occlusion_enabled, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enabled bool }{enabled}))
}

//go:nosplit
func (self class) IsOcclusionEnabled() bool { //gd:TileMapLayer.is_occlusion_enabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_occlusion_enabled, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetNavigationEnabled(enabled bool) { //gd:TileMapLayer.set_navigation_enabled
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_navigation_enabled, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enabled bool }{enabled}))
}

//go:nosplit
func (self class) IsNavigationEnabled() bool { //gd:TileMapLayer.is_navigation_enabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_navigation_enabled, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Sets a custom [param map] as a [NavigationServer2D] navigation map. If not set, uses the default [World2D] navigation map instead.
*/
//go:nosplit
func (self class) SetNavigationMap(mapping RID.Any) { //gd:TileMapLayer.set_navigation_map
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_navigation_map, 0|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ mapping RID.Any }{mapping}))
}

/*
Returns the [RID] of the [NavigationServer2D] navigation used by this [TileMapLayer].
By default this returns the default [World2D] navigation map, unless a custom map was provided using [method set_navigation_map].
*/
//go:nosplit
func (self class) GetNavigationMap() RID.Any { //gd:TileMapLayer.get_navigation_map
	var r_ret = gdextension.Call[RID.Any](gd.ObjectChecked(self.AsObject()), methods.get_navigation_map, gdextension.SizeRID, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetNavigationVisibilityMode(show_navigation DebugVisibilityMode) { //gd:TileMapLayer.set_navigation_visibility_mode
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_navigation_visibility_mode, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ show_navigation DebugVisibilityMode }{show_navigation}))
}

//go:nosplit
func (self class) GetNavigationVisibilityMode() DebugVisibilityMode { //gd:TileMapLayer.get_navigation_visibility_mode
	var r_ret = gdextension.Call[DebugVisibilityMode](gd.ObjectChecked(self.AsObject()), methods.get_navigation_visibility_mode, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}
func (self Instance) OnChanged(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("changed"), gd.NewCallable(cb), 0)
}

func (self class) AsTileMapLayer() Advanced          { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsTileMapLayer() Instance       { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsTileMapLayer() Instance  { return self.Super().AsTileMapLayer() }
func (self class) AsNode2D() Node2D.Advanced         { return *((*Node2D.Advanced)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsNode2D() Node2D.Instance { return self.Super().AsNode2D() }
func (self Instance) AsNode2D() Node2D.Instance      { return *((*Node2D.Instance)(unsafe.Pointer(&self))) }
func (self class) AsCanvasItem() CanvasItem.Advanced {
	return *((*CanvasItem.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsCanvasItem() CanvasItem.Instance { return self.Super().AsCanvasItem() }
func (self Instance) AsCanvasItem() CanvasItem.Instance {
	return *((*CanvasItem.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsNode() Node.Advanced         { return *((*Node.Advanced)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsNode() Node.Instance { return self.Super().AsNode() }
func (self Instance) AsNode() Node.Instance      { return *((*Node.Instance)(unsafe.Pointer(&self))) }

func (self class) Virtual(name string) reflect.Value {
	switch name {
	case "_use_tile_data_runtime_update":
		return reflect.ValueOf(self._use_tile_data_runtime_update)
	case "_tile_data_runtime_update":
		return reflect.ValueOf(self._tile_data_runtime_update)
	case "_update_cells":
		return reflect.ValueOf(self._update_cells)
	default:
		return gd.VirtualByName(Node2D.Advanced(self.AsNode2D()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	case "_use_tile_data_runtime_update":
		return reflect.ValueOf(self._use_tile_data_runtime_update)
	case "_tile_data_runtime_update":
		return reflect.ValueOf(self._tile_data_runtime_update)
	case "_update_cells":
		return reflect.ValueOf(self._update_cells)
	default:
		return gd.VirtualByName(Node2D.Instance(self.AsNode2D()), name)
	}
}
func init() {
	gdclass.Register("TileMapLayer", func(ptr gd.Object) any { return *(*Instance)(unsafe.Pointer(&ptr)) })
}

type DebugVisibilityMode int //gd:TileMapLayer.DebugVisibilityMode

const (
	/*Hide the collisions or navigation debug shapes in the editor, and use the debug settings to determine their visibility in game (i.e. [member SceneTree.debug_collisions_hint] or [member SceneTree.debug_navigation_hint]).*/
	DebugVisibilityModeDefault DebugVisibilityMode = 0
	/*Always hide the collisions or navigation debug shapes.*/
	DebugVisibilityModeForceHide DebugVisibilityMode = 2
	/*Always show the collisions or navigation debug shapes.*/
	DebugVisibilityModeForceShow DebugVisibilityMode = 1
)
