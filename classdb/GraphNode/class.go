// Code generated by the generate package DO NOT EDIT

// Package GraphNode provides methods for working with GraphNode object instances.
package GraphNode

import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/variant/Signal"
import "graphics.gd/classdb/CanvasItem"
import "graphics.gd/classdb/Container"
import "graphics.gd/classdb/Control"
import "graphics.gd/classdb/GraphElement"
import "graphics.gd/classdb/HBoxContainer"
import "graphics.gd/classdb/Node"
import "graphics.gd/classdb/Texture2D"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Color"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"
import "graphics.gd/variant/Vector2"
import "graphics.gd/variant/Vector2i"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Signal.Any
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
[GraphNode] allows to create nodes for a [GraphEdit] graph with customizable content based on its child controls. [GraphNode] is derived from [Container] and it is responsible for placing its children on screen. This works similar to [VBoxContainer]. Children, in turn, provide [GraphNode] with so-called slots, each of which can have a connection port on either side.
Each [GraphNode] slot is defined by its index and can provide the node with up to two ports: one on the left, and one on the right. By convention the left port is also referred to as the [b]input port[/b] and the right port is referred to as the [b]output port[/b]. Each port can be enabled and configured individually, using different type and color. The type is an arbitrary value that you can define using your own considerations. The parent [GraphEdit] will receive this information on each connect and disconnect request.
Slots can be configured in the Inspector dock once you add at least one child [Control]. The properties are grouped by each slot's index in the "Slot" section.
[b]Note:[/b] While GraphNode is set up using slots and slot indices, connections are made between the ports which are enabled. Because of that [GraphEdit] uses the port's index and not the slot's index. You can use [method get_input_port_slot] and [method get_output_port_slot] to get the slot index from the port index.

	See [Interface] for methods that can be overridden by a [Class] that extends it.
*/
type Instance [1]gdclass.GraphNode

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	set_title                          gdextension.MethodForClass `hash:"83702148"`
	get_title                          gdextension.MethodForClass `hash:"201670096"`
	get_titlebar_hbox                  gdextension.MethodForClass `hash:"3590609951"`
	set_slot                           gdextension.MethodForClass `hash:"2873310869"`
	clear_slot                         gdextension.MethodForClass `hash:"1286410249"`
	clear_all_slots                    gdextension.MethodForClass `hash:"3218959716"`
	is_slot_enabled_left               gdextension.MethodForClass `hash:"1116898809"`
	set_slot_enabled_left              gdextension.MethodForClass `hash:"300928843"`
	set_slot_type_left                 gdextension.MethodForClass `hash:"3937882851"`
	get_slot_type_left                 gdextension.MethodForClass `hash:"923996154"`
	set_slot_color_left                gdextension.MethodForClass `hash:"2878471219"`
	get_slot_color_left                gdextension.MethodForClass `hash:"3457211756"`
	set_slot_custom_icon_left          gdextension.MethodForClass `hash:"666127730"`
	get_slot_custom_icon_left          gdextension.MethodForClass `hash:"3536238170"`
	is_slot_enabled_right              gdextension.MethodForClass `hash:"1116898809"`
	set_slot_enabled_right             gdextension.MethodForClass `hash:"300928843"`
	set_slot_type_right                gdextension.MethodForClass `hash:"3937882851"`
	get_slot_type_right                gdextension.MethodForClass `hash:"923996154"`
	set_slot_color_right               gdextension.MethodForClass `hash:"2878471219"`
	get_slot_color_right               gdextension.MethodForClass `hash:"3457211756"`
	set_slot_custom_icon_right         gdextension.MethodForClass `hash:"666127730"`
	get_slot_custom_icon_right         gdextension.MethodForClass `hash:"3536238170"`
	is_slot_draw_stylebox              gdextension.MethodForClass `hash:"1116898809"`
	set_slot_draw_stylebox             gdextension.MethodForClass `hash:"300928843"`
	set_ignore_invalid_connection_type gdextension.MethodForClass `hash:"2586408642"`
	is_ignoring_valid_connection_type  gdextension.MethodForClass `hash:"36873697"`
	get_input_port_count               gdextension.MethodForClass `hash:"2455072627"`
	get_input_port_position            gdextension.MethodForClass `hash:"3114997196"`
	get_input_port_type                gdextension.MethodForClass `hash:"3744713108"`
	get_input_port_color               gdextension.MethodForClass `hash:"2624840992"`
	get_input_port_slot                gdextension.MethodForClass `hash:"3744713108"`
	get_output_port_count              gdextension.MethodForClass `hash:"2455072627"`
	get_output_port_position           gdextension.MethodForClass `hash:"3114997196"`
	get_output_port_type               gdextension.MethodForClass `hash:"3744713108"`
	get_output_port_color              gdextension.MethodForClass `hash:"2624840992"`
	get_output_port_slot               gdextension.MethodForClass `hash:"3744713108"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("GraphNode")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		gdextension.Free(gdextension.TypeStringName, &sname)
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

type Expanded [1]gdclass.GraphNode

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsGraphNode() Instance
}
type Interface interface {
	DrawPort(slot_index int, position Vector2i.XY, left bool, color Color.RGBA)
}

// Implementation implements [Interface] with empty methods.
type Implementation = implementation

type implementation struct{}

func (self implementation) DrawPort(slot_index int, position Vector2i.XY, left bool, color Color.RGBA) {
	return
}
func (Instance) _draw_port(impl func(ptr gdclass.Receiver, slot_index int, position Vector2i.XY, left bool, color Color.RGBA)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var slot_index = gd.UnsafeGet[int64](p_args, 0)
		var position = gd.UnsafeGet[Vector2i.XY](p_args, 1)
		var left = gd.UnsafeGet[bool](p_args, 2)
		var color = gd.UnsafeGet[Color.RGBA](p_args, 3)
		self := gdclass.Receiver(reflect.ValueOf(class).UnsafePointer())
		impl(self, int(slot_index), position, left, color)
	}
}

/*
Returns the [HBoxContainer] used for the title bar, only containing a [Label] for displaying the title by default. This can be used to add custom controls to the title bar such as option or close buttons.
*/
func (self Instance) GetTitlebarHbox() HBoxContainer.Instance { //gd:GraphNode.get_titlebar_hbox
	return HBoxContainer.Instance(Advanced(self).GetTitlebarHbox())
}

/*
Sets properties of the slot with the given [param slot_index].
If [param enable_left_port]/[param enable_right_port] is [code]true[/code], a port will appear and the slot will be able to be connected from this side.
With [param type_left]/[param type_right] an arbitrary type can be assigned to each port. Two ports can be connected if they share the same type, or if the connection between their types is allowed in the parent [GraphEdit] (see [method GraphEdit.add_valid_connection_type]). Keep in mind that the [GraphEdit] has the final say in accepting the connection. Type compatibility simply allows the [signal GraphEdit.connection_request] signal to be emitted.
Ports can be further customized using [param color_left]/[param color_right] and [param custom_icon_left]/[param custom_icon_right]. The color parameter adds a tint to the icon. The custom icon can be used to override the default port dot.
Additionally, [param draw_stylebox] can be used to enable or disable drawing of the background stylebox for each slot. See [theme_item slot].
Individual properties can also be set using one of the [code]set_slot_*[/code] methods.
[b]Note:[/b] This method only sets properties of the slot. To create the slot itself, add a [Control]-derived child to the GraphNode.
*/
func (self Instance) SetSlot(slot_index int, enable_left_port bool, type_left int, color_left Color.RGBA, enable_right_port bool, type_right int, color_right Color.RGBA) { //gd:GraphNode.set_slot
	Advanced(self).SetSlot(int64(slot_index), enable_left_port, int64(type_left), Color.RGBA(color_left), enable_right_port, int64(type_right), Color.RGBA(color_right), [1]Texture2D.Instance{}[0], [1]Texture2D.Instance{}[0], true)
}

/*
Sets properties of the slot with the given [param slot_index].
If [param enable_left_port]/[param enable_right_port] is [code]true[/code], a port will appear and the slot will be able to be connected from this side.
With [param type_left]/[param type_right] an arbitrary type can be assigned to each port. Two ports can be connected if they share the same type, or if the connection between their types is allowed in the parent [GraphEdit] (see [method GraphEdit.add_valid_connection_type]). Keep in mind that the [GraphEdit] has the final say in accepting the connection. Type compatibility simply allows the [signal GraphEdit.connection_request] signal to be emitted.
Ports can be further customized using [param color_left]/[param color_right] and [param custom_icon_left]/[param custom_icon_right]. The color parameter adds a tint to the icon. The custom icon can be used to override the default port dot.
Additionally, [param draw_stylebox] can be used to enable or disable drawing of the background stylebox for each slot. See [theme_item slot].
Individual properties can also be set using one of the [code]set_slot_*[/code] methods.
[b]Note:[/b] This method only sets properties of the slot. To create the slot itself, add a [Control]-derived child to the GraphNode.
*/
func (self Expanded) SetSlot(slot_index int, enable_left_port bool, type_left int, color_left Color.RGBA, enable_right_port bool, type_right int, color_right Color.RGBA, custom_icon_left Texture2D.Instance, custom_icon_right Texture2D.Instance, draw_stylebox bool) { //gd:GraphNode.set_slot
	Advanced(self).SetSlot(int64(slot_index), enable_left_port, int64(type_left), Color.RGBA(color_left), enable_right_port, int64(type_right), Color.RGBA(color_right), custom_icon_left, custom_icon_right, draw_stylebox)
}

/*
Disables the slot with the given [param slot_index]. This will remove the corresponding input and output port from the GraphNode.
*/
func (self Instance) ClearSlot(slot_index int) { //gd:GraphNode.clear_slot
	Advanced(self).ClearSlot(int64(slot_index))
}

/*
Disables all slots of the GraphNode. This will remove all input/output ports from the GraphNode.
*/
func (self Instance) ClearAllSlots() { //gd:GraphNode.clear_all_slots
	Advanced(self).ClearAllSlots()
}

/*
Returns [code]true[/code] if left (input) side of the slot with the given [param slot_index] is enabled.
*/
func (self Instance) IsSlotEnabledLeft(slot_index int) bool { //gd:GraphNode.is_slot_enabled_left
	return bool(Advanced(self).IsSlotEnabledLeft(int64(slot_index)))
}

/*
Toggles the left (input) side of the slot with the given [param slot_index]. If [param enable] is [code]true[/code], a port will appear on the left side and the slot will be able to be connected from this side.
*/
func (self Instance) SetSlotEnabledLeft(slot_index int, enable bool) { //gd:GraphNode.set_slot_enabled_left
	Advanced(self).SetSlotEnabledLeft(int64(slot_index), enable)
}

/*
Sets the left (input) type of the slot with the given [param slot_index] to [param type]. If the value is negative, all connections will be disallowed to be created via user inputs.
*/
func (self Instance) SetSlotTypeLeft(slot_index int, atype int) { //gd:GraphNode.set_slot_type_left
	Advanced(self).SetSlotTypeLeft(int64(slot_index), int64(atype))
}

/*
Returns the left (input) type of the slot with the given [param slot_index].
*/
func (self Instance) GetSlotTypeLeft(slot_index int) int { //gd:GraphNode.get_slot_type_left
	return int(int(Advanced(self).GetSlotTypeLeft(int64(slot_index))))
}

/*
Sets the [Color] of the left (input) side of the slot with the given [param slot_index] to [param color].
*/
func (self Instance) SetSlotColorLeft(slot_index int, color Color.RGBA) { //gd:GraphNode.set_slot_color_left
	Advanced(self).SetSlotColorLeft(int64(slot_index), Color.RGBA(color))
}

/*
Returns the left (input) [Color] of the slot with the given [param slot_index].
*/
func (self Instance) GetSlotColorLeft(slot_index int) Color.RGBA { //gd:GraphNode.get_slot_color_left
	return Color.RGBA(Advanced(self).GetSlotColorLeft(int64(slot_index)))
}

/*
Sets the custom [Texture2D] of the left (input) side of the slot with the given [param slot_index] to [param custom_icon].
*/
func (self Instance) SetSlotCustomIconLeft(slot_index int, custom_icon Texture2D.Instance) { //gd:GraphNode.set_slot_custom_icon_left
	Advanced(self).SetSlotCustomIconLeft(int64(slot_index), custom_icon)
}

/*
Returns the left (input) custom [Texture2D] of the slot with the given [param slot_index].
*/
func (self Instance) GetSlotCustomIconLeft(slot_index int) Texture2D.Instance { //gd:GraphNode.get_slot_custom_icon_left
	return Texture2D.Instance(Advanced(self).GetSlotCustomIconLeft(int64(slot_index)))
}

/*
Returns [code]true[/code] if right (output) side of the slot with the given [param slot_index] is enabled.
*/
func (self Instance) IsSlotEnabledRight(slot_index int) bool { //gd:GraphNode.is_slot_enabled_right
	return bool(Advanced(self).IsSlotEnabledRight(int64(slot_index)))
}

/*
Toggles the right (output) side of the slot with the given [param slot_index]. If [param enable] is [code]true[/code], a port will appear on the right side and the slot will be able to be connected from this side.
*/
func (self Instance) SetSlotEnabledRight(slot_index int, enable bool) { //gd:GraphNode.set_slot_enabled_right
	Advanced(self).SetSlotEnabledRight(int64(slot_index), enable)
}

/*
Sets the right (output) type of the slot with the given [param slot_index] to [param type]. If the value is negative, all connections will be disallowed to be created via user inputs.
*/
func (self Instance) SetSlotTypeRight(slot_index int, atype int) { //gd:GraphNode.set_slot_type_right
	Advanced(self).SetSlotTypeRight(int64(slot_index), int64(atype))
}

/*
Returns the right (output) type of the slot with the given [param slot_index].
*/
func (self Instance) GetSlotTypeRight(slot_index int) int { //gd:GraphNode.get_slot_type_right
	return int(int(Advanced(self).GetSlotTypeRight(int64(slot_index))))
}

/*
Sets the [Color] of the right (output) side of the slot with the given [param slot_index] to [param color].
*/
func (self Instance) SetSlotColorRight(slot_index int, color Color.RGBA) { //gd:GraphNode.set_slot_color_right
	Advanced(self).SetSlotColorRight(int64(slot_index), Color.RGBA(color))
}

/*
Returns the right (output) [Color] of the slot with the given [param slot_index].
*/
func (self Instance) GetSlotColorRight(slot_index int) Color.RGBA { //gd:GraphNode.get_slot_color_right
	return Color.RGBA(Advanced(self).GetSlotColorRight(int64(slot_index)))
}

/*
Sets the custom [Texture2D] of the right (output) side of the slot with the given [param slot_index] to [param custom_icon].
*/
func (self Instance) SetSlotCustomIconRight(slot_index int, custom_icon Texture2D.Instance) { //gd:GraphNode.set_slot_custom_icon_right
	Advanced(self).SetSlotCustomIconRight(int64(slot_index), custom_icon)
}

/*
Returns the right (output) custom [Texture2D] of the slot with the given [param slot_index].
*/
func (self Instance) GetSlotCustomIconRight(slot_index int) Texture2D.Instance { //gd:GraphNode.get_slot_custom_icon_right
	return Texture2D.Instance(Advanced(self).GetSlotCustomIconRight(int64(slot_index)))
}

/*
Returns [code]true[/code] if the background [StyleBox] of the slot with the given [param slot_index] is drawn.
*/
func (self Instance) IsSlotDrawStylebox(slot_index int) bool { //gd:GraphNode.is_slot_draw_stylebox
	return bool(Advanced(self).IsSlotDrawStylebox(int64(slot_index)))
}

/*
Toggles the background [StyleBox] of the slot with the given [param slot_index].
*/
func (self Instance) SetSlotDrawStylebox(slot_index int, enable bool) { //gd:GraphNode.set_slot_draw_stylebox
	Advanced(self).SetSlotDrawStylebox(int64(slot_index), enable)
}

/*
Returns the number of slots with an enabled input port.
*/
func (self Instance) GetInputPortCount() int { //gd:GraphNode.get_input_port_count
	return int(int(Advanced(self).GetInputPortCount()))
}

/*
Returns the position of the input port with the given [param port_idx].
*/
func (self Instance) GetInputPortPosition(port_idx int) Vector2.XY { //gd:GraphNode.get_input_port_position
	return Vector2.XY(Advanced(self).GetInputPortPosition(int64(port_idx)))
}

/*
Returns the type of the input port with the given [param port_idx].
*/
func (self Instance) GetInputPortType(port_idx int) int { //gd:GraphNode.get_input_port_type
	return int(int(Advanced(self).GetInputPortType(int64(port_idx))))
}

/*
Returns the [Color] of the input port with the given [param port_idx].
*/
func (self Instance) GetInputPortColor(port_idx int) Color.RGBA { //gd:GraphNode.get_input_port_color
	return Color.RGBA(Advanced(self).GetInputPortColor(int64(port_idx)))
}

/*
Returns the corresponding slot index of the input port with the given [param port_idx].
*/
func (self Instance) GetInputPortSlot(port_idx int) int { //gd:GraphNode.get_input_port_slot
	return int(int(Advanced(self).GetInputPortSlot(int64(port_idx))))
}

/*
Returns the number of slots with an enabled output port.
*/
func (self Instance) GetOutputPortCount() int { //gd:GraphNode.get_output_port_count
	return int(int(Advanced(self).GetOutputPortCount()))
}

/*
Returns the position of the output port with the given [param port_idx].
*/
func (self Instance) GetOutputPortPosition(port_idx int) Vector2.XY { //gd:GraphNode.get_output_port_position
	return Vector2.XY(Advanced(self).GetOutputPortPosition(int64(port_idx)))
}

/*
Returns the type of the output port with the given [param port_idx].
*/
func (self Instance) GetOutputPortType(port_idx int) int { //gd:GraphNode.get_output_port_type
	return int(int(Advanced(self).GetOutputPortType(int64(port_idx))))
}

/*
Returns the [Color] of the output port with the given [param port_idx].
*/
func (self Instance) GetOutputPortColor(port_idx int) Color.RGBA { //gd:GraphNode.get_output_port_color
	return Color.RGBA(Advanced(self).GetOutputPortColor(int64(port_idx)))
}

/*
Returns the corresponding slot index of the output port with the given [param port_idx].
*/
func (self Instance) GetOutputPortSlot(port_idx int) int { //gd:GraphNode.get_output_port_slot
	return int(int(Advanced(self).GetOutputPortSlot(int64(port_idx))))
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.GraphNode

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = pointers.AsA[gdclass.GraphNode](obj[0])
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = pointers.AsA[gdclass.GraphNode](obj[0])
		return true
	}
	return false
}
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }
func (self *Extension[T]) AsObject() [1]gd.Object { return self.Super().AsObject() }
func New() Instance {
	if !gd.Linked {
		var placeholder = Instance([1]gdclass.GraphNode{pointers.Add[gdclass.GraphNode]([3]uint64{})})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(pointers.AsA[gd.Object](placeholder[0]), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	casted := Instance([1]gdclass.GraphNode{pointers.New[gdclass.GraphNode]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})})
	casted.AsObject()[0].Notification(0, false)
	return casted
}

func (self Instance) Title() string {
	return string(class(self).GetTitle().String())
}

func (self Instance) SetTitle(value string) {
	class(self).SetTitle(String.New(value))
}

func (self Instance) IgnoreInvalidConnectionType() bool {
	return bool(class(self).IsIgnoringValidConnectionType())
}

func (self Instance) SetIgnoreInvalidConnectionType(value bool) {
	class(self).SetIgnoreInvalidConnectionType(value)
}

func (class) _draw_port(impl func(ptr gdclass.Receiver, slot_index int64, position Vector2i.XY, left bool, color Color.RGBA)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var slot_index = gd.UnsafeGet[int64](p_args, 0)
		var position = gd.UnsafeGet[Vector2i.XY](p_args, 1)
		var left = gd.UnsafeGet[bool](p_args, 2)
		var color = gd.UnsafeGet[Color.RGBA](p_args, 3)
		self := gdclass.Receiver(reflect.ValueOf(class).UnsafePointer())
		impl(self, slot_index, position, left, color)
	}
}

//go:nosplit
func (self class) SetTitle(title String.Readable) { //gd:GraphNode.set_title
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_title, 0|(gdextension.SizeString<<4), &struct{ title gdextension.String }{pointers.Get(gd.InternalString(title))})
}

//go:nosplit
func (self class) GetTitle() String.Readable { //gd:GraphNode.get_title
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_title, gdextension.SizeString, &struct{}{})
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Returns the [HBoxContainer] used for the title bar, only containing a [Label] for displaying the title by default. This can be used to add custom controls to the title bar such as option or close buttons.
*/
//go:nosplit
func (self class) GetTitlebarHbox() [1]gdclass.HBoxContainer { //gd:GraphNode.get_titlebar_hbox
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_titlebar_hbox, gdextension.SizeObject, &struct{}{})
	var ret = [1]gdclass.HBoxContainer{gd.PointerLifetimeBoundTo[gdclass.HBoxContainer](self.AsObject(), r_ret)}
	return ret
}

/*
Sets properties of the slot with the given [param slot_index].
If [param enable_left_port]/[param enable_right_port] is [code]true[/code], a port will appear and the slot will be able to be connected from this side.
With [param type_left]/[param type_right] an arbitrary type can be assigned to each port. Two ports can be connected if they share the same type, or if the connection between their types is allowed in the parent [GraphEdit] (see [method GraphEdit.add_valid_connection_type]). Keep in mind that the [GraphEdit] has the final say in accepting the connection. Type compatibility simply allows the [signal GraphEdit.connection_request] signal to be emitted.
Ports can be further customized using [param color_left]/[param color_right] and [param custom_icon_left]/[param custom_icon_right]. The color parameter adds a tint to the icon. The custom icon can be used to override the default port dot.
Additionally, [param draw_stylebox] can be used to enable or disable drawing of the background stylebox for each slot. See [theme_item slot].
Individual properties can also be set using one of the [code]set_slot_*[/code] methods.
[b]Note:[/b] This method only sets properties of the slot. To create the slot itself, add a [Control]-derived child to the GraphNode.
*/
//go:nosplit
func (self class) SetSlot(slot_index int64, enable_left_port bool, type_left int64, color_left Color.RGBA, enable_right_port bool, type_right int64, color_right Color.RGBA, custom_icon_left [1]gdclass.Texture2D, custom_icon_right [1]gdclass.Texture2D, draw_stylebox bool) { //gd:GraphNode.set_slot
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_slot, 0|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeColor<<16)|(gdextension.SizeBool<<20)|(gdextension.SizeInt<<24)|(gdextension.SizeColor<<28)|(gdextension.SizeObject<<32)|(gdextension.SizeObject<<36)|(gdextension.SizeBool<<40), &struct {
		slot_index        int64
		enable_left_port  bool
		type_left         int64
		color_left        Color.RGBA
		enable_right_port bool
		type_right        int64
		color_right       Color.RGBA
		custom_icon_left  gdextension.Object
		custom_icon_right gdextension.Object
		draw_stylebox     bool
	}{slot_index, enable_left_port, type_left, color_left, enable_right_port, type_right, color_right, gdextension.Object(gd.ObjectChecked(custom_icon_left[0].AsObject())), gdextension.Object(gd.ObjectChecked(custom_icon_right[0].AsObject())), draw_stylebox})
}

/*
Disables the slot with the given [param slot_index]. This will remove the corresponding input and output port from the GraphNode.
*/
//go:nosplit
func (self class) ClearSlot(slot_index int64) { //gd:GraphNode.clear_slot
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.clear_slot, 0|(gdextension.SizeInt<<4), &struct{ slot_index int64 }{slot_index})
}

/*
Disables all slots of the GraphNode. This will remove all input/output ports from the GraphNode.
*/
//go:nosplit
func (self class) ClearAllSlots() { //gd:GraphNode.clear_all_slots
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.clear_all_slots, 0, &struct{}{})
}

/*
Returns [code]true[/code] if left (input) side of the slot with the given [param slot_index] is enabled.
*/
//go:nosplit
func (self class) IsSlotEnabledLeft(slot_index int64) bool { //gd:GraphNode.is_slot_enabled_left
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_slot_enabled_left, gdextension.SizeBool|(gdextension.SizeInt<<4), &struct{ slot_index int64 }{slot_index})
	var ret = r_ret
	return ret
}

/*
Toggles the left (input) side of the slot with the given [param slot_index]. If [param enable] is [code]true[/code], a port will appear on the left side and the slot will be able to be connected from this side.
*/
//go:nosplit
func (self class) SetSlotEnabledLeft(slot_index int64, enable bool) { //gd:GraphNode.set_slot_enabled_left
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_slot_enabled_left, 0|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8), &struct {
		slot_index int64
		enable     bool
	}{slot_index, enable})
}

/*
Sets the left (input) type of the slot with the given [param slot_index] to [param type]. If the value is negative, all connections will be disallowed to be created via user inputs.
*/
//go:nosplit
func (self class) SetSlotTypeLeft(slot_index int64, atype int64) { //gd:GraphNode.set_slot_type_left
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_slot_type_left, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), &struct {
		slot_index int64
		atype      int64
	}{slot_index, atype})
}

/*
Returns the left (input) type of the slot with the given [param slot_index].
*/
//go:nosplit
func (self class) GetSlotTypeLeft(slot_index int64) int64 { //gd:GraphNode.get_slot_type_left
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_slot_type_left, gdextension.SizeInt|(gdextension.SizeInt<<4), &struct{ slot_index int64 }{slot_index})
	var ret = r_ret
	return ret
}

/*
Sets the [Color] of the left (input) side of the slot with the given [param slot_index] to [param color].
*/
//go:nosplit
func (self class) SetSlotColorLeft(slot_index int64, color Color.RGBA) { //gd:GraphNode.set_slot_color_left
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_slot_color_left, 0|(gdextension.SizeInt<<4)|(gdextension.SizeColor<<8), &struct {
		slot_index int64
		color      Color.RGBA
	}{slot_index, color})
}

/*
Returns the left (input) [Color] of the slot with the given [param slot_index].
*/
//go:nosplit
func (self class) GetSlotColorLeft(slot_index int64) Color.RGBA { //gd:GraphNode.get_slot_color_left
	var r_ret = gdextension.Call[Color.RGBA](gd.ObjectChecked(self.AsObject()), methods.get_slot_color_left, gdextension.SizeColor|(gdextension.SizeInt<<4), &struct{ slot_index int64 }{slot_index})
	var ret = r_ret
	return ret
}

/*
Sets the custom [Texture2D] of the left (input) side of the slot with the given [param slot_index] to [param custom_icon].
*/
//go:nosplit
func (self class) SetSlotCustomIconLeft(slot_index int64, custom_icon [1]gdclass.Texture2D) { //gd:GraphNode.set_slot_custom_icon_left
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_slot_custom_icon_left, 0|(gdextension.SizeInt<<4)|(gdextension.SizeObject<<8), &struct {
		slot_index  int64
		custom_icon gdextension.Object
	}{slot_index, gdextension.Object(gd.ObjectChecked(custom_icon[0].AsObject()))})
}

/*
Returns the left (input) custom [Texture2D] of the slot with the given [param slot_index].
*/
//go:nosplit
func (self class) GetSlotCustomIconLeft(slot_index int64) [1]gdclass.Texture2D { //gd:GraphNode.get_slot_custom_icon_left
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_slot_custom_icon_left, gdextension.SizeObject|(gdextension.SizeInt<<4), &struct{ slot_index int64 }{slot_index})
	var ret = [1]gdclass.Texture2D{gd.PointerWithOwnershipTransferredToGo[gdclass.Texture2D](r_ret)}
	return ret
}

/*
Returns [code]true[/code] if right (output) side of the slot with the given [param slot_index] is enabled.
*/
//go:nosplit
func (self class) IsSlotEnabledRight(slot_index int64) bool { //gd:GraphNode.is_slot_enabled_right
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_slot_enabled_right, gdextension.SizeBool|(gdextension.SizeInt<<4), &struct{ slot_index int64 }{slot_index})
	var ret = r_ret
	return ret
}

/*
Toggles the right (output) side of the slot with the given [param slot_index]. If [param enable] is [code]true[/code], a port will appear on the right side and the slot will be able to be connected from this side.
*/
//go:nosplit
func (self class) SetSlotEnabledRight(slot_index int64, enable bool) { //gd:GraphNode.set_slot_enabled_right
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_slot_enabled_right, 0|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8), &struct {
		slot_index int64
		enable     bool
	}{slot_index, enable})
}

/*
Sets the right (output) type of the slot with the given [param slot_index] to [param type]. If the value is negative, all connections will be disallowed to be created via user inputs.
*/
//go:nosplit
func (self class) SetSlotTypeRight(slot_index int64, atype int64) { //gd:GraphNode.set_slot_type_right
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_slot_type_right, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), &struct {
		slot_index int64
		atype      int64
	}{slot_index, atype})
}

/*
Returns the right (output) type of the slot with the given [param slot_index].
*/
//go:nosplit
func (self class) GetSlotTypeRight(slot_index int64) int64 { //gd:GraphNode.get_slot_type_right
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_slot_type_right, gdextension.SizeInt|(gdextension.SizeInt<<4), &struct{ slot_index int64 }{slot_index})
	var ret = r_ret
	return ret
}

/*
Sets the [Color] of the right (output) side of the slot with the given [param slot_index] to [param color].
*/
//go:nosplit
func (self class) SetSlotColorRight(slot_index int64, color Color.RGBA) { //gd:GraphNode.set_slot_color_right
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_slot_color_right, 0|(gdextension.SizeInt<<4)|(gdextension.SizeColor<<8), &struct {
		slot_index int64
		color      Color.RGBA
	}{slot_index, color})
}

/*
Returns the right (output) [Color] of the slot with the given [param slot_index].
*/
//go:nosplit
func (self class) GetSlotColorRight(slot_index int64) Color.RGBA { //gd:GraphNode.get_slot_color_right
	var r_ret = gdextension.Call[Color.RGBA](gd.ObjectChecked(self.AsObject()), methods.get_slot_color_right, gdextension.SizeColor|(gdextension.SizeInt<<4), &struct{ slot_index int64 }{slot_index})
	var ret = r_ret
	return ret
}

/*
Sets the custom [Texture2D] of the right (output) side of the slot with the given [param slot_index] to [param custom_icon].
*/
//go:nosplit
func (self class) SetSlotCustomIconRight(slot_index int64, custom_icon [1]gdclass.Texture2D) { //gd:GraphNode.set_slot_custom_icon_right
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_slot_custom_icon_right, 0|(gdextension.SizeInt<<4)|(gdextension.SizeObject<<8), &struct {
		slot_index  int64
		custom_icon gdextension.Object
	}{slot_index, gdextension.Object(gd.ObjectChecked(custom_icon[0].AsObject()))})
}

/*
Returns the right (output) custom [Texture2D] of the slot with the given [param slot_index].
*/
//go:nosplit
func (self class) GetSlotCustomIconRight(slot_index int64) [1]gdclass.Texture2D { //gd:GraphNode.get_slot_custom_icon_right
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_slot_custom_icon_right, gdextension.SizeObject|(gdextension.SizeInt<<4), &struct{ slot_index int64 }{slot_index})
	var ret = [1]gdclass.Texture2D{gd.PointerWithOwnershipTransferredToGo[gdclass.Texture2D](r_ret)}
	return ret
}

/*
Returns [code]true[/code] if the background [StyleBox] of the slot with the given [param slot_index] is drawn.
*/
//go:nosplit
func (self class) IsSlotDrawStylebox(slot_index int64) bool { //gd:GraphNode.is_slot_draw_stylebox
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_slot_draw_stylebox, gdextension.SizeBool|(gdextension.SizeInt<<4), &struct{ slot_index int64 }{slot_index})
	var ret = r_ret
	return ret
}

/*
Toggles the background [StyleBox] of the slot with the given [param slot_index].
*/
//go:nosplit
func (self class) SetSlotDrawStylebox(slot_index int64, enable bool) { //gd:GraphNode.set_slot_draw_stylebox
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_slot_draw_stylebox, 0|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8), &struct {
		slot_index int64
		enable     bool
	}{slot_index, enable})
}

//go:nosplit
func (self class) SetIgnoreInvalidConnectionType(ignore bool) { //gd:GraphNode.set_ignore_invalid_connection_type
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_ignore_invalid_connection_type, 0|(gdextension.SizeBool<<4), &struct{ ignore bool }{ignore})
}

//go:nosplit
func (self class) IsIgnoringValidConnectionType() bool { //gd:GraphNode.is_ignoring_valid_connection_type
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_ignoring_valid_connection_type, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

/*
Returns the number of slots with an enabled input port.
*/
//go:nosplit
func (self class) GetInputPortCount() int64 { //gd:GraphNode.get_input_port_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_input_port_count, gdextension.SizeInt, &struct{}{})
	var ret = r_ret
	return ret
}

/*
Returns the position of the input port with the given [param port_idx].
*/
//go:nosplit
func (self class) GetInputPortPosition(port_idx int64) Vector2.XY { //gd:GraphNode.get_input_port_position
	var r_ret = gdextension.Call[Vector2.XY](gd.ObjectChecked(self.AsObject()), methods.get_input_port_position, gdextension.SizeVector2|(gdextension.SizeInt<<4), &struct{ port_idx int64 }{port_idx})
	var ret = r_ret
	return ret
}

/*
Returns the type of the input port with the given [param port_idx].
*/
//go:nosplit
func (self class) GetInputPortType(port_idx int64) int64 { //gd:GraphNode.get_input_port_type
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_input_port_type, gdextension.SizeInt|(gdextension.SizeInt<<4), &struct{ port_idx int64 }{port_idx})
	var ret = r_ret
	return ret
}

/*
Returns the [Color] of the input port with the given [param port_idx].
*/
//go:nosplit
func (self class) GetInputPortColor(port_idx int64) Color.RGBA { //gd:GraphNode.get_input_port_color
	var r_ret = gdextension.Call[Color.RGBA](gd.ObjectChecked(self.AsObject()), methods.get_input_port_color, gdextension.SizeColor|(gdextension.SizeInt<<4), &struct{ port_idx int64 }{port_idx})
	var ret = r_ret
	return ret
}

/*
Returns the corresponding slot index of the input port with the given [param port_idx].
*/
//go:nosplit
func (self class) GetInputPortSlot(port_idx int64) int64 { //gd:GraphNode.get_input_port_slot
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_input_port_slot, gdextension.SizeInt|(gdextension.SizeInt<<4), &struct{ port_idx int64 }{port_idx})
	var ret = r_ret
	return ret
}

/*
Returns the number of slots with an enabled output port.
*/
//go:nosplit
func (self class) GetOutputPortCount() int64 { //gd:GraphNode.get_output_port_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_output_port_count, gdextension.SizeInt, &struct{}{})
	var ret = r_ret
	return ret
}

/*
Returns the position of the output port with the given [param port_idx].
*/
//go:nosplit
func (self class) GetOutputPortPosition(port_idx int64) Vector2.XY { //gd:GraphNode.get_output_port_position
	var r_ret = gdextension.Call[Vector2.XY](gd.ObjectChecked(self.AsObject()), methods.get_output_port_position, gdextension.SizeVector2|(gdextension.SizeInt<<4), &struct{ port_idx int64 }{port_idx})
	var ret = r_ret
	return ret
}

/*
Returns the type of the output port with the given [param port_idx].
*/
//go:nosplit
func (self class) GetOutputPortType(port_idx int64) int64 { //gd:GraphNode.get_output_port_type
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_output_port_type, gdextension.SizeInt|(gdextension.SizeInt<<4), &struct{ port_idx int64 }{port_idx})
	var ret = r_ret
	return ret
}

/*
Returns the [Color] of the output port with the given [param port_idx].
*/
//go:nosplit
func (self class) GetOutputPortColor(port_idx int64) Color.RGBA { //gd:GraphNode.get_output_port_color
	var r_ret = gdextension.Call[Color.RGBA](gd.ObjectChecked(self.AsObject()), methods.get_output_port_color, gdextension.SizeColor|(gdextension.SizeInt<<4), &struct{ port_idx int64 }{port_idx})
	var ret = r_ret
	return ret
}

/*
Returns the corresponding slot index of the output port with the given [param port_idx].
*/
//go:nosplit
func (self class) GetOutputPortSlot(port_idx int64) int64 { //gd:GraphNode.get_output_port_slot
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_output_port_slot, gdextension.SizeInt|(gdextension.SizeInt<<4), &struct{ port_idx int64 }{port_idx})
	var ret = r_ret
	return ret
}
func (self Instance) OnSlotUpdated(cb func(slot_index int), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("slot_updated"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) SlotUpdated() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`SlotUpdated`))))
}

func (self class) AsGraphNode() Advanced { return Advanced{pointers.AsA[gdclass.GraphNode](self[0])} }
func (self Instance) AsGraphNode() Instance {
	return Instance{pointers.AsA[gdclass.GraphNode](self[0])}
}
func (self *Extension[T]) AsGraphNode() Instance { return self.Super().AsGraphNode() }
func (self class) AsGraphElement() GraphElement.Advanced {
	return GraphElement.Advanced{pointers.AsA[gdclass.GraphElement](self[0])}
}
func (self *Extension[T]) AsGraphElement() GraphElement.Instance {
	return self.Super().AsGraphElement()
}
func (self Instance) AsGraphElement() GraphElement.Instance {
	return GraphElement.Instance{pointers.AsA[gdclass.GraphElement](self[0])}
}
func (self class) AsContainer() Container.Advanced {
	return Container.Advanced{pointers.AsA[gdclass.Container](self[0])}
}
func (self *Extension[T]) AsContainer() Container.Instance { return self.Super().AsContainer() }
func (self Instance) AsContainer() Container.Instance {
	return Container.Instance{pointers.AsA[gdclass.Container](self[0])}
}
func (self class) AsControl() Control.Advanced {
	return Control.Advanced{pointers.AsA[gdclass.Control](self[0])}
}
func (self *Extension[T]) AsControl() Control.Instance { return self.Super().AsControl() }
func (self Instance) AsControl() Control.Instance {
	return Control.Instance{pointers.AsA[gdclass.Control](self[0])}
}
func (self class) AsCanvasItem() CanvasItem.Advanced {
	return CanvasItem.Advanced{pointers.AsA[gdclass.CanvasItem](self[0])}
}
func (self *Extension[T]) AsCanvasItem() CanvasItem.Instance { return self.Super().AsCanvasItem() }
func (self Instance) AsCanvasItem() CanvasItem.Instance {
	return CanvasItem.Instance{pointers.AsA[gdclass.CanvasItem](self[0])}
}
func (self class) AsNode() Node.Advanced         { return Node.Advanced{pointers.AsA[gdclass.Node](self[0])} }
func (self *Extension[T]) AsNode() Node.Instance { return self.Super().AsNode() }
func (self Instance) AsNode() Node.Instance {
	return Node.Instance{pointers.AsA[gdclass.Node](self[0])}
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	case "_draw_port":
		return reflect.ValueOf(self._draw_port)
	default:
		return gd.VirtualByName(GraphElement.Advanced(self.AsGraphElement()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	case "_draw_port":
		return reflect.ValueOf(self._draw_port)
	default:
		return gd.VirtualByName(GraphElement.Instance(self.AsGraphElement()), name)
	}
}
func init() {
	gdclass.Register("GraphNode", func(ptr gd.Object) any { return Instance{pointers.AsA[gdclass.GraphNode](ptr)} })
}
