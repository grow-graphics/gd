// Code generated by the generate package DO NOT EDIT

// Package XRInterfaceExtension provides methods for working with XRInterfaceExtension object instances.
package XRInterfaceExtension

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/XRInterface"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/Rect2"
import "graphics.gd/variant/Rect2i"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"
import "graphics.gd/variant/Transform3D"
import "graphics.gd/variant/Vector2"
import "graphics.gd/variant/Vector3"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
External XR interface plugins should inherit from this class.

	See [Interface] for methods that can be overridden by a [Class] that extends it.
*/
type Instance [1]gdclass.XRInterfaceExtension

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	get_color_texture         gdextension.MethodForClass `hash:"529393457"`
	get_depth_texture         gdextension.MethodForClass `hash:"529393457"`
	get_velocity_texture      gdextension.MethodForClass `hash:"529393457"`
	add_blit                  gdextension.MethodForClass `hash:"258596971"`
	get_render_target_texture gdextension.MethodForClass `hash:"41030802"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("XRInterfaceExtension")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		pointers.Raw[gd.StringName](sname).Free()
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsXRInterfaceExtension() Instance
}
type Interface interface {
	//Returns the name of this interface.
	GetName() string
	//Returns the capabilities of this interface.
	GetCapabilities() int
	//Returns [code]true[/code] if this interface has been initialized.
	IsInitialized() bool
	//Initializes the interface, returns [code]true[/code] on success.
	Initialize() bool
	//Uninitialize the interface.
	Uninitialize()
	//Returns a [Dictionary] with system information related to this interface.
	GetSystemInfo() map[any]any
	//Returns [code]true[/code] if this interface supports this play area mode.
	SupportsPlayAreaMode(mode XRInterface.PlayAreaMode) bool
	//Returns the play area mode that sets up our play area.
	GetPlayAreaMode() XRInterface.PlayAreaMode
	//Set the play area mode for this interface.
	SetPlayAreaMode(mode XRInterface.PlayAreaMode) bool
	//Returns a [PackedVector3Array] that represents the play areas boundaries (if applicable).
	GetPlayArea() []Vector3.XYZ
	//Returns the size of our render target for this interface, this overrides the size of the [Viewport] marked as the xr viewport.
	GetRenderTargetSize() Vector2.XY
	//Returns the number of views this interface requires, 1 for mono, 2 for stereoscopic.
	GetViewCount() int
	//Returns the [Transform3D] that positions the [XRCamera3D] in the world.
	GetCameraTransform() Transform3D.BasisOrigin
	//Returns a [Transform3D] for a given view.
	GetTransformForView(view int, cam_transform Transform3D.BasisOrigin) Transform3D.BasisOrigin
	//Returns the projection matrix for the given view as a [PackedFloat64Array].
	GetProjectionForView(view int, aspect Float.X, z_near Float.X, z_far Float.X) []float64
	GetVrsTexture() RID.Any
	//Called if this [XRInterfaceExtension] is active before our physics and game process is called. Most XR interfaces will update its [XRPositionalTracker]s at this point in time.
	Process()
	//Called if this [XRInterfaceExtension] is active before rendering starts. Most XR interfaces will sync tracking at this point in time.
	PreRender()
	//Called if this is our primary [XRInterfaceExtension] before we start processing a [Viewport] for every active XR [Viewport], returns [code]true[/code] if that viewport should be rendered. An XR interface may return [code]false[/code] if the user has taken off their headset and we can pause rendering.
	PreDrawViewport(render_target RID.Any) bool
	//Called after the XR [Viewport] draw logic has completed.
	PostDrawViewport(render_target RID.Any, screen_rect Rect2.PositionSize)
	//Called if interface is active and queues have been submitted.
	EndFrame()
	//Returns a [PackedStringArray] with tracker names configured by this interface. Note that user configuration can override this list.
	GetSuggestedTrackerNames() []string
	//Returns a [PackedStringArray] with pose names configured by this interface. Note that user configuration can override this list.
	GetSuggestedPoseNames(tracker_name string) []string
	//Returns a [enum XRInterface.TrackingStatus] specifying the current status of our tracking.
	GetTrackingStatus() XRInterface.TrackingStatus
	//Triggers a haptic pulse to be emitted on the specified tracker.
	TriggerHapticPulse(action_name string, tracker_name string, frequency Float.X, amplitude Float.X, duration_sec Float.X, delay_sec Float.X)
	//Return [code]true[/code] if anchor detection is enabled for this interface.
	GetAnchorDetectionIsEnabled() bool
	//Enables anchor detection on this interface if supported.
	SetAnchorDetectionIsEnabled(enabled bool)
	//Returns the camera feed ID for the [CameraFeed] registered with the [CameraServer] that should be presented as the background on an AR capable device (if applicable).
	GetCameraFeedId() int
	//Return color texture into which to render (if applicable).
	GetColorTexture() RID.Any
	//Return depth texture into which to render (if applicable).
	GetDepthTexture() RID.Any
	//Return velocity texture into which to render (if applicable).
	GetVelocityTexture() RID.Any
}

// Implementation implements [Interface] with empty methods.
type Implementation = implementation

type implementation struct{}

func (self implementation) GetName() (_ string)                                         { return }
func (self implementation) GetCapabilities() (_ int)                                    { return }
func (self implementation) IsInitialized() (_ bool)                                     { return }
func (self implementation) Initialize() (_ bool)                                        { return }
func (self implementation) Uninitialize()                                               { return }
func (self implementation) GetSystemInfo() (_ map[any]any)                              { return }
func (self implementation) SupportsPlayAreaMode(mode XRInterface.PlayAreaMode) (_ bool) { return }
func (self implementation) GetPlayAreaMode() (_ XRInterface.PlayAreaMode)               { return }
func (self implementation) SetPlayAreaMode(mode XRInterface.PlayAreaMode) (_ bool)      { return }
func (self implementation) GetPlayArea() (_ []Vector3.XYZ)                              { return }
func (self implementation) GetRenderTargetSize() (_ Vector2.XY)                         { return }
func (self implementation) GetViewCount() (_ int)                                       { return }
func (self implementation) GetCameraTransform() (_ Transform3D.BasisOrigin)             { return }
func (self implementation) GetTransformForView(view int, cam_transform Transform3D.BasisOrigin) (_ Transform3D.BasisOrigin) {
	return
}
func (self implementation) GetProjectionForView(view int, aspect Float.X, z_near Float.X, z_far Float.X) (_ []float64) {
	return
}
func (self implementation) GetVrsTexture() (_ RID.Any)                     { return }
func (self implementation) Process()                                       { return }
func (self implementation) PreRender()                                     { return }
func (self implementation) PreDrawViewport(render_target RID.Any) (_ bool) { return }
func (self implementation) PostDrawViewport(render_target RID.Any, screen_rect Rect2.PositionSize) {
	return
}
func (self implementation) EndFrame()                                              { return }
func (self implementation) GetSuggestedTrackerNames() (_ []string)                 { return }
func (self implementation) GetSuggestedPoseNames(tracker_name string) (_ []string) { return }
func (self implementation) GetTrackingStatus() (_ XRInterface.TrackingStatus)      { return }
func (self implementation) TriggerHapticPulse(action_name string, tracker_name string, frequency Float.X, amplitude Float.X, duration_sec Float.X, delay_sec Float.X) {
	return
}
func (self implementation) GetAnchorDetectionIsEnabled() (_ bool)    { return }
func (self implementation) SetAnchorDetectionIsEnabled(enabled bool) { return }
func (self implementation) GetCameraFeedId() (_ int)                 { return }
func (self implementation) GetColorTexture() (_ RID.Any)             { return }
func (self implementation) GetDepthTexture() (_ RID.Any)             { return }
func (self implementation) GetVelocityTexture() (_ RID.Any)          { return }

/*
Returns the name of this interface.
*/
func (Instance) _get_name(impl func(ptr unsafe.Pointer) string) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		ptr, ok := pointers.End(gd.InternalStringName(String.Name(String.New(ret))))

		if !ok {
			return
		}
		gd.UnsafeSet(p_back, ptr)
	}
}

/*
Returns the capabilities of this interface.
*/
func (Instance) _get_capabilities(impl func(ptr unsafe.Pointer) int) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		gd.UnsafeSet(p_back, int64(ret))
	}
}

/*
Returns [code]true[/code] if this interface has been initialized.
*/
func (Instance) _is_initialized(impl func(ptr unsafe.Pointer) bool) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		gd.UnsafeSet(p_back, ret)
	}
}

/*
Initializes the interface, returns [code]true[/code] on success.
*/
func (Instance) _initialize(impl func(ptr unsafe.Pointer) bool) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		gd.UnsafeSet(p_back, ret)
	}
}

/*
Uninitialize the interface.
*/
func (Instance) _uninitialize(impl func(ptr unsafe.Pointer)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self)
	}
}

/*
Returns a [Dictionary] with system information related to this interface.
*/
func (Instance) _get_system_info(impl func(ptr unsafe.Pointer) map[any]any) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		ptr, ok := pointers.End(gd.InternalDictionary(gd.DictionaryFromMap(ret)))

		if !ok {
			return
		}
		gd.UnsafeSet(p_back, ptr)
	}
}

/*
Returns [code]true[/code] if this interface supports this play area mode.
*/
func (Instance) _supports_play_area_mode(impl func(ptr unsafe.Pointer, mode XRInterface.PlayAreaMode) bool) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var mode = gd.UnsafeGet[XRInterface.PlayAreaMode](p_args, 0)
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self, mode)
		gd.UnsafeSet(p_back, ret)
	}
}

/*
Returns the play area mode that sets up our play area.
*/
func (Instance) _get_play_area_mode(impl func(ptr unsafe.Pointer) XRInterface.PlayAreaMode) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		gd.UnsafeSet(p_back, ret)
	}
}

/*
Set the play area mode for this interface.
*/
func (Instance) _set_play_area_mode(impl func(ptr unsafe.Pointer, mode XRInterface.PlayAreaMode) bool) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var mode = gd.UnsafeGet[XRInterface.PlayAreaMode](p_args, 0)
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self, mode)
		gd.UnsafeSet(p_back, ret)
	}
}

/*
Returns a [PackedVector3Array] that represents the play areas boundaries (if applicable).
*/
func (Instance) _get_play_area(impl func(ptr unsafe.Pointer) []Vector3.XYZ) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		ptr, ok := pointers.End(gd.InternalPacked[gd.PackedVector3Array, Vector3.XYZ](Packed.New(ret...)))

		if !ok {
			return
		}
		gd.UnsafeSet(p_back, ptr)
	}
}

/*
Returns the size of our render target for this interface, this overrides the size of the [Viewport] marked as the xr viewport.
*/
func (Instance) _get_render_target_size(impl func(ptr unsafe.Pointer) Vector2.XY) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		gd.UnsafeSet(p_back, Vector2.XY(ret))
	}
}

/*
Returns the number of views this interface requires, 1 for mono, 2 for stereoscopic.
*/
func (Instance) _get_view_count(impl func(ptr unsafe.Pointer) int) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		gd.UnsafeSet(p_back, int64(ret))
	}
}

/*
Returns the [Transform3D] that positions the [XRCamera3D] in the world.
*/
func (Instance) _get_camera_transform(impl func(ptr unsafe.Pointer) Transform3D.BasisOrigin) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		gd.UnsafeSet(p_back, gd.Transposed(Transform3D.BasisOrigin(ret)))
	}
}

/*
Returns a [Transform3D] for a given view.
*/
func (Instance) _get_transform_for_view(impl func(ptr unsafe.Pointer, view int, cam_transform Transform3D.BasisOrigin) Transform3D.BasisOrigin) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var view = gd.UnsafeGet[int64](p_args, 0)
		var cam_transform = gd.Transposed(gd.UnsafeGet[Transform3D.BasisOrigin](p_args, 1))
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self, int(view), cam_transform)
		gd.UnsafeSet(p_back, gd.Transposed(Transform3D.BasisOrigin(ret)))
	}
}

/*
Returns the projection matrix for the given view as a [PackedFloat64Array].
*/
func (Instance) _get_projection_for_view(impl func(ptr unsafe.Pointer, view int, aspect Float.X, z_near Float.X, z_far Float.X) []float64) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var view = gd.UnsafeGet[int64](p_args, 0)
		var aspect = gd.UnsafeGet[float64](p_args, 1)
		var z_near = gd.UnsafeGet[float64](p_args, 2)
		var z_far = gd.UnsafeGet[float64](p_args, 3)
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self, int(view), Float.X(aspect), Float.X(z_near), Float.X(z_far))
		ptr, ok := pointers.End(gd.InternalPacked[gd.PackedFloat64Array, float64](Packed.New(ret...)))

		if !ok {
			return
		}
		gd.UnsafeSet(p_back, ptr)
	}
}
func (Instance) _get_vrs_texture(impl func(ptr unsafe.Pointer) RID.Any) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		gd.UnsafeSet(p_back, RID.Any(ret))
	}
}

/*
Called if this [XRInterfaceExtension] is active before our physics and game process is called. Most XR interfaces will update its [XRPositionalTracker]s at this point in time.
*/
func (Instance) _process(impl func(ptr unsafe.Pointer)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self)
	}
}

/*
Called if this [XRInterfaceExtension] is active before rendering starts. Most XR interfaces will sync tracking at this point in time.
*/
func (Instance) _pre_render(impl func(ptr unsafe.Pointer)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self)
	}
}

/*
Called if this is our primary [XRInterfaceExtension] before we start processing a [Viewport] for every active XR [Viewport], returns [code]true[/code] if that viewport should be rendered. An XR interface may return [code]false[/code] if the user has taken off their headset and we can pause rendering.
*/
func (Instance) _pre_draw_viewport(impl func(ptr unsafe.Pointer, render_target RID.Any) bool) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var render_target = gd.UnsafeGet[RID.Any](p_args, 0)
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self, render_target)
		gd.UnsafeSet(p_back, ret)
	}
}

/*
Called after the XR [Viewport] draw logic has completed.
*/
func (Instance) _post_draw_viewport(impl func(ptr unsafe.Pointer, render_target RID.Any, screen_rect Rect2.PositionSize)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var render_target = gd.UnsafeGet[RID.Any](p_args, 0)
		var screen_rect = gd.UnsafeGet[Rect2.PositionSize](p_args, 1)
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, render_target, screen_rect)
	}
}

/*
Called if interface is active and queues have been submitted.
*/
func (Instance) _end_frame(impl func(ptr unsafe.Pointer)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self)
	}
}

/*
Returns a [PackedStringArray] with tracker names configured by this interface. Note that user configuration can override this list.
*/
func (Instance) _get_suggested_tracker_names(impl func(ptr unsafe.Pointer) []string) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		ptr, ok := pointers.End(gd.InternalPackedStrings(Packed.MakeStrings(ret...)))

		if !ok {
			return
		}
		gd.UnsafeSet(p_back, ptr)
	}
}

/*
Returns a [PackedStringArray] with pose names configured by this interface. Note that user configuration can override this list.
*/
func (Instance) _get_suggested_pose_names(impl func(ptr unsafe.Pointer, tracker_name string) []string) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var tracker_name = String.Name(String.Via(gd.StringNameProxy{}, pointers.Pack(pointers.New[gd.StringName](gd.UnsafeGet[gdextension.StringName](p_args, 0)))))
		defer pointers.End(gd.InternalStringName(tracker_name))
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self, tracker_name.String())
		ptr, ok := pointers.End(gd.InternalPackedStrings(Packed.MakeStrings(ret...)))

		if !ok {
			return
		}
		gd.UnsafeSet(p_back, ptr)
	}
}

/*
Returns a [enum XRInterface.TrackingStatus] specifying the current status of our tracking.
*/
func (Instance) _get_tracking_status(impl func(ptr unsafe.Pointer) XRInterface.TrackingStatus) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		gd.UnsafeSet(p_back, ret)
	}
}

/*
Triggers a haptic pulse to be emitted on the specified tracker.
*/
func (Instance) _trigger_haptic_pulse(impl func(ptr unsafe.Pointer, action_name string, tracker_name string, frequency Float.X, amplitude Float.X, duration_sec Float.X, delay_sec Float.X)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var action_name = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](gd.UnsafeGet[gdextension.String](p_args, 0))))
		defer pointers.End(gd.InternalString(action_name))
		var tracker_name = String.Name(String.Via(gd.StringNameProxy{}, pointers.Pack(pointers.New[gd.StringName](gd.UnsafeGet[gdextension.StringName](p_args, 1)))))
		defer pointers.End(gd.InternalStringName(tracker_name))
		var frequency = gd.UnsafeGet[float64](p_args, 2)
		var amplitude = gd.UnsafeGet[float64](p_args, 3)
		var duration_sec = gd.UnsafeGet[float64](p_args, 4)
		var delay_sec = gd.UnsafeGet[float64](p_args, 5)
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, action_name.String(), tracker_name.String(), Float.X(frequency), Float.X(amplitude), Float.X(duration_sec), Float.X(delay_sec))
	}
}

/*
Return [code]true[/code] if anchor detection is enabled for this interface.
*/
func (Instance) _get_anchor_detection_is_enabled(impl func(ptr unsafe.Pointer) bool) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		gd.UnsafeSet(p_back, ret)
	}
}

/*
Enables anchor detection on this interface if supported.
*/
func (Instance) _set_anchor_detection_is_enabled(impl func(ptr unsafe.Pointer, enabled bool)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var enabled = gd.UnsafeGet[bool](p_args, 0)
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, enabled)
	}
}

/*
Returns the camera feed ID for the [CameraFeed] registered with the [CameraServer] that should be presented as the background on an AR capable device (if applicable).
*/
func (Instance) _get_camera_feed_id(impl func(ptr unsafe.Pointer) int) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		gd.UnsafeSet(p_back, int64(ret))
	}
}

/*
Return color texture into which to render (if applicable).
*/
func (Instance) _get_color_texture(impl func(ptr unsafe.Pointer) RID.Any) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		gd.UnsafeSet(p_back, RID.Any(ret))
	}
}

/*
Return depth texture into which to render (if applicable).
*/
func (Instance) _get_depth_texture(impl func(ptr unsafe.Pointer) RID.Any) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		gd.UnsafeSet(p_back, RID.Any(ret))
	}
}

/*
Return velocity texture into which to render (if applicable).
*/
func (Instance) _get_velocity_texture(impl func(ptr unsafe.Pointer) RID.Any) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		gd.UnsafeSet(p_back, RID.Any(ret))
	}
}
func (self Instance) GetColorTexture() RID.Texture { //gd:XRInterfaceExtension.get_color_texture
	return RID.Texture(Advanced(self).GetColorTexture())
}
func (self Instance) GetDepthTexture() RID.Texture { //gd:XRInterfaceExtension.get_depth_texture
	return RID.Texture(Advanced(self).GetDepthTexture())
}
func (self Instance) GetVelocityTexture() RID.Texture { //gd:XRInterfaceExtension.get_velocity_texture
	return RID.Texture(Advanced(self).GetVelocityTexture())
}

/*
Blits our render results to screen optionally applying lens distortion. This can only be called while processing [code]_commit_views[/code].
*/
func (self Instance) AddBlit(render_target RID.Framebuffer, src_rect Rect2.PositionSize, dst_rect Rect2i.PositionSize, use_layer bool, layer int, apply_lens_distortion bool, eye_center Vector2.XY, k1 Float.X, k2 Float.X, upscale Float.X, aspect_ratio Float.X) { //gd:XRInterfaceExtension.add_blit
	Advanced(self).AddBlit(RID.Any(render_target), Rect2.PositionSize(src_rect), Rect2i.PositionSize(dst_rect), use_layer, int64(layer), apply_lens_distortion, Vector2.XY(eye_center), float64(k1), float64(k2), float64(upscale), float64(aspect_ratio))
}

/*
Returns a valid [RID] for a texture to which we should render the current frame if supported by the interface.
*/
func (self Instance) GetRenderTargetTexture(render_target RID.Framebuffer) RID.Texture { //gd:XRInterfaceExtension.get_render_target_texture
	return RID.Texture(Advanced(self).GetRenderTargetTexture(RID.Any(render_target)))
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.XRInterfaceExtension

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.XRInterfaceExtension)(unsafe.Pointer(&obj))
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.XRInterfaceExtension)(unsafe.Pointer(&obj))
		return true
	}
	return false
}

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {

	if !gd.Linked {
		var placeholder Instance
		*(*gd.Object)(unsafe.Pointer(&placeholder)) = pointers.Add[gd.Object]([3]uint64{})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(*(*gd.Object)(unsafe.Pointer(&placeholder)), raw)
				gd.RegisterCleanup(func() {
					gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
				})
			}
		})
		return placeholder
	}
	object := [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})}
	casted := Instance{*(*gdclass.XRInterfaceExtension)(unsafe.Pointer(&object))}
	casted.AsRefCounted()[0].Reference()
	object[0].Notification(0, false)
	return casted
}

/*
Returns the name of this interface.
*/
func (class) _get_name(impl func(ptr unsafe.Pointer) String.Name) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		ptr, ok := pointers.End(gd.InternalStringName(ret))

		if !ok {
			return
		}
		gd.UnsafeSet(p_back, ptr)
	}
}

/*
Returns the capabilities of this interface.
*/
func (class) _get_capabilities(impl func(ptr unsafe.Pointer) int64) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		gd.UnsafeSet(p_back, ret)
	}
}

/*
Returns [code]true[/code] if this interface has been initialized.
*/
func (class) _is_initialized(impl func(ptr unsafe.Pointer) bool) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		gd.UnsafeSet(p_back, ret)
	}
}

/*
Initializes the interface, returns [code]true[/code] on success.
*/
func (class) _initialize(impl func(ptr unsafe.Pointer) bool) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		gd.UnsafeSet(p_back, ret)
	}
}

/*
Uninitialize the interface.
*/
func (class) _uninitialize(impl func(ptr unsafe.Pointer)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self)
	}
}

/*
Returns a [Dictionary] with system information related to this interface.
*/
func (class) _get_system_info(impl func(ptr unsafe.Pointer) Dictionary.Any) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		ptr, ok := pointers.End(gd.InternalDictionary(ret))

		if !ok {
			return
		}
		gd.UnsafeSet(p_back, ptr)
	}
}

/*
Returns [code]true[/code] if this interface supports this play area mode.
*/
func (class) _supports_play_area_mode(impl func(ptr unsafe.Pointer, mode XRInterface.PlayAreaMode) bool) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var mode = gd.UnsafeGet[XRInterface.PlayAreaMode](p_args, 0)
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self, mode)
		gd.UnsafeSet(p_back, ret)
	}
}

/*
Returns the play area mode that sets up our play area.
*/
func (class) _get_play_area_mode(impl func(ptr unsafe.Pointer) XRInterface.PlayAreaMode) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		gd.UnsafeSet(p_back, ret)
	}
}

/*
Set the play area mode for this interface.
*/
func (class) _set_play_area_mode(impl func(ptr unsafe.Pointer, mode XRInterface.PlayAreaMode) bool) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var mode = gd.UnsafeGet[XRInterface.PlayAreaMode](p_args, 0)
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self, mode)
		gd.UnsafeSet(p_back, ret)
	}
}

/*
Returns a [PackedVector3Array] that represents the play areas boundaries (if applicable).
*/
func (class) _get_play_area(impl func(ptr unsafe.Pointer) Packed.Array[Vector3.XYZ]) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		ptr, ok := pointers.End(gd.InternalPacked[gd.PackedVector3Array, Vector3.XYZ](ret))

		if !ok {
			return
		}
		gd.UnsafeSet(p_back, ptr)
	}
}

/*
Returns the size of our render target for this interface, this overrides the size of the [Viewport] marked as the xr viewport.
*/
func (class) _get_render_target_size(impl func(ptr unsafe.Pointer) Vector2.XY) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		gd.UnsafeSet(p_back, ret)
	}
}

/*
Returns the number of views this interface requires, 1 for mono, 2 for stereoscopic.
*/
func (class) _get_view_count(impl func(ptr unsafe.Pointer) int64) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		gd.UnsafeSet(p_back, ret)
	}
}

/*
Returns the [Transform3D] that positions the [XRCamera3D] in the world.
*/
func (class) _get_camera_transform(impl func(ptr unsafe.Pointer) Transform3D.BasisOrigin) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		gd.UnsafeSet(p_back, gd.Transposed(ret))
	}
}

/*
Returns a [Transform3D] for a given view.
*/
func (class) _get_transform_for_view(impl func(ptr unsafe.Pointer, view int64, cam_transform Transform3D.BasisOrigin) Transform3D.BasisOrigin) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var view = gd.UnsafeGet[int64](p_args, 0)
		var cam_transform = gd.Transposed(gd.UnsafeGet[Transform3D.BasisOrigin](p_args, 1))
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self, view, cam_transform)
		gd.UnsafeSet(p_back, gd.Transposed(ret))
	}
}

/*
Returns the projection matrix for the given view as a [PackedFloat64Array].
*/
func (class) _get_projection_for_view(impl func(ptr unsafe.Pointer, view int64, aspect float64, z_near float64, z_far float64) Packed.Array[float64]) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var view = gd.UnsafeGet[int64](p_args, 0)
		var aspect = gd.UnsafeGet[float64](p_args, 1)
		var z_near = gd.UnsafeGet[float64](p_args, 2)
		var z_far = gd.UnsafeGet[float64](p_args, 3)
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self, view, aspect, z_near, z_far)
		ptr, ok := pointers.End(gd.InternalPacked[gd.PackedFloat64Array, float64](ret))

		if !ok {
			return
		}
		gd.UnsafeSet(p_back, ptr)
	}
}

func (class) _get_vrs_texture(impl func(ptr unsafe.Pointer) RID.Any) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		gd.UnsafeSet(p_back, ret)
	}
}

/*
Called if this [XRInterfaceExtension] is active before our physics and game process is called. Most XR interfaces will update its [XRPositionalTracker]s at this point in time.
*/
func (class) _process(impl func(ptr unsafe.Pointer)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self)
	}
}

/*
Called if this [XRInterfaceExtension] is active before rendering starts. Most XR interfaces will sync tracking at this point in time.
*/
func (class) _pre_render(impl func(ptr unsafe.Pointer)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self)
	}
}

/*
Called if this is our primary [XRInterfaceExtension] before we start processing a [Viewport] for every active XR [Viewport], returns [code]true[/code] if that viewport should be rendered. An XR interface may return [code]false[/code] if the user has taken off their headset and we can pause rendering.
*/
func (class) _pre_draw_viewport(impl func(ptr unsafe.Pointer, render_target RID.Any) bool) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var render_target = gd.UnsafeGet[RID.Any](p_args, 0)
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self, render_target)
		gd.UnsafeSet(p_back, ret)
	}
}

/*
Called after the XR [Viewport] draw logic has completed.
*/
func (class) _post_draw_viewport(impl func(ptr unsafe.Pointer, render_target RID.Any, screen_rect Rect2.PositionSize)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var render_target = gd.UnsafeGet[RID.Any](p_args, 0)
		var screen_rect = gd.UnsafeGet[Rect2.PositionSize](p_args, 1)
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, render_target, screen_rect)
	}
}

/*
Called if interface is active and queues have been submitted.
*/
func (class) _end_frame(impl func(ptr unsafe.Pointer)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self)
	}
}

/*
Returns a [PackedStringArray] with tracker names configured by this interface. Note that user configuration can override this list.
*/
func (class) _get_suggested_tracker_names(impl func(ptr unsafe.Pointer) Packed.Strings) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		ptr, ok := pointers.End(gd.InternalPackedStrings(ret))

		if !ok {
			return
		}
		gd.UnsafeSet(p_back, ptr)
	}
}

/*
Returns a [PackedStringArray] with pose names configured by this interface. Note that user configuration can override this list.
*/
func (class) _get_suggested_pose_names(impl func(ptr unsafe.Pointer, tracker_name String.Name) Packed.Strings) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var tracker_name = String.Name(String.Via(gd.StringNameProxy{}, pointers.Pack(pointers.New[gd.StringName](gd.UnsafeGet[gdextension.StringName](p_args, 0)))))
		defer pointers.End(gd.InternalStringName(tracker_name))
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self, tracker_name)
		ptr, ok := pointers.End(gd.InternalPackedStrings(ret))

		if !ok {
			return
		}
		gd.UnsafeSet(p_back, ptr)
	}
}

/*
Returns a [enum XRInterface.TrackingStatus] specifying the current status of our tracking.
*/
func (class) _get_tracking_status(impl func(ptr unsafe.Pointer) XRInterface.TrackingStatus) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		gd.UnsafeSet(p_back, ret)
	}
}

/*
Triggers a haptic pulse to be emitted on the specified tracker.
*/
func (class) _trigger_haptic_pulse(impl func(ptr unsafe.Pointer, action_name String.Readable, tracker_name String.Name, frequency float64, amplitude float64, duration_sec float64, delay_sec float64)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var action_name = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](gd.UnsafeGet[gdextension.String](p_args, 0))))
		defer pointers.End(gd.InternalString(action_name))
		var tracker_name = String.Name(String.Via(gd.StringNameProxy{}, pointers.Pack(pointers.New[gd.StringName](gd.UnsafeGet[gdextension.StringName](p_args, 1)))))
		defer pointers.End(gd.InternalStringName(tracker_name))
		var frequency = gd.UnsafeGet[float64](p_args, 2)
		var amplitude = gd.UnsafeGet[float64](p_args, 3)
		var duration_sec = gd.UnsafeGet[float64](p_args, 4)
		var delay_sec = gd.UnsafeGet[float64](p_args, 5)
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, action_name, tracker_name, frequency, amplitude, duration_sec, delay_sec)
	}
}

/*
Return [code]true[/code] if anchor detection is enabled for this interface.
*/
func (class) _get_anchor_detection_is_enabled(impl func(ptr unsafe.Pointer) bool) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		gd.UnsafeSet(p_back, ret)
	}
}

/*
Enables anchor detection on this interface if supported.
*/
func (class) _set_anchor_detection_is_enabled(impl func(ptr unsafe.Pointer, enabled bool)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var enabled = gd.UnsafeGet[bool](p_args, 0)
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, enabled)
	}
}

/*
Returns the camera feed ID for the [CameraFeed] registered with the [CameraServer] that should be presented as the background on an AR capable device (if applicable).
*/
func (class) _get_camera_feed_id(impl func(ptr unsafe.Pointer) int64) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		gd.UnsafeSet(p_back, ret)
	}
}

/*
Return color texture into which to render (if applicable).
*/
func (class) _get_color_texture(impl func(ptr unsafe.Pointer) RID.Any) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		gd.UnsafeSet(p_back, ret)
	}
}

/*
Return depth texture into which to render (if applicable).
*/
func (class) _get_depth_texture(impl func(ptr unsafe.Pointer) RID.Any) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		gd.UnsafeSet(p_back, ret)
	}
}

/*
Return velocity texture into which to render (if applicable).
*/
func (class) _get_velocity_texture(impl func(ptr unsafe.Pointer) RID.Any) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		gd.UnsafeSet(p_back, ret)
	}
}

//go:nosplit
func (self class) GetColorTexture() RID.Any { //gd:XRInterfaceExtension.get_color_texture
	var r_ret = gdextension.Call[RID.Any](gd.ObjectChecked(self.AsObject()), methods.get_color_texture, gdextension.SizeRID, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) GetDepthTexture() RID.Any { //gd:XRInterfaceExtension.get_depth_texture
	var r_ret = gdextension.Call[RID.Any](gd.ObjectChecked(self.AsObject()), methods.get_depth_texture, gdextension.SizeRID, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) GetVelocityTexture() RID.Any { //gd:XRInterfaceExtension.get_velocity_texture
	var r_ret = gdextension.Call[RID.Any](gd.ObjectChecked(self.AsObject()), methods.get_velocity_texture, gdextension.SizeRID, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Blits our render results to screen optionally applying lens distortion. This can only be called while processing [code]_commit_views[/code].
*/
//go:nosplit
func (self class) AddBlit(render_target RID.Any, src_rect Rect2.PositionSize, dst_rect Rect2i.PositionSize, use_layer bool, layer int64, apply_lens_distortion bool, eye_center Vector2.XY, k1 float64, k2 float64, upscale float64, aspect_ratio float64) { //gd:XRInterfaceExtension.add_blit
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_blit, 0|(gdextension.SizeRID<<4)|(gdextension.SizeRect2<<8)|(gdextension.SizeRect2i<<12)|(gdextension.SizeBool<<16)|(gdextension.SizeInt<<20)|(gdextension.SizeBool<<24)|(gdextension.SizeVector2<<28)|(gdextension.SizeFloat<<32)|(gdextension.SizeFloat<<36)|(gdextension.SizeFloat<<40)|(gdextension.SizeFloat<<44), unsafe.Pointer(&struct {
		render_target         RID.Any
		src_rect              Rect2.PositionSize
		dst_rect              Rect2i.PositionSize
		use_layer             bool
		layer                 int64
		apply_lens_distortion bool
		eye_center            Vector2.XY
		k1                    float64
		k2                    float64
		upscale               float64
		aspect_ratio          float64
	}{render_target, src_rect, dst_rect, use_layer, layer, apply_lens_distortion, eye_center, k1, k2, upscale, aspect_ratio}))
}

/*
Returns a valid [RID] for a texture to which we should render the current frame if supported by the interface.
*/
//go:nosplit
func (self class) GetRenderTargetTexture(render_target RID.Any) RID.Any { //gd:XRInterfaceExtension.get_render_target_texture
	var r_ret = gdextension.Call[RID.Any](gd.ObjectChecked(self.AsObject()), methods.get_render_target_texture, gdextension.SizeRID|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ render_target RID.Any }{render_target}))
	var ret = r_ret
	return ret
}
func (self class) AsXRInterfaceExtension() Advanced    { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsXRInterfaceExtension() Instance { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsXRInterfaceExtension() Instance {
	return self.Super().AsXRInterfaceExtension()
}
func (self class) AsXRInterface() XRInterface.Advanced {
	return *((*XRInterface.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsXRInterface() XRInterface.Instance { return self.Super().AsXRInterface() }
func (self Instance) AsXRInterface() XRInterface.Instance {
	return *((*XRInterface.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsRefCounted() [1]gd.RefCounted { return self.Super().AsRefCounted() }
func (self Instance) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	case "_get_name":
		return reflect.ValueOf(self._get_name)
	case "_get_capabilities":
		return reflect.ValueOf(self._get_capabilities)
	case "_is_initialized":
		return reflect.ValueOf(self._is_initialized)
	case "_initialize":
		return reflect.ValueOf(self._initialize)
	case "_uninitialize":
		return reflect.ValueOf(self._uninitialize)
	case "_get_system_info":
		return reflect.ValueOf(self._get_system_info)
	case "_supports_play_area_mode":
		return reflect.ValueOf(self._supports_play_area_mode)
	case "_get_play_area_mode":
		return reflect.ValueOf(self._get_play_area_mode)
	case "_set_play_area_mode":
		return reflect.ValueOf(self._set_play_area_mode)
	case "_get_play_area":
		return reflect.ValueOf(self._get_play_area)
	case "_get_render_target_size":
		return reflect.ValueOf(self._get_render_target_size)
	case "_get_view_count":
		return reflect.ValueOf(self._get_view_count)
	case "_get_camera_transform":
		return reflect.ValueOf(self._get_camera_transform)
	case "_get_transform_for_view":
		return reflect.ValueOf(self._get_transform_for_view)
	case "_get_projection_for_view":
		return reflect.ValueOf(self._get_projection_for_view)
	case "_get_vrs_texture":
		return reflect.ValueOf(self._get_vrs_texture)
	case "_process":
		return reflect.ValueOf(self._process)
	case "_pre_render":
		return reflect.ValueOf(self._pre_render)
	case "_pre_draw_viewport":
		return reflect.ValueOf(self._pre_draw_viewport)
	case "_post_draw_viewport":
		return reflect.ValueOf(self._post_draw_viewport)
	case "_end_frame":
		return reflect.ValueOf(self._end_frame)
	case "_get_suggested_tracker_names":
		return reflect.ValueOf(self._get_suggested_tracker_names)
	case "_get_suggested_pose_names":
		return reflect.ValueOf(self._get_suggested_pose_names)
	case "_get_tracking_status":
		return reflect.ValueOf(self._get_tracking_status)
	case "_trigger_haptic_pulse":
		return reflect.ValueOf(self._trigger_haptic_pulse)
	case "_get_anchor_detection_is_enabled":
		return reflect.ValueOf(self._get_anchor_detection_is_enabled)
	case "_set_anchor_detection_is_enabled":
		return reflect.ValueOf(self._set_anchor_detection_is_enabled)
	case "_get_camera_feed_id":
		return reflect.ValueOf(self._get_camera_feed_id)
	case "_get_color_texture":
		return reflect.ValueOf(self._get_color_texture)
	case "_get_depth_texture":
		return reflect.ValueOf(self._get_depth_texture)
	case "_get_velocity_texture":
		return reflect.ValueOf(self._get_velocity_texture)
	default:
		return gd.VirtualByName(XRInterface.Advanced(self.AsXRInterface()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	case "_get_name":
		return reflect.ValueOf(self._get_name)
	case "_get_capabilities":
		return reflect.ValueOf(self._get_capabilities)
	case "_is_initialized":
		return reflect.ValueOf(self._is_initialized)
	case "_initialize":
		return reflect.ValueOf(self._initialize)
	case "_uninitialize":
		return reflect.ValueOf(self._uninitialize)
	case "_get_system_info":
		return reflect.ValueOf(self._get_system_info)
	case "_supports_play_area_mode":
		return reflect.ValueOf(self._supports_play_area_mode)
	case "_get_play_area_mode":
		return reflect.ValueOf(self._get_play_area_mode)
	case "_set_play_area_mode":
		return reflect.ValueOf(self._set_play_area_mode)
	case "_get_play_area":
		return reflect.ValueOf(self._get_play_area)
	case "_get_render_target_size":
		return reflect.ValueOf(self._get_render_target_size)
	case "_get_view_count":
		return reflect.ValueOf(self._get_view_count)
	case "_get_camera_transform":
		return reflect.ValueOf(self._get_camera_transform)
	case "_get_transform_for_view":
		return reflect.ValueOf(self._get_transform_for_view)
	case "_get_projection_for_view":
		return reflect.ValueOf(self._get_projection_for_view)
	case "_get_vrs_texture":
		return reflect.ValueOf(self._get_vrs_texture)
	case "_process":
		return reflect.ValueOf(self._process)
	case "_pre_render":
		return reflect.ValueOf(self._pre_render)
	case "_pre_draw_viewport":
		return reflect.ValueOf(self._pre_draw_viewport)
	case "_post_draw_viewport":
		return reflect.ValueOf(self._post_draw_viewport)
	case "_end_frame":
		return reflect.ValueOf(self._end_frame)
	case "_get_suggested_tracker_names":
		return reflect.ValueOf(self._get_suggested_tracker_names)
	case "_get_suggested_pose_names":
		return reflect.ValueOf(self._get_suggested_pose_names)
	case "_get_tracking_status":
		return reflect.ValueOf(self._get_tracking_status)
	case "_trigger_haptic_pulse":
		return reflect.ValueOf(self._trigger_haptic_pulse)
	case "_get_anchor_detection_is_enabled":
		return reflect.ValueOf(self._get_anchor_detection_is_enabled)
	case "_set_anchor_detection_is_enabled":
		return reflect.ValueOf(self._set_anchor_detection_is_enabled)
	case "_get_camera_feed_id":
		return reflect.ValueOf(self._get_camera_feed_id)
	case "_get_color_texture":
		return reflect.ValueOf(self._get_color_texture)
	case "_get_depth_texture":
		return reflect.ValueOf(self._get_depth_texture)
	case "_get_velocity_texture":
		return reflect.ValueOf(self._get_velocity_texture)
	default:
		return gd.VirtualByName(XRInterface.Instance(self.AsXRInterface()), name)
	}
}
func init() {
	gdclass.Register("XRInterfaceExtension", func(ptr gd.Object) any { return *(*Instance)(unsafe.Pointer(&ptr)) })
}
