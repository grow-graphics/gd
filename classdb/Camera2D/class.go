// Code generated by the generate package DO NOT EDIT

// Package Camera2D provides methods for working with Camera2D object instances.
package Camera2D

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/CanvasItem"
import "graphics.gd/classdb/Node"
import "graphics.gd/classdb/Node2D"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/Rect2"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"
import "graphics.gd/variant/Vector2"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
Camera node for 2D scenes. It forces the screen (current layer) to scroll following this node. This makes it easier (and faster) to program scrollable scenes than manually changing the position of [CanvasItem]-based nodes.
Cameras register themselves in the nearest [Viewport] node (when ascending the tree). Only one camera can be active per viewport. If no viewport is available ascending the tree, the camera will register in the global viewport.
This node is intended to be a simple helper to get things going quickly, but more functionality may be desired to change how the camera works. To make your own custom camera node, inherit it from [Node2D] and change the transform of the canvas by setting [member Viewport.canvas_transform] in [Viewport] (you can obtain the current [Viewport] by using [method Node.get_viewport]).
Note that the [Camera2D] node's [code]position[/code] doesn't represent the actual position of the screen, which may differ due to applied smoothing or limits. You can use [method get_screen_center_position] to get the real position.
*/
type Instance [1]gdclass.Camera2D

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	set_offset                     gdextension.MethodForClass `hash:"743155724"`
	get_offset                     gdextension.MethodForClass `hash:"3341600327"`
	set_anchor_mode                gdextension.MethodForClass `hash:"2050398218"`
	get_anchor_mode                gdextension.MethodForClass `hash:"155978067"`
	set_ignore_rotation            gdextension.MethodForClass `hash:"2586408642"`
	is_ignoring_rotation           gdextension.MethodForClass `hash:"36873697"`
	set_process_callback           gdextension.MethodForClass `hash:"4201947462"`
	get_process_callback           gdextension.MethodForClass `hash:"2325344499"`
	set_enabled                    gdextension.MethodForClass `hash:"2586408642"`
	is_enabled                     gdextension.MethodForClass `hash:"36873697"`
	make_current                   gdextension.MethodForClass `hash:"3218959716"`
	is_current                     gdextension.MethodForClass `hash:"36873697"`
	set_limit                      gdextension.MethodForClass `hash:"437707142"`
	get_limit                      gdextension.MethodForClass `hash:"1983885014"`
	set_limit_smoothing_enabled    gdextension.MethodForClass `hash:"2586408642"`
	is_limit_smoothing_enabled     gdextension.MethodForClass `hash:"36873697"`
	set_drag_vertical_enabled      gdextension.MethodForClass `hash:"2586408642"`
	is_drag_vertical_enabled       gdextension.MethodForClass `hash:"36873697"`
	set_drag_horizontal_enabled    gdextension.MethodForClass `hash:"2586408642"`
	is_drag_horizontal_enabled     gdextension.MethodForClass `hash:"36873697"`
	set_drag_vertical_offset       gdextension.MethodForClass `hash:"373806689"`
	get_drag_vertical_offset       gdextension.MethodForClass `hash:"1740695150"`
	set_drag_horizontal_offset     gdextension.MethodForClass `hash:"373806689"`
	get_drag_horizontal_offset     gdextension.MethodForClass `hash:"1740695150"`
	set_drag_margin                gdextension.MethodForClass `hash:"4290182280"`
	get_drag_margin                gdextension.MethodForClass `hash:"2869120046"`
	get_target_position            gdextension.MethodForClass `hash:"3341600327"`
	get_screen_center_position     gdextension.MethodForClass `hash:"3341600327"`
	set_zoom                       gdextension.MethodForClass `hash:"743155724"`
	get_zoom                       gdextension.MethodForClass `hash:"3341600327"`
	set_custom_viewport            gdextension.MethodForClass `hash:"1078189570"`
	get_custom_viewport            gdextension.MethodForClass `hash:"3160264692"`
	set_position_smoothing_speed   gdextension.MethodForClass `hash:"373806689"`
	get_position_smoothing_speed   gdextension.MethodForClass `hash:"1740695150"`
	set_position_smoothing_enabled gdextension.MethodForClass `hash:"2586408642"`
	is_position_smoothing_enabled  gdextension.MethodForClass `hash:"36873697"`
	set_rotation_smoothing_enabled gdextension.MethodForClass `hash:"2586408642"`
	is_rotation_smoothing_enabled  gdextension.MethodForClass `hash:"36873697"`
	set_rotation_smoothing_speed   gdextension.MethodForClass `hash:"373806689"`
	get_rotation_smoothing_speed   gdextension.MethodForClass `hash:"1740695150"`
	force_update_scroll            gdextension.MethodForClass `hash:"3218959716"`
	reset_smoothing                gdextension.MethodForClass `hash:"3218959716"`
	align                          gdextension.MethodForClass `hash:"3218959716"`
	set_screen_drawing_enabled     gdextension.MethodForClass `hash:"2586408642"`
	is_screen_drawing_enabled      gdextension.MethodForClass `hash:"36873697"`
	set_limit_drawing_enabled      gdextension.MethodForClass `hash:"2586408642"`
	is_limit_drawing_enabled       gdextension.MethodForClass `hash:"36873697"`
	set_margin_drawing_enabled     gdextension.MethodForClass `hash:"2586408642"`
	is_margin_drawing_enabled      gdextension.MethodForClass `hash:"36873697"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("Camera2D")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		pointers.Raw[gd.StringName](sname).Free()
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsCamera2D() Instance
}

/*
Forces this [Camera2D] to become the current active one. [member enabled] must be [code]true[/code].
*/
func (self Instance) MakeCurrent() { //gd:Camera2D.make_current
	Advanced(self).MakeCurrent()
}

/*
Returns [code]true[/code] if this [Camera2D] is the active camera (see [method Viewport.get_camera_2d]).
*/
func (self Instance) IsCurrent() bool { //gd:Camera2D.is_current
	return bool(Advanced(self).IsCurrent())
}

/*
Returns this camera's target position, in global coordinates.
[b]Note:[/b] The returned value is not the same as [member Node2D.global_position], as it is affected by the drag properties. It is also not the same as the current position if [member position_smoothing_enabled] is [code]true[/code] (see [method get_screen_center_position]).
*/
func (self Instance) GetTargetPosition() Vector2.XY { //gd:Camera2D.get_target_position
	return Vector2.XY(Advanced(self).GetTargetPosition())
}

/*
Returns the center of the screen from this camera's point of view, in global coordinates.
[b]Note:[/b] The exact targeted position of the camera may be different. See [method get_target_position].
*/
func (self Instance) GetScreenCenterPosition() Vector2.XY { //gd:Camera2D.get_screen_center_position
	return Vector2.XY(Advanced(self).GetScreenCenterPosition())
}

/*
Forces the camera to update scroll immediately.
*/
func (self Instance) ForceUpdateScroll() { //gd:Camera2D.force_update_scroll
	Advanced(self).ForceUpdateScroll()
}

/*
Sets the camera's position immediately to its current smoothing destination.
This method has no effect if [member position_smoothing_enabled] is [code]false[/code].
*/
func (self Instance) ResetSmoothing() { //gd:Camera2D.reset_smoothing
	Advanced(self).ResetSmoothing()
}

/*
Aligns the camera to the tracked node.
*/
func (self Instance) Align() { //gd:Camera2D.align
	Advanced(self).Align()
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.Camera2D

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.Camera2D)(unsafe.Pointer(&obj))
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.Camera2D)(unsafe.Pointer(&obj))
		return true
	}
	return false
}

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {
	object := [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})}
	casted := Instance{*(*gdclass.Camera2D)(unsafe.Pointer(&object))}
	object[0].Notification(0, false)
	return casted
}

func (self Instance) Offset() Vector2.XY {
	return Vector2.XY(class(self).GetOffset())
}

func (self Instance) SetOffset(value Vector2.XY) {
	class(self).SetOffset(Vector2.XY(value))
}

func (self Instance) AnchorMode() AnchorMode {
	return AnchorMode(class(self).GetAnchorMode())
}

func (self Instance) SetAnchorMode(value AnchorMode) {
	class(self).SetAnchorMode(value)
}

func (self Instance) IgnoreRotation() bool {
	return bool(class(self).IsIgnoringRotation())
}

func (self Instance) SetIgnoreRotation(value bool) {
	class(self).SetIgnoreRotation(value)
}

func (self Instance) Enabled() bool {
	return bool(class(self).IsEnabled())
}

func (self Instance) SetEnabled(value bool) {
	class(self).SetEnabled(value)
}

func (self Instance) Zoom() Vector2.XY {
	return Vector2.XY(class(self).GetZoom())
}

func (self Instance) SetZoom(value Vector2.XY) {
	class(self).SetZoom(Vector2.XY(value))
}

func (self Instance) CustomViewport() Node.Instance {
	return Node.Instance(class(self).GetCustomViewport())
}

func (self Instance) SetCustomViewport(value Node.Instance) {
	class(self).SetCustomViewport(value)
}

func (self Instance) ProcessCallback() Camera2DProcessCallback {
	return Camera2DProcessCallback(class(self).GetProcessCallback())
}

func (self Instance) SetProcessCallback(value Camera2DProcessCallback) {
	class(self).SetProcessCallback(value)
}

func (self Instance) LimitLeft() int {
	return int(int(class(self).GetLimit(0)))
}

func (self Instance) SetLimitLeft(value int) {
	class(self).SetLimit(0, int64(value))
}

func (self Instance) LimitTop() int {
	return int(int(class(self).GetLimit(1)))
}

func (self Instance) SetLimitTop(value int) {
	class(self).SetLimit(1, int64(value))
}

func (self Instance) LimitRight() int {
	return int(int(class(self).GetLimit(2)))
}

func (self Instance) SetLimitRight(value int) {
	class(self).SetLimit(2, int64(value))
}

func (self Instance) LimitBottom() int {
	return int(int(class(self).GetLimit(3)))
}

func (self Instance) SetLimitBottom(value int) {
	class(self).SetLimit(3, int64(value))
}

func (self Instance) LimitSmoothed() bool {
	return bool(class(self).IsLimitSmoothingEnabled())
}

func (self Instance) SetLimitSmoothed(value bool) {
	class(self).SetLimitSmoothingEnabled(value)
}

func (self Instance) PositionSmoothingEnabled() bool {
	return bool(class(self).IsPositionSmoothingEnabled())
}

func (self Instance) SetPositionSmoothingEnabled(value bool) {
	class(self).SetPositionSmoothingEnabled(value)
}

func (self Instance) PositionSmoothingSpeed() Float.X {
	return Float.X(Float.X(class(self).GetPositionSmoothingSpeed()))
}

func (self Instance) SetPositionSmoothingSpeed(value Float.X) {
	class(self).SetPositionSmoothingSpeed(float64(value))
}

func (self Instance) RotationSmoothingEnabled() bool {
	return bool(class(self).IsRotationSmoothingEnabled())
}

func (self Instance) SetRotationSmoothingEnabled(value bool) {
	class(self).SetRotationSmoothingEnabled(value)
}

func (self Instance) RotationSmoothingSpeed() Float.X {
	return Float.X(Float.X(class(self).GetRotationSmoothingSpeed()))
}

func (self Instance) SetRotationSmoothingSpeed(value Float.X) {
	class(self).SetRotationSmoothingSpeed(float64(value))
}

func (self Instance) DragHorizontalEnabled() bool {
	return bool(class(self).IsDragHorizontalEnabled())
}

func (self Instance) SetDragHorizontalEnabled(value bool) {
	class(self).SetDragHorizontalEnabled(value)
}

func (self Instance) DragVerticalEnabled() bool {
	return bool(class(self).IsDragVerticalEnabled())
}

func (self Instance) SetDragVerticalEnabled(value bool) {
	class(self).SetDragVerticalEnabled(value)
}

func (self Instance) DragHorizontalOffset() Float.X {
	return Float.X(Float.X(class(self).GetDragHorizontalOffset()))
}

func (self Instance) SetDragHorizontalOffset(value Float.X) {
	class(self).SetDragHorizontalOffset(float64(value))
}

func (self Instance) DragVerticalOffset() Float.X {
	return Float.X(Float.X(class(self).GetDragVerticalOffset()))
}

func (self Instance) SetDragVerticalOffset(value Float.X) {
	class(self).SetDragVerticalOffset(float64(value))
}

func (self Instance) DragLeftMargin() Float.X {
	return Float.X(Float.X(class(self).GetDragMargin(0)))
}

func (self Instance) SetDragLeftMargin(value Float.X) {
	class(self).SetDragMargin(0, float64(value))
}

func (self Instance) DragTopMargin() Float.X {
	return Float.X(Float.X(class(self).GetDragMargin(1)))
}

func (self Instance) SetDragTopMargin(value Float.X) {
	class(self).SetDragMargin(1, float64(value))
}

func (self Instance) DragRightMargin() Float.X {
	return Float.X(Float.X(class(self).GetDragMargin(2)))
}

func (self Instance) SetDragRightMargin(value Float.X) {
	class(self).SetDragMargin(2, float64(value))
}

func (self Instance) DragBottomMargin() Float.X {
	return Float.X(Float.X(class(self).GetDragMargin(3)))
}

func (self Instance) SetDragBottomMargin(value Float.X) {
	class(self).SetDragMargin(3, float64(value))
}

func (self Instance) EditorDrawScreen() bool {
	return bool(class(self).IsScreenDrawingEnabled())
}

func (self Instance) SetEditorDrawScreen(value bool) {
	class(self).SetScreenDrawingEnabled(value)
}

func (self Instance) EditorDrawLimits() bool {
	return bool(class(self).IsLimitDrawingEnabled())
}

func (self Instance) SetEditorDrawLimits(value bool) {
	class(self).SetLimitDrawingEnabled(value)
}

func (self Instance) EditorDrawDragMargin() bool {
	return bool(class(self).IsMarginDrawingEnabled())
}

func (self Instance) SetEditorDrawDragMargin(value bool) {
	class(self).SetMarginDrawingEnabled(value)
}

//go:nosplit
func (self class) SetOffset(offset Vector2.XY) { //gd:Camera2D.set_offset
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_offset, 0|(gdextension.SizeVector2<<4), unsafe.Pointer(&struct{ offset Vector2.XY }{offset}))
}

//go:nosplit
func (self class) GetOffset() Vector2.XY { //gd:Camera2D.get_offset
	var r_ret = gdextension.Call[Vector2.XY](gd.ObjectChecked(self.AsObject()), methods.get_offset, gdextension.SizeVector2, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetAnchorMode(anchor_mode AnchorMode) { //gd:Camera2D.set_anchor_mode
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_anchor_mode, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ anchor_mode AnchorMode }{anchor_mode}))
}

//go:nosplit
func (self class) GetAnchorMode() AnchorMode { //gd:Camera2D.get_anchor_mode
	var r_ret = gdextension.Call[AnchorMode](gd.ObjectChecked(self.AsObject()), methods.get_anchor_mode, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetIgnoreRotation(ignore bool) { //gd:Camera2D.set_ignore_rotation
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_ignore_rotation, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ ignore bool }{ignore}))
}

//go:nosplit
func (self class) IsIgnoringRotation() bool { //gd:Camera2D.is_ignoring_rotation
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_ignoring_rotation, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetProcessCallback(mode Camera2DProcessCallback) { //gd:Camera2D.set_process_callback
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_process_callback, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ mode Camera2DProcessCallback }{mode}))
}

//go:nosplit
func (self class) GetProcessCallback() Camera2DProcessCallback { //gd:Camera2D.get_process_callback
	var r_ret = gdextension.Call[Camera2DProcessCallback](gd.ObjectChecked(self.AsObject()), methods.get_process_callback, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetEnabled(enabled bool) { //gd:Camera2D.set_enabled
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_enabled, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enabled bool }{enabled}))
}

//go:nosplit
func (self class) IsEnabled() bool { //gd:Camera2D.is_enabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_enabled, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Forces this [Camera2D] to become the current active one. [member enabled] must be [code]true[/code].
*/
//go:nosplit
func (self class) MakeCurrent() { //gd:Camera2D.make_current
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.make_current, 0, unsafe.Pointer(&struct{}{}))
}

/*
Returns [code]true[/code] if this [Camera2D] is the active camera (see [method Viewport.get_camera_2d]).
*/
//go:nosplit
func (self class) IsCurrent() bool { //gd:Camera2D.is_current
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_current, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Sets the camera limit for the specified [enum Side]. See also [member limit_bottom], [member limit_top], [member limit_left], and [member limit_right].
*/
//go:nosplit
func (self class) SetLimit(margin Rect2.Side, limit int64) { //gd:Camera2D.set_limit
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_limit, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		margin Rect2.Side
		limit  int64
	}{margin, limit}))
}

/*
Returns the camera limit for the specified [enum Side]. See also [member limit_bottom], [member limit_top], [member limit_left], and [member limit_right].
*/
//go:nosplit
func (self class) GetLimit(margin Rect2.Side) int64 { //gd:Camera2D.get_limit
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_limit, gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ margin Rect2.Side }{margin}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetLimitSmoothingEnabled(limit_smoothing_enabled bool) { //gd:Camera2D.set_limit_smoothing_enabled
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_limit_smoothing_enabled, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ limit_smoothing_enabled bool }{limit_smoothing_enabled}))
}

//go:nosplit
func (self class) IsLimitSmoothingEnabled() bool { //gd:Camera2D.is_limit_smoothing_enabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_limit_smoothing_enabled, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetDragVerticalEnabled(enabled bool) { //gd:Camera2D.set_drag_vertical_enabled
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_drag_vertical_enabled, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enabled bool }{enabled}))
}

//go:nosplit
func (self class) IsDragVerticalEnabled() bool { //gd:Camera2D.is_drag_vertical_enabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_drag_vertical_enabled, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetDragHorizontalEnabled(enabled bool) { //gd:Camera2D.set_drag_horizontal_enabled
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_drag_horizontal_enabled, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enabled bool }{enabled}))
}

//go:nosplit
func (self class) IsDragHorizontalEnabled() bool { //gd:Camera2D.is_drag_horizontal_enabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_drag_horizontal_enabled, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetDragVerticalOffset(offset float64) { //gd:Camera2D.set_drag_vertical_offset
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_drag_vertical_offset, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ offset float64 }{offset}))
}

//go:nosplit
func (self class) GetDragVerticalOffset() float64 { //gd:Camera2D.get_drag_vertical_offset
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_drag_vertical_offset, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetDragHorizontalOffset(offset float64) { //gd:Camera2D.set_drag_horizontal_offset
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_drag_horizontal_offset, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ offset float64 }{offset}))
}

//go:nosplit
func (self class) GetDragHorizontalOffset() float64 { //gd:Camera2D.get_drag_horizontal_offset
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_drag_horizontal_offset, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Sets the specified [enum Side]'s margin. See also [member drag_bottom_margin], [member drag_top_margin], [member drag_left_margin], and [member drag_right_margin].
*/
//go:nosplit
func (self class) SetDragMargin(margin Rect2.Side, drag_margin float64) { //gd:Camera2D.set_drag_margin
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_drag_margin, 0|(gdextension.SizeInt<<4)|(gdextension.SizeFloat<<8), unsafe.Pointer(&struct {
		margin      Rect2.Side
		drag_margin float64
	}{margin, drag_margin}))
}

/*
Returns the specified [enum Side]'s margin. See also [member drag_bottom_margin], [member drag_top_margin], [member drag_left_margin], and [member drag_right_margin].
*/
//go:nosplit
func (self class) GetDragMargin(margin Rect2.Side) float64 { //gd:Camera2D.get_drag_margin
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_drag_margin, gdextension.SizeFloat|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ margin Rect2.Side }{margin}))
	var ret = r_ret
	return ret
}

/*
Returns this camera's target position, in global coordinates.
[b]Note:[/b] The returned value is not the same as [member Node2D.global_position], as it is affected by the drag properties. It is also not the same as the current position if [member position_smoothing_enabled] is [code]true[/code] (see [method get_screen_center_position]).
*/
//go:nosplit
func (self class) GetTargetPosition() Vector2.XY { //gd:Camera2D.get_target_position
	var r_ret = gdextension.Call[Vector2.XY](gd.ObjectChecked(self.AsObject()), methods.get_target_position, gdextension.SizeVector2, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the center of the screen from this camera's point of view, in global coordinates.
[b]Note:[/b] The exact targeted position of the camera may be different. See [method get_target_position].
*/
//go:nosplit
func (self class) GetScreenCenterPosition() Vector2.XY { //gd:Camera2D.get_screen_center_position
	var r_ret = gdextension.Call[Vector2.XY](gd.ObjectChecked(self.AsObject()), methods.get_screen_center_position, gdextension.SizeVector2, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetZoom(zoom Vector2.XY) { //gd:Camera2D.set_zoom
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_zoom, 0|(gdextension.SizeVector2<<4), unsafe.Pointer(&struct{ zoom Vector2.XY }{zoom}))
}

//go:nosplit
func (self class) GetZoom() Vector2.XY { //gd:Camera2D.get_zoom
	var r_ret = gdextension.Call[Vector2.XY](gd.ObjectChecked(self.AsObject()), methods.get_zoom, gdextension.SizeVector2, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetCustomViewport(viewport [1]gdclass.Node) { //gd:Camera2D.set_custom_viewport
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_custom_viewport, 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ viewport gdextension.Object }{gdextension.Object(gd.ObjectChecked(viewport[0].AsObject()))}))
}

//go:nosplit
func (self class) GetCustomViewport() [1]gdclass.Node { //gd:Camera2D.get_custom_viewport
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_custom_viewport, gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.Node{gd.PointerMustAssertInstanceID[gdclass.Node](r_ret)}
	return ret
}

//go:nosplit
func (self class) SetPositionSmoothingSpeed(position_smoothing_speed float64) { //gd:Camera2D.set_position_smoothing_speed
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_position_smoothing_speed, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ position_smoothing_speed float64 }{position_smoothing_speed}))
}

//go:nosplit
func (self class) GetPositionSmoothingSpeed() float64 { //gd:Camera2D.get_position_smoothing_speed
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_position_smoothing_speed, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetPositionSmoothingEnabled(position_smoothing_speed bool) { //gd:Camera2D.set_position_smoothing_enabled
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_position_smoothing_enabled, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ position_smoothing_speed bool }{position_smoothing_speed}))
}

//go:nosplit
func (self class) IsPositionSmoothingEnabled() bool { //gd:Camera2D.is_position_smoothing_enabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_position_smoothing_enabled, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetRotationSmoothingEnabled(enabled bool) { //gd:Camera2D.set_rotation_smoothing_enabled
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_rotation_smoothing_enabled, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enabled bool }{enabled}))
}

//go:nosplit
func (self class) IsRotationSmoothingEnabled() bool { //gd:Camera2D.is_rotation_smoothing_enabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_rotation_smoothing_enabled, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetRotationSmoothingSpeed(speed float64) { //gd:Camera2D.set_rotation_smoothing_speed
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_rotation_smoothing_speed, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ speed float64 }{speed}))
}

//go:nosplit
func (self class) GetRotationSmoothingSpeed() float64 { //gd:Camera2D.get_rotation_smoothing_speed
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_rotation_smoothing_speed, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Forces the camera to update scroll immediately.
*/
//go:nosplit
func (self class) ForceUpdateScroll() { //gd:Camera2D.force_update_scroll
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.force_update_scroll, 0, unsafe.Pointer(&struct{}{}))
}

/*
Sets the camera's position immediately to its current smoothing destination.
This method has no effect if [member position_smoothing_enabled] is [code]false[/code].
*/
//go:nosplit
func (self class) ResetSmoothing() { //gd:Camera2D.reset_smoothing
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.reset_smoothing, 0, unsafe.Pointer(&struct{}{}))
}

/*
Aligns the camera to the tracked node.
*/
//go:nosplit
func (self class) Align() { //gd:Camera2D.align
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.align, 0, unsafe.Pointer(&struct{}{}))
}

//go:nosplit
func (self class) SetScreenDrawingEnabled(screen_drawing_enabled bool) { //gd:Camera2D.set_screen_drawing_enabled
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_screen_drawing_enabled, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ screen_drawing_enabled bool }{screen_drawing_enabled}))
}

//go:nosplit
func (self class) IsScreenDrawingEnabled() bool { //gd:Camera2D.is_screen_drawing_enabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_screen_drawing_enabled, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetLimitDrawingEnabled(limit_drawing_enabled bool) { //gd:Camera2D.set_limit_drawing_enabled
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_limit_drawing_enabled, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ limit_drawing_enabled bool }{limit_drawing_enabled}))
}

//go:nosplit
func (self class) IsLimitDrawingEnabled() bool { //gd:Camera2D.is_limit_drawing_enabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_limit_drawing_enabled, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetMarginDrawingEnabled(margin_drawing_enabled bool) { //gd:Camera2D.set_margin_drawing_enabled
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_margin_drawing_enabled, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ margin_drawing_enabled bool }{margin_drawing_enabled}))
}

//go:nosplit
func (self class) IsMarginDrawingEnabled() bool { //gd:Camera2D.is_margin_drawing_enabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_margin_drawing_enabled, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}
func (self class) AsCamera2D() Advanced              { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsCamera2D() Instance           { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsCamera2D() Instance      { return self.Super().AsCamera2D() }
func (self class) AsNode2D() Node2D.Advanced         { return *((*Node2D.Advanced)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsNode2D() Node2D.Instance { return self.Super().AsNode2D() }
func (self Instance) AsNode2D() Node2D.Instance      { return *((*Node2D.Instance)(unsafe.Pointer(&self))) }
func (self class) AsCanvasItem() CanvasItem.Advanced {
	return *((*CanvasItem.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsCanvasItem() CanvasItem.Instance { return self.Super().AsCanvasItem() }
func (self Instance) AsCanvasItem() CanvasItem.Instance {
	return *((*CanvasItem.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsNode() Node.Advanced         { return *((*Node.Advanced)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsNode() Node.Instance { return self.Super().AsNode() }
func (self Instance) AsNode() Node.Instance      { return *((*Node.Instance)(unsafe.Pointer(&self))) }

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Node2D.Advanced(self.AsNode2D()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Node2D.Instance(self.AsNode2D()), name)
	}
}
func init() {
	gdclass.Register("Camera2D", func(ptr gd.Object) any { return *(*Instance)(unsafe.Pointer(&ptr)) })
}

type AnchorMode int //gd:Camera2D.AnchorMode

const (
	/*The camera's position is fixed so that the top-left corner is always at the origin.*/
	AnchorModeFixedTopLeft AnchorMode = 0
	/*The camera's position takes into account vertical/horizontal offsets and the screen size.*/
	AnchorModeDragCenter AnchorMode = 1
)

type Camera2DProcessCallback int //gd:Camera2D.Camera2DProcessCallback

const (
	/*The camera updates during physics frames (see [constant Node.NOTIFICATION_INTERNAL_PHYSICS_PROCESS]).*/
	Camera2dProcessPhysics Camera2DProcessCallback = 0
	/*The camera updates during process frames (see [constant Node.NOTIFICATION_INTERNAL_PROCESS]).*/
	Camera2dProcessIdle Camera2DProcessCallback = 1
)
