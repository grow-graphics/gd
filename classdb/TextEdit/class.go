// Code generated by the generate package DO NOT EDIT

// Package TextEdit provides methods for working with TextEdit object instances.
package TextEdit

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/CanvasItem"
import "graphics.gd/classdb/Control"
import "graphics.gd/classdb/HScrollBar"
import "graphics.gd/classdb/Node"
import "graphics.gd/classdb/PopupMenu"
import "graphics.gd/classdb/TextServer"
import "graphics.gd/classdb/Texture2D"
import "graphics.gd/classdb/VScrollBar"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Color"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/Rect2"
import "graphics.gd/variant/Rect2i"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"
import "graphics.gd/variant/Vector2"
import "graphics.gd/variant/Vector2i"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
A multiline text editor. It also has limited facilities for editing code, such as syntax highlighting support. For more advanced facilities for editing code, see [CodeEdit].
[b]Note:[/b] Most viewport, caret, and edit methods contain a [code]caret_index[/code] argument for [member caret_multiple] support. The argument should be one of the following: [code]-1[/code] for all carets, [code]0[/code] for the main caret, or greater than [code]0[/code] for secondary carets in the order they were created.
[b]Note:[/b] When holding down [kbd]Alt[/kbd], the vertical scroll wheel will scroll 5 times as fast as it would normally do. This also works in the Godot script editor.

	See [Interface] for methods that can be overridden by a [Class] that extends it.
*/
type Instance [1]gdclass.TextEdit

func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

type Expanded [1]gdclass.TextEdit

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsTextEdit() Instance
}
type Interface interface {
	//Override this method to define what happens when the user types in the provided key [param unicode_char].
	HandleUnicodeInput(unicode_char int, caret_index int)
	//Override this method to define what happens when the user presses the backspace key.
	Backspace(caret_index int)
	//Override this method to define what happens when the user performs a cut operation.
	Cut(caret_index int)
	//Override this method to define what happens when the user performs a copy operation.
	Copy(caret_index int)
	//Override this method to define what happens when the user performs a paste operation.
	Paste(caret_index int)
	//Override this method to define what happens when the user performs a paste operation with middle mouse button.
	//[b]Note:[/b] This method is only implemented on Linux.
	PastePrimaryClipboard(caret_index int)
}

// Implementation implements [Interface] with empty methods.
type Implementation = implementation

type implementation struct{}

func (self implementation) HandleUnicodeInput(unicode_char int, caret_index int) { return }
func (self implementation) Backspace(caret_index int)                            { return }
func (self implementation) Cut(caret_index int)                                  { return }
func (self implementation) Copy(caret_index int)                                 { return }
func (self implementation) Paste(caret_index int)                                { return }
func (self implementation) PastePrimaryClipboard(caret_index int)                { return }

/*
Override this method to define what happens when the user types in the provided key [param unicode_char].
*/
func (Instance) _handle_unicode_input(impl func(ptr unsafe.Pointer, unicode_char int, caret_index int)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var unicode_char = gd.UnsafeGet[int64](p_args, 0)
		var caret_index = gd.UnsafeGet[int64](p_args, 1)
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, int(unicode_char), int(caret_index))
	}
}

/*
Override this method to define what happens when the user presses the backspace key.
*/
func (Instance) _backspace(impl func(ptr unsafe.Pointer, caret_index int)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var caret_index = gd.UnsafeGet[int64](p_args, 0)
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, int(caret_index))
	}
}

/*
Override this method to define what happens when the user performs a cut operation.
*/
func (Instance) _cut(impl func(ptr unsafe.Pointer, caret_index int)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var caret_index = gd.UnsafeGet[int64](p_args, 0)
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, int(caret_index))
	}
}

/*
Override this method to define what happens when the user performs a copy operation.
*/
func (Instance) _copy(impl func(ptr unsafe.Pointer, caret_index int)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var caret_index = gd.UnsafeGet[int64](p_args, 0)
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, int(caret_index))
	}
}

/*
Override this method to define what happens when the user performs a paste operation.
*/
func (Instance) _paste(impl func(ptr unsafe.Pointer, caret_index int)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var caret_index = gd.UnsafeGet[int64](p_args, 0)
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, int(caret_index))
	}
}

/*
Override this method to define what happens when the user performs a paste operation with middle mouse button.
[b]Note:[/b] This method is only implemented on Linux.
*/
func (Instance) _paste_primary_clipboard(impl func(ptr unsafe.Pointer, caret_index int)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var caret_index = gd.UnsafeGet[int64](p_args, 0)
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, int(caret_index))
	}
}

/*
Returns [code]true[/code] if the user has text in the [url=https://en.wikipedia.org/wiki/Input_method]Input Method Editor[/url] (IME).
*/
func (self Instance) HasImeText() bool { //gd:TextEdit.has_ime_text
	return bool(Advanced(self).HasImeText())
}

/*
Closes the [url=https://en.wikipedia.org/wiki/Input_method]Input Method Editor[/url] (IME) if it is open. Any text in the IME will be lost.
*/
func (self Instance) CancelIme() { //gd:TextEdit.cancel_ime
	Advanced(self).CancelIme()
}

/*
Applies text from the [url=https://en.wikipedia.org/wiki/Input_method]Input Method Editor[/url] (IME) to each caret and closes the IME if it is open.
*/
func (self Instance) ApplyIme() { //gd:TextEdit.apply_ime
	Advanced(self).ApplyIme()
}

/*
Sets the tab size for the [TextEdit] to use.
*/
func (self Instance) SetTabSize(size int) { //gd:TextEdit.set_tab_size
	Advanced(self).SetTabSize(int64(size))
}

/*
Returns the [TextEdit]'s' tab size.
*/
func (self Instance) GetTabSize() int { //gd:TextEdit.get_tab_size
	return int(int(Advanced(self).GetTabSize()))
}

/*
If [code]true[/code], enables overtype mode. In this mode, typing overrides existing text instead of inserting text. The [member ProjectSettings.input/ui_text_toggle_insert_mode] action toggles overtype mode. See [method is_overtype_mode_enabled].
*/
func (self Instance) SetOvertypeModeEnabled(enabled bool) { //gd:TextEdit.set_overtype_mode_enabled
	Advanced(self).SetOvertypeModeEnabled(enabled)
}

/*
Returns [code]true[/code] if overtype mode is enabled. See [method set_overtype_mode_enabled].
*/
func (self Instance) IsOvertypeModeEnabled() bool { //gd:TextEdit.is_overtype_mode_enabled
	return bool(Advanced(self).IsOvertypeModeEnabled())
}

/*
Performs a full reset of [TextEdit], including undo history.
*/
func (self Instance) Clear() { //gd:TextEdit.clear
	Advanced(self).Clear()
}

/*
Returns the number of lines in the text.
*/
func (self Instance) GetLineCount() int { //gd:TextEdit.get_line_count
	return int(int(Advanced(self).GetLineCount()))
}

/*
Sets the text for a specific [param line].
Carets on the line will attempt to keep their visual x position.
*/
func (self Instance) SetLine(line int, new_text string) { //gd:TextEdit.set_line
	Advanced(self).SetLine(int64(line), String.New(new_text))
}

/*
Returns the text of a specific line.
*/
func (self Instance) GetLine(line int) string { //gd:TextEdit.get_line
	return string(Advanced(self).GetLine(int64(line)).String())
}

/*
Returns line text as it is currently displayed, including IME composition string.
*/
func (self Instance) GetLineWithIme(line int) string { //gd:TextEdit.get_line_with_ime
	return string(Advanced(self).GetLineWithIme(int64(line)).String())
}

/*
Returns the width in pixels of the [param wrap_index] on [param line].
*/
func (self Instance) GetLineWidth(line int) int { //gd:TextEdit.get_line_width
	return int(int(Advanced(self).GetLineWidth(int64(line), int64(-1))))
}

/*
Returns the width in pixels of the [param wrap_index] on [param line].
*/
func (self Expanded) GetLineWidth(line int, wrap_index int) int { //gd:TextEdit.get_line_width
	return int(int(Advanced(self).GetLineWidth(int64(line), int64(wrap_index))))
}

/*
Returns the maximum value of the line height among all lines.
[b]Note:[/b] The return value is influenced by [theme_item line_spacing] and [theme_item font_size]. And it will not be less than [code]1[/code].
*/
func (self Instance) GetLineHeight() int { //gd:TextEdit.get_line_height
	return int(int(Advanced(self).GetLineHeight()))
}

/*
Returns the indent level of the given line. This is the number of spaces and tabs at the beginning of the line, with the tabs taking the tab size into account (see [method get_tab_size]).
*/
func (self Instance) GetIndentLevel(line int) int { //gd:TextEdit.get_indent_level
	return int(int(Advanced(self).GetIndentLevel(int64(line))))
}

/*
Returns the first column containing a non-whitespace character on the given line. If there is only whitespace, returns the number of characters.
*/
func (self Instance) GetFirstNonWhitespaceColumn(line int) int { //gd:TextEdit.get_first_non_whitespace_column
	return int(int(Advanced(self).GetFirstNonWhitespaceColumn(int64(line))))
}

/*
Swaps the two lines. Carets will be swapped with the lines.
*/
func (self Instance) SwapLines(from_line int, to_line int) { //gd:TextEdit.swap_lines
	Advanced(self).SwapLines(int64(from_line), int64(to_line))
}

/*
Inserts a new line with [param text] at [param line].
*/
func (self Instance) InsertLineAt(line int, text string) { //gd:TextEdit.insert_line_at
	Advanced(self).InsertLineAt(int64(line), String.New(text))
}

/*
Removes the line of text at [param line]. Carets on this line will attempt to match their previous visual x position.
If [param move_carets_down] is [code]true[/code] carets will move to the next line down, otherwise carets will move up.
*/
func (self Instance) RemoveLineAt(line int) { //gd:TextEdit.remove_line_at
	Advanced(self).RemoveLineAt(int64(line), true)
}

/*
Removes the line of text at [param line]. Carets on this line will attempt to match their previous visual x position.
If [param move_carets_down] is [code]true[/code] carets will move to the next line down, otherwise carets will move up.
*/
func (self Expanded) RemoveLineAt(line int, move_carets_down bool) { //gd:TextEdit.remove_line_at
	Advanced(self).RemoveLineAt(int64(line), move_carets_down)
}

/*
Insert the specified text at the caret position.
*/
func (self Instance) InsertTextAtCaret(text string) { //gd:TextEdit.insert_text_at_caret
	Advanced(self).InsertTextAtCaret(String.New(text), int64(-1))
}

/*
Insert the specified text at the caret position.
*/
func (self Expanded) InsertTextAtCaret(text string, caret_index int) { //gd:TextEdit.insert_text_at_caret
	Advanced(self).InsertTextAtCaret(String.New(text), int64(caret_index))
}

/*
Inserts the [param text] at [param line] and [param column].
If [param before_selection_begin] is [code]true[/code], carets and selections that begin at [param line] and [param column] will moved to the end of the inserted text, along with all carets after it.
If [param before_selection_end] is [code]true[/code], selections that end at [param line] and [param column] will be extended to the end of the inserted text. These parameters can be used to insert text inside of or outside of selections.
*/
func (self Instance) InsertText(text string, line int, column int) { //gd:TextEdit.insert_text
	Advanced(self).InsertText(String.New(text), int64(line), int64(column), true, false)
}

/*
Inserts the [param text] at [param line] and [param column].
If [param before_selection_begin] is [code]true[/code], carets and selections that begin at [param line] and [param column] will moved to the end of the inserted text, along with all carets after it.
If [param before_selection_end] is [code]true[/code], selections that end at [param line] and [param column] will be extended to the end of the inserted text. These parameters can be used to insert text inside of or outside of selections.
*/
func (self Expanded) InsertText(text string, line int, column int, before_selection_begin bool, before_selection_end bool) { //gd:TextEdit.insert_text
	Advanced(self).InsertText(String.New(text), int64(line), int64(column), before_selection_begin, before_selection_end)
}

/*
Removes text between the given positions.
*/
func (self Instance) RemoveText(from_line int, from_column int, to_line int, to_column int) { //gd:TextEdit.remove_text
	Advanced(self).RemoveText(int64(from_line), int64(from_column), int64(to_line), int64(to_column))
}

/*
Returns the last unhidden line in the entire [TextEdit].
*/
func (self Instance) GetLastUnhiddenLine() int { //gd:TextEdit.get_last_unhidden_line
	return int(int(Advanced(self).GetLastUnhiddenLine()))
}

/*
Returns the count to the next visible line from [param line] to [code]line + visible_amount[/code]. Can also count backwards. For example if a [TextEdit] has 5 lines with lines 2 and 3 hidden, calling this with [code]line = 1, visible_amount = 1[/code] would return 3.
*/
func (self Instance) GetNextVisibleLineOffsetFrom(line int, visible_amount int) int { //gd:TextEdit.get_next_visible_line_offset_from
	return int(int(Advanced(self).GetNextVisibleLineOffsetFrom(int64(line), int64(visible_amount))))
}

/*
Similar to [method get_next_visible_line_offset_from], but takes into account the line wrap indexes. In the returned vector, [code]x[/code] is the line, [code]y[/code] is the wrap index.
*/
func (self Instance) GetNextVisibleLineIndexOffsetFrom(line int, wrap_index int, visible_amount int) Vector2i.XY { //gd:TextEdit.get_next_visible_line_index_offset_from
	return Vector2i.XY(Advanced(self).GetNextVisibleLineIndexOffsetFrom(int64(line), int64(wrap_index), int64(visible_amount)))
}

/*
Called when the user presses the backspace key. Can be overridden with [method _backspace].
*/
func (self Instance) Backspace() { //gd:TextEdit.backspace
	Advanced(self).Backspace(int64(-1))
}

/*
Called when the user presses the backspace key. Can be overridden with [method _backspace].
*/
func (self Expanded) Backspace(caret_index int) { //gd:TextEdit.backspace
	Advanced(self).Backspace(int64(caret_index))
}

/*
Cut's the current selection. Can be overridden with [method _cut].
*/
func (self Instance) Cut() { //gd:TextEdit.cut
	Advanced(self).Cut(int64(-1))
}

/*
Cut's the current selection. Can be overridden with [method _cut].
*/
func (self Expanded) Cut(caret_index int) { //gd:TextEdit.cut
	Advanced(self).Cut(int64(caret_index))
}

/*
Copies the current text selection. Can be overridden with [method _copy].
*/
func (self Instance) Copy() { //gd:TextEdit.copy
	Advanced(self).Copy(int64(-1))
}

/*
Copies the current text selection. Can be overridden with [method _copy].
*/
func (self Expanded) Copy(caret_index int) { //gd:TextEdit.copy
	Advanced(self).Copy(int64(caret_index))
}

/*
Paste at the current location. Can be overridden with [method _paste].
*/
func (self Instance) Paste() { //gd:TextEdit.paste
	Advanced(self).Paste(int64(-1))
}

/*
Paste at the current location. Can be overridden with [method _paste].
*/
func (self Expanded) Paste(caret_index int) { //gd:TextEdit.paste
	Advanced(self).Paste(int64(caret_index))
}

/*
Pastes the primary clipboard.
*/
func (self Instance) PastePrimaryClipboard() { //gd:TextEdit.paste_primary_clipboard
	Advanced(self).PastePrimaryClipboard(int64(-1))
}

/*
Pastes the primary clipboard.
*/
func (self Expanded) PastePrimaryClipboard(caret_index int) { //gd:TextEdit.paste_primary_clipboard
	Advanced(self).PastePrimaryClipboard(int64(caret_index))
}

/*
Starts an action, will end the current action if [param action] is different.
An action will also end after a call to [method end_action], after [member ProjectSettings.gui/timers/text_edit_idle_detect_sec] is triggered or a new undoable step outside the [method start_action] and [method end_action] calls.
*/
func (self Instance) StartAction(action EditAction) { //gd:TextEdit.start_action
	Advanced(self).StartAction(action)
}

/*
Marks the end of steps in the current action started with [method start_action].
*/
func (self Instance) EndAction() { //gd:TextEdit.end_action
	Advanced(self).EndAction()
}

/*
Starts a multipart edit. All edits will be treated as one action until [method end_complex_operation] is called.
*/
func (self Instance) BeginComplexOperation() { //gd:TextEdit.begin_complex_operation
	Advanced(self).BeginComplexOperation()
}

/*
Ends a multipart edit, started with [method begin_complex_operation]. If called outside a complex operation, the current operation is pushed onto the undo/redo stack.
*/
func (self Instance) EndComplexOperation() { //gd:TextEdit.end_complex_operation
	Advanced(self).EndComplexOperation()
}

/*
Returns [code]true[/code] if an "undo" action is available.
*/
func (self Instance) HasUndo() bool { //gd:TextEdit.has_undo
	return bool(Advanced(self).HasUndo())
}

/*
Returns [code]true[/code] if a "redo" action is available.
*/
func (self Instance) HasRedo() bool { //gd:TextEdit.has_redo
	return bool(Advanced(self).HasRedo())
}

/*
Perform undo operation.
*/
func (self Instance) Undo() { //gd:TextEdit.undo
	Advanced(self).Undo()
}

/*
Perform redo operation.
*/
func (self Instance) Redo() { //gd:TextEdit.redo
	Advanced(self).Redo()
}

/*
Clears the undo history.
*/
func (self Instance) ClearUndoHistory() { //gd:TextEdit.clear_undo_history
	Advanced(self).ClearUndoHistory()
}

/*
Tag the current version as saved.
*/
func (self Instance) TagSavedVersion() { //gd:TextEdit.tag_saved_version
	Advanced(self).TagSavedVersion()
}

/*
Returns the current version of the [TextEdit]. The version is a count of recorded operations by the undo/redo history.
*/
func (self Instance) GetVersion() int { //gd:TextEdit.get_version
	return int(int(Advanced(self).GetVersion()))
}

/*
Returns the last tagged saved version from [method tag_saved_version].
*/
func (self Instance) GetSavedVersion() int { //gd:TextEdit.get_saved_version
	return int(int(Advanced(self).GetSavedVersion()))
}

/*
Sets the search text. See [method set_search_flags].
*/
func (self Instance) SetSearchText(search_text string) { //gd:TextEdit.set_search_text
	Advanced(self).SetSearchText(String.New(search_text))
}

/*
Sets the search [param flags]. This is used with [method set_search_text] to highlight occurrences of the searched text. Search flags can be specified from the [enum SearchFlags] enum.
*/
func (self Instance) SetSearchFlags(flags int) { //gd:TextEdit.set_search_flags
	Advanced(self).SetSearchFlags(int64(flags))
}

/*
Perform a search inside the text. Search flags can be specified in the [enum SearchFlags] enum.
In the returned vector, [code]x[/code] is the column, [code]y[/code] is the line. If no results are found, both are equal to [code]-1[/code].
[codeblocks]
[gdscript]
var result = search("print", SEARCH_WHOLE_WORDS, 0, 0)
if result.x != -1:

	# Result found.
	var line_number = result.y
	var column_number = result.x

[/gdscript]
[csharp]
Vector2I result = Search("print", (uint)TextEdit.SearchFlags.WholeWords, 0, 0);
if (result.X != -1)

	{
	    // Result found.
	    int lineNumber = result.Y;
	    int columnNumber = result.X;
	}

[/csharp]
[/codeblocks]
*/
func (self Instance) Search(text string, flags int, from_line int, from_column int) Vector2i.XY { //gd:TextEdit.search
	return Vector2i.XY(Advanced(self).Search(String.New(text), int64(flags), int64(from_line), int64(from_column)))
}

/*
Provide custom tooltip text. The callback method must take the following args: [code]hovered_word: String[/code].
*/
func (self Instance) SetTooltipRequestFunc(callback func(hovered_word string) string) { //gd:TextEdit.set_tooltip_request_func
	Advanced(self).SetTooltipRequestFunc(Callable.New(callback))
}

/*
Returns the local mouse position adjusted for the text direction.
*/
func (self Instance) GetLocalMousePos() Vector2.XY { //gd:TextEdit.get_local_mouse_pos
	return Vector2.XY(Advanced(self).GetLocalMousePos())
}

/*
Returns the word at [param position].
*/
func (self Instance) GetWordAtPos(position Vector2.XY) string { //gd:TextEdit.get_word_at_pos
	return string(Advanced(self).GetWordAtPos(Vector2.XY(position)).String())
}

/*
Returns the line and column at the given position. In the returned vector, [code]x[/code] is the column and [code]y[/code] is the line.
If [param clamp_line] is [code]false[/code] and [param position] is below the last line, [code]Vector2i(-1, -1)[/code] is returned.
If [param clamp_column] is [code]false[/code] and [param position] is outside the column range of the line, [code]Vector2i(-1, -1)[/code] is returned.
*/
func (self Instance) GetLineColumnAtPos(position Vector2i.XY) Vector2i.XY { //gd:TextEdit.get_line_column_at_pos
	return Vector2i.XY(Advanced(self).GetLineColumnAtPos(Vector2i.XY(position), true, true))
}

/*
Returns the line and column at the given position. In the returned vector, [code]x[/code] is the column and [code]y[/code] is the line.
If [param clamp_line] is [code]false[/code] and [param position] is below the last line, [code]Vector2i(-1, -1)[/code] is returned.
If [param clamp_column] is [code]false[/code] and [param position] is outside the column range of the line, [code]Vector2i(-1, -1)[/code] is returned.
*/
func (self Expanded) GetLineColumnAtPos(position Vector2i.XY, clamp_line bool, clamp_column bool) Vector2i.XY { //gd:TextEdit.get_line_column_at_pos
	return Vector2i.XY(Advanced(self).GetLineColumnAtPos(Vector2i.XY(position), clamp_line, clamp_column))
}

/*
Returns the local position for the given [param line] and [param column]. If [code]x[/code] or [code]y[/code] of the returned vector equal [code]-1[/code], the position is outside of the viewable area of the control.
[b]Note:[/b] The Y position corresponds to the bottom side of the line. Use [method get_rect_at_line_column] to get the top side position.
*/
func (self Instance) GetPosAtLineColumn(line int, column int) Vector2i.XY { //gd:TextEdit.get_pos_at_line_column
	return Vector2i.XY(Advanced(self).GetPosAtLineColumn(int64(line), int64(column)))
}

/*
Returns the local position and size for the grapheme at the given [param line] and [param column]. If [code]x[/code] or [code]y[/code] position of the returned rect equal [code]-1[/code], the position is outside of the viewable area of the control.
[b]Note:[/b] The Y position of the returned rect corresponds to the top side of the line, unlike [method get_pos_at_line_column] which returns the bottom side.
*/
func (self Instance) GetRectAtLineColumn(line int, column int) Rect2i.PositionSize { //gd:TextEdit.get_rect_at_line_column
	return Rect2i.PositionSize(Advanced(self).GetRectAtLineColumn(int64(line), int64(column)))
}

/*
Returns the equivalent minimap line at [param position].
*/
func (self Instance) GetMinimapLineAtPos(position Vector2i.XY) int { //gd:TextEdit.get_minimap_line_at_pos
	return int(int(Advanced(self).GetMinimapLineAtPos(Vector2i.XY(position))))
}

/*
Returns [code]true[/code] if the user is dragging their mouse for scrolling, selecting, or text dragging.
*/
func (self Instance) IsDraggingCursor() bool { //gd:TextEdit.is_dragging_cursor
	return bool(Advanced(self).IsDraggingCursor())
}

/*
Returns [code]true[/code] if the mouse is over a selection. If [param edges] is [code]true[/code], the edges are considered part of the selection.
*/
func (self Instance) IsMouseOverSelection(edges bool) bool { //gd:TextEdit.is_mouse_over_selection
	return bool(Advanced(self).IsMouseOverSelection(edges, int64(-1)))
}

/*
Returns [code]true[/code] if the mouse is over a selection. If [param edges] is [code]true[/code], the edges are considered part of the selection.
*/
func (self Expanded) IsMouseOverSelection(edges bool, caret_index int) bool { //gd:TextEdit.is_mouse_over_selection
	return bool(Advanced(self).IsMouseOverSelection(edges, int64(caret_index)))
}

/*
Adds a new caret at the given location. Returns the index of the new caret, or [code]-1[/code] if the location is invalid.
*/
func (self Instance) AddCaret(line int, column int) int { //gd:TextEdit.add_caret
	return int(int(Advanced(self).AddCaret(int64(line), int64(column))))
}

/*
Removes the given caret index.
[b]Note:[/b] This can result in adjustment of all other caret indices.
*/
func (self Instance) RemoveCaret(caret int) { //gd:TextEdit.remove_caret
	Advanced(self).RemoveCaret(int64(caret))
}

/*
Removes all additional carets.
*/
func (self Instance) RemoveSecondaryCarets() { //gd:TextEdit.remove_secondary_carets
	Advanced(self).RemoveSecondaryCarets()
}

/*
Returns the number of carets in this [TextEdit].
*/
func (self Instance) GetCaretCount() int { //gd:TextEdit.get_caret_count
	return int(int(Advanced(self).GetCaretCount()))
}

/*
Adds an additional caret above or below every caret. If [param below] is [code]true[/code] the new caret will be added below and above otherwise.
*/
func (self Instance) AddCaretAtCarets(below bool) { //gd:TextEdit.add_caret_at_carets
	Advanced(self).AddCaretAtCarets(below)
}

/*
Returns the carets sorted by selection beginning from lowest line and column to highest (from top to bottom of text).
If [param include_ignored_carets] is [code]false[/code], carets from [method multicaret_edit_ignore_caret] will be ignored.
*/
func (self Instance) GetSortedCarets() []int32 { //gd:TextEdit.get_sorted_carets
	return []int32(slices.Collect(Advanced(self).GetSortedCarets(false).Values()))
}

/*
Returns the carets sorted by selection beginning from lowest line and column to highest (from top to bottom of text).
If [param include_ignored_carets] is [code]false[/code], carets from [method multicaret_edit_ignore_caret] will be ignored.
*/
func (self Expanded) GetSortedCarets(include_ignored_carets bool) []int32 { //gd:TextEdit.get_sorted_carets
	return []int32(slices.Collect(Advanced(self).GetSortedCarets(include_ignored_carets).Values()))
}

/*
Collapse all carets in the given range to the [param from_line] and [param from_column] position.
[param inclusive] applies to both ends.
If [method is_in_mulitcaret_edit] is [code]true[/code], carets that are collapsed will be [code]true[/code] for [method multicaret_edit_ignore_caret].
[method merge_overlapping_carets] will be called if any carets were collapsed.
*/
func (self Instance) CollapseCarets(from_line int, from_column int, to_line int, to_column int) { //gd:TextEdit.collapse_carets
	Advanced(self).CollapseCarets(int64(from_line), int64(from_column), int64(to_line), int64(to_column), false)
}

/*
Collapse all carets in the given range to the [param from_line] and [param from_column] position.
[param inclusive] applies to both ends.
If [method is_in_mulitcaret_edit] is [code]true[/code], carets that are collapsed will be [code]true[/code] for [method multicaret_edit_ignore_caret].
[method merge_overlapping_carets] will be called if any carets were collapsed.
*/
func (self Expanded) CollapseCarets(from_line int, from_column int, to_line int, to_column int, inclusive bool) { //gd:TextEdit.collapse_carets
	Advanced(self).CollapseCarets(int64(from_line), int64(from_column), int64(to_line), int64(to_column), inclusive)
}

/*
Merges any overlapping carets. Will favor the newest caret, or the caret with a selection.
If [method is_in_mulitcaret_edit] is [code]true[/code], the merge will be queued to happen at the end of the multicaret edit. See [method begin_multicaret_edit] and [method end_multicaret_edit].
[b]Note:[/b] This is not called when a caret changes position but after certain actions, so it is possible to get into a state where carets overlap.
*/
func (self Instance) MergeOverlappingCarets() { //gd:TextEdit.merge_overlapping_carets
	Advanced(self).MergeOverlappingCarets()
}

/*
Starts an edit for multiple carets. The edit must be ended with [method end_multicaret_edit]. Multicaret edits can be used to edit text at multiple carets and delay merging the carets until the end, so the caret indexes aren't affected immediately. [method begin_multicaret_edit] and [method end_multicaret_edit] can be nested, and the merge will happen at the last [method end_multicaret_edit].
[codeblock]
begin_complex_operation()
begin_multicaret_edit()
for i in range(get_caret_count()):

	if multicaret_edit_ignore_caret(i):
	    continue
	# Logic here.

end_multicaret_edit()
end_complex_operation()
[/codeblock]
*/
func (self Instance) BeginMulticaretEdit() { //gd:TextEdit.begin_multicaret_edit
	Advanced(self).BeginMulticaretEdit()
}

/*
Ends an edit for multiple carets, that was started with [method begin_multicaret_edit]. If this was the last [method end_multicaret_edit] and [method merge_overlapping_carets] was called, carets will be merged.
*/
func (self Instance) EndMulticaretEdit() { //gd:TextEdit.end_multicaret_edit
	Advanced(self).EndMulticaretEdit()
}

/*
Returns [code]true[/code] if a [method begin_multicaret_edit] has been called and [method end_multicaret_edit] has not yet been called.
*/
func (self Instance) IsInMulitcaretEdit() bool { //gd:TextEdit.is_in_mulitcaret_edit
	return bool(Advanced(self).IsInMulitcaretEdit())
}

/*
Returns [code]true[/code] if the given [param caret_index] should be ignored as part of a multicaret edit. See [method begin_multicaret_edit] and [method end_multicaret_edit]. Carets that should be ignored are ones that were part of removed text and will likely be merged at the end of the edit, or carets that were added during the edit.
It is recommended to [code]continue[/code] within a loop iterating on multiple carets if a caret should be ignored.
*/
func (self Instance) MulticaretEditIgnoreCaret(caret_index int) bool { //gd:TextEdit.multicaret_edit_ignore_caret
	return bool(Advanced(self).MulticaretEditIgnoreCaret(int64(caret_index)))
}

/*
Returns [code]true[/code] if the caret is visible, [code]false[/code] otherwise. A caret will be considered hidden if it is outside the scrollable area when scrolling is enabled.
[b]Note:[/b] [method is_caret_visible] does not account for a caret being off-screen if it is still within the scrollable area. It will return [code]true[/code] even if the caret is off-screen as long as it meets [TextEdit]'s own conditions for being visible. This includes uses of [member scroll_fit_content_width] and [member scroll_fit_content_height] that cause the [TextEdit] to expand beyond the viewport's bounds.
*/
func (self Instance) IsCaretVisible() bool { //gd:TextEdit.is_caret_visible
	return bool(Advanced(self).IsCaretVisible(int64(0)))
}

/*
Returns [code]true[/code] if the caret is visible, [code]false[/code] otherwise. A caret will be considered hidden if it is outside the scrollable area when scrolling is enabled.
[b]Note:[/b] [method is_caret_visible] does not account for a caret being off-screen if it is still within the scrollable area. It will return [code]true[/code] even if the caret is off-screen as long as it meets [TextEdit]'s own conditions for being visible. This includes uses of [member scroll_fit_content_width] and [member scroll_fit_content_height] that cause the [TextEdit] to expand beyond the viewport's bounds.
*/
func (self Expanded) IsCaretVisible(caret_index int) bool { //gd:TextEdit.is_caret_visible
	return bool(Advanced(self).IsCaretVisible(int64(caret_index)))
}

/*
Returns the caret pixel draw position.
*/
func (self Instance) GetCaretDrawPos() Vector2.XY { //gd:TextEdit.get_caret_draw_pos
	return Vector2.XY(Advanced(self).GetCaretDrawPos(int64(0)))
}

/*
Returns the caret pixel draw position.
*/
func (self Expanded) GetCaretDrawPos(caret_index int) Vector2.XY { //gd:TextEdit.get_caret_draw_pos
	return Vector2.XY(Advanced(self).GetCaretDrawPos(int64(caret_index)))
}

/*
Moves the caret to the specified [param line] index. The caret column will be moved to the same visual position it was at the last time [method set_caret_column] was called, or clamped to the end of the line.
If [param adjust_viewport] is [code]true[/code], the viewport will center at the caret position after the move occurs.
If [param can_be_hidden] is [code]true[/code], the specified [param line] can be hidden.
If [param wrap_index] is [code]-1[/code], the caret column will be clamped to the [param line]'s length. If [param wrap_index] is greater than [code]-1[/code], the column will be moved to attempt to match the visual x position on the line's [param wrap_index] to the position from the last time [method set_caret_column] was called.
[b]Note:[/b] If supporting multiple carets this will not check for any overlap. See [method merge_overlapping_carets].
*/
func (self Instance) SetCaretLine(line int) { //gd:TextEdit.set_caret_line
	Advanced(self).SetCaretLine(int64(line), true, true, int64(0), int64(0))
}

/*
Moves the caret to the specified [param line] index. The caret column will be moved to the same visual position it was at the last time [method set_caret_column] was called, or clamped to the end of the line.
If [param adjust_viewport] is [code]true[/code], the viewport will center at the caret position after the move occurs.
If [param can_be_hidden] is [code]true[/code], the specified [param line] can be hidden.
If [param wrap_index] is [code]-1[/code], the caret column will be clamped to the [param line]'s length. If [param wrap_index] is greater than [code]-1[/code], the column will be moved to attempt to match the visual x position on the line's [param wrap_index] to the position from the last time [method set_caret_column] was called.
[b]Note:[/b] If supporting multiple carets this will not check for any overlap. See [method merge_overlapping_carets].
*/
func (self Expanded) SetCaretLine(line int, adjust_viewport bool, can_be_hidden bool, wrap_index int, caret_index int) { //gd:TextEdit.set_caret_line
	Advanced(self).SetCaretLine(int64(line), adjust_viewport, can_be_hidden, int64(wrap_index), int64(caret_index))
}

/*
Returns the line the editing caret is on.
*/
func (self Instance) GetCaretLine() int { //gd:TextEdit.get_caret_line
	return int(int(Advanced(self).GetCaretLine(int64(0))))
}

/*
Returns the line the editing caret is on.
*/
func (self Expanded) GetCaretLine(caret_index int) int { //gd:TextEdit.get_caret_line
	return int(int(Advanced(self).GetCaretLine(int64(caret_index))))
}

/*
Moves the caret to the specified [param column] index.
If [param adjust_viewport] is [code]true[/code], the viewport will center at the caret position after the move occurs.
[b]Note:[/b] If supporting multiple carets this will not check for any overlap. See [method merge_overlapping_carets].
*/
func (self Instance) SetCaretColumn(column int) { //gd:TextEdit.set_caret_column
	Advanced(self).SetCaretColumn(int64(column), true, int64(0))
}

/*
Moves the caret to the specified [param column] index.
If [param adjust_viewport] is [code]true[/code], the viewport will center at the caret position after the move occurs.
[b]Note:[/b] If supporting multiple carets this will not check for any overlap. See [method merge_overlapping_carets].
*/
func (self Expanded) SetCaretColumn(column int, adjust_viewport bool, caret_index int) { //gd:TextEdit.set_caret_column
	Advanced(self).SetCaretColumn(int64(column), adjust_viewport, int64(caret_index))
}

/*
Returns the column the editing caret is at.
*/
func (self Instance) GetCaretColumn() int { //gd:TextEdit.get_caret_column
	return int(int(Advanced(self).GetCaretColumn(int64(0))))
}

/*
Returns the column the editing caret is at.
*/
func (self Expanded) GetCaretColumn(caret_index int) int { //gd:TextEdit.get_caret_column
	return int(int(Advanced(self).GetCaretColumn(int64(caret_index))))
}

/*
Returns the wrap index the editing caret is on.
*/
func (self Instance) GetCaretWrapIndex() int { //gd:TextEdit.get_caret_wrap_index
	return int(int(Advanced(self).GetCaretWrapIndex(int64(0))))
}

/*
Returns the wrap index the editing caret is on.
*/
func (self Expanded) GetCaretWrapIndex(caret_index int) int { //gd:TextEdit.get_caret_wrap_index
	return int(int(Advanced(self).GetCaretWrapIndex(int64(caret_index))))
}

/*
Returns a [String] text with the word under the caret's location.
*/
func (self Instance) GetWordUnderCaret() string { //gd:TextEdit.get_word_under_caret
	return string(Advanced(self).GetWordUnderCaret(int64(-1)).String())
}

/*
Returns a [String] text with the word under the caret's location.
*/
func (self Expanded) GetWordUnderCaret(caret_index int) string { //gd:TextEdit.get_word_under_caret
	return string(Advanced(self).GetWordUnderCaret(int64(caret_index)).String())
}

/*
Sets the current selection mode.
*/
func (self Instance) SetSelectionMode(mode SelectionMode) { //gd:TextEdit.set_selection_mode
	Advanced(self).SetSelectionMode(mode)
}

/*
Returns the current selection mode.
*/
func (self Instance) GetSelectionMode() SelectionMode { //gd:TextEdit.get_selection_mode
	return SelectionMode(Advanced(self).GetSelectionMode())
}

/*
Select all the text.
If [member selecting_enabled] is [code]false[/code], no selection will occur.
*/
func (self Instance) SelectAll() { //gd:TextEdit.select_all
	Advanced(self).SelectAll()
}

/*
Selects the word under the caret.
*/
func (self Instance) SelectWordUnderCaret() { //gd:TextEdit.select_word_under_caret
	Advanced(self).SelectWordUnderCaret(int64(-1))
}

/*
Selects the word under the caret.
*/
func (self Expanded) SelectWordUnderCaret(caret_index int) { //gd:TextEdit.select_word_under_caret
	Advanced(self).SelectWordUnderCaret(int64(caret_index))
}

/*
Adds a selection and a caret for the next occurrence of the current selection. If there is no active selection, selects word under caret.
*/
func (self Instance) AddSelectionForNextOccurrence() { //gd:TextEdit.add_selection_for_next_occurrence
	Advanced(self).AddSelectionForNextOccurrence()
}

/*
Moves a selection and a caret for the next occurrence of the current selection. If there is no active selection, moves to the next occurrence of the word under caret.
*/
func (self Instance) SkipSelectionForNextOccurrence() { //gd:TextEdit.skip_selection_for_next_occurrence
	Advanced(self).SkipSelectionForNextOccurrence()
}

/*
Selects text from [param origin_line] and [param origin_column] to [param caret_line] and [param caret_column] for the given [param caret_index]. This moves the selection origin and the caret. If the positions are the same, the selection will be deselected.
If [member selecting_enabled] is [code]false[/code], no selection will occur.
[b]Note:[/b] If supporting multiple carets this will not check for any overlap. See [method merge_overlapping_carets].
*/
func (self Instance) Select(origin_line int, origin_column int, caret_line int, caret_column int) { //gd:TextEdit.select
	Advanced(self).Select(int64(origin_line), int64(origin_column), int64(caret_line), int64(caret_column), int64(0))
}

/*
Selects text from [param origin_line] and [param origin_column] to [param caret_line] and [param caret_column] for the given [param caret_index]. This moves the selection origin and the caret. If the positions are the same, the selection will be deselected.
If [member selecting_enabled] is [code]false[/code], no selection will occur.
[b]Note:[/b] If supporting multiple carets this will not check for any overlap. See [method merge_overlapping_carets].
*/
func (self Expanded) Select(origin_line int, origin_column int, caret_line int, caret_column int, caret_index int) { //gd:TextEdit.select
	Advanced(self).Select(int64(origin_line), int64(origin_column), int64(caret_line), int64(caret_column), int64(caret_index))
}

/*
Returns [code]true[/code] if the user has selected text.
*/
func (self Instance) HasSelection() bool { //gd:TextEdit.has_selection
	return bool(Advanced(self).HasSelection(int64(-1)))
}

/*
Returns [code]true[/code] if the user has selected text.
*/
func (self Expanded) HasSelection(caret_index int) bool { //gd:TextEdit.has_selection
	return bool(Advanced(self).HasSelection(int64(caret_index)))
}

/*
Returns the text inside the selection of a caret, or all the carets if [param caret_index] is its default value [code]-1[/code].
*/
func (self Instance) GetSelectedText() string { //gd:TextEdit.get_selected_text
	return string(Advanced(self).GetSelectedText(int64(-1)).String())
}

/*
Returns the text inside the selection of a caret, or all the carets if [param caret_index] is its default value [code]-1[/code].
*/
func (self Expanded) GetSelectedText(caret_index int) string { //gd:TextEdit.get_selected_text
	return string(Advanced(self).GetSelectedText(int64(caret_index)).String())
}

/*
Returns the caret index of the selection at the given [param line] and [param column], or [code]-1[/code] if there is none.
If [param include_edges] is [code]false[/code], the position must be inside the selection and not at either end. If [param only_selections] is [code]false[/code], carets without a selection will also be considered.
*/
func (self Instance) GetSelectionAtLineColumn(line int, column int) int { //gd:TextEdit.get_selection_at_line_column
	return int(int(Advanced(self).GetSelectionAtLineColumn(int64(line), int64(column), true, true)))
}

/*
Returns the caret index of the selection at the given [param line] and [param column], or [code]-1[/code] if there is none.
If [param include_edges] is [code]false[/code], the position must be inside the selection and not at either end. If [param only_selections] is [code]false[/code], carets without a selection will also be considered.
*/
func (self Expanded) GetSelectionAtLineColumn(line int, column int, include_edges bool, only_selections bool) int { //gd:TextEdit.get_selection_at_line_column
	return int(int(Advanced(self).GetSelectionAtLineColumn(int64(line), int64(column), include_edges, only_selections)))
}

/*
Returns an [Array] of line ranges where [code]x[/code] is the first line and [code]y[/code] is the last line. All lines within these ranges will have a caret on them or be part of a selection. Each line will only be part of one line range, even if it has multiple carets on it.
If a selection's end column ([method get_selection_to_column]) is at column [code]0[/code], that line will not be included. If a selection begins on the line after another selection ends and [param merge_adjacent] is [code]true[/code], or they begin and end on the same line, one line range will include both selections.
*/
func (self Instance) GetLineRangesFromCarets() []Vector2i.XY { //gd:TextEdit.get_line_ranges_from_carets
	return []Vector2i.XY(gd.ArrayAs[[]Vector2i.XY](gd.InternalArray(Advanced(self).GetLineRangesFromCarets(false, true))))
}

/*
Returns an [Array] of line ranges where [code]x[/code] is the first line and [code]y[/code] is the last line. All lines within these ranges will have a caret on them or be part of a selection. Each line will only be part of one line range, even if it has multiple carets on it.
If a selection's end column ([method get_selection_to_column]) is at column [code]0[/code], that line will not be included. If a selection begins on the line after another selection ends and [param merge_adjacent] is [code]true[/code], or they begin and end on the same line, one line range will include both selections.
*/
func (self Expanded) GetLineRangesFromCarets(only_selections bool, merge_adjacent bool) []Vector2i.XY { //gd:TextEdit.get_line_ranges_from_carets
	return []Vector2i.XY(gd.ArrayAs[[]Vector2i.XY](gd.InternalArray(Advanced(self).GetLineRangesFromCarets(only_selections, merge_adjacent))))
}

/*
Returns the origin line of the selection. This is the opposite end from the caret.
*/
func (self Instance) GetSelectionOriginLine() int { //gd:TextEdit.get_selection_origin_line
	return int(int(Advanced(self).GetSelectionOriginLine(int64(0))))
}

/*
Returns the origin line of the selection. This is the opposite end from the caret.
*/
func (self Expanded) GetSelectionOriginLine(caret_index int) int { //gd:TextEdit.get_selection_origin_line
	return int(int(Advanced(self).GetSelectionOriginLine(int64(caret_index))))
}

/*
Returns the origin column of the selection. This is the opposite end from the caret.
*/
func (self Instance) GetSelectionOriginColumn() int { //gd:TextEdit.get_selection_origin_column
	return int(int(Advanced(self).GetSelectionOriginColumn(int64(0))))
}

/*
Returns the origin column of the selection. This is the opposite end from the caret.
*/
func (self Expanded) GetSelectionOriginColumn(caret_index int) int { //gd:TextEdit.get_selection_origin_column
	return int(int(Advanced(self).GetSelectionOriginColumn(int64(caret_index))))
}

/*
Sets the selection origin line to the [param line] for the given [param caret_index]. If the selection origin is moved to the caret position, the selection will deselect.
If [param can_be_hidden] is [code]false[/code], The line will be set to the nearest unhidden line below or above.
If [param wrap_index] is [code]-1[/code], the selection origin column will be clamped to the [param line]'s length. If [param wrap_index] is greater than [code]-1[/code], the column will be moved to attempt to match the visual x position on the line's [param wrap_index] to the position from the last time [method set_selection_origin_column] or [method select] was called.
*/
func (self Instance) SetSelectionOriginLine(line int) { //gd:TextEdit.set_selection_origin_line
	Advanced(self).SetSelectionOriginLine(int64(line), true, int64(-1), int64(0))
}

/*
Sets the selection origin line to the [param line] for the given [param caret_index]. If the selection origin is moved to the caret position, the selection will deselect.
If [param can_be_hidden] is [code]false[/code], The line will be set to the nearest unhidden line below or above.
If [param wrap_index] is [code]-1[/code], the selection origin column will be clamped to the [param line]'s length. If [param wrap_index] is greater than [code]-1[/code], the column will be moved to attempt to match the visual x position on the line's [param wrap_index] to the position from the last time [method set_selection_origin_column] or [method select] was called.
*/
func (self Expanded) SetSelectionOriginLine(line int, can_be_hidden bool, wrap_index int, caret_index int) { //gd:TextEdit.set_selection_origin_line
	Advanced(self).SetSelectionOriginLine(int64(line), can_be_hidden, int64(wrap_index), int64(caret_index))
}

/*
Sets the selection origin column to the [param column] for the given [param caret_index]. If the selection origin is moved to the caret position, the selection will deselect.
*/
func (self Instance) SetSelectionOriginColumn(column int) { //gd:TextEdit.set_selection_origin_column
	Advanced(self).SetSelectionOriginColumn(int64(column), int64(0))
}

/*
Sets the selection origin column to the [param column] for the given [param caret_index]. If the selection origin is moved to the caret position, the selection will deselect.
*/
func (self Expanded) SetSelectionOriginColumn(column int, caret_index int) { //gd:TextEdit.set_selection_origin_column
	Advanced(self).SetSelectionOriginColumn(int64(column), int64(caret_index))
}

/*
Returns the selection begin line. Returns the caret line if there is no selection.
*/
func (self Instance) GetSelectionFromLine() int { //gd:TextEdit.get_selection_from_line
	return int(int(Advanced(self).GetSelectionFromLine(int64(0))))
}

/*
Returns the selection begin line. Returns the caret line if there is no selection.
*/
func (self Expanded) GetSelectionFromLine(caret_index int) int { //gd:TextEdit.get_selection_from_line
	return int(int(Advanced(self).GetSelectionFromLine(int64(caret_index))))
}

/*
Returns the selection begin column. Returns the caret column if there is no selection.
*/
func (self Instance) GetSelectionFromColumn() int { //gd:TextEdit.get_selection_from_column
	return int(int(Advanced(self).GetSelectionFromColumn(int64(0))))
}

/*
Returns the selection begin column. Returns the caret column if there is no selection.
*/
func (self Expanded) GetSelectionFromColumn(caret_index int) int { //gd:TextEdit.get_selection_from_column
	return int(int(Advanced(self).GetSelectionFromColumn(int64(caret_index))))
}

/*
Returns the selection end line. Returns the caret line if there is no selection.
*/
func (self Instance) GetSelectionToLine() int { //gd:TextEdit.get_selection_to_line
	return int(int(Advanced(self).GetSelectionToLine(int64(0))))
}

/*
Returns the selection end line. Returns the caret line if there is no selection.
*/
func (self Expanded) GetSelectionToLine(caret_index int) int { //gd:TextEdit.get_selection_to_line
	return int(int(Advanced(self).GetSelectionToLine(int64(caret_index))))
}

/*
Returns the selection end column. Returns the caret column if there is no selection.
*/
func (self Instance) GetSelectionToColumn() int { //gd:TextEdit.get_selection_to_column
	return int(int(Advanced(self).GetSelectionToColumn(int64(0))))
}

/*
Returns the selection end column. Returns the caret column if there is no selection.
*/
func (self Expanded) GetSelectionToColumn(caret_index int) int { //gd:TextEdit.get_selection_to_column
	return int(int(Advanced(self).GetSelectionToColumn(int64(caret_index))))
}

/*
Returns [code]true[/code] if the caret of the selection is after the selection origin. This can be used to determine the direction of the selection.
*/
func (self Instance) IsCaretAfterSelectionOrigin() bool { //gd:TextEdit.is_caret_after_selection_origin
	return bool(Advanced(self).IsCaretAfterSelectionOrigin(int64(0)))
}

/*
Returns [code]true[/code] if the caret of the selection is after the selection origin. This can be used to determine the direction of the selection.
*/
func (self Expanded) IsCaretAfterSelectionOrigin(caret_index int) bool { //gd:TextEdit.is_caret_after_selection_origin
	return bool(Advanced(self).IsCaretAfterSelectionOrigin(int64(caret_index)))
}

/*
Deselects the current selection.
*/
func (self Instance) Deselect() { //gd:TextEdit.deselect
	Advanced(self).Deselect(int64(-1))
}

/*
Deselects the current selection.
*/
func (self Expanded) Deselect(caret_index int) { //gd:TextEdit.deselect
	Advanced(self).Deselect(int64(caret_index))
}

/*
Deletes the selected text.
*/
func (self Instance) DeleteSelection() { //gd:TextEdit.delete_selection
	Advanced(self).DeleteSelection(int64(-1))
}

/*
Deletes the selected text.
*/
func (self Expanded) DeleteSelection(caret_index int) { //gd:TextEdit.delete_selection
	Advanced(self).DeleteSelection(int64(caret_index))
}

/*
Returns if the given line is wrapped.
*/
func (self Instance) IsLineWrapped(line int) bool { //gd:TextEdit.is_line_wrapped
	return bool(Advanced(self).IsLineWrapped(int64(line)))
}

/*
Returns the number of times the given line is wrapped.
*/
func (self Instance) GetLineWrapCount(line int) int { //gd:TextEdit.get_line_wrap_count
	return int(int(Advanced(self).GetLineWrapCount(int64(line))))
}

/*
Returns the wrap index of the given column on the given line. This ranges from [code]0[/code] to [method get_line_wrap_count].
*/
func (self Instance) GetLineWrapIndexAtColumn(line int, column int) int { //gd:TextEdit.get_line_wrap_index_at_column
	return int(int(Advanced(self).GetLineWrapIndexAtColumn(int64(line), int64(column))))
}

/*
Returns an array of [String]s representing each wrapped index.
*/
func (self Instance) GetLineWrappedText(line int) []string { //gd:TextEdit.get_line_wrapped_text
	return []string(Advanced(self).GetLineWrappedText(int64(line)).Strings())
}

/*
Returns the [VScrollBar] of the [TextEdit].
*/
func (self Instance) GetVScrollBar() VScrollBar.Instance { //gd:TextEdit.get_v_scroll_bar
	return VScrollBar.Instance(Advanced(self).GetVScrollBar())
}

/*
Returns the [HScrollBar] used by [TextEdit].
*/
func (self Instance) GetHScrollBar() HScrollBar.Instance { //gd:TextEdit.get_h_scroll_bar
	return HScrollBar.Instance(Advanced(self).GetHScrollBar())
}

/*
Returns the scroll position for [param wrap_index] of [param line].
*/
func (self Instance) GetScrollPosForLine(line int) Float.X { //gd:TextEdit.get_scroll_pos_for_line
	return Float.X(Float.X(Advanced(self).GetScrollPosForLine(int64(line), int64(0))))
}

/*
Returns the scroll position for [param wrap_index] of [param line].
*/
func (self Expanded) GetScrollPosForLine(line int, wrap_index int) Float.X { //gd:TextEdit.get_scroll_pos_for_line
	return Float.X(Float.X(Advanced(self).GetScrollPosForLine(int64(line), int64(wrap_index))))
}

/*
Positions the [param wrap_index] of [param line] at the top of the viewport.
*/
func (self Instance) SetLineAsFirstVisible(line int) { //gd:TextEdit.set_line_as_first_visible
	Advanced(self).SetLineAsFirstVisible(int64(line), int64(0))
}

/*
Positions the [param wrap_index] of [param line] at the top of the viewport.
*/
func (self Expanded) SetLineAsFirstVisible(line int, wrap_index int) { //gd:TextEdit.set_line_as_first_visible
	Advanced(self).SetLineAsFirstVisible(int64(line), int64(wrap_index))
}

/*
Returns the first visible line.
*/
func (self Instance) GetFirstVisibleLine() int { //gd:TextEdit.get_first_visible_line
	return int(int(Advanced(self).GetFirstVisibleLine()))
}

/*
Positions the [param wrap_index] of [param line] at the center of the viewport.
*/
func (self Instance) SetLineAsCenterVisible(line int) { //gd:TextEdit.set_line_as_center_visible
	Advanced(self).SetLineAsCenterVisible(int64(line), int64(0))
}

/*
Positions the [param wrap_index] of [param line] at the center of the viewport.
*/
func (self Expanded) SetLineAsCenterVisible(line int, wrap_index int) { //gd:TextEdit.set_line_as_center_visible
	Advanced(self).SetLineAsCenterVisible(int64(line), int64(wrap_index))
}

/*
Positions the [param wrap_index] of [param line] at the bottom of the viewport.
*/
func (self Instance) SetLineAsLastVisible(line int) { //gd:TextEdit.set_line_as_last_visible
	Advanced(self).SetLineAsLastVisible(int64(line), int64(0))
}

/*
Positions the [param wrap_index] of [param line] at the bottom of the viewport.
*/
func (self Expanded) SetLineAsLastVisible(line int, wrap_index int) { //gd:TextEdit.set_line_as_last_visible
	Advanced(self).SetLineAsLastVisible(int64(line), int64(wrap_index))
}

/*
Returns the last visible line. Use [method get_last_full_visible_line_wrap_index] for the wrap index.
*/
func (self Instance) GetLastFullVisibleLine() int { //gd:TextEdit.get_last_full_visible_line
	return int(int(Advanced(self).GetLastFullVisibleLine()))
}

/*
Returns the last visible wrap index of the last visible line.
*/
func (self Instance) GetLastFullVisibleLineWrapIndex() int { //gd:TextEdit.get_last_full_visible_line_wrap_index
	return int(int(Advanced(self).GetLastFullVisibleLineWrapIndex()))
}

/*
Returns the number of lines that can visually fit, rounded down, based on this control's height.
*/
func (self Instance) GetVisibleLineCount() int { //gd:TextEdit.get_visible_line_count
	return int(int(Advanced(self).GetVisibleLineCount()))
}

/*
Returns the total number of lines between [param from_line] and [param to_line] (inclusive) in the text. This includes wrapped lines and excludes folded lines. If the range covers all lines it is equivalent to [method get_total_visible_line_count].
*/
func (self Instance) GetVisibleLineCountInRange(from_line int, to_line int) int { //gd:TextEdit.get_visible_line_count_in_range
	return int(int(Advanced(self).GetVisibleLineCountInRange(int64(from_line), int64(to_line))))
}

/*
Returns the total number of lines in the text. This includes wrapped lines and excludes folded lines. If [member wrap_mode] is set to [constant LINE_WRAPPING_NONE] and no lines are folded (see [method CodeEdit.is_line_folded]) then this is equivalent to [method get_line_count]. See [method get_visible_line_count_in_range] for a limited range of lines.
*/
func (self Instance) GetTotalVisibleLineCount() int { //gd:TextEdit.get_total_visible_line_count
	return int(int(Advanced(self).GetTotalVisibleLineCount()))
}

/*
Adjust the viewport so the caret is visible.
*/
func (self Instance) AdjustViewportToCaret() { //gd:TextEdit.adjust_viewport_to_caret
	Advanced(self).AdjustViewportToCaret(int64(0))
}

/*
Adjust the viewport so the caret is visible.
*/
func (self Expanded) AdjustViewportToCaret(caret_index int) { //gd:TextEdit.adjust_viewport_to_caret
	Advanced(self).AdjustViewportToCaret(int64(caret_index))
}

/*
Centers the viewport on the line the editing caret is at. This also resets the [member scroll_horizontal] value to [code]0[/code].
*/
func (self Instance) CenterViewportToCaret() { //gd:TextEdit.center_viewport_to_caret
	Advanced(self).CenterViewportToCaret(int64(0))
}

/*
Centers the viewport on the line the editing caret is at. This also resets the [member scroll_horizontal] value to [code]0[/code].
*/
func (self Expanded) CenterViewportToCaret(caret_index int) { //gd:TextEdit.center_viewport_to_caret
	Advanced(self).CenterViewportToCaret(int64(caret_index))
}

/*
Returns the number of lines that may be drawn on the minimap.
*/
func (self Instance) GetMinimapVisibleLines() int { //gd:TextEdit.get_minimap_visible_lines
	return int(int(Advanced(self).GetMinimapVisibleLines()))
}

/*
Register a new gutter to this [TextEdit]. Use [param at] to have a specific gutter order. A value of [code]-1[/code] appends the gutter to the right.
*/
func (self Instance) AddGutter() { //gd:TextEdit.add_gutter
	Advanced(self).AddGutter(int64(-1))
}

/*
Register a new gutter to this [TextEdit]. Use [param at] to have a specific gutter order. A value of [code]-1[/code] appends the gutter to the right.
*/
func (self Expanded) AddGutter(at int) { //gd:TextEdit.add_gutter
	Advanced(self).AddGutter(int64(at))
}

/*
Removes the gutter at the given index.
*/
func (self Instance) RemoveGutter(gutter int) { //gd:TextEdit.remove_gutter
	Advanced(self).RemoveGutter(int64(gutter))
}

/*
Returns the number of gutters registered.
*/
func (self Instance) GetGutterCount() int { //gd:TextEdit.get_gutter_count
	return int(int(Advanced(self).GetGutterCount()))
}

/*
Sets the name of the gutter at the given index.
*/
func (self Instance) SetGutterName(gutter int, name string) { //gd:TextEdit.set_gutter_name
	Advanced(self).SetGutterName(int64(gutter), String.New(name))
}

/*
Returns the name of the gutter at the given index.
*/
func (self Instance) GetGutterName(gutter int) string { //gd:TextEdit.get_gutter_name
	return string(Advanced(self).GetGutterName(int64(gutter)).String())
}

/*
Sets the type of gutter at the given index. Gutters can contain icons, text, or custom visuals. See [enum TextEdit.GutterType] for options.
*/
func (self Instance) SetGutterType(gutter int, atype GutterType) { //gd:TextEdit.set_gutter_type
	Advanced(self).SetGutterType(int64(gutter), atype)
}

/*
Returns the type of the gutter at the given index. Gutters can contain icons, text, or custom visuals. See [enum TextEdit.GutterType] for options.
*/
func (self Instance) GetGutterType(gutter int) GutterType { //gd:TextEdit.get_gutter_type
	return GutterType(Advanced(self).GetGutterType(int64(gutter)))
}

/*
Set the width of the gutter at the given index.
*/
func (self Instance) SetGutterWidth(gutter int, width int) { //gd:TextEdit.set_gutter_width
	Advanced(self).SetGutterWidth(int64(gutter), int64(width))
}

/*
Returns the width of the gutter at the given index.
*/
func (self Instance) GetGutterWidth(gutter int) int { //gd:TextEdit.get_gutter_width
	return int(int(Advanced(self).GetGutterWidth(int64(gutter))))
}

/*
If [code]true[/code], the gutter at the given index is drawn. The gutter type ([method set_gutter_type]) determines how it is drawn. See [method is_gutter_drawn].
*/
func (self Instance) SetGutterDraw(gutter int, draw bool) { //gd:TextEdit.set_gutter_draw
	Advanced(self).SetGutterDraw(int64(gutter), draw)
}

/*
Returns [code]true[/code] if the gutter at the given index is currently drawn. See [method set_gutter_draw].
*/
func (self Instance) IsGutterDrawn(gutter int) bool { //gd:TextEdit.is_gutter_drawn
	return bool(Advanced(self).IsGutterDrawn(int64(gutter)))
}

/*
If [code]true[/code], the mouse cursor will change to a pointing hand ([constant Control.CURSOR_POINTING_HAND]) when hovering over the gutter at the given index. See [method is_gutter_clickable] and [method set_line_gutter_clickable].
*/
func (self Instance) SetGutterClickable(gutter int, clickable bool) { //gd:TextEdit.set_gutter_clickable
	Advanced(self).SetGutterClickable(int64(gutter), clickable)
}

/*
Returns [code]true[/code] if the gutter at the given index is clickable. See [method set_gutter_clickable].
*/
func (self Instance) IsGutterClickable(gutter int) bool { //gd:TextEdit.is_gutter_clickable
	return bool(Advanced(self).IsGutterClickable(int64(gutter)))
}

/*
If [code]true[/code], the line data of the gutter at the given index can be overridden when using [method merge_gutters]. See [method is_gutter_overwritable].
*/
func (self Instance) SetGutterOverwritable(gutter int, overwritable bool) { //gd:TextEdit.set_gutter_overwritable
	Advanced(self).SetGutterOverwritable(int64(gutter), overwritable)
}

/*
Returns [code]true[/code] if the gutter at the given index is overwritable. See [method set_gutter_overwritable].
*/
func (self Instance) IsGutterOverwritable(gutter int) bool { //gd:TextEdit.is_gutter_overwritable
	return bool(Advanced(self).IsGutterOverwritable(int64(gutter)))
}

/*
Merge the gutters from [param from_line] into [param to_line]. Only overwritable gutters will be copied. See [method set_gutter_overwritable].
*/
func (self Instance) MergeGutters(from_line int, to_line int) { //gd:TextEdit.merge_gutters
	Advanced(self).MergeGutters(int64(from_line), int64(to_line))
}

/*
Set a custom draw callback for the gutter at the given index. [param draw_callback] must take the following arguments: A line index [int], a gutter index [int], and an area [Rect2]. This callback only works when the gutter type is [constant GUTTER_TYPE_CUSTOM] (see [method set_gutter_type]).
*/
func (self Instance) SetGutterCustomDraw(column int, draw_callback func(line int, gutter int, area Rect2.PositionSize)) { //gd:TextEdit.set_gutter_custom_draw
	Advanced(self).SetGutterCustomDraw(int64(column), Callable.New(draw_callback))
}

/*
Returns the total width of all gutters and internal padding.
*/
func (self Instance) GetTotalGutterWidth() int { //gd:TextEdit.get_total_gutter_width
	return int(int(Advanced(self).GetTotalGutterWidth()))
}

/*
Sets the metadata for [param gutter] on [param line] to [param metadata].
*/
func (self Instance) SetLineGutterMetadata(line int, gutter int, metadata any) { //gd:TextEdit.set_line_gutter_metadata
	Advanced(self).SetLineGutterMetadata(int64(line), int64(gutter), variant.New(metadata))
}

/*
Returns the metadata currently in [param gutter] at [param line].
*/
func (self Instance) GetLineGutterMetadata(line int, gutter int) any { //gd:TextEdit.get_line_gutter_metadata
	return any(Advanced(self).GetLineGutterMetadata(int64(line), int64(gutter)).Interface())
}

/*
Sets the text for [param gutter] on [param line] to [param text]. This only works when the gutter type is [constant GUTTER_TYPE_STRING] (see [method set_gutter_type]).
*/
func (self Instance) SetLineGutterText(line int, gutter int, text string) { //gd:TextEdit.set_line_gutter_text
	Advanced(self).SetLineGutterText(int64(line), int64(gutter), String.New(text))
}

/*
Returns the text currently in [param gutter] at [param line]. This only works when the gutter type is [constant GUTTER_TYPE_STRING] (see [method set_gutter_type]).
*/
func (self Instance) GetLineGutterText(line int, gutter int) string { //gd:TextEdit.get_line_gutter_text
	return string(Advanced(self).GetLineGutterText(int64(line), int64(gutter)).String())
}

/*
Sets the icon for [param gutter] on [param line] to [param icon]. This only works when the gutter type is [constant GUTTER_TYPE_ICON] (see [method set_gutter_type]).
*/
func (self Instance) SetLineGutterIcon(line int, gutter int, icon Texture2D.Instance) { //gd:TextEdit.set_line_gutter_icon
	Advanced(self).SetLineGutterIcon(int64(line), int64(gutter), icon)
}

/*
Returns the icon currently in [param gutter] at [param line]. This only works when the gutter type is [constant GUTTER_TYPE_ICON] (see [method set_gutter_type]).
*/
func (self Instance) GetLineGutterIcon(line int, gutter int) Texture2D.Instance { //gd:TextEdit.get_line_gutter_icon
	return Texture2D.Instance(Advanced(self).GetLineGutterIcon(int64(line), int64(gutter)))
}

/*
Sets the color for [param gutter] on [param line] to [param color].
*/
func (self Instance) SetLineGutterItemColor(line int, gutter int, color Color.RGBA) { //gd:TextEdit.set_line_gutter_item_color
	Advanced(self).SetLineGutterItemColor(int64(line), int64(gutter), Color.RGBA(color))
}

/*
Returns the color currently in [param gutter] at [param line].
*/
func (self Instance) GetLineGutterItemColor(line int, gutter int) Color.RGBA { //gd:TextEdit.get_line_gutter_item_color
	return Color.RGBA(Advanced(self).GetLineGutterItemColor(int64(line), int64(gutter)))
}

/*
If [param clickable] is [code]true[/code], makes the [param gutter] on the given [param line] clickable. This is like [method set_gutter_clickable], but for a single line. If [method is_gutter_clickable] is [code]true[/code], this will not have any effect. See [method is_line_gutter_clickable] and [signal gutter_clicked].
*/
func (self Instance) SetLineGutterClickable(line int, gutter int, clickable bool) { //gd:TextEdit.set_line_gutter_clickable
	Advanced(self).SetLineGutterClickable(int64(line), int64(gutter), clickable)
}

/*
Returns [code]true[/code] if the gutter at the given index on the given line is clickable. See [method set_line_gutter_clickable].
*/
func (self Instance) IsLineGutterClickable(line int, gutter int) bool { //gd:TextEdit.is_line_gutter_clickable
	return bool(Advanced(self).IsLineGutterClickable(int64(line), int64(gutter)))
}

/*
Sets the custom background color of the given line. If transparent, this color is applied on top of the default background color (See [theme_item background_color]). If set to [code]Color(0, 0, 0, 0)[/code], no additional color is applied.
*/
func (self Instance) SetLineBackgroundColor(line int, color Color.RGBA) { //gd:TextEdit.set_line_background_color
	Advanced(self).SetLineBackgroundColor(int64(line), Color.RGBA(color))
}

/*
Returns the custom background color of the given line. If no color is set, returns [code]Color(0, 0, 0, 0)[/code].
*/
func (self Instance) GetLineBackgroundColor(line int) Color.RGBA { //gd:TextEdit.get_line_background_color
	return Color.RGBA(Advanced(self).GetLineBackgroundColor(int64(line)))
}

/*
Returns the [PopupMenu] of this [TextEdit]. By default, this menu is displayed when right-clicking on the [TextEdit].
You can add custom menu items or remove standard ones. Make sure your IDs don't conflict with the standard ones (see [enum MenuItems]). For example:
[codeblocks]
[gdscript]
func _ready():

	var menu = get_menu()
	# Remove all items after "Redo".
	menu.item_count = menu.get_item_index(MENU_REDO) + 1
	# Add custom items.
	menu.add_separator()
	menu.add_item("Insert Date", MENU_MAX + 1)
	# Connect callback.
	menu.id_pressed.connect(_on_item_pressed)

func _on_item_pressed(id):

	if id == MENU_MAX + 1:
	    insert_text_at_caret(Time.get_date_string_from_system())

[/gdscript]
[csharp]
public override void _Ready()

	{
	    var menu = GetMenu();
	    // Remove all items after "Redo".
	    menu.ItemCount = menu.GetItemIndex(TextEdit.MenuItems.Redo) + 1;
	    // Add custom items.
	    menu.AddSeparator();
	    menu.AddItem("Insert Date", TextEdit.MenuItems.Max + 1);
	    // Add event handler.
	    menu.IdPressed += OnItemPressed;
	}

public void OnItemPressed(int id)

	{
	    if (id == TextEdit.MenuItems.Max + 1)
	    {
	        InsertTextAtCaret(Time.GetDateStringFromSystem());
	    }
	}

[/csharp]
[/codeblocks]
[b]Warning:[/b] This is a required internal node, removing and freeing it may cause a crash. If you wish to hide it or any of its children, use their [member Window.visible] property.
*/
func (self Instance) GetMenu() PopupMenu.Instance { //gd:TextEdit.get_menu
	return PopupMenu.Instance(Advanced(self).GetMenu())
}

/*
Returns [code]true[/code] if the menu is visible. Use this instead of [code]get_menu().visible[/code] to improve performance (so the creation of the menu is avoided). See [method get_menu].
*/
func (self Instance) IsMenuVisible() bool { //gd:TextEdit.is_menu_visible
	return bool(Advanced(self).IsMenuVisible())
}

/*
Executes a given action as defined in the [enum MenuItems] enum.
*/
func (self Instance) MenuOption(option int) { //gd:TextEdit.menu_option
	Advanced(self).MenuOption(int64(option))
}

/*
This method does nothing.
*/
func (self Instance) AdjustCaretsAfterEdit(caret int, from_line int, from_col int, to_line int, to_col int) { //gd:TextEdit.adjust_carets_after_edit
	Advanced(self).AdjustCaretsAfterEdit(int64(caret), int64(from_line), int64(from_col), int64(to_line), int64(to_col))
}

/*
Returns a list of caret indexes in their edit order, this done from bottom to top. Edit order refers to the way actions such as [method insert_text_at_caret] are applied.
*/
func (self Instance) GetCaretIndexEditOrder() []int32 { //gd:TextEdit.get_caret_index_edit_order
	return []int32(slices.Collect(Advanced(self).GetCaretIndexEditOrder().Values()))
}

/*
Returns the original start line of the selection.
*/
func (self Instance) GetSelectionLine() int { //gd:TextEdit.get_selection_line
	return int(int(Advanced(self).GetSelectionLine(int64(0))))
}

/*
Returns the original start line of the selection.
*/
func (self Expanded) GetSelectionLine(caret_index int) int { //gd:TextEdit.get_selection_line
	return int(int(Advanced(self).GetSelectionLine(int64(caret_index))))
}

/*
Returns the original start column of the selection.
*/
func (self Instance) GetSelectionColumn() int { //gd:TextEdit.get_selection_column
	return int(int(Advanced(self).GetSelectionColumn(int64(0))))
}

/*
Returns the original start column of the selection.
*/
func (self Expanded) GetSelectionColumn(caret_index int) int { //gd:TextEdit.get_selection_column
	return int(int(Advanced(self).GetSelectionColumn(int64(caret_index))))
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.TextEdit

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {
	object := gd.Global.ClassDB.ConstructObject(gd.NewStringName("TextEdit"))
	casted := Instance{*(*gdclass.TextEdit)(unsafe.Pointer(&object))}
	return casted
}

func (self Instance) Text() string {
	return string(class(self).GetText().String())
}

func (self Instance) SetText(value string) {
	class(self).SetText(String.New(value))
}

func (self Instance) PlaceholderText() string {
	return string(class(self).GetPlaceholder().String())
}

func (self Instance) SetPlaceholderText(value string) {
	class(self).SetPlaceholder(String.New(value))
}

func (self Instance) Editable() bool {
	return bool(class(self).IsEditable())
}

func (self Instance) SetEditable(value bool) {
	class(self).SetEditable(value)
}

func (self Instance) ContextMenuEnabled() bool {
	return bool(class(self).IsContextMenuEnabled())
}

func (self Instance) SetContextMenuEnabled(value bool) {
	class(self).SetContextMenuEnabled(value)
}

func (self Instance) EmojiMenuEnabled() bool {
	return bool(class(self).IsEmojiMenuEnabled())
}

func (self Instance) SetEmojiMenuEnabled(value bool) {
	class(self).SetEmojiMenuEnabled(value)
}

func (self Instance) ShortcutKeysEnabled() bool {
	return bool(class(self).IsShortcutKeysEnabled())
}

func (self Instance) SetShortcutKeysEnabled(value bool) {
	class(self).SetShortcutKeysEnabled(value)
}

func (self Instance) SelectingEnabled() bool {
	return bool(class(self).IsSelectingEnabled())
}

func (self Instance) SetSelectingEnabled(value bool) {
	class(self).SetSelectingEnabled(value)
}

func (self Instance) DeselectOnFocusLossEnabled() bool {
	return bool(class(self).IsDeselectOnFocusLossEnabled())
}

func (self Instance) SetDeselectOnFocusLossEnabled(value bool) {
	class(self).SetDeselectOnFocusLossEnabled(value)
}

func (self Instance) DragAndDropSelectionEnabled() bool {
	return bool(class(self).IsDragAndDropSelectionEnabled())
}

func (self Instance) SetDragAndDropSelectionEnabled(value bool) {
	class(self).SetDragAndDropSelectionEnabled(value)
}

func (self Instance) VirtualKeyboardEnabled() bool {
	return bool(class(self).IsVirtualKeyboardEnabled())
}

func (self Instance) SetVirtualKeyboardEnabled(value bool) {
	class(self).SetVirtualKeyboardEnabled(value)
}

func (self Instance) MiddleMousePasteEnabled() bool {
	return bool(class(self).IsMiddleMousePasteEnabled())
}

func (self Instance) SetMiddleMousePasteEnabled(value bool) {
	class(self).SetMiddleMousePasteEnabled(value)
}

func (self Instance) EmptySelectionClipboardEnabled() bool {
	return bool(class(self).IsEmptySelectionClipboardEnabled())
}

func (self Instance) SetEmptySelectionClipboardEnabled(value bool) {
	class(self).SetEmptySelectionClipboardEnabled(value)
}

func (self Instance) WrapMode() LineWrappingMode {
	return LineWrappingMode(class(self).GetLineWrappingMode())
}

func (self Instance) SetWrapMode(value LineWrappingMode) {
	class(self).SetLineWrappingMode(value)
}

func (self Instance) AutowrapMode() TextServer.AutowrapMode {
	return TextServer.AutowrapMode(class(self).GetAutowrapMode())
}

func (self Instance) SetAutowrapMode(value TextServer.AutowrapMode) {
	class(self).SetAutowrapMode(value)
}

func (self Instance) IndentWrappedLines() bool {
	return bool(class(self).IsIndentWrappedLines())
}

func (self Instance) SetIndentWrappedLines(value bool) {
	class(self).SetIndentWrappedLines(value)
}

func (self Instance) ScrollSmooth() bool {
	return bool(class(self).IsSmoothScrollEnabled())
}

func (self Instance) SetScrollSmooth(value bool) {
	class(self).SetSmoothScrollEnabled(value)
}

func (self Instance) ScrollVScrollSpeed() Float.X {
	return Float.X(Float.X(class(self).GetVScrollSpeed()))
}

func (self Instance) SetScrollVScrollSpeed(value Float.X) {
	class(self).SetVScrollSpeed(float64(value))
}

func (self Instance) ScrollPastEndOfFile() bool {
	return bool(class(self).IsScrollPastEndOfFileEnabled())
}

func (self Instance) SetScrollPastEndOfFile(value bool) {
	class(self).SetScrollPastEndOfFileEnabled(value)
}

func (self Instance) ScrollVertical() Float.X {
	return Float.X(Float.X(class(self).GetVScroll()))
}

func (self Instance) SetScrollVertical(value Float.X) {
	class(self).SetVScroll(float64(value))
}

func (self Instance) ScrollHorizontal() int {
	return int(int(class(self).GetHScroll()))
}

func (self Instance) SetScrollHorizontal(value int) {
	class(self).SetHScroll(int64(value))
}

func (self Instance) ScrollFitContentHeight() bool {
	return bool(class(self).IsFitContentHeightEnabled())
}

func (self Instance) SetScrollFitContentHeight(value bool) {
	class(self).SetFitContentHeightEnabled(value)
}

func (self Instance) ScrollFitContentWidth() bool {
	return bool(class(self).IsFitContentWidthEnabled())
}

func (self Instance) SetScrollFitContentWidth(value bool) {
	class(self).SetFitContentWidthEnabled(value)
}

func (self Instance) MinimapDraw() bool {
	return bool(class(self).IsDrawingMinimap())
}

func (self Instance) SetMinimapDraw(value bool) {
	class(self).SetDrawMinimap(value)
}

func (self Instance) MinimapWidth() int {
	return int(int(class(self).GetMinimapWidth()))
}

func (self Instance) SetMinimapWidth(value int) {
	class(self).SetMinimapWidth(int64(value))
}

func (self Instance) CaretType() CaretType {
	return CaretType(class(self).GetCaretType())
}

func (self Instance) SetCaretType(value CaretType) {
	class(self).SetCaretType(value)
}

func (self Instance) CaretBlink() bool {
	return bool(class(self).IsCaretBlinkEnabled())
}

func (self Instance) SetCaretBlink(value bool) {
	class(self).SetCaretBlinkEnabled(value)
}

func (self Instance) CaretBlinkInterval() Float.X {
	return Float.X(Float.X(class(self).GetCaretBlinkInterval()))
}

func (self Instance) SetCaretBlinkInterval(value Float.X) {
	class(self).SetCaretBlinkInterval(float64(value))
}

func (self Instance) CaretDrawWhenEditableDisabled() bool {
	return bool(class(self).IsDrawingCaretWhenEditableDisabled())
}

func (self Instance) SetCaretDrawWhenEditableDisabled(value bool) {
	class(self).SetDrawCaretWhenEditableDisabled(value)
}

func (self Instance) CaretMoveOnRightClick() bool {
	return bool(class(self).IsMoveCaretOnRightClickEnabled())
}

func (self Instance) SetCaretMoveOnRightClick(value bool) {
	class(self).SetMoveCaretOnRightClickEnabled(value)
}

func (self Instance) CaretMidGrapheme() bool {
	return bool(class(self).IsCaretMidGraphemeEnabled())
}

func (self Instance) SetCaretMidGrapheme(value bool) {
	class(self).SetCaretMidGraphemeEnabled(value)
}

func (self Instance) CaretMultiple() bool {
	return bool(class(self).IsMultipleCaretsEnabled())
}

func (self Instance) SetCaretMultiple(value bool) {
	class(self).SetMultipleCaretsEnabled(value)
}

func (self Instance) UseDefaultWordSeparators() bool {
	return bool(class(self).IsDefaultWordSeparatorsEnabled())
}

func (self Instance) SetUseDefaultWordSeparators(value bool) {
	class(self).SetUseDefaultWordSeparators(value)
}

func (self Instance) UseCustomWordSeparators() bool {
	return bool(class(self).IsCustomWordSeparatorsEnabled())
}

func (self Instance) SetUseCustomWordSeparators(value bool) {
	class(self).SetUseCustomWordSeparators(value)
}

func (self Instance) CustomWordSeparators() string {
	return string(class(self).GetCustomWordSeparators().String())
}

func (self Instance) SetCustomWordSeparators(value string) {
	class(self).SetCustomWordSeparators(String.New(value))
}

func (self Instance) HighlightAllOccurrences() bool {
	return bool(class(self).IsHighlightAllOccurrencesEnabled())
}

func (self Instance) SetHighlightAllOccurrences(value bool) {
	class(self).SetHighlightAllOccurrences(value)
}

func (self Instance) HighlightCurrentLine() bool {
	return bool(class(self).IsHighlightCurrentLineEnabled())
}

func (self Instance) SetHighlightCurrentLine(value bool) {
	class(self).SetHighlightCurrentLine(value)
}

func (self Instance) DrawControlChars() bool {
	return bool(class(self).GetDrawControlChars())
}

func (self Instance) SetDrawControlChars(value bool) {
	class(self).SetDrawControlChars(value)
}

func (self Instance) DrawTabs() bool {
	return bool(class(self).IsDrawingTabs())
}

func (self Instance) SetDrawTabs(value bool) {
	class(self).SetDrawTabs(value)
}

func (self Instance) DrawSpaces() bool {
	return bool(class(self).IsDrawingSpaces())
}

func (self Instance) SetDrawSpaces(value bool) {
	class(self).SetDrawSpaces(value)
}

func (self Instance) TextDirection() Control.TextDirection {
	return Control.TextDirection(class(self).GetTextDirection())
}

func (self Instance) SetTextDirection(value Control.TextDirection) {
	class(self).SetTextDirection(value)
}

func (self Instance) Language() string {
	return string(class(self).GetLanguage().String())
}

func (self Instance) SetLanguage(value string) {
	class(self).SetLanguage(String.New(value))
}

func (self Instance) StructuredTextBidiOverride() TextServer.StructuredTextParser {
	return TextServer.StructuredTextParser(class(self).GetStructuredTextBidiOverride())
}

func (self Instance) SetStructuredTextBidiOverride(value TextServer.StructuredTextParser) {
	class(self).SetStructuredTextBidiOverride(value)
}

func (self Instance) StructuredTextBidiOverrideOptions() []any {
	return []any(gd.ArrayAs[[]any](gd.InternalArray(class(self).GetStructuredTextBidiOverrideOptions())))
}

func (self Instance) SetStructuredTextBidiOverrideOptions(value []any) {
	class(self).SetStructuredTextBidiOverrideOptions(gd.EngineArrayFromSlice(value))
}

/*
Override this method to define what happens when the user types in the provided key [param unicode_char].
*/
func (class) _handle_unicode_input(impl func(ptr unsafe.Pointer, unicode_char int64, caret_index int64)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var unicode_char = gd.UnsafeGet[int64](p_args, 0)
		var caret_index = gd.UnsafeGet[int64](p_args, 1)
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, unicode_char, caret_index)
	}
}

/*
Override this method to define what happens when the user presses the backspace key.
*/
func (class) _backspace(impl func(ptr unsafe.Pointer, caret_index int64)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var caret_index = gd.UnsafeGet[int64](p_args, 0)
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, caret_index)
	}
}

/*
Override this method to define what happens when the user performs a cut operation.
*/
func (class) _cut(impl func(ptr unsafe.Pointer, caret_index int64)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var caret_index = gd.UnsafeGet[int64](p_args, 0)
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, caret_index)
	}
}

/*
Override this method to define what happens when the user performs a copy operation.
*/
func (class) _copy(impl func(ptr unsafe.Pointer, caret_index int64)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var caret_index = gd.UnsafeGet[int64](p_args, 0)
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, caret_index)
	}
}

/*
Override this method to define what happens when the user performs a paste operation.
*/
func (class) _paste(impl func(ptr unsafe.Pointer, caret_index int64)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var caret_index = gd.UnsafeGet[int64](p_args, 0)
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, caret_index)
	}
}

/*
Override this method to define what happens when the user performs a paste operation with middle mouse button.
[b]Note:[/b] This method is only implemented on Linux.
*/
func (class) _paste_primary_clipboard(impl func(ptr unsafe.Pointer, caret_index int64)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var caret_index = gd.UnsafeGet[int64](p_args, 0)
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, caret_index)
	}
}

/*
Returns [code]true[/code] if the user has text in the [url=https://en.wikipedia.org/wiki/Input_method]Input Method Editor[/url] (IME).
*/
//go:nosplit
func (self class) HasImeText() bool { //gd:TextEdit.has_ime_text
	var r_ret = gdextension.Call[bool](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_has_ime_text), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Closes the [url=https://en.wikipedia.org/wiki/Input_method]Input Method Editor[/url] (IME) if it is open. Any text in the IME will be lost.
*/
//go:nosplit
func (self class) CancelIme() { //gd:TextEdit.cancel_ime
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_cancel_ime), 0, unsafe.Pointer(&struct{}{}))
}

/*
Applies text from the [url=https://en.wikipedia.org/wiki/Input_method]Input Method Editor[/url] (IME) to each caret and closes the IME if it is open.
*/
//go:nosplit
func (self class) ApplyIme() { //gd:TextEdit.apply_ime
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_apply_ime), 0, unsafe.Pointer(&struct{}{}))
}

//go:nosplit
func (self class) SetEditable(enabled bool) { //gd:TextEdit.set_editable
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_editable), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enabled bool }{enabled}))
}

//go:nosplit
func (self class) IsEditable() bool { //gd:TextEdit.is_editable
	var r_ret = gdextension.Call[bool](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_is_editable), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetTextDirection(direction Control.TextDirection) { //gd:TextEdit.set_text_direction
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_text_direction), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ direction Control.TextDirection }{direction}))
}

//go:nosplit
func (self class) GetTextDirection() Control.TextDirection { //gd:TextEdit.get_text_direction
	var r_ret = gdextension.Call[Control.TextDirection](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_text_direction), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetLanguage(language String.Readable) { //gd:TextEdit.set_language
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_language), 0|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ language gdextension.String }{gdextension.String(pointers.Get(gd.InternalString(language))[0])}))
}

//go:nosplit
func (self class) GetLanguage() String.Readable { //gd:TextEdit.get_language
	var r_ret = gdextension.Call[[1]gd.EnginePointer](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_language), gdextension.SizeString, unsafe.Pointer(&struct{}{}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

//go:nosplit
func (self class) SetStructuredTextBidiOverride(parser TextServer.StructuredTextParser) { //gd:TextEdit.set_structured_text_bidi_override
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_structured_text_bidi_override), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct {
		parser TextServer.StructuredTextParser
	}{parser}))
}

//go:nosplit
func (self class) GetStructuredTextBidiOverride() TextServer.StructuredTextParser { //gd:TextEdit.get_structured_text_bidi_override
	var r_ret = gdextension.Call[TextServer.StructuredTextParser](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_structured_text_bidi_override), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetStructuredTextBidiOverrideOptions(args Array.Any) { //gd:TextEdit.set_structured_text_bidi_override_options
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_structured_text_bidi_override_options), 0|(gdextension.SizeArray<<4), unsafe.Pointer(&struct{ args gdextension.Array }{gdextension.Array(pointers.Get(gd.InternalArray(args))[0])}))
}

//go:nosplit
func (self class) GetStructuredTextBidiOverrideOptions() Array.Any { //gd:TextEdit.get_structured_text_bidi_override_options
	var r_ret = gdextension.Call[[1]gd.EnginePointer](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_structured_text_bidi_override_options), gdextension.SizeArray, unsafe.Pointer(&struct{}{}))
	var ret = Array.Through(gd.ArrayProxy[variant.Any]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

/*
Sets the tab size for the [TextEdit] to use.
*/
//go:nosplit
func (self class) SetTabSize(size int64) { //gd:TextEdit.set_tab_size
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_tab_size), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ size int64 }{size}))
}

/*
Returns the [TextEdit]'s' tab size.
*/
//go:nosplit
func (self class) GetTabSize() int64 { //gd:TextEdit.get_tab_size
	var r_ret = gdextension.Call[int64](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_tab_size), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetIndentWrappedLines(enabled bool) { //gd:TextEdit.set_indent_wrapped_lines
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_indent_wrapped_lines), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enabled bool }{enabled}))
}

//go:nosplit
func (self class) IsIndentWrappedLines() bool { //gd:TextEdit.is_indent_wrapped_lines
	var r_ret = gdextension.Call[bool](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_is_indent_wrapped_lines), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
If [code]true[/code], enables overtype mode. In this mode, typing overrides existing text instead of inserting text. The [member ProjectSettings.input/ui_text_toggle_insert_mode] action toggles overtype mode. See [method is_overtype_mode_enabled].
*/
//go:nosplit
func (self class) SetOvertypeModeEnabled(enabled bool) { //gd:TextEdit.set_overtype_mode_enabled
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_overtype_mode_enabled), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enabled bool }{enabled}))
}

/*
Returns [code]true[/code] if overtype mode is enabled. See [method set_overtype_mode_enabled].
*/
//go:nosplit
func (self class) IsOvertypeModeEnabled() bool { //gd:TextEdit.is_overtype_mode_enabled
	var r_ret = gdextension.Call[bool](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_is_overtype_mode_enabled), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetContextMenuEnabled(enabled bool) { //gd:TextEdit.set_context_menu_enabled
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_context_menu_enabled), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enabled bool }{enabled}))
}

//go:nosplit
func (self class) IsContextMenuEnabled() bool { //gd:TextEdit.is_context_menu_enabled
	var r_ret = gdextension.Call[bool](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_is_context_menu_enabled), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetEmojiMenuEnabled(enable bool) { //gd:TextEdit.set_emoji_menu_enabled
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_emoji_menu_enabled), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

//go:nosplit
func (self class) IsEmojiMenuEnabled() bool { //gd:TextEdit.is_emoji_menu_enabled
	var r_ret = gdextension.Call[bool](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_is_emoji_menu_enabled), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetShortcutKeysEnabled(enabled bool) { //gd:TextEdit.set_shortcut_keys_enabled
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_shortcut_keys_enabled), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enabled bool }{enabled}))
}

//go:nosplit
func (self class) IsShortcutKeysEnabled() bool { //gd:TextEdit.is_shortcut_keys_enabled
	var r_ret = gdextension.Call[bool](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_is_shortcut_keys_enabled), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetVirtualKeyboardEnabled(enabled bool) { //gd:TextEdit.set_virtual_keyboard_enabled
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_virtual_keyboard_enabled), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enabled bool }{enabled}))
}

//go:nosplit
func (self class) IsVirtualKeyboardEnabled() bool { //gd:TextEdit.is_virtual_keyboard_enabled
	var r_ret = gdextension.Call[bool](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_is_virtual_keyboard_enabled), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetMiddleMousePasteEnabled(enabled bool) { //gd:TextEdit.set_middle_mouse_paste_enabled
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_middle_mouse_paste_enabled), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enabled bool }{enabled}))
}

//go:nosplit
func (self class) IsMiddleMousePasteEnabled() bool { //gd:TextEdit.is_middle_mouse_paste_enabled
	var r_ret = gdextension.Call[bool](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_is_middle_mouse_paste_enabled), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetEmptySelectionClipboardEnabled(enabled bool) { //gd:TextEdit.set_empty_selection_clipboard_enabled
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_empty_selection_clipboard_enabled), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enabled bool }{enabled}))
}

//go:nosplit
func (self class) IsEmptySelectionClipboardEnabled() bool { //gd:TextEdit.is_empty_selection_clipboard_enabled
	var r_ret = gdextension.Call[bool](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_is_empty_selection_clipboard_enabled), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Performs a full reset of [TextEdit], including undo history.
*/
//go:nosplit
func (self class) Clear() { //gd:TextEdit.clear
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_clear), 0, unsafe.Pointer(&struct{}{}))
}

//go:nosplit
func (self class) SetText(text String.Readable) { //gd:TextEdit.set_text
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_text), 0|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ text gdextension.String }{gdextension.String(pointers.Get(gd.InternalString(text))[0])}))
}

//go:nosplit
func (self class) GetText() String.Readable { //gd:TextEdit.get_text
	var r_ret = gdextension.Call[[1]gd.EnginePointer](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_text), gdextension.SizeString, unsafe.Pointer(&struct{}{}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Returns the number of lines in the text.
*/
//go:nosplit
func (self class) GetLineCount() int64 { //gd:TextEdit.get_line_count
	var r_ret = gdextension.Call[int64](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_line_count), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetPlaceholder(text String.Readable) { //gd:TextEdit.set_placeholder
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_placeholder), 0|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ text gdextension.String }{gdextension.String(pointers.Get(gd.InternalString(text))[0])}))
}

//go:nosplit
func (self class) GetPlaceholder() String.Readable { //gd:TextEdit.get_placeholder
	var r_ret = gdextension.Call[[1]gd.EnginePointer](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_placeholder), gdextension.SizeString, unsafe.Pointer(&struct{}{}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Sets the text for a specific [param line].
Carets on the line will attempt to keep their visual x position.
*/
//go:nosplit
func (self class) SetLine(line int64, new_text String.Readable) { //gd:TextEdit.set_line
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_line), 0|(gdextension.SizeInt<<4)|(gdextension.SizeString<<8), unsafe.Pointer(&struct {
		line     int64
		new_text gdextension.String
	}{line, gdextension.String(pointers.Get(gd.InternalString(new_text))[0])}))
}

/*
Returns the text of a specific line.
*/
//go:nosplit
func (self class) GetLine(line int64) String.Readable { //gd:TextEdit.get_line
	var r_ret = gdextension.Call[[1]gd.EnginePointer](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_line), gdextension.SizeString|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ line int64 }{line}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Returns line text as it is currently displayed, including IME composition string.
*/
//go:nosplit
func (self class) GetLineWithIme(line int64) String.Readable { //gd:TextEdit.get_line_with_ime
	var r_ret = gdextension.Call[[1]gd.EnginePointer](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_line_with_ime), gdextension.SizeString|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ line int64 }{line}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Returns the width in pixels of the [param wrap_index] on [param line].
*/
//go:nosplit
func (self class) GetLineWidth(line int64, wrap_index int64) int64 { //gd:TextEdit.get_line_width
	var r_ret = gdextension.Call[int64](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_line_width), gdextension.SizeInt|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		line       int64
		wrap_index int64
	}{line, wrap_index}))
	var ret = r_ret
	return ret
}

/*
Returns the maximum value of the line height among all lines.
[b]Note:[/b] The return value is influenced by [theme_item line_spacing] and [theme_item font_size]. And it will not be less than [code]1[/code].
*/
//go:nosplit
func (self class) GetLineHeight() int64 { //gd:TextEdit.get_line_height
	var r_ret = gdextension.Call[int64](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_line_height), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the indent level of the given line. This is the number of spaces and tabs at the beginning of the line, with the tabs taking the tab size into account (see [method get_tab_size]).
*/
//go:nosplit
func (self class) GetIndentLevel(line int64) int64 { //gd:TextEdit.get_indent_level
	var r_ret = gdextension.Call[int64](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_indent_level), gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ line int64 }{line}))
	var ret = r_ret
	return ret
}

/*
Returns the first column containing a non-whitespace character on the given line. If there is only whitespace, returns the number of characters.
*/
//go:nosplit
func (self class) GetFirstNonWhitespaceColumn(line int64) int64 { //gd:TextEdit.get_first_non_whitespace_column
	var r_ret = gdextension.Call[int64](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_first_non_whitespace_column), gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ line int64 }{line}))
	var ret = r_ret
	return ret
}

/*
Swaps the two lines. Carets will be swapped with the lines.
*/
//go:nosplit
func (self class) SwapLines(from_line int64, to_line int64) { //gd:TextEdit.swap_lines
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_swap_lines), 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		from_line int64
		to_line   int64
	}{from_line, to_line}))
}

/*
Inserts a new line with [param text] at [param line].
*/
//go:nosplit
func (self class) InsertLineAt(line int64, text String.Readable) { //gd:TextEdit.insert_line_at
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_insert_line_at), 0|(gdextension.SizeInt<<4)|(gdextension.SizeString<<8), unsafe.Pointer(&struct {
		line int64
		text gdextension.String
	}{line, gdextension.String(pointers.Get(gd.InternalString(text))[0])}))
}

/*
Removes the line of text at [param line]. Carets on this line will attempt to match their previous visual x position.
If [param move_carets_down] is [code]true[/code] carets will move to the next line down, otherwise carets will move up.
*/
//go:nosplit
func (self class) RemoveLineAt(line int64, move_carets_down bool) { //gd:TextEdit.remove_line_at
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_remove_line_at), 0|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		line             int64
		move_carets_down bool
	}{line, move_carets_down}))
}

/*
Insert the specified text at the caret position.
*/
//go:nosplit
func (self class) InsertTextAtCaret(text String.Readable, caret_index int64) { //gd:TextEdit.insert_text_at_caret
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_insert_text_at_caret), 0|(gdextension.SizeString<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		text        gdextension.String
		caret_index int64
	}{gdextension.String(pointers.Get(gd.InternalString(text))[0]), caret_index}))
}

/*
Inserts the [param text] at [param line] and [param column].
If [param before_selection_begin] is [code]true[/code], carets and selections that begin at [param line] and [param column] will moved to the end of the inserted text, along with all carets after it.
If [param before_selection_end] is [code]true[/code], selections that end at [param line] and [param column] will be extended to the end of the inserted text. These parameters can be used to insert text inside of or outside of selections.
*/
//go:nosplit
func (self class) InsertText(text String.Readable, line int64, column int64, before_selection_begin bool, before_selection_end bool) { //gd:TextEdit.insert_text
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_insert_text), 0|(gdextension.SizeString<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeBool<<16)|(gdextension.SizeBool<<20), unsafe.Pointer(&struct {
		text                   gdextension.String
		line                   int64
		column                 int64
		before_selection_begin bool
		before_selection_end   bool
	}{gdextension.String(pointers.Get(gd.InternalString(text))[0]), line, column, before_selection_begin, before_selection_end}))
}

/*
Removes text between the given positions.
*/
//go:nosplit
func (self class) RemoveText(from_line int64, from_column int64, to_line int64, to_column int64) { //gd:TextEdit.remove_text
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_remove_text), 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeInt<<16), unsafe.Pointer(&struct {
		from_line   int64
		from_column int64
		to_line     int64
		to_column   int64
	}{from_line, from_column, to_line, to_column}))
}

/*
Returns the last unhidden line in the entire [TextEdit].
*/
//go:nosplit
func (self class) GetLastUnhiddenLine() int64 { //gd:TextEdit.get_last_unhidden_line
	var r_ret = gdextension.Call[int64](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_last_unhidden_line), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the count to the next visible line from [param line] to [code]line + visible_amount[/code]. Can also count backwards. For example if a [TextEdit] has 5 lines with lines 2 and 3 hidden, calling this with [code]line = 1, visible_amount = 1[/code] would return 3.
*/
//go:nosplit
func (self class) GetNextVisibleLineOffsetFrom(line int64, visible_amount int64) int64 { //gd:TextEdit.get_next_visible_line_offset_from
	var r_ret = gdextension.Call[int64](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_next_visible_line_offset_from), gdextension.SizeInt|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		line           int64
		visible_amount int64
	}{line, visible_amount}))
	var ret = r_ret
	return ret
}

/*
Similar to [method get_next_visible_line_offset_from], but takes into account the line wrap indexes. In the returned vector, [code]x[/code] is the line, [code]y[/code] is the wrap index.
*/
//go:nosplit
func (self class) GetNextVisibleLineIndexOffsetFrom(line int64, wrap_index int64, visible_amount int64) Vector2i.XY { //gd:TextEdit.get_next_visible_line_index_offset_from
	var r_ret = gdextension.Call[Vector2i.XY](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_next_visible_line_index_offset_from), gdextension.SizeVector2i|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		line           int64
		wrap_index     int64
		visible_amount int64
	}{line, wrap_index, visible_amount}))
	var ret = r_ret
	return ret
}

/*
Called when the user presses the backspace key. Can be overridden with [method _backspace].
*/
//go:nosplit
func (self class) Backspace(caret_index int64) { //gd:TextEdit.backspace
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_backspace), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ caret_index int64 }{caret_index}))
}

/*
Cut's the current selection. Can be overridden with [method _cut].
*/
//go:nosplit
func (self class) Cut(caret_index int64) { //gd:TextEdit.cut
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_cut), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ caret_index int64 }{caret_index}))
}

/*
Copies the current text selection. Can be overridden with [method _copy].
*/
//go:nosplit
func (self class) Copy(caret_index int64) { //gd:TextEdit.copy
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_copy), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ caret_index int64 }{caret_index}))
}

/*
Paste at the current location. Can be overridden with [method _paste].
*/
//go:nosplit
func (self class) Paste(caret_index int64) { //gd:TextEdit.paste
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_paste), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ caret_index int64 }{caret_index}))
}

/*
Pastes the primary clipboard.
*/
//go:nosplit
func (self class) PastePrimaryClipboard(caret_index int64) { //gd:TextEdit.paste_primary_clipboard
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_paste_primary_clipboard), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ caret_index int64 }{caret_index}))
}

/*
Starts an action, will end the current action if [param action] is different.
An action will also end after a call to [method end_action], after [member ProjectSettings.gui/timers/text_edit_idle_detect_sec] is triggered or a new undoable step outside the [method start_action] and [method end_action] calls.
*/
//go:nosplit
func (self class) StartAction(action EditAction) { //gd:TextEdit.start_action
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_start_action), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ action EditAction }{action}))
}

/*
Marks the end of steps in the current action started with [method start_action].
*/
//go:nosplit
func (self class) EndAction() { //gd:TextEdit.end_action
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_end_action), 0, unsafe.Pointer(&struct{}{}))
}

/*
Starts a multipart edit. All edits will be treated as one action until [method end_complex_operation] is called.
*/
//go:nosplit
func (self class) BeginComplexOperation() { //gd:TextEdit.begin_complex_operation
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_begin_complex_operation), 0, unsafe.Pointer(&struct{}{}))
}

/*
Ends a multipart edit, started with [method begin_complex_operation]. If called outside a complex operation, the current operation is pushed onto the undo/redo stack.
*/
//go:nosplit
func (self class) EndComplexOperation() { //gd:TextEdit.end_complex_operation
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_end_complex_operation), 0, unsafe.Pointer(&struct{}{}))
}

/*
Returns [code]true[/code] if an "undo" action is available.
*/
//go:nosplit
func (self class) HasUndo() bool { //gd:TextEdit.has_undo
	var r_ret = gdextension.Call[bool](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_has_undo), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if a "redo" action is available.
*/
//go:nosplit
func (self class) HasRedo() bool { //gd:TextEdit.has_redo
	var r_ret = gdextension.Call[bool](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_has_redo), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Perform undo operation.
*/
//go:nosplit
func (self class) Undo() { //gd:TextEdit.undo
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_undo), 0, unsafe.Pointer(&struct{}{}))
}

/*
Perform redo operation.
*/
//go:nosplit
func (self class) Redo() { //gd:TextEdit.redo
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_redo), 0, unsafe.Pointer(&struct{}{}))
}

/*
Clears the undo history.
*/
//go:nosplit
func (self class) ClearUndoHistory() { //gd:TextEdit.clear_undo_history
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_clear_undo_history), 0, unsafe.Pointer(&struct{}{}))
}

/*
Tag the current version as saved.
*/
//go:nosplit
func (self class) TagSavedVersion() { //gd:TextEdit.tag_saved_version
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_tag_saved_version), 0, unsafe.Pointer(&struct{}{}))
}

/*
Returns the current version of the [TextEdit]. The version is a count of recorded operations by the undo/redo history.
*/
//go:nosplit
func (self class) GetVersion() int64 { //gd:TextEdit.get_version
	var r_ret = gdextension.Call[int64](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_version), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the last tagged saved version from [method tag_saved_version].
*/
//go:nosplit
func (self class) GetSavedVersion() int64 { //gd:TextEdit.get_saved_version
	var r_ret = gdextension.Call[int64](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_saved_version), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Sets the search text. See [method set_search_flags].
*/
//go:nosplit
func (self class) SetSearchText(search_text String.Readable) { //gd:TextEdit.set_search_text
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_search_text), 0|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ search_text gdextension.String }{gdextension.String(pointers.Get(gd.InternalString(search_text))[0])}))
}

/*
Sets the search [param flags]. This is used with [method set_search_text] to highlight occurrences of the searched text. Search flags can be specified from the [enum SearchFlags] enum.
*/
//go:nosplit
func (self class) SetSearchFlags(flags int64) { //gd:TextEdit.set_search_flags
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_search_flags), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ flags int64 }{flags}))
}

/*
Perform a search inside the text. Search flags can be specified in the [enum SearchFlags] enum.
In the returned vector, [code]x[/code] is the column, [code]y[/code] is the line. If no results are found, both are equal to [code]-1[/code].
[codeblocks]
[gdscript]
var result = search("print", SEARCH_WHOLE_WORDS, 0, 0)
if result.x != -1:
    # Result found.
    var line_number = result.y
    var column_number = result.x
[/gdscript]
[csharp]
Vector2I result = Search("print", (uint)TextEdit.SearchFlags.WholeWords, 0, 0);
if (result.X != -1)
{
    // Result found.
    int lineNumber = result.Y;
    int columnNumber = result.X;
}
[/csharp]
[/codeblocks]
*/
//go:nosplit
func (self class) Search(text String.Readable, flags int64, from_line int64, from_column int64) Vector2i.XY { //gd:TextEdit.search
	var r_ret = gdextension.Call[Vector2i.XY](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_search), gdextension.SizeVector2i|(gdextension.SizeString<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeInt<<16), unsafe.Pointer(&struct {
		text        gdextension.String
		flags       int64
		from_line   int64
		from_column int64
	}{gdextension.String(pointers.Get(gd.InternalString(text))[0]), flags, from_line, from_column}))
	var ret = r_ret
	return ret
}

/*
Provide custom tooltip text. The callback method must take the following args: [code]hovered_word: String[/code].
*/
//go:nosplit
func (self class) SetTooltipRequestFunc(callback Callable.Function) { //gd:TextEdit.set_tooltip_request_func
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_tooltip_request_func), 0|(gdextension.SizeCallable<<4), unsafe.Pointer(&struct{ callback gdextension.Callable }{gdextension.Callable(pointers.Get(gd.InternalCallable(callback)))}))
}

/*
Returns the local mouse position adjusted for the text direction.
*/
//go:nosplit
func (self class) GetLocalMousePos() Vector2.XY { //gd:TextEdit.get_local_mouse_pos
	var r_ret = gdextension.Call[Vector2.XY](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_local_mouse_pos), gdextension.SizeVector2, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the word at [param position].
*/
//go:nosplit
func (self class) GetWordAtPos(position Vector2.XY) String.Readable { //gd:TextEdit.get_word_at_pos
	var r_ret = gdextension.Call[[1]gd.EnginePointer](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_word_at_pos), gdextension.SizeString|(gdextension.SizeVector2<<4), unsafe.Pointer(&struct{ position Vector2.XY }{position}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Returns the line and column at the given position. In the returned vector, [code]x[/code] is the column and [code]y[/code] is the line.
If [param clamp_line] is [code]false[/code] and [param position] is below the last line, [code]Vector2i(-1, -1)[/code] is returned.
If [param clamp_column] is [code]false[/code] and [param position] is outside the column range of the line, [code]Vector2i(-1, -1)[/code] is returned.
*/
//go:nosplit
func (self class) GetLineColumnAtPos(position Vector2i.XY, clamp_line bool, clamp_column bool) Vector2i.XY { //gd:TextEdit.get_line_column_at_pos
	var r_ret = gdextension.Call[Vector2i.XY](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_line_column_at_pos), gdextension.SizeVector2i|(gdextension.SizeVector2i<<4)|(gdextension.SizeBool<<8)|(gdextension.SizeBool<<12), unsafe.Pointer(&struct {
		position     Vector2i.XY
		clamp_line   bool
		clamp_column bool
	}{position, clamp_line, clamp_column}))
	var ret = r_ret
	return ret
}

/*
Returns the local position for the given [param line] and [param column]. If [code]x[/code] or [code]y[/code] of the returned vector equal [code]-1[/code], the position is outside of the viewable area of the control.
[b]Note:[/b] The Y position corresponds to the bottom side of the line. Use [method get_rect_at_line_column] to get the top side position.
*/
//go:nosplit
func (self class) GetPosAtLineColumn(line int64, column int64) Vector2i.XY { //gd:TextEdit.get_pos_at_line_column
	var r_ret = gdextension.Call[Vector2i.XY](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_pos_at_line_column), gdextension.SizeVector2i|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		line   int64
		column int64
	}{line, column}))
	var ret = r_ret
	return ret
}

/*
Returns the local position and size for the grapheme at the given [param line] and [param column]. If [code]x[/code] or [code]y[/code] position of the returned rect equal [code]-1[/code], the position is outside of the viewable area of the control.
[b]Note:[/b] The Y position of the returned rect corresponds to the top side of the line, unlike [method get_pos_at_line_column] which returns the bottom side.
*/
//go:nosplit
func (self class) GetRectAtLineColumn(line int64, column int64) Rect2i.PositionSize { //gd:TextEdit.get_rect_at_line_column
	var r_ret = gdextension.Call[Rect2i.PositionSize](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_rect_at_line_column), gdextension.SizeRect2i|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		line   int64
		column int64
	}{line, column}))
	var ret = r_ret
	return ret
}

/*
Returns the equivalent minimap line at [param position].
*/
//go:nosplit
func (self class) GetMinimapLineAtPos(position Vector2i.XY) int64 { //gd:TextEdit.get_minimap_line_at_pos
	var r_ret = gdextension.Call[int64](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_minimap_line_at_pos), gdextension.SizeInt|(gdextension.SizeVector2i<<4), unsafe.Pointer(&struct{ position Vector2i.XY }{position}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if the user is dragging their mouse for scrolling, selecting, or text dragging.
*/
//go:nosplit
func (self class) IsDraggingCursor() bool { //gd:TextEdit.is_dragging_cursor
	var r_ret = gdextension.Call[bool](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_is_dragging_cursor), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if the mouse is over a selection. If [param edges] is [code]true[/code], the edges are considered part of the selection.
*/
//go:nosplit
func (self class) IsMouseOverSelection(edges bool, caret_index int64) bool { //gd:TextEdit.is_mouse_over_selection
	var r_ret = gdextension.Call[bool](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_is_mouse_over_selection), gdextension.SizeBool|(gdextension.SizeBool<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		edges       bool
		caret_index int64
	}{edges, caret_index}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetCaretType(atype CaretType) { //gd:TextEdit.set_caret_type
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_caret_type), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ atype CaretType }{atype}))
}

//go:nosplit
func (self class) GetCaretType() CaretType { //gd:TextEdit.get_caret_type
	var r_ret = gdextension.Call[CaretType](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_caret_type), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetCaretBlinkEnabled(enable bool) { //gd:TextEdit.set_caret_blink_enabled
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_caret_blink_enabled), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

//go:nosplit
func (self class) IsCaretBlinkEnabled() bool { //gd:TextEdit.is_caret_blink_enabled
	var r_ret = gdextension.Call[bool](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_is_caret_blink_enabled), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetCaretBlinkInterval(interval float64) { //gd:TextEdit.set_caret_blink_interval
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_caret_blink_interval), 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ interval float64 }{interval}))
}

//go:nosplit
func (self class) GetCaretBlinkInterval() float64 { //gd:TextEdit.get_caret_blink_interval
	var r_ret = gdextension.Call[float64](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_caret_blink_interval), gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetDrawCaretWhenEditableDisabled(enable bool) { //gd:TextEdit.set_draw_caret_when_editable_disabled
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_draw_caret_when_editable_disabled), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

//go:nosplit
func (self class) IsDrawingCaretWhenEditableDisabled() bool { //gd:TextEdit.is_drawing_caret_when_editable_disabled
	var r_ret = gdextension.Call[bool](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_is_drawing_caret_when_editable_disabled), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetMoveCaretOnRightClickEnabled(enable bool) { //gd:TextEdit.set_move_caret_on_right_click_enabled
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_move_caret_on_right_click_enabled), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

//go:nosplit
func (self class) IsMoveCaretOnRightClickEnabled() bool { //gd:TextEdit.is_move_caret_on_right_click_enabled
	var r_ret = gdextension.Call[bool](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_is_move_caret_on_right_click_enabled), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetCaretMidGraphemeEnabled(enabled bool) { //gd:TextEdit.set_caret_mid_grapheme_enabled
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_caret_mid_grapheme_enabled), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enabled bool }{enabled}))
}

//go:nosplit
func (self class) IsCaretMidGraphemeEnabled() bool { //gd:TextEdit.is_caret_mid_grapheme_enabled
	var r_ret = gdextension.Call[bool](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_is_caret_mid_grapheme_enabled), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetMultipleCaretsEnabled(enabled bool) { //gd:TextEdit.set_multiple_carets_enabled
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_multiple_carets_enabled), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enabled bool }{enabled}))
}

//go:nosplit
func (self class) IsMultipleCaretsEnabled() bool { //gd:TextEdit.is_multiple_carets_enabled
	var r_ret = gdextension.Call[bool](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_is_multiple_carets_enabled), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Adds a new caret at the given location. Returns the index of the new caret, or [code]-1[/code] if the location is invalid.
*/
//go:nosplit
func (self class) AddCaret(line int64, column int64) int64 { //gd:TextEdit.add_caret
	var r_ret = gdextension.Call[int64](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_add_caret), gdextension.SizeInt|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		line   int64
		column int64
	}{line, column}))
	var ret = r_ret
	return ret
}

/*
Removes the given caret index.
[b]Note:[/b] This can result in adjustment of all other caret indices.
*/
//go:nosplit
func (self class) RemoveCaret(caret int64) { //gd:TextEdit.remove_caret
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_remove_caret), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ caret int64 }{caret}))
}

/*
Removes all additional carets.
*/
//go:nosplit
func (self class) RemoveSecondaryCarets() { //gd:TextEdit.remove_secondary_carets
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_remove_secondary_carets), 0, unsafe.Pointer(&struct{}{}))
}

/*
Returns the number of carets in this [TextEdit].
*/
//go:nosplit
func (self class) GetCaretCount() int64 { //gd:TextEdit.get_caret_count
	var r_ret = gdextension.Call[int64](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_caret_count), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Adds an additional caret above or below every caret. If [param below] is [code]true[/code] the new caret will be added below and above otherwise.
*/
//go:nosplit
func (self class) AddCaretAtCarets(below bool) { //gd:TextEdit.add_caret_at_carets
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_add_caret_at_carets), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ below bool }{below}))
}

/*
Returns the carets sorted by selection beginning from lowest line and column to highest (from top to bottom of text).
If [param include_ignored_carets] is [code]false[/code], carets from [method multicaret_edit_ignore_caret] will be ignored.
*/
//go:nosplit
func (self class) GetSortedCarets(include_ignored_carets bool) Packed.Array[int32] { //gd:TextEdit.get_sorted_carets
	var r_ret = gdextension.Call[gd.PackedPointers](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_sorted_carets), gdextension.SizePackedArray|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ include_ignored_carets bool }{include_ignored_carets}))
	var ret = Packed.Array[int32](Array.Through(gd.PackedProxy[gd.PackedInt32Array, int32]{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

/*
Collapse all carets in the given range to the [param from_line] and [param from_column] position.
[param inclusive] applies to both ends.
If [method is_in_mulitcaret_edit] is [code]true[/code], carets that are collapsed will be [code]true[/code] for [method multicaret_edit_ignore_caret].
[method merge_overlapping_carets] will be called if any carets were collapsed.
*/
//go:nosplit
func (self class) CollapseCarets(from_line int64, from_column int64, to_line int64, to_column int64, inclusive bool) { //gd:TextEdit.collapse_carets
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_collapse_carets), 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeInt<<16)|(gdextension.SizeBool<<20), unsafe.Pointer(&struct {
		from_line   int64
		from_column int64
		to_line     int64
		to_column   int64
		inclusive   bool
	}{from_line, from_column, to_line, to_column, inclusive}))
}

/*
Merges any overlapping carets. Will favor the newest caret, or the caret with a selection.
If [method is_in_mulitcaret_edit] is [code]true[/code], the merge will be queued to happen at the end of the multicaret edit. See [method begin_multicaret_edit] and [method end_multicaret_edit].
[b]Note:[/b] This is not called when a caret changes position but after certain actions, so it is possible to get into a state where carets overlap.
*/
//go:nosplit
func (self class) MergeOverlappingCarets() { //gd:TextEdit.merge_overlapping_carets
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_merge_overlapping_carets), 0, unsafe.Pointer(&struct{}{}))
}

/*
Starts an edit for multiple carets. The edit must be ended with [method end_multicaret_edit]. Multicaret edits can be used to edit text at multiple carets and delay merging the carets until the end, so the caret indexes aren't affected immediately. [method begin_multicaret_edit] and [method end_multicaret_edit] can be nested, and the merge will happen at the last [method end_multicaret_edit].
[codeblock]
begin_complex_operation()
begin_multicaret_edit()
for i in range(get_caret_count()):
    if multicaret_edit_ignore_caret(i):
        continue
    # Logic here.
end_multicaret_edit()
end_complex_operation()
[/codeblock]
*/
//go:nosplit
func (self class) BeginMulticaretEdit() { //gd:TextEdit.begin_multicaret_edit
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_begin_multicaret_edit), 0, unsafe.Pointer(&struct{}{}))
}

/*
Ends an edit for multiple carets, that was started with [method begin_multicaret_edit]. If this was the last [method end_multicaret_edit] and [method merge_overlapping_carets] was called, carets will be merged.
*/
//go:nosplit
func (self class) EndMulticaretEdit() { //gd:TextEdit.end_multicaret_edit
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_end_multicaret_edit), 0, unsafe.Pointer(&struct{}{}))
}

/*
Returns [code]true[/code] if a [method begin_multicaret_edit] has been called and [method end_multicaret_edit] has not yet been called.
*/
//go:nosplit
func (self class) IsInMulitcaretEdit() bool { //gd:TextEdit.is_in_mulitcaret_edit
	var r_ret = gdextension.Call[bool](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_is_in_mulitcaret_edit), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if the given [param caret_index] should be ignored as part of a multicaret edit. See [method begin_multicaret_edit] and [method end_multicaret_edit]. Carets that should be ignored are ones that were part of removed text and will likely be merged at the end of the edit, or carets that were added during the edit.
It is recommended to [code]continue[/code] within a loop iterating on multiple carets if a caret should be ignored.
*/
//go:nosplit
func (self class) MulticaretEditIgnoreCaret(caret_index int64) bool { //gd:TextEdit.multicaret_edit_ignore_caret
	var r_ret = gdextension.Call[bool](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_multicaret_edit_ignore_caret), gdextension.SizeBool|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ caret_index int64 }{caret_index}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if the caret is visible, [code]false[/code] otherwise. A caret will be considered hidden if it is outside the scrollable area when scrolling is enabled.
[b]Note:[/b] [method is_caret_visible] does not account for a caret being off-screen if it is still within the scrollable area. It will return [code]true[/code] even if the caret is off-screen as long as it meets [TextEdit]'s own conditions for being visible. This includes uses of [member scroll_fit_content_width] and [member scroll_fit_content_height] that cause the [TextEdit] to expand beyond the viewport's bounds.
*/
//go:nosplit
func (self class) IsCaretVisible(caret_index int64) bool { //gd:TextEdit.is_caret_visible
	var r_ret = gdextension.Call[bool](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_is_caret_visible), gdextension.SizeBool|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ caret_index int64 }{caret_index}))
	var ret = r_ret
	return ret
}

/*
Returns the caret pixel draw position.
*/
//go:nosplit
func (self class) GetCaretDrawPos(caret_index int64) Vector2.XY { //gd:TextEdit.get_caret_draw_pos
	var r_ret = gdextension.Call[Vector2.XY](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_caret_draw_pos), gdextension.SizeVector2|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ caret_index int64 }{caret_index}))
	var ret = r_ret
	return ret
}

/*
Moves the caret to the specified [param line] index. The caret column will be moved to the same visual position it was at the last time [method set_caret_column] was called, or clamped to the end of the line.
If [param adjust_viewport] is [code]true[/code], the viewport will center at the caret position after the move occurs.
If [param can_be_hidden] is [code]true[/code], the specified [param line] can be hidden.
If [param wrap_index] is [code]-1[/code], the caret column will be clamped to the [param line]'s length. If [param wrap_index] is greater than [code]-1[/code], the column will be moved to attempt to match the visual x position on the line's [param wrap_index] to the position from the last time [method set_caret_column] was called.
[b]Note:[/b] If supporting multiple carets this will not check for any overlap. See [method merge_overlapping_carets].
*/
//go:nosplit
func (self class) SetCaretLine(line int64, adjust_viewport bool, can_be_hidden bool, wrap_index int64, caret_index int64) { //gd:TextEdit.set_caret_line
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_caret_line), 0|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8)|(gdextension.SizeBool<<12)|(gdextension.SizeInt<<16)|(gdextension.SizeInt<<20), unsafe.Pointer(&struct {
		line            int64
		adjust_viewport bool
		can_be_hidden   bool
		wrap_index      int64
		caret_index     int64
	}{line, adjust_viewport, can_be_hidden, wrap_index, caret_index}))
}

/*
Returns the line the editing caret is on.
*/
//go:nosplit
func (self class) GetCaretLine(caret_index int64) int64 { //gd:TextEdit.get_caret_line
	var r_ret = gdextension.Call[int64](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_caret_line), gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ caret_index int64 }{caret_index}))
	var ret = r_ret
	return ret
}

/*
Moves the caret to the specified [param column] index.
If [param adjust_viewport] is [code]true[/code], the viewport will center at the caret position after the move occurs.
[b]Note:[/b] If supporting multiple carets this will not check for any overlap. See [method merge_overlapping_carets].
*/
//go:nosplit
func (self class) SetCaretColumn(column int64, adjust_viewport bool, caret_index int64) { //gd:TextEdit.set_caret_column
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_caret_column), 0|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		column          int64
		adjust_viewport bool
		caret_index     int64
	}{column, adjust_viewport, caret_index}))
}

/*
Returns the column the editing caret is at.
*/
//go:nosplit
func (self class) GetCaretColumn(caret_index int64) int64 { //gd:TextEdit.get_caret_column
	var r_ret = gdextension.Call[int64](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_caret_column), gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ caret_index int64 }{caret_index}))
	var ret = r_ret
	return ret
}

/*
Returns the wrap index the editing caret is on.
*/
//go:nosplit
func (self class) GetCaretWrapIndex(caret_index int64) int64 { //gd:TextEdit.get_caret_wrap_index
	var r_ret = gdextension.Call[int64](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_caret_wrap_index), gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ caret_index int64 }{caret_index}))
	var ret = r_ret
	return ret
}

/*
Returns a [String] text with the word under the caret's location.
*/
//go:nosplit
func (self class) GetWordUnderCaret(caret_index int64) String.Readable { //gd:TextEdit.get_word_under_caret
	var r_ret = gdextension.Call[[1]gd.EnginePointer](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_word_under_caret), gdextension.SizeString|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ caret_index int64 }{caret_index}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

//go:nosplit
func (self class) SetUseDefaultWordSeparators(enabled bool) { //gd:TextEdit.set_use_default_word_separators
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_use_default_word_separators), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enabled bool }{enabled}))
}

//go:nosplit
func (self class) IsDefaultWordSeparatorsEnabled() bool { //gd:TextEdit.is_default_word_separators_enabled
	var r_ret = gdextension.Call[bool](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_is_default_word_separators_enabled), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetUseCustomWordSeparators(enabled bool) { //gd:TextEdit.set_use_custom_word_separators
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_use_custom_word_separators), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enabled bool }{enabled}))
}

//go:nosplit
func (self class) IsCustomWordSeparatorsEnabled() bool { //gd:TextEdit.is_custom_word_separators_enabled
	var r_ret = gdextension.Call[bool](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_is_custom_word_separators_enabled), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetCustomWordSeparators(custom_word_separators String.Readable) { //gd:TextEdit.set_custom_word_separators
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_custom_word_separators), 0|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ custom_word_separators gdextension.String }{gdextension.String(pointers.Get(gd.InternalString(custom_word_separators))[0])}))
}

//go:nosplit
func (self class) GetCustomWordSeparators() String.Readable { //gd:TextEdit.get_custom_word_separators
	var r_ret = gdextension.Call[[1]gd.EnginePointer](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_custom_word_separators), gdextension.SizeString, unsafe.Pointer(&struct{}{}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

//go:nosplit
func (self class) SetSelectingEnabled(enable bool) { //gd:TextEdit.set_selecting_enabled
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_selecting_enabled), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

//go:nosplit
func (self class) IsSelectingEnabled() bool { //gd:TextEdit.is_selecting_enabled
	var r_ret = gdextension.Call[bool](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_is_selecting_enabled), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetDeselectOnFocusLossEnabled(enable bool) { //gd:TextEdit.set_deselect_on_focus_loss_enabled
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_deselect_on_focus_loss_enabled), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

//go:nosplit
func (self class) IsDeselectOnFocusLossEnabled() bool { //gd:TextEdit.is_deselect_on_focus_loss_enabled
	var r_ret = gdextension.Call[bool](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_is_deselect_on_focus_loss_enabled), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetDragAndDropSelectionEnabled(enable bool) { //gd:TextEdit.set_drag_and_drop_selection_enabled
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_drag_and_drop_selection_enabled), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

//go:nosplit
func (self class) IsDragAndDropSelectionEnabled() bool { //gd:TextEdit.is_drag_and_drop_selection_enabled
	var r_ret = gdextension.Call[bool](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_is_drag_and_drop_selection_enabled), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Sets the current selection mode.
*/
//go:nosplit
func (self class) SetSelectionMode(mode SelectionMode) { //gd:TextEdit.set_selection_mode
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_selection_mode), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ mode SelectionMode }{mode}))
}

/*
Returns the current selection mode.
*/
//go:nosplit
func (self class) GetSelectionMode() SelectionMode { //gd:TextEdit.get_selection_mode
	var r_ret = gdextension.Call[SelectionMode](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_selection_mode), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Select all the text.
If [member selecting_enabled] is [code]false[/code], no selection will occur.
*/
//go:nosplit
func (self class) SelectAll() { //gd:TextEdit.select_all
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_select_all), 0, unsafe.Pointer(&struct{}{}))
}

/*
Selects the word under the caret.
*/
//go:nosplit
func (self class) SelectWordUnderCaret(caret_index int64) { //gd:TextEdit.select_word_under_caret
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_select_word_under_caret), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ caret_index int64 }{caret_index}))
}

/*
Adds a selection and a caret for the next occurrence of the current selection. If there is no active selection, selects word under caret.
*/
//go:nosplit
func (self class) AddSelectionForNextOccurrence() { //gd:TextEdit.add_selection_for_next_occurrence
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_add_selection_for_next_occurrence), 0, unsafe.Pointer(&struct{}{}))
}

/*
Moves a selection and a caret for the next occurrence of the current selection. If there is no active selection, moves to the next occurrence of the word under caret.
*/
//go:nosplit
func (self class) SkipSelectionForNextOccurrence() { //gd:TextEdit.skip_selection_for_next_occurrence
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_skip_selection_for_next_occurrence), 0, unsafe.Pointer(&struct{}{}))
}

/*
Selects text from [param origin_line] and [param origin_column] to [param caret_line] and [param caret_column] for the given [param caret_index]. This moves the selection origin and the caret. If the positions are the same, the selection will be deselected.
If [member selecting_enabled] is [code]false[/code], no selection will occur.
[b]Note:[/b] If supporting multiple carets this will not check for any overlap. See [method merge_overlapping_carets].
*/
//go:nosplit
func (self class) Select(origin_line int64, origin_column int64, caret_line int64, caret_column int64, caret_index int64) { //gd:TextEdit.select_
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_select_), 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeInt<<16)|(gdextension.SizeInt<<20), unsafe.Pointer(&struct {
		origin_line   int64
		origin_column int64
		caret_line    int64
		caret_column  int64
		caret_index   int64
	}{origin_line, origin_column, caret_line, caret_column, caret_index}))
}

/*
Returns [code]true[/code] if the user has selected text.
*/
//go:nosplit
func (self class) HasSelection(caret_index int64) bool { //gd:TextEdit.has_selection
	var r_ret = gdextension.Call[bool](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_has_selection), gdextension.SizeBool|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ caret_index int64 }{caret_index}))
	var ret = r_ret
	return ret
}

/*
Returns the text inside the selection of a caret, or all the carets if [param caret_index] is its default value [code]-1[/code].
*/
//go:nosplit
func (self class) GetSelectedText(caret_index int64) String.Readable { //gd:TextEdit.get_selected_text
	var r_ret = gdextension.Call[[1]gd.EnginePointer](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_selected_text), gdextension.SizeString|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ caret_index int64 }{caret_index}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Returns the caret index of the selection at the given [param line] and [param column], or [code]-1[/code] if there is none.
If [param include_edges] is [code]false[/code], the position must be inside the selection and not at either end. If [param only_selections] is [code]false[/code], carets without a selection will also be considered.
*/
//go:nosplit
func (self class) GetSelectionAtLineColumn(line int64, column int64, include_edges bool, only_selections bool) int64 { //gd:TextEdit.get_selection_at_line_column
	var r_ret = gdextension.Call[int64](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_selection_at_line_column), gdextension.SizeInt|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeBool<<12)|(gdextension.SizeBool<<16), unsafe.Pointer(&struct {
		line            int64
		column          int64
		include_edges   bool
		only_selections bool
	}{line, column, include_edges, only_selections}))
	var ret = r_ret
	return ret
}

/*
Returns an [Array] of line ranges where [code]x[/code] is the first line and [code]y[/code] is the last line. All lines within these ranges will have a caret on them or be part of a selection. Each line will only be part of one line range, even if it has multiple carets on it.
If a selection's end column ([method get_selection_to_column]) is at column [code]0[/code], that line will not be included. If a selection begins on the line after another selection ends and [param merge_adjacent] is [code]true[/code], or they begin and end on the same line, one line range will include both selections.
*/
//go:nosplit
func (self class) GetLineRangesFromCarets(only_selections bool, merge_adjacent bool) Array.Contains[Vector2i.XY] { //gd:TextEdit.get_line_ranges_from_carets
	var r_ret = gdextension.Call[[1]gd.EnginePointer](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_line_ranges_from_carets), gdextension.SizeArray|(gdextension.SizeBool<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		only_selections bool
		merge_adjacent  bool
	}{only_selections, merge_adjacent}))
	var ret = Array.Through(gd.ArrayProxy[Vector2i.XY]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

/*
Returns the origin line of the selection. This is the opposite end from the caret.
*/
//go:nosplit
func (self class) GetSelectionOriginLine(caret_index int64) int64 { //gd:TextEdit.get_selection_origin_line
	var r_ret = gdextension.Call[int64](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_selection_origin_line), gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ caret_index int64 }{caret_index}))
	var ret = r_ret
	return ret
}

/*
Returns the origin column of the selection. This is the opposite end from the caret.
*/
//go:nosplit
func (self class) GetSelectionOriginColumn(caret_index int64) int64 { //gd:TextEdit.get_selection_origin_column
	var r_ret = gdextension.Call[int64](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_selection_origin_column), gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ caret_index int64 }{caret_index}))
	var ret = r_ret
	return ret
}

/*
Sets the selection origin line to the [param line] for the given [param caret_index]. If the selection origin is moved to the caret position, the selection will deselect.
If [param can_be_hidden] is [code]false[/code], The line will be set to the nearest unhidden line below or above.
If [param wrap_index] is [code]-1[/code], the selection origin column will be clamped to the [param line]'s length. If [param wrap_index] is greater than [code]-1[/code], the column will be moved to attempt to match the visual x position on the line's [param wrap_index] to the position from the last time [method set_selection_origin_column] or [method select] was called.
*/
//go:nosplit
func (self class) SetSelectionOriginLine(line int64, can_be_hidden bool, wrap_index int64, caret_index int64) { //gd:TextEdit.set_selection_origin_line
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_selection_origin_line), 0|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeInt<<16), unsafe.Pointer(&struct {
		line          int64
		can_be_hidden bool
		wrap_index    int64
		caret_index   int64
	}{line, can_be_hidden, wrap_index, caret_index}))
}

/*
Sets the selection origin column to the [param column] for the given [param caret_index]. If the selection origin is moved to the caret position, the selection will deselect.
*/
//go:nosplit
func (self class) SetSelectionOriginColumn(column int64, caret_index int64) { //gd:TextEdit.set_selection_origin_column
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_selection_origin_column), 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		column      int64
		caret_index int64
	}{column, caret_index}))
}

/*
Returns the selection begin line. Returns the caret line if there is no selection.
*/
//go:nosplit
func (self class) GetSelectionFromLine(caret_index int64) int64 { //gd:TextEdit.get_selection_from_line
	var r_ret = gdextension.Call[int64](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_selection_from_line), gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ caret_index int64 }{caret_index}))
	var ret = r_ret
	return ret
}

/*
Returns the selection begin column. Returns the caret column if there is no selection.
*/
//go:nosplit
func (self class) GetSelectionFromColumn(caret_index int64) int64 { //gd:TextEdit.get_selection_from_column
	var r_ret = gdextension.Call[int64](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_selection_from_column), gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ caret_index int64 }{caret_index}))
	var ret = r_ret
	return ret
}

/*
Returns the selection end line. Returns the caret line if there is no selection.
*/
//go:nosplit
func (self class) GetSelectionToLine(caret_index int64) int64 { //gd:TextEdit.get_selection_to_line
	var r_ret = gdextension.Call[int64](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_selection_to_line), gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ caret_index int64 }{caret_index}))
	var ret = r_ret
	return ret
}

/*
Returns the selection end column. Returns the caret column if there is no selection.
*/
//go:nosplit
func (self class) GetSelectionToColumn(caret_index int64) int64 { //gd:TextEdit.get_selection_to_column
	var r_ret = gdextension.Call[int64](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_selection_to_column), gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ caret_index int64 }{caret_index}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if the caret of the selection is after the selection origin. This can be used to determine the direction of the selection.
*/
//go:nosplit
func (self class) IsCaretAfterSelectionOrigin(caret_index int64) bool { //gd:TextEdit.is_caret_after_selection_origin
	var r_ret = gdextension.Call[bool](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_is_caret_after_selection_origin), gdextension.SizeBool|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ caret_index int64 }{caret_index}))
	var ret = r_ret
	return ret
}

/*
Deselects the current selection.
*/
//go:nosplit
func (self class) Deselect(caret_index int64) { //gd:TextEdit.deselect
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_deselect), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ caret_index int64 }{caret_index}))
}

/*
Deletes the selected text.
*/
//go:nosplit
func (self class) DeleteSelection(caret_index int64) { //gd:TextEdit.delete_selection
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_delete_selection), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ caret_index int64 }{caret_index}))
}

//go:nosplit
func (self class) SetLineWrappingMode(mode LineWrappingMode) { //gd:TextEdit.set_line_wrapping_mode
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_line_wrapping_mode), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ mode LineWrappingMode }{mode}))
}

//go:nosplit
func (self class) GetLineWrappingMode() LineWrappingMode { //gd:TextEdit.get_line_wrapping_mode
	var r_ret = gdextension.Call[LineWrappingMode](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_line_wrapping_mode), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetAutowrapMode(autowrap_mode TextServer.AutowrapMode) { //gd:TextEdit.set_autowrap_mode
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_autowrap_mode), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ autowrap_mode TextServer.AutowrapMode }{autowrap_mode}))
}

//go:nosplit
func (self class) GetAutowrapMode() TextServer.AutowrapMode { //gd:TextEdit.get_autowrap_mode
	var r_ret = gdextension.Call[TextServer.AutowrapMode](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_autowrap_mode), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns if the given line is wrapped.
*/
//go:nosplit
func (self class) IsLineWrapped(line int64) bool { //gd:TextEdit.is_line_wrapped
	var r_ret = gdextension.Call[bool](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_is_line_wrapped), gdextension.SizeBool|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ line int64 }{line}))
	var ret = r_ret
	return ret
}

/*
Returns the number of times the given line is wrapped.
*/
//go:nosplit
func (self class) GetLineWrapCount(line int64) int64 { //gd:TextEdit.get_line_wrap_count
	var r_ret = gdextension.Call[int64](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_line_wrap_count), gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ line int64 }{line}))
	var ret = r_ret
	return ret
}

/*
Returns the wrap index of the given column on the given line. This ranges from [code]0[/code] to [method get_line_wrap_count].
*/
//go:nosplit
func (self class) GetLineWrapIndexAtColumn(line int64, column int64) int64 { //gd:TextEdit.get_line_wrap_index_at_column
	var r_ret = gdextension.Call[int64](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_line_wrap_index_at_column), gdextension.SizeInt|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		line   int64
		column int64
	}{line, column}))
	var ret = r_ret
	return ret
}

/*
Returns an array of [String]s representing each wrapped index.
*/
//go:nosplit
func (self class) GetLineWrappedText(line int64) Packed.Strings { //gd:TextEdit.get_line_wrapped_text
	var r_ret = gdextension.Call[gd.PackedPointers](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_line_wrapped_text), gdextension.SizePackedArray|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ line int64 }{line}))
	var ret = Packed.Strings(Array.Through(gd.PackedStringArrayProxy{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

//go:nosplit
func (self class) SetSmoothScrollEnabled(enable bool) { //gd:TextEdit.set_smooth_scroll_enabled
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_smooth_scroll_enabled), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

//go:nosplit
func (self class) IsSmoothScrollEnabled() bool { //gd:TextEdit.is_smooth_scroll_enabled
	var r_ret = gdextension.Call[bool](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_is_smooth_scroll_enabled), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the [VScrollBar] of the [TextEdit].
*/
//go:nosplit
func (self class) GetVScrollBar() [1]gdclass.VScrollBar { //gd:TextEdit.get_v_scroll_bar
	var r_ret = gdextension.Call[gd.EnginePointer](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_v_scroll_bar), gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.VScrollBar{gd.PointerLifetimeBoundTo[gdclass.VScrollBar](self.AsObject(), r_ret)}
	return ret
}

/*
Returns the [HScrollBar] used by [TextEdit].
*/
//go:nosplit
func (self class) GetHScrollBar() [1]gdclass.HScrollBar { //gd:TextEdit.get_h_scroll_bar
	var r_ret = gdextension.Call[gd.EnginePointer](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_h_scroll_bar), gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.HScrollBar{gd.PointerLifetimeBoundTo[gdclass.HScrollBar](self.AsObject(), r_ret)}
	return ret
}

//go:nosplit
func (self class) SetVScroll(value float64) { //gd:TextEdit.set_v_scroll
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_v_scroll), 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ value float64 }{value}))
}

//go:nosplit
func (self class) GetVScroll() float64 { //gd:TextEdit.get_v_scroll
	var r_ret = gdextension.Call[float64](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_v_scroll), gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetHScroll(value int64) { //gd:TextEdit.set_h_scroll
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_h_scroll), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ value int64 }{value}))
}

//go:nosplit
func (self class) GetHScroll() int64 { //gd:TextEdit.get_h_scroll
	var r_ret = gdextension.Call[int64](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_h_scroll), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetScrollPastEndOfFileEnabled(enable bool) { //gd:TextEdit.set_scroll_past_end_of_file_enabled
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_scroll_past_end_of_file_enabled), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

//go:nosplit
func (self class) IsScrollPastEndOfFileEnabled() bool { //gd:TextEdit.is_scroll_past_end_of_file_enabled
	var r_ret = gdextension.Call[bool](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_is_scroll_past_end_of_file_enabled), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetVScrollSpeed(speed float64) { //gd:TextEdit.set_v_scroll_speed
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_v_scroll_speed), 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ speed float64 }{speed}))
}

//go:nosplit
func (self class) GetVScrollSpeed() float64 { //gd:TextEdit.get_v_scroll_speed
	var r_ret = gdextension.Call[float64](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_v_scroll_speed), gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetFitContentHeightEnabled(enabled bool) { //gd:TextEdit.set_fit_content_height_enabled
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_fit_content_height_enabled), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enabled bool }{enabled}))
}

//go:nosplit
func (self class) IsFitContentHeightEnabled() bool { //gd:TextEdit.is_fit_content_height_enabled
	var r_ret = gdextension.Call[bool](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_is_fit_content_height_enabled), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetFitContentWidthEnabled(enabled bool) { //gd:TextEdit.set_fit_content_width_enabled
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_fit_content_width_enabled), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enabled bool }{enabled}))
}

//go:nosplit
func (self class) IsFitContentWidthEnabled() bool { //gd:TextEdit.is_fit_content_width_enabled
	var r_ret = gdextension.Call[bool](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_is_fit_content_width_enabled), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the scroll position for [param wrap_index] of [param line].
*/
//go:nosplit
func (self class) GetScrollPosForLine(line int64, wrap_index int64) float64 { //gd:TextEdit.get_scroll_pos_for_line
	var r_ret = gdextension.Call[float64](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_scroll_pos_for_line), gdextension.SizeFloat|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		line       int64
		wrap_index int64
	}{line, wrap_index}))
	var ret = r_ret
	return ret
}

/*
Positions the [param wrap_index] of [param line] at the top of the viewport.
*/
//go:nosplit
func (self class) SetLineAsFirstVisible(line int64, wrap_index int64) { //gd:TextEdit.set_line_as_first_visible
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_line_as_first_visible), 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		line       int64
		wrap_index int64
	}{line, wrap_index}))
}

/*
Returns the first visible line.
*/
//go:nosplit
func (self class) GetFirstVisibleLine() int64 { //gd:TextEdit.get_first_visible_line
	var r_ret = gdextension.Call[int64](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_first_visible_line), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Positions the [param wrap_index] of [param line] at the center of the viewport.
*/
//go:nosplit
func (self class) SetLineAsCenterVisible(line int64, wrap_index int64) { //gd:TextEdit.set_line_as_center_visible
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_line_as_center_visible), 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		line       int64
		wrap_index int64
	}{line, wrap_index}))
}

/*
Positions the [param wrap_index] of [param line] at the bottom of the viewport.
*/
//go:nosplit
func (self class) SetLineAsLastVisible(line int64, wrap_index int64) { //gd:TextEdit.set_line_as_last_visible
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_line_as_last_visible), 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		line       int64
		wrap_index int64
	}{line, wrap_index}))
}

/*
Returns the last visible line. Use [method get_last_full_visible_line_wrap_index] for the wrap index.
*/
//go:nosplit
func (self class) GetLastFullVisibleLine() int64 { //gd:TextEdit.get_last_full_visible_line
	var r_ret = gdextension.Call[int64](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_last_full_visible_line), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the last visible wrap index of the last visible line.
*/
//go:nosplit
func (self class) GetLastFullVisibleLineWrapIndex() int64 { //gd:TextEdit.get_last_full_visible_line_wrap_index
	var r_ret = gdextension.Call[int64](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_last_full_visible_line_wrap_index), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the number of lines that can visually fit, rounded down, based on this control's height.
*/
//go:nosplit
func (self class) GetVisibleLineCount() int64 { //gd:TextEdit.get_visible_line_count
	var r_ret = gdextension.Call[int64](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_visible_line_count), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the total number of lines between [param from_line] and [param to_line] (inclusive) in the text. This includes wrapped lines and excludes folded lines. If the range covers all lines it is equivalent to [method get_total_visible_line_count].
*/
//go:nosplit
func (self class) GetVisibleLineCountInRange(from_line int64, to_line int64) int64 { //gd:TextEdit.get_visible_line_count_in_range
	var r_ret = gdextension.Call[int64](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_visible_line_count_in_range), gdextension.SizeInt|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		from_line int64
		to_line   int64
	}{from_line, to_line}))
	var ret = r_ret
	return ret
}

/*
Returns the total number of lines in the text. This includes wrapped lines and excludes folded lines. If [member wrap_mode] is set to [constant LINE_WRAPPING_NONE] and no lines are folded (see [method CodeEdit.is_line_folded]) then this is equivalent to [method get_line_count]. See [method get_visible_line_count_in_range] for a limited range of lines.
*/
//go:nosplit
func (self class) GetTotalVisibleLineCount() int64 { //gd:TextEdit.get_total_visible_line_count
	var r_ret = gdextension.Call[int64](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_total_visible_line_count), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Adjust the viewport so the caret is visible.
*/
//go:nosplit
func (self class) AdjustViewportToCaret(caret_index int64) { //gd:TextEdit.adjust_viewport_to_caret
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_adjust_viewport_to_caret), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ caret_index int64 }{caret_index}))
}

/*
Centers the viewport on the line the editing caret is at. This also resets the [member scroll_horizontal] value to [code]0[/code].
*/
//go:nosplit
func (self class) CenterViewportToCaret(caret_index int64) { //gd:TextEdit.center_viewport_to_caret
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_center_viewport_to_caret), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ caret_index int64 }{caret_index}))
}

//go:nosplit
func (self class) SetDrawMinimap(enabled bool) { //gd:TextEdit.set_draw_minimap
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_draw_minimap), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enabled bool }{enabled}))
}

//go:nosplit
func (self class) IsDrawingMinimap() bool { //gd:TextEdit.is_drawing_minimap
	var r_ret = gdextension.Call[bool](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_is_drawing_minimap), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetMinimapWidth(width int64) { //gd:TextEdit.set_minimap_width
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_minimap_width), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ width int64 }{width}))
}

//go:nosplit
func (self class) GetMinimapWidth() int64 { //gd:TextEdit.get_minimap_width
	var r_ret = gdextension.Call[int64](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_minimap_width), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the number of lines that may be drawn on the minimap.
*/
//go:nosplit
func (self class) GetMinimapVisibleLines() int64 { //gd:TextEdit.get_minimap_visible_lines
	var r_ret = gdextension.Call[int64](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_minimap_visible_lines), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Register a new gutter to this [TextEdit]. Use [param at] to have a specific gutter order. A value of [code]-1[/code] appends the gutter to the right.
*/
//go:nosplit
func (self class) AddGutter(at int64) { //gd:TextEdit.add_gutter
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_add_gutter), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ at int64 }{at}))
}

/*
Removes the gutter at the given index.
*/
//go:nosplit
func (self class) RemoveGutter(gutter int64) { //gd:TextEdit.remove_gutter
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_remove_gutter), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ gutter int64 }{gutter}))
}

/*
Returns the number of gutters registered.
*/
//go:nosplit
func (self class) GetGutterCount() int64 { //gd:TextEdit.get_gutter_count
	var r_ret = gdextension.Call[int64](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_gutter_count), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Sets the name of the gutter at the given index.
*/
//go:nosplit
func (self class) SetGutterName(gutter int64, name String.Readable) { //gd:TextEdit.set_gutter_name
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_gutter_name), 0|(gdextension.SizeInt<<4)|(gdextension.SizeString<<8), unsafe.Pointer(&struct {
		gutter int64
		name   gdextension.String
	}{gutter, gdextension.String(pointers.Get(gd.InternalString(name))[0])}))
}

/*
Returns the name of the gutter at the given index.
*/
//go:nosplit
func (self class) GetGutterName(gutter int64) String.Readable { //gd:TextEdit.get_gutter_name
	var r_ret = gdextension.Call[[1]gd.EnginePointer](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_gutter_name), gdextension.SizeString|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ gutter int64 }{gutter}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Sets the type of gutter at the given index. Gutters can contain icons, text, or custom visuals. See [enum TextEdit.GutterType] for options.
*/
//go:nosplit
func (self class) SetGutterType(gutter int64, atype GutterType) { //gd:TextEdit.set_gutter_type
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_gutter_type), 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		gutter int64
		atype  GutterType
	}{gutter, atype}))
}

/*
Returns the type of the gutter at the given index. Gutters can contain icons, text, or custom visuals. See [enum TextEdit.GutterType] for options.
*/
//go:nosplit
func (self class) GetGutterType(gutter int64) GutterType { //gd:TextEdit.get_gutter_type
	var r_ret = gdextension.Call[GutterType](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_gutter_type), gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ gutter int64 }{gutter}))
	var ret = r_ret
	return ret
}

/*
Set the width of the gutter at the given index.
*/
//go:nosplit
func (self class) SetGutterWidth(gutter int64, width int64) { //gd:TextEdit.set_gutter_width
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_gutter_width), 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		gutter int64
		width  int64
	}{gutter, width}))
}

/*
Returns the width of the gutter at the given index.
*/
//go:nosplit
func (self class) GetGutterWidth(gutter int64) int64 { //gd:TextEdit.get_gutter_width
	var r_ret = gdextension.Call[int64](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_gutter_width), gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ gutter int64 }{gutter}))
	var ret = r_ret
	return ret
}

/*
If [code]true[/code], the gutter at the given index is drawn. The gutter type ([method set_gutter_type]) determines how it is drawn. See [method is_gutter_drawn].
*/
//go:nosplit
func (self class) SetGutterDraw(gutter int64, draw bool) { //gd:TextEdit.set_gutter_draw
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_gutter_draw), 0|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		gutter int64
		draw   bool
	}{gutter, draw}))
}

/*
Returns [code]true[/code] if the gutter at the given index is currently drawn. See [method set_gutter_draw].
*/
//go:nosplit
func (self class) IsGutterDrawn(gutter int64) bool { //gd:TextEdit.is_gutter_drawn
	var r_ret = gdextension.Call[bool](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_is_gutter_drawn), gdextension.SizeBool|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ gutter int64 }{gutter}))
	var ret = r_ret
	return ret
}

/*
If [code]true[/code], the mouse cursor will change to a pointing hand ([constant Control.CURSOR_POINTING_HAND]) when hovering over the gutter at the given index. See [method is_gutter_clickable] and [method set_line_gutter_clickable].
*/
//go:nosplit
func (self class) SetGutterClickable(gutter int64, clickable bool) { //gd:TextEdit.set_gutter_clickable
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_gutter_clickable), 0|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		gutter    int64
		clickable bool
	}{gutter, clickable}))
}

/*
Returns [code]true[/code] if the gutter at the given index is clickable. See [method set_gutter_clickable].
*/
//go:nosplit
func (self class) IsGutterClickable(gutter int64) bool { //gd:TextEdit.is_gutter_clickable
	var r_ret = gdextension.Call[bool](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_is_gutter_clickable), gdextension.SizeBool|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ gutter int64 }{gutter}))
	var ret = r_ret
	return ret
}

/*
If [code]true[/code], the line data of the gutter at the given index can be overridden when using [method merge_gutters]. See [method is_gutter_overwritable].
*/
//go:nosplit
func (self class) SetGutterOverwritable(gutter int64, overwritable bool) { //gd:TextEdit.set_gutter_overwritable
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_gutter_overwritable), 0|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		gutter       int64
		overwritable bool
	}{gutter, overwritable}))
}

/*
Returns [code]true[/code] if the gutter at the given index is overwritable. See [method set_gutter_overwritable].
*/
//go:nosplit
func (self class) IsGutterOverwritable(gutter int64) bool { //gd:TextEdit.is_gutter_overwritable
	var r_ret = gdextension.Call[bool](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_is_gutter_overwritable), gdextension.SizeBool|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ gutter int64 }{gutter}))
	var ret = r_ret
	return ret
}

/*
Merge the gutters from [param from_line] into [param to_line]. Only overwritable gutters will be copied. See [method set_gutter_overwritable].
*/
//go:nosplit
func (self class) MergeGutters(from_line int64, to_line int64) { //gd:TextEdit.merge_gutters
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_merge_gutters), 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		from_line int64
		to_line   int64
	}{from_line, to_line}))
}

/*
Set a custom draw callback for the gutter at the given index. [param draw_callback] must take the following arguments: A line index [int], a gutter index [int], and an area [Rect2]. This callback only works when the gutter type is [constant GUTTER_TYPE_CUSTOM] (see [method set_gutter_type]).
*/
//go:nosplit
func (self class) SetGutterCustomDraw(column int64, draw_callback Callable.Function) { //gd:TextEdit.set_gutter_custom_draw
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_gutter_custom_draw), 0|(gdextension.SizeInt<<4)|(gdextension.SizeCallable<<8), unsafe.Pointer(&struct {
		column        int64
		draw_callback gdextension.Callable
	}{column, gdextension.Callable(pointers.Get(gd.InternalCallable(draw_callback)))}))
}

/*
Returns the total width of all gutters and internal padding.
*/
//go:nosplit
func (self class) GetTotalGutterWidth() int64 { //gd:TextEdit.get_total_gutter_width
	var r_ret = gdextension.Call[int64](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_total_gutter_width), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Sets the metadata for [param gutter] on [param line] to [param metadata].
*/
//go:nosplit
func (self class) SetLineGutterMetadata(line int64, gutter int64, metadata variant.Any) { //gd:TextEdit.set_line_gutter_metadata
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_line_gutter_metadata), 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeVariant<<12), unsafe.Pointer(&struct {
		line     int64
		gutter   int64
		metadata gdextension.Variant
	}{line, gutter, gdextension.Variant(pointers.Get(gd.InternalVariant(metadata)))}))
}

/*
Returns the metadata currently in [param gutter] at [param line].
*/
//go:nosplit
func (self class) GetLineGutterMetadata(line int64, gutter int64) variant.Any { //gd:TextEdit.get_line_gutter_metadata
	var r_ret = gdextension.Call[[3]uint64](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_line_gutter_metadata), gdextension.SizeVariant|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		line   int64
		gutter int64
	}{line, gutter}))
	var ret = variant.Implementation(gd.VariantProxy{}, pointers.Pack(pointers.New[gd.Variant](r_ret)))
	return ret
}

/*
Sets the text for [param gutter] on [param line] to [param text]. This only works when the gutter type is [constant GUTTER_TYPE_STRING] (see [method set_gutter_type]).
*/
//go:nosplit
func (self class) SetLineGutterText(line int64, gutter int64, text String.Readable) { //gd:TextEdit.set_line_gutter_text
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_line_gutter_text), 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeString<<12), unsafe.Pointer(&struct {
		line   int64
		gutter int64
		text   gdextension.String
	}{line, gutter, gdextension.String(pointers.Get(gd.InternalString(text))[0])}))
}

/*
Returns the text currently in [param gutter] at [param line]. This only works when the gutter type is [constant GUTTER_TYPE_STRING] (see [method set_gutter_type]).
*/
//go:nosplit
func (self class) GetLineGutterText(line int64, gutter int64) String.Readable { //gd:TextEdit.get_line_gutter_text
	var r_ret = gdextension.Call[[1]gd.EnginePointer](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_line_gutter_text), gdextension.SizeString|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		line   int64
		gutter int64
	}{line, gutter}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Sets the icon for [param gutter] on [param line] to [param icon]. This only works when the gutter type is [constant GUTTER_TYPE_ICON] (see [method set_gutter_type]).
*/
//go:nosplit
func (self class) SetLineGutterIcon(line int64, gutter int64, icon [1]gdclass.Texture2D) { //gd:TextEdit.set_line_gutter_icon
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_line_gutter_icon), 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeObject<<12), unsafe.Pointer(&struct {
		line   int64
		gutter int64
		icon   gdextension.Object
	}{line, gutter, gdextension.Object(gd.ObjectChecked(icon[0].AsObject()))}))
}

/*
Returns the icon currently in [param gutter] at [param line]. This only works when the gutter type is [constant GUTTER_TYPE_ICON] (see [method set_gutter_type]).
*/
//go:nosplit
func (self class) GetLineGutterIcon(line int64, gutter int64) [1]gdclass.Texture2D { //gd:TextEdit.get_line_gutter_icon
	var r_ret = gdextension.Call[gd.EnginePointer](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_line_gutter_icon), gdextension.SizeObject|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		line   int64
		gutter int64
	}{line, gutter}))
	var ret = [1]gdclass.Texture2D{gd.PointerWithOwnershipTransferredToGo[gdclass.Texture2D](r_ret)}
	return ret
}

/*
Sets the color for [param gutter] on [param line] to [param color].
*/
//go:nosplit
func (self class) SetLineGutterItemColor(line int64, gutter int64, color Color.RGBA) { //gd:TextEdit.set_line_gutter_item_color
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_line_gutter_item_color), 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeColor<<12), unsafe.Pointer(&struct {
		line   int64
		gutter int64
		color  Color.RGBA
	}{line, gutter, color}))
}

/*
Returns the color currently in [param gutter] at [param line].
*/
//go:nosplit
func (self class) GetLineGutterItemColor(line int64, gutter int64) Color.RGBA { //gd:TextEdit.get_line_gutter_item_color
	var r_ret = gdextension.Call[Color.RGBA](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_line_gutter_item_color), gdextension.SizeColor|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		line   int64
		gutter int64
	}{line, gutter}))
	var ret = r_ret
	return ret
}

/*
If [param clickable] is [code]true[/code], makes the [param gutter] on the given [param line] clickable. This is like [method set_gutter_clickable], but for a single line. If [method is_gutter_clickable] is [code]true[/code], this will not have any effect. See [method is_line_gutter_clickable] and [signal gutter_clicked].
*/
//go:nosplit
func (self class) SetLineGutterClickable(line int64, gutter int64, clickable bool) { //gd:TextEdit.set_line_gutter_clickable
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_line_gutter_clickable), 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeBool<<12), unsafe.Pointer(&struct {
		line      int64
		gutter    int64
		clickable bool
	}{line, gutter, clickable}))
}

/*
Returns [code]true[/code] if the gutter at the given index on the given line is clickable. See [method set_line_gutter_clickable].
*/
//go:nosplit
func (self class) IsLineGutterClickable(line int64, gutter int64) bool { //gd:TextEdit.is_line_gutter_clickable
	var r_ret = gdextension.Call[bool](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_is_line_gutter_clickable), gdextension.SizeBool|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		line   int64
		gutter int64
	}{line, gutter}))
	var ret = r_ret
	return ret
}

/*
Sets the custom background color of the given line. If transparent, this color is applied on top of the default background color (See [theme_item background_color]). If set to [code]Color(0, 0, 0, 0)[/code], no additional color is applied.
*/
//go:nosplit
func (self class) SetLineBackgroundColor(line int64, color Color.RGBA) { //gd:TextEdit.set_line_background_color
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_line_background_color), 0|(gdextension.SizeInt<<4)|(gdextension.SizeColor<<8), unsafe.Pointer(&struct {
		line  int64
		color Color.RGBA
	}{line, color}))
}

/*
Returns the custom background color of the given line. If no color is set, returns [code]Color(0, 0, 0, 0)[/code].
*/
//go:nosplit
func (self class) GetLineBackgroundColor(line int64) Color.RGBA { //gd:TextEdit.get_line_background_color
	var r_ret = gdextension.Call[Color.RGBA](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_line_background_color), gdextension.SizeColor|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ line int64 }{line}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetSyntaxHighlighter(syntax_highlighter [1]gdclass.SyntaxHighlighter) { //gd:TextEdit.set_syntax_highlighter
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_syntax_highlighter), 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ syntax_highlighter gdextension.Object }{gdextension.Object(gd.ObjectChecked(syntax_highlighter[0].AsObject()))}))
}

//go:nosplit
func (self class) GetSyntaxHighlighter() [1]gdclass.SyntaxHighlighter { //gd:TextEdit.get_syntax_highlighter
	var r_ret = gdextension.Call[gd.EnginePointer](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_syntax_highlighter), gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.SyntaxHighlighter{gd.PointerWithOwnershipTransferredToGo[gdclass.SyntaxHighlighter](r_ret)}
	return ret
}

//go:nosplit
func (self class) SetHighlightCurrentLine(enabled bool) { //gd:TextEdit.set_highlight_current_line
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_highlight_current_line), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enabled bool }{enabled}))
}

//go:nosplit
func (self class) IsHighlightCurrentLineEnabled() bool { //gd:TextEdit.is_highlight_current_line_enabled
	var r_ret = gdextension.Call[bool](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_is_highlight_current_line_enabled), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetHighlightAllOccurrences(enabled bool) { //gd:TextEdit.set_highlight_all_occurrences
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_highlight_all_occurrences), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enabled bool }{enabled}))
}

//go:nosplit
func (self class) IsHighlightAllOccurrencesEnabled() bool { //gd:TextEdit.is_highlight_all_occurrences_enabled
	var r_ret = gdextension.Call[bool](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_is_highlight_all_occurrences_enabled), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) GetDrawControlChars() bool { //gd:TextEdit.get_draw_control_chars
	var r_ret = gdextension.Call[bool](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_draw_control_chars), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetDrawControlChars(enabled bool) { //gd:TextEdit.set_draw_control_chars
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_draw_control_chars), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enabled bool }{enabled}))
}

//go:nosplit
func (self class) SetDrawTabs(enabled bool) { //gd:TextEdit.set_draw_tabs
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_draw_tabs), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enabled bool }{enabled}))
}

//go:nosplit
func (self class) IsDrawingTabs() bool { //gd:TextEdit.is_drawing_tabs
	var r_ret = gdextension.Call[bool](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_is_drawing_tabs), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetDrawSpaces(enabled bool) { //gd:TextEdit.set_draw_spaces
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_set_draw_spaces), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enabled bool }{enabled}))
}

//go:nosplit
func (self class) IsDrawingSpaces() bool { //gd:TextEdit.is_drawing_spaces
	var r_ret = gdextension.Call[bool](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_is_drawing_spaces), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the [PopupMenu] of this [TextEdit]. By default, this menu is displayed when right-clicking on the [TextEdit].
You can add custom menu items or remove standard ones. Make sure your IDs don't conflict with the standard ones (see [enum MenuItems]). For example:
[codeblocks]
[gdscript]
func _ready():
    var menu = get_menu()
    # Remove all items after "Redo".
    menu.item_count = menu.get_item_index(MENU_REDO) + 1
    # Add custom items.
    menu.add_separator()
    menu.add_item("Insert Date", MENU_MAX + 1)
    # Connect callback.
    menu.id_pressed.connect(_on_item_pressed)

func _on_item_pressed(id):
    if id == MENU_MAX + 1:
        insert_text_at_caret(Time.get_date_string_from_system())
[/gdscript]
[csharp]
public override void _Ready()
{
    var menu = GetMenu();
    // Remove all items after "Redo".
    menu.ItemCount = menu.GetItemIndex(TextEdit.MenuItems.Redo) + 1;
    // Add custom items.
    menu.AddSeparator();
    menu.AddItem("Insert Date", TextEdit.MenuItems.Max + 1);
    // Add event handler.
    menu.IdPressed += OnItemPressed;
}

public void OnItemPressed(int id)
{
    if (id == TextEdit.MenuItems.Max + 1)
    {
        InsertTextAtCaret(Time.GetDateStringFromSystem());
    }
}
[/csharp]
[/codeblocks]
[b]Warning:[/b] This is a required internal node, removing and freeing it may cause a crash. If you wish to hide it or any of its children, use their [member Window.visible] property.
*/
//go:nosplit
func (self class) GetMenu() [1]gdclass.PopupMenu { //gd:TextEdit.get_menu
	var r_ret = gdextension.Call[gd.EnginePointer](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_menu), gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.PopupMenu{gd.PointerLifetimeBoundTo[gdclass.PopupMenu](self.AsObject(), r_ret)}
	return ret
}

/*
Returns [code]true[/code] if the menu is visible. Use this instead of [code]get_menu().visible[/code] to improve performance (so the creation of the menu is avoided). See [method get_menu].
*/
//go:nosplit
func (self class) IsMenuVisible() bool { //gd:TextEdit.is_menu_visible
	var r_ret = gdextension.Call[bool](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_is_menu_visible), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Executes a given action as defined in the [enum MenuItems] enum.
*/
//go:nosplit
func (self class) MenuOption(option int64) { //gd:TextEdit.menu_option
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_menu_option), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ option int64 }{option}))
}

/*
This method does nothing.
*/
//go:nosplit
func (self class) AdjustCaretsAfterEdit(caret int64, from_line int64, from_col int64, to_line int64, to_col int64) { //gd:TextEdit.adjust_carets_after_edit
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_adjust_carets_after_edit), 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeInt<<16)|(gdextension.SizeInt<<20), unsafe.Pointer(&struct {
		caret     int64
		from_line int64
		from_col  int64
		to_line   int64
		to_col    int64
	}{caret, from_line, from_col, to_line, to_col}))
}

/*
Returns a list of caret indexes in their edit order, this done from bottom to top. Edit order refers to the way actions such as [method insert_text_at_caret] are applied.
*/
//go:nosplit
func (self class) GetCaretIndexEditOrder() Packed.Array[int32] { //gd:TextEdit.get_caret_index_edit_order
	var r_ret = gdextension.Call[gd.PackedPointers](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_caret_index_edit_order), gdextension.SizePackedArray, unsafe.Pointer(&struct{}{}))
	var ret = Packed.Array[int32](Array.Through(gd.PackedProxy[gd.PackedInt32Array, int32]{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

/*
Returns the original start line of the selection.
*/
//go:nosplit
func (self class) GetSelectionLine(caret_index int64) int64 { //gd:TextEdit.get_selection_line
	var r_ret = gdextension.Call[int64](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_selection_line), gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ caret_index int64 }{caret_index}))
	var ret = r_ret
	return ret
}

/*
Returns the original start column of the selection.
*/
//go:nosplit
func (self class) GetSelectionColumn(caret_index int64) int64 { //gd:TextEdit.get_selection_column
	var r_ret = gdextension.Call[int64](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.TextEdit.Bind_get_selection_column), gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ caret_index int64 }{caret_index}))
	var ret = r_ret
	return ret
}
func (self Instance) OnTextSet(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("text_set"), gd.NewCallable(cb), 0)
}

func (self Instance) OnTextChanged(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("text_changed"), gd.NewCallable(cb), 0)
}

func (self Instance) OnLinesEditedFrom(cb func(from_line int, to_line int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("lines_edited_from"), gd.NewCallable(cb), 0)
}

func (self Instance) OnCaretChanged(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("caret_changed"), gd.NewCallable(cb), 0)
}

func (self Instance) OnGutterClicked(cb func(line int, gutter int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("gutter_clicked"), gd.NewCallable(cb), 0)
}

func (self Instance) OnGutterAdded(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("gutter_added"), gd.NewCallable(cb), 0)
}

func (self Instance) OnGutterRemoved(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("gutter_removed"), gd.NewCallable(cb), 0)
}

func (self class) AsTextEdit() Advanced                { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsTextEdit() Instance             { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsTextEdit() Instance        { return self.Super().AsTextEdit() }
func (self class) AsControl() Control.Advanced         { return *((*Control.Advanced)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsControl() Control.Instance { return self.Super().AsControl() }
func (self Instance) AsControl() Control.Instance {
	return *((*Control.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsCanvasItem() CanvasItem.Advanced {
	return *((*CanvasItem.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsCanvasItem() CanvasItem.Instance { return self.Super().AsCanvasItem() }
func (self Instance) AsCanvasItem() CanvasItem.Instance {
	return *((*CanvasItem.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsNode() Node.Advanced         { return *((*Node.Advanced)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsNode() Node.Instance { return self.Super().AsNode() }
func (self Instance) AsNode() Node.Instance      { return *((*Node.Instance)(unsafe.Pointer(&self))) }

func (self class) Virtual(name string) reflect.Value {
	switch name {
	case "_handle_unicode_input":
		return reflect.ValueOf(self._handle_unicode_input)
	case "_backspace":
		return reflect.ValueOf(self._backspace)
	case "_cut":
		return reflect.ValueOf(self._cut)
	case "_copy":
		return reflect.ValueOf(self._copy)
	case "_paste":
		return reflect.ValueOf(self._paste)
	case "_paste_primary_clipboard":
		return reflect.ValueOf(self._paste_primary_clipboard)
	default:
		return gd.VirtualByName(Control.Advanced(self.AsControl()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	case "_handle_unicode_input":
		return reflect.ValueOf(self._handle_unicode_input)
	case "_backspace":
		return reflect.ValueOf(self._backspace)
	case "_cut":
		return reflect.ValueOf(self._cut)
	case "_copy":
		return reflect.ValueOf(self._copy)
	case "_paste":
		return reflect.ValueOf(self._paste)
	case "_paste_primary_clipboard":
		return reflect.ValueOf(self._paste_primary_clipboard)
	default:
		return gd.VirtualByName(Control.Instance(self.AsControl()), name)
	}
}
func init() {
	gdclass.Register("TextEdit", func(ptr gd.Object) any { return [1]gdclass.TextEdit{*(*gdclass.TextEdit)(unsafe.Pointer(&ptr))} })
}

type MenuItems int //gd:TextEdit.MenuItems

const (
	/*Cuts (copies and clears) the selected text.*/
	MenuCut MenuItems = 0
	/*Copies the selected text.*/
	MenuCopy MenuItems = 1
	/*Pastes the clipboard text over the selected text (or at the cursor's position).*/
	MenuPaste MenuItems = 2
	/*Erases the whole [TextEdit] text.*/
	MenuClear MenuItems = 3
	/*Selects the whole [TextEdit] text.*/
	MenuSelectAll MenuItems = 4
	/*Undoes the previous action.*/
	MenuUndo MenuItems = 5
	/*Redoes the previous action.*/
	MenuRedo MenuItems = 6
	/*ID of "Text Writing Direction" submenu.*/
	MenuSubmenuTextDir MenuItems = 7
	/*Sets text direction to inherited.*/
	MenuDirInherited MenuItems = 8
	/*Sets text direction to automatic.*/
	MenuDirAuto MenuItems = 9
	/*Sets text direction to left-to-right.*/
	MenuDirLtr MenuItems = 10
	/*Sets text direction to right-to-left.*/
	MenuDirRtl MenuItems = 11
	/*Toggles control character display.*/
	MenuDisplayUcc MenuItems = 12
	/*ID of "Insert Control Character" submenu.*/
	MenuSubmenuInsertUcc MenuItems = 13
	/*Inserts left-to-right mark (LRM) character.*/
	MenuInsertLrm MenuItems = 14
	/*Inserts right-to-left mark (RLM) character.*/
	MenuInsertRlm MenuItems = 15
	/*Inserts start of left-to-right embedding (LRE) character.*/
	MenuInsertLre MenuItems = 16
	/*Inserts start of right-to-left embedding (RLE) character.*/
	MenuInsertRle MenuItems = 17
	/*Inserts start of left-to-right override (LRO) character.*/
	MenuInsertLro MenuItems = 18
	/*Inserts start of right-to-left override (RLO) character.*/
	MenuInsertRlo MenuItems = 19
	/*Inserts pop direction formatting (PDF) character.*/
	MenuInsertPdf MenuItems = 20
	/*Inserts Arabic letter mark (ALM) character.*/
	MenuInsertAlm MenuItems = 21
	/*Inserts left-to-right isolate (LRI) character.*/
	MenuInsertLri MenuItems = 22
	/*Inserts right-to-left isolate (RLI) character.*/
	MenuInsertRli MenuItems = 23
	/*Inserts first strong isolate (FSI) character.*/
	MenuInsertFsi MenuItems = 24
	/*Inserts pop direction isolate (PDI) character.*/
	MenuInsertPdi MenuItems = 25
	/*Inserts zero width joiner (ZWJ) character.*/
	MenuInsertZwj MenuItems = 26
	/*Inserts zero width non-joiner (ZWNJ) character.*/
	MenuInsertZwnj MenuItems = 27
	/*Inserts word joiner (WJ) character.*/
	MenuInsertWj MenuItems = 28
	/*Inserts soft hyphen (SHY) character.*/
	MenuInsertShy MenuItems = 29
	/*Opens system emoji and symbol picker.*/
	MenuEmojiAndSymbol MenuItems = 30
	/*Represents the size of the [enum MenuItems] enum.*/
	MenuMax MenuItems = 31
)

type EditAction int //gd:TextEdit.EditAction

const (
	/*No current action.*/
	ActionNone EditAction = 0
	/*A typing action.*/
	ActionTyping EditAction = 1
	/*A backwards delete action.*/
	ActionBackspace EditAction = 2
	/*A forward delete action.*/
	ActionDelete EditAction = 3
)

type SearchFlags int //gd:TextEdit.SearchFlags

const (
	/*Match case when searching.*/
	SearchMatchCase SearchFlags = 1
	/*Match whole words when searching.*/
	SearchWholeWords SearchFlags = 2
	/*Search from end to beginning.*/
	SearchBackwards SearchFlags = 4
)

type CaretType int //gd:TextEdit.CaretType

const (
	/*Vertical line caret.*/
	CaretTypeLine CaretType = 0
	/*Block caret.*/
	CaretTypeBlock CaretType = 1
)

type SelectionMode int //gd:TextEdit.SelectionMode

const (
	/*Not selecting.*/
	SelectionModeNone SelectionMode = 0
	/*Select as if [code]shift[/code] is pressed.*/
	SelectionModeShift SelectionMode = 1
	/*Select single characters as if the user single clicked.*/
	SelectionModePointer SelectionMode = 2
	/*Select whole words as if the user double clicked.*/
	SelectionModeWord SelectionMode = 3
	/*Select whole lines as if the user triple clicked.*/
	SelectionModeLine SelectionMode = 4
)

type LineWrappingMode int //gd:TextEdit.LineWrappingMode

const (
	/*Line wrapping is disabled.*/
	LineWrappingNone LineWrappingMode = 0
	/*Line wrapping occurs at the control boundary, beyond what would normally be visible.*/
	LineWrappingBoundary LineWrappingMode = 1
)

type GutterType int //gd:TextEdit.GutterType

const (
	/*When a gutter is set to string using [method set_gutter_type], it is used to contain text set via the [method set_line_gutter_text] method.*/
	GutterTypeString GutterType = 0
	/*When a gutter is set to icon using [method set_gutter_type], it is used to contain an icon set via the [method set_line_gutter_icon] method.*/
	GutterTypeIcon GutterType = 1
	/*When a gutter is set to custom using [method set_gutter_type], it is used to contain custom visuals controlled by a callback method set via the [method set_gutter_custom_draw] method.*/
	GutterTypeCustom GutterType = 2
)
