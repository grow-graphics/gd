// Code generated by the generate package DO NOT EDIT

// Package UndoRedo provides methods for working with UndoRedo object instances.
package UndoRedo

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
UndoRedo works by registering methods and property changes inside "actions". You can create an action, then provide ways to do and undo this action using function calls and property changes, then commit the action.
When an action is committed, all of the [code]do_*[/code] methods will run. If the [method undo] method is used, the [code]undo_*[/code] methods will run. If the [method redo] method is used, once again, all of the [code]do_*[/code] methods will run.
Here's an example on how to add an action:
[codeblocks]
[gdscript]
var undo_redo = UndoRedo.new()

func do_something():

	pass # Put your code here.

func undo_something():

	pass # Put here the code that reverts what's done by "do_something()".

func _on_my_button_pressed():

	var node = get_node("MyNode2D")
	undo_redo.create_action("Move the node")
	undo_redo.add_do_method(do_something)
	undo_redo.add_undo_method(undo_something)
	undo_redo.add_do_property(node, "position", Vector2(100,100))
	undo_redo.add_undo_property(node, "position", node.position)
	undo_redo.commit_action()

[/gdscript]
[csharp]
private UndoRedo _undoRedo;

public override void _Ready()

	{
	    _undoRedo = new UndoRedo();
	}

public void DoSomething()

	{
	    // Put your code here.
	}

public void UndoSomething()

	{
	    // Put here the code that reverts what's done by "DoSomething()".
	}

private void OnMyButtonPressed()

	{
	    var node = GetNode<Node2D>("MyNode2D");
	    _undoRedo.CreateAction("Move the node");
	    _undoRedo.AddDoMethod(new Callable(this, MethodName.DoSomething));
	    _undoRedo.AddUndoMethod(new Callable(this, MethodName.UndoSomething));
	    _undoRedo.AddDoProperty(node, "position", new Vector2(100, 100));
	    _undoRedo.AddUndoProperty(node, "position", node.Position);
	    _undoRedo.CommitAction();
	}

[/csharp]
[/codeblocks]
Before calling any of the [code]add_(un)do_*[/code] methods, you need to first call [method create_action]. Afterwards you need to call [method commit_action].
If you don't need to register a method, you can leave [method add_do_method] and [method add_undo_method] out; the same goes for properties. You can also register more than one method/property.
If you are making an [EditorPlugin] and want to integrate into the editor's undo history, use [EditorUndoRedoManager] instead.
If you are registering multiple properties/method which depend on one another, be aware that by default undo operation are called in the same order they have been added. Therefore instead of grouping do operation with their undo operations it is better to group do on one side and undo on the other as shown below.
[codeblocks]
[gdscript]
undo_redo.create_action("Add object")

# DO
undo_redo.add_do_method(_create_object)
undo_redo.add_do_method(_add_object_to_singleton)

# UNDO
undo_redo.add_undo_method(_remove_object_from_singleton)
undo_redo.add_undo_method(_destroy_that_object)

undo_redo.commit_action()
[/gdscript]
[csharp]
_undo_redo.CreateAction("Add object");

// DO
_undo_redo.AddDoMethod(new Callable(this, MethodName.CreateObject));
_undo_redo.AddDoMethod(new Callable(this, MethodName.AddObjectToSingleton));

// UNDO
_undo_redo.AddUndoMethod(new Callable(this, MethodName.RemoveObjectFromSingleton));
_undo_redo.AddUndoMethod(new Callable(this, MethodName.DestroyThatObject));

_undo_redo.CommitAction();
[/csharp]
[/codeblocks]
*/
type Instance [1]gdclass.UndoRedo

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	create_action                  gdextension.MethodForClass `hash:"3171901514"`
	commit_action                  gdextension.MethodForClass `hash:"3216645846"`
	is_committing_action           gdextension.MethodForClass `hash:"36873697"`
	add_do_method                  gdextension.MethodForClass `hash:"1611583062"`
	add_undo_method                gdextension.MethodForClass `hash:"1611583062"`
	add_do_property                gdextension.MethodForClass `hash:"1017172818"`
	add_undo_property              gdextension.MethodForClass `hash:"1017172818"`
	add_do_reference               gdextension.MethodForClass `hash:"3975164845"`
	add_undo_reference             gdextension.MethodForClass `hash:"3975164845"`
	start_force_keep_in_merge_ends gdextension.MethodForClass `hash:"3218959716"`
	end_force_keep_in_merge_ends   gdextension.MethodForClass `hash:"3218959716"`
	get_history_count              gdextension.MethodForClass `hash:"2455072627"`
	get_current_action             gdextension.MethodForClass `hash:"2455072627"`
	get_action_name                gdextension.MethodForClass `hash:"990163283"`
	clear_history                  gdextension.MethodForClass `hash:"3216645846"`
	get_current_action_name        gdextension.MethodForClass `hash:"201670096"`
	has_undo                       gdextension.MethodForClass `hash:"36873697"`
	has_redo                       gdextension.MethodForClass `hash:"36873697"`
	get_version                    gdextension.MethodForClass `hash:"3905245786"`
	set_max_steps                  gdextension.MethodForClass `hash:"1286410249"`
	get_max_steps                  gdextension.MethodForClass `hash:"3905245786"`
	redo                           gdextension.MethodForClass `hash:"2240911060"`
	undo                           gdextension.MethodForClass `hash:"2240911060"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("UndoRedo")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		pointers.Raw[gd.StringName](sname).Free()
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

type Expanded [1]gdclass.UndoRedo

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsUndoRedo() Instance
}

/*
Create a new action. After this is called, do all your calls to [method add_do_method], [method add_undo_method], [method add_do_property], and [method add_undo_property], then commit the action with [method commit_action].
The way actions are merged is dictated by [param merge_mode]. See [enum MergeMode] for details.
The way undo operation are ordered in actions is dictated by [param backward_undo_ops]. When [param backward_undo_ops] is [code]false[/code] undo option are ordered in the same order they were added. Which means the first operation to be added will be the first to be undone.
*/
func (self Instance) CreateAction(name string) { //gd:UndoRedo.create_action
	Advanced(self).CreateAction(String.New(name), 0, false)
}

/*
Create a new action. After this is called, do all your calls to [method add_do_method], [method add_undo_method], [method add_do_property], and [method add_undo_property], then commit the action with [method commit_action].
The way actions are merged is dictated by [param merge_mode]. See [enum MergeMode] for details.
The way undo operation are ordered in actions is dictated by [param backward_undo_ops]. When [param backward_undo_ops] is [code]false[/code] undo option are ordered in the same order they were added. Which means the first operation to be added will be the first to be undone.
*/
func (self Expanded) CreateAction(name string, merge_mode MergeMode, backward_undo_ops bool) { //gd:UndoRedo.create_action
	Advanced(self).CreateAction(String.New(name), merge_mode, backward_undo_ops)
}

/*
Commit the action. If [param execute] is [code]true[/code] (which it is by default), all "do" methods/properties are called/set when this function is called.
*/
func (self Instance) CommitAction() { //gd:UndoRedo.commit_action
	Advanced(self).CommitAction(true)
}

/*
Commit the action. If [param execute] is [code]true[/code] (which it is by default), all "do" methods/properties are called/set when this function is called.
*/
func (self Expanded) CommitAction(execute bool) { //gd:UndoRedo.commit_action
	Advanced(self).CommitAction(execute)
}

/*
Returns [code]true[/code] if the [UndoRedo] is currently committing the action, i.e. running its "do" method or property change (see [method commit_action]).
*/
func (self Instance) IsCommittingAction() bool { //gd:UndoRedo.is_committing_action
	return bool(Advanced(self).IsCommittingAction())
}

/*
Register a [Callable] that will be called when the action is committed.
*/
func (self Instance) AddDoMethod(callable func()) { //gd:UndoRedo.add_do_method
	Advanced(self).AddDoMethod(Callable.New(callable))
}

/*
Register a [Callable] that will be called when the action is undone.
*/
func (self Instance) AddUndoMethod(callable func()) { //gd:UndoRedo.add_undo_method
	Advanced(self).AddUndoMethod(Callable.New(callable))
}

/*
Register a [param property] that would change its value to [param value] when the action is committed.
*/
func (self Instance) AddDoProperty(obj Object.Instance, property string, value any) { //gd:UndoRedo.add_do_property
	Advanced(self).AddDoProperty(obj, String.Name(String.New(property)), variant.New(value))
}

/*
Register a [param property] that would change its value to [param value] when the action is undone.
*/
func (self Instance) AddUndoProperty(obj Object.Instance, property string, value any) { //gd:UndoRedo.add_undo_property
	Advanced(self).AddUndoProperty(obj, String.Name(String.New(property)), variant.New(value))
}

/*
Register a reference to an object that will be erased if the "do" history is deleted. This is useful for objects added by the "do" action and removed by the "undo" action.
When the "do" history is deleted, if the object is a [RefCounted], it will be unreferenced. Otherwise, it will be freed. Do not use for resources.
[codeblock]
var node = Node2D.new()
undo_redo.create_action("Add node")
undo_redo.add_do_method(add_child.bind(node))
undo_redo.add_do_reference(node)
undo_redo.add_undo_method(remove_child.bind(node))
undo_redo.commit_action()
[/codeblock]
*/
func (self Instance) AddDoReference(obj Object.Instance) { //gd:UndoRedo.add_do_reference
	Advanced(self).AddDoReference(obj)
}

/*
Register a reference to an object that will be erased if the "undo" history is deleted. This is useful for objects added by the "undo" action and removed by the "do" action.
When the "undo" history is deleted, if the object is a [RefCounted], it will be unreferenced. Otherwise, it will be freed. Do not use for resources.
[codeblock]
var node = $Node2D
undo_redo.create_action("Remove node")
undo_redo.add_do_method(remove_child.bind(node))
undo_redo.add_undo_method(add_child.bind(node))
undo_redo.add_undo_reference(node)
undo_redo.commit_action()
[/codeblock]
*/
func (self Instance) AddUndoReference(obj Object.Instance) { //gd:UndoRedo.add_undo_reference
	Advanced(self).AddUndoReference(obj)
}

/*
Marks the next "do" and "undo" operations to be processed even if the action gets merged with another in the [constant MERGE_ENDS] mode. Return to normal operation using [method end_force_keep_in_merge_ends].
*/
func (self Instance) StartForceKeepInMergeEnds() { //gd:UndoRedo.start_force_keep_in_merge_ends
	Advanced(self).StartForceKeepInMergeEnds()
}

/*
Stops marking operations as to be processed even if the action gets merged with another in the [constant MERGE_ENDS] mode. See [method start_force_keep_in_merge_ends].
*/
func (self Instance) EndForceKeepInMergeEnds() { //gd:UndoRedo.end_force_keep_in_merge_ends
	Advanced(self).EndForceKeepInMergeEnds()
}

/*
Returns how many elements are in the history.
*/
func (self Instance) GetHistoryCount() int { //gd:UndoRedo.get_history_count
	return int(int(Advanced(self).GetHistoryCount()))
}

/*
Gets the index of the current action.
*/
func (self Instance) GetCurrentAction() int { //gd:UndoRedo.get_current_action
	return int(int(Advanced(self).GetCurrentAction()))
}

/*
Gets the action name from its index.
*/
func (self Instance) GetActionName(id int) string { //gd:UndoRedo.get_action_name
	return string(Advanced(self).GetActionName(int64(id)).String())
}

/*
Clear the undo/redo history and associated references.
Passing [code]false[/code] to [param increase_version] will prevent the version number from increasing when the history is cleared.
*/
func (self Instance) ClearHistory() { //gd:UndoRedo.clear_history
	Advanced(self).ClearHistory(true)
}

/*
Clear the undo/redo history and associated references.
Passing [code]false[/code] to [param increase_version] will prevent the version number from increasing when the history is cleared.
*/
func (self Expanded) ClearHistory(increase_version bool) { //gd:UndoRedo.clear_history
	Advanced(self).ClearHistory(increase_version)
}

/*
Gets the name of the current action, equivalent to [code]get_action_name(get_current_action())[/code].
*/
func (self Instance) GetCurrentActionName() string { //gd:UndoRedo.get_current_action_name
	return string(Advanced(self).GetCurrentActionName().String())
}

/*
Returns [code]true[/code] if an "undo" action is available.
*/
func (self Instance) HasUndo() bool { //gd:UndoRedo.has_undo
	return bool(Advanced(self).HasUndo())
}

/*
Returns [code]true[/code] if a "redo" action is available.
*/
func (self Instance) HasRedo() bool { //gd:UndoRedo.has_redo
	return bool(Advanced(self).HasRedo())
}

/*
Gets the version. Every time a new action is committed, the [UndoRedo]'s version number is increased automatically.
This is useful mostly to check if something changed from a saved version.
*/
func (self Instance) GetVersion() int { //gd:UndoRedo.get_version
	return int(int(Advanced(self).GetVersion()))
}

/*
Redo the last action.
*/
func (self Instance) Redo() bool { //gd:UndoRedo.redo
	return bool(Advanced(self).Redo())
}

/*
Undo the last action.
*/
func (self Instance) Undo() bool { //gd:UndoRedo.undo
	return bool(Advanced(self).Undo())
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.UndoRedo

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.UndoRedo)(unsafe.Pointer(&obj))
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.UndoRedo)(unsafe.Pointer(&obj))
		return true
	}
	return false
}

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {

	if !gd.Linked {
		var placeholder Instance
		*(*gd.Object)(unsafe.Pointer(&placeholder)) = pointers.Add[gd.Object]([3]uint64{})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(*(*gd.Object)(unsafe.Pointer(&placeholder)), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	object := [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})}
	casted := Instance{*(*gdclass.UndoRedo)(unsafe.Pointer(&object))}
	object[0].Notification(0, false)
	return casted
}

func (self Instance) MaxSteps() int {
	return int(int(class(self).GetMaxSteps()))
}

func (self Instance) SetMaxSteps(value int) {
	class(self).SetMaxSteps(int64(value))
}

/*
Create a new action. After this is called, do all your calls to [method add_do_method], [method add_undo_method], [method add_do_property], and [method add_undo_property], then commit the action with [method commit_action].
The way actions are merged is dictated by [param merge_mode]. See [enum MergeMode] for details.
The way undo operation are ordered in actions is dictated by [param backward_undo_ops]. When [param backward_undo_ops] is [code]false[/code] undo option are ordered in the same order they were added. Which means the first operation to be added will be the first to be undone.
*/
//go:nosplit
func (self class) CreateAction(name String.Readable, merge_mode MergeMode, backward_undo_ops bool) { //gd:UndoRedo.create_action
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.create_action, 0|(gdextension.SizeString<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeBool<<12), unsafe.Pointer(&struct {
		name              gdextension.String
		merge_mode        MergeMode
		backward_undo_ops bool
	}{pointers.Get(gd.InternalString(name)), merge_mode, backward_undo_ops}))
}

/*
Commit the action. If [param execute] is [code]true[/code] (which it is by default), all "do" methods/properties are called/set when this function is called.
*/
//go:nosplit
func (self class) CommitAction(execute bool) { //gd:UndoRedo.commit_action
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.commit_action, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ execute bool }{execute}))
}

/*
Returns [code]true[/code] if the [UndoRedo] is currently committing the action, i.e. running its "do" method or property change (see [method commit_action]).
*/
//go:nosplit
func (self class) IsCommittingAction() bool { //gd:UndoRedo.is_committing_action
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_committing_action, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Register a [Callable] that will be called when the action is committed.
*/
//go:nosplit
func (self class) AddDoMethod(callable Callable.Function) { //gd:UndoRedo.add_do_method
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_do_method, 0|(gdextension.SizeCallable<<4), unsafe.Pointer(&struct{ callable gdextension.Callable }{pointers.Get(gd.InternalCallable(callable))}))
}

/*
Register a [Callable] that will be called when the action is undone.
*/
//go:nosplit
func (self class) AddUndoMethod(callable Callable.Function) { //gd:UndoRedo.add_undo_method
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_undo_method, 0|(gdextension.SizeCallable<<4), unsafe.Pointer(&struct{ callable gdextension.Callable }{pointers.Get(gd.InternalCallable(callable))}))
}

/*
Register a [param property] that would change its value to [param value] when the action is committed.
*/
//go:nosplit
func (self class) AddDoProperty(obj [1]gd.Object, property String.Name, value variant.Any) { //gd:UndoRedo.add_do_property
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_do_property, 0|(gdextension.SizeObject<<4)|(gdextension.SizeStringName<<8)|(gdextension.SizeVariant<<12), unsafe.Pointer(&struct {
		obj      gdextension.Object
		property gdextension.StringName
		value    gdextension.Variant
	}{gdextension.Object(gd.PointerWithOwnershipTransferredToGodot(obj[0].AsObject()[0])), pointers.Get(gd.InternalStringName(property)), gdextension.Variant(pointers.Get(gd.InternalVariant(value)))}))
}

/*
Register a [param property] that would change its value to [param value] when the action is undone.
*/
//go:nosplit
func (self class) AddUndoProperty(obj [1]gd.Object, property String.Name, value variant.Any) { //gd:UndoRedo.add_undo_property
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_undo_property, 0|(gdextension.SizeObject<<4)|(gdextension.SizeStringName<<8)|(gdextension.SizeVariant<<12), unsafe.Pointer(&struct {
		obj      gdextension.Object
		property gdextension.StringName
		value    gdextension.Variant
	}{gdextension.Object(gd.PointerWithOwnershipTransferredToGodot(obj[0].AsObject()[0])), pointers.Get(gd.InternalStringName(property)), gdextension.Variant(pointers.Get(gd.InternalVariant(value)))}))
}

/*
Register a reference to an object that will be erased if the "do" history is deleted. This is useful for objects added by the "do" action and removed by the "undo" action.
When the "do" history is deleted, if the object is a [RefCounted], it will be unreferenced. Otherwise, it will be freed. Do not use for resources.
[codeblock]
var node = Node2D.new()
undo_redo.create_action("Add node")
undo_redo.add_do_method(add_child.bind(node))
undo_redo.add_do_reference(node)
undo_redo.add_undo_method(remove_child.bind(node))
undo_redo.commit_action()
[/codeblock]
*/
//go:nosplit
func (self class) AddDoReference(obj [1]gd.Object) { //gd:UndoRedo.add_do_reference
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_do_reference, 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ obj gdextension.Object }{gdextension.Object(gd.PointerWithOwnershipTransferredToGodot(obj[0].AsObject()[0]))}))
}

/*
Register a reference to an object that will be erased if the "undo" history is deleted. This is useful for objects added by the "undo" action and removed by the "do" action.
When the "undo" history is deleted, if the object is a [RefCounted], it will be unreferenced. Otherwise, it will be freed. Do not use for resources.
[codeblock]
var node = $Node2D
undo_redo.create_action("Remove node")
undo_redo.add_do_method(remove_child.bind(node))
undo_redo.add_undo_method(add_child.bind(node))
undo_redo.add_undo_reference(node)
undo_redo.commit_action()
[/codeblock]
*/
//go:nosplit
func (self class) AddUndoReference(obj [1]gd.Object) { //gd:UndoRedo.add_undo_reference
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_undo_reference, 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ obj gdextension.Object }{gdextension.Object(gd.PointerWithOwnershipTransferredToGodot(obj[0].AsObject()[0]))}))
}

/*
Marks the next "do" and "undo" operations to be processed even if the action gets merged with another in the [constant MERGE_ENDS] mode. Return to normal operation using [method end_force_keep_in_merge_ends].
*/
//go:nosplit
func (self class) StartForceKeepInMergeEnds() { //gd:UndoRedo.start_force_keep_in_merge_ends
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.start_force_keep_in_merge_ends, 0, unsafe.Pointer(&struct{}{}))
}

/*
Stops marking operations as to be processed even if the action gets merged with another in the [constant MERGE_ENDS] mode. See [method start_force_keep_in_merge_ends].
*/
//go:nosplit
func (self class) EndForceKeepInMergeEnds() { //gd:UndoRedo.end_force_keep_in_merge_ends
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.end_force_keep_in_merge_ends, 0, unsafe.Pointer(&struct{}{}))
}

/*
Returns how many elements are in the history.
*/
//go:nosplit
func (self class) GetHistoryCount() int64 { //gd:UndoRedo.get_history_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_history_count, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Gets the index of the current action.
*/
//go:nosplit
func (self class) GetCurrentAction() int64 { //gd:UndoRedo.get_current_action
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_current_action, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Gets the action name from its index.
*/
//go:nosplit
func (self class) GetActionName(id int64) String.Readable { //gd:UndoRedo.get_action_name
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_action_name, gdextension.SizeString|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ id int64 }{id}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Clear the undo/redo history and associated references.
Passing [code]false[/code] to [param increase_version] will prevent the version number from increasing when the history is cleared.
*/
//go:nosplit
func (self class) ClearHistory(increase_version bool) { //gd:UndoRedo.clear_history
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.clear_history, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ increase_version bool }{increase_version}))
}

/*
Gets the name of the current action, equivalent to [code]get_action_name(get_current_action())[/code].
*/
//go:nosplit
func (self class) GetCurrentActionName() String.Readable { //gd:UndoRedo.get_current_action_name
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_current_action_name, gdextension.SizeString, unsafe.Pointer(&struct{}{}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Returns [code]true[/code] if an "undo" action is available.
*/
//go:nosplit
func (self class) HasUndo() bool { //gd:UndoRedo.has_undo
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.has_undo, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if a "redo" action is available.
*/
//go:nosplit
func (self class) HasRedo() bool { //gd:UndoRedo.has_redo
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.has_redo, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Gets the version. Every time a new action is committed, the [UndoRedo]'s version number is increased automatically.
This is useful mostly to check if something changed from a saved version.
*/
//go:nosplit
func (self class) GetVersion() int64 { //gd:UndoRedo.get_version
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_version, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetMaxSteps(max_steps int64) { //gd:UndoRedo.set_max_steps
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_max_steps, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ max_steps int64 }{max_steps}))
}

//go:nosplit
func (self class) GetMaxSteps() int64 { //gd:UndoRedo.get_max_steps
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_max_steps, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Redo the last action.
*/
//go:nosplit
func (self class) Redo() bool { //gd:UndoRedo.redo
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.redo, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Undo the last action.
*/
//go:nosplit
func (self class) Undo() bool { //gd:UndoRedo.undo
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.undo, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}
func (self Instance) OnVersionChanged(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("version_changed"), gd.NewCallable(cb), 0)
}

func (self class) AsUndoRedo() Advanced         { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsUndoRedo() Instance      { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsUndoRedo() Instance { return self.Super().AsUndoRedo() }

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Object.Advanced(self.AsObject()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Object.Instance(self.AsObject()), name)
	}
}
func init() {
	gdclass.Register("UndoRedo", func(ptr gd.Object) any { return *(*Instance)(unsafe.Pointer(&ptr)) })
}

type MergeMode int //gd:UndoRedo.MergeMode

const (
	/*Makes "do"/"undo" operations stay in separate actions.*/
	MergeDisable MergeMode = 0
	/*Merges this action with the previous one if they have the same name. Keeps only the first action's "undo" operations and the last action's "do" operations. Useful for sequential changes to a single value.*/
	MergeEnds MergeMode = 1
	/*Merges this action with the previous one if they have the same name.*/
	MergeAll MergeMode = 2
)
