// Code generated by the generate package DO NOT EDIT

// Package AudioStreamSynchronized provides methods for working with AudioStreamSynchronized object instances.
package AudioStreamSynchronized

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/AudioStream"
import "graphics.gd/classdb/Resource"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
This is a stream that can be fitted with sub-streams, which will be played in-sync. The streams begin at exactly the same time when play is pressed, and will end when the last of them ends. If one of the sub-streams loops, then playback will continue.
*/
type Instance [1]gdclass.AudioStreamSynchronized

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	set_stream_count       gdextension.MethodForClass `hash:"1286410249"`
	get_stream_count       gdextension.MethodForClass `hash:"3905245786"`
	set_sync_stream        gdextension.MethodForClass `hash:"111075094"`
	get_sync_stream        gdextension.MethodForClass `hash:"2739380747"`
	set_sync_stream_volume gdextension.MethodForClass `hash:"1602489585"`
	get_sync_stream_volume gdextension.MethodForClass `hash:"2339986948"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("AudioStreamSynchronized")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		pointers.Raw[gd.StringName](sname).Free()
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsAudioStreamSynchronized() Instance
}

/*
Set one of the synchronized streams, by index.
*/
func (self Instance) SetSyncStream(stream_index int, audio_stream AudioStream.Instance) { //gd:AudioStreamSynchronized.set_sync_stream
	Advanced(self).SetSyncStream(int64(stream_index), audio_stream)
}

/*
Get one of the synchronized streams, by index.
*/
func (self Instance) GetSyncStream(stream_index int) AudioStream.Instance { //gd:AudioStreamSynchronized.get_sync_stream
	return AudioStream.Instance(Advanced(self).GetSyncStream(int64(stream_index)))
}

/*
Set the volume of one of the synchronized streams, by index.
*/
func (self Instance) SetSyncStreamVolume(stream_index int, volume_db Float.X) { //gd:AudioStreamSynchronized.set_sync_stream_volume
	Advanced(self).SetSyncStreamVolume(int64(stream_index), float64(volume_db))
}

/*
Get the volume of one of the synchronized streams, by index.
*/
func (self Instance) GetSyncStreamVolume(stream_index int) Float.X { //gd:AudioStreamSynchronized.get_sync_stream_volume
	return Float.X(Float.X(Advanced(self).GetSyncStreamVolume(int64(stream_index))))
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.AudioStreamSynchronized

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.AudioStreamSynchronized)(unsafe.Pointer(&obj))
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.AudioStreamSynchronized)(unsafe.Pointer(&obj))
		return true
	}
	return false
}

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {
	object := [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})}
	casted := Instance{*(*gdclass.AudioStreamSynchronized)(unsafe.Pointer(&object))}
	casted.AsRefCounted()[0].Reference()
	object[0].Notification(0, false)
	return casted
}

func (self Instance) StreamCount() int {
	return int(int(class(self).GetStreamCount()))
}

func (self Instance) SetStreamCount(value int) {
	class(self).SetStreamCount(int64(value))
}

//go:nosplit
func (self class) SetStreamCount(stream_count int64) { //gd:AudioStreamSynchronized.set_stream_count
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_stream_count, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ stream_count int64 }{stream_count}))
}

//go:nosplit
func (self class) GetStreamCount() int64 { //gd:AudioStreamSynchronized.get_stream_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_stream_count, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Set one of the synchronized streams, by index.
*/
//go:nosplit
func (self class) SetSyncStream(stream_index int64, audio_stream [1]gdclass.AudioStream) { //gd:AudioStreamSynchronized.set_sync_stream
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_sync_stream, 0|(gdextension.SizeInt<<4)|(gdextension.SizeObject<<8), unsafe.Pointer(&struct {
		stream_index int64
		audio_stream gdextension.Object
	}{stream_index, gdextension.Object(gd.ObjectChecked(audio_stream[0].AsObject()))}))
}

/*
Get one of the synchronized streams, by index.
*/
//go:nosplit
func (self class) GetSyncStream(stream_index int64) [1]gdclass.AudioStream { //gd:AudioStreamSynchronized.get_sync_stream
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_sync_stream, gdextension.SizeObject|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ stream_index int64 }{stream_index}))
	var ret = [1]gdclass.AudioStream{gd.PointerWithOwnershipTransferredToGo[gdclass.AudioStream](r_ret)}
	return ret
}

/*
Set the volume of one of the synchronized streams, by index.
*/
//go:nosplit
func (self class) SetSyncStreamVolume(stream_index int64, volume_db float64) { //gd:AudioStreamSynchronized.set_sync_stream_volume
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_sync_stream_volume, 0|(gdextension.SizeInt<<4)|(gdextension.SizeFloat<<8), unsafe.Pointer(&struct {
		stream_index int64
		volume_db    float64
	}{stream_index, volume_db}))
}

/*
Get the volume of one of the synchronized streams, by index.
*/
//go:nosplit
func (self class) GetSyncStreamVolume(stream_index int64) float64 { //gd:AudioStreamSynchronized.get_sync_stream_volume
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_sync_stream_volume, gdextension.SizeFloat|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ stream_index int64 }{stream_index}))
	var ret = r_ret
	return ret
}
func (self class) AsAudioStreamSynchronized() Advanced { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsAudioStreamSynchronized() Instance {
	return *((*Instance)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsAudioStreamSynchronized() Instance {
	return self.Super().AsAudioStreamSynchronized()
}
func (self class) AsAudioStream() AudioStream.Advanced {
	return *((*AudioStream.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsAudioStream() AudioStream.Instance { return self.Super().AsAudioStream() }
func (self Instance) AsAudioStream() AudioStream.Instance {
	return *((*AudioStream.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsResource() Resource.Advanced {
	return *((*Resource.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsResource() Resource.Instance { return self.Super().AsResource() }
func (self Instance) AsResource() Resource.Instance {
	return *((*Resource.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsRefCounted() [1]gd.RefCounted { return self.Super().AsRefCounted() }
func (self Instance) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(AudioStream.Advanced(self.AsAudioStream()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(AudioStream.Instance(self.AsAudioStream()), name)
	}
}
func init() {
	gdclass.Register("AudioStreamSynchronized", func(ptr gd.Object) any { return *(*Instance)(unsafe.Pointer(&ptr)) })
}

const MaxStreams int = 32 //gd:AudioStreamSynchronized.MAX_STREAMS
