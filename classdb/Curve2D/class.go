// Code generated by the generate package DO NOT EDIT

// Package Curve2D provides methods for working with Curve2D object instances.
package Curve2D

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/Resource"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"
import "graphics.gd/variant/Transform2D"
import "graphics.gd/variant/Vector2"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
This class describes a BÃ©zier curve in 2D space. It is mainly used to give a shape to a [Path2D], but can be manually sampled for other purposes.
It keeps a cache of precalculated points along the curve, to speed up further calculations.
*/
type Instance [1]gdclass.Curve2D

func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

type Expanded [1]gdclass.Curve2D

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsCurve2D() Instance
}

/*
Adds a point with the specified [param position] relative to the curve's own position, with control points [param in] and [param out]. Appends the new point at the end of the point list.
If [param index] is given, the new point is inserted before the existing point identified by index [param index]. Every existing point starting from [param index] is shifted further down the list of points. The index must be greater than or equal to [code]0[/code] and must not exceed the number of existing points in the line. See [member point_count].
*/
func (self Instance) AddPoint(position Vector2.XY) { //gd:Curve2D.add_point
	Advanced(self).AddPoint(Vector2.XY(position), Vector2.XY(gd.Vector2{0, 0}), Vector2.XY(gd.Vector2{0, 0}), int64(-1))
}

/*
Adds a point with the specified [param position] relative to the curve's own position, with control points [param in] and [param out]. Appends the new point at the end of the point list.
If [param index] is given, the new point is inserted before the existing point identified by index [param index]. Every existing point starting from [param index] is shifted further down the list of points. The index must be greater than or equal to [code]0[/code] and must not exceed the number of existing points in the line. See [member point_count].
*/
func (self Expanded) AddPoint(position Vector2.XY, in Vector2.XY, out Vector2.XY, index int) { //gd:Curve2D.add_point
	Advanced(self).AddPoint(Vector2.XY(position), Vector2.XY(in), Vector2.XY(out), int64(index))
}

/*
Sets the position for the vertex [param idx]. If the index is out of bounds, the function sends an error to the console.
*/
func (self Instance) SetPointPosition(idx int, position Vector2.XY) { //gd:Curve2D.set_point_position
	Advanced(self).SetPointPosition(int64(idx), Vector2.XY(position))
}

/*
Returns the position of the vertex [param idx]. If the index is out of bounds, the function sends an error to the console, and returns [code](0, 0)[/code].
*/
func (self Instance) GetPointPosition(idx int) Vector2.XY { //gd:Curve2D.get_point_position
	return Vector2.XY(Advanced(self).GetPointPosition(int64(idx)))
}

/*
Sets the position of the control point leading to the vertex [param idx]. If the index is out of bounds, the function sends an error to the console. The position is relative to the vertex.
*/
func (self Instance) SetPointIn(idx int, position Vector2.XY) { //gd:Curve2D.set_point_in
	Advanced(self).SetPointIn(int64(idx), Vector2.XY(position))
}

/*
Returns the position of the control point leading to the vertex [param idx]. The returned position is relative to the vertex [param idx]. If the index is out of bounds, the function sends an error to the console, and returns [code](0, 0)[/code].
*/
func (self Instance) GetPointIn(idx int) Vector2.XY { //gd:Curve2D.get_point_in
	return Vector2.XY(Advanced(self).GetPointIn(int64(idx)))
}

/*
Sets the position of the control point leading out of the vertex [param idx]. If the index is out of bounds, the function sends an error to the console. The position is relative to the vertex.
*/
func (self Instance) SetPointOut(idx int, position Vector2.XY) { //gd:Curve2D.set_point_out
	Advanced(self).SetPointOut(int64(idx), Vector2.XY(position))
}

/*
Returns the position of the control point leading out of the vertex [param idx]. The returned position is relative to the vertex [param idx]. If the index is out of bounds, the function sends an error to the console, and returns [code](0, 0)[/code].
*/
func (self Instance) GetPointOut(idx int) Vector2.XY { //gd:Curve2D.get_point_out
	return Vector2.XY(Advanced(self).GetPointOut(int64(idx)))
}

/*
Deletes the point [param idx] from the curve. Sends an error to the console if [param idx] is out of bounds.
*/
func (self Instance) RemovePoint(idx int) { //gd:Curve2D.remove_point
	Advanced(self).RemovePoint(int64(idx))
}

/*
Removes all points from the curve.
*/
func (self Instance) ClearPoints() { //gd:Curve2D.clear_points
	Advanced(self).ClearPoints()
}

/*
Returns the position between the vertex [param idx] and the vertex [code]idx + 1[/code], where [param t] controls if the point is the first vertex ([code]t = 0.0[/code]), the last vertex ([code]t = 1.0[/code]), or in between. Values of [param t] outside the range ([code]0.0 <= t <= 1.0[/code]) give strange, but predictable results.
If [param idx] is out of bounds it is truncated to the first or last vertex, and [param t] is ignored. If the curve has no points, the function sends an error to the console, and returns [code](0, 0)[/code].
*/
func (self Instance) Sample(idx int, t Float.X) Vector2.XY { //gd:Curve2D.sample
	return Vector2.XY(Advanced(self).Sample(int64(idx), float64(t)))
}

/*
Returns the position at the vertex [param fofs]. It calls [method sample] using the integer part of [param fofs] as [code]idx[/code], and its fractional part as [code]t[/code].
*/
func (self Instance) Samplef(fofs Float.X) Vector2.XY { //gd:Curve2D.samplef
	return Vector2.XY(Advanced(self).Samplef(float64(fofs)))
}

/*
Returns the total length of the curve, based on the cached points. Given enough density (see [member bake_interval]), it should be approximate enough.
*/
func (self Instance) GetBakedLength() Float.X { //gd:Curve2D.get_baked_length
	return Float.X(Float.X(Advanced(self).GetBakedLength()))
}

/*
Returns a point within the curve at position [param offset], where [param offset] is measured as a pixel distance along the curve.
To do that, it finds the two cached points where the [param offset] lies between, then interpolates the values. This interpolation is cubic if [param cubic] is set to [code]true[/code], or linear if set to [code]false[/code].
Cubic interpolation tends to follow the curves better, but linear is faster (and often, precise enough).
*/
func (self Instance) SampleBaked() Vector2.XY { //gd:Curve2D.sample_baked
	return Vector2.XY(Advanced(self).SampleBaked(float64(0.0), false))
}

/*
Returns a point within the curve at position [param offset], where [param offset] is measured as a pixel distance along the curve.
To do that, it finds the two cached points where the [param offset] lies between, then interpolates the values. This interpolation is cubic if [param cubic] is set to [code]true[/code], or linear if set to [code]false[/code].
Cubic interpolation tends to follow the curves better, but linear is faster (and often, precise enough).
*/
func (self Expanded) SampleBaked(offset Float.X, cubic bool) Vector2.XY { //gd:Curve2D.sample_baked
	return Vector2.XY(Advanced(self).SampleBaked(float64(offset), cubic))
}

/*
Similar to [method sample_baked], but returns [Transform2D] that includes a rotation along the curve, with [member Transform2D.origin] as the point position and the [member Transform2D.x] vector pointing in the direction of the path at that point. Returns an empty transform if the length of the curve is [code]0[/code].
[codeblock]
var baked = curve.sample_baked_with_rotation(offset)
# The returned Transform2D can be set directly.
transform = baked
# You can also read the origin and rotation separately from the returned Transform2D.
position = baked.get_origin()
rotation = baked.get_rotation()
[/codeblock]
*/
func (self Instance) SampleBakedWithRotation() Transform2D.OriginXY { //gd:Curve2D.sample_baked_with_rotation
	return Transform2D.OriginXY(Advanced(self).SampleBakedWithRotation(float64(0.0), false))
}

/*
Similar to [method sample_baked], but returns [Transform2D] that includes a rotation along the curve, with [member Transform2D.origin] as the point position and the [member Transform2D.x] vector pointing in the direction of the path at that point. Returns an empty transform if the length of the curve is [code]0[/code].
[codeblock]
var baked = curve.sample_baked_with_rotation(offset)
# The returned Transform2D can be set directly.
transform = baked
# You can also read the origin and rotation separately from the returned Transform2D.
position = baked.get_origin()
rotation = baked.get_rotation()
[/codeblock]
*/
func (self Expanded) SampleBakedWithRotation(offset Float.X, cubic bool) Transform2D.OriginXY { //gd:Curve2D.sample_baked_with_rotation
	return Transform2D.OriginXY(Advanced(self).SampleBakedWithRotation(float64(offset), cubic))
}

/*
Returns the cache of points as a [PackedVector2Array].
*/
func (self Instance) GetBakedPoints() []Vector2.XY { //gd:Curve2D.get_baked_points
	return []Vector2.XY(slices.Collect(Advanced(self).GetBakedPoints().Values()))
}

/*
Returns the closest point on baked segments (in curve's local space) to [param to_point].
[param to_point] must be in this curve's local space.
*/
func (self Instance) GetClosestPoint(to_point Vector2.XY) Vector2.XY { //gd:Curve2D.get_closest_point
	return Vector2.XY(Advanced(self).GetClosestPoint(Vector2.XY(to_point)))
}

/*
Returns the closest offset to [param to_point]. This offset is meant to be used in [method sample_baked].
[param to_point] must be in this curve's local space.
*/
func (self Instance) GetClosestOffset(to_point Vector2.XY) Float.X { //gd:Curve2D.get_closest_offset
	return Float.X(Float.X(Advanced(self).GetClosestOffset(Vector2.XY(to_point))))
}

/*
Returns a list of points along the curve, with a curvature controlled point density. That is, the curvier parts will have more points than the straighter parts.
This approximation makes straight segments between each point, then subdivides those segments until the resulting shape is similar enough.
[param max_stages] controls how many subdivisions a curve segment may face before it is considered approximate enough. Each subdivision splits the segment in half, so the default 5 stages may mean up to 32 subdivisions per curve segment. Increase with care!
[param tolerance_degrees] controls how many degrees the midpoint of a segment may deviate from the real curve, before the segment has to be subdivided.
*/
func (self Instance) Tessellate() []Vector2.XY { //gd:Curve2D.tessellate
	return []Vector2.XY(slices.Collect(Advanced(self).Tessellate(int64(5), float64(4)).Values()))
}

/*
Returns a list of points along the curve, with a curvature controlled point density. That is, the curvier parts will have more points than the straighter parts.
This approximation makes straight segments between each point, then subdivides those segments until the resulting shape is similar enough.
[param max_stages] controls how many subdivisions a curve segment may face before it is considered approximate enough. Each subdivision splits the segment in half, so the default 5 stages may mean up to 32 subdivisions per curve segment. Increase with care!
[param tolerance_degrees] controls how many degrees the midpoint of a segment may deviate from the real curve, before the segment has to be subdivided.
*/
func (self Expanded) Tessellate(max_stages int, tolerance_degrees Float.X) []Vector2.XY { //gd:Curve2D.tessellate
	return []Vector2.XY(slices.Collect(Advanced(self).Tessellate(int64(max_stages), float64(tolerance_degrees)).Values()))
}

/*
Returns a list of points along the curve, with almost uniform density. [param max_stages] controls how many subdivisions a curve segment may face before it is considered approximate enough. Each subdivision splits the segment in half, so the default 5 stages may mean up to 32 subdivisions per curve segment. Increase with care!
[param tolerance_length] controls the maximal distance between two neighboring points, before the segment has to be subdivided.
*/
func (self Instance) TessellateEvenLength() []Vector2.XY { //gd:Curve2D.tessellate_even_length
	return []Vector2.XY(slices.Collect(Advanced(self).TessellateEvenLength(int64(5), float64(20.0)).Values()))
}

/*
Returns a list of points along the curve, with almost uniform density. [param max_stages] controls how many subdivisions a curve segment may face before it is considered approximate enough. Each subdivision splits the segment in half, so the default 5 stages may mean up to 32 subdivisions per curve segment. Increase with care!
[param tolerance_length] controls the maximal distance between two neighboring points, before the segment has to be subdivided.
*/
func (self Expanded) TessellateEvenLength(max_stages int, tolerance_length Float.X) []Vector2.XY { //gd:Curve2D.tessellate_even_length
	return []Vector2.XY(slices.Collect(Advanced(self).TessellateEvenLength(int64(max_stages), float64(tolerance_length)).Values()))
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.Curve2D

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {
	object := gd.Global.ClassDB.ConstructObject(gd.NewStringName("Curve2D"))
	casted := Instance{*(*gdclass.Curve2D)(unsafe.Pointer(&object))}
	casted.AsRefCounted()[0].Reference()
	return casted
}

func (self Instance) BakeInterval() Float.X {
	return Float.X(Float.X(class(self).GetBakeInterval()))
}

func (self Instance) SetBakeInterval(value Float.X) {
	class(self).SetBakeInterval(float64(value))
}

func (self Instance) PointCount() int {
	return int(int(class(self).GetPointCount()))
}

func (self Instance) SetPointCount(value int) {
	class(self).SetPointCount(int64(value))
}

//go:nosplit
func (self class) GetPointCount() int64 { //gd:Curve2D.get_point_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Curve2D.Bind_get_point_count), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetPointCount(count int64) { //gd:Curve2D.set_point_count
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Curve2D.Bind_set_point_count), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ count int64 }{count}))
}

/*
Adds a point with the specified [param position] relative to the curve's own position, with control points [param in] and [param out]. Appends the new point at the end of the point list.
If [param index] is given, the new point is inserted before the existing point identified by index [param index]. Every existing point starting from [param index] is shifted further down the list of points. The index must be greater than or equal to [code]0[/code] and must not exceed the number of existing points in the line. See [member point_count].
*/
//go:nosplit
func (self class) AddPoint(position Vector2.XY, in Vector2.XY, out Vector2.XY, index int64) { //gd:Curve2D.add_point
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Curve2D.Bind_add_point), 0|(gdextension.SizeVector2<<4)|(gdextension.SizeVector2<<8)|(gdextension.SizeVector2<<12)|(gdextension.SizeInt<<16), unsafe.Pointer(&struct {
		position Vector2.XY
		in       Vector2.XY
		out      Vector2.XY
		index    int64
	}{position, in, out, index}))
}

/*
Sets the position for the vertex [param idx]. If the index is out of bounds, the function sends an error to the console.
*/
//go:nosplit
func (self class) SetPointPosition(idx int64, position Vector2.XY) { //gd:Curve2D.set_point_position
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Curve2D.Bind_set_point_position), 0|(gdextension.SizeInt<<4)|(gdextension.SizeVector2<<8), unsafe.Pointer(&struct {
		idx      int64
		position Vector2.XY
	}{idx, position}))
}

/*
Returns the position of the vertex [param idx]. If the index is out of bounds, the function sends an error to the console, and returns [code](0, 0)[/code].
*/
//go:nosplit
func (self class) GetPointPosition(idx int64) Vector2.XY { //gd:Curve2D.get_point_position
	var r_ret = gdextension.Call[Vector2.XY](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Curve2D.Bind_get_point_position), gdextension.SizeVector2|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ idx int64 }{idx}))
	var ret = r_ret
	return ret
}

/*
Sets the position of the control point leading to the vertex [param idx]. If the index is out of bounds, the function sends an error to the console. The position is relative to the vertex.
*/
//go:nosplit
func (self class) SetPointIn(idx int64, position Vector2.XY) { //gd:Curve2D.set_point_in
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Curve2D.Bind_set_point_in), 0|(gdextension.SizeInt<<4)|(gdextension.SizeVector2<<8), unsafe.Pointer(&struct {
		idx      int64
		position Vector2.XY
	}{idx, position}))
}

/*
Returns the position of the control point leading to the vertex [param idx]. The returned position is relative to the vertex [param idx]. If the index is out of bounds, the function sends an error to the console, and returns [code](0, 0)[/code].
*/
//go:nosplit
func (self class) GetPointIn(idx int64) Vector2.XY { //gd:Curve2D.get_point_in
	var r_ret = gdextension.Call[Vector2.XY](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Curve2D.Bind_get_point_in), gdextension.SizeVector2|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ idx int64 }{idx}))
	var ret = r_ret
	return ret
}

/*
Sets the position of the control point leading out of the vertex [param idx]. If the index is out of bounds, the function sends an error to the console. The position is relative to the vertex.
*/
//go:nosplit
func (self class) SetPointOut(idx int64, position Vector2.XY) { //gd:Curve2D.set_point_out
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Curve2D.Bind_set_point_out), 0|(gdextension.SizeInt<<4)|(gdextension.SizeVector2<<8), unsafe.Pointer(&struct {
		idx      int64
		position Vector2.XY
	}{idx, position}))
}

/*
Returns the position of the control point leading out of the vertex [param idx]. The returned position is relative to the vertex [param idx]. If the index is out of bounds, the function sends an error to the console, and returns [code](0, 0)[/code].
*/
//go:nosplit
func (self class) GetPointOut(idx int64) Vector2.XY { //gd:Curve2D.get_point_out
	var r_ret = gdextension.Call[Vector2.XY](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Curve2D.Bind_get_point_out), gdextension.SizeVector2|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ idx int64 }{idx}))
	var ret = r_ret
	return ret
}

/*
Deletes the point [param idx] from the curve. Sends an error to the console if [param idx] is out of bounds.
*/
//go:nosplit
func (self class) RemovePoint(idx int64) { //gd:Curve2D.remove_point
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Curve2D.Bind_remove_point), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ idx int64 }{idx}))
}

/*
Removes all points from the curve.
*/
//go:nosplit
func (self class) ClearPoints() { //gd:Curve2D.clear_points
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Curve2D.Bind_clear_points), 0, unsafe.Pointer(&struct{}{}))
}

/*
Returns the position between the vertex [param idx] and the vertex [code]idx + 1[/code], where [param t] controls if the point is the first vertex ([code]t = 0.0[/code]), the last vertex ([code]t = 1.0[/code]), or in between. Values of [param t] outside the range ([code]0.0 <= t <= 1.0[/code]) give strange, but predictable results.
If [param idx] is out of bounds it is truncated to the first or last vertex, and [param t] is ignored. If the curve has no points, the function sends an error to the console, and returns [code](0, 0)[/code].
*/
//go:nosplit
func (self class) Sample(idx int64, t float64) Vector2.XY { //gd:Curve2D.sample
	var r_ret = gdextension.Call[Vector2.XY](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Curve2D.Bind_sample), gdextension.SizeVector2|(gdextension.SizeInt<<4)|(gdextension.SizeFloat<<8), unsafe.Pointer(&struct {
		idx int64
		t   float64
	}{idx, t}))
	var ret = r_ret
	return ret
}

/*
Returns the position at the vertex [param fofs]. It calls [method sample] using the integer part of [param fofs] as [code]idx[/code], and its fractional part as [code]t[/code].
*/
//go:nosplit
func (self class) Samplef(fofs float64) Vector2.XY { //gd:Curve2D.samplef
	var r_ret = gdextension.Call[Vector2.XY](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Curve2D.Bind_samplef), gdextension.SizeVector2|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ fofs float64 }{fofs}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetBakeInterval(distance float64) { //gd:Curve2D.set_bake_interval
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Curve2D.Bind_set_bake_interval), 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ distance float64 }{distance}))
}

//go:nosplit
func (self class) GetBakeInterval() float64 { //gd:Curve2D.get_bake_interval
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Curve2D.Bind_get_bake_interval), gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the total length of the curve, based on the cached points. Given enough density (see [member bake_interval]), it should be approximate enough.
*/
//go:nosplit
func (self class) GetBakedLength() float64 { //gd:Curve2D.get_baked_length
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Curve2D.Bind_get_baked_length), gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns a point within the curve at position [param offset], where [param offset] is measured as a pixel distance along the curve.
To do that, it finds the two cached points where the [param offset] lies between, then interpolates the values. This interpolation is cubic if [param cubic] is set to [code]true[/code], or linear if set to [code]false[/code].
Cubic interpolation tends to follow the curves better, but linear is faster (and often, precise enough).
*/
//go:nosplit
func (self class) SampleBaked(offset float64, cubic bool) Vector2.XY { //gd:Curve2D.sample_baked
	var r_ret = gdextension.Call[Vector2.XY](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Curve2D.Bind_sample_baked), gdextension.SizeVector2|(gdextension.SizeFloat<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		offset float64
		cubic  bool
	}{offset, cubic}))
	var ret = r_ret
	return ret
}

/*
Similar to [method sample_baked], but returns [Transform2D] that includes a rotation along the curve, with [member Transform2D.origin] as the point position and the [member Transform2D.x] vector pointing in the direction of the path at that point. Returns an empty transform if the length of the curve is [code]0[/code].
[codeblock]
var baked = curve.sample_baked_with_rotation(offset)
# The returned Transform2D can be set directly.
transform = baked
# You can also read the origin and rotation separately from the returned Transform2D.
position = baked.get_origin()
rotation = baked.get_rotation()
[/codeblock]
*/
//go:nosplit
func (self class) SampleBakedWithRotation(offset float64, cubic bool) Transform2D.OriginXY { //gd:Curve2D.sample_baked_with_rotation
	var r_ret = gdextension.Call[Transform2D.OriginXY](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Curve2D.Bind_sample_baked_with_rotation), gdextension.SizeTransform2D|(gdextension.SizeFloat<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		offset float64
		cubic  bool
	}{offset, cubic}))
	var ret = r_ret
	return ret
}

/*
Returns the cache of points as a [PackedVector2Array].
*/
//go:nosplit
func (self class) GetBakedPoints() Packed.Array[Vector2.XY] { //gd:Curve2D.get_baked_points
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Curve2D.Bind_get_baked_points), gdextension.SizePackedArray, unsafe.Pointer(&struct{}{}))
	var ret = Packed.Array[Vector2.XY](Array.Through(gd.PackedProxy[gd.PackedVector2Array, Vector2.XY]{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

/*
Returns the closest point on baked segments (in curve's local space) to [param to_point].
[param to_point] must be in this curve's local space.
*/
//go:nosplit
func (self class) GetClosestPoint(to_point Vector2.XY) Vector2.XY { //gd:Curve2D.get_closest_point
	var r_ret = gdextension.Call[Vector2.XY](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Curve2D.Bind_get_closest_point), gdextension.SizeVector2|(gdextension.SizeVector2<<4), unsafe.Pointer(&struct{ to_point Vector2.XY }{to_point}))
	var ret = r_ret
	return ret
}

/*
Returns the closest offset to [param to_point]. This offset is meant to be used in [method sample_baked].
[param to_point] must be in this curve's local space.
*/
//go:nosplit
func (self class) GetClosestOffset(to_point Vector2.XY) float64 { //gd:Curve2D.get_closest_offset
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Curve2D.Bind_get_closest_offset), gdextension.SizeFloat|(gdextension.SizeVector2<<4), unsafe.Pointer(&struct{ to_point Vector2.XY }{to_point}))
	var ret = r_ret
	return ret
}

/*
Returns a list of points along the curve, with a curvature controlled point density. That is, the curvier parts will have more points than the straighter parts.
This approximation makes straight segments between each point, then subdivides those segments until the resulting shape is similar enough.
[param max_stages] controls how many subdivisions a curve segment may face before it is considered approximate enough. Each subdivision splits the segment in half, so the default 5 stages may mean up to 32 subdivisions per curve segment. Increase with care!
[param tolerance_degrees] controls how many degrees the midpoint of a segment may deviate from the real curve, before the segment has to be subdivided.
*/
//go:nosplit
func (self class) Tessellate(max_stages int64, tolerance_degrees float64) Packed.Array[Vector2.XY] { //gd:Curve2D.tessellate
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Curve2D.Bind_tessellate), gdextension.SizePackedArray|(gdextension.SizeInt<<4)|(gdextension.SizeFloat<<8), unsafe.Pointer(&struct {
		max_stages        int64
		tolerance_degrees float64
	}{max_stages, tolerance_degrees}))
	var ret = Packed.Array[Vector2.XY](Array.Through(gd.PackedProxy[gd.PackedVector2Array, Vector2.XY]{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

/*
Returns a list of points along the curve, with almost uniform density. [param max_stages] controls how many subdivisions a curve segment may face before it is considered approximate enough. Each subdivision splits the segment in half, so the default 5 stages may mean up to 32 subdivisions per curve segment. Increase with care!
[param tolerance_length] controls the maximal distance between two neighboring points, before the segment has to be subdivided.
*/
//go:nosplit
func (self class) TessellateEvenLength(max_stages int64, tolerance_length float64) Packed.Array[Vector2.XY] { //gd:Curve2D.tessellate_even_length
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.Curve2D.Bind_tessellate_even_length), gdextension.SizePackedArray|(gdextension.SizeInt<<4)|(gdextension.SizeFloat<<8), unsafe.Pointer(&struct {
		max_stages       int64
		tolerance_length float64
	}{max_stages, tolerance_length}))
	var ret = Packed.Array[Vector2.XY](Array.Through(gd.PackedProxy[gd.PackedVector2Array, Vector2.XY]{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}
func (self class) AsCurve2D() Advanced         { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsCurve2D() Instance      { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsCurve2D() Instance { return self.Super().AsCurve2D() }
func (self class) AsResource() Resource.Advanced {
	return *((*Resource.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsResource() Resource.Instance { return self.Super().AsResource() }
func (self Instance) AsResource() Resource.Instance {
	return *((*Resource.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsRefCounted() [1]gd.RefCounted { return self.Super().AsRefCounted() }
func (self Instance) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Resource.Advanced(self.AsResource()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Resource.Instance(self.AsResource()), name)
	}
}
func init() {
	gdclass.Register("Curve2D", func(ptr gd.Object) any { return [1]gdclass.Curve2D{*(*gdclass.Curve2D)(unsafe.Pointer(&ptr))} })
}
