// Code generated by the generate package DO NOT EDIT

// Package Skeleton3D provides methods for working with Skeleton3D object instances.
package Skeleton3D

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/Node"
import "graphics.gd/classdb/Node3D"
import "graphics.gd/classdb/Skin"
import "graphics.gd/classdb/SkinReference"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/Quaternion"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"
import "graphics.gd/variant/Transform3D"
import "graphics.gd/variant/Vector3"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
[Skeleton3D] provides an interface for managing a hierarchy of bones, including pose, rest and animation (see [Animation]). It can also use ragdoll physics.
The overall transform of a bone with respect to the skeleton is determined by bone pose. Bone rest defines the initial transform of the bone pose.
Note that "global pose" below refers to the overall transform of the bone with respect to skeleton, so it is not the actual global/world transform of the bone.
*/
type Instance [1]gdclass.Skeleton3D

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	add_bone                                  gdextension.MethodForClass `hash:"1597066294"`
	find_bone                                 gdextension.MethodForClass `hash:"1321353865"`
	get_bone_name                             gdextension.MethodForClass `hash:"844755477"`
	set_bone_name                             gdextension.MethodForClass `hash:"501894301"`
	get_bone_meta                             gdextension.MethodForClass `hash:"203112058"`
	get_bone_meta_list                        gdextension.MethodForClass `hash:"663333327"`
	has_bone_meta                             gdextension.MethodForClass `hash:"921227809"`
	set_bone_meta                             gdextension.MethodForClass `hash:"702482756"`
	get_concatenated_bone_names               gdextension.MethodForClass `hash:"2002593661"`
	get_bone_parent                           gdextension.MethodForClass `hash:"923996154"`
	set_bone_parent                           gdextension.MethodForClass `hash:"3937882851"`
	get_bone_count                            gdextension.MethodForClass `hash:"3905245786"`
	get_version                               gdextension.MethodForClass `hash:"3905245786"`
	unparent_bone_and_rest                    gdextension.MethodForClass `hash:"1286410249"`
	get_bone_children                         gdextension.MethodForClass `hash:"1706082319"`
	get_parentless_bones                      gdextension.MethodForClass `hash:"1930428628"`
	get_bone_rest                             gdextension.MethodForClass `hash:"1965739696"`
	set_bone_rest                             gdextension.MethodForClass `hash:"3616898986"`
	get_bone_global_rest                      gdextension.MethodForClass `hash:"1965739696"`
	create_skin_from_rest_transforms          gdextension.MethodForClass `hash:"1032037385"`
	register_skin                             gdextension.MethodForClass `hash:"3405789568"`
	localize_rests                            gdextension.MethodForClass `hash:"3218959716"`
	clear_bones                               gdextension.MethodForClass `hash:"3218959716"`
	get_bone_pose                             gdextension.MethodForClass `hash:"1965739696"`
	set_bone_pose                             gdextension.MethodForClass `hash:"3616898986"`
	set_bone_pose_position                    gdextension.MethodForClass `hash:"1530502735"`
	set_bone_pose_rotation                    gdextension.MethodForClass `hash:"2823819782"`
	set_bone_pose_scale                       gdextension.MethodForClass `hash:"1530502735"`
	get_bone_pose_position                    gdextension.MethodForClass `hash:"711720468"`
	get_bone_pose_rotation                    gdextension.MethodForClass `hash:"476865136"`
	get_bone_pose_scale                       gdextension.MethodForClass `hash:"711720468"`
	reset_bone_pose                           gdextension.MethodForClass `hash:"1286410249"`
	reset_bone_poses                          gdextension.MethodForClass `hash:"3218959716"`
	is_bone_enabled                           gdextension.MethodForClass `hash:"1116898809"`
	set_bone_enabled                          gdextension.MethodForClass `hash:"972357352"`
	get_bone_global_pose                      gdextension.MethodForClass `hash:"1965739696"`
	set_bone_global_pose                      gdextension.MethodForClass `hash:"3616898986"`
	force_update_all_bone_transforms          gdextension.MethodForClass `hash:"3218959716"`
	force_update_bone_child_transform         gdextension.MethodForClass `hash:"1286410249"`
	set_motion_scale                          gdextension.MethodForClass `hash:"373806689"`
	get_motion_scale                          gdextension.MethodForClass `hash:"1740695150"`
	set_show_rest_only                        gdextension.MethodForClass `hash:"2586408642"`
	is_show_rest_only                         gdextension.MethodForClass `hash:"36873697"`
	set_modifier_callback_mode_process        gdextension.MethodForClass `hash:"3916362634"`
	get_modifier_callback_mode_process        gdextension.MethodForClass `hash:"997182536"`
	clear_bones_global_pose_override          gdextension.MethodForClass `hash:"3218959716"`
	set_bone_global_pose_override             gdextension.MethodForClass `hash:"3483398371"`
	get_bone_global_pose_override             gdextension.MethodForClass `hash:"1965739696"`
	get_bone_global_pose_no_override          gdextension.MethodForClass `hash:"1965739696"`
	set_animate_physical_bones                gdextension.MethodForClass `hash:"2586408642"`
	get_animate_physical_bones                gdextension.MethodForClass `hash:"36873697"`
	physical_bones_stop_simulation            gdextension.MethodForClass `hash:"3218959716"`
	physical_bones_start_simulation           gdextension.MethodForClass `hash:"2787316981"`
	physical_bones_add_collision_exception    gdextension.MethodForClass `hash:"2722037293"`
	physical_bones_remove_collision_exception gdextension.MethodForClass `hash:"2722037293"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("Skeleton3D")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		pointers.Raw[gd.StringName](sname).Free()
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

type Expanded [1]gdclass.Skeleton3D

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsSkeleton3D() Instance
}

/*
Adds a new bone with the given name. Returns the new bone's index, or [code]-1[/code] if this method fails.
[b]Note:[/b] Bone names should be unique, non empty, and cannot include the [code]:[/code] and [code]/[/code] characters.
*/
func (self Instance) AddBone(name string) int { //gd:Skeleton3D.add_bone
	return int(int(Advanced(self).AddBone(String.New(name))))
}

/*
Returns the bone index that matches [param name] as its name. Returns [code]-1[/code] if no bone with this name exists.
*/
func (self Instance) FindBone(name string) int { //gd:Skeleton3D.find_bone
	return int(int(Advanced(self).FindBone(String.New(name))))
}

/*
Returns the name of the bone at index [param bone_idx].
*/
func (self Instance) GetBoneName(bone_idx int) string { //gd:Skeleton3D.get_bone_name
	return string(Advanced(self).GetBoneName(int64(bone_idx)).String())
}

/*
Sets the bone name, [param name], for the bone at [param bone_idx].
*/
func (self Instance) SetBoneName(bone_idx int, name string) { //gd:Skeleton3D.set_bone_name
	Advanced(self).SetBoneName(int64(bone_idx), String.New(name))
}

/*
Returns bone metadata for [param bone_idx] with [param key].
*/
func (self Instance) GetBoneMeta(bone_idx int, key string) any { //gd:Skeleton3D.get_bone_meta
	return any(Advanced(self).GetBoneMeta(int64(bone_idx), String.Name(String.New(key))).Interface())
}

/*
Returns a list of all metadata keys for [param bone_idx].
*/
func (self Instance) GetBoneMetaList(bone_idx int) []string { //gd:Skeleton3D.get_bone_meta_list
	return []string(gd.ArrayAs[[]string](gd.InternalArray(Advanced(self).GetBoneMetaList(int64(bone_idx)))))
}

/*
Returns whether there exists any bone metadata for [param bone_idx] with key [param key].
*/
func (self Instance) HasBoneMeta(bone_idx int, key string) bool { //gd:Skeleton3D.has_bone_meta
	return bool(Advanced(self).HasBoneMeta(int64(bone_idx), String.Name(String.New(key))))
}

/*
Sets bone metadata for [param bone_idx], will set the [param key] meta to [param value].
*/
func (self Instance) SetBoneMeta(bone_idx int, key string, value any) { //gd:Skeleton3D.set_bone_meta
	Advanced(self).SetBoneMeta(int64(bone_idx), String.Name(String.New(key)), variant.New(value))
}

/*
Returns all bone names concatenated with commas ([code],[/code]) as a single [StringName].
It is useful to set it as a hint for the enum property.
*/
func (self Instance) GetConcatenatedBoneNames() string { //gd:Skeleton3D.get_concatenated_bone_names
	return string(Advanced(self).GetConcatenatedBoneNames().String())
}

/*
Returns the bone index which is the parent of the bone at [param bone_idx]. If -1, then bone has no parent.
[b]Note:[/b] The parent bone returned will always be less than [param bone_idx].
*/
func (self Instance) GetBoneParent(bone_idx int) int { //gd:Skeleton3D.get_bone_parent
	return int(int(Advanced(self).GetBoneParent(int64(bone_idx))))
}

/*
Sets the bone index [param parent_idx] as the parent of the bone at [param bone_idx]. If -1, then bone has no parent.
[b]Note:[/b] [param parent_idx] must be less than [param bone_idx].
*/
func (self Instance) SetBoneParent(bone_idx int, parent_idx int) { //gd:Skeleton3D.set_bone_parent
	Advanced(self).SetBoneParent(int64(bone_idx), int64(parent_idx))
}

/*
Returns the number of bones in the skeleton.
*/
func (self Instance) GetBoneCount() int { //gd:Skeleton3D.get_bone_count
	return int(int(Advanced(self).GetBoneCount()))
}

/*
Returns the number of times the bone hierarchy has changed within this skeleton, including renames.
The Skeleton version is not serialized: only use within a single instance of Skeleton3D.
Use for invalidating caches in IK solvers and other nodes which process bones.
*/
func (self Instance) GetVersion() int { //gd:Skeleton3D.get_version
	return int(int(Advanced(self).GetVersion()))
}

/*
Unparents the bone at [param bone_idx] and sets its rest position to that of its parent prior to being reset.
*/
func (self Instance) UnparentBoneAndRest(bone_idx int) { //gd:Skeleton3D.unparent_bone_and_rest
	Advanced(self).UnparentBoneAndRest(int64(bone_idx))
}

/*
Returns an array containing the bone indexes of all the child node of the passed in bone, [param bone_idx].
*/
func (self Instance) GetBoneChildren(bone_idx int) []int32 { //gd:Skeleton3D.get_bone_children
	return []int32(slices.Collect(Advanced(self).GetBoneChildren(int64(bone_idx)).Values()))
}

/*
Returns an array with all of the bones that are parentless. Another way to look at this is that it returns the indexes of all the bones that are not dependent or modified by other bones in the Skeleton.
*/
func (self Instance) GetParentlessBones() []int32 { //gd:Skeleton3D.get_parentless_bones
	return []int32(slices.Collect(Advanced(self).GetParentlessBones().Values()))
}

/*
Returns the rest transform for a bone [param bone_idx].
*/
func (self Instance) GetBoneRest(bone_idx int) Transform3D.BasisOrigin { //gd:Skeleton3D.get_bone_rest
	return Transform3D.BasisOrigin(Advanced(self).GetBoneRest(int64(bone_idx)))
}

/*
Sets the rest transform for bone [param bone_idx].
*/
func (self Instance) SetBoneRest(bone_idx int, rest Transform3D.BasisOrigin) { //gd:Skeleton3D.set_bone_rest
	Advanced(self).SetBoneRest(int64(bone_idx), Transform3D.BasisOrigin(rest))
}

/*
Returns the global rest transform for [param bone_idx].
*/
func (self Instance) GetBoneGlobalRest(bone_idx int) Transform3D.BasisOrigin { //gd:Skeleton3D.get_bone_global_rest
	return Transform3D.BasisOrigin(Advanced(self).GetBoneGlobalRest(int64(bone_idx)))
}
func (self Instance) CreateSkinFromRestTransforms() Skin.Instance { //gd:Skeleton3D.create_skin_from_rest_transforms
	return Skin.Instance(Advanced(self).CreateSkinFromRestTransforms())
}

/*
Binds the given Skin to the Skeleton.
*/
func (self Instance) RegisterSkin(skin Skin.Instance) SkinReference.Instance { //gd:Skeleton3D.register_skin
	return SkinReference.Instance(Advanced(self).RegisterSkin(skin))
}

/*
Returns all bones in the skeleton to their rest poses.
*/
func (self Instance) LocalizeRests() { //gd:Skeleton3D.localize_rests
	Advanced(self).LocalizeRests()
}

/*
Clear all the bones in this skeleton.
*/
func (self Instance) ClearBones() { //gd:Skeleton3D.clear_bones
	Advanced(self).ClearBones()
}

/*
Returns the pose transform of the specified bone.
[b]Note:[/b] This is the pose you set to the skeleton in the process, the final pose can get overridden by modifiers in the deferred process, if you want to access the final pose, use [signal SkeletonModifier3D.modification_processed].
*/
func (self Instance) GetBonePose(bone_idx int) Transform3D.BasisOrigin { //gd:Skeleton3D.get_bone_pose
	return Transform3D.BasisOrigin(Advanced(self).GetBonePose(int64(bone_idx)))
}

/*
Sets the pose transform, [param pose], for the bone at [param bone_idx].
*/
func (self Instance) SetBonePose(bone_idx int, pose Transform3D.BasisOrigin) { //gd:Skeleton3D.set_bone_pose
	Advanced(self).SetBonePose(int64(bone_idx), Transform3D.BasisOrigin(pose))
}

/*
Sets the pose position of the bone at [param bone_idx] to [param position]. [param position] is a [Vector3] describing a position local to the [Skeleton3D] node.
*/
func (self Instance) SetBonePosePosition(bone_idx int, position Vector3.XYZ) { //gd:Skeleton3D.set_bone_pose_position
	Advanced(self).SetBonePosePosition(int64(bone_idx), Vector3.XYZ(position))
}

/*
Sets the pose rotation of the bone at [param bone_idx] to [param rotation]. [param rotation] is a [Quaternion] describing a rotation in the bone's local coordinate space with respect to the rotation of any parent bones.
*/
func (self Instance) SetBonePoseRotation(bone_idx int, rotation Quaternion.IJKX) { //gd:Skeleton3D.set_bone_pose_rotation
	Advanced(self).SetBonePoseRotation(int64(bone_idx), rotation)
}

/*
Sets the pose scale of the bone at [param bone_idx] to [param scale].
*/
func (self Instance) SetBonePoseScale(bone_idx int, scale Vector3.XYZ) { //gd:Skeleton3D.set_bone_pose_scale
	Advanced(self).SetBonePoseScale(int64(bone_idx), Vector3.XYZ(scale))
}

/*
Returns the pose position of the bone at [param bone_idx]. The returned [Vector3] is in the local coordinate space of the [Skeleton3D] node.
*/
func (self Instance) GetBonePosePosition(bone_idx int) Vector3.XYZ { //gd:Skeleton3D.get_bone_pose_position
	return Vector3.XYZ(Advanced(self).GetBonePosePosition(int64(bone_idx)))
}

/*
Returns the pose rotation of the bone at [param bone_idx]. The returned [Quaternion] is local to the bone with respect to the rotation of any parent bones.
*/
func (self Instance) GetBonePoseRotation(bone_idx int) Quaternion.IJKX { //gd:Skeleton3D.get_bone_pose_rotation
	return Quaternion.IJKX(Advanced(self).GetBonePoseRotation(int64(bone_idx)))
}

/*
Returns the pose scale of the bone at [param bone_idx].
*/
func (self Instance) GetBonePoseScale(bone_idx int) Vector3.XYZ { //gd:Skeleton3D.get_bone_pose_scale
	return Vector3.XYZ(Advanced(self).GetBonePoseScale(int64(bone_idx)))
}

/*
Sets the bone pose to rest for [param bone_idx].
*/
func (self Instance) ResetBonePose(bone_idx int) { //gd:Skeleton3D.reset_bone_pose
	Advanced(self).ResetBonePose(int64(bone_idx))
}

/*
Sets all bone poses to rests.
*/
func (self Instance) ResetBonePoses() { //gd:Skeleton3D.reset_bone_poses
	Advanced(self).ResetBonePoses()
}

/*
Returns whether the bone pose for the bone at [param bone_idx] is enabled.
*/
func (self Instance) IsBoneEnabled(bone_idx int) bool { //gd:Skeleton3D.is_bone_enabled
	return bool(Advanced(self).IsBoneEnabled(int64(bone_idx)))
}

/*
Disables the pose for the bone at [param bone_idx] if [code]false[/code], enables the bone pose if [code]true[/code].
*/
func (self Instance) SetBoneEnabled(bone_idx int) { //gd:Skeleton3D.set_bone_enabled
	Advanced(self).SetBoneEnabled(int64(bone_idx), true)
}

/*
Disables the pose for the bone at [param bone_idx] if [code]false[/code], enables the bone pose if [code]true[/code].
*/
func (self Expanded) SetBoneEnabled(bone_idx int, enabled bool) { //gd:Skeleton3D.set_bone_enabled
	Advanced(self).SetBoneEnabled(int64(bone_idx), enabled)
}

/*
Returns the overall transform of the specified bone, with respect to the skeleton. Being relative to the skeleton frame, this is not the actual "global" transform of the bone.
[b]Note:[/b] This is the global pose you set to the skeleton in the process, the final global pose can get overridden by modifiers in the deferred process, if you want to access the final global pose, use [signal SkeletonModifier3D.modification_processed].
*/
func (self Instance) GetBoneGlobalPose(bone_idx int) Transform3D.BasisOrigin { //gd:Skeleton3D.get_bone_global_pose
	return Transform3D.BasisOrigin(Advanced(self).GetBoneGlobalPose(int64(bone_idx)))
}

/*
Sets the global pose transform, [param pose], for the bone at [param bone_idx].
[b]Note:[/b] If other bone poses have been changed, this method executes a dirty poses recalculation and will cause performance to deteriorate. If you know that multiple global poses will be applied, consider using [method set_bone_pose] with precalculation.
*/
func (self Instance) SetBoneGlobalPose(bone_idx int, pose Transform3D.BasisOrigin) { //gd:Skeleton3D.set_bone_global_pose
	Advanced(self).SetBoneGlobalPose(int64(bone_idx), Transform3D.BasisOrigin(pose))
}

/*
Force updates the bone transforms/poses for all bones in the skeleton.
*/
func (self Instance) ForceUpdateAllBoneTransforms() { //gd:Skeleton3D.force_update_all_bone_transforms
	Advanced(self).ForceUpdateAllBoneTransforms()
}

/*
Force updates the bone transform for the bone at [param bone_idx] and all of its children.
*/
func (self Instance) ForceUpdateBoneChildTransform(bone_idx int) { //gd:Skeleton3D.force_update_bone_child_transform
	Advanced(self).ForceUpdateBoneChildTransform(int64(bone_idx))
}

/*
Removes the global pose override on all bones in the skeleton.
*/
func (self Instance) ClearBonesGlobalPoseOverride() { //gd:Skeleton3D.clear_bones_global_pose_override
	Advanced(self).ClearBonesGlobalPoseOverride()
}

/*
Sets the global pose transform, [param pose], for the bone at [param bone_idx].
[param amount] is the interpolation strength that will be used when applying the pose, and [param persistent] determines if the applied pose will remain.
[b]Note:[/b] The pose transform needs to be a global pose! To convert a world transform from a [Node3D] to a global bone pose, multiply the [method Transform3D.affine_inverse] of the node's [member Node3D.global_transform] by the desired world transform.
*/
func (self Instance) SetBoneGlobalPoseOverride(bone_idx int, pose Transform3D.BasisOrigin, amount Float.X) { //gd:Skeleton3D.set_bone_global_pose_override
	Advanced(self).SetBoneGlobalPoseOverride(int64(bone_idx), Transform3D.BasisOrigin(pose), float64(amount), false)
}

/*
Sets the global pose transform, [param pose], for the bone at [param bone_idx].
[param amount] is the interpolation strength that will be used when applying the pose, and [param persistent] determines if the applied pose will remain.
[b]Note:[/b] The pose transform needs to be a global pose! To convert a world transform from a [Node3D] to a global bone pose, multiply the [method Transform3D.affine_inverse] of the node's [member Node3D.global_transform] by the desired world transform.
*/
func (self Expanded) SetBoneGlobalPoseOverride(bone_idx int, pose Transform3D.BasisOrigin, amount Float.X, persistent bool) { //gd:Skeleton3D.set_bone_global_pose_override
	Advanced(self).SetBoneGlobalPoseOverride(int64(bone_idx), Transform3D.BasisOrigin(pose), float64(amount), persistent)
}

/*
Returns the global pose override transform for [param bone_idx].
*/
func (self Instance) GetBoneGlobalPoseOverride(bone_idx int) Transform3D.BasisOrigin { //gd:Skeleton3D.get_bone_global_pose_override
	return Transform3D.BasisOrigin(Advanced(self).GetBoneGlobalPoseOverride(int64(bone_idx)))
}

/*
Returns the overall transform of the specified bone, with respect to the skeleton, but without any global pose overrides. Being relative to the skeleton frame, this is not the actual "global" transform of the bone.
*/
func (self Instance) GetBoneGlobalPoseNoOverride(bone_idx int) Transform3D.BasisOrigin { //gd:Skeleton3D.get_bone_global_pose_no_override
	return Transform3D.BasisOrigin(Advanced(self).GetBoneGlobalPoseNoOverride(int64(bone_idx)))
}

/*
Tells the [PhysicalBone3D] nodes in the Skeleton to stop simulating.
*/
func (self Instance) PhysicalBonesStopSimulation() { //gd:Skeleton3D.physical_bones_stop_simulation
	Advanced(self).PhysicalBonesStopSimulation()
}

/*
Tells the [PhysicalBone3D] nodes in the Skeleton to start simulating and reacting to the physics world.
Optionally, a list of bone names can be passed-in, allowing only the passed-in bones to be simulated.
*/
func (self Instance) PhysicalBonesStartSimulation() { //gd:Skeleton3D.physical_bones_start_simulation
	Advanced(self).PhysicalBonesStartSimulation(gd.ArrayFromSlice[Array.Contains[String.Name]]([1][]string{}[0]))
}

/*
Tells the [PhysicalBone3D] nodes in the Skeleton to start simulating and reacting to the physics world.
Optionally, a list of bone names can be passed-in, allowing only the passed-in bones to be simulated.
*/
func (self Expanded) PhysicalBonesStartSimulation(bones []string) { //gd:Skeleton3D.physical_bones_start_simulation
	Advanced(self).PhysicalBonesStartSimulation(gd.ArrayFromSlice[Array.Contains[String.Name]](bones))
}

/*
Adds a collision exception to the physical bone.
Works just like the [RigidBody3D] node.
*/
func (self Instance) PhysicalBonesAddCollisionException(exception RID.Body3D) { //gd:Skeleton3D.physical_bones_add_collision_exception
	Advanced(self).PhysicalBonesAddCollisionException(RID.Any(exception))
}

/*
Removes a collision exception to the physical bone.
Works just like the [RigidBody3D] node.
*/
func (self Instance) PhysicalBonesRemoveCollisionException(exception RID.Body3D) { //gd:Skeleton3D.physical_bones_remove_collision_exception
	Advanced(self).PhysicalBonesRemoveCollisionException(RID.Any(exception))
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.Skeleton3D

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.Skeleton3D)(unsafe.Pointer(&obj))
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.Skeleton3D)(unsafe.Pointer(&obj))
		return true
	}
	return false
}

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {

	if !gd.Linked {
		var placeholder Instance
		*(*gd.Object)(unsafe.Pointer(&placeholder)) = pointers.Add[gd.Object]([3]uint64{})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(*(*gd.Object)(unsafe.Pointer(&placeholder)), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	object := [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})}
	casted := Instance{*(*gdclass.Skeleton3D)(unsafe.Pointer(&object))}
	object[0].Notification(0, false)
	return casted
}

func (self Instance) MotionScale() Float.X {
	return Float.X(Float.X(class(self).GetMotionScale()))
}

func (self Instance) SetMotionScale(value Float.X) {
	class(self).SetMotionScale(float64(value))
}

func (self Instance) ShowRestOnly() bool {
	return bool(class(self).IsShowRestOnly())
}

func (self Instance) SetShowRestOnly(value bool) {
	class(self).SetShowRestOnly(value)
}

func (self Instance) ModifierCallbackModeProcess() ModifierCallbackModeProcess {
	return ModifierCallbackModeProcess(class(self).GetModifierCallbackModeProcess())
}

func (self Instance) SetModifierCallbackModeProcess(value ModifierCallbackModeProcess) {
	class(self).SetModifierCallbackModeProcess(value)
}

func (self Instance) AnimatePhysicalBones() bool {
	return bool(class(self).GetAnimatePhysicalBones())
}

func (self Instance) SetAnimatePhysicalBones(value bool) {
	class(self).SetAnimatePhysicalBones(value)
}

/*
Adds a new bone with the given name. Returns the new bone's index, or [code]-1[/code] if this method fails.
[b]Note:[/b] Bone names should be unique, non empty, and cannot include the [code]:[/code] and [code]/[/code] characters.
*/
//go:nosplit
func (self class) AddBone(name String.Readable) int64 { //gd:Skeleton3D.add_bone
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.add_bone, gdextension.SizeInt|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ name gdextension.String }{pointers.Get(gd.InternalString(name))}))
	var ret = r_ret
	return ret
}

/*
Returns the bone index that matches [param name] as its name. Returns [code]-1[/code] if no bone with this name exists.
*/
//go:nosplit
func (self class) FindBone(name String.Readable) int64 { //gd:Skeleton3D.find_bone
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.find_bone, gdextension.SizeInt|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ name gdextension.String }{pointers.Get(gd.InternalString(name))}))
	var ret = r_ret
	return ret
}

/*
Returns the name of the bone at index [param bone_idx].
*/
//go:nosplit
func (self class) GetBoneName(bone_idx int64) String.Readable { //gd:Skeleton3D.get_bone_name
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_bone_name, gdextension.SizeString|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ bone_idx int64 }{bone_idx}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Sets the bone name, [param name], for the bone at [param bone_idx].
*/
//go:nosplit
func (self class) SetBoneName(bone_idx int64, name String.Readable) { //gd:Skeleton3D.set_bone_name
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_bone_name, 0|(gdextension.SizeInt<<4)|(gdextension.SizeString<<8), unsafe.Pointer(&struct {
		bone_idx int64
		name     gdextension.String
	}{bone_idx, pointers.Get(gd.InternalString(name))}))
}

/*
Returns bone metadata for [param bone_idx] with [param key].
*/
//go:nosplit
func (self class) GetBoneMeta(bone_idx int64, key String.Name) variant.Any { //gd:Skeleton3D.get_bone_meta
	var r_ret = gdextension.Call[gdextension.Variant](gd.ObjectChecked(self.AsObject()), methods.get_bone_meta, gdextension.SizeVariant|(gdextension.SizeInt<<4)|(gdextension.SizeStringName<<8), unsafe.Pointer(&struct {
		bone_idx int64
		key      gdextension.StringName
	}{bone_idx, pointers.Get(gd.InternalStringName(key))}))
	var ret = variant.Implementation(gd.VariantProxy{}, pointers.Pack(pointers.New[gd.Variant](r_ret)))
	return ret
}

/*
Returns a list of all metadata keys for [param bone_idx].
*/
//go:nosplit
func (self class) GetBoneMetaList(bone_idx int64) Array.Contains[String.Name] { //gd:Skeleton3D.get_bone_meta_list
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), methods.get_bone_meta_list, gdextension.SizeArray|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ bone_idx int64 }{bone_idx}))
	var ret = Array.Through(gd.ArrayProxy[String.Name]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

/*
Returns whether there exists any bone metadata for [param bone_idx] with key [param key].
*/
//go:nosplit
func (self class) HasBoneMeta(bone_idx int64, key String.Name) bool { //gd:Skeleton3D.has_bone_meta
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.has_bone_meta, gdextension.SizeBool|(gdextension.SizeInt<<4)|(gdextension.SizeStringName<<8), unsafe.Pointer(&struct {
		bone_idx int64
		key      gdextension.StringName
	}{bone_idx, pointers.Get(gd.InternalStringName(key))}))
	var ret = r_ret
	return ret
}

/*
Sets bone metadata for [param bone_idx], will set the [param key] meta to [param value].
*/
//go:nosplit
func (self class) SetBoneMeta(bone_idx int64, key String.Name, value variant.Any) { //gd:Skeleton3D.set_bone_meta
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_bone_meta, 0|(gdextension.SizeInt<<4)|(gdextension.SizeStringName<<8)|(gdextension.SizeVariant<<12), unsafe.Pointer(&struct {
		bone_idx int64
		key      gdextension.StringName
		value    gdextension.Variant
	}{bone_idx, pointers.Get(gd.InternalStringName(key)), gdextension.Variant(pointers.Get(gd.InternalVariant(value)))}))
}

/*
Returns all bone names concatenated with commas ([code],[/code]) as a single [StringName].
It is useful to set it as a hint for the enum property.
*/
//go:nosplit
func (self class) GetConcatenatedBoneNames() String.Name { //gd:Skeleton3D.get_concatenated_bone_names
	var r_ret = gdextension.Call[gdextension.StringName](gd.ObjectChecked(self.AsObject()), methods.get_concatenated_bone_names, gdextension.SizeStringName, unsafe.Pointer(&struct{}{}))
	var ret = String.Name(String.Via(gd.StringNameProxy{}, pointers.Pack(pointers.New[gd.StringName](r_ret))))
	return ret
}

/*
Returns the bone index which is the parent of the bone at [param bone_idx]. If -1, then bone has no parent.
[b]Note:[/b] The parent bone returned will always be less than [param bone_idx].
*/
//go:nosplit
func (self class) GetBoneParent(bone_idx int64) int64 { //gd:Skeleton3D.get_bone_parent
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_bone_parent, gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ bone_idx int64 }{bone_idx}))
	var ret = r_ret
	return ret
}

/*
Sets the bone index [param parent_idx] as the parent of the bone at [param bone_idx]. If -1, then bone has no parent.
[b]Note:[/b] [param parent_idx] must be less than [param bone_idx].
*/
//go:nosplit
func (self class) SetBoneParent(bone_idx int64, parent_idx int64) { //gd:Skeleton3D.set_bone_parent
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_bone_parent, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		bone_idx   int64
		parent_idx int64
	}{bone_idx, parent_idx}))
}

/*
Returns the number of bones in the skeleton.
*/
//go:nosplit
func (self class) GetBoneCount() int64 { //gd:Skeleton3D.get_bone_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_bone_count, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the number of times the bone hierarchy has changed within this skeleton, including renames.
The Skeleton version is not serialized: only use within a single instance of Skeleton3D.
Use for invalidating caches in IK solvers and other nodes which process bones.
*/
//go:nosplit
func (self class) GetVersion() int64 { //gd:Skeleton3D.get_version
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_version, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Unparents the bone at [param bone_idx] and sets its rest position to that of its parent prior to being reset.
*/
//go:nosplit
func (self class) UnparentBoneAndRest(bone_idx int64) { //gd:Skeleton3D.unparent_bone_and_rest
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.unparent_bone_and_rest, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ bone_idx int64 }{bone_idx}))
}

/*
Returns an array containing the bone indexes of all the child node of the passed in bone, [param bone_idx].
*/
//go:nosplit
func (self class) GetBoneChildren(bone_idx int64) Packed.Array[int32] { //gd:Skeleton3D.get_bone_children
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.get_bone_children, gdextension.SizePackedArray|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ bone_idx int64 }{bone_idx}))
	var ret = Packed.Array[int32](Array.Through(gd.PackedProxy[gd.PackedInt32Array, int32]{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

/*
Returns an array with all of the bones that are parentless. Another way to look at this is that it returns the indexes of all the bones that are not dependent or modified by other bones in the Skeleton.
*/
//go:nosplit
func (self class) GetParentlessBones() Packed.Array[int32] { //gd:Skeleton3D.get_parentless_bones
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.get_parentless_bones, gdextension.SizePackedArray, unsafe.Pointer(&struct{}{}))
	var ret = Packed.Array[int32](Array.Through(gd.PackedProxy[gd.PackedInt32Array, int32]{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

/*
Returns the rest transform for a bone [param bone_idx].
*/
//go:nosplit
func (self class) GetBoneRest(bone_idx int64) Transform3D.BasisOrigin { //gd:Skeleton3D.get_bone_rest
	var r_ret = gdextension.Call[Transform3D.BasisOrigin](gd.ObjectChecked(self.AsObject()), methods.get_bone_rest, gdextension.SizeTransform3D|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ bone_idx int64 }{bone_idx}))
	var ret = gd.Transposed(r_ret)
	return ret
}

/*
Sets the rest transform for bone [param bone_idx].
*/
//go:nosplit
func (self class) SetBoneRest(bone_idx int64, rest Transform3D.BasisOrigin) { //gd:Skeleton3D.set_bone_rest
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_bone_rest, 0|(gdextension.SizeInt<<4)|(gdextension.SizeTransform3D<<8), unsafe.Pointer(&struct {
		bone_idx int64
		rest     Transform3D.BasisOrigin
	}{bone_idx, gd.Transposed(rest)}))
}

/*
Returns the global rest transform for [param bone_idx].
*/
//go:nosplit
func (self class) GetBoneGlobalRest(bone_idx int64) Transform3D.BasisOrigin { //gd:Skeleton3D.get_bone_global_rest
	var r_ret = gdextension.Call[Transform3D.BasisOrigin](gd.ObjectChecked(self.AsObject()), methods.get_bone_global_rest, gdextension.SizeTransform3D|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ bone_idx int64 }{bone_idx}))
	var ret = gd.Transposed(r_ret)
	return ret
}

//go:nosplit
func (self class) CreateSkinFromRestTransforms() [1]gdclass.Skin { //gd:Skeleton3D.create_skin_from_rest_transforms
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.create_skin_from_rest_transforms, gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.Skin{gd.PointerWithOwnershipTransferredToGo[gdclass.Skin](r_ret)}
	return ret
}

/*
Binds the given Skin to the Skeleton.
*/
//go:nosplit
func (self class) RegisterSkin(skin [1]gdclass.Skin) [1]gdclass.SkinReference { //gd:Skeleton3D.register_skin
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.register_skin, gdextension.SizeObject|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ skin gdextension.Object }{gdextension.Object(gd.ObjectChecked(skin[0].AsObject()))}))
	var ret = [1]gdclass.SkinReference{gd.PointerWithOwnershipTransferredToGo[gdclass.SkinReference](r_ret)}
	return ret
}

/*
Returns all bones in the skeleton to their rest poses.
*/
//go:nosplit
func (self class) LocalizeRests() { //gd:Skeleton3D.localize_rests
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.localize_rests, 0, unsafe.Pointer(&struct{}{}))
}

/*
Clear all the bones in this skeleton.
*/
//go:nosplit
func (self class) ClearBones() { //gd:Skeleton3D.clear_bones
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.clear_bones, 0, unsafe.Pointer(&struct{}{}))
}

/*
Returns the pose transform of the specified bone.
[b]Note:[/b] This is the pose you set to the skeleton in the process, the final pose can get overridden by modifiers in the deferred process, if you want to access the final pose, use [signal SkeletonModifier3D.modification_processed].
*/
//go:nosplit
func (self class) GetBonePose(bone_idx int64) Transform3D.BasisOrigin { //gd:Skeleton3D.get_bone_pose
	var r_ret = gdextension.Call[Transform3D.BasisOrigin](gd.ObjectChecked(self.AsObject()), methods.get_bone_pose, gdextension.SizeTransform3D|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ bone_idx int64 }{bone_idx}))
	var ret = gd.Transposed(r_ret)
	return ret
}

/*
Sets the pose transform, [param pose], for the bone at [param bone_idx].
*/
//go:nosplit
func (self class) SetBonePose(bone_idx int64, pose Transform3D.BasisOrigin) { //gd:Skeleton3D.set_bone_pose
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_bone_pose, 0|(gdextension.SizeInt<<4)|(gdextension.SizeTransform3D<<8), unsafe.Pointer(&struct {
		bone_idx int64
		pose     Transform3D.BasisOrigin
	}{bone_idx, gd.Transposed(pose)}))
}

/*
Sets the pose position of the bone at [param bone_idx] to [param position]. [param position] is a [Vector3] describing a position local to the [Skeleton3D] node.
*/
//go:nosplit
func (self class) SetBonePosePosition(bone_idx int64, position Vector3.XYZ) { //gd:Skeleton3D.set_bone_pose_position
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_bone_pose_position, 0|(gdextension.SizeInt<<4)|(gdextension.SizeVector3<<8), unsafe.Pointer(&struct {
		bone_idx int64
		position Vector3.XYZ
	}{bone_idx, position}))
}

/*
Sets the pose rotation of the bone at [param bone_idx] to [param rotation]. [param rotation] is a [Quaternion] describing a rotation in the bone's local coordinate space with respect to the rotation of any parent bones.
*/
//go:nosplit
func (self class) SetBonePoseRotation(bone_idx int64, rotation Quaternion.IJKX) { //gd:Skeleton3D.set_bone_pose_rotation
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_bone_pose_rotation, 0|(gdextension.SizeInt<<4)|(gdextension.SizeQuaternion<<8), unsafe.Pointer(&struct {
		bone_idx int64
		rotation Quaternion.IJKX
	}{bone_idx, rotation}))
}

/*
Sets the pose scale of the bone at [param bone_idx] to [param scale].
*/
//go:nosplit
func (self class) SetBonePoseScale(bone_idx int64, scale Vector3.XYZ) { //gd:Skeleton3D.set_bone_pose_scale
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_bone_pose_scale, 0|(gdextension.SizeInt<<4)|(gdextension.SizeVector3<<8), unsafe.Pointer(&struct {
		bone_idx int64
		scale    Vector3.XYZ
	}{bone_idx, scale}))
}

/*
Returns the pose position of the bone at [param bone_idx]. The returned [Vector3] is in the local coordinate space of the [Skeleton3D] node.
*/
//go:nosplit
func (self class) GetBonePosePosition(bone_idx int64) Vector3.XYZ { //gd:Skeleton3D.get_bone_pose_position
	var r_ret = gdextension.Call[Vector3.XYZ](gd.ObjectChecked(self.AsObject()), methods.get_bone_pose_position, gdextension.SizeVector3|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ bone_idx int64 }{bone_idx}))
	var ret = r_ret
	return ret
}

/*
Returns the pose rotation of the bone at [param bone_idx]. The returned [Quaternion] is local to the bone with respect to the rotation of any parent bones.
*/
//go:nosplit
func (self class) GetBonePoseRotation(bone_idx int64) Quaternion.IJKX { //gd:Skeleton3D.get_bone_pose_rotation
	var r_ret = gdextension.Call[Quaternion.IJKX](gd.ObjectChecked(self.AsObject()), methods.get_bone_pose_rotation, gdextension.SizeQuaternion|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ bone_idx int64 }{bone_idx}))
	var ret = r_ret
	return ret
}

/*
Returns the pose scale of the bone at [param bone_idx].
*/
//go:nosplit
func (self class) GetBonePoseScale(bone_idx int64) Vector3.XYZ { //gd:Skeleton3D.get_bone_pose_scale
	var r_ret = gdextension.Call[Vector3.XYZ](gd.ObjectChecked(self.AsObject()), methods.get_bone_pose_scale, gdextension.SizeVector3|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ bone_idx int64 }{bone_idx}))
	var ret = r_ret
	return ret
}

/*
Sets the bone pose to rest for [param bone_idx].
*/
//go:nosplit
func (self class) ResetBonePose(bone_idx int64) { //gd:Skeleton3D.reset_bone_pose
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.reset_bone_pose, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ bone_idx int64 }{bone_idx}))
}

/*
Sets all bone poses to rests.
*/
//go:nosplit
func (self class) ResetBonePoses() { //gd:Skeleton3D.reset_bone_poses
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.reset_bone_poses, 0, unsafe.Pointer(&struct{}{}))
}

/*
Returns whether the bone pose for the bone at [param bone_idx] is enabled.
*/
//go:nosplit
func (self class) IsBoneEnabled(bone_idx int64) bool { //gd:Skeleton3D.is_bone_enabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_bone_enabled, gdextension.SizeBool|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ bone_idx int64 }{bone_idx}))
	var ret = r_ret
	return ret
}

/*
Disables the pose for the bone at [param bone_idx] if [code]false[/code], enables the bone pose if [code]true[/code].
*/
//go:nosplit
func (self class) SetBoneEnabled(bone_idx int64, enabled bool) { //gd:Skeleton3D.set_bone_enabled
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_bone_enabled, 0|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		bone_idx int64
		enabled  bool
	}{bone_idx, enabled}))
}

/*
Returns the overall transform of the specified bone, with respect to the skeleton. Being relative to the skeleton frame, this is not the actual "global" transform of the bone.
[b]Note:[/b] This is the global pose you set to the skeleton in the process, the final global pose can get overridden by modifiers in the deferred process, if you want to access the final global pose, use [signal SkeletonModifier3D.modification_processed].
*/
//go:nosplit
func (self class) GetBoneGlobalPose(bone_idx int64) Transform3D.BasisOrigin { //gd:Skeleton3D.get_bone_global_pose
	var r_ret = gdextension.Call[Transform3D.BasisOrigin](gd.ObjectChecked(self.AsObject()), methods.get_bone_global_pose, gdextension.SizeTransform3D|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ bone_idx int64 }{bone_idx}))
	var ret = gd.Transposed(r_ret)
	return ret
}

/*
Sets the global pose transform, [param pose], for the bone at [param bone_idx].
[b]Note:[/b] If other bone poses have been changed, this method executes a dirty poses recalculation and will cause performance to deteriorate. If you know that multiple global poses will be applied, consider using [method set_bone_pose] with precalculation.
*/
//go:nosplit
func (self class) SetBoneGlobalPose(bone_idx int64, pose Transform3D.BasisOrigin) { //gd:Skeleton3D.set_bone_global_pose
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_bone_global_pose, 0|(gdextension.SizeInt<<4)|(gdextension.SizeTransform3D<<8), unsafe.Pointer(&struct {
		bone_idx int64
		pose     Transform3D.BasisOrigin
	}{bone_idx, gd.Transposed(pose)}))
}

/*
Force updates the bone transforms/poses for all bones in the skeleton.
*/
//go:nosplit
func (self class) ForceUpdateAllBoneTransforms() { //gd:Skeleton3D.force_update_all_bone_transforms
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.force_update_all_bone_transforms, 0, unsafe.Pointer(&struct{}{}))
}

/*
Force updates the bone transform for the bone at [param bone_idx] and all of its children.
*/
//go:nosplit
func (self class) ForceUpdateBoneChildTransform(bone_idx int64) { //gd:Skeleton3D.force_update_bone_child_transform
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.force_update_bone_child_transform, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ bone_idx int64 }{bone_idx}))
}

//go:nosplit
func (self class) SetMotionScale(motion_scale float64) { //gd:Skeleton3D.set_motion_scale
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_motion_scale, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ motion_scale float64 }{motion_scale}))
}

//go:nosplit
func (self class) GetMotionScale() float64 { //gd:Skeleton3D.get_motion_scale
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_motion_scale, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetShowRestOnly(enabled bool) { //gd:Skeleton3D.set_show_rest_only
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_show_rest_only, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enabled bool }{enabled}))
}

//go:nosplit
func (self class) IsShowRestOnly() bool { //gd:Skeleton3D.is_show_rest_only
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_show_rest_only, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetModifierCallbackModeProcess(mode ModifierCallbackModeProcess) { //gd:Skeleton3D.set_modifier_callback_mode_process
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_modifier_callback_mode_process, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ mode ModifierCallbackModeProcess }{mode}))
}

//go:nosplit
func (self class) GetModifierCallbackModeProcess() ModifierCallbackModeProcess { //gd:Skeleton3D.get_modifier_callback_mode_process
	var r_ret = gdextension.Call[ModifierCallbackModeProcess](gd.ObjectChecked(self.AsObject()), methods.get_modifier_callback_mode_process, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Removes the global pose override on all bones in the skeleton.
*/
//go:nosplit
func (self class) ClearBonesGlobalPoseOverride() { //gd:Skeleton3D.clear_bones_global_pose_override
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.clear_bones_global_pose_override, 0, unsafe.Pointer(&struct{}{}))
}

/*
Sets the global pose transform, [param pose], for the bone at [param bone_idx].
[param amount] is the interpolation strength that will be used when applying the pose, and [param persistent] determines if the applied pose will remain.
[b]Note:[/b] The pose transform needs to be a global pose! To convert a world transform from a [Node3D] to a global bone pose, multiply the [method Transform3D.affine_inverse] of the node's [member Node3D.global_transform] by the desired world transform.
*/
//go:nosplit
func (self class) SetBoneGlobalPoseOverride(bone_idx int64, pose Transform3D.BasisOrigin, amount float64, persistent bool) { //gd:Skeleton3D.set_bone_global_pose_override
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_bone_global_pose_override, 0|(gdextension.SizeInt<<4)|(gdextension.SizeTransform3D<<8)|(gdextension.SizeFloat<<12)|(gdextension.SizeBool<<16), unsafe.Pointer(&struct {
		bone_idx   int64
		pose       Transform3D.BasisOrigin
		amount     float64
		persistent bool
	}{bone_idx, gd.Transposed(pose), amount, persistent}))
}

/*
Returns the global pose override transform for [param bone_idx].
*/
//go:nosplit
func (self class) GetBoneGlobalPoseOverride(bone_idx int64) Transform3D.BasisOrigin { //gd:Skeleton3D.get_bone_global_pose_override
	var r_ret = gdextension.Call[Transform3D.BasisOrigin](gd.ObjectChecked(self.AsObject()), methods.get_bone_global_pose_override, gdextension.SizeTransform3D|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ bone_idx int64 }{bone_idx}))
	var ret = gd.Transposed(r_ret)
	return ret
}

/*
Returns the overall transform of the specified bone, with respect to the skeleton, but without any global pose overrides. Being relative to the skeleton frame, this is not the actual "global" transform of the bone.
*/
//go:nosplit
func (self class) GetBoneGlobalPoseNoOverride(bone_idx int64) Transform3D.BasisOrigin { //gd:Skeleton3D.get_bone_global_pose_no_override
	var r_ret = gdextension.Call[Transform3D.BasisOrigin](gd.ObjectChecked(self.AsObject()), methods.get_bone_global_pose_no_override, gdextension.SizeTransform3D|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ bone_idx int64 }{bone_idx}))
	var ret = gd.Transposed(r_ret)
	return ret
}

//go:nosplit
func (self class) SetAnimatePhysicalBones(enabled bool) { //gd:Skeleton3D.set_animate_physical_bones
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_animate_physical_bones, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enabled bool }{enabled}))
}

//go:nosplit
func (self class) GetAnimatePhysicalBones() bool { //gd:Skeleton3D.get_animate_physical_bones
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.get_animate_physical_bones, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Tells the [PhysicalBone3D] nodes in the Skeleton to stop simulating.
*/
//go:nosplit
func (self class) PhysicalBonesStopSimulation() { //gd:Skeleton3D.physical_bones_stop_simulation
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.physical_bones_stop_simulation, 0, unsafe.Pointer(&struct{}{}))
}

/*
Tells the [PhysicalBone3D] nodes in the Skeleton to start simulating and reacting to the physics world.
Optionally, a list of bone names can be passed-in, allowing only the passed-in bones to be simulated.
*/
//go:nosplit
func (self class) PhysicalBonesStartSimulation(bones Array.Contains[String.Name]) { //gd:Skeleton3D.physical_bones_start_simulation
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.physical_bones_start_simulation, 0|(gdextension.SizeArray<<4), unsafe.Pointer(&struct{ bones gdextension.Array }{pointers.Get(gd.InternalArray(bones))}))
}

/*
Adds a collision exception to the physical bone.
Works just like the [RigidBody3D] node.
*/
//go:nosplit
func (self class) PhysicalBonesAddCollisionException(exception RID.Any) { //gd:Skeleton3D.physical_bones_add_collision_exception
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.physical_bones_add_collision_exception, 0|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ exception RID.Any }{exception}))
}

/*
Removes a collision exception to the physical bone.
Works just like the [RigidBody3D] node.
*/
//go:nosplit
func (self class) PhysicalBonesRemoveCollisionException(exception RID.Any) { //gd:Skeleton3D.physical_bones_remove_collision_exception
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.physical_bones_remove_collision_exception, 0|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ exception RID.Any }{exception}))
}
func (self Instance) OnRestUpdated(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("rest_updated"), gd.NewCallable(cb), 0)
}

func (self Instance) OnPoseUpdated(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("pose_updated"), gd.NewCallable(cb), 0)
}

func (self Instance) OnSkeletonUpdated(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("skeleton_updated"), gd.NewCallable(cb), 0)
}

func (self Instance) OnBoneEnabledChanged(cb func(bone_idx int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("bone_enabled_changed"), gd.NewCallable(cb), 0)
}

func (self Instance) OnBoneListChanged(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("bone_list_changed"), gd.NewCallable(cb), 0)
}

func (self Instance) OnShowRestOnlyChanged(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("show_rest_only_changed"), gd.NewCallable(cb), 0)
}

func (self class) AsSkeleton3D() Advanced            { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsSkeleton3D() Instance         { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsSkeleton3D() Instance    { return self.Super().AsSkeleton3D() }
func (self class) AsNode3D() Node3D.Advanced         { return *((*Node3D.Advanced)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsNode3D() Node3D.Instance { return self.Super().AsNode3D() }
func (self Instance) AsNode3D() Node3D.Instance      { return *((*Node3D.Instance)(unsafe.Pointer(&self))) }
func (self class) AsNode() Node.Advanced             { return *((*Node.Advanced)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsNode() Node.Instance     { return self.Super().AsNode() }
func (self Instance) AsNode() Node.Instance          { return *((*Node.Instance)(unsafe.Pointer(&self))) }

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Node3D.Advanced(self.AsNode3D()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Node3D.Instance(self.AsNode3D()), name)
	}
}
func init() {
	gdclass.Register("Skeleton3D", func(ptr gd.Object) any { return *(*Instance)(unsafe.Pointer(&ptr)) })
}

type ModifierCallbackModeProcess int //gd:Skeleton3D.ModifierCallbackModeProcess

const (
	/*Set a flag to process modification during physics frames (see [constant Node.NOTIFICATION_INTERNAL_PHYSICS_PROCESS]).*/
	ModifierCallbackModeProcessPhysics ModifierCallbackModeProcess = 0
	/*Set a flag to process modification during process frames (see [constant Node.NOTIFICATION_INTERNAL_PROCESS]).*/
	ModifierCallbackModeProcessIdle ModifierCallbackModeProcess = 1
)
const NotificationUpdateSkeleton Object.Notification = 50 //gd:Skeleton3D.NOTIFICATION_UPDATE_SKELETON
