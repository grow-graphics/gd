// Code generated by the generate package DO NOT EDIT

// Package TileSetAtlasSource provides methods for working with TileSetAtlasSource object instances.
package TileSetAtlasSource

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/Resource"
import "graphics.gd/classdb/Texture2D"
import "graphics.gd/classdb/TileData"
import "graphics.gd/classdb/TileSetSource"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/Rect2i"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"
import "graphics.gd/variant/Vector2"
import "graphics.gd/variant/Vector2i"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
An atlas is a grid of tiles laid out on a texture. Each tile in the grid must be exposed using [method create_tile]. Those tiles are then indexed using their coordinates in the grid.
Each tile can also have a size in the grid coordinates, making it more or less cells in the atlas.
Alternatives version of a tile can be created using [method create_alternative_tile], which are then indexed using an alternative ID. The main tile (the one in the grid), is accessed with an alternative ID equal to 0.
Each tile alternate has a set of properties that is defined by the source's [TileSet] layers. Those properties are stored in a TileData object that can be accessed and modified using [method get_tile_data].
As TileData properties are stored directly in the TileSetAtlasSource resource, their properties might also be set using [code]TileSetAtlasSource.set("<coords_x>:<coords_y>/<alternative_id>/<tile_data_property>")[/code].
*/
type Instance [1]gdclass.TileSetAtlasSource

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	set_texture                       gdextension.MethodForClass `hash:"4051416890"`
	get_texture                       gdextension.MethodForClass `hash:"3635182373"`
	set_margins                       gdextension.MethodForClass `hash:"1130785943"`
	get_margins                       gdextension.MethodForClass `hash:"3690982128"`
	set_separation                    gdextension.MethodForClass `hash:"1130785943"`
	get_separation                    gdextension.MethodForClass `hash:"3690982128"`
	set_texture_region_size           gdextension.MethodForClass `hash:"1130785943"`
	get_texture_region_size           gdextension.MethodForClass `hash:"3690982128"`
	set_use_texture_padding           gdextension.MethodForClass `hash:"2586408642"`
	get_use_texture_padding           gdextension.MethodForClass `hash:"36873697"`
	create_tile                       gdextension.MethodForClass `hash:"190528769"`
	remove_tile                       gdextension.MethodForClass `hash:"1130785943"`
	move_tile_in_atlas                gdextension.MethodForClass `hash:"3870111920"`
	get_tile_size_in_atlas            gdextension.MethodForClass `hash:"3050897911"`
	has_room_for_tile                 gdextension.MethodForClass `hash:"3018597268"`
	get_tiles_to_be_removed_on_change gdextension.MethodForClass `hash:"1240378054"`
	get_tile_at_coords                gdextension.MethodForClass `hash:"3050897911"`
	has_tiles_outside_texture         gdextension.MethodForClass `hash:"36873697"`
	clear_tiles_outside_texture       gdextension.MethodForClass `hash:"3218959716"`
	set_tile_animation_columns        gdextension.MethodForClass `hash:"3200960707"`
	get_tile_animation_columns        gdextension.MethodForClass `hash:"2485466453"`
	set_tile_animation_separation     gdextension.MethodForClass `hash:"1941061099"`
	get_tile_animation_separation     gdextension.MethodForClass `hash:"3050897911"`
	set_tile_animation_speed          gdextension.MethodForClass `hash:"2262553149"`
	get_tile_animation_speed          gdextension.MethodForClass `hash:"719993801"`
	set_tile_animation_mode           gdextension.MethodForClass `hash:"3192753483"`
	get_tile_animation_mode           gdextension.MethodForClass `hash:"4025349959"`
	set_tile_animation_frames_count   gdextension.MethodForClass `hash:"3200960707"`
	get_tile_animation_frames_count   gdextension.MethodForClass `hash:"2485466453"`
	set_tile_animation_frame_duration gdextension.MethodForClass `hash:"2843487787"`
	get_tile_animation_frame_duration gdextension.MethodForClass `hash:"1802448425"`
	get_tile_animation_total_duration gdextension.MethodForClass `hash:"719993801"`
	create_alternative_tile           gdextension.MethodForClass `hash:"2226298068"`
	remove_alternative_tile           gdextension.MethodForClass `hash:"3200960707"`
	set_alternative_tile_id           gdextension.MethodForClass `hash:"1499785778"`
	get_next_alternative_tile_id      gdextension.MethodForClass `hash:"2485466453"`
	get_tile_data                     gdextension.MethodForClass `hash:"3534028207"`
	get_atlas_grid_size               gdextension.MethodForClass `hash:"3690982128"`
	get_tile_texture_region           gdextension.MethodForClass `hash:"241857547"`
	get_runtime_texture               gdextension.MethodForClass `hash:"3635182373"`
	get_runtime_tile_texture_region   gdextension.MethodForClass `hash:"104874263"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("TileSetAtlasSource")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		gdextension.Free(gdextension.TypeStringName, &sname)
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

type Expanded [1]gdclass.TileSetAtlasSource

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsTileSetAtlasSource() Instance
}

/*
Creates a new tile at coordinates [param atlas_coords] with the given [param size].
*/
func (self Instance) CreateTile(atlas_coords Vector2i.XY) { //gd:TileSetAtlasSource.create_tile
	Advanced(self).CreateTile(Vector2i.XY(atlas_coords), Vector2i.XY(gd.Vector2i{1, 1}))
}

/*
Creates a new tile at coordinates [param atlas_coords] with the given [param size].
*/
func (self Expanded) CreateTile(atlas_coords Vector2i.XY, size Vector2i.XY) { //gd:TileSetAtlasSource.create_tile
	Advanced(self).CreateTile(Vector2i.XY(atlas_coords), Vector2i.XY(size))
}

/*
Remove a tile and its alternative at coordinates [param atlas_coords].
*/
func (self Instance) RemoveTile(atlas_coords Vector2i.XY) { //gd:TileSetAtlasSource.remove_tile
	Advanced(self).RemoveTile(Vector2i.XY(atlas_coords))
}

/*
Move the tile and its alternatives at the [param atlas_coords] coordinates to the [param new_atlas_coords] coordinates with the [param new_size] size. This functions will fail if a tile is already present in the given area.
If [param new_atlas_coords] is [code]Vector2i(-1, -1)[/code], keeps the tile's coordinates. If [param new_size] is [code]Vector2i(-1, -1)[/code], keeps the tile's size.
To avoid an error, first check if a move is possible using [method has_room_for_tile].
*/
func (self Instance) MoveTileInAtlas(atlas_coords Vector2i.XY) { //gd:TileSetAtlasSource.move_tile_in_atlas
	Advanced(self).MoveTileInAtlas(Vector2i.XY(atlas_coords), Vector2i.XY(gd.Vector2i{-1, -1}), Vector2i.XY(gd.Vector2i{-1, -1}))
}

/*
Move the tile and its alternatives at the [param atlas_coords] coordinates to the [param new_atlas_coords] coordinates with the [param new_size] size. This functions will fail if a tile is already present in the given area.
If [param new_atlas_coords] is [code]Vector2i(-1, -1)[/code], keeps the tile's coordinates. If [param new_size] is [code]Vector2i(-1, -1)[/code], keeps the tile's size.
To avoid an error, first check if a move is possible using [method has_room_for_tile].
*/
func (self Expanded) MoveTileInAtlas(atlas_coords Vector2i.XY, new_atlas_coords Vector2i.XY, new_size Vector2i.XY) { //gd:TileSetAtlasSource.move_tile_in_atlas
	Advanced(self).MoveTileInAtlas(Vector2i.XY(atlas_coords), Vector2i.XY(new_atlas_coords), Vector2i.XY(new_size))
}

/*
Returns the size of the tile (in the grid coordinates system) at coordinates [param atlas_coords].
*/
func (self Instance) GetTileSizeInAtlas(atlas_coords Vector2i.XY) Vector2i.XY { //gd:TileSetAtlasSource.get_tile_size_in_atlas
	return Vector2i.XY(Advanced(self).GetTileSizeInAtlas(Vector2i.XY(atlas_coords)))
}

/*
Returns whether there is enough room in an atlas to create/modify a tile with the given properties. If [param ignored_tile] is provided, act as is the given tile was not present in the atlas. This may be used when you want to modify a tile's properties.
*/
func (self Instance) HasRoomForTile(atlas_coords Vector2i.XY, size Vector2i.XY, animation_columns int, animation_separation Vector2i.XY, frames_count int) bool { //gd:TileSetAtlasSource.has_room_for_tile
	return bool(Advanced(self).HasRoomForTile(Vector2i.XY(atlas_coords), Vector2i.XY(size), int64(animation_columns), Vector2i.XY(animation_separation), int64(frames_count), Vector2i.XY(gd.Vector2i{-1, -1})))
}

/*
Returns whether there is enough room in an atlas to create/modify a tile with the given properties. If [param ignored_tile] is provided, act as is the given tile was not present in the atlas. This may be used when you want to modify a tile's properties.
*/
func (self Expanded) HasRoomForTile(atlas_coords Vector2i.XY, size Vector2i.XY, animation_columns int, animation_separation Vector2i.XY, frames_count int, ignored_tile Vector2i.XY) bool { //gd:TileSetAtlasSource.has_room_for_tile
	return bool(Advanced(self).HasRoomForTile(Vector2i.XY(atlas_coords), Vector2i.XY(size), int64(animation_columns), Vector2i.XY(animation_separation), int64(frames_count), Vector2i.XY(ignored_tile)))
}

/*
Returns an array of tiles coordinates ID that will be automatically removed when modifying one or several of those properties: [param texture], [param margins], [param separation] or [param texture_region_size]. This can be used to undo changes that would have caused tiles data loss.
*/
func (self Instance) GetTilesToBeRemovedOnChange(texture Texture2D.Instance, margins Vector2i.XY, separation Vector2i.XY, texture_region_size Vector2i.XY) []Vector2.XY { //gd:TileSetAtlasSource.get_tiles_to_be_removed_on_change
	return []Vector2.XY(slices.Collect(Advanced(self).GetTilesToBeRemovedOnChange(texture, Vector2i.XY(margins), Vector2i.XY(separation), Vector2i.XY(texture_region_size)).Values()))
}

/*
If there is a tile covering the [param atlas_coords] coordinates, returns the top-left coordinates of the tile (thus its coordinate ID). Returns [code]Vector2i(-1, -1)[/code] otherwise.
*/
func (self Instance) GetTileAtCoords(atlas_coords Vector2i.XY) Vector2i.XY { //gd:TileSetAtlasSource.get_tile_at_coords
	return Vector2i.XY(Advanced(self).GetTileAtCoords(Vector2i.XY(atlas_coords)))
}

/*
Checks if the source has any tiles that don't fit the texture area (either partially or completely).
*/
func (self Instance) HasTilesOutsideTexture() bool { //gd:TileSetAtlasSource.has_tiles_outside_texture
	return bool(Advanced(self).HasTilesOutsideTexture())
}

/*
Removes all tiles that don't fit the available texture area. This method iterates over all the source's tiles, so it's advised to use [method has_tiles_outside_texture] beforehand.
*/
func (self Instance) ClearTilesOutsideTexture() { //gd:TileSetAtlasSource.clear_tiles_outside_texture
	Advanced(self).ClearTilesOutsideTexture()
}

/*
Sets the number of columns in the animation layout of the tile at coordinates [param atlas_coords]. If set to 0, then the different frames of the animation are laid out as a single horizontal line in the atlas.
*/
func (self Instance) SetTileAnimationColumns(atlas_coords Vector2i.XY, frame_columns int) { //gd:TileSetAtlasSource.set_tile_animation_columns
	Advanced(self).SetTileAnimationColumns(Vector2i.XY(atlas_coords), int64(frame_columns))
}

/*
Returns how many columns the tile at [param atlas_coords] has in its animation layout.
*/
func (self Instance) GetTileAnimationColumns(atlas_coords Vector2i.XY) int { //gd:TileSetAtlasSource.get_tile_animation_columns
	return int(int(Advanced(self).GetTileAnimationColumns(Vector2i.XY(atlas_coords))))
}

/*
Sets the margin (in grid tiles) between each tile in the animation layout of the tile at coordinates [param atlas_coords] has.
*/
func (self Instance) SetTileAnimationSeparation(atlas_coords Vector2i.XY, separation Vector2i.XY) { //gd:TileSetAtlasSource.set_tile_animation_separation
	Advanced(self).SetTileAnimationSeparation(Vector2i.XY(atlas_coords), Vector2i.XY(separation))
}

/*
Returns the separation (as in the atlas grid) between each frame of an animated tile at coordinates [param atlas_coords].
*/
func (self Instance) GetTileAnimationSeparation(atlas_coords Vector2i.XY) Vector2i.XY { //gd:TileSetAtlasSource.get_tile_animation_separation
	return Vector2i.XY(Advanced(self).GetTileAnimationSeparation(Vector2i.XY(atlas_coords)))
}

/*
Sets the animation speed of the tile at coordinates [param atlas_coords] has.
*/
func (self Instance) SetTileAnimationSpeed(atlas_coords Vector2i.XY, speed Float.X) { //gd:TileSetAtlasSource.set_tile_animation_speed
	Advanced(self).SetTileAnimationSpeed(Vector2i.XY(atlas_coords), float64(speed))
}

/*
Returns the animation speed of the tile at coordinates [param atlas_coords].
*/
func (self Instance) GetTileAnimationSpeed(atlas_coords Vector2i.XY) Float.X { //gd:TileSetAtlasSource.get_tile_animation_speed
	return Float.X(Float.X(Advanced(self).GetTileAnimationSpeed(Vector2i.XY(atlas_coords))))
}

/*
Sets the tile animation mode of the tile at [param atlas_coords] to [param mode]. See also [method get_tile_animation_mode].
*/
func (self Instance) SetTileAnimationMode(atlas_coords Vector2i.XY, mode TileAnimationMode) { //gd:TileSetAtlasSource.set_tile_animation_mode
	Advanced(self).SetTileAnimationMode(Vector2i.XY(atlas_coords), mode)
}

/*
Returns the tile animation mode of the tile at [param atlas_coords]. See also [method set_tile_animation_mode].
*/
func (self Instance) GetTileAnimationMode(atlas_coords Vector2i.XY) TileAnimationMode { //gd:TileSetAtlasSource.get_tile_animation_mode
	return TileAnimationMode(Advanced(self).GetTileAnimationMode(Vector2i.XY(atlas_coords)))
}

/*
Sets how many animation frames the tile at coordinates [param atlas_coords] has.
*/
func (self Instance) SetTileAnimationFramesCount(atlas_coords Vector2i.XY, frames_count int) { //gd:TileSetAtlasSource.set_tile_animation_frames_count
	Advanced(self).SetTileAnimationFramesCount(Vector2i.XY(atlas_coords), int64(frames_count))
}

/*
Returns how many animation frames has the tile at coordinates [param atlas_coords].
*/
func (self Instance) GetTileAnimationFramesCount(atlas_coords Vector2i.XY) int { //gd:TileSetAtlasSource.get_tile_animation_frames_count
	return int(int(Advanced(self).GetTileAnimationFramesCount(Vector2i.XY(atlas_coords))))
}

/*
Sets the animation frame [param duration] of frame [param frame_index] for the tile at coordinates [param atlas_coords].
*/
func (self Instance) SetTileAnimationFrameDuration(atlas_coords Vector2i.XY, frame_index int, duration Float.X) { //gd:TileSetAtlasSource.set_tile_animation_frame_duration
	Advanced(self).SetTileAnimationFrameDuration(Vector2i.XY(atlas_coords), int64(frame_index), float64(duration))
}

/*
Returns the animation frame duration of frame [param frame_index] for the tile at coordinates [param atlas_coords].
*/
func (self Instance) GetTileAnimationFrameDuration(atlas_coords Vector2i.XY, frame_index int) Float.X { //gd:TileSetAtlasSource.get_tile_animation_frame_duration
	return Float.X(Float.X(Advanced(self).GetTileAnimationFrameDuration(Vector2i.XY(atlas_coords), int64(frame_index))))
}

/*
Returns the sum of the sum of the frame durations of the tile at coordinates [param atlas_coords]. This value needs to be divided by the animation speed to get the actual animation loop duration.
*/
func (self Instance) GetTileAnimationTotalDuration(atlas_coords Vector2i.XY) Float.X { //gd:TileSetAtlasSource.get_tile_animation_total_duration
	return Float.X(Float.X(Advanced(self).GetTileAnimationTotalDuration(Vector2i.XY(atlas_coords))))
}

/*
Creates an alternative tile for the tile at coordinates [param atlas_coords]. If [param alternative_id_override] is -1, give it an automatically generated unique ID, or assigns it the given ID otherwise.
Returns the new alternative identifier, or -1 if the alternative could not be created with a provided [param alternative_id_override].
*/
func (self Instance) CreateAlternativeTile(atlas_coords Vector2i.XY) int { //gd:TileSetAtlasSource.create_alternative_tile
	return int(int(Advanced(self).CreateAlternativeTile(Vector2i.XY(atlas_coords), int64(-1))))
}

/*
Creates an alternative tile for the tile at coordinates [param atlas_coords]. If [param alternative_id_override] is -1, give it an automatically generated unique ID, or assigns it the given ID otherwise.
Returns the new alternative identifier, or -1 if the alternative could not be created with a provided [param alternative_id_override].
*/
func (self Expanded) CreateAlternativeTile(atlas_coords Vector2i.XY, alternative_id_override int) int { //gd:TileSetAtlasSource.create_alternative_tile
	return int(int(Advanced(self).CreateAlternativeTile(Vector2i.XY(atlas_coords), int64(alternative_id_override))))
}

/*
Remove a tile's alternative with alternative ID [param alternative_tile].
Calling this function with [param alternative_tile] equals to 0 will fail, as the base tile alternative cannot be removed.
*/
func (self Instance) RemoveAlternativeTile(atlas_coords Vector2i.XY, alternative_tile int) { //gd:TileSetAtlasSource.remove_alternative_tile
	Advanced(self).RemoveAlternativeTile(Vector2i.XY(atlas_coords), int64(alternative_tile))
}

/*
Change a tile's alternative ID from [param alternative_tile] to [param new_id].
Calling this function with [param new_id] of 0 will fail, as the base tile alternative cannot be moved.
*/
func (self Instance) SetAlternativeTileId(atlas_coords Vector2i.XY, alternative_tile int, new_id int) { //gd:TileSetAtlasSource.set_alternative_tile_id
	Advanced(self).SetAlternativeTileId(Vector2i.XY(atlas_coords), int64(alternative_tile), int64(new_id))
}

/*
Returns the alternative ID a following call to [method create_alternative_tile] would return.
*/
func (self Instance) GetNextAlternativeTileId(atlas_coords Vector2i.XY) int { //gd:TileSetAtlasSource.get_next_alternative_tile_id
	return int(int(Advanced(self).GetNextAlternativeTileId(Vector2i.XY(atlas_coords))))
}

/*
Returns the [TileData] object for the given atlas coordinates and alternative ID.
*/
func (self Instance) GetTileData(atlas_coords Vector2i.XY, alternative_tile int) TileData.Instance { //gd:TileSetAtlasSource.get_tile_data
	return TileData.Instance(Advanced(self).GetTileData(Vector2i.XY(atlas_coords), int64(alternative_tile)))
}

/*
Returns the atlas grid size, which depends on how many tiles can fit in the texture. It thus depends on the [member texture]'s size, the atlas [member margins], and the tiles' [member texture_region_size].
*/
func (self Instance) GetAtlasGridSize() Vector2i.XY { //gd:TileSetAtlasSource.get_atlas_grid_size
	return Vector2i.XY(Advanced(self).GetAtlasGridSize())
}

/*
Returns a tile's texture region in the atlas texture. For animated tiles, a [param frame] argument might be provided for the different frames of the animation.
*/
func (self Instance) GetTileTextureRegion(atlas_coords Vector2i.XY) Rect2i.PositionSize { //gd:TileSetAtlasSource.get_tile_texture_region
	return Rect2i.PositionSize(Advanced(self).GetTileTextureRegion(Vector2i.XY(atlas_coords), int64(0)))
}

/*
Returns a tile's texture region in the atlas texture. For animated tiles, a [param frame] argument might be provided for the different frames of the animation.
*/
func (self Expanded) GetTileTextureRegion(atlas_coords Vector2i.XY, frame_ int) Rect2i.PositionSize { //gd:TileSetAtlasSource.get_tile_texture_region
	return Rect2i.PositionSize(Advanced(self).GetTileTextureRegion(Vector2i.XY(atlas_coords), int64(frame_)))
}

/*
If [member use_texture_padding] is [code]false[/code], returns [member texture]. Otherwise, returns and internal [ImageTexture] created that includes the padding.
*/
func (self Instance) GetRuntimeTexture() Texture2D.Instance { //gd:TileSetAtlasSource.get_runtime_texture
	return Texture2D.Instance(Advanced(self).GetRuntimeTexture())
}

/*
Returns the region of the tile at coordinates [param atlas_coords] for the given [param frame] inside the texture returned by [method get_runtime_texture].
[b]Note:[/b] If [member use_texture_padding] is [code]false[/code], returns the same as [method get_tile_texture_region].
*/
func (self Instance) GetRuntimeTileTextureRegion(atlas_coords Vector2i.XY, frame_ int) Rect2i.PositionSize { //gd:TileSetAtlasSource.get_runtime_tile_texture_region
	return Rect2i.PositionSize(Advanced(self).GetRuntimeTileTextureRegion(Vector2i.XY(atlas_coords), int64(frame_)))
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.TileSetAtlasSource

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.TileSetAtlasSource)(unsafe.Pointer(&obj))
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.TileSetAtlasSource)(unsafe.Pointer(&obj))
		return true
	}
	return false
}

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {

	if !gd.Linked {
		var placeholder Instance
		*(*gd.Object)(unsafe.Pointer(&placeholder)) = pointers.Add[gd.Object]([3]uint64{})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(*(*gd.Object)(unsafe.Pointer(&placeholder)), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	object := [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})}
	casted := Instance{*(*gdclass.TileSetAtlasSource)(unsafe.Pointer(&object))}
	object[0].Notification(0, false)
	return casted
}

func (self Instance) Texture() Texture2D.Instance {
	return Texture2D.Instance(class(self).GetTexture())
}

func (self Instance) SetTexture(value Texture2D.Instance) {
	class(self).SetTexture(value)
}

func (self Instance) Margins() Vector2i.XY {
	return Vector2i.XY(class(self).GetMargins())
}

func (self Instance) SetMargins(value Vector2i.XY) {
	class(self).SetMargins(Vector2i.XY(value))
}

func (self Instance) Separation() Vector2i.XY {
	return Vector2i.XY(class(self).GetSeparation())
}

func (self Instance) SetSeparation(value Vector2i.XY) {
	class(self).SetSeparation(Vector2i.XY(value))
}

func (self Instance) TextureRegionSize() Vector2i.XY {
	return Vector2i.XY(class(self).GetTextureRegionSize())
}

func (self Instance) SetTextureRegionSize(value Vector2i.XY) {
	class(self).SetTextureRegionSize(Vector2i.XY(value))
}

func (self Instance) UseTexturePadding() bool {
	return bool(class(self).GetUseTexturePadding())
}

func (self Instance) SetUseTexturePadding(value bool) {
	class(self).SetUseTexturePadding(value)
}

//go:nosplit
func (self class) SetTexture(texture [1]gdclass.Texture2D) { //gd:TileSetAtlasSource.set_texture
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_texture, 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ texture gdextension.Object }{gdextension.Object(gd.CallerIncrements(texture[0].AsObject()))}))
}

//go:nosplit
func (self class) GetTexture() [1]gdclass.Texture2D { //gd:TileSetAtlasSource.get_texture
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_texture, gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.Texture2D{gd.PointerWithOwnershipTransferredToGo[gdclass.Texture2D](r_ret)}
	return ret
}

//go:nosplit
func (self class) SetMargins(margins Vector2i.XY) { //gd:TileSetAtlasSource.set_margins
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_margins, 0|(gdextension.SizeVector2i<<4), unsafe.Pointer(&struct{ margins Vector2i.XY }{margins}))
}

//go:nosplit
func (self class) GetMargins() Vector2i.XY { //gd:TileSetAtlasSource.get_margins
	var r_ret = gdextension.Call[Vector2i.XY](gd.ObjectChecked(self.AsObject()), methods.get_margins, gdextension.SizeVector2i, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetSeparation(separation Vector2i.XY) { //gd:TileSetAtlasSource.set_separation
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_separation, 0|(gdextension.SizeVector2i<<4), unsafe.Pointer(&struct{ separation Vector2i.XY }{separation}))
}

//go:nosplit
func (self class) GetSeparation() Vector2i.XY { //gd:TileSetAtlasSource.get_separation
	var r_ret = gdextension.Call[Vector2i.XY](gd.ObjectChecked(self.AsObject()), methods.get_separation, gdextension.SizeVector2i, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetTextureRegionSize(texture_region_size Vector2i.XY) { //gd:TileSetAtlasSource.set_texture_region_size
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_texture_region_size, 0|(gdextension.SizeVector2i<<4), unsafe.Pointer(&struct{ texture_region_size Vector2i.XY }{texture_region_size}))
}

//go:nosplit
func (self class) GetTextureRegionSize() Vector2i.XY { //gd:TileSetAtlasSource.get_texture_region_size
	var r_ret = gdextension.Call[Vector2i.XY](gd.ObjectChecked(self.AsObject()), methods.get_texture_region_size, gdextension.SizeVector2i, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetUseTexturePadding(use_texture_padding bool) { //gd:TileSetAtlasSource.set_use_texture_padding
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_use_texture_padding, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ use_texture_padding bool }{use_texture_padding}))
}

//go:nosplit
func (self class) GetUseTexturePadding() bool { //gd:TileSetAtlasSource.get_use_texture_padding
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.get_use_texture_padding, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Creates a new tile at coordinates [param atlas_coords] with the given [param size].
*/
//go:nosplit
func (self class) CreateTile(atlas_coords Vector2i.XY, size Vector2i.XY) { //gd:TileSetAtlasSource.create_tile
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.create_tile, 0|(gdextension.SizeVector2i<<4)|(gdextension.SizeVector2i<<8), unsafe.Pointer(&struct {
		atlas_coords Vector2i.XY
		size         Vector2i.XY
	}{atlas_coords, size}))
}

/*
Remove a tile and its alternative at coordinates [param atlas_coords].
*/
//go:nosplit
func (self class) RemoveTile(atlas_coords Vector2i.XY) { //gd:TileSetAtlasSource.remove_tile
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.remove_tile, 0|(gdextension.SizeVector2i<<4), unsafe.Pointer(&struct{ atlas_coords Vector2i.XY }{atlas_coords}))
}

/*
Move the tile and its alternatives at the [param atlas_coords] coordinates to the [param new_atlas_coords] coordinates with the [param new_size] size. This functions will fail if a tile is already present in the given area.
If [param new_atlas_coords] is [code]Vector2i(-1, -1)[/code], keeps the tile's coordinates. If [param new_size] is [code]Vector2i(-1, -1)[/code], keeps the tile's size.
To avoid an error, first check if a move is possible using [method has_room_for_tile].
*/
//go:nosplit
func (self class) MoveTileInAtlas(atlas_coords Vector2i.XY, new_atlas_coords Vector2i.XY, new_size Vector2i.XY) { //gd:TileSetAtlasSource.move_tile_in_atlas
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.move_tile_in_atlas, 0|(gdextension.SizeVector2i<<4)|(gdextension.SizeVector2i<<8)|(gdextension.SizeVector2i<<12), unsafe.Pointer(&struct {
		atlas_coords     Vector2i.XY
		new_atlas_coords Vector2i.XY
		new_size         Vector2i.XY
	}{atlas_coords, new_atlas_coords, new_size}))
}

/*
Returns the size of the tile (in the grid coordinates system) at coordinates [param atlas_coords].
*/
//go:nosplit
func (self class) GetTileSizeInAtlas(atlas_coords Vector2i.XY) Vector2i.XY { //gd:TileSetAtlasSource.get_tile_size_in_atlas
	var r_ret = gdextension.Call[Vector2i.XY](gd.ObjectChecked(self.AsObject()), methods.get_tile_size_in_atlas, gdextension.SizeVector2i|(gdextension.SizeVector2i<<4), unsafe.Pointer(&struct{ atlas_coords Vector2i.XY }{atlas_coords}))
	var ret = r_ret
	return ret
}

/*
Returns whether there is enough room in an atlas to create/modify a tile with the given properties. If [param ignored_tile] is provided, act as is the given tile was not present in the atlas. This may be used when you want to modify a tile's properties.
*/
//go:nosplit
func (self class) HasRoomForTile(atlas_coords Vector2i.XY, size Vector2i.XY, animation_columns int64, animation_separation Vector2i.XY, frames_count int64, ignored_tile Vector2i.XY) bool { //gd:TileSetAtlasSource.has_room_for_tile
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.has_room_for_tile, gdextension.SizeBool|(gdextension.SizeVector2i<<4)|(gdextension.SizeVector2i<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeVector2i<<16)|(gdextension.SizeInt<<20)|(gdextension.SizeVector2i<<24), unsafe.Pointer(&struct {
		atlas_coords         Vector2i.XY
		size                 Vector2i.XY
		animation_columns    int64
		animation_separation Vector2i.XY
		frames_count         int64
		ignored_tile         Vector2i.XY
	}{atlas_coords, size, animation_columns, animation_separation, frames_count, ignored_tile}))
	var ret = r_ret
	return ret
}

/*
Returns an array of tiles coordinates ID that will be automatically removed when modifying one or several of those properties: [param texture], [param margins], [param separation] or [param texture_region_size]. This can be used to undo changes that would have caused tiles data loss.
*/
//go:nosplit
func (self class) GetTilesToBeRemovedOnChange(texture [1]gdclass.Texture2D, margins Vector2i.XY, separation Vector2i.XY, texture_region_size Vector2i.XY) Packed.Array[Vector2.XY] { //gd:TileSetAtlasSource.get_tiles_to_be_removed_on_change
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.get_tiles_to_be_removed_on_change, gdextension.SizePackedArray|(gdextension.SizeObject<<4)|(gdextension.SizeVector2i<<8)|(gdextension.SizeVector2i<<12)|(gdextension.SizeVector2i<<16), unsafe.Pointer(&struct {
		texture             gdextension.Object
		margins             Vector2i.XY
		separation          Vector2i.XY
		texture_region_size Vector2i.XY
	}{gdextension.Object(gd.ObjectChecked(texture[0].AsObject())), margins, separation, texture_region_size}))
	var ret = Packed.Array[Vector2.XY](Array.Through(gd.PackedProxy[gd.PackedVector2Array, Vector2.XY]{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

/*
If there is a tile covering the [param atlas_coords] coordinates, returns the top-left coordinates of the tile (thus its coordinate ID). Returns [code]Vector2i(-1, -1)[/code] otherwise.
*/
//go:nosplit
func (self class) GetTileAtCoords(atlas_coords Vector2i.XY) Vector2i.XY { //gd:TileSetAtlasSource.get_tile_at_coords
	var r_ret = gdextension.Call[Vector2i.XY](gd.ObjectChecked(self.AsObject()), methods.get_tile_at_coords, gdextension.SizeVector2i|(gdextension.SizeVector2i<<4), unsafe.Pointer(&struct{ atlas_coords Vector2i.XY }{atlas_coords}))
	var ret = r_ret
	return ret
}

/*
Checks if the source has any tiles that don't fit the texture area (either partially or completely).
*/
//go:nosplit
func (self class) HasTilesOutsideTexture() bool { //gd:TileSetAtlasSource.has_tiles_outside_texture
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.has_tiles_outside_texture, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Removes all tiles that don't fit the available texture area. This method iterates over all the source's tiles, so it's advised to use [method has_tiles_outside_texture] beforehand.
*/
//go:nosplit
func (self class) ClearTilesOutsideTexture() { //gd:TileSetAtlasSource.clear_tiles_outside_texture
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.clear_tiles_outside_texture, 0, unsafe.Pointer(&struct{}{}))
}

/*
Sets the number of columns in the animation layout of the tile at coordinates [param atlas_coords]. If set to 0, then the different frames of the animation are laid out as a single horizontal line in the atlas.
*/
//go:nosplit
func (self class) SetTileAnimationColumns(atlas_coords Vector2i.XY, frame_columns int64) { //gd:TileSetAtlasSource.set_tile_animation_columns
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_tile_animation_columns, 0|(gdextension.SizeVector2i<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		atlas_coords  Vector2i.XY
		frame_columns int64
	}{atlas_coords, frame_columns}))
}

/*
Returns how many columns the tile at [param atlas_coords] has in its animation layout.
*/
//go:nosplit
func (self class) GetTileAnimationColumns(atlas_coords Vector2i.XY) int64 { //gd:TileSetAtlasSource.get_tile_animation_columns
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_tile_animation_columns, gdextension.SizeInt|(gdextension.SizeVector2i<<4), unsafe.Pointer(&struct{ atlas_coords Vector2i.XY }{atlas_coords}))
	var ret = r_ret
	return ret
}

/*
Sets the margin (in grid tiles) between each tile in the animation layout of the tile at coordinates [param atlas_coords] has.
*/
//go:nosplit
func (self class) SetTileAnimationSeparation(atlas_coords Vector2i.XY, separation Vector2i.XY) { //gd:TileSetAtlasSource.set_tile_animation_separation
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_tile_animation_separation, 0|(gdextension.SizeVector2i<<4)|(gdextension.SizeVector2i<<8), unsafe.Pointer(&struct {
		atlas_coords Vector2i.XY
		separation   Vector2i.XY
	}{atlas_coords, separation}))
}

/*
Returns the separation (as in the atlas grid) between each frame of an animated tile at coordinates [param atlas_coords].
*/
//go:nosplit
func (self class) GetTileAnimationSeparation(atlas_coords Vector2i.XY) Vector2i.XY { //gd:TileSetAtlasSource.get_tile_animation_separation
	var r_ret = gdextension.Call[Vector2i.XY](gd.ObjectChecked(self.AsObject()), methods.get_tile_animation_separation, gdextension.SizeVector2i|(gdextension.SizeVector2i<<4), unsafe.Pointer(&struct{ atlas_coords Vector2i.XY }{atlas_coords}))
	var ret = r_ret
	return ret
}

/*
Sets the animation speed of the tile at coordinates [param atlas_coords] has.
*/
//go:nosplit
func (self class) SetTileAnimationSpeed(atlas_coords Vector2i.XY, speed float64) { //gd:TileSetAtlasSource.set_tile_animation_speed
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_tile_animation_speed, 0|(gdextension.SizeVector2i<<4)|(gdextension.SizeFloat<<8), unsafe.Pointer(&struct {
		atlas_coords Vector2i.XY
		speed        float64
	}{atlas_coords, speed}))
}

/*
Returns the animation speed of the tile at coordinates [param atlas_coords].
*/
//go:nosplit
func (self class) GetTileAnimationSpeed(atlas_coords Vector2i.XY) float64 { //gd:TileSetAtlasSource.get_tile_animation_speed
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_tile_animation_speed, gdextension.SizeFloat|(gdextension.SizeVector2i<<4), unsafe.Pointer(&struct{ atlas_coords Vector2i.XY }{atlas_coords}))
	var ret = r_ret
	return ret
}

/*
Sets the tile animation mode of the tile at [param atlas_coords] to [param mode]. See also [method get_tile_animation_mode].
*/
//go:nosplit
func (self class) SetTileAnimationMode(atlas_coords Vector2i.XY, mode TileAnimationMode) { //gd:TileSetAtlasSource.set_tile_animation_mode
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_tile_animation_mode, 0|(gdextension.SizeVector2i<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		atlas_coords Vector2i.XY
		mode         TileAnimationMode
	}{atlas_coords, mode}))
}

/*
Returns the tile animation mode of the tile at [param atlas_coords]. See also [method set_tile_animation_mode].
*/
//go:nosplit
func (self class) GetTileAnimationMode(atlas_coords Vector2i.XY) TileAnimationMode { //gd:TileSetAtlasSource.get_tile_animation_mode
	var r_ret = gdextension.Call[TileAnimationMode](gd.ObjectChecked(self.AsObject()), methods.get_tile_animation_mode, gdextension.SizeInt|(gdextension.SizeVector2i<<4), unsafe.Pointer(&struct{ atlas_coords Vector2i.XY }{atlas_coords}))
	var ret = r_ret
	return ret
}

/*
Sets how many animation frames the tile at coordinates [param atlas_coords] has.
*/
//go:nosplit
func (self class) SetTileAnimationFramesCount(atlas_coords Vector2i.XY, frames_count int64) { //gd:TileSetAtlasSource.set_tile_animation_frames_count
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_tile_animation_frames_count, 0|(gdextension.SizeVector2i<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		atlas_coords Vector2i.XY
		frames_count int64
	}{atlas_coords, frames_count}))
}

/*
Returns how many animation frames has the tile at coordinates [param atlas_coords].
*/
//go:nosplit
func (self class) GetTileAnimationFramesCount(atlas_coords Vector2i.XY) int64 { //gd:TileSetAtlasSource.get_tile_animation_frames_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_tile_animation_frames_count, gdextension.SizeInt|(gdextension.SizeVector2i<<4), unsafe.Pointer(&struct{ atlas_coords Vector2i.XY }{atlas_coords}))
	var ret = r_ret
	return ret
}

/*
Sets the animation frame [param duration] of frame [param frame_index] for the tile at coordinates [param atlas_coords].
*/
//go:nosplit
func (self class) SetTileAnimationFrameDuration(atlas_coords Vector2i.XY, frame_index int64, duration float64) { //gd:TileSetAtlasSource.set_tile_animation_frame_duration
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_tile_animation_frame_duration, 0|(gdextension.SizeVector2i<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeFloat<<12), unsafe.Pointer(&struct {
		atlas_coords Vector2i.XY
		frame_index  int64
		duration     float64
	}{atlas_coords, frame_index, duration}))
}

/*
Returns the animation frame duration of frame [param frame_index] for the tile at coordinates [param atlas_coords].
*/
//go:nosplit
func (self class) GetTileAnimationFrameDuration(atlas_coords Vector2i.XY, frame_index int64) float64 { //gd:TileSetAtlasSource.get_tile_animation_frame_duration
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_tile_animation_frame_duration, gdextension.SizeFloat|(gdextension.SizeVector2i<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		atlas_coords Vector2i.XY
		frame_index  int64
	}{atlas_coords, frame_index}))
	var ret = r_ret
	return ret
}

/*
Returns the sum of the sum of the frame durations of the tile at coordinates [param atlas_coords]. This value needs to be divided by the animation speed to get the actual animation loop duration.
*/
//go:nosplit
func (self class) GetTileAnimationTotalDuration(atlas_coords Vector2i.XY) float64 { //gd:TileSetAtlasSource.get_tile_animation_total_duration
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_tile_animation_total_duration, gdextension.SizeFloat|(gdextension.SizeVector2i<<4), unsafe.Pointer(&struct{ atlas_coords Vector2i.XY }{atlas_coords}))
	var ret = r_ret
	return ret
}

/*
Creates an alternative tile for the tile at coordinates [param atlas_coords]. If [param alternative_id_override] is -1, give it an automatically generated unique ID, or assigns it the given ID otherwise.
Returns the new alternative identifier, or -1 if the alternative could not be created with a provided [param alternative_id_override].
*/
//go:nosplit
func (self class) CreateAlternativeTile(atlas_coords Vector2i.XY, alternative_id_override int64) int64 { //gd:TileSetAtlasSource.create_alternative_tile
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.create_alternative_tile, gdextension.SizeInt|(gdextension.SizeVector2i<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		atlas_coords            Vector2i.XY
		alternative_id_override int64
	}{atlas_coords, alternative_id_override}))
	var ret = r_ret
	return ret
}

/*
Remove a tile's alternative with alternative ID [param alternative_tile].
Calling this function with [param alternative_tile] equals to 0 will fail, as the base tile alternative cannot be removed.
*/
//go:nosplit
func (self class) RemoveAlternativeTile(atlas_coords Vector2i.XY, alternative_tile int64) { //gd:TileSetAtlasSource.remove_alternative_tile
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.remove_alternative_tile, 0|(gdextension.SizeVector2i<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		atlas_coords     Vector2i.XY
		alternative_tile int64
	}{atlas_coords, alternative_tile}))
}

/*
Change a tile's alternative ID from [param alternative_tile] to [param new_id].
Calling this function with [param new_id] of 0 will fail, as the base tile alternative cannot be moved.
*/
//go:nosplit
func (self class) SetAlternativeTileId(atlas_coords Vector2i.XY, alternative_tile int64, new_id int64) { //gd:TileSetAtlasSource.set_alternative_tile_id
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_alternative_tile_id, 0|(gdextension.SizeVector2i<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		atlas_coords     Vector2i.XY
		alternative_tile int64
		new_id           int64
	}{atlas_coords, alternative_tile, new_id}))
}

/*
Returns the alternative ID a following call to [method create_alternative_tile] would return.
*/
//go:nosplit
func (self class) GetNextAlternativeTileId(atlas_coords Vector2i.XY) int64 { //gd:TileSetAtlasSource.get_next_alternative_tile_id
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_next_alternative_tile_id, gdextension.SizeInt|(gdextension.SizeVector2i<<4), unsafe.Pointer(&struct{ atlas_coords Vector2i.XY }{atlas_coords}))
	var ret = r_ret
	return ret
}

/*
Returns the [TileData] object for the given atlas coordinates and alternative ID.
*/
//go:nosplit
func (self class) GetTileData(atlas_coords Vector2i.XY, alternative_tile int64) [1]gdclass.TileData { //gd:TileSetAtlasSource.get_tile_data
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_tile_data, gdextension.SizeObject|(gdextension.SizeVector2i<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		atlas_coords     Vector2i.XY
		alternative_tile int64
	}{atlas_coords, alternative_tile}))
	var ret = [1]gdclass.TileData{gd.PointerMustAssertInstanceID[gdclass.TileData](r_ret)}
	return ret
}

/*
Returns the atlas grid size, which depends on how many tiles can fit in the texture. It thus depends on the [member texture]'s size, the atlas [member margins], and the tiles' [member texture_region_size].
*/
//go:nosplit
func (self class) GetAtlasGridSize() Vector2i.XY { //gd:TileSetAtlasSource.get_atlas_grid_size
	var r_ret = gdextension.Call[Vector2i.XY](gd.ObjectChecked(self.AsObject()), methods.get_atlas_grid_size, gdextension.SizeVector2i, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns a tile's texture region in the atlas texture. For animated tiles, a [param frame] argument might be provided for the different frames of the animation.
*/
//go:nosplit
func (self class) GetTileTextureRegion(atlas_coords Vector2i.XY, frame_ int64) Rect2i.PositionSize { //gd:TileSetAtlasSource.get_tile_texture_region
	var r_ret = gdextension.Call[Rect2i.PositionSize](gd.ObjectChecked(self.AsObject()), methods.get_tile_texture_region, gdextension.SizeRect2i|(gdextension.SizeVector2i<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		atlas_coords Vector2i.XY
		frame_       int64
	}{atlas_coords, frame_}))
	var ret = r_ret
	return ret
}

/*
If [member use_texture_padding] is [code]false[/code], returns [member texture]. Otherwise, returns and internal [ImageTexture] created that includes the padding.
*/
//go:nosplit
func (self class) GetRuntimeTexture() [1]gdclass.Texture2D { //gd:TileSetAtlasSource.get_runtime_texture
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_runtime_texture, gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.Texture2D{gd.PointerWithOwnershipTransferredToGo[gdclass.Texture2D](r_ret)}
	return ret
}

/*
Returns the region of the tile at coordinates [param atlas_coords] for the given [param frame] inside the texture returned by [method get_runtime_texture].
[b]Note:[/b] If [member use_texture_padding] is [code]false[/code], returns the same as [method get_tile_texture_region].
*/
//go:nosplit
func (self class) GetRuntimeTileTextureRegion(atlas_coords Vector2i.XY, frame_ int64) Rect2i.PositionSize { //gd:TileSetAtlasSource.get_runtime_tile_texture_region
	var r_ret = gdextension.Call[Rect2i.PositionSize](gd.ObjectChecked(self.AsObject()), methods.get_runtime_tile_texture_region, gdextension.SizeRect2i|(gdextension.SizeVector2i<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		atlas_coords Vector2i.XY
		frame_       int64
	}{atlas_coords, frame_}))
	var ret = r_ret
	return ret
}
func (self class) AsTileSetAtlasSource() Advanced         { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsTileSetAtlasSource() Instance      { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsTileSetAtlasSource() Instance { return self.Super().AsTileSetAtlasSource() }
func (self class) AsTileSetSource() TileSetSource.Advanced {
	return *((*TileSetSource.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsTileSetSource() TileSetSource.Instance {
	return self.Super().AsTileSetSource()
}
func (self Instance) AsTileSetSource() TileSetSource.Instance {
	return *((*TileSetSource.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsResource() Resource.Advanced {
	return *((*Resource.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsResource() Resource.Instance { return self.Super().AsResource() }
func (self Instance) AsResource() Resource.Instance {
	return *((*Resource.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsRefCounted() [1]gd.RefCounted { return self.Super().AsRefCounted() }
func (self Instance) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(TileSetSource.Advanced(self.AsTileSetSource()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(TileSetSource.Instance(self.AsTileSetSource()), name)
	}
}
func init() {
	gdclass.Register("TileSetAtlasSource", func(ptr gd.Object) any { return *(*Instance)(unsafe.Pointer(&ptr)) })
}

type TileAnimationMode int //gd:TileSetAtlasSource.TileAnimationMode

const (
	/*Tile animations start at same time, looking identical.*/
	TileAnimationModeDefault TileAnimationMode = 0
	/*Tile animations start at random times, looking varied.*/
	TileAnimationModeRandomStartTimes TileAnimationMode = 1
	/*Represents the size of the [enum TileAnimationMode] enum.*/
	TileAnimationModeMax TileAnimationMode = 2
)
const TransformFlipH = 4096      //gd:TileSetAtlasSource.TRANSFORM_FLIP_H
const TransformFlipV = 8192      //gd:TileSetAtlasSource.TRANSFORM_FLIP_V
const TransformTranspose = 16384 //gd:TileSetAtlasSource.TRANSFORM_TRANSPOSE
