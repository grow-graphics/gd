// Code generated by the generate package DO NOT EDIT

// Package MeshInstance3D provides methods for working with MeshInstance3D object instances.
package MeshInstance3D

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/variant/Signal"
import "graphics.gd/classdb/ArrayMesh"
import "graphics.gd/classdb/GeometryInstance3D"
import "graphics.gd/classdb/Material"
import "graphics.gd/classdb/Mesh"
import "graphics.gd/classdb/MeshConvexDecompositionSettings"
import "graphics.gd/classdb/Node"
import "graphics.gd/classdb/Node3D"
import "graphics.gd/classdb/Skin"
import "graphics.gd/classdb/SkinReference"
import "graphics.gd/classdb/VisualInstance3D"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Signal.Any
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
MeshInstance3D is a node that takes a [Mesh] resource and adds it to the current scenario by creating an instance of it. This is the class most often used render 3D geometry and can be used to instance a single [Mesh] in many places. This allows reusing geometry, which can save on resources. When a [Mesh] has to be instantiated more than thousands of times at close proximity, consider using a [MultiMesh] in a [MultiMeshInstance3D] instead.
*/
type Instance [1]gdclass.MeshInstance3D

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	set_mesh                               gdextension.MethodForClass `hash:"194775623"`
	get_mesh                               gdextension.MethodForClass `hash:"1808005922"`
	set_skeleton_path                      gdextension.MethodForClass `hash:"1348162250"`
	get_skeleton_path                      gdextension.MethodForClass `hash:"277076166"`
	set_skin                               gdextension.MethodForClass `hash:"3971435618"`
	get_skin                               gdextension.MethodForClass `hash:"2074563878"`
	get_skin_reference                     gdextension.MethodForClass `hash:"2060603409"`
	get_surface_override_material_count    gdextension.MethodForClass `hash:"3905245786"`
	set_surface_override_material          gdextension.MethodForClass `hash:"3671737478"`
	get_surface_override_material          gdextension.MethodForClass `hash:"2897466400"`
	get_active_material                    gdextension.MethodForClass `hash:"2897466400"`
	create_trimesh_collision               gdextension.MethodForClass `hash:"3218959716"`
	create_convex_collision                gdextension.MethodForClass `hash:"2751962654"`
	create_multiple_convex_collisions      gdextension.MethodForClass `hash:"628789669"`
	get_blend_shape_count                  gdextension.MethodForClass `hash:"3905245786"`
	find_blend_shape_by_name               gdextension.MethodForClass `hash:"4150868206"`
	get_blend_shape_value                  gdextension.MethodForClass `hash:"2339986948"`
	set_blend_shape_value                  gdextension.MethodForClass `hash:"1602489585"`
	create_debug_tangents                  gdextension.MethodForClass `hash:"3218959716"`
	bake_mesh_from_current_blend_shape_mix gdextension.MethodForClass `hash:"1457573577"`
	bake_mesh_from_current_skeleton_pose   gdextension.MethodForClass `hash:"1457573577"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("MeshInstance3D")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		gdextension.Free(gdextension.TypeStringName, &sname)
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

type Expanded [1]gdclass.MeshInstance3D

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsMeshInstance3D() Instance
}

/*
Returns the internal [SkinReference] containing the skeleton's [RID] attached to this RID. See also [method Resource.get_rid], [method SkinReference.get_skeleton], and [method RenderingServer.instance_attach_skeleton].
*/
func (self Instance) GetSkinReference() SkinReference.Instance { //gd:MeshInstance3D.get_skin_reference
	return SkinReference.Instance(Advanced(self).GetSkinReference())
}

/*
Returns the number of surface override materials. This is equivalent to [method Mesh.get_surface_count]. See also [method get_surface_override_material].
*/
func (self Instance) GetSurfaceOverrideMaterialCount() int { //gd:MeshInstance3D.get_surface_override_material_count
	return int(int(Advanced(self).GetSurfaceOverrideMaterialCount()))
}

/*
Sets the override [param material] for the specified [param surface] of the [Mesh] resource. This material is associated with this [MeshInstance3D] rather than with [member mesh].
[b]Note:[/b] This assigns the [Material] associated to the [MeshInstance3D]'s Surface Material Override properties, not the material within the [Mesh] resource. To set the material within the [Mesh] resource, use [method Mesh.surface_set_material] instead.
*/
func (self Instance) SetSurfaceOverrideMaterial(surface int, material Material.Instance) { //gd:MeshInstance3D.set_surface_override_material
	Advanced(self).SetSurfaceOverrideMaterial(int64(surface), material)
}

/*
Returns the override [Material] for the specified [param surface] of the [Mesh] resource. See also [method get_surface_override_material_count].
[b]Note:[/b] This returns the [Material] associated to the [MeshInstance3D]'s Surface Material Override properties, not the material within the [Mesh] resource. To get the material within the [Mesh] resource, use [method Mesh.surface_get_material] instead.
*/
func (self Instance) GetSurfaceOverrideMaterial(surface int) Material.Instance { //gd:MeshInstance3D.get_surface_override_material
	return Material.Instance(Advanced(self).GetSurfaceOverrideMaterial(int64(surface)))
}

/*
Returns the [Material] that will be used by the [Mesh] when drawing. This can return the [member GeometryInstance3D.material_override], the surface override [Material] defined in this [MeshInstance3D], or the surface [Material] defined in the [member mesh]. For example, if [member GeometryInstance3D.material_override] is used, all surfaces will return the override material.
Returns [code]null[/code] if no material is active, including when [member mesh] is [code]null[/code].
*/
func (self Instance) GetActiveMaterial(surface int) Material.Instance { //gd:MeshInstance3D.get_active_material
	return Material.Instance(Advanced(self).GetActiveMaterial(int64(surface)))
}

/*
This helper creates a [StaticBody3D] child node with a [ConcavePolygonShape3D] collision shape calculated from the mesh geometry. It's mainly used for testing.
*/
func (self Instance) CreateTrimeshCollision() { //gd:MeshInstance3D.create_trimesh_collision
	Advanced(self).CreateTrimeshCollision()
}

/*
This helper creates a [StaticBody3D] child node with a [ConvexPolygonShape3D] collision shape calculated from the mesh geometry. It's mainly used for testing.
If [param clean] is [code]true[/code] (default), duplicate and interior vertices are removed automatically. You can set it to [code]false[/code] to make the process faster if not needed.
If [param simplify] is [code]true[/code], the geometry can be further simplified to reduce the number of vertices. Disabled by default.
*/
func (self Instance) CreateConvexCollision() { //gd:MeshInstance3D.create_convex_collision
	Advanced(self).CreateConvexCollision(true, false)
}

/*
This helper creates a [StaticBody3D] child node with a [ConvexPolygonShape3D] collision shape calculated from the mesh geometry. It's mainly used for testing.
If [param clean] is [code]true[/code] (default), duplicate and interior vertices are removed automatically. You can set it to [code]false[/code] to make the process faster if not needed.
If [param simplify] is [code]true[/code], the geometry can be further simplified to reduce the number of vertices. Disabled by default.
*/
func (self Expanded) CreateConvexCollision(clean bool, simplify bool) { //gd:MeshInstance3D.create_convex_collision
	Advanced(self).CreateConvexCollision(clean, simplify)
}

/*
This helper creates a [StaticBody3D] child node with multiple [ConvexPolygonShape3D] collision shapes calculated from the mesh geometry via convex decomposition. The convex decomposition operation can be controlled with parameters from the optional [param settings].
*/
func (self Instance) CreateMultipleConvexCollisions() { //gd:MeshInstance3D.create_multiple_convex_collisions
	Advanced(self).CreateMultipleConvexCollisions([1]MeshConvexDecompositionSettings.Instance{}[0])
}

/*
This helper creates a [StaticBody3D] child node with multiple [ConvexPolygonShape3D] collision shapes calculated from the mesh geometry via convex decomposition. The convex decomposition operation can be controlled with parameters from the optional [param settings].
*/
func (self Expanded) CreateMultipleConvexCollisions(settings MeshConvexDecompositionSettings.Instance) { //gd:MeshInstance3D.create_multiple_convex_collisions
	Advanced(self).CreateMultipleConvexCollisions(settings)
}

/*
Returns the number of blend shapes available. Produces an error if [member mesh] is [code]null[/code].
*/
func (self Instance) GetBlendShapeCount() int { //gd:MeshInstance3D.get_blend_shape_count
	return int(int(Advanced(self).GetBlendShapeCount()))
}

/*
Returns the index of the blend shape with the given [param name]. Returns [code]-1[/code] if no blend shape with this name exists, including when [member mesh] is [code]null[/code].
*/
func (self Instance) FindBlendShapeByName(name string) int { //gd:MeshInstance3D.find_blend_shape_by_name
	return int(int(Advanced(self).FindBlendShapeByName(String.Name(String.New(name)))))
}

/*
Returns the value of the blend shape at the given [param blend_shape_idx]. Returns [code]0.0[/code] and produces an error if [member mesh] is [code]null[/code] or doesn't have a blend shape at that index.
*/
func (self Instance) GetBlendShapeValue(blend_shape_idx int) Float.X { //gd:MeshInstance3D.get_blend_shape_value
	return Float.X(Float.X(Advanced(self).GetBlendShapeValue(int64(blend_shape_idx))))
}

/*
Sets the value of the blend shape at [param blend_shape_idx] to [param value]. Produces an error if [member mesh] is [code]null[/code] or doesn't have a blend shape at that index.
*/
func (self Instance) SetBlendShapeValue(blend_shape_idx int, value Float.X) { //gd:MeshInstance3D.set_blend_shape_value
	Advanced(self).SetBlendShapeValue(int64(blend_shape_idx), float64(value))
}

/*
This helper creates a [MeshInstance3D] child node with gizmos at every vertex calculated from the mesh geometry. It's mainly used for testing.
*/
func (self Instance) CreateDebugTangents() { //gd:MeshInstance3D.create_debug_tangents
	Advanced(self).CreateDebugTangents()
}

/*
Takes a snapshot from the current [ArrayMesh] with all blend shapes applied according to their current weights and bakes it to the provided [param existing] mesh. If no [param existing] mesh is provided a new [ArrayMesh] is created, baked and returned. Mesh surface materials are not copied.
[b]Performance:[/b] [Mesh] data needs to be received from the GPU, stalling the [RenderingServer] in the process.
*/
func (self Instance) BakeMeshFromCurrentBlendShapeMix() ArrayMesh.Instance { //gd:MeshInstance3D.bake_mesh_from_current_blend_shape_mix
	return ArrayMesh.Instance(Advanced(self).BakeMeshFromCurrentBlendShapeMix([1]ArrayMesh.Instance{}[0]))
}

/*
Takes a snapshot from the current [ArrayMesh] with all blend shapes applied according to their current weights and bakes it to the provided [param existing] mesh. If no [param existing] mesh is provided a new [ArrayMesh] is created, baked and returned. Mesh surface materials are not copied.
[b]Performance:[/b] [Mesh] data needs to be received from the GPU, stalling the [RenderingServer] in the process.
*/
func (self Expanded) BakeMeshFromCurrentBlendShapeMix(existing ArrayMesh.Instance) ArrayMesh.Instance { //gd:MeshInstance3D.bake_mesh_from_current_blend_shape_mix
	return ArrayMesh.Instance(Advanced(self).BakeMeshFromCurrentBlendShapeMix(existing))
}

/*
Takes a snapshot of the current animated skeleton pose of the skinned mesh and bakes it to the provided [param existing] mesh. If no [param existing] mesh is provided a new [ArrayMesh] is created, baked, and returned. Requires a skeleton with a registered skin to work. Blendshapes are ignored. Mesh surface materials are not copied.
[b]Performance:[/b] [Mesh] data needs to be retrieved from the GPU, stalling the [RenderingServer] in the process.
*/
func (self Instance) BakeMeshFromCurrentSkeletonPose() ArrayMesh.Instance { //gd:MeshInstance3D.bake_mesh_from_current_skeleton_pose
	return ArrayMesh.Instance(Advanced(self).BakeMeshFromCurrentSkeletonPose([1]ArrayMesh.Instance{}[0]))
}

/*
Takes a snapshot of the current animated skeleton pose of the skinned mesh and bakes it to the provided [param existing] mesh. If no [param existing] mesh is provided a new [ArrayMesh] is created, baked, and returned. Requires a skeleton with a registered skin to work. Blendshapes are ignored. Mesh surface materials are not copied.
[b]Performance:[/b] [Mesh] data needs to be retrieved from the GPU, stalling the [RenderingServer] in the process.
*/
func (self Expanded) BakeMeshFromCurrentSkeletonPose(existing ArrayMesh.Instance) ArrayMesh.Instance { //gd:MeshInstance3D.bake_mesh_from_current_skeleton_pose
	return ArrayMesh.Instance(Advanced(self).BakeMeshFromCurrentSkeletonPose(existing))
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.MeshInstance3D

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = pointers.AsA[gdclass.MeshInstance3D](obj[0])
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = pointers.AsA[gdclass.MeshInstance3D](obj[0])
		return true
	}
	return false
}
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }
func (self *Extension[T]) AsObject() [1]gd.Object { return self.Super().AsObject() }
func New() Instance {
	if !gd.Linked {
		var placeholder = Instance([1]gdclass.MeshInstance3D{pointers.Add[gdclass.MeshInstance3D]([3]uint64{})})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(pointers.AsA[gd.Object](placeholder[0]), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	casted := Instance([1]gdclass.MeshInstance3D{pointers.New[gdclass.MeshInstance3D]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})})
	casted.AsObject()[0].Notification(0, false)
	return casted
}

func (self Instance) Mesh() Mesh.Instance {
	return Mesh.Instance(class(self).GetMesh())
}

func (self Instance) SetMesh(value Mesh.Instance) {
	class(self).SetMesh(value)
}

func (self Instance) Skin() Skin.Instance {
	return Skin.Instance(class(self).GetSkin())
}

func (self Instance) SetSkin(value Skin.Instance) {
	class(self).SetSkin(value)
}

func (self Instance) Skeleton() string {
	return string(class(self).GetSkeletonPath().String())
}

func (self Instance) SetSkeleton(value string) {
	class(self).SetSkeletonPath(Path.ToNode(String.New(value)))
}

//go:nosplit
func (self class) SetMesh(mesh [1]gdclass.Mesh) { //gd:MeshInstance3D.set_mesh
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_mesh, 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ mesh gdextension.Object }{gdextension.Object(gd.ObjectChecked(mesh[0].AsObject()))}))
}

//go:nosplit
func (self class) GetMesh() [1]gdclass.Mesh { //gd:MeshInstance3D.get_mesh
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_mesh, gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.Mesh{gd.PointerWithOwnershipTransferredToGo[gdclass.Mesh](r_ret)}
	return ret
}

//go:nosplit
func (self class) SetSkeletonPath(skeleton_path Path.ToNode) { //gd:MeshInstance3D.set_skeleton_path
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_skeleton_path, 0|(gdextension.SizeNodePath<<4), unsafe.Pointer(&struct{ skeleton_path gdextension.NodePath }{pointers.Get(gd.InternalNodePath(skeleton_path))}))
}

//go:nosplit
func (self class) GetSkeletonPath() Path.ToNode { //gd:MeshInstance3D.get_skeleton_path
	var r_ret = gdextension.Call[gdextension.NodePath](gd.ObjectChecked(self.AsObject()), methods.get_skeleton_path, gdextension.SizeNodePath, unsafe.Pointer(&struct{}{}))
	var ret = Path.ToNode(String.Via(gd.NodePathProxy{}, pointers.Pack(pointers.New[gd.NodePath](r_ret))))
	return ret
}

//go:nosplit
func (self class) SetSkin(skin [1]gdclass.Skin) { //gd:MeshInstance3D.set_skin
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_skin, 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ skin gdextension.Object }{gdextension.Object(gd.ObjectChecked(skin[0].AsObject()))}))
}

//go:nosplit
func (self class) GetSkin() [1]gdclass.Skin { //gd:MeshInstance3D.get_skin
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_skin, gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.Skin{gd.PointerWithOwnershipTransferredToGo[gdclass.Skin](r_ret)}
	return ret
}

/*
Returns the internal [SkinReference] containing the skeleton's [RID] attached to this RID. See also [method Resource.get_rid], [method SkinReference.get_skeleton], and [method RenderingServer.instance_attach_skeleton].
*/
//go:nosplit
func (self class) GetSkinReference() [1]gdclass.SkinReference { //gd:MeshInstance3D.get_skin_reference
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_skin_reference, gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.SkinReference{gd.PointerWithOwnershipTransferredToGo[gdclass.SkinReference](r_ret)}
	return ret
}

/*
Returns the number of surface override materials. This is equivalent to [method Mesh.get_surface_count]. See also [method get_surface_override_material].
*/
//go:nosplit
func (self class) GetSurfaceOverrideMaterialCount() int64 { //gd:MeshInstance3D.get_surface_override_material_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_surface_override_material_count, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Sets the override [param material] for the specified [param surface] of the [Mesh] resource. This material is associated with this [MeshInstance3D] rather than with [member mesh].
[b]Note:[/b] This assigns the [Material] associated to the [MeshInstance3D]'s Surface Material Override properties, not the material within the [Mesh] resource. To set the material within the [Mesh] resource, use [method Mesh.surface_set_material] instead.
*/
//go:nosplit
func (self class) SetSurfaceOverrideMaterial(surface int64, material [1]gdclass.Material) { //gd:MeshInstance3D.set_surface_override_material
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_surface_override_material, 0|(gdextension.SizeInt<<4)|(gdextension.SizeObject<<8), unsafe.Pointer(&struct {
		surface  int64
		material gdextension.Object
	}{surface, gdextension.Object(gd.ObjectChecked(material[0].AsObject()))}))
}

/*
Returns the override [Material] for the specified [param surface] of the [Mesh] resource. See also [method get_surface_override_material_count].
[b]Note:[/b] This returns the [Material] associated to the [MeshInstance3D]'s Surface Material Override properties, not the material within the [Mesh] resource. To get the material within the [Mesh] resource, use [method Mesh.surface_get_material] instead.
*/
//go:nosplit
func (self class) GetSurfaceOverrideMaterial(surface int64) [1]gdclass.Material { //gd:MeshInstance3D.get_surface_override_material
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_surface_override_material, gdextension.SizeObject|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ surface int64 }{surface}))
	var ret = [1]gdclass.Material{gd.PointerWithOwnershipTransferredToGo[gdclass.Material](r_ret)}
	return ret
}

/*
Returns the [Material] that will be used by the [Mesh] when drawing. This can return the [member GeometryInstance3D.material_override], the surface override [Material] defined in this [MeshInstance3D], or the surface [Material] defined in the [member mesh]. For example, if [member GeometryInstance3D.material_override] is used, all surfaces will return the override material.
Returns [code]null[/code] if no material is active, including when [member mesh] is [code]null[/code].
*/
//go:nosplit
func (self class) GetActiveMaterial(surface int64) [1]gdclass.Material { //gd:MeshInstance3D.get_active_material
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_active_material, gdextension.SizeObject|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ surface int64 }{surface}))
	var ret = [1]gdclass.Material{gd.PointerWithOwnershipTransferredToGo[gdclass.Material](r_ret)}
	return ret
}

/*
This helper creates a [StaticBody3D] child node with a [ConcavePolygonShape3D] collision shape calculated from the mesh geometry. It's mainly used for testing.
*/
//go:nosplit
func (self class) CreateTrimeshCollision() { //gd:MeshInstance3D.create_trimesh_collision
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.create_trimesh_collision, 0, unsafe.Pointer(&struct{}{}))
}

/*
This helper creates a [StaticBody3D] child node with a [ConvexPolygonShape3D] collision shape calculated from the mesh geometry. It's mainly used for testing.
If [param clean] is [code]true[/code] (default), duplicate and interior vertices are removed automatically. You can set it to [code]false[/code] to make the process faster if not needed.
If [param simplify] is [code]true[/code], the geometry can be further simplified to reduce the number of vertices. Disabled by default.
*/
//go:nosplit
func (self class) CreateConvexCollision(clean bool, simplify bool) { //gd:MeshInstance3D.create_convex_collision
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.create_convex_collision, 0|(gdextension.SizeBool<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		clean    bool
		simplify bool
	}{clean, simplify}))
}

/*
This helper creates a [StaticBody3D] child node with multiple [ConvexPolygonShape3D] collision shapes calculated from the mesh geometry via convex decomposition. The convex decomposition operation can be controlled with parameters from the optional [param settings].
*/
//go:nosplit
func (self class) CreateMultipleConvexCollisions(settings [1]gdclass.MeshConvexDecompositionSettings) { //gd:MeshInstance3D.create_multiple_convex_collisions
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.create_multiple_convex_collisions, 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ settings gdextension.Object }{gdextension.Object(gd.ObjectChecked(settings[0].AsObject()))}))
}

/*
Returns the number of blend shapes available. Produces an error if [member mesh] is [code]null[/code].
*/
//go:nosplit
func (self class) GetBlendShapeCount() int64 { //gd:MeshInstance3D.get_blend_shape_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_blend_shape_count, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the index of the blend shape with the given [param name]. Returns [code]-1[/code] if no blend shape with this name exists, including when [member mesh] is [code]null[/code].
*/
//go:nosplit
func (self class) FindBlendShapeByName(name String.Name) int64 { //gd:MeshInstance3D.find_blend_shape_by_name
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.find_blend_shape_by_name, gdextension.SizeInt|(gdextension.SizeStringName<<4), unsafe.Pointer(&struct{ name gdextension.StringName }{pointers.Get(gd.InternalStringName(name))}))
	var ret = r_ret
	return ret
}

/*
Returns the value of the blend shape at the given [param blend_shape_idx]. Returns [code]0.0[/code] and produces an error if [member mesh] is [code]null[/code] or doesn't have a blend shape at that index.
*/
//go:nosplit
func (self class) GetBlendShapeValue(blend_shape_idx int64) float64 { //gd:MeshInstance3D.get_blend_shape_value
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_blend_shape_value, gdextension.SizeFloat|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ blend_shape_idx int64 }{blend_shape_idx}))
	var ret = r_ret
	return ret
}

/*
Sets the value of the blend shape at [param blend_shape_idx] to [param value]. Produces an error if [member mesh] is [code]null[/code] or doesn't have a blend shape at that index.
*/
//go:nosplit
func (self class) SetBlendShapeValue(blend_shape_idx int64, value float64) { //gd:MeshInstance3D.set_blend_shape_value
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_blend_shape_value, 0|(gdextension.SizeInt<<4)|(gdextension.SizeFloat<<8), unsafe.Pointer(&struct {
		blend_shape_idx int64
		value           float64
	}{blend_shape_idx, value}))
}

/*
This helper creates a [MeshInstance3D] child node with gizmos at every vertex calculated from the mesh geometry. It's mainly used for testing.
*/
//go:nosplit
func (self class) CreateDebugTangents() { //gd:MeshInstance3D.create_debug_tangents
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.create_debug_tangents, 0, unsafe.Pointer(&struct{}{}))
}

/*
Takes a snapshot from the current [ArrayMesh] with all blend shapes applied according to their current weights and bakes it to the provided [param existing] mesh. If no [param existing] mesh is provided a new [ArrayMesh] is created, baked and returned. Mesh surface materials are not copied.
[b]Performance:[/b] [Mesh] data needs to be received from the GPU, stalling the [RenderingServer] in the process.
*/
//go:nosplit
func (self class) BakeMeshFromCurrentBlendShapeMix(existing [1]gdclass.ArrayMesh) [1]gdclass.ArrayMesh { //gd:MeshInstance3D.bake_mesh_from_current_blend_shape_mix
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.bake_mesh_from_current_blend_shape_mix, gdextension.SizeObject|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ existing gdextension.Object }{gdextension.Object(gd.ObjectChecked(existing[0].AsObject()))}))
	var ret = [1]gdclass.ArrayMesh{gd.PointerWithOwnershipTransferredToGo[gdclass.ArrayMesh](r_ret)}
	return ret
}

/*
Takes a snapshot of the current animated skeleton pose of the skinned mesh and bakes it to the provided [param existing] mesh. If no [param existing] mesh is provided a new [ArrayMesh] is created, baked, and returned. Requires a skeleton with a registered skin to work. Blendshapes are ignored. Mesh surface materials are not copied.
[b]Performance:[/b] [Mesh] data needs to be retrieved from the GPU, stalling the [RenderingServer] in the process.
*/
//go:nosplit
func (self class) BakeMeshFromCurrentSkeletonPose(existing [1]gdclass.ArrayMesh) [1]gdclass.ArrayMesh { //gd:MeshInstance3D.bake_mesh_from_current_skeleton_pose
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.bake_mesh_from_current_skeleton_pose, gdextension.SizeObject|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ existing gdextension.Object }{gdextension.Object(gd.ObjectChecked(existing[0].AsObject()))}))
	var ret = [1]gdclass.ArrayMesh{gd.PointerWithOwnershipTransferredToGo[gdclass.ArrayMesh](r_ret)}
	return ret
}
func (self class) AsMeshInstance3D() Advanced {
	return Advanced{pointers.AsA[gdclass.MeshInstance3D](self[0])}
}
func (self Instance) AsMeshInstance3D() Instance {
	return Instance{pointers.AsA[gdclass.MeshInstance3D](self[0])}
}
func (self *Extension[T]) AsMeshInstance3D() Instance { return self.Super().AsMeshInstance3D() }
func (self class) AsGeometryInstance3D() GeometryInstance3D.Advanced {
	return GeometryInstance3D.Advanced{pointers.AsA[gdclass.GeometryInstance3D](self[0])}
}
func (self *Extension[T]) AsGeometryInstance3D() GeometryInstance3D.Instance {
	return self.Super().AsGeometryInstance3D()
}
func (self Instance) AsGeometryInstance3D() GeometryInstance3D.Instance {
	return GeometryInstance3D.Instance{pointers.AsA[gdclass.GeometryInstance3D](self[0])}
}
func (self class) AsVisualInstance3D() VisualInstance3D.Advanced {
	return VisualInstance3D.Advanced{pointers.AsA[gdclass.VisualInstance3D](self[0])}
}
func (self *Extension[T]) AsVisualInstance3D() VisualInstance3D.Instance {
	return self.Super().AsVisualInstance3D()
}
func (self Instance) AsVisualInstance3D() VisualInstance3D.Instance {
	return VisualInstance3D.Instance{pointers.AsA[gdclass.VisualInstance3D](self[0])}
}
func (self class) AsNode3D() Node3D.Advanced {
	return Node3D.Advanced{pointers.AsA[gdclass.Node3D](self[0])}
}
func (self *Extension[T]) AsNode3D() Node3D.Instance { return self.Super().AsNode3D() }
func (self Instance) AsNode3D() Node3D.Instance {
	return Node3D.Instance{pointers.AsA[gdclass.Node3D](self[0])}
}
func (self class) AsNode() Node.Advanced         { return Node.Advanced{pointers.AsA[gdclass.Node](self[0])} }
func (self *Extension[T]) AsNode() Node.Instance { return self.Super().AsNode() }
func (self Instance) AsNode() Node.Instance {
	return Node.Instance{pointers.AsA[gdclass.Node](self[0])}
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(GeometryInstance3D.Advanced(self.AsGeometryInstance3D()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(GeometryInstance3D.Instance(self.AsGeometryInstance3D()), name)
	}
}
func init() {
	gdclass.Register("MeshInstance3D", func(ptr gd.Object) any { return Instance{pointers.AsA[gdclass.MeshInstance3D](ptr)} })
}
