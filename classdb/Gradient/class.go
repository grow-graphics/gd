// Code generated by the generate package DO NOT EDIT

// Package Gradient provides methods for working with Gradient object instances.
package Gradient

import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/variant/Signal"
import "graphics.gd/classdb/Resource"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Color"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Signal.Any
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
This resource describes a color transition by defining a set of colored points and how to interpolate between them.
See also [Curve] which supports more complex easing methods, but does not support colors.
*/
type Instance [1]gdclass.Gradient

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	add_point                     gdextension.MethodForClass `hash:"3629403827"`
	remove_point                  gdextension.MethodForClass `hash:"1286410249"`
	set_offset                    gdextension.MethodForClass `hash:"1602489585"`
	get_offset                    gdextension.MethodForClass `hash:"4025615559"`
	reverse                       gdextension.MethodForClass `hash:"3218959716"`
	set_color                     gdextension.MethodForClass `hash:"2878471219"`
	get_color                     gdextension.MethodForClass `hash:"2624840992"`
	sample                        gdextension.MethodForClass `hash:"1250405064"`
	get_point_count               gdextension.MethodForClass `hash:"3905245786"`
	set_offsets                   gdextension.MethodForClass `hash:"2899603908"`
	get_offsets                   gdextension.MethodForClass `hash:"675695659"`
	set_colors                    gdextension.MethodForClass `hash:"3546319833"`
	get_colors                    gdextension.MethodForClass `hash:"1392750486"`
	set_interpolation_mode        gdextension.MethodForClass `hash:"1971444490"`
	get_interpolation_mode        gdextension.MethodForClass `hash:"3674172981"`
	set_interpolation_color_space gdextension.MethodForClass `hash:"3685995981"`
	get_interpolation_color_space gdextension.MethodForClass `hash:"1538296000"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("Gradient")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		gdextension.Free(gdextension.TypeStringName, &sname)
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsGradient() Instance
}

/*
Adds the specified color to the gradient, with the specified offset.
*/
func (self Instance) AddPoint(offset Float.X, color Color.RGBA) { //gd:Gradient.add_point
	Advanced(self).AddPoint(float64(offset), Color.RGBA(color))
}

/*
Removes the color at index [param point].
*/
func (self Instance) RemovePoint(point int) { //gd:Gradient.remove_point
	Advanced(self).RemovePoint(int64(point))
}

/*
Sets the offset for the gradient color at index [param point].
*/
func (self Instance) SetOffset(point int, offset Float.X) { //gd:Gradient.set_offset
	Advanced(self).SetOffset(int64(point), float64(offset))
}

/*
Returns the offset of the gradient color at index [param point].
*/
func (self Instance) GetOffset(point int) Float.X { //gd:Gradient.get_offset
	return Float.X(Float.X(Advanced(self).GetOffset(int64(point))))
}

/*
Reverses/mirrors the gradient.
[b]Note:[/b] This method mirrors all points around the middle of the gradient, which may produce unexpected results when [member interpolation_mode] is set to [constant GRADIENT_INTERPOLATE_CONSTANT].
*/
func (self Instance) Reverse() { //gd:Gradient.reverse
	Advanced(self).Reverse()
}

/*
Sets the color of the gradient color at index [param point].
*/
func (self Instance) SetColor(point int, color Color.RGBA) { //gd:Gradient.set_color
	Advanced(self).SetColor(int64(point), Color.RGBA(color))
}

/*
Returns the color of the gradient color at index [param point].
*/
func (self Instance) GetColor(point int) Color.RGBA { //gd:Gradient.get_color
	return Color.RGBA(Advanced(self).GetColor(int64(point)))
}

/*
Returns the interpolated color specified by [param offset].
*/
func (self Instance) Sample(offset Float.X) Color.RGBA { //gd:Gradient.sample
	return Color.RGBA(Advanced(self).Sample(float64(offset)))
}

/*
Returns the number of colors in the gradient.
*/
func (self Instance) GetPointCount() int { //gd:Gradient.get_point_count
	return int(int(Advanced(self).GetPointCount()))
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.Gradient

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = pointers.AsA[gdclass.Gradient](obj[0])
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = pointers.AsA[gdclass.Gradient](obj[0])
		return true
	}
	return false
}
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }
func (self *Extension[T]) AsObject() [1]gd.Object { return self.Super().AsObject() }
func New() Instance {
	if !gd.Linked {
		var placeholder = Instance([1]gdclass.Gradient{pointers.Add[gdclass.Gradient]([3]uint64{})})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(pointers.AsA[gd.Object](placeholder[0]), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	casted := Instance([1]gdclass.Gradient{pointers.New[gdclass.Gradient]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})})
	casted.AsRefCounted()[0].InitRef()
	casted.AsObject()[0].Notification(0, false)
	return casted
}

func (self Instance) InterpolationMode() InterpolationMode {
	return InterpolationMode(class(self).GetInterpolationMode())
}

func (self Instance) SetInterpolationMode(value InterpolationMode) {
	class(self).SetInterpolationMode(value)
}

func (self Instance) InterpolationColorSpace() ColorSpace {
	return ColorSpace(class(self).GetInterpolationColorSpace())
}

func (self Instance) SetInterpolationColorSpace(value ColorSpace) {
	class(self).SetInterpolationColorSpace(value)
}

func (self Instance) Offsets() []float32 {
	return []float32(slices.Collect(class(self).GetOffsets().Values()))
}

func (self Instance) SetOffsets(value []float32) {
	class(self).SetOffsets(Packed.New(value...))
}

func (self Instance) Colors() []Color.RGBA {
	return []Color.RGBA(slices.Collect(class(self).GetColors().Values()))
}

func (self Instance) SetColors(value []Color.RGBA) {
	class(self).SetColors(Packed.New(value...))
}

/*
Adds the specified color to the gradient, with the specified offset.
*/
//go:nosplit
func (self class) AddPoint(offset float64, color Color.RGBA) { //gd:Gradient.add_point
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_point, 0|(gdextension.SizeFloat<<4)|(gdextension.SizeColor<<8), &struct {
		offset float64
		color  Color.RGBA
	}{offset, color})
}

/*
Removes the color at index [param point].
*/
//go:nosplit
func (self class) RemovePoint(point int64) { //gd:Gradient.remove_point
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.remove_point, 0|(gdextension.SizeInt<<4), &struct{ point int64 }{point})
}

/*
Sets the offset for the gradient color at index [param point].
*/
//go:nosplit
func (self class) SetOffset(point int64, offset float64) { //gd:Gradient.set_offset
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_offset, 0|(gdextension.SizeInt<<4)|(gdextension.SizeFloat<<8), &struct {
		point  int64
		offset float64
	}{point, offset})
}

/*
Returns the offset of the gradient color at index [param point].
*/
//go:nosplit
func (self class) GetOffset(point int64) float64 { //gd:Gradient.get_offset
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_offset, gdextension.SizeFloat|(gdextension.SizeInt<<4), &struct{ point int64 }{point})
	var ret = r_ret
	return ret
}

/*
Reverses/mirrors the gradient.
[b]Note:[/b] This method mirrors all points around the middle of the gradient, which may produce unexpected results when [member interpolation_mode] is set to [constant GRADIENT_INTERPOLATE_CONSTANT].
*/
//go:nosplit
func (self class) Reverse() { //gd:Gradient.reverse
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.reverse, 0, &struct{}{})
}

/*
Sets the color of the gradient color at index [param point].
*/
//go:nosplit
func (self class) SetColor(point int64, color Color.RGBA) { //gd:Gradient.set_color
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_color, 0|(gdextension.SizeInt<<4)|(gdextension.SizeColor<<8), &struct {
		point int64
		color Color.RGBA
	}{point, color})
}

/*
Returns the color of the gradient color at index [param point].
*/
//go:nosplit
func (self class) GetColor(point int64) Color.RGBA { //gd:Gradient.get_color
	var r_ret = gdextension.Call[Color.RGBA](gd.ObjectChecked(self.AsObject()), methods.get_color, gdextension.SizeColor|(gdextension.SizeInt<<4), &struct{ point int64 }{point})
	var ret = r_ret
	return ret
}

/*
Returns the interpolated color specified by [param offset].
*/
//go:nosplit
func (self class) Sample(offset float64) Color.RGBA { //gd:Gradient.sample
	var r_ret = gdextension.Call[Color.RGBA](gd.ObjectChecked(self.AsObject()), methods.sample, gdextension.SizeColor|(gdextension.SizeFloat<<4), &struct{ offset float64 }{offset})
	var ret = r_ret
	return ret
}

/*
Returns the number of colors in the gradient.
*/
//go:nosplit
func (self class) GetPointCount() int64 { //gd:Gradient.get_point_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_point_count, gdextension.SizeInt, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetOffsets(offsets Packed.Array[float32]) { //gd:Gradient.set_offsets
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_offsets, 0|(gdextension.SizePackedArray<<4), &struct {
		offsets gdextension.PackedArray[float32]
	}{pointers.Get(gd.InternalPacked[gd.PackedFloat32Array, float32](offsets))})
}

//go:nosplit
func (self class) GetOffsets() Packed.Array[float32] { //gd:Gradient.get_offsets
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.get_offsets, gdextension.SizePackedArray, &struct{}{})
	var ret = Packed.Array[float32](Array.Through(gd.PackedProxy[gd.PackedFloat32Array, float32]{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

//go:nosplit
func (self class) SetColors(colors Packed.Array[Color.RGBA]) { //gd:Gradient.set_colors
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_colors, 0|(gdextension.SizePackedArray<<4), &struct {
		colors gdextension.PackedArray[Color.RGBA]
	}{pointers.Get(gd.InternalPacked[gd.PackedColorArray, Color.RGBA](colors))})
}

//go:nosplit
func (self class) GetColors() Packed.Array[Color.RGBA] { //gd:Gradient.get_colors
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.get_colors, gdextension.SizePackedArray, &struct{}{})
	var ret = Packed.Array[Color.RGBA](Array.Through(gd.PackedProxy[gd.PackedColorArray, Color.RGBA]{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

//go:nosplit
func (self class) SetInterpolationMode(interpolation_mode InterpolationMode) { //gd:Gradient.set_interpolation_mode
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_interpolation_mode, 0|(gdextension.SizeInt<<4), &struct{ interpolation_mode InterpolationMode }{interpolation_mode})
}

//go:nosplit
func (self class) GetInterpolationMode() InterpolationMode { //gd:Gradient.get_interpolation_mode
	var r_ret = gdextension.Call[InterpolationMode](gd.ObjectChecked(self.AsObject()), methods.get_interpolation_mode, gdextension.SizeInt, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetInterpolationColorSpace(interpolation_color_space ColorSpace) { //gd:Gradient.set_interpolation_color_space
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_interpolation_color_space, 0|(gdextension.SizeInt<<4), &struct{ interpolation_color_space ColorSpace }{interpolation_color_space})
}

//go:nosplit
func (self class) GetInterpolationColorSpace() ColorSpace { //gd:Gradient.get_interpolation_color_space
	var r_ret = gdextension.Call[ColorSpace](gd.ObjectChecked(self.AsObject()), methods.get_interpolation_color_space, gdextension.SizeInt, &struct{}{})
	var ret = r_ret
	return ret
}
func (self class) AsGradient() Advanced         { return Advanced{pointers.AsA[gdclass.Gradient](self[0])} }
func (self Instance) AsGradient() Instance      { return Instance{pointers.AsA[gdclass.Gradient](self[0])} }
func (self *Extension[T]) AsGradient() Instance { return self.Super().AsGradient() }
func (self class) AsResource() Resource.Advanced {
	return Resource.Advanced{pointers.AsA[gdclass.Resource](self[0])}
}
func (self *Extension[T]) AsResource() Resource.Instance { return self.Super().AsResource() }
func (self Instance) AsResource() Resource.Instance {
	return Resource.Instance{pointers.AsA[gdclass.Resource](self[0])}
}
func (self class) AsRefCounted() [1]gd.RefCounted {
	return [1]gd.RefCounted{gd.RefCounted(pointers.AsA[gd.Object](self[0]))}
}
func (self *Extension[T]) AsRefCounted() [1]gd.RefCounted { return self.Super().AsRefCounted() }
func (self Instance) AsRefCounted() [1]gd.RefCounted {
	return [1]gd.RefCounted{gd.RefCounted(pointers.AsA[gd.Object](self[0]))}
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Resource.Advanced(self.AsResource()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Resource.Instance(self.AsResource()), name)
	}
}
func init() {
	gdclass.Register("Gradient", func(ptr gd.Object) any { return Instance{pointers.AsA[gdclass.Gradient](ptr)} })
}

type InterpolationMode int //gd:Gradient.InterpolationMode

const (
	/*Linear interpolation.*/
	GradientInterpolateLinear InterpolationMode = 0
	/*Constant interpolation, color changes abruptly at each point and stays uniform between. This might cause visible aliasing when used for a gradient texture in some cases.*/
	GradientInterpolateConstant InterpolationMode = 1
	/*Cubic interpolation.*/
	GradientInterpolateCubic InterpolationMode = 2
)

type ColorSpace int //gd:Gradient.ColorSpace

const (
	/*sRGB color space.*/
	GradientColorSpaceSrgb ColorSpace = 0
	/*Linear sRGB color space.*/
	GradientColorSpaceLinearSrgb ColorSpace = 1
	/*[url=https://bottosson.github.io/posts/oklab/]Oklab[/url] color space. This color space provides a smooth and uniform-looking transition between colors.*/
	GradientColorSpaceOklab ColorSpace = 2
)
