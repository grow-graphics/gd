// Code generated by the generate package DO NOT EDIT

// Package VehicleWheel3D provides methods for working with VehicleWheel3D object instances.
package VehicleWheel3D

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/Node"
import "graphics.gd/classdb/Node3D"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"
import "graphics.gd/variant/Vector3"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
A node used as a child of a [VehicleBody3D] parent to simulate the behavior of one of its wheels. This node also acts as a collider to detect if the wheel is touching a surface.
[b]Note:[/b] This class has known issues and isn't designed to provide realistic 3D vehicle physics. If you want advanced vehicle physics, you may need to write your own physics integration using another [PhysicsBody3D] class.
*/
type Instance [1]gdclass.VehicleWheel3D

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	set_radius                 gdextension.MethodForClass `hash:"373806689"`
	get_radius                 gdextension.MethodForClass `hash:"1740695150"`
	set_suspension_rest_length gdextension.MethodForClass `hash:"373806689"`
	get_suspension_rest_length gdextension.MethodForClass `hash:"1740695150"`
	set_suspension_travel      gdextension.MethodForClass `hash:"373806689"`
	get_suspension_travel      gdextension.MethodForClass `hash:"1740695150"`
	set_suspension_stiffness   gdextension.MethodForClass `hash:"373806689"`
	get_suspension_stiffness   gdextension.MethodForClass `hash:"1740695150"`
	set_suspension_max_force   gdextension.MethodForClass `hash:"373806689"`
	get_suspension_max_force   gdextension.MethodForClass `hash:"1740695150"`
	set_damping_compression    gdextension.MethodForClass `hash:"373806689"`
	get_damping_compression    gdextension.MethodForClass `hash:"1740695150"`
	set_damping_relaxation     gdextension.MethodForClass `hash:"373806689"`
	get_damping_relaxation     gdextension.MethodForClass `hash:"1740695150"`
	set_use_as_traction        gdextension.MethodForClass `hash:"2586408642"`
	is_used_as_traction        gdextension.MethodForClass `hash:"36873697"`
	set_use_as_steering        gdextension.MethodForClass `hash:"2586408642"`
	is_used_as_steering        gdextension.MethodForClass `hash:"36873697"`
	set_friction_slip          gdextension.MethodForClass `hash:"373806689"`
	get_friction_slip          gdextension.MethodForClass `hash:"1740695150"`
	is_in_contact              gdextension.MethodForClass `hash:"36873697"`
	get_contact_body           gdextension.MethodForClass `hash:"151077316"`
	get_contact_point          gdextension.MethodForClass `hash:"3360562783"`
	get_contact_normal         gdextension.MethodForClass `hash:"3360562783"`
	set_roll_influence         gdextension.MethodForClass `hash:"373806689"`
	get_roll_influence         gdextension.MethodForClass `hash:"1740695150"`
	get_skidinfo               gdextension.MethodForClass `hash:"1740695150"`
	get_rpm                    gdextension.MethodForClass `hash:"1740695150"`
	set_engine_force           gdextension.MethodForClass `hash:"373806689"`
	get_engine_force           gdextension.MethodForClass `hash:"1740695150"`
	set_brake                  gdextension.MethodForClass `hash:"373806689"`
	get_brake                  gdextension.MethodForClass `hash:"1740695150"`
	set_steering               gdextension.MethodForClass `hash:"373806689"`
	get_steering               gdextension.MethodForClass `hash:"1740695150"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("VehicleWheel3D")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		gdextension.Free(gdextension.TypeStringName, &sname)
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsVehicleWheel3D() Instance
}

/*
Returns [code]true[/code] if this wheel is in contact with a surface.
*/
func (self Instance) IsInContact() bool { //gd:VehicleWheel3D.is_in_contact
	return bool(Advanced(self).IsInContact())
}

/*
Returns the contacting body node if valid in the tree, as [Node3D]. At the moment, [GridMap] is not supported so the node will be always of type [PhysicsBody3D].
Returns [code]null[/code] if the wheel is not in contact with a surface, or the contact body is not a [PhysicsBody3D].
*/
func (self Instance) GetContactBody() Node3D.Instance { //gd:VehicleWheel3D.get_contact_body
	return Node3D.Instance(Advanced(self).GetContactBody())
}

/*
Returns the point of the suspension's collision in world space if the wheel is in contact. If the wheel isn't in contact with anything, returns the maximum point of the wheel's ray cast in world space, which is defined by [code]wheel_rest_length + wheel_radius[/code].
*/
func (self Instance) GetContactPoint() Vector3.XYZ { //gd:VehicleWheel3D.get_contact_point
	return Vector3.XYZ(Advanced(self).GetContactPoint())
}

/*
Returns the normal of the suspension's collision in world space if the wheel is in contact. If the wheel isn't in contact with anything, returns a vector pointing directly along the suspension axis toward the vehicle in world space.
*/
func (self Instance) GetContactNormal() Vector3.XYZ { //gd:VehicleWheel3D.get_contact_normal
	return Vector3.XYZ(Advanced(self).GetContactNormal())
}

/*
Returns a value between 0.0 and 1.0 that indicates whether this wheel is skidding. 0.0 is skidding (the wheel has lost grip, e.g. icy terrain), 1.0 means not skidding (the wheel has full grip, e.g. dry asphalt road).
*/
func (self Instance) GetSkidinfo() Float.X { //gd:VehicleWheel3D.get_skidinfo
	return Float.X(Float.X(Advanced(self).GetSkidinfo()))
}

/*
Returns the rotational speed of the wheel in revolutions per minute.
*/
func (self Instance) GetRpm() Float.X { //gd:VehicleWheel3D.get_rpm
	return Float.X(Float.X(Advanced(self).GetRpm()))
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.VehicleWheel3D

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.VehicleWheel3D)(unsafe.Pointer(&obj))
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.VehicleWheel3D)(unsafe.Pointer(&obj))
		return true
	}
	return false
}

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {

	if !gd.Linked {
		var placeholder Instance
		*(*gd.Object)(unsafe.Pointer(&placeholder)) = pointers.Add[gd.Object]([3]uint64{})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(*(*gd.Object)(unsafe.Pointer(&placeholder)), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	object := [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})}
	casted := Instance{*(*gdclass.VehicleWheel3D)(unsafe.Pointer(&object))}
	object[0].Notification(0, false)
	return casted
}

func (self Instance) EngineForce() Float.X {
	return Float.X(Float.X(class(self).GetEngineForce()))
}

func (self Instance) SetEngineForce(value Float.X) {
	class(self).SetEngineForce(float64(value))
}

func (self Instance) Brake() Float.X {
	return Float.X(Float.X(class(self).GetBrake()))
}

func (self Instance) SetBrake(value Float.X) {
	class(self).SetBrake(float64(value))
}

func (self Instance) Steering() Float.X {
	return Float.X(Float.X(class(self).GetSteering()))
}

func (self Instance) SetSteering(value Float.X) {
	class(self).SetSteering(float64(value))
}

func (self Instance) UseAsTraction() bool {
	return bool(class(self).IsUsedAsTraction())
}

func (self Instance) SetUseAsTraction(value bool) {
	class(self).SetUseAsTraction(value)
}

func (self Instance) UseAsSteering() bool {
	return bool(class(self).IsUsedAsSteering())
}

func (self Instance) SetUseAsSteering(value bool) {
	class(self).SetUseAsSteering(value)
}

func (self Instance) WheelRollInfluence() Float.X {
	return Float.X(Float.X(class(self).GetRollInfluence()))
}

func (self Instance) SetWheelRollInfluence(value Float.X) {
	class(self).SetRollInfluence(float64(value))
}

func (self Instance) WheelRadius() Float.X {
	return Float.X(Float.X(class(self).GetRadius()))
}

func (self Instance) SetWheelRadius(value Float.X) {
	class(self).SetRadius(float64(value))
}

func (self Instance) WheelRestLength() Float.X {
	return Float.X(Float.X(class(self).GetSuspensionRestLength()))
}

func (self Instance) SetWheelRestLength(value Float.X) {
	class(self).SetSuspensionRestLength(float64(value))
}

func (self Instance) WheelFrictionSlip() Float.X {
	return Float.X(Float.X(class(self).GetFrictionSlip()))
}

func (self Instance) SetWheelFrictionSlip(value Float.X) {
	class(self).SetFrictionSlip(float64(value))
}

func (self Instance) SuspensionTravel() Float.X {
	return Float.X(Float.X(class(self).GetSuspensionTravel()))
}

func (self Instance) SetSuspensionTravel(value Float.X) {
	class(self).SetSuspensionTravel(float64(value))
}

func (self Instance) SuspensionStiffness() Float.X {
	return Float.X(Float.X(class(self).GetSuspensionStiffness()))
}

func (self Instance) SetSuspensionStiffness(value Float.X) {
	class(self).SetSuspensionStiffness(float64(value))
}

func (self Instance) SuspensionMaxForce() Float.X {
	return Float.X(Float.X(class(self).GetSuspensionMaxForce()))
}

func (self Instance) SetSuspensionMaxForce(value Float.X) {
	class(self).SetSuspensionMaxForce(float64(value))
}

func (self Instance) DampingCompression() Float.X {
	return Float.X(Float.X(class(self).GetDampingCompression()))
}

func (self Instance) SetDampingCompression(value Float.X) {
	class(self).SetDampingCompression(float64(value))
}

func (self Instance) DampingRelaxation() Float.X {
	return Float.X(Float.X(class(self).GetDampingRelaxation()))
}

func (self Instance) SetDampingRelaxation(value Float.X) {
	class(self).SetDampingRelaxation(float64(value))
}

//go:nosplit
func (self class) SetRadius(length float64) { //gd:VehicleWheel3D.set_radius
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_radius, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ length float64 }{length}))
}

//go:nosplit
func (self class) GetRadius() float64 { //gd:VehicleWheel3D.get_radius
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_radius, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetSuspensionRestLength(length float64) { //gd:VehicleWheel3D.set_suspension_rest_length
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_suspension_rest_length, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ length float64 }{length}))
}

//go:nosplit
func (self class) GetSuspensionRestLength() float64 { //gd:VehicleWheel3D.get_suspension_rest_length
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_suspension_rest_length, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetSuspensionTravel(length float64) { //gd:VehicleWheel3D.set_suspension_travel
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_suspension_travel, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ length float64 }{length}))
}

//go:nosplit
func (self class) GetSuspensionTravel() float64 { //gd:VehicleWheel3D.get_suspension_travel
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_suspension_travel, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetSuspensionStiffness(length float64) { //gd:VehicleWheel3D.set_suspension_stiffness
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_suspension_stiffness, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ length float64 }{length}))
}

//go:nosplit
func (self class) GetSuspensionStiffness() float64 { //gd:VehicleWheel3D.get_suspension_stiffness
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_suspension_stiffness, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetSuspensionMaxForce(length float64) { //gd:VehicleWheel3D.set_suspension_max_force
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_suspension_max_force, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ length float64 }{length}))
}

//go:nosplit
func (self class) GetSuspensionMaxForce() float64 { //gd:VehicleWheel3D.get_suspension_max_force
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_suspension_max_force, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetDampingCompression(length float64) { //gd:VehicleWheel3D.set_damping_compression
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_damping_compression, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ length float64 }{length}))
}

//go:nosplit
func (self class) GetDampingCompression() float64 { //gd:VehicleWheel3D.get_damping_compression
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_damping_compression, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetDampingRelaxation(length float64) { //gd:VehicleWheel3D.set_damping_relaxation
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_damping_relaxation, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ length float64 }{length}))
}

//go:nosplit
func (self class) GetDampingRelaxation() float64 { //gd:VehicleWheel3D.get_damping_relaxation
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_damping_relaxation, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetUseAsTraction(enable bool) { //gd:VehicleWheel3D.set_use_as_traction
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_use_as_traction, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

//go:nosplit
func (self class) IsUsedAsTraction() bool { //gd:VehicleWheel3D.is_used_as_traction
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_used_as_traction, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetUseAsSteering(enable bool) { //gd:VehicleWheel3D.set_use_as_steering
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_use_as_steering, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

//go:nosplit
func (self class) IsUsedAsSteering() bool { //gd:VehicleWheel3D.is_used_as_steering
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_used_as_steering, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetFrictionSlip(length float64) { //gd:VehicleWheel3D.set_friction_slip
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_friction_slip, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ length float64 }{length}))
}

//go:nosplit
func (self class) GetFrictionSlip() float64 { //gd:VehicleWheel3D.get_friction_slip
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_friction_slip, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if this wheel is in contact with a surface.
*/
//go:nosplit
func (self class) IsInContact() bool { //gd:VehicleWheel3D.is_in_contact
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_in_contact, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the contacting body node if valid in the tree, as [Node3D]. At the moment, [GridMap] is not supported so the node will be always of type [PhysicsBody3D].
Returns [code]null[/code] if the wheel is not in contact with a surface, or the contact body is not a [PhysicsBody3D].
*/
//go:nosplit
func (self class) GetContactBody() [1]gdclass.Node3D { //gd:VehicleWheel3D.get_contact_body
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_contact_body, gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.Node3D{gd.PointerMustAssertInstanceID[gdclass.Node3D](r_ret)}
	return ret
}

/*
Returns the point of the suspension's collision in world space if the wheel is in contact. If the wheel isn't in contact with anything, returns the maximum point of the wheel's ray cast in world space, which is defined by [code]wheel_rest_length + wheel_radius[/code].
*/
//go:nosplit
func (self class) GetContactPoint() Vector3.XYZ { //gd:VehicleWheel3D.get_contact_point
	var r_ret = gdextension.Call[Vector3.XYZ](gd.ObjectChecked(self.AsObject()), methods.get_contact_point, gdextension.SizeVector3, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the normal of the suspension's collision in world space if the wheel is in contact. If the wheel isn't in contact with anything, returns a vector pointing directly along the suspension axis toward the vehicle in world space.
*/
//go:nosplit
func (self class) GetContactNormal() Vector3.XYZ { //gd:VehicleWheel3D.get_contact_normal
	var r_ret = gdextension.Call[Vector3.XYZ](gd.ObjectChecked(self.AsObject()), methods.get_contact_normal, gdextension.SizeVector3, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetRollInfluence(roll_influence float64) { //gd:VehicleWheel3D.set_roll_influence
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_roll_influence, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ roll_influence float64 }{roll_influence}))
}

//go:nosplit
func (self class) GetRollInfluence() float64 { //gd:VehicleWheel3D.get_roll_influence
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_roll_influence, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns a value between 0.0 and 1.0 that indicates whether this wheel is skidding. 0.0 is skidding (the wheel has lost grip, e.g. icy terrain), 1.0 means not skidding (the wheel has full grip, e.g. dry asphalt road).
*/
//go:nosplit
func (self class) GetSkidinfo() float64 { //gd:VehicleWheel3D.get_skidinfo
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_skidinfo, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the rotational speed of the wheel in revolutions per minute.
*/
//go:nosplit
func (self class) GetRpm() float64 { //gd:VehicleWheel3D.get_rpm
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_rpm, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetEngineForce(engine_force float64) { //gd:VehicleWheel3D.set_engine_force
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_engine_force, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ engine_force float64 }{engine_force}))
}

//go:nosplit
func (self class) GetEngineForce() float64 { //gd:VehicleWheel3D.get_engine_force
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_engine_force, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetBrake(brake float64) { //gd:VehicleWheel3D.set_brake
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_brake, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ brake float64 }{brake}))
}

//go:nosplit
func (self class) GetBrake() float64 { //gd:VehicleWheel3D.get_brake
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_brake, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetSteering(steering float64) { //gd:VehicleWheel3D.set_steering
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_steering, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ steering float64 }{steering}))
}

//go:nosplit
func (self class) GetSteering() float64 { //gd:VehicleWheel3D.get_steering
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_steering, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}
func (self class) AsVehicleWheel3D() Advanced         { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsVehicleWheel3D() Instance      { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsVehicleWheel3D() Instance { return self.Super().AsVehicleWheel3D() }
func (self class) AsNode3D() Node3D.Advanced          { return *((*Node3D.Advanced)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsNode3D() Node3D.Instance  { return self.Super().AsNode3D() }
func (self Instance) AsNode3D() Node3D.Instance       { return *((*Node3D.Instance)(unsafe.Pointer(&self))) }
func (self class) AsNode() Node.Advanced              { return *((*Node.Advanced)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsNode() Node.Instance      { return self.Super().AsNode() }
func (self Instance) AsNode() Node.Instance           { return *((*Node.Instance)(unsafe.Pointer(&self))) }

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Node3D.Advanced(self.AsNode3D()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Node3D.Instance(self.AsNode3D()), name)
	}
}
func init() {
	gdclass.Register("VehicleWheel3D", func(ptr gd.Object) any { return *(*Instance)(unsafe.Pointer(&ptr)) })
}
