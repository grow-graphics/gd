// Code generated by the generate package DO NOT EDIT

// Package MultiplayerPeer provides methods for working with MultiplayerPeer object instances.
package MultiplayerPeer

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/PacketPeer"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
Manages the connection with one or more remote peers acting as server or client and assigning unique IDs to each of them. See also [MultiplayerAPI].
[b]Note:[/b] The [MultiplayerAPI] protocol is an implementation detail and isn't meant to be used by non-Godot servers. It may change without notice.
[b]Note:[/b] When exporting to Android, make sure to enable the [code]INTERNET[/code] permission in the Android export preset before exporting the project or using one-click deploy. Otherwise, network communication of any kind will be blocked by Android.
*/
type Instance [1]gdclass.MultiplayerPeer

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	set_transfer_channel        gdextension.MethodForClass `hash:"1286410249"`
	get_transfer_channel        gdextension.MethodForClass `hash:"3905245786"`
	set_transfer_mode           gdextension.MethodForClass `hash:"950411049"`
	get_transfer_mode           gdextension.MethodForClass `hash:"3369852622"`
	set_target_peer             gdextension.MethodForClass `hash:"1286410249"`
	get_packet_peer             gdextension.MethodForClass `hash:"3905245786"`
	get_packet_channel          gdextension.MethodForClass `hash:"3905245786"`
	get_packet_mode             gdextension.MethodForClass `hash:"3369852622"`
	poll                        gdextension.MethodForClass `hash:"3218959716"`
	close                       gdextension.MethodForClass `hash:"3218959716"`
	disconnect_peer             gdextension.MethodForClass `hash:"4023243586"`
	get_connection_status       gdextension.MethodForClass `hash:"2147374275"`
	get_unique_id               gdextension.MethodForClass `hash:"3905245786"`
	generate_unique_id          gdextension.MethodForClass `hash:"3905245786"`
	set_refuse_new_connections  gdextension.MethodForClass `hash:"2586408642"`
	is_refusing_new_connections gdextension.MethodForClass `hash:"36873697"`
	is_server_relay_supported   gdextension.MethodForClass `hash:"36873697"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("MultiplayerPeer")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		pointers.Raw[gd.StringName](sname).Free()
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

type Expanded [1]gdclass.MultiplayerPeer

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsMultiplayerPeer() Instance
}

/*
Sets the peer to which packets will be sent.
The [param id] can be one of: [constant TARGET_PEER_BROADCAST] to send to all connected peers, [constant TARGET_PEER_SERVER] to send to the peer acting as server, a valid peer ID to send to that specific peer, a negative peer ID to send to all peers except that one. By default, the target peer is [constant TARGET_PEER_BROADCAST].
*/
func (self Instance) SetTargetPeer(id TargetPeer) { //gd:MultiplayerPeer.set_target_peer
	Advanced(self).SetTargetPeer(int64(id))
}

/*
Returns the ID of the [MultiplayerPeer] who sent the next available packet. See [method PacketPeer.get_available_packet_count].
*/
func (self Instance) GetPacketPeer() int { //gd:MultiplayerPeer.get_packet_peer
	return int(int(Advanced(self).GetPacketPeer()))
}

/*
Returns the channel over which the next available packet was received. See [method PacketPeer.get_available_packet_count].
*/
func (self Instance) GetPacketChannel() int { //gd:MultiplayerPeer.get_packet_channel
	return int(int(Advanced(self).GetPacketChannel()))
}

/*
Returns the transfer mode the remote peer used to send the next available packet. See [method PacketPeer.get_available_packet_count].
*/
func (self Instance) GetPacketMode() TransferMode { //gd:MultiplayerPeer.get_packet_mode
	return TransferMode(Advanced(self).GetPacketMode())
}

/*
Waits up to 1 second to receive a new network event.
*/
func (self Instance) Poll() { //gd:MultiplayerPeer.poll
	Advanced(self).Poll()
}

/*
Immediately close the multiplayer peer returning to the state [constant CONNECTION_DISCONNECTED]. Connected peers will be dropped without emitting [signal peer_disconnected].
*/
func (self Instance) Close() { //gd:MultiplayerPeer.close
	Advanced(self).Close()
}

/*
Disconnects the given [param peer] from this host. If [param force] is [code]true[/code] the [signal peer_disconnected] signal will not be emitted for this peer.
*/
func (self Instance) DisconnectPeer(peer int) { //gd:MultiplayerPeer.disconnect_peer
	Advanced(self).DisconnectPeer(int64(peer), false)
}

/*
Disconnects the given [param peer] from this host. If [param force] is [code]true[/code] the [signal peer_disconnected] signal will not be emitted for this peer.
*/
func (self Expanded) DisconnectPeer(peer int, force bool) { //gd:MultiplayerPeer.disconnect_peer
	Advanced(self).DisconnectPeer(int64(peer), force)
}

/*
Returns the current state of the connection. See [enum ConnectionStatus].
*/
func (self Instance) GetConnectionStatus() ConnectionStatus { //gd:MultiplayerPeer.get_connection_status
	return ConnectionStatus(Advanced(self).GetConnectionStatus())
}

/*
Returns the ID of this [MultiplayerPeer].
*/
func (self Instance) GetUniqueId() int { //gd:MultiplayerPeer.get_unique_id
	return int(int(Advanced(self).GetUniqueId()))
}

/*
Returns a randomly generated integer that can be used as a network unique ID.
*/
func (self Instance) GenerateUniqueId() int { //gd:MultiplayerPeer.generate_unique_id
	return int(int(Advanced(self).GenerateUniqueId()))
}

/*
Returns [code]true[/code] if the server can act as a relay in the current configuration. That is, if the higher level [MultiplayerAPI] should notify connected clients of other peers, and implement a relay protocol to allow communication between them.
*/
func (self Instance) IsServerRelaySupported() bool { //gd:MultiplayerPeer.is_server_relay_supported
	return bool(Advanced(self).IsServerRelaySupported())
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.MultiplayerPeer

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.MultiplayerPeer)(unsafe.Pointer(&obj))
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.MultiplayerPeer)(unsafe.Pointer(&obj))
		return true
	}
	return false
}

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {

	if !gd.Linked {
		var placeholder Instance
		*(*gd.Object)(unsafe.Pointer(&placeholder)) = pointers.Add[gd.Object]([3]uint64{})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(*(*gd.Object)(unsafe.Pointer(&placeholder)), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	object := [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})}
	casted := Instance{*(*gdclass.MultiplayerPeer)(unsafe.Pointer(&object))}
	casted.AsRefCounted()[0].Reference()
	object[0].Notification(0, false)
	return casted
}

func (self Instance) RefuseNewConnections() bool {
	return bool(class(self).IsRefusingNewConnections())
}

func (self Instance) SetRefuseNewConnections(value bool) {
	class(self).SetRefuseNewConnections(value)
}

func (self Instance) TransferMode() TransferMode {
	return TransferMode(class(self).GetTransferMode())
}

func (self Instance) SetTransferMode(value TransferMode) {
	class(self).SetTransferMode(value)
}

func (self Instance) TransferChannel() int {
	return int(int(class(self).GetTransferChannel()))
}

func (self Instance) SetTransferChannel(value int) {
	class(self).SetTransferChannel(int64(value))
}

//go:nosplit
func (self class) SetTransferChannel(channel int64) { //gd:MultiplayerPeer.set_transfer_channel
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_transfer_channel, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ channel int64 }{channel}))
}

//go:nosplit
func (self class) GetTransferChannel() int64 { //gd:MultiplayerPeer.get_transfer_channel
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_transfer_channel, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetTransferMode(mode TransferMode) { //gd:MultiplayerPeer.set_transfer_mode
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_transfer_mode, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ mode TransferMode }{mode}))
}

//go:nosplit
func (self class) GetTransferMode() TransferMode { //gd:MultiplayerPeer.get_transfer_mode
	var r_ret = gdextension.Call[TransferMode](gd.ObjectChecked(self.AsObject()), methods.get_transfer_mode, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Sets the peer to which packets will be sent.
The [param id] can be one of: [constant TARGET_PEER_BROADCAST] to send to all connected peers, [constant TARGET_PEER_SERVER] to send to the peer acting as server, a valid peer ID to send to that specific peer, a negative peer ID to send to all peers except that one. By default, the target peer is [constant TARGET_PEER_BROADCAST].
*/
//go:nosplit
func (self class) SetTargetPeer(id int64) { //gd:MultiplayerPeer.set_target_peer
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_target_peer, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ id int64 }{id}))
}

/*
Returns the ID of the [MultiplayerPeer] who sent the next available packet. See [method PacketPeer.get_available_packet_count].
*/
//go:nosplit
func (self class) GetPacketPeer() int64 { //gd:MultiplayerPeer.get_packet_peer
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_packet_peer, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the channel over which the next available packet was received. See [method PacketPeer.get_available_packet_count].
*/
//go:nosplit
func (self class) GetPacketChannel() int64 { //gd:MultiplayerPeer.get_packet_channel
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_packet_channel, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the transfer mode the remote peer used to send the next available packet. See [method PacketPeer.get_available_packet_count].
*/
//go:nosplit
func (self class) GetPacketMode() TransferMode { //gd:MultiplayerPeer.get_packet_mode
	var r_ret = gdextension.Call[TransferMode](gd.ObjectChecked(self.AsObject()), methods.get_packet_mode, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Waits up to 1 second to receive a new network event.
*/
//go:nosplit
func (self class) Poll() { //gd:MultiplayerPeer.poll
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.poll, 0, unsafe.Pointer(&struct{}{}))
}

/*
Immediately close the multiplayer peer returning to the state [constant CONNECTION_DISCONNECTED]. Connected peers will be dropped without emitting [signal peer_disconnected].
*/
//go:nosplit
func (self class) Close() { //gd:MultiplayerPeer.close
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.close, 0, unsafe.Pointer(&struct{}{}))
}

/*
Disconnects the given [param peer] from this host. If [param force] is [code]true[/code] the [signal peer_disconnected] signal will not be emitted for this peer.
*/
//go:nosplit
func (self class) DisconnectPeer(peer int64, force bool) { //gd:MultiplayerPeer.disconnect_peer
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.disconnect_peer, 0|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		peer  int64
		force bool
	}{peer, force}))
}

/*
Returns the current state of the connection. See [enum ConnectionStatus].
*/
//go:nosplit
func (self class) GetConnectionStatus() ConnectionStatus { //gd:MultiplayerPeer.get_connection_status
	var r_ret = gdextension.Call[ConnectionStatus](gd.ObjectChecked(self.AsObject()), methods.get_connection_status, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the ID of this [MultiplayerPeer].
*/
//go:nosplit
func (self class) GetUniqueId() int64 { //gd:MultiplayerPeer.get_unique_id
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_unique_id, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns a randomly generated integer that can be used as a network unique ID.
*/
//go:nosplit
func (self class) GenerateUniqueId() int64 { //gd:MultiplayerPeer.generate_unique_id
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.generate_unique_id, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetRefuseNewConnections(enable bool) { //gd:MultiplayerPeer.set_refuse_new_connections
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_refuse_new_connections, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

//go:nosplit
func (self class) IsRefusingNewConnections() bool { //gd:MultiplayerPeer.is_refusing_new_connections
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_refusing_new_connections, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if the server can act as a relay in the current configuration. That is, if the higher level [MultiplayerAPI] should notify connected clients of other peers, and implement a relay protocol to allow communication between them.
*/
//go:nosplit
func (self class) IsServerRelaySupported() bool { //gd:MultiplayerPeer.is_server_relay_supported
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_server_relay_supported, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}
func (self Instance) OnPeerConnected(cb func(id int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("peer_connected"), gd.NewCallable(cb), 0)
}

func (self Instance) OnPeerDisconnected(cb func(id int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("peer_disconnected"), gd.NewCallable(cb), 0)
}

func (self class) AsMultiplayerPeer() Advanced         { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsMultiplayerPeer() Instance      { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsMultiplayerPeer() Instance { return self.Super().AsMultiplayerPeer() }
func (self class) AsPacketPeer() PacketPeer.Advanced {
	return *((*PacketPeer.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsPacketPeer() PacketPeer.Instance { return self.Super().AsPacketPeer() }
func (self Instance) AsPacketPeer() PacketPeer.Instance {
	return *((*PacketPeer.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsRefCounted() [1]gd.RefCounted { return self.Super().AsRefCounted() }
func (self Instance) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(PacketPeer.Advanced(self.AsPacketPeer()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(PacketPeer.Instance(self.AsPacketPeer()), name)
	}
}
func init() {
	gdclass.Register("MultiplayerPeer", func(ptr gd.Object) any { return *(*Instance)(unsafe.Pointer(&ptr)) })
}

type ConnectionStatus int //gd:MultiplayerPeer.ConnectionStatus

const (
	/*The MultiplayerPeer is disconnected.*/
	ConnectionDisconnected ConnectionStatus = 0
	/*The MultiplayerPeer is currently connecting to a server.*/
	ConnectionConnecting ConnectionStatus = 1
	/*This MultiplayerPeer is connected.*/
	ConnectionConnected ConnectionStatus = 2
)

type TransferMode int //gd:MultiplayerPeer.TransferMode

const (
	/*Packets are not acknowledged, no resend attempts are made for lost packets. Packets may arrive in any order. Potentially faster than [constant TRANSFER_MODE_UNRELIABLE_ORDERED]. Use for non-critical data, and always consider whether the order matters.*/
	TransferModeUnreliable TransferMode = 0
	/*Packets are not acknowledged, no resend attempts are made for lost packets. Packets are received in the order they were sent in. Potentially faster than [constant TRANSFER_MODE_RELIABLE]. Use for non-critical data or data that would be outdated if received late due to resend attempt(s) anyway, for example movement and positional data.*/
	TransferModeUnreliableOrdered TransferMode = 1
	/*Packets must be received and resend attempts should be made until the packets are acknowledged. Packets must be received in the order they were sent in. Most reliable transfer mode, but potentially the slowest due to the overhead. Use for critical data that must be transmitted and arrive in order, for example an ability being triggered or a chat message. Consider carefully if the information really is critical, and use sparingly.*/
	TransferModeReliable TransferMode = 2
)

type TargetPeer int

const TargetPeerBroadcast TargetPeer = 0 //gd:MultiplayerPeer.TARGET_PEER_BROADCAST
const TargetPeerServer TargetPeer = 1    //gd:MultiplayerPeer.TARGET_PEER_SERVER
