// Code generated by the generate package DO NOT EDIT

// Package StreamPeerBuffer provides methods for working with StreamPeerBuffer object instances.
package StreamPeerBuffer

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/StreamPeer"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
A data buffer stream peer that uses a byte array as the stream. This object can be used to handle binary data from network sessions. To handle binary data stored in files, [FileAccess] can be used directly.
A [StreamPeerBuffer] object keeps an internal cursor which is the offset in bytes to the start of the buffer. Get and put operations are performed at the cursor position and will move the cursor accordingly.
*/
type Instance [1]gdclass.StreamPeerBuffer

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	seek           gdextension.MethodForClass `hash:"1286410249"`
	get_size       gdextension.MethodForClass `hash:"3905245786"`
	get_position   gdextension.MethodForClass `hash:"3905245786"`
	resize         gdextension.MethodForClass `hash:"1286410249"`
	set_data_array gdextension.MethodForClass `hash:"2971499966"`
	get_data_array gdextension.MethodForClass `hash:"2362200018"`
	clear          gdextension.MethodForClass `hash:"3218959716"`
	duplicate      gdextension.MethodForClass `hash:"2474064677"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("StreamPeerBuffer")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		gdextension.Free(gdextension.TypeStringName, &sname)
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsStreamPeerBuffer() Instance
}

/*
Moves the cursor to the specified position. [param position] must be a valid index of [member data_array].
*/
func (self Instance) SeekTo(position int) { //gd:StreamPeerBuffer.seek
	Advanced(self).SeekTo(int64(position))
}

/*
Returns the size of [member data_array].
*/
func (self Instance) GetSize() int { //gd:StreamPeerBuffer.get_size
	return int(int(Advanced(self).GetSize()))
}

/*
Returns the current cursor position.
*/
func (self Instance) GetPosition() int { //gd:StreamPeerBuffer.get_position
	return int(int(Advanced(self).GetPosition()))
}

/*
Resizes the [member data_array]. This [i]doesn't[/i] update the cursor.
*/
func (self Instance) Resize(size int) { //gd:StreamPeerBuffer.resize
	Advanced(self).Resize(int64(size))
}

/*
Clears the [member data_array] and resets the cursor.
*/
func (self Instance) Clear() { //gd:StreamPeerBuffer.clear
	Advanced(self).Clear()
}

/*
Returns a new [StreamPeerBuffer] with the same [member data_array] content.
*/
func (self Instance) Duplicate() Instance { //gd:StreamPeerBuffer.duplicate
	return Instance(Advanced(self).Duplicate())
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.StreamPeerBuffer

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.StreamPeerBuffer)(unsafe.Pointer(&obj))
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.StreamPeerBuffer)(unsafe.Pointer(&obj))
		return true
	}
	return false
}

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {

	if !gd.Linked {
		var placeholder Instance
		*(*gd.Object)(unsafe.Pointer(&placeholder)) = pointers.Add[gd.Object]([3]uint64{})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(*(*gd.Object)(unsafe.Pointer(&placeholder)), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	object := [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})}
	casted := Instance{*(*gdclass.StreamPeerBuffer)(unsafe.Pointer(&object))}
	object[0].Notification(0, false)
	return casted
}

func (self Instance) DataArray() []byte {
	return []byte(class(self).GetDataArray().Bytes())
}

func (self Instance) SetDataArray(value []byte) {
	class(self).SetDataArray(Packed.Bytes(Packed.New(value...)))
}

/*
Moves the cursor to the specified position. [param position] must be a valid index of [member data_array].
*/
//go:nosplit
func (self class) SeekTo(position int64) { //gd:StreamPeerBuffer.seek
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.seek, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ position int64 }{position}))
}

/*
Returns the size of [member data_array].
*/
//go:nosplit
func (self class) GetSize() int64 { //gd:StreamPeerBuffer.get_size
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_size, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the current cursor position.
*/
//go:nosplit
func (self class) GetPosition() int64 { //gd:StreamPeerBuffer.get_position
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_position, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Resizes the [member data_array]. This [i]doesn't[/i] update the cursor.
*/
//go:nosplit
func (self class) Resize(size int64) { //gd:StreamPeerBuffer.resize
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.resize, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ size int64 }{size}))
}

//go:nosplit
func (self class) SetDataArray(data Packed.Bytes) { //gd:StreamPeerBuffer.set_data_array
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_data_array, 0|(gdextension.SizePackedArray<<4), unsafe.Pointer(&struct{ data gdextension.PackedArray[byte] }{pointers.Get(gd.InternalPacked[gd.PackedByteArray, byte](Packed.Array[byte](data)))}))
}

//go:nosplit
func (self class) GetDataArray() Packed.Bytes { //gd:StreamPeerBuffer.get_data_array
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.get_data_array, gdextension.SizePackedArray, unsafe.Pointer(&struct{}{}))
	var ret = Packed.Bytes(Array.Through(gd.PackedProxy[gd.PackedByteArray, byte]{}, pointers.Pack(pointers.Let[gd.PackedByteArray](r_ret))))
	return ret
}

/*
Clears the [member data_array] and resets the cursor.
*/
//go:nosplit
func (self class) Clear() { //gd:StreamPeerBuffer.clear
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.clear, 0, unsafe.Pointer(&struct{}{}))
}

/*
Returns a new [StreamPeerBuffer] with the same [member data_array] content.
*/
//go:nosplit
func (self class) Duplicate() [1]gdclass.StreamPeerBuffer { //gd:StreamPeerBuffer.duplicate
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.duplicate, gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.StreamPeerBuffer{gd.PointerWithOwnershipTransferredToGo[gdclass.StreamPeerBuffer](r_ret)}
	return ret
}
func (self class) AsStreamPeerBuffer() Advanced         { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsStreamPeerBuffer() Instance      { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsStreamPeerBuffer() Instance { return self.Super().AsStreamPeerBuffer() }
func (self class) AsStreamPeer() StreamPeer.Advanced {
	return *((*StreamPeer.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsStreamPeer() StreamPeer.Instance { return self.Super().AsStreamPeer() }
func (self Instance) AsStreamPeer() StreamPeer.Instance {
	return *((*StreamPeer.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsRefCounted() [1]gd.RefCounted { return self.Super().AsRefCounted() }
func (self Instance) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(StreamPeer.Advanced(self.AsStreamPeer()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(StreamPeer.Instance(self.AsStreamPeer()), name)
	}
}
func init() {
	gdclass.Register("StreamPeerBuffer", func(ptr gd.Object) any { return *(*Instance)(unsafe.Pointer(&ptr)) })
}
