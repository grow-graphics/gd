// Code generated by the generate package DO NOT EDIT

// Package CSGPolygon3D provides methods for working with CSGPolygon3D object instances.
package CSGPolygon3D

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/variant/Signal"
import "graphics.gd/classdb/CSGPrimitive3D"
import "graphics.gd/classdb/CSGShape3D"
import "graphics.gd/classdb/GeometryInstance3D"
import "graphics.gd/classdb/Material"
import "graphics.gd/classdb/Node"
import "graphics.gd/classdb/Node3D"
import "graphics.gd/classdb/VisualInstance3D"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"
import "graphics.gd/variant/Vector2"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Signal.Any
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
An array of 2D points is extruded to quickly and easily create a variety of 3D meshes. See also [CSGMesh3D] for using 3D meshes as CSG nodes.
[b]Note:[/b] CSG nodes are intended to be used for level prototyping. Creating CSG nodes has a significant CPU cost compared to creating a [MeshInstance3D] with a [PrimitiveMesh]. Moving a CSG node within another CSG node also has a significant CPU cost, so it should be avoided during gameplay.
*/
type Instance [1]gdclass.CSGPolygon3D

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	set_polygon                gdextension.MethodForClass `hash:"1509147220"`
	get_polygon                gdextension.MethodForClass `hash:"2961356807"`
	set_mode                   gdextension.MethodForClass `hash:"3158377035"`
	get_mode                   gdextension.MethodForClass `hash:"1201612222"`
	set_depth                  gdextension.MethodForClass `hash:"373806689"`
	get_depth                  gdextension.MethodForClass `hash:"1740695150"`
	set_spin_degrees           gdextension.MethodForClass `hash:"373806689"`
	get_spin_degrees           gdextension.MethodForClass `hash:"1740695150"`
	set_spin_sides             gdextension.MethodForClass `hash:"1286410249"`
	get_spin_sides             gdextension.MethodForClass `hash:"3905245786"`
	set_path_node              gdextension.MethodForClass `hash:"1348162250"`
	get_path_node              gdextension.MethodForClass `hash:"4075236667"`
	set_path_interval_type     gdextension.MethodForClass `hash:"3744240707"`
	get_path_interval_type     gdextension.MethodForClass `hash:"3434618397"`
	set_path_interval          gdextension.MethodForClass `hash:"373806689"`
	get_path_interval          gdextension.MethodForClass `hash:"1740695150"`
	set_path_simplify_angle    gdextension.MethodForClass `hash:"373806689"`
	get_path_simplify_angle    gdextension.MethodForClass `hash:"1740695150"`
	set_path_rotation          gdextension.MethodForClass `hash:"1412947288"`
	get_path_rotation          gdextension.MethodForClass `hash:"647219346"`
	set_path_rotation_accurate gdextension.MethodForClass `hash:"2586408642"`
	get_path_rotation_accurate gdextension.MethodForClass `hash:"36873697"`
	set_path_local             gdextension.MethodForClass `hash:"2586408642"`
	is_path_local              gdextension.MethodForClass `hash:"36873697"`
	set_path_continuous_u      gdextension.MethodForClass `hash:"2586408642"`
	is_path_continuous_u       gdextension.MethodForClass `hash:"36873697"`
	set_path_u_distance        gdextension.MethodForClass `hash:"373806689"`
	get_path_u_distance        gdextension.MethodForClass `hash:"1740695150"`
	set_path_joined            gdextension.MethodForClass `hash:"2586408642"`
	is_path_joined             gdextension.MethodForClass `hash:"36873697"`
	set_material               gdextension.MethodForClass `hash:"2757459619"`
	get_material               gdextension.MethodForClass `hash:"5934680"`
	set_smooth_faces           gdextension.MethodForClass `hash:"2586408642"`
	get_smooth_faces           gdextension.MethodForClass `hash:"36873697"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("CSGPolygon3D")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		gdextension.Free(gdextension.TypeStringName, &sname)
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsCSGPolygon3D() Instance
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.CSGPolygon3D

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.CSGPolygon3D)(unsafe.Pointer(&obj))
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.CSGPolygon3D)(unsafe.Pointer(&obj))
		return true
	}
	return false
}

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {

	if !gd.Linked {
		var placeholder Instance
		*(*gd.Object)(unsafe.Pointer(&placeholder)) = pointers.Add[gd.Object]([3]uint64{})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(*(*gd.Object)(unsafe.Pointer(&placeholder)), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	object := [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})}
	casted := Instance{*(*gdclass.CSGPolygon3D)(unsafe.Pointer(&object))}
	object[0].Notification(0, false)
	return casted
}

func (self Instance) Polygon() []Vector2.XY {
	return []Vector2.XY(slices.Collect(class(self).GetPolygon().Values()))
}

func (self Instance) SetPolygon(value []Vector2.XY) {
	class(self).SetPolygon(Packed.New(value...))
}

func (self Instance) Mode() Mode {
	return Mode(class(self).GetMode())
}

func (self Instance) SetMode(value Mode) {
	class(self).SetMode(value)
}

func (self Instance) Depth() Float.X {
	return Float.X(Float.X(class(self).GetDepth()))
}

func (self Instance) SetDepth(value Float.X) {
	class(self).SetDepth(float64(value))
}

func (self Instance) SpinDegrees() Float.X {
	return Float.X(Float.X(class(self).GetSpinDegrees()))
}

func (self Instance) SetSpinDegrees(value Float.X) {
	class(self).SetSpinDegrees(float64(value))
}

func (self Instance) SpinSides() int {
	return int(int(class(self).GetSpinSides()))
}

func (self Instance) SetSpinSides(value int) {
	class(self).SetSpinSides(int64(value))
}

func (self Instance) PathNode() string {
	return string(class(self).GetPathNode().String())
}

func (self Instance) SetPathNode(value string) {
	class(self).SetPathNode(Path.ToNode(String.New(value)))
}

func (self Instance) PathIntervalType() PathIntervalType {
	return PathIntervalType(class(self).GetPathIntervalType())
}

func (self Instance) SetPathIntervalType(value PathIntervalType) {
	class(self).SetPathIntervalType(value)
}

func (self Instance) PathInterval() Float.X {
	return Float.X(Float.X(class(self).GetPathInterval()))
}

func (self Instance) SetPathInterval(value Float.X) {
	class(self).SetPathInterval(float64(value))
}

func (self Instance) PathSimplifyAngle() Angle.Radians {
	return Angle.Radians(Float.X(class(self).GetPathSimplifyAngle()))
}

func (self Instance) SetPathSimplifyAngle(value Angle.Radians) {
	class(self).SetPathSimplifyAngle(float64(value))
}

func (self Instance) PathRotation() PathRotation {
	return PathRotation(class(self).GetPathRotation())
}

func (self Instance) SetPathRotation(value PathRotation) {
	class(self).SetPathRotation(value)
}

func (self Instance) PathRotationAccurate() bool {
	return bool(class(self).GetPathRotationAccurate())
}

func (self Instance) SetPathRotationAccurate(value bool) {
	class(self).SetPathRotationAccurate(value)
}

func (self Instance) PathLocal() bool {
	return bool(class(self).IsPathLocal())
}

func (self Instance) SetPathLocal(value bool) {
	class(self).SetPathLocal(value)
}

func (self Instance) PathContinuousU() bool {
	return bool(class(self).IsPathContinuousU())
}

func (self Instance) SetPathContinuousU(value bool) {
	class(self).SetPathContinuousU(value)
}

func (self Instance) PathUDistance() Float.X {
	return Float.X(Float.X(class(self).GetPathUDistance()))
}

func (self Instance) SetPathUDistance(value Float.X) {
	class(self).SetPathUDistance(float64(value))
}

func (self Instance) PathJoined() bool {
	return bool(class(self).IsPathJoined())
}

func (self Instance) SetPathJoined(value bool) {
	class(self).SetPathJoined(value)
}

func (self Instance) SmoothFaces() bool {
	return bool(class(self).GetSmoothFaces())
}

func (self Instance) SetSmoothFaces(value bool) {
	class(self).SetSmoothFaces(value)
}

func (self Instance) Material() Material.Instance {
	return Material.Instance(class(self).GetMaterial())
}

func (self Instance) SetMaterial(value Material.Instance) {
	class(self).SetMaterial(value)
}

//go:nosplit
func (self class) SetPolygon(polygon Packed.Array[Vector2.XY]) { //gd:CSGPolygon3D.set_polygon
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_polygon, 0|(gdextension.SizePackedArray<<4), unsafe.Pointer(&struct {
		polygon gdextension.PackedArray[Vector2.XY]
	}{pointers.Get(gd.InternalPacked[gd.PackedVector2Array, Vector2.XY](polygon))}))
}

//go:nosplit
func (self class) GetPolygon() Packed.Array[Vector2.XY] { //gd:CSGPolygon3D.get_polygon
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.get_polygon, gdextension.SizePackedArray, unsafe.Pointer(&struct{}{}))
	var ret = Packed.Array[Vector2.XY](Array.Through(gd.PackedProxy[gd.PackedVector2Array, Vector2.XY]{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

//go:nosplit
func (self class) SetMode(mode Mode) { //gd:CSGPolygon3D.set_mode
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_mode, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ mode Mode }{mode}))
}

//go:nosplit
func (self class) GetMode() Mode { //gd:CSGPolygon3D.get_mode
	var r_ret = gdextension.Call[Mode](gd.ObjectChecked(self.AsObject()), methods.get_mode, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetDepth(depth float64) { //gd:CSGPolygon3D.set_depth
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_depth, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ depth float64 }{depth}))
}

//go:nosplit
func (self class) GetDepth() float64 { //gd:CSGPolygon3D.get_depth
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_depth, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetSpinDegrees(degrees float64) { //gd:CSGPolygon3D.set_spin_degrees
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_spin_degrees, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ degrees float64 }{degrees}))
}

//go:nosplit
func (self class) GetSpinDegrees() float64 { //gd:CSGPolygon3D.get_spin_degrees
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_spin_degrees, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetSpinSides(spin_sides int64) { //gd:CSGPolygon3D.set_spin_sides
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_spin_sides, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ spin_sides int64 }{spin_sides}))
}

//go:nosplit
func (self class) GetSpinSides() int64 { //gd:CSGPolygon3D.get_spin_sides
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_spin_sides, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetPathNode(path Path.ToNode) { //gd:CSGPolygon3D.set_path_node
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_path_node, 0|(gdextension.SizeNodePath<<4), unsafe.Pointer(&struct{ path gdextension.NodePath }{pointers.Get(gd.InternalNodePath(path))}))
}

//go:nosplit
func (self class) GetPathNode() Path.ToNode { //gd:CSGPolygon3D.get_path_node
	var r_ret = gdextension.Call[gdextension.NodePath](gd.ObjectChecked(self.AsObject()), methods.get_path_node, gdextension.SizeNodePath, unsafe.Pointer(&struct{}{}))
	var ret = Path.ToNode(String.Via(gd.NodePathProxy{}, pointers.Pack(pointers.New[gd.NodePath](r_ret))))
	return ret
}

//go:nosplit
func (self class) SetPathIntervalType(interval_type PathIntervalType) { //gd:CSGPolygon3D.set_path_interval_type
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_path_interval_type, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ interval_type PathIntervalType }{interval_type}))
}

//go:nosplit
func (self class) GetPathIntervalType() PathIntervalType { //gd:CSGPolygon3D.get_path_interval_type
	var r_ret = gdextension.Call[PathIntervalType](gd.ObjectChecked(self.AsObject()), methods.get_path_interval_type, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetPathInterval(interval float64) { //gd:CSGPolygon3D.set_path_interval
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_path_interval, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ interval float64 }{interval}))
}

//go:nosplit
func (self class) GetPathInterval() float64 { //gd:CSGPolygon3D.get_path_interval
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_path_interval, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetPathSimplifyAngle(degrees float64) { //gd:CSGPolygon3D.set_path_simplify_angle
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_path_simplify_angle, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ degrees float64 }{degrees}))
}

//go:nosplit
func (self class) GetPathSimplifyAngle() float64 { //gd:CSGPolygon3D.get_path_simplify_angle
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_path_simplify_angle, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetPathRotation(path_rotation PathRotation) { //gd:CSGPolygon3D.set_path_rotation
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_path_rotation, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ path_rotation PathRotation }{path_rotation}))
}

//go:nosplit
func (self class) GetPathRotation() PathRotation { //gd:CSGPolygon3D.get_path_rotation
	var r_ret = gdextension.Call[PathRotation](gd.ObjectChecked(self.AsObject()), methods.get_path_rotation, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetPathRotationAccurate(enable bool) { //gd:CSGPolygon3D.set_path_rotation_accurate
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_path_rotation_accurate, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

//go:nosplit
func (self class) GetPathRotationAccurate() bool { //gd:CSGPolygon3D.get_path_rotation_accurate
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.get_path_rotation_accurate, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetPathLocal(enable bool) { //gd:CSGPolygon3D.set_path_local
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_path_local, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

//go:nosplit
func (self class) IsPathLocal() bool { //gd:CSGPolygon3D.is_path_local
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_path_local, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetPathContinuousU(enable bool) { //gd:CSGPolygon3D.set_path_continuous_u
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_path_continuous_u, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

//go:nosplit
func (self class) IsPathContinuousU() bool { //gd:CSGPolygon3D.is_path_continuous_u
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_path_continuous_u, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetPathUDistance(distance float64) { //gd:CSGPolygon3D.set_path_u_distance
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_path_u_distance, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ distance float64 }{distance}))
}

//go:nosplit
func (self class) GetPathUDistance() float64 { //gd:CSGPolygon3D.get_path_u_distance
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_path_u_distance, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetPathJoined(enable bool) { //gd:CSGPolygon3D.set_path_joined
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_path_joined, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

//go:nosplit
func (self class) IsPathJoined() bool { //gd:CSGPolygon3D.is_path_joined
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_path_joined, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetMaterial(material [1]gdclass.Material) { //gd:CSGPolygon3D.set_material
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_material, 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ material gdextension.Object }{gdextension.Object(gd.ObjectChecked(material[0].AsObject()))}))
}

//go:nosplit
func (self class) GetMaterial() [1]gdclass.Material { //gd:CSGPolygon3D.get_material
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_material, gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.Material{gd.PointerWithOwnershipTransferredToGo[gdclass.Material](r_ret)}
	return ret
}

//go:nosplit
func (self class) SetSmoothFaces(smooth_faces bool) { //gd:CSGPolygon3D.set_smooth_faces
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_smooth_faces, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ smooth_faces bool }{smooth_faces}))
}

//go:nosplit
func (self class) GetSmoothFaces() bool { //gd:CSGPolygon3D.get_smooth_faces
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.get_smooth_faces, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}
func (self class) AsCSGPolygon3D() Advanced         { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsCSGPolygon3D() Instance      { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsCSGPolygon3D() Instance { return self.Super().AsCSGPolygon3D() }
func (self class) AsCSGPrimitive3D() CSGPrimitive3D.Advanced {
	return *((*CSGPrimitive3D.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsCSGPrimitive3D() CSGPrimitive3D.Instance {
	return self.Super().AsCSGPrimitive3D()
}
func (self Instance) AsCSGPrimitive3D() CSGPrimitive3D.Instance {
	return *((*CSGPrimitive3D.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsCSGShape3D() CSGShape3D.Advanced {
	return *((*CSGShape3D.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsCSGShape3D() CSGShape3D.Instance { return self.Super().AsCSGShape3D() }
func (self Instance) AsCSGShape3D() CSGShape3D.Instance {
	return *((*CSGShape3D.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsGeometryInstance3D() GeometryInstance3D.Advanced {
	return *((*GeometryInstance3D.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsGeometryInstance3D() GeometryInstance3D.Instance {
	return self.Super().AsGeometryInstance3D()
}
func (self Instance) AsGeometryInstance3D() GeometryInstance3D.Instance {
	return *((*GeometryInstance3D.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsVisualInstance3D() VisualInstance3D.Advanced {
	return *((*VisualInstance3D.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsVisualInstance3D() VisualInstance3D.Instance {
	return self.Super().AsVisualInstance3D()
}
func (self Instance) AsVisualInstance3D() VisualInstance3D.Instance {
	return *((*VisualInstance3D.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsNode3D() Node3D.Advanced         { return *((*Node3D.Advanced)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsNode3D() Node3D.Instance { return self.Super().AsNode3D() }
func (self Instance) AsNode3D() Node3D.Instance      { return *((*Node3D.Instance)(unsafe.Pointer(&self))) }
func (self class) AsNode() Node.Advanced             { return *((*Node.Advanced)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsNode() Node.Instance     { return self.Super().AsNode() }
func (self Instance) AsNode() Node.Instance          { return *((*Node.Instance)(unsafe.Pointer(&self))) }

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(CSGPrimitive3D.Advanced(self.AsCSGPrimitive3D()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(CSGPrimitive3D.Instance(self.AsCSGPrimitive3D()), name)
	}
}
func init() {
	gdclass.Register("CSGPolygon3D", func(ptr gd.Object) any { return *(*Instance)(unsafe.Pointer(&ptr)) })
}

type Mode int //gd:CSGPolygon3D.Mode

const (
	/*The [member polygon] shape is extruded along the negative Z axis.*/
	ModeDepth Mode = 0
	/*The [member polygon] shape is extruded by rotating it around the Y axis.*/
	ModeSpin Mode = 1
	/*The [member polygon] shape is extruded along the [Path3D] specified in [member path_node].*/
	ModePath Mode = 2
)

type PathRotation int //gd:CSGPolygon3D.PathRotation

const (
	/*The [member polygon] shape is not rotated.
	  [b]Note:[/b] Requires the path Z coordinates to continually decrease to ensure viable shapes.*/
	PathRotationPolygon PathRotation = 0
	/*The [member polygon] shape is rotated along the path, but it is not rotated around the path axis.
	  [b]Note:[/b] Requires the path Z coordinates to continually decrease to ensure viable shapes.*/
	PathRotationPath PathRotation = 1
	/*The [member polygon] shape follows the path and its rotations around the path axis.*/
	PathRotationPathFollow PathRotation = 2
)

type PathIntervalType int //gd:CSGPolygon3D.PathIntervalType

const (
	/*When [member mode] is set to [constant MODE_PATH], [member path_interval] will determine the distance, in meters, each interval of the path will extrude.*/
	PathIntervalDistance PathIntervalType = 0
	/*When [member mode] is set to [constant MODE_PATH], [member path_interval] will subdivide the polygons along the path.*/
	PathIntervalSubdivide PathIntervalType = 1
)
