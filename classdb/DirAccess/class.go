// Code generated by the generate package DO NOT EDIT

// Package DirAccess provides methods for working with DirAccess object instances.
package DirAccess

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
This class is used to manage directories and their content, even outside of the project folder.
[DirAccess] can't be instantiated directly. Instead it is created with a static method that takes a path for which it will be opened.
Most of the methods have a static alternative that can be used without creating a [DirAccess]. Static methods only support absolute paths (including [code]res://[/code] and [code]user://[/code]).
[codeblock]
# Standard
var dir = DirAccess.open("user://levels")
dir.make_dir("world1")
# Static
DirAccess.make_dir_absolute("user://levels/world1")
[/codeblock]
[b]Note:[/b] Accessing project ("res://") directories once exported may behave unexpectedly as some files are converted to engine-specific formats and their original source files may not be present in the expected PCK package. Because of this, to access resources in an exported project, it is recommended to use [ResourceLoader] instead of [FileAccess].
Here is an example on how to iterate through the files of a directory:
[codeblocks]
[gdscript]
func dir_contents(path):

	var dir = DirAccess.open(path)
	if dir:
	    dir.list_dir_begin()
	    var file_name = dir.get_next()
	    while file_name != "":
	        if dir.current_is_dir():
	            print("Found directory: " + file_name)
	        else:
	            print("Found file: " + file_name)
	        file_name = dir.get_next()
	else:
	    print("An error occurred when trying to access the path.")

[/gdscript]
[csharp]
public void DirContents(string path)

	{
	    using var dir = DirAccess.Open(path);
	    if (dir != null)
	    {
	        dir.ListDirBegin();
	        string fileName = dir.GetNext();
	        while (fileName != "")
	        {
	            if (dir.CurrentIsDir())
	            {
	                GD.Print($"Found directory: {fileName}");
	            }
	            else
	            {
	                GD.Print($"Found file: {fileName}");
	            }
	            fileName = dir.GetNext();
	        }
	    }
	    else
	    {
	        GD.Print("An error occurred when trying to access the path.");
	    }
	}

[/csharp]
[/codeblocks]
Keep in mind that file names may change or be remapped after export. If you want to see the actual resource file list as it appears in the editor, use [method ResourceLoader.list_directory] instead.
*/
type Instance [1]gdclass.DirAccess

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	open                        gdextension.MethodForClass `hash:"1923528528"`
	get_open_error              gdextension.MethodForClass `hash:"166280745"`
	create_temp                 gdextension.MethodForClass `hash:"812913566"`
	list_dir_begin              gdextension.MethodForClass `hash:"166280745"`
	get_next                    gdextension.MethodForClass `hash:"2841200299"`
	current_is_dir              gdextension.MethodForClass `hash:"36873697"`
	list_dir_end                gdextension.MethodForClass `hash:"3218959716"`
	get_files                   gdextension.MethodForClass `hash:"2981934095"`
	get_files_at                gdextension.MethodForClass `hash:"3538744774"`
	get_directories             gdextension.MethodForClass `hash:"2981934095"`
	get_directories_at          gdextension.MethodForClass `hash:"3538744774"`
	get_drive_count             gdextension.MethodForClass `hash:"2455072627"`
	get_drive_name              gdextension.MethodForClass `hash:"990163283"`
	get_current_drive           gdextension.MethodForClass `hash:"2455072627"`
	change_dir                  gdextension.MethodForClass `hash:"166001499"`
	get_current_dir             gdextension.MethodForClass `hash:"1287308131"`
	make_dir                    gdextension.MethodForClass `hash:"166001499"`
	make_dir_absolute           gdextension.MethodForClass `hash:"166001499"`
	make_dir_recursive          gdextension.MethodForClass `hash:"166001499"`
	make_dir_recursive_absolute gdextension.MethodForClass `hash:"166001499"`
	file_exists                 gdextension.MethodForClass `hash:"2323990056"`
	dir_exists                  gdextension.MethodForClass `hash:"2323990056"`
	dir_exists_absolute         gdextension.MethodForClass `hash:"2323990056"`
	get_space_left              gdextension.MethodForClass `hash:"2455072627"`
	copy                        gdextension.MethodForClass `hash:"1063198817"`
	copy_absolute               gdextension.MethodForClass `hash:"1063198817"`
	rename                      gdextension.MethodForClass `hash:"852856452"`
	rename_absolute             gdextension.MethodForClass `hash:"852856452"`
	remove                      gdextension.MethodForClass `hash:"166001499"`
	remove_absolute             gdextension.MethodForClass `hash:"166001499"`
	is_link                     gdextension.MethodForClass `hash:"2323990056"`
	read_link                   gdextension.MethodForClass `hash:"1703090593"`
	create_link                 gdextension.MethodForClass `hash:"852856452"`
	is_bundle                   gdextension.MethodForClass `hash:"3927539163"`
	set_include_navigational    gdextension.MethodForClass `hash:"2586408642"`
	get_include_navigational    gdextension.MethodForClass `hash:"36873697"`
	set_include_hidden          gdextension.MethodForClass `hash:"2586408642"`
	get_include_hidden          gdextension.MethodForClass `hash:"36873697"`
	is_case_sensitive           gdextension.MethodForClass `hash:"3927539163"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("DirAccess")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		gdextension.Free(gdextension.TypeStringName, &sname)
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

type Expanded [1]gdclass.DirAccess

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsDirAccess() Instance
}

/*
Creates a new [DirAccess] object and opens an existing directory of the filesystem. The [param path] argument can be within the project tree ([code]res://folder[/code]), the user directory ([code]user://folder[/code]) or an absolute path of the user filesystem (e.g. [code]/tmp/folder[/code] or [code]C:\tmp\folder[/code]).
Returns [code]null[/code] if opening the directory failed. You can use [method get_open_error] to check the error that occurred.
*/
func Open(path string) Instance { //gd:DirAccess.open
	self := Instance{}
	return Instance(Advanced(self).Open(String.New(path)))
}

/*
Returns the result of the last [method open] call in the current thread.
*/
func GetOpenError() error { //gd:DirAccess.get_open_error
	self := Instance{}
	return error(gd.ToError(Advanced(self).GetOpenError()))
}

/*
Creates a temporary directory. This directory will be freed when the returned [DirAccess] is freed.
If [param prefix] is not empty, it will be prefixed to the directory name, separated by a [code]-[/code].
If [param keep] is [code]true[/code], the directory is not deleted when the returned [DirAccess] is freed.
Returns [code]null[/code] if opening the directory failed. You can use [method get_open_error] to check the error that occurred.
*/
func CreateTemp(prefix string, keep bool) Instance { //gd:DirAccess.create_temp
	self := Instance{}
	return Instance(Advanced(self).CreateTemp(String.New(prefix), keep))
}

/*
Creates a temporary directory. This directory will be freed when the returned [DirAccess] is freed.
If [param prefix] is not empty, it will be prefixed to the directory name, separated by a [code]-[/code].
If [param keep] is [code]true[/code], the directory is not deleted when the returned [DirAccess] is freed.
Returns [code]null[/code] if opening the directory failed. You can use [method get_open_error] to check the error that occurred.
*/
func CreateTempOptions(prefix string, keep bool) Instance { //gd:DirAccess.create_temp
	self := Instance{}
	return Instance(Advanced(self).CreateTemp(String.New(prefix), keep))
}

/*
Initializes the stream used to list all files and directories using the [method get_next] function, closing the currently opened stream if needed. Once the stream has been processed, it should typically be closed with [method list_dir_end].
Affected by [member include_hidden] and [member include_navigational].
[b]Note:[/b] The order of files and directories returned by this method is not deterministic, and can vary between operating systems. If you want a list of all files or folders sorted alphabetically, use [method get_files] or [method get_directories].
*/
func (self Instance) ListDirBegin() error { //gd:DirAccess.list_dir_begin
	return error(gd.ToError(Advanced(self).ListDirBegin()))
}

/*
Returns the next element (file or directory) in the current directory.
The name of the file or directory is returned (and not its full path). Once the stream has been fully processed, the method returns an empty [String] and closes the stream automatically (i.e. [method list_dir_end] would not be mandatory in such a case).
*/
func (self Instance) GetNext() string { //gd:DirAccess.get_next
	return string(Advanced(self).GetNext().String())
}

/*
Returns whether the current item processed with the last [method get_next] call is a directory ([code].[/code] and [code]..[/code] are considered directories).
*/
func (self Instance) CurrentIsDir() bool { //gd:DirAccess.current_is_dir
	return bool(Advanced(self).CurrentIsDir())
}

/*
Closes the current stream opened with [method list_dir_begin] (whether it has been fully processed with [method get_next] does not matter).
*/
func (self Instance) ListDirEnd() { //gd:DirAccess.list_dir_end
	Advanced(self).ListDirEnd()
}

/*
Returns a [PackedStringArray] containing filenames of the directory contents, excluding directories. The array is sorted alphabetically.
Affected by [member include_hidden].
[b]Note:[/b] When used on a [code]res://[/code] path in an exported project, only the files actually included in the PCK at the given folder level are returned. In practice, this means that since imported resources are stored in a top-level [code].godot/[/code] folder, only paths to [code]*.gd[/code] and [code]*.import[/code] files are returned (plus a few files such as [code]project.godot[/code] or [code]project.binary[/code] and the project icon). In an exported project, the list of returned files will also vary depending on whether [member ProjectSettings.editor/export/convert_text_resources_to_binary] is [code]true[/code].
*/
func (self Instance) GetFiles() []string { //gd:DirAccess.get_files
	return []string(Advanced(self).GetFiles().Strings())
}

/*
Returns a [PackedStringArray] containing filenames of the directory contents, excluding directories, at the given [param path]. The array is sorted alphabetically.
Use [method get_files] if you want more control of what gets included.
[b]Note:[/b] When used on a [code]res://[/code] path in an exported project, only the files included in the PCK at the given folder level are returned. In practice, this means that since imported resources are stored in a top-level [code].godot/[/code] folder, only paths to [code].gd[/code] and [code].import[/code] files are returned (plus a few other files, such as [code]project.godot[/code] or [code]project.binary[/code] and the project icon). In an exported project, the list of returned files will also vary depending on [member ProjectSettings.editor/export/convert_text_resources_to_binary].
*/
func GetFilesAt(path string) []string { //gd:DirAccess.get_files_at
	self := Instance{}
	return []string(Advanced(self).GetFilesAt(String.New(path)).Strings())
}

/*
Returns a [PackedStringArray] containing filenames of the directory contents, excluding files. The array is sorted alphabetically.
Affected by [member include_hidden] and [member include_navigational].
[b]Note:[/b] The returned directories in the editor and after exporting in the [code]res://[/code] directory may differ as some files are converted to engine-specific formats when exported.
*/
func (self Instance) GetDirectories() []string { //gd:DirAccess.get_directories
	return []string(Advanced(self).GetDirectories().Strings())
}

/*
Returns a [PackedStringArray] containing filenames of the directory contents, excluding files, at the given [param path]. The array is sorted alphabetically.
Use [method get_directories] if you want more control of what gets included.
[b]Note:[/b] The returned directories in the editor and after exporting in the [code]res://[/code] directory may differ as some files are converted to engine-specific formats when exported.
*/
func GetDirectoriesAt(path string) []string { //gd:DirAccess.get_directories_at
	self := Instance{}
	return []string(Advanced(self).GetDirectoriesAt(String.New(path)).Strings())
}

/*
On Windows, returns the number of drives (partitions) mounted on the current filesystem.
On macOS, returns the number of mounted volumes.
On Linux, returns the number of mounted volumes and GTK 3 bookmarks.
On other platforms, the method returns 0.
*/
func GetDriveCount() int { //gd:DirAccess.get_drive_count
	self := Instance{}
	return int(int(Advanced(self).GetDriveCount()))
}

/*
On Windows, returns the name of the drive (partition) passed as an argument (e.g. [code]C:[/code]).
On macOS, returns the path to the mounted volume passed as an argument.
On Linux, returns the path to the mounted volume or GTK 3 bookmark passed as an argument.
On other platforms, or if the requested drive does not exist, the method returns an empty String.
*/
func GetDriveName(idx int) string { //gd:DirAccess.get_drive_name
	self := Instance{}
	return string(Advanced(self).GetDriveName(int64(idx)).String())
}

/*
Returns the currently opened directory's drive index. See [method get_drive_name] to convert returned index to the name of the drive.
*/
func (self Instance) GetCurrentDrive() int { //gd:DirAccess.get_current_drive
	return int(int(Advanced(self).GetCurrentDrive()))
}

/*
Changes the currently opened directory to the one passed as an argument. The argument can be relative to the current directory (e.g. [code]newdir[/code] or [code]../newdir[/code]), or an absolute path (e.g. [code]/tmp/newdir[/code] or [code]res://somedir/newdir[/code]).
Returns one of the [enum Error] code constants ([constant OK] on success).
[b]Note:[/b] The new directory must be within the same scope, e.g. when you had opened a directory inside [code]res://[/code], you can't change it to [code]user://[/code] directory. If you need to open a directory in another access scope, use [method open] to create a new instance instead.
*/
func (self Instance) ChangeDir(to_dir string) error { //gd:DirAccess.change_dir
	return error(gd.ToError(Advanced(self).ChangeDir(String.New(to_dir))))
}

/*
Returns the absolute path to the currently opened directory (e.g. [code]res://folder[/code] or [code]C:\tmp\folder[/code]).
*/
func (self Instance) GetCurrentDir() string { //gd:DirAccess.get_current_dir
	return string(Advanced(self).GetCurrentDir(true).String())
}

/*
Returns the absolute path to the currently opened directory (e.g. [code]res://folder[/code] or [code]C:\tmp\folder[/code]).
*/
func (self Expanded) GetCurrentDir(include_drive bool) string { //gd:DirAccess.get_current_dir
	return string(Advanced(self).GetCurrentDir(include_drive).String())
}

/*
Creates a directory. The argument can be relative to the current directory, or an absolute path. The target directory should be placed in an already existing directory (to create the full path recursively, see [method make_dir_recursive]).
Returns one of the [enum Error] code constants ([constant OK] on success).
*/
func (self Instance) MakeDir(path string) error { //gd:DirAccess.make_dir
	return error(gd.ToError(Advanced(self).MakeDir(String.New(path))))
}

/*
Static version of [method make_dir]. Supports only absolute paths.
*/
func MakeDirAbsolute(path string) error { //gd:DirAccess.make_dir_absolute
	self := Instance{}
	return error(gd.ToError(Advanced(self).MakeDirAbsolute(String.New(path))))
}

/*
Creates a target directory and all necessary intermediate directories in its path, by calling [method make_dir] recursively. The argument can be relative to the current directory, or an absolute path.
Returns one of the [enum Error] code constants ([constant OK] on success).
*/
func (self Instance) MakeDirRecursive(path string) error { //gd:DirAccess.make_dir_recursive
	return error(gd.ToError(Advanced(self).MakeDirRecursive(String.New(path))))
}

/*
Static version of [method make_dir_recursive]. Supports only absolute paths.
*/
func MakeDirRecursiveAbsolute(path string) error { //gd:DirAccess.make_dir_recursive_absolute
	self := Instance{}
	return error(gd.ToError(Advanced(self).MakeDirRecursiveAbsolute(String.New(path))))
}

/*
Returns whether the target file exists. The argument can be relative to the current directory, or an absolute path.
For a static equivalent, use [method FileAccess.file_exists].
[b]Note:[/b] Many resources types are imported (e.g. textures or sound files), and their source asset will not be included in the exported game, as only the imported version is used. See [method ResourceLoader.exists] for an alternative approach that takes resource remapping into account.
*/
func (self Instance) FileExists(path string) bool { //gd:DirAccess.file_exists
	return bool(Advanced(self).FileExists(String.New(path)))
}

/*
Returns whether the target directory exists. The argument can be relative to the current directory, or an absolute path.
[b]Note:[/b] The returned [bool] in the editor and after exporting when used on a path in the [code]res://[/code] directory may be different. Some files are converted to engine-specific formats when exported, potentially changing the directory structure.
*/
func (self Instance) DirExists(path string) bool { //gd:DirAccess.dir_exists
	return bool(Advanced(self).DirExists(String.New(path)))
}

/*
Static version of [method dir_exists]. Supports only absolute paths.
[b]Note:[/b] The returned [bool] in the editor and after exporting when used on a path in the [code]res://[/code] directory may be different. Some files are converted to engine-specific formats when exported, potentially changing the directory structure.
*/
func DirExistsAbsolute(path string) bool { //gd:DirAccess.dir_exists_absolute
	self := Instance{}
	return bool(Advanced(self).DirExistsAbsolute(String.New(path)))
}

/*
Returns the available space on the current directory's disk, in bytes. Returns [code]0[/code] if the platform-specific method to query the available space fails.
*/
func (self Instance) GetSpaceLeft() int { //gd:DirAccess.get_space_left
	return int(int(Advanced(self).GetSpaceLeft()))
}

/*
Copies the [param from] file to the [param to] destination. Both arguments should be paths to files, either relative or absolute. If the destination file exists and is not access-protected, it will be overwritten.
If [param chmod_flags] is different than [code]-1[/code], the Unix permissions for the destination path will be set to the provided value, if available on the current operating system.
Returns one of the [enum Error] code constants ([constant OK] on success).
*/
func (self Instance) Copy(from string, to string) error { //gd:DirAccess.copy
	return error(gd.ToError(Advanced(self).Copy(String.New(from), String.New(to), int64(-1))))
}

/*
Copies the [param from] file to the [param to] destination. Both arguments should be paths to files, either relative or absolute. If the destination file exists and is not access-protected, it will be overwritten.
If [param chmod_flags] is different than [code]-1[/code], the Unix permissions for the destination path will be set to the provided value, if available on the current operating system.
Returns one of the [enum Error] code constants ([constant OK] on success).
*/
func (self Expanded) Copy(from string, to string, chmod_flags int) error { //gd:DirAccess.copy
	return error(gd.ToError(Advanced(self).Copy(String.New(from), String.New(to), int64(chmod_flags))))
}

/*
Static version of [method copy]. Supports only absolute paths.
*/
func CopyAbsolute(from string, to string) error { //gd:DirAccess.copy_absolute
	self := Instance{}
	return error(gd.ToError(Advanced(self).CopyAbsolute(String.New(from), String.New(to), int64(-1))))
}

/*
Static version of [method copy]. Supports only absolute paths.
*/
func CopyAbsoluteOptions(from string, to string, chmod_flags int) error { //gd:DirAccess.copy_absolute
	self := Instance{}
	return error(gd.ToError(Advanced(self).CopyAbsolute(String.New(from), String.New(to), int64(chmod_flags))))
}

/*
Renames (move) the [param from] file or directory to the [param to] destination. Both arguments should be paths to files or directories, either relative or absolute. If the destination file or directory exists and is not access-protected, it will be overwritten.
Returns one of the [enum Error] code constants ([constant OK] on success).
*/
func (self Instance) Rename(from string, to string) error { //gd:DirAccess.rename
	return error(gd.ToError(Advanced(self).Rename(String.New(from), String.New(to))))
}

/*
Static version of [method rename]. Supports only absolute paths.
*/
func RenameAbsolute(from string, to string) error { //gd:DirAccess.rename_absolute
	self := Instance{}
	return error(gd.ToError(Advanced(self).RenameAbsolute(String.New(from), String.New(to))))
}

/*
Permanently deletes the target file or an empty directory. The argument can be relative to the current directory, or an absolute path. If the target directory is not empty, the operation will fail.
If you don't want to delete the file/directory permanently, use [method OS.move_to_trash] instead.
Returns one of the [enum Error] code constants ([constant OK] on success).
*/
func (self Instance) Remove(path string) error { //gd:DirAccess.remove
	return error(gd.ToError(Advanced(self).Remove(String.New(path))))
}

/*
Static version of [method remove]. Supports only absolute paths.
*/
func RemoveAbsolute(path string) error { //gd:DirAccess.remove_absolute
	self := Instance{}
	return error(gd.ToError(Advanced(self).RemoveAbsolute(String.New(path))))
}

/*
Returns [code]true[/code] if the file or directory is a symbolic link, directory junction, or other reparse point.
[b]Note:[/b] This method is implemented on macOS, Linux, and Windows.
*/
func (self Instance) IsLink(path string) bool { //gd:DirAccess.is_link
	return bool(Advanced(self).IsLink(String.New(path)))
}

/*
Returns target of the symbolic link.
[b]Note:[/b] This method is implemented on macOS, Linux, and Windows.
*/
func (self Instance) ReadLink(path string) string { //gd:DirAccess.read_link
	return string(Advanced(self).ReadLink(String.New(path)).String())
}

/*
Creates symbolic link between files or folders.
[b]Note:[/b] On Windows, this method works only if the application is running with elevated privileges or Developer Mode is enabled.
[b]Note:[/b] This method is implemented on macOS, Linux, and Windows.
*/
func (self Instance) CreateLink(source string, target string) error { //gd:DirAccess.create_link
	return error(gd.ToError(Advanced(self).CreateLink(String.New(source), String.New(target))))
}

/*
Returns [code]true[/code] if the directory is a macOS bundle.
[b]Note:[/b] This method is implemented on macOS.
*/
func (self Instance) IsBundle(path string) bool { //gd:DirAccess.is_bundle
	return bool(Advanced(self).IsBundle(String.New(path)))
}

/*
Returns [code]true[/code] if the file system or directory use case sensitive file names.
[b]Note:[/b] This method is implemented on macOS, Linux (for EXT4 and F2FS filesystems only) and Windows. On other platforms, it always returns [code]true[/code].
*/
func (self Instance) IsCaseSensitive(path string) bool { //gd:DirAccess.is_case_sensitive
	return bool(Advanced(self).IsCaseSensitive(String.New(path)))
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.DirAccess

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.DirAccess)(unsafe.Pointer(&obj))
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.DirAccess)(unsafe.Pointer(&obj))
		return true
	}
	return false
}

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {

	if !gd.Linked {
		var placeholder Instance
		*(*gd.Object)(unsafe.Pointer(&placeholder)) = pointers.Add[gd.Object]([3]uint64{})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(*(*gd.Object)(unsafe.Pointer(&placeholder)), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	object := [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})}
	casted := Instance{*(*gdclass.DirAccess)(unsafe.Pointer(&object))}
	object[0].Notification(0, false)
	return casted
}

func (self Instance) IncludeNavigational() bool {
	return bool(class(self).GetIncludeNavigational())
}

func (self Instance) SetIncludeNavigational(value bool) {
	class(self).SetIncludeNavigational(value)
}

func (self Instance) IncludeHidden() bool {
	return bool(class(self).GetIncludeHidden())
}

func (self Instance) SetIncludeHidden(value bool) {
	class(self).SetIncludeHidden(value)
}

/*
Creates a new [DirAccess] object and opens an existing directory of the filesystem. The [param path] argument can be within the project tree ([code]res://folder[/code]), the user directory ([code]user://folder[/code]) or an absolute path of the user filesystem (e.g. [code]/tmp/folder[/code] or [code]C:\tmp\folder[/code]).
Returns [code]null[/code] if opening the directory failed. You can use [method get_open_error] to check the error that occurred.
*/
//go:nosplit
func (self class) Open(path String.Readable) [1]gdclass.DirAccess { //gd:DirAccess.open
	var r_ret = gdextension.CallStatic[gdextension.Object](methods.open, gdextension.SizeObject|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ path gdextension.String }{pointers.Get(gd.InternalString(path))}))
	var ret = [1]gdclass.DirAccess{gd.PointerWithOwnershipTransferredToGo[gdclass.DirAccess](r_ret)}
	return ret
}

/*
Returns the result of the last [method open] call in the current thread.
*/
//go:nosplit
func (self class) GetOpenError() Error.Code { //gd:DirAccess.get_open_error
	var r_ret = gdextension.CallStatic[int64](methods.get_open_error, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = Error.Code(r_ret)
	return ret
}

/*
Creates a temporary directory. This directory will be freed when the returned [DirAccess] is freed.
If [param prefix] is not empty, it will be prefixed to the directory name, separated by a [code]-[/code].
If [param keep] is [code]true[/code], the directory is not deleted when the returned [DirAccess] is freed.
Returns [code]null[/code] if opening the directory failed. You can use [method get_open_error] to check the error that occurred.
*/
//go:nosplit
func (self class) CreateTemp(prefix String.Readable, keep bool) [1]gdclass.DirAccess { //gd:DirAccess.create_temp
	var r_ret = gdextension.CallStatic[gdextension.Object](methods.create_temp, gdextension.SizeObject|(gdextension.SizeString<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		prefix gdextension.String
		keep   bool
	}{pointers.Get(gd.InternalString(prefix)), keep}))
	var ret = [1]gdclass.DirAccess{gd.PointerWithOwnershipTransferredToGo[gdclass.DirAccess](r_ret)}
	return ret
}

/*
Initializes the stream used to list all files and directories using the [method get_next] function, closing the currently opened stream if needed. Once the stream has been processed, it should typically be closed with [method list_dir_end].
Affected by [member include_hidden] and [member include_navigational].
[b]Note:[/b] The order of files and directories returned by this method is not deterministic, and can vary between operating systems. If you want a list of all files or folders sorted alphabetically, use [method get_files] or [method get_directories].
*/
//go:nosplit
func (self class) ListDirBegin() Error.Code { //gd:DirAccess.list_dir_begin
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.list_dir_begin, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = Error.Code(r_ret)
	return ret
}

/*
Returns the next element (file or directory) in the current directory.
The name of the file or directory is returned (and not its full path). Once the stream has been fully processed, the method returns an empty [String] and closes the stream automatically (i.e. [method list_dir_end] would not be mandatory in such a case).
*/
//go:nosplit
func (self class) GetNext() String.Readable { //gd:DirAccess.get_next
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_next, gdextension.SizeString, unsafe.Pointer(&struct{}{}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Returns whether the current item processed with the last [method get_next] call is a directory ([code].[/code] and [code]..[/code] are considered directories).
*/
//go:nosplit
func (self class) CurrentIsDir() bool { //gd:DirAccess.current_is_dir
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.current_is_dir, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Closes the current stream opened with [method list_dir_begin] (whether it has been fully processed with [method get_next] does not matter).
*/
//go:nosplit
func (self class) ListDirEnd() { //gd:DirAccess.list_dir_end
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.list_dir_end, 0, unsafe.Pointer(&struct{}{}))
}

/*
Returns a [PackedStringArray] containing filenames of the directory contents, excluding directories. The array is sorted alphabetically.
Affected by [member include_hidden].
[b]Note:[/b] When used on a [code]res://[/code] path in an exported project, only the files actually included in the PCK at the given folder level are returned. In practice, this means that since imported resources are stored in a top-level [code].godot/[/code] folder, only paths to [code]*.gd[/code] and [code]*.import[/code] files are returned (plus a few files such as [code]project.godot[/code] or [code]project.binary[/code] and the project icon). In an exported project, the list of returned files will also vary depending on whether [member ProjectSettings.editor/export/convert_text_resources_to_binary] is [code]true[/code].
*/
//go:nosplit
func (self class) GetFiles() Packed.Strings { //gd:DirAccess.get_files
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.get_files, gdextension.SizePackedArray, unsafe.Pointer(&struct{}{}))
	var ret = Packed.Strings(Array.Through(gd.PackedStringArrayProxy{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

/*
Returns a [PackedStringArray] containing filenames of the directory contents, excluding directories, at the given [param path]. The array is sorted alphabetically.
Use [method get_files] if you want more control of what gets included.
[b]Note:[/b] When used on a [code]res://[/code] path in an exported project, only the files included in the PCK at the given folder level are returned. In practice, this means that since imported resources are stored in a top-level [code].godot/[/code] folder, only paths to [code].gd[/code] and [code].import[/code] files are returned (plus a few other files, such as [code]project.godot[/code] or [code]project.binary[/code] and the project icon). In an exported project, the list of returned files will also vary depending on [member ProjectSettings.editor/export/convert_text_resources_to_binary].
*/
//go:nosplit
func (self class) GetFilesAt(path String.Readable) Packed.Strings { //gd:DirAccess.get_files_at
	var r_ret = gdextension.CallStatic[gd.PackedPointers](methods.get_files_at, gdextension.SizePackedArray|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ path gdextension.String }{pointers.Get(gd.InternalString(path))}))
	var ret = Packed.Strings(Array.Through(gd.PackedStringArrayProxy{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

/*
Returns a [PackedStringArray] containing filenames of the directory contents, excluding files. The array is sorted alphabetically.
Affected by [member include_hidden] and [member include_navigational].
[b]Note:[/b] The returned directories in the editor and after exporting in the [code]res://[/code] directory may differ as some files are converted to engine-specific formats when exported.
*/
//go:nosplit
func (self class) GetDirectories() Packed.Strings { //gd:DirAccess.get_directories
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.get_directories, gdextension.SizePackedArray, unsafe.Pointer(&struct{}{}))
	var ret = Packed.Strings(Array.Through(gd.PackedStringArrayProxy{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

/*
Returns a [PackedStringArray] containing filenames of the directory contents, excluding files, at the given [param path]. The array is sorted alphabetically.
Use [method get_directories] if you want more control of what gets included.
[b]Note:[/b] The returned directories in the editor and after exporting in the [code]res://[/code] directory may differ as some files are converted to engine-specific formats when exported.
*/
//go:nosplit
func (self class) GetDirectoriesAt(path String.Readable) Packed.Strings { //gd:DirAccess.get_directories_at
	var r_ret = gdextension.CallStatic[gd.PackedPointers](methods.get_directories_at, gdextension.SizePackedArray|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ path gdextension.String }{pointers.Get(gd.InternalString(path))}))
	var ret = Packed.Strings(Array.Through(gd.PackedStringArrayProxy{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

/*
On Windows, returns the number of drives (partitions) mounted on the current filesystem.
On macOS, returns the number of mounted volumes.
On Linux, returns the number of mounted volumes and GTK 3 bookmarks.
On other platforms, the method returns 0.
*/
//go:nosplit
func (self class) GetDriveCount() int64 { //gd:DirAccess.get_drive_count
	var r_ret = gdextension.CallStatic[int64](methods.get_drive_count, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
On Windows, returns the name of the drive (partition) passed as an argument (e.g. [code]C:[/code]).
On macOS, returns the path to the mounted volume passed as an argument.
On Linux, returns the path to the mounted volume or GTK 3 bookmark passed as an argument.
On other platforms, or if the requested drive does not exist, the method returns an empty String.
*/
//go:nosplit
func (self class) GetDriveName(idx int64) String.Readable { //gd:DirAccess.get_drive_name
	var r_ret = gdextension.CallStatic[gdextension.String](methods.get_drive_name, gdextension.SizeString|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ idx int64 }{idx}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Returns the currently opened directory's drive index. See [method get_drive_name] to convert returned index to the name of the drive.
*/
//go:nosplit
func (self class) GetCurrentDrive() int64 { //gd:DirAccess.get_current_drive
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_current_drive, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Changes the currently opened directory to the one passed as an argument. The argument can be relative to the current directory (e.g. [code]newdir[/code] or [code]../newdir[/code]), or an absolute path (e.g. [code]/tmp/newdir[/code] or [code]res://somedir/newdir[/code]).
Returns one of the [enum Error] code constants ([constant OK] on success).
[b]Note:[/b] The new directory must be within the same scope, e.g. when you had opened a directory inside [code]res://[/code], you can't change it to [code]user://[/code] directory. If you need to open a directory in another access scope, use [method open] to create a new instance instead.
*/
//go:nosplit
func (self class) ChangeDir(to_dir String.Readable) Error.Code { //gd:DirAccess.change_dir
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.change_dir, gdextension.SizeInt|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ to_dir gdextension.String }{pointers.Get(gd.InternalString(to_dir))}))
	var ret = Error.Code(r_ret)
	return ret
}

/*
Returns the absolute path to the currently opened directory (e.g. [code]res://folder[/code] or [code]C:\tmp\folder[/code]).
*/
//go:nosplit
func (self class) GetCurrentDir(include_drive bool) String.Readable { //gd:DirAccess.get_current_dir
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_current_dir, gdextension.SizeString|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ include_drive bool }{include_drive}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Creates a directory. The argument can be relative to the current directory, or an absolute path. The target directory should be placed in an already existing directory (to create the full path recursively, see [method make_dir_recursive]).
Returns one of the [enum Error] code constants ([constant OK] on success).
*/
//go:nosplit
func (self class) MakeDir(path String.Readable) Error.Code { //gd:DirAccess.make_dir
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.make_dir, gdextension.SizeInt|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ path gdextension.String }{pointers.Get(gd.InternalString(path))}))
	var ret = Error.Code(r_ret)
	return ret
}

/*
Static version of [method make_dir]. Supports only absolute paths.
*/
//go:nosplit
func (self class) MakeDirAbsolute(path String.Readable) Error.Code { //gd:DirAccess.make_dir_absolute
	var r_ret = gdextension.CallStatic[int64](methods.make_dir_absolute, gdextension.SizeInt|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ path gdextension.String }{pointers.Get(gd.InternalString(path))}))
	var ret = Error.Code(r_ret)
	return ret
}

/*
Creates a target directory and all necessary intermediate directories in its path, by calling [method make_dir] recursively. The argument can be relative to the current directory, or an absolute path.
Returns one of the [enum Error] code constants ([constant OK] on success).
*/
//go:nosplit
func (self class) MakeDirRecursive(path String.Readable) Error.Code { //gd:DirAccess.make_dir_recursive
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.make_dir_recursive, gdextension.SizeInt|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ path gdextension.String }{pointers.Get(gd.InternalString(path))}))
	var ret = Error.Code(r_ret)
	return ret
}

/*
Static version of [method make_dir_recursive]. Supports only absolute paths.
*/
//go:nosplit
func (self class) MakeDirRecursiveAbsolute(path String.Readable) Error.Code { //gd:DirAccess.make_dir_recursive_absolute
	var r_ret = gdextension.CallStatic[int64](methods.make_dir_recursive_absolute, gdextension.SizeInt|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ path gdextension.String }{pointers.Get(gd.InternalString(path))}))
	var ret = Error.Code(r_ret)
	return ret
}

/*
Returns whether the target file exists. The argument can be relative to the current directory, or an absolute path.
For a static equivalent, use [method FileAccess.file_exists].
[b]Note:[/b] Many resources types are imported (e.g. textures or sound files), and their source asset will not be included in the exported game, as only the imported version is used. See [method ResourceLoader.exists] for an alternative approach that takes resource remapping into account.
*/
//go:nosplit
func (self class) FileExists(path String.Readable) bool { //gd:DirAccess.file_exists
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.file_exists, gdextension.SizeBool|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ path gdextension.String }{pointers.Get(gd.InternalString(path))}))
	var ret = r_ret
	return ret
}

/*
Returns whether the target directory exists. The argument can be relative to the current directory, or an absolute path.
[b]Note:[/b] The returned [bool] in the editor and after exporting when used on a path in the [code]res://[/code] directory may be different. Some files are converted to engine-specific formats when exported, potentially changing the directory structure.
*/
//go:nosplit
func (self class) DirExists(path String.Readable) bool { //gd:DirAccess.dir_exists
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.dir_exists, gdextension.SizeBool|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ path gdextension.String }{pointers.Get(gd.InternalString(path))}))
	var ret = r_ret
	return ret
}

/*
Static version of [method dir_exists]. Supports only absolute paths.
[b]Note:[/b] The returned [bool] in the editor and after exporting when used on a path in the [code]res://[/code] directory may be different. Some files are converted to engine-specific formats when exported, potentially changing the directory structure.
*/
//go:nosplit
func (self class) DirExistsAbsolute(path String.Readable) bool { //gd:DirAccess.dir_exists_absolute
	var r_ret = gdextension.CallStatic[bool](methods.dir_exists_absolute, gdextension.SizeBool|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ path gdextension.String }{pointers.Get(gd.InternalString(path))}))
	var ret = r_ret
	return ret
}

/*
Returns the available space on the current directory's disk, in bytes. Returns [code]0[/code] if the platform-specific method to query the available space fails.
*/
//go:nosplit
func (self class) GetSpaceLeft() int64 { //gd:DirAccess.get_space_left
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_space_left, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Copies the [param from] file to the [param to] destination. Both arguments should be paths to files, either relative or absolute. If the destination file exists and is not access-protected, it will be overwritten.
If [param chmod_flags] is different than [code]-1[/code], the Unix permissions for the destination path will be set to the provided value, if available on the current operating system.
Returns one of the [enum Error] code constants ([constant OK] on success).
*/
//go:nosplit
func (self class) Copy(from String.Readable, to String.Readable, chmod_flags int64) Error.Code { //gd:DirAccess.copy
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.copy, gdextension.SizeInt|(gdextension.SizeString<<4)|(gdextension.SizeString<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		from        gdextension.String
		to          gdextension.String
		chmod_flags int64
	}{pointers.Get(gd.InternalString(from)), pointers.Get(gd.InternalString(to)), chmod_flags}))
	var ret = Error.Code(r_ret)
	return ret
}

/*
Static version of [method copy]. Supports only absolute paths.
*/
//go:nosplit
func (self class) CopyAbsolute(from String.Readable, to String.Readable, chmod_flags int64) Error.Code { //gd:DirAccess.copy_absolute
	var r_ret = gdextension.CallStatic[int64](methods.copy_absolute, gdextension.SizeInt|(gdextension.SizeString<<4)|(gdextension.SizeString<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		from        gdextension.String
		to          gdextension.String
		chmod_flags int64
	}{pointers.Get(gd.InternalString(from)), pointers.Get(gd.InternalString(to)), chmod_flags}))
	var ret = Error.Code(r_ret)
	return ret
}

/*
Renames (move) the [param from] file or directory to the [param to] destination. Both arguments should be paths to files or directories, either relative or absolute. If the destination file or directory exists and is not access-protected, it will be overwritten.
Returns one of the [enum Error] code constants ([constant OK] on success).
*/
//go:nosplit
func (self class) Rename(from String.Readable, to String.Readable) Error.Code { //gd:DirAccess.rename
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.rename, gdextension.SizeInt|(gdextension.SizeString<<4)|(gdextension.SizeString<<8), unsafe.Pointer(&struct {
		from gdextension.String
		to   gdextension.String
	}{pointers.Get(gd.InternalString(from)), pointers.Get(gd.InternalString(to))}))
	var ret = Error.Code(r_ret)
	return ret
}

/*
Static version of [method rename]. Supports only absolute paths.
*/
//go:nosplit
func (self class) RenameAbsolute(from String.Readable, to String.Readable) Error.Code { //gd:DirAccess.rename_absolute
	var r_ret = gdextension.CallStatic[int64](methods.rename_absolute, gdextension.SizeInt|(gdextension.SizeString<<4)|(gdextension.SizeString<<8), unsafe.Pointer(&struct {
		from gdextension.String
		to   gdextension.String
	}{pointers.Get(gd.InternalString(from)), pointers.Get(gd.InternalString(to))}))
	var ret = Error.Code(r_ret)
	return ret
}

/*
Permanently deletes the target file or an empty directory. The argument can be relative to the current directory, or an absolute path. If the target directory is not empty, the operation will fail.
If you don't want to delete the file/directory permanently, use [method OS.move_to_trash] instead.
Returns one of the [enum Error] code constants ([constant OK] on success).
*/
//go:nosplit
func (self class) Remove(path String.Readable) Error.Code { //gd:DirAccess.remove
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.remove, gdextension.SizeInt|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ path gdextension.String }{pointers.Get(gd.InternalString(path))}))
	var ret = Error.Code(r_ret)
	return ret
}

/*
Static version of [method remove]. Supports only absolute paths.
*/
//go:nosplit
func (self class) RemoveAbsolute(path String.Readable) Error.Code { //gd:DirAccess.remove_absolute
	var r_ret = gdextension.CallStatic[int64](methods.remove_absolute, gdextension.SizeInt|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ path gdextension.String }{pointers.Get(gd.InternalString(path))}))
	var ret = Error.Code(r_ret)
	return ret
}

/*
Returns [code]true[/code] if the file or directory is a symbolic link, directory junction, or other reparse point.
[b]Note:[/b] This method is implemented on macOS, Linux, and Windows.
*/
//go:nosplit
func (self class) IsLink(path String.Readable) bool { //gd:DirAccess.is_link
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_link, gdextension.SizeBool|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ path gdextension.String }{pointers.Get(gd.InternalString(path))}))
	var ret = r_ret
	return ret
}

/*
Returns target of the symbolic link.
[b]Note:[/b] This method is implemented on macOS, Linux, and Windows.
*/
//go:nosplit
func (self class) ReadLink(path String.Readable) String.Readable { //gd:DirAccess.read_link
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.read_link, gdextension.SizeString|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ path gdextension.String }{pointers.Get(gd.InternalString(path))}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Creates symbolic link between files or folders.
[b]Note:[/b] On Windows, this method works only if the application is running with elevated privileges or Developer Mode is enabled.
[b]Note:[/b] This method is implemented on macOS, Linux, and Windows.
*/
//go:nosplit
func (self class) CreateLink(source String.Readable, target String.Readable) Error.Code { //gd:DirAccess.create_link
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.create_link, gdextension.SizeInt|(gdextension.SizeString<<4)|(gdextension.SizeString<<8), unsafe.Pointer(&struct {
		source gdextension.String
		target gdextension.String
	}{pointers.Get(gd.InternalString(source)), pointers.Get(gd.InternalString(target))}))
	var ret = Error.Code(r_ret)
	return ret
}

/*
Returns [code]true[/code] if the directory is a macOS bundle.
[b]Note:[/b] This method is implemented on macOS.
*/
//go:nosplit
func (self class) IsBundle(path String.Readable) bool { //gd:DirAccess.is_bundle
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_bundle, gdextension.SizeBool|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ path gdextension.String }{pointers.Get(gd.InternalString(path))}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetIncludeNavigational(enable bool) { //gd:DirAccess.set_include_navigational
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_include_navigational, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

//go:nosplit
func (self class) GetIncludeNavigational() bool { //gd:DirAccess.get_include_navigational
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.get_include_navigational, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetIncludeHidden(enable bool) { //gd:DirAccess.set_include_hidden
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_include_hidden, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

//go:nosplit
func (self class) GetIncludeHidden() bool { //gd:DirAccess.get_include_hidden
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.get_include_hidden, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if the file system or directory use case sensitive file names.
[b]Note:[/b] This method is implemented on macOS, Linux (for EXT4 and F2FS filesystems only) and Windows. On other platforms, it always returns [code]true[/code].
*/
//go:nosplit
func (self class) IsCaseSensitive(path String.Readable) bool { //gd:DirAccess.is_case_sensitive
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_case_sensitive, gdextension.SizeBool|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ path gdextension.String }{pointers.Get(gd.InternalString(path))}))
	var ret = r_ret
	return ret
}
func (self class) AsDirAccess() Advanced         { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsDirAccess() Instance      { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsDirAccess() Instance { return self.Super().AsDirAccess() }
func (self class) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsRefCounted() [1]gd.RefCounted { return self.Super().AsRefCounted() }
func (self Instance) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(RefCounted.Advanced(self.AsRefCounted()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(RefCounted.Instance(self.AsRefCounted()), name)
	}
}
func init() {
	gdclass.Register("DirAccess", func(ptr gd.Object) any { return *(*Instance)(unsafe.Pointer(&ptr)) })
}
