// Code generated by the generate package DO NOT EDIT

// Package SpriteFrames provides methods for working with SpriteFrames object instances.
package SpriteFrames

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/Resource"
import "graphics.gd/classdb/Texture2D"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
Sprite frame library for an [AnimatedSprite2D] or [AnimatedSprite3D] node. Contains frames and animation data for playback.
*/
type Instance [1]gdclass.SpriteFrames

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	add_animation       gdextension.MethodForClass `hash:"3304788590"`
	has_animation       gdextension.MethodForClass `hash:"2619796661"`
	duplicate_animation gdextension.MethodForClass `hash:"3740211285"`
	remove_animation    gdextension.MethodForClass `hash:"3304788590"`
	rename_animation    gdextension.MethodForClass `hash:"3740211285"`
	get_animation_names gdextension.MethodForClass `hash:"1139954409"`
	set_animation_speed gdextension.MethodForClass `hash:"4135858297"`
	get_animation_speed gdextension.MethodForClass `hash:"2349060816"`
	set_animation_loop  gdextension.MethodForClass `hash:"2524380260"`
	get_animation_loop  gdextension.MethodForClass `hash:"2619796661"`
	add_frame           gdextension.MethodForClass `hash:"1351332740"`
	set_frame           gdextension.MethodForClass `hash:"56804795"`
	remove_frame        gdextension.MethodForClass `hash:"2415702435"`
	get_frame_count     gdextension.MethodForClass `hash:"2458036349"`
	get_frame_texture   gdextension.MethodForClass `hash:"2900517879"`
	get_frame_duration  gdextension.MethodForClass `hash:"1129309260"`
	clear               gdextension.MethodForClass `hash:"3304788590"`
	clear_all           gdextension.MethodForClass `hash:"3218959716"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("SpriteFrames")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		gdextension.Free(gdextension.TypeStringName, &sname)
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

type Expanded [1]gdclass.SpriteFrames

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsSpriteFrames() Instance
}

/*
Adds a new [param anim] animation to the library.
*/
func (self Instance) AddAnimation(anim string) { //gd:SpriteFrames.add_animation
	Advanced(self).AddAnimation(String.Name(String.New(anim)))
}

/*
Returns [code]true[/code] if the [param anim] animation exists.
*/
func (self Instance) HasAnimation(anim string) bool { //gd:SpriteFrames.has_animation
	return bool(Advanced(self).HasAnimation(String.Name(String.New(anim))))
}

/*
Duplicates the animation [param anim_from] to a new animation named [param anim_to]. Fails if [param anim_to] already exists, or if [param anim_from] does not exist.
*/
func (self Instance) DuplicateAnimation(anim_from string, anim_to string) { //gd:SpriteFrames.duplicate_animation
	Advanced(self).DuplicateAnimation(String.Name(String.New(anim_from)), String.Name(String.New(anim_to)))
}

/*
Removes the [param anim] animation.
*/
func (self Instance) RemoveAnimation(anim string) { //gd:SpriteFrames.remove_animation
	Advanced(self).RemoveAnimation(String.Name(String.New(anim)))
}

/*
Changes the [param anim] animation's name to [param newname].
*/
func (self Instance) RenameAnimation(anim string, newname string) { //gd:SpriteFrames.rename_animation
	Advanced(self).RenameAnimation(String.Name(String.New(anim)), String.Name(String.New(newname)))
}

/*
Returns an array containing the names associated to each animation. Values are placed in alphabetical order.
*/
func (self Instance) GetAnimationNames() []string { //gd:SpriteFrames.get_animation_names
	return []string(Advanced(self).GetAnimationNames().Strings())
}

/*
Sets the speed for the [param anim] animation in frames per second.
*/
func (self Instance) SetAnimationSpeed(anim string, fps Float.X) { //gd:SpriteFrames.set_animation_speed
	Advanced(self).SetAnimationSpeed(String.Name(String.New(anim)), float64(fps))
}

/*
Returns the speed in frames per second for the [param anim] animation.
*/
func (self Instance) GetAnimationSpeed(anim string) Float.X { //gd:SpriteFrames.get_animation_speed
	return Float.X(Float.X(Advanced(self).GetAnimationSpeed(String.Name(String.New(anim)))))
}

/*
If [param loop] is [code]true[/code], the [param anim] animation will loop when it reaches the end, or the start if it is played in reverse.
*/
func (self Instance) SetAnimationLoop(anim string, loop bool) { //gd:SpriteFrames.set_animation_loop
	Advanced(self).SetAnimationLoop(String.Name(String.New(anim)), loop)
}

/*
Returns [code]true[/code] if the given animation is configured to loop when it finishes playing. Otherwise, returns [code]false[/code].
*/
func (self Instance) GetAnimationLoop(anim string) bool { //gd:SpriteFrames.get_animation_loop
	return bool(Advanced(self).GetAnimationLoop(String.Name(String.New(anim))))
}

/*
Adds a frame to the [param anim] animation. If [param at_position] is [code]-1[/code], the frame will be added to the end of the animation. [param duration] specifies the relative duration, see [method get_frame_duration] for details.
*/
func (self Instance) AddFrame(anim string, texture Texture2D.Instance) { //gd:SpriteFrames.add_frame
	Advanced(self).AddFrame(String.Name(String.New(anim)), texture, float64(1.0), int64(-1))
}

/*
Adds a frame to the [param anim] animation. If [param at_position] is [code]-1[/code], the frame will be added to the end of the animation. [param duration] specifies the relative duration, see [method get_frame_duration] for details.
*/
func (self Expanded) AddFrame(anim string, texture Texture2D.Instance, duration Float.X, at_position int) { //gd:SpriteFrames.add_frame
	Advanced(self).AddFrame(String.Name(String.New(anim)), texture, float64(duration), int64(at_position))
}

/*
Sets the [param texture] and the [param duration] of the frame [param idx] in the [param anim] animation. [param duration] specifies the relative duration, see [method get_frame_duration] for details.
*/
func (self Instance) SetFrame(anim string, idx int, texture Texture2D.Instance) { //gd:SpriteFrames.set_frame
	Advanced(self).SetFrame(String.Name(String.New(anim)), int64(idx), texture, float64(1.0))
}

/*
Sets the [param texture] and the [param duration] of the frame [param idx] in the [param anim] animation. [param duration] specifies the relative duration, see [method get_frame_duration] for details.
*/
func (self Expanded) SetFrame(anim string, idx int, texture Texture2D.Instance, duration Float.X) { //gd:SpriteFrames.set_frame
	Advanced(self).SetFrame(String.Name(String.New(anim)), int64(idx), texture, float64(duration))
}

/*
Removes the [param anim] animation's frame [param idx].
*/
func (self Instance) RemoveFrame(anim string, idx int) { //gd:SpriteFrames.remove_frame
	Advanced(self).RemoveFrame(String.Name(String.New(anim)), int64(idx))
}

/*
Returns the number of frames for the [param anim] animation.
*/
func (self Instance) GetFrameCount(anim string) int { //gd:SpriteFrames.get_frame_count
	return int(int(Advanced(self).GetFrameCount(String.Name(String.New(anim)))))
}

/*
Returns the texture of the frame [param idx] in the [param anim] animation.
*/
func (self Instance) GetFrameTexture(anim string, idx int) Texture2D.Instance { //gd:SpriteFrames.get_frame_texture
	return Texture2D.Instance(Advanced(self).GetFrameTexture(String.Name(String.New(anim)), int64(idx)))
}

/*
Returns a relative duration of the frame [param idx] in the [param anim] animation (defaults to [code]1.0[/code]). For example, a frame with a duration of [code]2.0[/code] is displayed twice as long as a frame with a duration of [code]1.0[/code]. You can calculate the absolute duration (in seconds) of a frame using the following formula:
[codeblock]
absolute_duration = relative_duration / (animation_fps * abs(playing_speed))
[/codeblock]
In this example, [code]playing_speed[/code] refers to either [method AnimatedSprite2D.get_playing_speed] or [method AnimatedSprite3D.get_playing_speed].
*/
func (self Instance) GetFrameDuration(anim string, idx int) Float.X { //gd:SpriteFrames.get_frame_duration
	return Float.X(Float.X(Advanced(self).GetFrameDuration(String.Name(String.New(anim)), int64(idx))))
}

/*
Removes all frames from the [param anim] animation.
*/
func (self Instance) Clear(anim string) { //gd:SpriteFrames.clear
	Advanced(self).Clear(String.Name(String.New(anim)))
}

/*
Removes all animations. An empty [code]default[/code] animation will be created.
*/
func (self Instance) ClearAll() { //gd:SpriteFrames.clear_all
	Advanced(self).ClearAll()
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.SpriteFrames

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.SpriteFrames)(unsafe.Pointer(&obj))
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.SpriteFrames)(unsafe.Pointer(&obj))
		return true
	}
	return false
}

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {

	if !gd.Linked {
		var placeholder Instance
		*(*gd.Object)(unsafe.Pointer(&placeholder)) = pointers.Add[gd.Object]([3]uint64{})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(*(*gd.Object)(unsafe.Pointer(&placeholder)), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	object := [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})}
	casted := Instance{*(*gdclass.SpriteFrames)(unsafe.Pointer(&object))}
	object[0].Notification(0, false)
	return casted
}

/*
Adds a new [param anim] animation to the library.
*/
//go:nosplit
func (self class) AddAnimation(anim String.Name) { //gd:SpriteFrames.add_animation
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_animation, 0|(gdextension.SizeStringName<<4), unsafe.Pointer(&struct{ anim gdextension.StringName }{pointers.Get(gd.InternalStringName(anim))}))
}

/*
Returns [code]true[/code] if the [param anim] animation exists.
*/
//go:nosplit
func (self class) HasAnimation(anim String.Name) bool { //gd:SpriteFrames.has_animation
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.has_animation, gdextension.SizeBool|(gdextension.SizeStringName<<4), unsafe.Pointer(&struct{ anim gdextension.StringName }{pointers.Get(gd.InternalStringName(anim))}))
	var ret = r_ret
	return ret
}

/*
Duplicates the animation [param anim_from] to a new animation named [param anim_to]. Fails if [param anim_to] already exists, or if [param anim_from] does not exist.
*/
//go:nosplit
func (self class) DuplicateAnimation(anim_from String.Name, anim_to String.Name) { //gd:SpriteFrames.duplicate_animation
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.duplicate_animation, 0|(gdextension.SizeStringName<<4)|(gdextension.SizeStringName<<8), unsafe.Pointer(&struct {
		anim_from gdextension.StringName
		anim_to   gdextension.StringName
	}{pointers.Get(gd.InternalStringName(anim_from)), pointers.Get(gd.InternalStringName(anim_to))}))
}

/*
Removes the [param anim] animation.
*/
//go:nosplit
func (self class) RemoveAnimation(anim String.Name) { //gd:SpriteFrames.remove_animation
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.remove_animation, 0|(gdextension.SizeStringName<<4), unsafe.Pointer(&struct{ anim gdextension.StringName }{pointers.Get(gd.InternalStringName(anim))}))
}

/*
Changes the [param anim] animation's name to [param newname].
*/
//go:nosplit
func (self class) RenameAnimation(anim String.Name, newname String.Name) { //gd:SpriteFrames.rename_animation
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.rename_animation, 0|(gdextension.SizeStringName<<4)|(gdextension.SizeStringName<<8), unsafe.Pointer(&struct {
		anim    gdextension.StringName
		newname gdextension.StringName
	}{pointers.Get(gd.InternalStringName(anim)), pointers.Get(gd.InternalStringName(newname))}))
}

/*
Returns an array containing the names associated to each animation. Values are placed in alphabetical order.
*/
//go:nosplit
func (self class) GetAnimationNames() Packed.Strings { //gd:SpriteFrames.get_animation_names
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.get_animation_names, gdextension.SizePackedArray, unsafe.Pointer(&struct{}{}))
	var ret = Packed.Strings(Array.Through(gd.PackedStringArrayProxy{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

/*
Sets the speed for the [param anim] animation in frames per second.
*/
//go:nosplit
func (self class) SetAnimationSpeed(anim String.Name, fps float64) { //gd:SpriteFrames.set_animation_speed
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_animation_speed, 0|(gdextension.SizeStringName<<4)|(gdextension.SizeFloat<<8), unsafe.Pointer(&struct {
		anim gdextension.StringName
		fps  float64
	}{pointers.Get(gd.InternalStringName(anim)), fps}))
}

/*
Returns the speed in frames per second for the [param anim] animation.
*/
//go:nosplit
func (self class) GetAnimationSpeed(anim String.Name) float64 { //gd:SpriteFrames.get_animation_speed
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_animation_speed, gdextension.SizeFloat|(gdextension.SizeStringName<<4), unsafe.Pointer(&struct{ anim gdextension.StringName }{pointers.Get(gd.InternalStringName(anim))}))
	var ret = r_ret
	return ret
}

/*
If [param loop] is [code]true[/code], the [param anim] animation will loop when it reaches the end, or the start if it is played in reverse.
*/
//go:nosplit
func (self class) SetAnimationLoop(anim String.Name, loop bool) { //gd:SpriteFrames.set_animation_loop
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_animation_loop, 0|(gdextension.SizeStringName<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		anim gdextension.StringName
		loop bool
	}{pointers.Get(gd.InternalStringName(anim)), loop}))
}

/*
Returns [code]true[/code] if the given animation is configured to loop when it finishes playing. Otherwise, returns [code]false[/code].
*/
//go:nosplit
func (self class) GetAnimationLoop(anim String.Name) bool { //gd:SpriteFrames.get_animation_loop
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.get_animation_loop, gdextension.SizeBool|(gdextension.SizeStringName<<4), unsafe.Pointer(&struct{ anim gdextension.StringName }{pointers.Get(gd.InternalStringName(anim))}))
	var ret = r_ret
	return ret
}

/*
Adds a frame to the [param anim] animation. If [param at_position] is [code]-1[/code], the frame will be added to the end of the animation. [param duration] specifies the relative duration, see [method get_frame_duration] for details.
*/
//go:nosplit
func (self class) AddFrame(anim String.Name, texture [1]gdclass.Texture2D, duration float64, at_position int64) { //gd:SpriteFrames.add_frame
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_frame, 0|(gdextension.SizeStringName<<4)|(gdextension.SizeObject<<8)|(gdextension.SizeFloat<<12)|(gdextension.SizeInt<<16), unsafe.Pointer(&struct {
		anim        gdextension.StringName
		texture     gdextension.Object
		duration    float64
		at_position int64
	}{pointers.Get(gd.InternalStringName(anim)), gdextension.Object(gd.CallerIncrements(texture[0].AsObject())), duration, at_position}))
}

/*
Sets the [param texture] and the [param duration] of the frame [param idx] in the [param anim] animation. [param duration] specifies the relative duration, see [method get_frame_duration] for details.
*/
//go:nosplit
func (self class) SetFrame(anim String.Name, idx int64, texture [1]gdclass.Texture2D, duration float64) { //gd:SpriteFrames.set_frame
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_frame, 0|(gdextension.SizeStringName<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeObject<<12)|(gdextension.SizeFloat<<16), unsafe.Pointer(&struct {
		anim     gdextension.StringName
		idx      int64
		texture  gdextension.Object
		duration float64
	}{pointers.Get(gd.InternalStringName(anim)), idx, gdextension.Object(gd.CallerIncrements(texture[0].AsObject())), duration}))
}

/*
Removes the [param anim] animation's frame [param idx].
*/
//go:nosplit
func (self class) RemoveFrame(anim String.Name, idx int64) { //gd:SpriteFrames.remove_frame
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.remove_frame, 0|(gdextension.SizeStringName<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		anim gdextension.StringName
		idx  int64
	}{pointers.Get(gd.InternalStringName(anim)), idx}))
}

/*
Returns the number of frames for the [param anim] animation.
*/
//go:nosplit
func (self class) GetFrameCount(anim String.Name) int64 { //gd:SpriteFrames.get_frame_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_frame_count, gdextension.SizeInt|(gdextension.SizeStringName<<4), unsafe.Pointer(&struct{ anim gdextension.StringName }{pointers.Get(gd.InternalStringName(anim))}))
	var ret = r_ret
	return ret
}

/*
Returns the texture of the frame [param idx] in the [param anim] animation.
*/
//go:nosplit
func (self class) GetFrameTexture(anim String.Name, idx int64) [1]gdclass.Texture2D { //gd:SpriteFrames.get_frame_texture
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_frame_texture, gdextension.SizeObject|(gdextension.SizeStringName<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		anim gdextension.StringName
		idx  int64
	}{pointers.Get(gd.InternalStringName(anim)), idx}))
	var ret = [1]gdclass.Texture2D{gd.PointerWithOwnershipTransferredToGo[gdclass.Texture2D](r_ret)}
	return ret
}

/*
Returns a relative duration of the frame [param idx] in the [param anim] animation (defaults to [code]1.0[/code]). For example, a frame with a duration of [code]2.0[/code] is displayed twice as long as a frame with a duration of [code]1.0[/code]. You can calculate the absolute duration (in seconds) of a frame using the following formula:
[codeblock]
absolute_duration = relative_duration / (animation_fps * abs(playing_speed))
[/codeblock]
In this example, [code]playing_speed[/code] refers to either [method AnimatedSprite2D.get_playing_speed] or [method AnimatedSprite3D.get_playing_speed].
*/
//go:nosplit
func (self class) GetFrameDuration(anim String.Name, idx int64) float64 { //gd:SpriteFrames.get_frame_duration
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_frame_duration, gdextension.SizeFloat|(gdextension.SizeStringName<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		anim gdextension.StringName
		idx  int64
	}{pointers.Get(gd.InternalStringName(anim)), idx}))
	var ret = r_ret
	return ret
}

/*
Removes all frames from the [param anim] animation.
*/
//go:nosplit
func (self class) Clear(anim String.Name) { //gd:SpriteFrames.clear
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.clear, 0|(gdextension.SizeStringName<<4), unsafe.Pointer(&struct{ anim gdextension.StringName }{pointers.Get(gd.InternalStringName(anim))}))
}

/*
Removes all animations. An empty [code]default[/code] animation will be created.
*/
//go:nosplit
func (self class) ClearAll() { //gd:SpriteFrames.clear_all
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.clear_all, 0, unsafe.Pointer(&struct{}{}))
}
func (self class) AsSpriteFrames() Advanced         { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsSpriteFrames() Instance      { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsSpriteFrames() Instance { return self.Super().AsSpriteFrames() }
func (self class) AsResource() Resource.Advanced {
	return *((*Resource.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsResource() Resource.Instance { return self.Super().AsResource() }
func (self Instance) AsResource() Resource.Instance {
	return *((*Resource.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsRefCounted() [1]gd.RefCounted { return self.Super().AsRefCounted() }
func (self Instance) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Resource.Advanced(self.AsResource()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Resource.Instance(self.AsResource()), name)
	}
}
func init() {
	gdclass.Register("SpriteFrames", func(ptr gd.Object) any { return *(*Instance)(unsafe.Pointer(&ptr)) })
}
