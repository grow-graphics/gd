// Code generated by the generate package DO NOT EDIT

// Package SkeletonModification2D provides methods for working with SkeletonModification2D object instances.
package SkeletonModification2D

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/variant/Signal"
import "graphics.gd/classdb/Resource"
import "graphics.gd/classdb/SkeletonModificationStack2D"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Signal.Any
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
This resource provides an interface that can be expanded so code that operates on [Bone2D] nodes in a [Skeleton2D] can be mixed and matched together to create complex interactions.
This is used to provide Godot with a flexible and powerful Inverse Kinematics solution that can be adapted for many different uses.

	See [Interface] for methods that can be overridden by a [Class] that extends it.
*/
type Instance [1]gdclass.SkeletonModification2D

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	set_enabled            gdextension.MethodForClass `hash:"2586408642"`
	get_enabled            gdextension.MethodForClass `hash:"2240911060"`
	get_modification_stack gdextension.MethodForClass `hash:"2137761694"`
	set_is_setup           gdextension.MethodForClass `hash:"2586408642"`
	get_is_setup           gdextension.MethodForClass `hash:"36873697"`
	set_execution_mode     gdextension.MethodForClass `hash:"1286410249"`
	get_execution_mode     gdextension.MethodForClass `hash:"3905245786"`
	clamp_angle            gdextension.MethodForClass `hash:"1229502682"`
	set_editor_draw_gizmo  gdextension.MethodForClass `hash:"2586408642"`
	get_editor_draw_gizmo  gdextension.MethodForClass `hash:"36873697"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("SkeletonModification2D")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		gdextension.Free(gdextension.TypeStringName, &sname)
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsSkeletonModification2D() Instance
}
type Interface interface {
	//Executes the given modification. This is where the modification performs whatever function it is designed to do.
	Execute(delta Float.X)
	//Called when the modification is setup. This is where the modification performs initialization.
	SetupModification(modification_stack SkeletonModificationStack2D.Instance)
	//Used for drawing [b]editor-only[/b] modification gizmos. This function will only be called in the Godot editor and can be overridden to draw custom gizmos.
	//[b]Note:[/b] You will need to use the Skeleton2D from [method SkeletonModificationStack2D.get_skeleton] and it's draw functions, as the [SkeletonModification2D] resource cannot draw on its own.
	DrawEditorGizmo()
}

// Implementation implements [Interface] with empty methods.
type Implementation = implementation

type implementation struct{}

func (self implementation) Execute(delta Float.X) { return }
func (self implementation) SetupModification(modification_stack SkeletonModificationStack2D.Instance) {
	return
}
func (self implementation) DrawEditorGizmo() { return }

/*
Executes the given modification. This is where the modification performs whatever function it is designed to do.
*/
func (Instance) _execute(impl func(ptr unsafe.Pointer, delta Float.X)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var delta = gd.UnsafeGet[float64](p_args, 0)
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, Float.X(delta))
	}
}

/*
Called when the modification is setup. This is where the modification performs initialization.
*/
func (Instance) _setup_modification(impl func(ptr unsafe.Pointer, modification_stack SkeletonModificationStack2D.Instance)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var modification_stack = [1]gdclass.SkeletonModificationStack2D{pointers.New[gdclass.SkeletonModificationStack2D]([3]uint64{uint64(gd.UnsafeGet[gdextension.Object](p_args, 0))})}

		defer pointers.End(modification_stack[0])
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, modification_stack)
	}
}

/*
Used for drawing [b]editor-only[/b] modification gizmos. This function will only be called in the Godot editor and can be overridden to draw custom gizmos.
[b]Note:[/b] You will need to use the Skeleton2D from [method SkeletonModificationStack2D.get_skeleton] and it's draw functions, as the [SkeletonModification2D] resource cannot draw on its own.
*/
func (Instance) _draw_editor_gizmo(impl func(ptr unsafe.Pointer)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self)
	}
}

/*
Returns the [SkeletonModificationStack2D] that this modification is bound to. Through the modification stack, you can access the Skeleton2D the modification is operating on.
*/
func (self Instance) GetModificationStack() SkeletonModificationStack2D.Instance { //gd:SkeletonModification2D.get_modification_stack
	return SkeletonModificationStack2D.Instance(Advanced(self).GetModificationStack())
}

/*
Manually allows you to set the setup state of the modification. This function should only rarely be used, as the [SkeletonModificationStack2D] the modification is bound to should handle setting the modification up.
*/
func (self Instance) SetIsSetup(is_setup bool) { //gd:SkeletonModification2D.set_is_setup
	Advanced(self).SetIsSetup(is_setup)
}

/*
Returns whether this modification has been successfully setup or not.
*/
func (self Instance) GetIsSetup() bool { //gd:SkeletonModification2D.get_is_setup
	return bool(Advanced(self).GetIsSetup())
}

/*
Takes an angle and clamps it so it is within the passed-in [param min] and [param max] range. [param invert] will inversely clamp the angle, clamping it to the range outside of the given bounds.
*/
func (self Instance) ClampAngle(angle Angle.Radians, min Angle.Radians, max Angle.Radians, invert bool) Angle.Radians { //gd:SkeletonModification2D.clamp_angle
	return Angle.Radians(Float.X(Advanced(self).ClampAngle(float64(angle), float64(min), float64(max), invert)))
}

/*
Sets whether this modification will call [method _draw_editor_gizmo] in the Godot editor to draw modification-specific gizmos.
*/
func (self Instance) SetEditorDrawGizmo(draw_gizmo bool) { //gd:SkeletonModification2D.set_editor_draw_gizmo
	Advanced(self).SetEditorDrawGizmo(draw_gizmo)
}

/*
Returns whether this modification will call [method _draw_editor_gizmo] in the Godot editor to draw modification-specific gizmos.
*/
func (self Instance) GetEditorDrawGizmo() bool { //gd:SkeletonModification2D.get_editor_draw_gizmo
	return bool(Advanced(self).GetEditorDrawGizmo())
}

/*
Adds the passed-in [SkeletonModification2D] to the stack.
*/
func (self Instance) Add(peer SkeletonModificationStack2D.Instance) { //gd:SkeletonModificationStack2D.add_modification
	SkeletonModificationStack2D.Advanced(peer).AddModification(self)
}

/*
Returns the [SkeletonModification2D] at the passed-in index, [param mod_idx].
*/
func Get(peer SkeletonModificationStack2D.Instance, mod_idx int) Instance { //gd:SkeletonModificationStack2D.get_modification
	return Instance(SkeletonModificationStack2D.Advanced(peer).GetModification(int64(mod_idx)))
}

/*
Sets the modification at [param mod_idx] to the passed-in modification, [param modification].
*/
func (self Instance) Set(peer SkeletonModificationStack2D.Instance, mod_idx int) { //gd:SkeletonModificationStack2D.set_modification
	SkeletonModificationStack2D.Advanced(peer).SetModification(int64(mod_idx), self)
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.SkeletonModification2D

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = pointers.AsA[gdclass.SkeletonModification2D](obj[0])
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = pointers.AsA[gdclass.SkeletonModification2D](obj[0])
		return true
	}
	return false
}
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }
func (self *Extension[T]) AsObject() [1]gd.Object { return self.Super().AsObject() }
func New() Instance {
	if !gd.Linked {
		var placeholder = Instance([1]gdclass.SkeletonModification2D{pointers.Add[gdclass.SkeletonModification2D]([3]uint64{})})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(pointers.AsA[gd.Object](placeholder[0]), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	casted := Instance([1]gdclass.SkeletonModification2D{pointers.New[gdclass.SkeletonModification2D]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})})
	casted.AsRefCounted()[0].InitRef()
	casted.AsObject()[0].Notification(0, false)
	return casted
}

func (self Instance) Enabled() bool {
	return bool(class(self).GetEnabled())
}

func (self Instance) SetEnabled(value bool) {
	class(self).SetEnabled(value)
}

func (self Instance) ExecutionMode() int {
	return int(int(class(self).GetExecutionMode()))
}

func (self Instance) SetExecutionMode(value int) {
	class(self).SetExecutionMode(int64(value))
}

/*
Executes the given modification. This is where the modification performs whatever function it is designed to do.
*/
func (class) _execute(impl func(ptr unsafe.Pointer, delta float64)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var delta = gd.UnsafeGet[float64](p_args, 0)
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, delta)
	}
}

/*
Called when the modification is setup. This is where the modification performs initialization.
*/
func (class) _setup_modification(impl func(ptr unsafe.Pointer, modification_stack [1]gdclass.SkeletonModificationStack2D)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var modification_stack = [1]gdclass.SkeletonModificationStack2D{pointers.New[gdclass.SkeletonModificationStack2D]([3]uint64{uint64(gd.UnsafeGet[gdextension.Object](p_args, 0))})}

		defer pointers.End(modification_stack[0])
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, modification_stack)
	}
}

/*
Used for drawing [b]editor-only[/b] modification gizmos. This function will only be called in the Godot editor and can be overridden to draw custom gizmos.
[b]Note:[/b] You will need to use the Skeleton2D from [method SkeletonModificationStack2D.get_skeleton] and it's draw functions, as the [SkeletonModification2D] resource cannot draw on its own.
*/
func (class) _draw_editor_gizmo(impl func(ptr unsafe.Pointer)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self)
	}
}

//go:nosplit
func (self class) SetEnabled(enabled bool) { //gd:SkeletonModification2D.set_enabled
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_enabled, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enabled bool }{enabled}))
}

//go:nosplit
func (self class) GetEnabled() bool { //gd:SkeletonModification2D.get_enabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.get_enabled, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the [SkeletonModificationStack2D] that this modification is bound to. Through the modification stack, you can access the Skeleton2D the modification is operating on.
*/
//go:nosplit
func (self class) GetModificationStack() [1]gdclass.SkeletonModificationStack2D { //gd:SkeletonModification2D.get_modification_stack
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_modification_stack, gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.SkeletonModificationStack2D{gd.PointerWithOwnershipTransferredToGo[gdclass.SkeletonModificationStack2D](r_ret)}
	return ret
}

/*
Manually allows you to set the setup state of the modification. This function should only rarely be used, as the [SkeletonModificationStack2D] the modification is bound to should handle setting the modification up.
*/
//go:nosplit
func (self class) SetIsSetup(is_setup bool) { //gd:SkeletonModification2D.set_is_setup
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_is_setup, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ is_setup bool }{is_setup}))
}

/*
Returns whether this modification has been successfully setup or not.
*/
//go:nosplit
func (self class) GetIsSetup() bool { //gd:SkeletonModification2D.get_is_setup
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.get_is_setup, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetExecutionMode(execution_mode int64) { //gd:SkeletonModification2D.set_execution_mode
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_execution_mode, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ execution_mode int64 }{execution_mode}))
}

//go:nosplit
func (self class) GetExecutionMode() int64 { //gd:SkeletonModification2D.get_execution_mode
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_execution_mode, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Takes an angle and clamps it so it is within the passed-in [param min] and [param max] range. [param invert] will inversely clamp the angle, clamping it to the range outside of the given bounds.
*/
//go:nosplit
func (self class) ClampAngle(angle float64, min float64, max float64, invert bool) float64 { //gd:SkeletonModification2D.clamp_angle
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.clamp_angle, gdextension.SizeFloat|(gdextension.SizeFloat<<4)|(gdextension.SizeFloat<<8)|(gdextension.SizeFloat<<12)|(gdextension.SizeBool<<16), unsafe.Pointer(&struct {
		angle  float64
		min    float64
		max    float64
		invert bool
	}{angle, min, max, invert}))
	var ret = r_ret
	return ret
}

/*
Sets whether this modification will call [method _draw_editor_gizmo] in the Godot editor to draw modification-specific gizmos.
*/
//go:nosplit
func (self class) SetEditorDrawGizmo(draw_gizmo bool) { //gd:SkeletonModification2D.set_editor_draw_gizmo
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_editor_draw_gizmo, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ draw_gizmo bool }{draw_gizmo}))
}

/*
Returns whether this modification will call [method _draw_editor_gizmo] in the Godot editor to draw modification-specific gizmos.
*/
//go:nosplit
func (self class) GetEditorDrawGizmo() bool { //gd:SkeletonModification2D.get_editor_draw_gizmo
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.get_editor_draw_gizmo, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}
func (self class) AsSkeletonModification2D() Advanced {
	return Advanced{pointers.AsA[gdclass.SkeletonModification2D](self[0])}
}
func (self Instance) AsSkeletonModification2D() Instance {
	return Instance{pointers.AsA[gdclass.SkeletonModification2D](self[0])}
}
func (self *Extension[T]) AsSkeletonModification2D() Instance {
	return self.Super().AsSkeletonModification2D()
}
func (self class) AsResource() Resource.Advanced {
	return Resource.Advanced{pointers.AsA[gdclass.Resource](self[0])}
}
func (self *Extension[T]) AsResource() Resource.Instance { return self.Super().AsResource() }
func (self Instance) AsResource() Resource.Instance {
	return Resource.Instance{pointers.AsA[gdclass.Resource](self[0])}
}
func (self class) AsRefCounted() [1]gd.RefCounted {
	return [1]gd.RefCounted{gd.RefCounted(pointers.AsA[gd.Object](self[0]))}
}
func (self *Extension[T]) AsRefCounted() [1]gd.RefCounted { return self.Super().AsRefCounted() }
func (self Instance) AsRefCounted() [1]gd.RefCounted {
	return [1]gd.RefCounted{gd.RefCounted(pointers.AsA[gd.Object](self[0]))}
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	case "_execute":
		return reflect.ValueOf(self._execute)
	case "_setup_modification":
		return reflect.ValueOf(self._setup_modification)
	case "_draw_editor_gizmo":
		return reflect.ValueOf(self._draw_editor_gizmo)
	default:
		return gd.VirtualByName(Resource.Advanced(self.AsResource()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	case "_execute":
		return reflect.ValueOf(self._execute)
	case "_setup_modification":
		return reflect.ValueOf(self._setup_modification)
	case "_draw_editor_gizmo":
		return reflect.ValueOf(self._draw_editor_gizmo)
	default:
		return gd.VirtualByName(Resource.Instance(self.AsResource()), name)
	}
}
func init() {
	gdclass.Register("SkeletonModification2D", func(ptr gd.Object) any { return Instance{pointers.AsA[gdclass.SkeletonModification2D](ptr)} })
}
