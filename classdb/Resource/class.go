// Code generated by the generate package DO NOT EDIT

// Package Resource provides methods for working with Resource object instances.
package Resource

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
Resource is the base class for all Godot-specific resource types, serving primarily as data containers. Since they inherit from [RefCounted], resources are reference-counted and freed when no longer in use. They can also be nested within other resources, and saved on disk. [PackedScene], one of the most common [Object]s in a Godot project, is also a resource, uniquely capable of storing and instantiating the [Node]s it contains as many times as desired.
In GDScript, resources can loaded from disk by their [member resource_path] using [method @GDScript.load] or [method @GDScript.preload].
The engine keeps a global cache of all loaded resources, referenced by paths (see [method ResourceLoader.has_cached]). A resource will be cached when loaded for the first time and removed from cache once all references are released. When a resource is cached, subsequent loads using its path will return the cached reference.
[b]Note:[/b] In C#, resources will not be freed instantly after they are no longer in use. Instead, garbage collection will run periodically and will free resources that are no longer in use. This means that unused resources will remain in memory for a while before being removed.

	See [Interface] for methods that can be overridden by a [Class] that extends it.
*/
type Instance [1]gdclass.Resource

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	set_path                 gdextension.MethodForClass `hash:"83702148"`
	take_over_path           gdextension.MethodForClass `hash:"83702148"`
	get_path                 gdextension.MethodForClass `hash:"201670096"`
	set_path_cache           gdextension.MethodForClass `hash:"83702148"`
	set_name                 gdextension.MethodForClass `hash:"83702148"`
	get_name                 gdextension.MethodForClass `hash:"201670096"`
	get_rid                  gdextension.MethodForClass `hash:"2944877500"`
	set_local_to_scene       gdextension.MethodForClass `hash:"2586408642"`
	is_local_to_scene        gdextension.MethodForClass `hash:"36873697"`
	get_local_scene          gdextension.MethodForClass `hash:"3160264692"`
	setup_local_to_scene     gdextension.MethodForClass `hash:"3218959716"`
	reset_state              gdextension.MethodForClass `hash:"3218959716"`
	set_id_for_path          gdextension.MethodForClass `hash:"3186203200"`
	get_id_for_path          gdextension.MethodForClass `hash:"3135753539"`
	is_built_in              gdextension.MethodForClass `hash:"36873697"`
	generate_scene_unique_id gdextension.MethodForClass `hash:"2841200299"`
	set_scene_unique_id      gdextension.MethodForClass `hash:"83702148"`
	get_scene_unique_id      gdextension.MethodForClass `hash:"201670096"`
	emit_changed             gdextension.MethodForClass `hash:"3218959716"`
	duplicate                gdextension.MethodForClass `hash:"482882304"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("Resource")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		pointers.Raw[gd.StringName](sname).Free()
	})
}

type Expanded [1]gdclass.Resource

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsResource() Instance
}
type Interface interface {
	//Override this method to customize the newly duplicated resource created from [method PackedScene.instantiate], if the original's [member resource_local_to_scene] is set to [code]true[/code].
	//[b]Example:[/b] Set a random [code]damage[/code] value to every local resource from an instantiated scene:
	//[codeblock]
	//extends Resource
	//
	//var damage = 0
	//
	//func _setup_local_to_scene():
	//    damage = randi_range(10, 40)
	//[/codeblock]
	SetupLocalToScene()
	//Override this method to return a custom [RID] when [method get_rid] is called.
	GetRid() ID
	//For resources that use a variable number of properties, either via [method Object._validate_property] or [method Object._get_property_list], this method should be implemented to correctly clear the resource's state.
	ResetState()
	//Sets the resource's path to [param path] without involving the resource cache.
	SetPathCache(path string)
}

// Implementation implements [Interface] with empty methods.
type Implementation = implementation

type implementation struct{}

func (self implementation) SetupLocalToScene()       { return }
func (self implementation) GetRid() (_ ID)           { return }
func (self implementation) ResetState()              { return }
func (self implementation) SetPathCache(path string) { return }

/*
Override this method to customize the newly duplicated resource created from [method PackedScene.instantiate], if the original's [member resource_local_to_scene] is set to [code]true[/code].
[b]Example:[/b] Set a random [code]damage[/code] value to every local resource from an instantiated scene:
[codeblock]
extends Resource

var damage = 0

func _setup_local_to_scene():

	damage = randi_range(10, 40)

[/codeblock]
*/
func (Instance) _setup_local_to_scene(impl func(ptr unsafe.Pointer)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self)
	}
}

/*
Override this method to return a custom [RID] when [method get_rid] is called.
*/
func (Instance) _get_rid(impl func(ptr unsafe.Pointer) ID) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		gd.UnsafeSet(p_back, RID.Any(ret))
	}
}

/*
For resources that use a variable number of properties, either via [method Object._validate_property] or [method Object._get_property_list], this method should be implemented to correctly clear the resource's state.
*/
func (Instance) _reset_state(impl func(ptr unsafe.Pointer)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self)
	}
}

/*
Sets the resource's path to [param path] without involving the resource cache.
*/
func (Instance) _set_path_cache(impl func(ptr unsafe.Pointer, path string)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var path = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](gd.UnsafeGet[gdextension.String](p_args, 0))))
		defer pointers.End(gd.InternalString(path))
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, path.String())
	}
}

/*
Sets the [member resource_path] to [param path], potentially overriding an existing cache entry for this path. Further attempts to load an overridden resource by path will instead return this resource.
*/
func (self Instance) TakeOverPath(path string) { //gd:Resource.take_over_path
	Advanced(self).TakeOverPath(String.New(path))
}

/*
Sets the resource's path to [param path] without involving the resource cache.
*/
func (self Instance) SetPathCache(path string) { //gd:Resource.set_path_cache
	Advanced(self).SetPathCache(String.New(path))
}

/*
Returns the [RID] of this resource (or an empty RID). Many resources (such as [Texture2D], [Mesh], and so on) are high-level abstractions of resources stored in a specialized server ([DisplayServer], [RenderingServer], etc.), so this function will return the original [RID].
*/
func (self Instance) GetRid() ID { //gd:Resource.get_rid
	return ID(Advanced(self).GetRid())
}

/*
Calls [method _setup_local_to_scene]. If [member resource_local_to_scene] is set to [code]true[/code], this method is automatically called from [method PackedScene.instantiate] by the newly duplicated resource within the scene instance.
*/
func (self Instance) SetupLocalToScene() { //gd:Resource.setup_local_to_scene
	Advanced(self).SetupLocalToScene()
}

/*
For resources that use a variable number of properties, either via [method Object._validate_property] or [method Object._get_property_list], override [method _reset_state] to correctly clear the resource's state.
*/
func (self Instance) ResetState() { //gd:Resource.reset_state
	Advanced(self).ResetState()
}

/*
Sets the unique identifier to [param id] for the resource with the given [param path] in the resource cache. If the unique identifier is empty, the cache entry using [param path] is removed if it exists.
[b]Note:[/b] This method is only implemented when running in an editor context.
*/
func (self Instance) SetIdForPath(path string, id string) { //gd:Resource.set_id_for_path
	Advanced(self).SetIdForPath(String.New(path), String.New(id))
}

/*
Returns the unique identifier for the resource with the given [param path] from the resource cache. If the resource is not loaded and cached, an empty string is returned.
[b]Note:[/b] This method is only implemented when running in an editor context. At runtime, it returns an empty string.
*/
func (self Instance) GetIdForPath(path string) string { //gd:Resource.get_id_for_path
	return string(Advanced(self).GetIdForPath(String.New(path)).String())
}

/*
Returns [code]true[/code] if the resource is built-in (from the engine) or [code]false[/code] if it is user-defined.
*/
func (self Instance) IsBuiltIn() bool { //gd:Resource.is_built_in
	return bool(Advanced(self).IsBuiltIn())
}

/*
Generates a unique identifier for a resource to be contained inside a [PackedScene], based on the current date, time, and a random value. The returned string is only composed of letters ([code]a[/code] to [code]y[/code]) and numbers ([code]0[/code] to [code]8[/code]). See also [member resource_scene_unique_id].
*/
func GenerateSceneUniqueId() string { //gd:Resource.generate_scene_unique_id
	self := Instance{}
	return string(Advanced(self).GenerateSceneUniqueId().String())
}

/*
Emits the [signal changed] signal. This method is called automatically for some built-in resources.
[b]Note:[/b] For custom resources, it's recommended to call this method whenever a meaningful change occurs, such as a modified property. This ensures that custom [Object]s depending on the resource are properly updated.
[codeblock]
var damage:

	set(new_value):
	    if damage != new_value:
	        damage = new_value
	        emit_changed()

[/codeblock]
*/
func (self Instance) EmitChanged() { //gd:Resource.emit_changed
	Advanced(self).EmitChanged()
}

/*
Duplicates this resource, returning a new resource with its [code]export[/code]ed or [constant PROPERTY_USAGE_STORAGE] properties copied from the original.
If [param subresources] is [code]false[/code], a shallow copy is returned; nested resources within subresources are not duplicated and are shared with the original resource (with one exception; see below). If [param subresources] is [code]true[/code], a deep copy is returned; nested subresources will be duplicated and are not shared (with two exceptions; see below).
[param subresources] is usually respected, with the following exceptions:
- Subresource properties with the [constant PROPERTY_USAGE_ALWAYS_DUPLICATE] flag are always duplicated.
- Subresource properties with the [constant PROPERTY_USAGE_NEVER_DUPLICATE] flag are never duplicated.
- Subresources inside [Array] and [Dictionary] properties are never duplicated.
[b]Note:[/b] For custom resources, this method will fail if [method Object._init] has been defined with required parameters.
*/
func (self Instance) Duplicate() Instance { //gd:Resource.duplicate
	return Instance(Advanced(self).Duplicate(false))
}

/*
Duplicates this resource, returning a new resource with its [code]export[/code]ed or [constant PROPERTY_USAGE_STORAGE] properties copied from the original.
If [param subresources] is [code]false[/code], a shallow copy is returned; nested resources within subresources are not duplicated and are shared with the original resource (with one exception; see below). If [param subresources] is [code]true[/code], a deep copy is returned; nested subresources will be duplicated and are not shared (with two exceptions; see below).
[param subresources] is usually respected, with the following exceptions:
- Subresource properties with the [constant PROPERTY_USAGE_ALWAYS_DUPLICATE] flag are always duplicated.
- Subresource properties with the [constant PROPERTY_USAGE_NEVER_DUPLICATE] flag are never duplicated.
- Subresources inside [Array] and [Dictionary] properties are never duplicated.
[b]Note:[/b] For custom resources, this method will fail if [method Object._init] has been defined with required parameters.
*/
func (self Expanded) Duplicate(subresources bool) Instance { //gd:Resource.duplicate
	return Instance(Advanced(self).Duplicate(subresources))
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.Resource

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.Resource)(unsafe.Pointer(&obj))
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.Resource)(unsafe.Pointer(&obj))
		return true
	}
	return false
}

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {
	object := [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})}
	casted := Instance{*(*gdclass.Resource)(unsafe.Pointer(&object))}
	casted.AsRefCounted()[0].Reference()
	object[0].Notification(0, false)
	return casted
}

func (self Instance) ResourceLocalToScene() bool {
	return bool(class(self).IsLocalToScene())
}

func (self Instance) SetResourceLocalToScene(value bool) {
	class(self).SetLocalToScene(value)
}

func (self Instance) ResourcePath() string {
	return string(class(self).GetPath().String())
}

func (self Instance) SetResourcePath(value string) {
	class(self).SetPath(String.New(value))
}

func (self Instance) ResourceName() string {
	return string(class(self).GetName().String())
}

func (self Instance) SetResourceName(value string) {
	class(self).SetName(String.New(value))
}

func (self Instance) ResourceSceneUniqueId() string {
	return string(class(self).GetSceneUniqueId().String())
}

func (self Instance) SetResourceSceneUniqueId(value string) {
	class(self).SetSceneUniqueId(String.New(value))
}

/*
Override this method to customize the newly duplicated resource created from [method PackedScene.instantiate], if the original's [member resource_local_to_scene] is set to [code]true[/code].
[b]Example:[/b] Set a random [code]damage[/code] value to every local resource from an instantiated scene:
[codeblock]
extends Resource

var damage = 0

func _setup_local_to_scene():

	damage = randi_range(10, 40)

[/codeblock]
*/
func (class) _setup_local_to_scene(impl func(ptr unsafe.Pointer)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self)
	}
}

/*
Override this method to return a custom [RID] when [method get_rid] is called.
*/
func (class) _get_rid(impl func(ptr unsafe.Pointer) RID.Any) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		gd.UnsafeSet(p_back, ret)
	}
}

/*
For resources that use a variable number of properties, either via [method Object._validate_property] or [method Object._get_property_list], this method should be implemented to correctly clear the resource's state.
*/
func (class) _reset_state(impl func(ptr unsafe.Pointer)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self)
	}
}

/*
Sets the resource's path to [param path] without involving the resource cache.
*/
func (class) _set_path_cache(impl func(ptr unsafe.Pointer, path String.Readable)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var path = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](gd.UnsafeGet[gdextension.String](p_args, 0))))
		defer pointers.End(gd.InternalString(path))
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, path)
	}
}

//go:nosplit
func (self class) SetPath(path String.Readable) { //gd:Resource.set_path
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_path, 0|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ path gdextension.String }{pointers.Get(gd.InternalString(path))}))
}

/*
Sets the [member resource_path] to [param path], potentially overriding an existing cache entry for this path. Further attempts to load an overridden resource by path will instead return this resource.
*/
//go:nosplit
func (self class) TakeOverPath(path String.Readable) { //gd:Resource.take_over_path
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.take_over_path, 0|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ path gdextension.String }{pointers.Get(gd.InternalString(path))}))
}

//go:nosplit
func (self class) GetPath() String.Readable { //gd:Resource.get_path
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_path, gdextension.SizeString, unsafe.Pointer(&struct{}{}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Sets the resource's path to [param path] without involving the resource cache.
*/
//go:nosplit
func (self class) SetPathCache(path String.Readable) { //gd:Resource.set_path_cache
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_path_cache, 0|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ path gdextension.String }{pointers.Get(gd.InternalString(path))}))
}

//go:nosplit
func (self class) SetName(name String.Readable) { //gd:Resource.set_name
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_name, 0|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ name gdextension.String }{pointers.Get(gd.InternalString(name))}))
}

//go:nosplit
func (self class) GetName() String.Readable { //gd:Resource.get_name
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_name, gdextension.SizeString, unsafe.Pointer(&struct{}{}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Returns the [RID] of this resource (or an empty RID). Many resources (such as [Texture2D], [Mesh], and so on) are high-level abstractions of resources stored in a specialized server ([DisplayServer], [RenderingServer], etc.), so this function will return the original [RID].
*/
//go:nosplit
func (self class) GetRid() RID.Any { //gd:Resource.get_rid
	var r_ret = gdextension.Call[RID.Any](gd.ObjectChecked(self.AsObject()), methods.get_rid, gdextension.SizeRID, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetLocalToScene(enable bool) { //gd:Resource.set_local_to_scene
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_local_to_scene, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

//go:nosplit
func (self class) IsLocalToScene() bool { //gd:Resource.is_local_to_scene
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_local_to_scene, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
If [member resource_local_to_scene] is set to [code]true[/code] and the resource has been loaded from a [PackedScene] instantiation, returns the root [Node] of the scene where this resource is used. Otherwise, returns [code]null[/code].
*/
//go:nosplit
func (self class) GetLocalScene() [1]gdclass.Node { //gd:Resource.get_local_scene
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_local_scene, gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.Node{gd.PointerMustAssertInstanceID[gdclass.Node](r_ret)}
	return ret
}

/*
Calls [method _setup_local_to_scene]. If [member resource_local_to_scene] is set to [code]true[/code], this method is automatically called from [method PackedScene.instantiate] by the newly duplicated resource within the scene instance.
*/
//go:nosplit
func (self class) SetupLocalToScene() { //gd:Resource.setup_local_to_scene
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.setup_local_to_scene, 0, unsafe.Pointer(&struct{}{}))
}

/*
For resources that use a variable number of properties, either via [method Object._validate_property] or [method Object._get_property_list], override [method _reset_state] to correctly clear the resource's state.
*/
//go:nosplit
func (self class) ResetState() { //gd:Resource.reset_state
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.reset_state, 0, unsafe.Pointer(&struct{}{}))
}

/*
Sets the unique identifier to [param id] for the resource with the given [param path] in the resource cache. If the unique identifier is empty, the cache entry using [param path] is removed if it exists.
[b]Note:[/b] This method is only implemented when running in an editor context.
*/
//go:nosplit
func (self class) SetIdForPath(path String.Readable, id String.Readable) { //gd:Resource.set_id_for_path
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_id_for_path, 0|(gdextension.SizeString<<4)|(gdextension.SizeString<<8), unsafe.Pointer(&struct {
		path gdextension.String
		id   gdextension.String
	}{pointers.Get(gd.InternalString(path)), pointers.Get(gd.InternalString(id))}))
}

/*
Returns the unique identifier for the resource with the given [param path] from the resource cache. If the resource is not loaded and cached, an empty string is returned.
[b]Note:[/b] This method is only implemented when running in an editor context. At runtime, it returns an empty string.
*/
//go:nosplit
func (self class) GetIdForPath(path String.Readable) String.Readable { //gd:Resource.get_id_for_path
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_id_for_path, gdextension.SizeString|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ path gdextension.String }{pointers.Get(gd.InternalString(path))}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Returns [code]true[/code] if the resource is built-in (from the engine) or [code]false[/code] if it is user-defined.
*/
//go:nosplit
func (self class) IsBuiltIn() bool { //gd:Resource.is_built_in
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_built_in, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Generates a unique identifier for a resource to be contained inside a [PackedScene], based on the current date, time, and a random value. The returned string is only composed of letters ([code]a[/code] to [code]y[/code]) and numbers ([code]0[/code] to [code]8[/code]). See also [member resource_scene_unique_id].
*/
//go:nosplit
func (self class) GenerateSceneUniqueId() String.Readable { //gd:Resource.generate_scene_unique_id
	var r_ret = gdextension.CallStatic[gdextension.String](methods.generate_scene_unique_id, gdextension.SizeString, unsafe.Pointer(&struct{}{}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

//go:nosplit
func (self class) SetSceneUniqueId(id String.Readable) { //gd:Resource.set_scene_unique_id
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_scene_unique_id, 0|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ id gdextension.String }{pointers.Get(gd.InternalString(id))}))
}

//go:nosplit
func (self class) GetSceneUniqueId() String.Readable { //gd:Resource.get_scene_unique_id
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_scene_unique_id, gdextension.SizeString, unsafe.Pointer(&struct{}{}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Emits the [signal changed] signal. This method is called automatically for some built-in resources.
[b]Note:[/b] For custom resources, it's recommended to call this method whenever a meaningful change occurs, such as a modified property. This ensures that custom [Object]s depending on the resource are properly updated.
[codeblock]
var damage:
    set(new_value):
        if damage != new_value:
            damage = new_value
            emit_changed()
[/codeblock]
*/
//go:nosplit
func (self class) EmitChanged() { //gd:Resource.emit_changed
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.emit_changed, 0, unsafe.Pointer(&struct{}{}))
}

/*
Duplicates this resource, returning a new resource with its [code]export[/code]ed or [constant PROPERTY_USAGE_STORAGE] properties copied from the original.
If [param subresources] is [code]false[/code], a shallow copy is returned; nested resources within subresources are not duplicated and are shared with the original resource (with one exception; see below). If [param subresources] is [code]true[/code], a deep copy is returned; nested subresources will be duplicated and are not shared (with two exceptions; see below).
[param subresources] is usually respected, with the following exceptions:
- Subresource properties with the [constant PROPERTY_USAGE_ALWAYS_DUPLICATE] flag are always duplicated.
- Subresource properties with the [constant PROPERTY_USAGE_NEVER_DUPLICATE] flag are never duplicated.
- Subresources inside [Array] and [Dictionary] properties are never duplicated.
[b]Note:[/b] For custom resources, this method will fail if [method Object._init] has been defined with required parameters.
*/
//go:nosplit
func (self class) Duplicate(subresources bool) [1]gdclass.Resource { //gd:Resource.duplicate
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.duplicate, gdextension.SizeObject|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ subresources bool }{subresources}))
	var ret = [1]gdclass.Resource{gd.PointerWithOwnershipTransferredToGo[gdclass.Resource](r_ret)}
	return ret
}
func (self Instance) OnChanged(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("changed"), gd.NewCallable(cb), 0)
}

func (self Instance) OnSetupLocalToSceneRequested(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("setup_local_to_scene_requested"), gd.NewCallable(cb), 0)
}

func (self class) AsResource() Advanced         { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsResource() Instance      { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsResource() Instance { return self.Super().AsResource() }
func (self class) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsRefCounted() [1]gd.RefCounted { return self.Super().AsRefCounted() }
func (self Instance) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	case "_setup_local_to_scene":
		return reflect.ValueOf(self._setup_local_to_scene)
	case "_get_rid":
		return reflect.ValueOf(self._get_rid)
	case "_reset_state":
		return reflect.ValueOf(self._reset_state)
	case "_set_path_cache":
		return reflect.ValueOf(self._set_path_cache)
	default:
		return gd.VirtualByName(RefCounted.Advanced(self.AsRefCounted()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	case "_setup_local_to_scene":
		return reflect.ValueOf(self._setup_local_to_scene)
	case "_get_rid":
		return reflect.ValueOf(self._get_rid)
	case "_reset_state":
		return reflect.ValueOf(self._reset_state)
	case "_set_path_cache":
		return reflect.ValueOf(self._set_path_cache)
	default:
		return gd.VirtualByName(RefCounted.Instance(self.AsRefCounted()), name)
	}
}
func init() {
	gdclass.Register("Resource", func(ptr gd.Object) any { return *(*Instance)(unsafe.Pointer(&ptr)) })
}
