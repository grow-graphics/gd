// Code generated by the generate package DO NOT EDIT

// Package LightmapGI provides methods for working with LightmapGI object instances.
package LightmapGI

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/CameraAttributes"
import "graphics.gd/classdb/LightmapGIData"
import "graphics.gd/classdb/Node"
import "graphics.gd/classdb/Node3D"
import "graphics.gd/classdb/Sky"
import "graphics.gd/classdb/VisualInstance3D"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Color"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
The [LightmapGI] node is used to compute and store baked lightmaps. Lightmaps are used to provide high-quality indirect lighting with very little light leaking. [LightmapGI] can also provide rough reflections using spherical harmonics if [member directional] is enabled. Dynamic objects can receive indirect lighting thanks to [i]light probes[/i], which can be automatically placed by setting [member generate_probes_subdiv] to a value other than [constant GENERATE_PROBES_DISABLED]. Additional lightmap probes can also be added by creating [LightmapProbe] nodes. The downside is that lightmaps are fully static and cannot be baked in an exported project. Baking a [LightmapGI] node is also slower compared to [VoxelGI].
[b]Procedural generation:[/b] Lightmap baking functionality is only available in the editor. This means [LightmapGI] is not suited to procedurally generated or user-built levels. For procedurally generated or user-built levels, use [VoxelGI] or SDFGI instead (see [member Environment.sdfgi_enabled]).
[b]Performance:[/b] [LightmapGI] provides the best possible run-time performance for global illumination. It is suitable for low-end hardware including integrated graphics and mobile devices.
[b]Note:[/b] Due to how lightmaps work, most properties only have a visible effect once lightmaps are baked again.
[b]Note:[/b] Lightmap baking on [CSGShape3D]s and [PrimitiveMesh]es is not supported, as these cannot store UV2 data required for baking.
[b]Note:[/b] If no custom lightmappers are installed, [LightmapGI] can only be baked from devices that support the Forward+ or Mobile renderers.
[b]Note:[/b] The [LightmapGI] node only bakes light data for child nodes of its parent. Nodes further up the hierarchy of the scene will not be baked.
*/
type Instance [1]gdclass.LightmapGI

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	set_light_data                gdextension.MethodForClass `hash:"1790597277"`
	get_light_data                gdextension.MethodForClass `hash:"290354153"`
	set_bake_quality              gdextension.MethodForClass `hash:"1192215803"`
	get_bake_quality              gdextension.MethodForClass `hash:"688832735"`
	set_bounces                   gdextension.MethodForClass `hash:"1286410249"`
	get_bounces                   gdextension.MethodForClass `hash:"3905245786"`
	set_bounce_indirect_energy    gdextension.MethodForClass `hash:"373806689"`
	get_bounce_indirect_energy    gdextension.MethodForClass `hash:"1740695150"`
	set_generate_probes           gdextension.MethodForClass `hash:"549981046"`
	get_generate_probes           gdextension.MethodForClass `hash:"3930596226"`
	set_bias                      gdextension.MethodForClass `hash:"373806689"`
	get_bias                      gdextension.MethodForClass `hash:"1740695150"`
	set_environment_mode          gdextension.MethodForClass `hash:"2282650285"`
	get_environment_mode          gdextension.MethodForClass `hash:"4128646479"`
	set_environment_custom_sky    gdextension.MethodForClass `hash:"3336722921"`
	get_environment_custom_sky    gdextension.MethodForClass `hash:"1177136966"`
	set_environment_custom_color  gdextension.MethodForClass `hash:"2920490490"`
	get_environment_custom_color  gdextension.MethodForClass `hash:"3444240500"`
	set_environment_custom_energy gdextension.MethodForClass `hash:"373806689"`
	get_environment_custom_energy gdextension.MethodForClass `hash:"1740695150"`
	set_texel_scale               gdextension.MethodForClass `hash:"373806689"`
	get_texel_scale               gdextension.MethodForClass `hash:"1740695150"`
	set_max_texture_size          gdextension.MethodForClass `hash:"1286410249"`
	get_max_texture_size          gdextension.MethodForClass `hash:"3905245786"`
	set_supersampling_enabled     gdextension.MethodForClass `hash:"2586408642"`
	is_supersampling_enabled      gdextension.MethodForClass `hash:"36873697"`
	set_supersampling_factor      gdextension.MethodForClass `hash:"373806689"`
	get_supersampling_factor      gdextension.MethodForClass `hash:"1740695150"`
	set_use_denoiser              gdextension.MethodForClass `hash:"2586408642"`
	is_using_denoiser             gdextension.MethodForClass `hash:"36873697"`
	set_denoiser_strength         gdextension.MethodForClass `hash:"373806689"`
	get_denoiser_strength         gdextension.MethodForClass `hash:"1740695150"`
	set_denoiser_range            gdextension.MethodForClass `hash:"1286410249"`
	get_denoiser_range            gdextension.MethodForClass `hash:"3905245786"`
	set_interior                  gdextension.MethodForClass `hash:"2586408642"`
	is_interior                   gdextension.MethodForClass `hash:"36873697"`
	set_directional               gdextension.MethodForClass `hash:"2586408642"`
	is_directional                gdextension.MethodForClass `hash:"36873697"`
	set_shadowmask_mode           gdextension.MethodForClass `hash:"3451066572"`
	get_shadowmask_mode           gdextension.MethodForClass `hash:"785478560"`
	set_use_texture_for_bounces   gdextension.MethodForClass `hash:"2586408642"`
	is_using_texture_for_bounces  gdextension.MethodForClass `hash:"36873697"`
	set_camera_attributes         gdextension.MethodForClass `hash:"2817810567"`
	get_camera_attributes         gdextension.MethodForClass `hash:"3921283215"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("LightmapGI")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		pointers.Raw[gd.StringName](sname).Free()
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsLightmapGI() Instance
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.LightmapGI

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.LightmapGI)(unsafe.Pointer(&obj))
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.LightmapGI)(unsafe.Pointer(&obj))
		return true
	}
	return false
}

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {
	object := [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})}
	casted := Instance{*(*gdclass.LightmapGI)(unsafe.Pointer(&object))}
	object[0].Notification(0, false)
	return casted
}

func (self Instance) Quality() BakeQuality {
	return BakeQuality(class(self).GetBakeQuality())
}

func (self Instance) SetQuality(value BakeQuality) {
	class(self).SetBakeQuality(value)
}

func (self Instance) Supersampling() bool {
	return bool(class(self).IsSupersamplingEnabled())
}

func (self Instance) SetSupersampling(value bool) {
	class(self).SetSupersamplingEnabled(value)
}

func (self Instance) SupersamplingFactor() Float.X {
	return Float.X(Float.X(class(self).GetSupersamplingFactor()))
}

func (self Instance) SetSupersamplingFactor(value Float.X) {
	class(self).SetSupersamplingFactor(float64(value))
}

func (self Instance) Bounces() int {
	return int(int(class(self).GetBounces()))
}

func (self Instance) SetBounces(value int) {
	class(self).SetBounces(int64(value))
}

func (self Instance) BounceIndirectEnergy() Float.X {
	return Float.X(Float.X(class(self).GetBounceIndirectEnergy()))
}

func (self Instance) SetBounceIndirectEnergy(value Float.X) {
	class(self).SetBounceIndirectEnergy(float64(value))
}

func (self Instance) Directional() bool {
	return bool(class(self).IsDirectional())
}

func (self Instance) SetDirectional(value bool) {
	class(self).SetDirectional(value)
}

func (self Instance) ShadowmaskMode() LightmapGIData.ShadowmaskMode {
	return LightmapGIData.ShadowmaskMode(class(self).GetShadowmaskMode())
}

func (self Instance) SetShadowmaskMode(value LightmapGIData.ShadowmaskMode) {
	class(self).SetShadowmaskMode(value)
}

func (self Instance) UseTextureForBounces() bool {
	return bool(class(self).IsUsingTextureForBounces())
}

func (self Instance) SetUseTextureForBounces(value bool) {
	class(self).SetUseTextureForBounces(value)
}

func (self Instance) Interior() bool {
	return bool(class(self).IsInterior())
}

func (self Instance) SetInterior(value bool) {
	class(self).SetInterior(value)
}

func (self Instance) UseDenoiser() bool {
	return bool(class(self).IsUsingDenoiser())
}

func (self Instance) SetUseDenoiser(value bool) {
	class(self).SetUseDenoiser(value)
}

func (self Instance) DenoiserStrength() Float.X {
	return Float.X(Float.X(class(self).GetDenoiserStrength()))
}

func (self Instance) SetDenoiserStrength(value Float.X) {
	class(self).SetDenoiserStrength(float64(value))
}

func (self Instance) DenoiserRange() int {
	return int(int(class(self).GetDenoiserRange()))
}

func (self Instance) SetDenoiserRange(value int) {
	class(self).SetDenoiserRange(int64(value))
}

func (self Instance) Bias() Float.X {
	return Float.X(Float.X(class(self).GetBias()))
}

func (self Instance) SetBias(value Float.X) {
	class(self).SetBias(float64(value))
}

func (self Instance) TexelScale() Float.X {
	return Float.X(Float.X(class(self).GetTexelScale()))
}

func (self Instance) SetTexelScale(value Float.X) {
	class(self).SetTexelScale(float64(value))
}

func (self Instance) MaxTextureSize() int {
	return int(int(class(self).GetMaxTextureSize()))
}

func (self Instance) SetMaxTextureSize(value int) {
	class(self).SetMaxTextureSize(int64(value))
}

func (self Instance) EnvironmentMode() EnvironmentMode {
	return EnvironmentMode(class(self).GetEnvironmentMode())
}

func (self Instance) SetEnvironmentMode(value EnvironmentMode) {
	class(self).SetEnvironmentMode(value)
}

func (self Instance) EnvironmentCustomSky() Sky.Instance {
	return Sky.Instance(class(self).GetEnvironmentCustomSky())
}

func (self Instance) SetEnvironmentCustomSky(value Sky.Instance) {
	class(self).SetEnvironmentCustomSky(value)
}

func (self Instance) EnvironmentCustomColor() Color.RGBA {
	return Color.RGBA(class(self).GetEnvironmentCustomColor())
}

func (self Instance) SetEnvironmentCustomColor(value Color.RGBA) {
	class(self).SetEnvironmentCustomColor(Color.RGBA(value))
}

func (self Instance) EnvironmentCustomEnergy() Float.X {
	return Float.X(Float.X(class(self).GetEnvironmentCustomEnergy()))
}

func (self Instance) SetEnvironmentCustomEnergy(value Float.X) {
	class(self).SetEnvironmentCustomEnergy(float64(value))
}

func (self Instance) CameraAttributes() CameraAttributes.Instance {
	return CameraAttributes.Instance(class(self).GetCameraAttributes())
}

func (self Instance) SetCameraAttributes(value CameraAttributes.Instance) {
	class(self).SetCameraAttributes(value)
}

func (self Instance) GenerateProbesSubdiv() GenerateProbes {
	return GenerateProbes(class(self).GetGenerateProbes())
}

func (self Instance) SetGenerateProbesSubdiv(value GenerateProbes) {
	class(self).SetGenerateProbes(value)
}

func (self Instance) LightData() LightmapGIData.Instance {
	return LightmapGIData.Instance(class(self).GetLightData())
}

func (self Instance) SetLightData(value LightmapGIData.Instance) {
	class(self).SetLightData(value)
}

//go:nosplit
func (self class) SetLightData(data [1]gdclass.LightmapGIData) { //gd:LightmapGI.set_light_data
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_light_data, 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ data gdextension.Object }{gdextension.Object(gd.ObjectChecked(data[0].AsObject()))}))
}

//go:nosplit
func (self class) GetLightData() [1]gdclass.LightmapGIData { //gd:LightmapGI.get_light_data
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_light_data, gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.LightmapGIData{gd.PointerWithOwnershipTransferredToGo[gdclass.LightmapGIData](r_ret)}
	return ret
}

//go:nosplit
func (self class) SetBakeQuality(bake_quality BakeQuality) { //gd:LightmapGI.set_bake_quality
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_bake_quality, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ bake_quality BakeQuality }{bake_quality}))
}

//go:nosplit
func (self class) GetBakeQuality() BakeQuality { //gd:LightmapGI.get_bake_quality
	var r_ret = gdextension.Call[BakeQuality](gd.ObjectChecked(self.AsObject()), methods.get_bake_quality, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetBounces(bounces int64) { //gd:LightmapGI.set_bounces
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_bounces, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ bounces int64 }{bounces}))
}

//go:nosplit
func (self class) GetBounces() int64 { //gd:LightmapGI.get_bounces
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_bounces, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetBounceIndirectEnergy(bounce_indirect_energy float64) { //gd:LightmapGI.set_bounce_indirect_energy
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_bounce_indirect_energy, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ bounce_indirect_energy float64 }{bounce_indirect_energy}))
}

//go:nosplit
func (self class) GetBounceIndirectEnergy() float64 { //gd:LightmapGI.get_bounce_indirect_energy
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_bounce_indirect_energy, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetGenerateProbes(subdivision GenerateProbes) { //gd:LightmapGI.set_generate_probes
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_generate_probes, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ subdivision GenerateProbes }{subdivision}))
}

//go:nosplit
func (self class) GetGenerateProbes() GenerateProbes { //gd:LightmapGI.get_generate_probes
	var r_ret = gdextension.Call[GenerateProbes](gd.ObjectChecked(self.AsObject()), methods.get_generate_probes, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetBias(bias float64) { //gd:LightmapGI.set_bias
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_bias, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ bias float64 }{bias}))
}

//go:nosplit
func (self class) GetBias() float64 { //gd:LightmapGI.get_bias
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_bias, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetEnvironmentMode(mode EnvironmentMode) { //gd:LightmapGI.set_environment_mode
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_environment_mode, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ mode EnvironmentMode }{mode}))
}

//go:nosplit
func (self class) GetEnvironmentMode() EnvironmentMode { //gd:LightmapGI.get_environment_mode
	var r_ret = gdextension.Call[EnvironmentMode](gd.ObjectChecked(self.AsObject()), methods.get_environment_mode, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetEnvironmentCustomSky(sky [1]gdclass.Sky) { //gd:LightmapGI.set_environment_custom_sky
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_environment_custom_sky, 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ sky gdextension.Object }{gdextension.Object(gd.ObjectChecked(sky[0].AsObject()))}))
}

//go:nosplit
func (self class) GetEnvironmentCustomSky() [1]gdclass.Sky { //gd:LightmapGI.get_environment_custom_sky
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_environment_custom_sky, gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.Sky{gd.PointerWithOwnershipTransferredToGo[gdclass.Sky](r_ret)}
	return ret
}

//go:nosplit
func (self class) SetEnvironmentCustomColor(color Color.RGBA) { //gd:LightmapGI.set_environment_custom_color
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_environment_custom_color, 0|(gdextension.SizeColor<<4), unsafe.Pointer(&struct{ color Color.RGBA }{color}))
}

//go:nosplit
func (self class) GetEnvironmentCustomColor() Color.RGBA { //gd:LightmapGI.get_environment_custom_color
	var r_ret = gdextension.Call[Color.RGBA](gd.ObjectChecked(self.AsObject()), methods.get_environment_custom_color, gdextension.SizeColor, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetEnvironmentCustomEnergy(energy float64) { //gd:LightmapGI.set_environment_custom_energy
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_environment_custom_energy, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ energy float64 }{energy}))
}

//go:nosplit
func (self class) GetEnvironmentCustomEnergy() float64 { //gd:LightmapGI.get_environment_custom_energy
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_environment_custom_energy, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetTexelScale(texel_scale float64) { //gd:LightmapGI.set_texel_scale
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_texel_scale, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ texel_scale float64 }{texel_scale}))
}

//go:nosplit
func (self class) GetTexelScale() float64 { //gd:LightmapGI.get_texel_scale
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_texel_scale, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetMaxTextureSize(max_texture_size int64) { //gd:LightmapGI.set_max_texture_size
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_max_texture_size, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ max_texture_size int64 }{max_texture_size}))
}

//go:nosplit
func (self class) GetMaxTextureSize() int64 { //gd:LightmapGI.get_max_texture_size
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_max_texture_size, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetSupersamplingEnabled(enable bool) { //gd:LightmapGI.set_supersampling_enabled
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_supersampling_enabled, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

//go:nosplit
func (self class) IsSupersamplingEnabled() bool { //gd:LightmapGI.is_supersampling_enabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_supersampling_enabled, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetSupersamplingFactor(factor float64) { //gd:LightmapGI.set_supersampling_factor
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_supersampling_factor, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ factor float64 }{factor}))
}

//go:nosplit
func (self class) GetSupersamplingFactor() float64 { //gd:LightmapGI.get_supersampling_factor
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_supersampling_factor, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetUseDenoiser(use_denoiser bool) { //gd:LightmapGI.set_use_denoiser
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_use_denoiser, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ use_denoiser bool }{use_denoiser}))
}

//go:nosplit
func (self class) IsUsingDenoiser() bool { //gd:LightmapGI.is_using_denoiser
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_using_denoiser, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetDenoiserStrength(denoiser_strength float64) { //gd:LightmapGI.set_denoiser_strength
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_denoiser_strength, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ denoiser_strength float64 }{denoiser_strength}))
}

//go:nosplit
func (self class) GetDenoiserStrength() float64 { //gd:LightmapGI.get_denoiser_strength
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_denoiser_strength, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetDenoiserRange(denoiser_range int64) { //gd:LightmapGI.set_denoiser_range
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_denoiser_range, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ denoiser_range int64 }{denoiser_range}))
}

//go:nosplit
func (self class) GetDenoiserRange() int64 { //gd:LightmapGI.get_denoiser_range
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_denoiser_range, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetInterior(enable bool) { //gd:LightmapGI.set_interior
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_interior, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

//go:nosplit
func (self class) IsInterior() bool { //gd:LightmapGI.is_interior
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_interior, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetDirectional(directional bool) { //gd:LightmapGI.set_directional
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_directional, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ directional bool }{directional}))
}

//go:nosplit
func (self class) IsDirectional() bool { //gd:LightmapGI.is_directional
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_directional, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetShadowmaskMode(mode LightmapGIData.ShadowmaskMode) { //gd:LightmapGI.set_shadowmask_mode
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_shadowmask_mode, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ mode LightmapGIData.ShadowmaskMode }{mode}))
}

//go:nosplit
func (self class) GetShadowmaskMode() LightmapGIData.ShadowmaskMode { //gd:LightmapGI.get_shadowmask_mode
	var r_ret = gdextension.Call[LightmapGIData.ShadowmaskMode](gd.ObjectChecked(self.AsObject()), methods.get_shadowmask_mode, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetUseTextureForBounces(use_texture_for_bounces bool) { //gd:LightmapGI.set_use_texture_for_bounces
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_use_texture_for_bounces, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ use_texture_for_bounces bool }{use_texture_for_bounces}))
}

//go:nosplit
func (self class) IsUsingTextureForBounces() bool { //gd:LightmapGI.is_using_texture_for_bounces
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_using_texture_for_bounces, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetCameraAttributes(camera_attributes [1]gdclass.CameraAttributes) { //gd:LightmapGI.set_camera_attributes
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_camera_attributes, 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ camera_attributes gdextension.Object }{gdextension.Object(gd.ObjectChecked(camera_attributes[0].AsObject()))}))
}

//go:nosplit
func (self class) GetCameraAttributes() [1]gdclass.CameraAttributes { //gd:LightmapGI.get_camera_attributes
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_camera_attributes, gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.CameraAttributes{gd.PointerWithOwnershipTransferredToGo[gdclass.CameraAttributes](r_ret)}
	return ret
}
func (self class) AsLightmapGI() Advanced         { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsLightmapGI() Instance      { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsLightmapGI() Instance { return self.Super().AsLightmapGI() }
func (self class) AsVisualInstance3D() VisualInstance3D.Advanced {
	return *((*VisualInstance3D.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsVisualInstance3D() VisualInstance3D.Instance {
	return self.Super().AsVisualInstance3D()
}
func (self Instance) AsVisualInstance3D() VisualInstance3D.Instance {
	return *((*VisualInstance3D.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsNode3D() Node3D.Advanced         { return *((*Node3D.Advanced)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsNode3D() Node3D.Instance { return self.Super().AsNode3D() }
func (self Instance) AsNode3D() Node3D.Instance      { return *((*Node3D.Instance)(unsafe.Pointer(&self))) }
func (self class) AsNode() Node.Advanced             { return *((*Node.Advanced)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsNode() Node.Instance     { return self.Super().AsNode() }
func (self Instance) AsNode() Node.Instance          { return *((*Node.Instance)(unsafe.Pointer(&self))) }

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(VisualInstance3D.Advanced(self.AsVisualInstance3D()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(VisualInstance3D.Instance(self.AsVisualInstance3D()), name)
	}
}
func init() {
	gdclass.Register("LightmapGI", func(ptr gd.Object) any { return *(*Instance)(unsafe.Pointer(&ptr)) })
}

type BakeQuality int //gd:LightmapGI.BakeQuality

const (
	/*Low bake quality (fastest bake times). The quality of this preset can be adjusted by changing [member ProjectSettings.rendering/lightmapping/bake_quality/low_quality_ray_count] and [member ProjectSettings.rendering/lightmapping/bake_quality/low_quality_probe_ray_count].*/
	BakeQualityLow BakeQuality = 0
	/*Medium bake quality (fast bake times). The quality of this preset can be adjusted by changing [member ProjectSettings.rendering/lightmapping/bake_quality/medium_quality_ray_count] and [member ProjectSettings.rendering/lightmapping/bake_quality/medium_quality_probe_ray_count].*/
	BakeQualityMedium BakeQuality = 1
	/*High bake quality (slow bake times). The quality of this preset can be adjusted by changing [member ProjectSettings.rendering/lightmapping/bake_quality/high_quality_ray_count] and [member ProjectSettings.rendering/lightmapping/bake_quality/high_quality_probe_ray_count].*/
	BakeQualityHigh BakeQuality = 2
	/*Highest bake quality (slowest bake times). The quality of this preset can be adjusted by changing [member ProjectSettings.rendering/lightmapping/bake_quality/ultra_quality_ray_count] and [member ProjectSettings.rendering/lightmapping/bake_quality/ultra_quality_probe_ray_count].*/
	BakeQualityUltra BakeQuality = 3
)

type GenerateProbes int //gd:LightmapGI.GenerateProbes

const (
	/*Don't generate lightmap probes for lighting dynamic objects.*/
	GenerateProbesDisabled GenerateProbes = 0
	/*Lowest level of subdivision (fastest bake times, smallest file sizes).*/
	GenerateProbesSubdiv4 GenerateProbes = 1
	/*Low level of subdivision (fast bake times, small file sizes).*/
	GenerateProbesSubdiv8 GenerateProbes = 2
	/*High level of subdivision (slow bake times, large file sizes).*/
	GenerateProbesSubdiv16 GenerateProbes = 3
	/*Highest level of subdivision (slowest bake times, largest file sizes).*/
	GenerateProbesSubdiv32 GenerateProbes = 4
)

type BakeError int //gd:LightmapGI.BakeError

const (
	/*Lightmap baking was successful.*/
	BakeErrorOk BakeError = 0
	/*Lightmap baking failed because the root node for the edited scene could not be accessed.*/
	BakeErrorNoSceneRoot BakeError = 1
	/*Lightmap baking failed as the lightmap data resource is embedded in a foreign resource.*/
	BakeErrorForeignData BakeError = 2
	/*Lightmap baking failed as there is no lightmapper available in this Godot build.*/
	BakeErrorNoLightmapper BakeError = 3
	/*Lightmap baking failed as the [LightmapGIData] save path isn't configured in the resource.*/
	BakeErrorNoSavePath BakeError = 4
	/*Lightmap baking failed as there are no meshes whose [member GeometryInstance3D.gi_mode] is [constant GeometryInstance3D.GI_MODE_STATIC] and with valid UV2 mapping in the current scene. You may need to select 3D scenes in the Import dock and change their global illumination mode accordingly.*/
	BakeErrorNoMeshes BakeError = 5
	/*Lightmap baking failed as the lightmapper failed to analyze some of the meshes marked as static for baking.*/
	BakeErrorMeshesInvalid BakeError = 6
	/*Lightmap baking failed as the resulting image couldn't be saved or imported by Godot after it was saved.*/
	BakeErrorCantCreateImage BakeError = 7
	/*The user aborted the lightmap baking operation (typically by clicking the [b]Cancel[/b] button in the progress dialog).*/
	BakeErrorUserAborted BakeError = 8
	/*Lightmap baking failed as the maximum texture size is too small to fit some of the meshes marked for baking.*/
	BakeErrorTextureSizeTooSmall BakeError = 9
	/*Lightmap baking failed as the lightmap is too small.*/
	BakeErrorLightmapTooSmall BakeError = 10
	/*Lightmap baking failed as the lightmap was unable to fit into an atlas.*/
	BakeErrorAtlasTooSmall BakeError = 11
)

type EnvironmentMode int //gd:LightmapGI.EnvironmentMode

const (
	/*Ignore environment lighting when baking lightmaps.*/
	EnvironmentModeDisabled EnvironmentMode = 0
	/*Use the scene's environment lighting when baking lightmaps.
	  [b]Note:[/b] If baking lightmaps in a scene with no [WorldEnvironment] node, this will act like [constant ENVIRONMENT_MODE_DISABLED]. The editor's preview sky and sun is [i]not[/i] taken into account by [LightmapGI] when baking lightmaps.*/
	EnvironmentModeScene EnvironmentMode = 1
	/*Use [member environment_custom_sky] as a source of environment lighting when baking lightmaps.*/
	EnvironmentModeCustomSky EnvironmentMode = 2
	/*Use [member environment_custom_color] multiplied by [member environment_custom_energy] as a constant source of environment lighting when baking lightmaps.*/
	EnvironmentModeCustomColor EnvironmentMode = 3
)
