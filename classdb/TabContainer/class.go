// Code generated by the generate package DO NOT EDIT

// Package TabContainer provides methods for working with TabContainer object instances.
package TabContainer

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/variant/Signal"
import "graphics.gd/classdb/CanvasItem"
import "graphics.gd/classdb/Container"
import "graphics.gd/classdb/Control"
import "graphics.gd/classdb/Node"
import "graphics.gd/classdb/Popup"
import "graphics.gd/classdb/TabBar"
import "graphics.gd/classdb/Texture2D"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"
import "graphics.gd/variant/Vector2"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Signal.Any
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
Arranges child controls into a tabbed view, creating a tab for each one. The active tab's corresponding control is made visible, while all other child controls are hidden. Ignores non-control children.
[b]Note:[/b] The drawing of the clickable tabs is handled by this node; [TabBar] is not needed.
*/
type Instance [1]gdclass.TabContainer

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	get_tab_count                    gdextension.MethodForClass `hash:"3905245786"`
	set_current_tab                  gdextension.MethodForClass `hash:"1286410249"`
	get_current_tab                  gdextension.MethodForClass `hash:"3905245786"`
	get_previous_tab                 gdextension.MethodForClass `hash:"3905245786"`
	select_previous_available        gdextension.MethodForClass `hash:"2240911060"`
	select_next_available            gdextension.MethodForClass `hash:"2240911060"`
	get_current_tab_control          gdextension.MethodForClass `hash:"2783021301"`
	get_tab_bar                      gdextension.MethodForClass `hash:"1865451809"`
	get_tab_control                  gdextension.MethodForClass `hash:"1065994134"`
	set_tab_alignment                gdextension.MethodForClass `hash:"2413632353"`
	get_tab_alignment                gdextension.MethodForClass `hash:"2178122193"`
	set_tabs_position                gdextension.MethodForClass `hash:"256673370"`
	get_tabs_position                gdextension.MethodForClass `hash:"919937023"`
	set_clip_tabs                    gdextension.MethodForClass `hash:"2586408642"`
	get_clip_tabs                    gdextension.MethodForClass `hash:"36873697"`
	set_tabs_visible                 gdextension.MethodForClass `hash:"2586408642"`
	are_tabs_visible                 gdextension.MethodForClass `hash:"36873697"`
	set_all_tabs_in_front            gdextension.MethodForClass `hash:"2586408642"`
	is_all_tabs_in_front             gdextension.MethodForClass `hash:"36873697"`
	set_tab_title                    gdextension.MethodForClass `hash:"501894301"`
	get_tab_title                    gdextension.MethodForClass `hash:"844755477"`
	set_tab_tooltip                  gdextension.MethodForClass `hash:"501894301"`
	get_tab_tooltip                  gdextension.MethodForClass `hash:"844755477"`
	set_tab_icon                     gdextension.MethodForClass `hash:"666127730"`
	get_tab_icon                     gdextension.MethodForClass `hash:"3536238170"`
	set_tab_icon_max_width           gdextension.MethodForClass `hash:"3937882851"`
	get_tab_icon_max_width           gdextension.MethodForClass `hash:"923996154"`
	set_tab_disabled                 gdextension.MethodForClass `hash:"300928843"`
	is_tab_disabled                  gdextension.MethodForClass `hash:"1116898809"`
	set_tab_hidden                   gdextension.MethodForClass `hash:"300928843"`
	is_tab_hidden                    gdextension.MethodForClass `hash:"1116898809"`
	set_tab_metadata                 gdextension.MethodForClass `hash:"2152698145"`
	get_tab_metadata                 gdextension.MethodForClass `hash:"4227898402"`
	set_tab_button_icon              gdextension.MethodForClass `hash:"666127730"`
	get_tab_button_icon              gdextension.MethodForClass `hash:"3536238170"`
	get_tab_idx_at_point             gdextension.MethodForClass `hash:"3820158470"`
	get_tab_idx_from_control         gdextension.MethodForClass `hash:"2787397975"`
	set_popup                        gdextension.MethodForClass `hash:"1078189570"`
	get_popup                        gdextension.MethodForClass `hash:"111095082"`
	set_drag_to_rearrange_enabled    gdextension.MethodForClass `hash:"2586408642"`
	get_drag_to_rearrange_enabled    gdextension.MethodForClass `hash:"36873697"`
	set_tabs_rearrange_group         gdextension.MethodForClass `hash:"1286410249"`
	get_tabs_rearrange_group         gdextension.MethodForClass `hash:"3905245786"`
	set_use_hidden_tabs_for_min_size gdextension.MethodForClass `hash:"2586408642"`
	get_use_hidden_tabs_for_min_size gdextension.MethodForClass `hash:"36873697"`
	set_tab_focus_mode               gdextension.MethodForClass `hash:"3232914922"`
	get_tab_focus_mode               gdextension.MethodForClass `hash:"2132829277"`
	set_deselect_enabled             gdextension.MethodForClass `hash:"2586408642"`
	get_deselect_enabled             gdextension.MethodForClass `hash:"36873697"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("TabContainer")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		gdextension.Free(gdextension.TypeStringName, &sname)
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsTabContainer() Instance
}

/*
Returns the number of tabs.
*/
func (self Instance) GetTabCount() int { //gd:TabContainer.get_tab_count
	return int(int(Advanced(self).GetTabCount()))
}

/*
Returns the previously active tab index.
*/
func (self Instance) GetPreviousTab() int { //gd:TabContainer.get_previous_tab
	return int(int(Advanced(self).GetPreviousTab()))
}

/*
Selects the first available tab with lower index than the currently selected. Returns [code]true[/code] if tab selection changed.
*/
func (self Instance) SelectPreviousAvailable() bool { //gd:TabContainer.select_previous_available
	return bool(Advanced(self).SelectPreviousAvailable())
}

/*
Selects the first available tab with greater index than the currently selected. Returns [code]true[/code] if tab selection changed.
*/
func (self Instance) SelectNextAvailable() bool { //gd:TabContainer.select_next_available
	return bool(Advanced(self).SelectNextAvailable())
}

/*
Returns the child [Control] node located at the active tab index.
*/
func (self Instance) GetCurrentTabControl() Control.Instance { //gd:TabContainer.get_current_tab_control
	return Control.Instance(Advanced(self).GetCurrentTabControl())
}

/*
Returns the [TabBar] contained in this container.
[b]Warning:[/b] This is a required internal node, removing and freeing it or editing its tabs may cause a crash. If you wish to edit the tabs, use the methods provided in [TabContainer].
*/
func (self Instance) GetTabBar() TabBar.Instance { //gd:TabContainer.get_tab_bar
	return TabBar.Instance(Advanced(self).GetTabBar())
}

/*
Returns the [Control] node from the tab at index [param tab_idx].
*/
func (self Instance) GetTabControl(tab_idx int) Control.Instance { //gd:TabContainer.get_tab_control
	return Control.Instance(Advanced(self).GetTabControl(int64(tab_idx)))
}

/*
Sets a custom title for the tab at index [param tab_idx] (tab titles default to the name of the indexed child node). Set it back to the child's name to make the tab default to it again.
*/
func (self Instance) SetTabTitle(tab_idx int, title string) { //gd:TabContainer.set_tab_title
	Advanced(self).SetTabTitle(int64(tab_idx), String.New(title))
}

/*
Returns the title of the tab at index [param tab_idx]. Tab titles default to the name of the indexed child node, but this can be overridden with [method set_tab_title].
*/
func (self Instance) GetTabTitle(tab_idx int) string { //gd:TabContainer.get_tab_title
	return string(Advanced(self).GetTabTitle(int64(tab_idx)).String())
}

/*
Sets a custom tooltip text for tab at index [param tab_idx].
[b]Note:[/b] By default, if the [param tooltip] is empty and the tab text is truncated (not all characters fit into the tab), the title will be displayed as a tooltip. To hide the tooltip, assign [code]" "[/code] as the [param tooltip] text.
*/
func (self Instance) SetTabTooltip(tab_idx int, tooltip string) { //gd:TabContainer.set_tab_tooltip
	Advanced(self).SetTabTooltip(int64(tab_idx), String.New(tooltip))
}

/*
Returns the tooltip text of the tab at index [param tab_idx].
*/
func (self Instance) GetTabTooltip(tab_idx int) string { //gd:TabContainer.get_tab_tooltip
	return string(Advanced(self).GetTabTooltip(int64(tab_idx)).String())
}

/*
Sets an icon for the tab at index [param tab_idx].
*/
func (self Instance) SetTabIcon(tab_idx int, icon Texture2D.Instance) { //gd:TabContainer.set_tab_icon
	Advanced(self).SetTabIcon(int64(tab_idx), icon)
}

/*
Returns the [Texture2D] for the tab at index [param tab_idx] or [code]null[/code] if the tab has no [Texture2D].
*/
func (self Instance) GetTabIcon(tab_idx int) Texture2D.Instance { //gd:TabContainer.get_tab_icon
	return Texture2D.Instance(Advanced(self).GetTabIcon(int64(tab_idx)))
}

/*
Sets the maximum allowed width of the icon for the tab at index [param tab_idx]. This limit is applied on top of the default size of the icon and on top of [theme_item icon_max_width]. The height is adjusted according to the icon's ratio.
*/
func (self Instance) SetTabIconMaxWidth(tab_idx int, width int) { //gd:TabContainer.set_tab_icon_max_width
	Advanced(self).SetTabIconMaxWidth(int64(tab_idx), int64(width))
}

/*
Returns the maximum allowed width of the icon for the tab at index [param tab_idx].
*/
func (self Instance) GetTabIconMaxWidth(tab_idx int) int { //gd:TabContainer.get_tab_icon_max_width
	return int(int(Advanced(self).GetTabIconMaxWidth(int64(tab_idx))))
}

/*
If [param disabled] is [code]true[/code], disables the tab at index [param tab_idx], making it non-interactable.
*/
func (self Instance) SetTabDisabled(tab_idx int, disabled bool) { //gd:TabContainer.set_tab_disabled
	Advanced(self).SetTabDisabled(int64(tab_idx), disabled)
}

/*
Returns [code]true[/code] if the tab at index [param tab_idx] is disabled.
*/
func (self Instance) IsTabDisabled(tab_idx int) bool { //gd:TabContainer.is_tab_disabled
	return bool(Advanced(self).IsTabDisabled(int64(tab_idx)))
}

/*
If [param hidden] is [code]true[/code], hides the tab at index [param tab_idx], making it disappear from the tab area.
*/
func (self Instance) SetTabHidden(tab_idx int, hidden bool) { //gd:TabContainer.set_tab_hidden
	Advanced(self).SetTabHidden(int64(tab_idx), hidden)
}

/*
Returns [code]true[/code] if the tab at index [param tab_idx] is hidden.
*/
func (self Instance) IsTabHidden(tab_idx int) bool { //gd:TabContainer.is_tab_hidden
	return bool(Advanced(self).IsTabHidden(int64(tab_idx)))
}

/*
Sets the metadata value for the tab at index [param tab_idx], which can be retrieved later using [method get_tab_metadata].
*/
func (self Instance) SetTabMetadata(tab_idx int, metadata any) { //gd:TabContainer.set_tab_metadata
	Advanced(self).SetTabMetadata(int64(tab_idx), variant.New(metadata))
}

/*
Returns the metadata value set to the tab at index [param tab_idx] using [method set_tab_metadata]. If no metadata was previously set, returns [code]null[/code] by default.
*/
func (self Instance) GetTabMetadata(tab_idx int) any { //gd:TabContainer.get_tab_metadata
	return any(Advanced(self).GetTabMetadata(int64(tab_idx)).Interface())
}

/*
Sets the button icon from the tab at index [param tab_idx].
*/
func (self Instance) SetTabButtonIcon(tab_idx int, icon Texture2D.Instance) { //gd:TabContainer.set_tab_button_icon
	Advanced(self).SetTabButtonIcon(int64(tab_idx), icon)
}

/*
Returns the button icon from the tab at index [param tab_idx].
*/
func (self Instance) GetTabButtonIcon(tab_idx int) Texture2D.Instance { //gd:TabContainer.get_tab_button_icon
	return Texture2D.Instance(Advanced(self).GetTabButtonIcon(int64(tab_idx)))
}

/*
Returns the index of the tab at local coordinates [param point]. Returns [code]-1[/code] if the point is outside the control boundaries or if there's no tab at the queried position.
*/
func (self Instance) GetTabIdxAtPoint(point Vector2.XY) int { //gd:TabContainer.get_tab_idx_at_point
	return int(int(Advanced(self).GetTabIdxAtPoint(Vector2.XY(point))))
}

/*
Returns the index of the tab tied to the given [param control]. The control must be a child of the [TabContainer].
*/
func (self Instance) GetTabIdxFromControl(control Control.Instance) int { //gd:TabContainer.get_tab_idx_from_control
	return int(int(Advanced(self).GetTabIdxFromControl(control)))
}

/*
If set on a [Popup] node instance, a popup menu icon appears in the top-right corner of the [TabContainer] (setting it to [code]null[/code] will make it go away). Clicking it will expand the [Popup] node.
*/
func (self Instance) SetPopup(popup Node.Instance) { //gd:TabContainer.set_popup
	Advanced(self).SetPopup(popup)
}

/*
Returns the [Popup] node instance if one has been set already with [method set_popup].
[b]Warning:[/b] This is a required internal node, removing and freeing it may cause a crash. If you wish to hide it or any of its children, use their [member Window.visible] property.
*/
func (self Instance) GetPopup() Popup.Instance { //gd:TabContainer.get_popup
	return Popup.Instance(Advanced(self).GetPopup())
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.TabContainer

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = pointers.AsA[gdclass.TabContainer](obj[0])
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = pointers.AsA[gdclass.TabContainer](obj[0])
		return true
	}
	return false
}
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }
func (self *Extension[T]) AsObject() [1]gd.Object { return self.Super().AsObject() }
func New() Instance {
	if !gd.Linked {
		var placeholder = Instance([1]gdclass.TabContainer{pointers.Add[gdclass.TabContainer]([3]uint64{})})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(pointers.AsA[gd.Object](placeholder[0]), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	casted := Instance([1]gdclass.TabContainer{pointers.New[gdclass.TabContainer]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})})
	casted.AsObject()[0].Notification(0, false)
	return casted
}

func (self Instance) TabAlignment() TabBar.AlignmentMode {
	return TabBar.AlignmentMode(class(self).GetTabAlignment())
}

func (self Instance) SetTabAlignment(value TabBar.AlignmentMode) {
	class(self).SetTabAlignment(value)
}

func (self Instance) CurrentTab() int {
	return int(int(class(self).GetCurrentTab()))
}

func (self Instance) SetCurrentTab(value int) {
	class(self).SetCurrentTab(int64(value))
}

func (self Instance) TabsPosition() TabPosition {
	return TabPosition(class(self).GetTabsPosition())
}

func (self Instance) SetTabsPosition(value TabPosition) {
	class(self).SetTabsPosition(value)
}

func (self Instance) ClipTabs() bool {
	return bool(class(self).GetClipTabs())
}

func (self Instance) SetClipTabs(value bool) {
	class(self).SetClipTabs(value)
}

func (self Instance) TabsVisible() bool {
	return bool(class(self).AreTabsVisible())
}

func (self Instance) SetTabsVisible(value bool) {
	class(self).SetTabsVisible(value)
}

func (self Instance) AllTabsInFront() bool {
	return bool(class(self).IsAllTabsInFront())
}

func (self Instance) SetAllTabsInFront(value bool) {
	class(self).SetAllTabsInFront(value)
}

func (self Instance) DragToRearrangeEnabled() bool {
	return bool(class(self).GetDragToRearrangeEnabled())
}

func (self Instance) SetDragToRearrangeEnabled(value bool) {
	class(self).SetDragToRearrangeEnabled(value)
}

func (self Instance) TabsRearrangeGroup() int {
	return int(int(class(self).GetTabsRearrangeGroup()))
}

func (self Instance) SetTabsRearrangeGroup(value int) {
	class(self).SetTabsRearrangeGroup(int64(value))
}

func (self Instance) UseHiddenTabsForMinSize() bool {
	return bool(class(self).GetUseHiddenTabsForMinSize())
}

func (self Instance) SetUseHiddenTabsForMinSize(value bool) {
	class(self).SetUseHiddenTabsForMinSize(value)
}

func (self Instance) TabFocusMode() Control.FocusMode {
	return Control.FocusMode(class(self).GetTabFocusMode())
}

func (self Instance) SetTabFocusMode(value Control.FocusMode) {
	class(self).SetTabFocusMode(value)
}

func (self Instance) DeselectEnabled() bool {
	return bool(class(self).GetDeselectEnabled())
}

func (self Instance) SetDeselectEnabled(value bool) {
	class(self).SetDeselectEnabled(value)
}

/*
Returns the number of tabs.
*/
//go:nosplit
func (self class) GetTabCount() int64 { //gd:TabContainer.get_tab_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_tab_count, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetCurrentTab(tab_idx int64) { //gd:TabContainer.set_current_tab
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_current_tab, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ tab_idx int64 }{tab_idx}))
}

//go:nosplit
func (self class) GetCurrentTab() int64 { //gd:TabContainer.get_current_tab
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_current_tab, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the previously active tab index.
*/
//go:nosplit
func (self class) GetPreviousTab() int64 { //gd:TabContainer.get_previous_tab
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_previous_tab, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Selects the first available tab with lower index than the currently selected. Returns [code]true[/code] if tab selection changed.
*/
//go:nosplit
func (self class) SelectPreviousAvailable() bool { //gd:TabContainer.select_previous_available
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.select_previous_available, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Selects the first available tab with greater index than the currently selected. Returns [code]true[/code] if tab selection changed.
*/
//go:nosplit
func (self class) SelectNextAvailable() bool { //gd:TabContainer.select_next_available
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.select_next_available, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the child [Control] node located at the active tab index.
*/
//go:nosplit
func (self class) GetCurrentTabControl() [1]gdclass.Control { //gd:TabContainer.get_current_tab_control
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_current_tab_control, gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.Control{gd.PointerMustAssertInstanceID[gdclass.Control](r_ret)}
	return ret
}

/*
Returns the [TabBar] contained in this container.
[b]Warning:[/b] This is a required internal node, removing and freeing it or editing its tabs may cause a crash. If you wish to edit the tabs, use the methods provided in [TabContainer].
*/
//go:nosplit
func (self class) GetTabBar() [1]gdclass.TabBar { //gd:TabContainer.get_tab_bar
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_tab_bar, gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.TabBar{gd.PointerLifetimeBoundTo[gdclass.TabBar](self.AsObject(), r_ret)}
	return ret
}

/*
Returns the [Control] node from the tab at index [param tab_idx].
*/
//go:nosplit
func (self class) GetTabControl(tab_idx int64) [1]gdclass.Control { //gd:TabContainer.get_tab_control
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_tab_control, gdextension.SizeObject|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ tab_idx int64 }{tab_idx}))
	var ret = [1]gdclass.Control{gd.PointerMustAssertInstanceID[gdclass.Control](r_ret)}
	return ret
}

//go:nosplit
func (self class) SetTabAlignment(alignment TabBar.AlignmentMode) { //gd:TabContainer.set_tab_alignment
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_tab_alignment, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ alignment TabBar.AlignmentMode }{alignment}))
}

//go:nosplit
func (self class) GetTabAlignment() TabBar.AlignmentMode { //gd:TabContainer.get_tab_alignment
	var r_ret = gdextension.Call[TabBar.AlignmentMode](gd.ObjectChecked(self.AsObject()), methods.get_tab_alignment, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetTabsPosition(tabs_position TabPosition) { //gd:TabContainer.set_tabs_position
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_tabs_position, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ tabs_position TabPosition }{tabs_position}))
}

//go:nosplit
func (self class) GetTabsPosition() TabPosition { //gd:TabContainer.get_tabs_position
	var r_ret = gdextension.Call[TabPosition](gd.ObjectChecked(self.AsObject()), methods.get_tabs_position, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetClipTabs(clip_tabs bool) { //gd:TabContainer.set_clip_tabs
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_clip_tabs, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ clip_tabs bool }{clip_tabs}))
}

//go:nosplit
func (self class) GetClipTabs() bool { //gd:TabContainer.get_clip_tabs
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.get_clip_tabs, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetTabsVisible(visible bool) { //gd:TabContainer.set_tabs_visible
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_tabs_visible, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ visible bool }{visible}))
}

//go:nosplit
func (self class) AreTabsVisible() bool { //gd:TabContainer.are_tabs_visible
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.are_tabs_visible, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetAllTabsInFront(is_front bool) { //gd:TabContainer.set_all_tabs_in_front
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_all_tabs_in_front, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ is_front bool }{is_front}))
}

//go:nosplit
func (self class) IsAllTabsInFront() bool { //gd:TabContainer.is_all_tabs_in_front
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_all_tabs_in_front, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Sets a custom title for the tab at index [param tab_idx] (tab titles default to the name of the indexed child node). Set it back to the child's name to make the tab default to it again.
*/
//go:nosplit
func (self class) SetTabTitle(tab_idx int64, title String.Readable) { //gd:TabContainer.set_tab_title
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_tab_title, 0|(gdextension.SizeInt<<4)|(gdextension.SizeString<<8), unsafe.Pointer(&struct {
		tab_idx int64
		title   gdextension.String
	}{tab_idx, pointers.Get(gd.InternalString(title))}))
}

/*
Returns the title of the tab at index [param tab_idx]. Tab titles default to the name of the indexed child node, but this can be overridden with [method set_tab_title].
*/
//go:nosplit
func (self class) GetTabTitle(tab_idx int64) String.Readable { //gd:TabContainer.get_tab_title
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_tab_title, gdextension.SizeString|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ tab_idx int64 }{tab_idx}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Sets a custom tooltip text for tab at index [param tab_idx].
[b]Note:[/b] By default, if the [param tooltip] is empty and the tab text is truncated (not all characters fit into the tab), the title will be displayed as a tooltip. To hide the tooltip, assign [code]" "[/code] as the [param tooltip] text.
*/
//go:nosplit
func (self class) SetTabTooltip(tab_idx int64, tooltip String.Readable) { //gd:TabContainer.set_tab_tooltip
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_tab_tooltip, 0|(gdextension.SizeInt<<4)|(gdextension.SizeString<<8), unsafe.Pointer(&struct {
		tab_idx int64
		tooltip gdextension.String
	}{tab_idx, pointers.Get(gd.InternalString(tooltip))}))
}

/*
Returns the tooltip text of the tab at index [param tab_idx].
*/
//go:nosplit
func (self class) GetTabTooltip(tab_idx int64) String.Readable { //gd:TabContainer.get_tab_tooltip
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_tab_tooltip, gdextension.SizeString|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ tab_idx int64 }{tab_idx}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Sets an icon for the tab at index [param tab_idx].
*/
//go:nosplit
func (self class) SetTabIcon(tab_idx int64, icon [1]gdclass.Texture2D) { //gd:TabContainer.set_tab_icon
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_tab_icon, 0|(gdextension.SizeInt<<4)|(gdextension.SizeObject<<8), unsafe.Pointer(&struct {
		tab_idx int64
		icon    gdextension.Object
	}{tab_idx, gdextension.Object(gd.ObjectChecked(icon[0].AsObject()))}))
}

/*
Returns the [Texture2D] for the tab at index [param tab_idx] or [code]null[/code] if the tab has no [Texture2D].
*/
//go:nosplit
func (self class) GetTabIcon(tab_idx int64) [1]gdclass.Texture2D { //gd:TabContainer.get_tab_icon
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_tab_icon, gdextension.SizeObject|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ tab_idx int64 }{tab_idx}))
	var ret = [1]gdclass.Texture2D{gd.PointerWithOwnershipTransferredToGo[gdclass.Texture2D](r_ret)}
	return ret
}

/*
Sets the maximum allowed width of the icon for the tab at index [param tab_idx]. This limit is applied on top of the default size of the icon and on top of [theme_item icon_max_width]. The height is adjusted according to the icon's ratio.
*/
//go:nosplit
func (self class) SetTabIconMaxWidth(tab_idx int64, width int64) { //gd:TabContainer.set_tab_icon_max_width
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_tab_icon_max_width, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		tab_idx int64
		width   int64
	}{tab_idx, width}))
}

/*
Returns the maximum allowed width of the icon for the tab at index [param tab_idx].
*/
//go:nosplit
func (self class) GetTabIconMaxWidth(tab_idx int64) int64 { //gd:TabContainer.get_tab_icon_max_width
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_tab_icon_max_width, gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ tab_idx int64 }{tab_idx}))
	var ret = r_ret
	return ret
}

/*
If [param disabled] is [code]true[/code], disables the tab at index [param tab_idx], making it non-interactable.
*/
//go:nosplit
func (self class) SetTabDisabled(tab_idx int64, disabled bool) { //gd:TabContainer.set_tab_disabled
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_tab_disabled, 0|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		tab_idx  int64
		disabled bool
	}{tab_idx, disabled}))
}

/*
Returns [code]true[/code] if the tab at index [param tab_idx] is disabled.
*/
//go:nosplit
func (self class) IsTabDisabled(tab_idx int64) bool { //gd:TabContainer.is_tab_disabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_tab_disabled, gdextension.SizeBool|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ tab_idx int64 }{tab_idx}))
	var ret = r_ret
	return ret
}

/*
If [param hidden] is [code]true[/code], hides the tab at index [param tab_idx], making it disappear from the tab area.
*/
//go:nosplit
func (self class) SetTabHidden(tab_idx int64, hidden bool) { //gd:TabContainer.set_tab_hidden
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_tab_hidden, 0|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		tab_idx int64
		hidden  bool
	}{tab_idx, hidden}))
}

/*
Returns [code]true[/code] if the tab at index [param tab_idx] is hidden.
*/
//go:nosplit
func (self class) IsTabHidden(tab_idx int64) bool { //gd:TabContainer.is_tab_hidden
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_tab_hidden, gdextension.SizeBool|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ tab_idx int64 }{tab_idx}))
	var ret = r_ret
	return ret
}

/*
Sets the metadata value for the tab at index [param tab_idx], which can be retrieved later using [method get_tab_metadata].
*/
//go:nosplit
func (self class) SetTabMetadata(tab_idx int64, metadata variant.Any) { //gd:TabContainer.set_tab_metadata
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_tab_metadata, 0|(gdextension.SizeInt<<4)|(gdextension.SizeVariant<<8), unsafe.Pointer(&struct {
		tab_idx  int64
		metadata gdextension.Variant
	}{tab_idx, gdextension.Variant(pointers.Get(gd.InternalVariant(metadata)))}))
}

/*
Returns the metadata value set to the tab at index [param tab_idx] using [method set_tab_metadata]. If no metadata was previously set, returns [code]null[/code] by default.
*/
//go:nosplit
func (self class) GetTabMetadata(tab_idx int64) variant.Any { //gd:TabContainer.get_tab_metadata
	var r_ret = gdextension.Call[gdextension.Variant](gd.ObjectChecked(self.AsObject()), methods.get_tab_metadata, gdextension.SizeVariant|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ tab_idx int64 }{tab_idx}))
	var ret = variant.Implementation(gd.VariantProxy{}, pointers.Pack(pointers.New[gd.Variant](r_ret)))
	return ret
}

/*
Sets the button icon from the tab at index [param tab_idx].
*/
//go:nosplit
func (self class) SetTabButtonIcon(tab_idx int64, icon [1]gdclass.Texture2D) { //gd:TabContainer.set_tab_button_icon
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_tab_button_icon, 0|(gdextension.SizeInt<<4)|(gdextension.SizeObject<<8), unsafe.Pointer(&struct {
		tab_idx int64
		icon    gdextension.Object
	}{tab_idx, gdextension.Object(gd.ObjectChecked(icon[0].AsObject()))}))
}

/*
Returns the button icon from the tab at index [param tab_idx].
*/
//go:nosplit
func (self class) GetTabButtonIcon(tab_idx int64) [1]gdclass.Texture2D { //gd:TabContainer.get_tab_button_icon
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_tab_button_icon, gdextension.SizeObject|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ tab_idx int64 }{tab_idx}))
	var ret = [1]gdclass.Texture2D{gd.PointerWithOwnershipTransferredToGo[gdclass.Texture2D](r_ret)}
	return ret
}

/*
Returns the index of the tab at local coordinates [param point]. Returns [code]-1[/code] if the point is outside the control boundaries or if there's no tab at the queried position.
*/
//go:nosplit
func (self class) GetTabIdxAtPoint(point Vector2.XY) int64 { //gd:TabContainer.get_tab_idx_at_point
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_tab_idx_at_point, gdextension.SizeInt|(gdextension.SizeVector2<<4), unsafe.Pointer(&struct{ point Vector2.XY }{point}))
	var ret = r_ret
	return ret
}

/*
Returns the index of the tab tied to the given [param control]. The control must be a child of the [TabContainer].
*/
//go:nosplit
func (self class) GetTabIdxFromControl(control [1]gdclass.Control) int64 { //gd:TabContainer.get_tab_idx_from_control
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_tab_idx_from_control, gdextension.SizeInt|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ control gdextension.Object }{gdextension.Object(gd.ObjectChecked(control[0].AsObject()))}))
	var ret = r_ret
	return ret
}

/*
If set on a [Popup] node instance, a popup menu icon appears in the top-right corner of the [TabContainer] (setting it to [code]null[/code] will make it go away). Clicking it will expand the [Popup] node.
*/
//go:nosplit
func (self class) SetPopup(popup [1]gdclass.Node) { //gd:TabContainer.set_popup
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_popup, 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ popup gdextension.Object }{gdextension.Object(gd.PointerWithOwnershipTransferredToGodot(popup[0].AsObject()[0]))}))
}

/*
Returns the [Popup] node instance if one has been set already with [method set_popup].
[b]Warning:[/b] This is a required internal node, removing and freeing it may cause a crash. If you wish to hide it or any of its children, use their [member Window.visible] property.
*/
//go:nosplit
func (self class) GetPopup() [1]gdclass.Popup { //gd:TabContainer.get_popup
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_popup, gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.Popup{gd.PointerMustAssertInstanceID[gdclass.Popup](r_ret)}
	return ret
}

//go:nosplit
func (self class) SetDragToRearrangeEnabled(enabled bool) { //gd:TabContainer.set_drag_to_rearrange_enabled
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_drag_to_rearrange_enabled, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enabled bool }{enabled}))
}

//go:nosplit
func (self class) GetDragToRearrangeEnabled() bool { //gd:TabContainer.get_drag_to_rearrange_enabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.get_drag_to_rearrange_enabled, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetTabsRearrangeGroup(group_id int64) { //gd:TabContainer.set_tabs_rearrange_group
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_tabs_rearrange_group, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ group_id int64 }{group_id}))
}

//go:nosplit
func (self class) GetTabsRearrangeGroup() int64 { //gd:TabContainer.get_tabs_rearrange_group
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_tabs_rearrange_group, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetUseHiddenTabsForMinSize(enabled bool) { //gd:TabContainer.set_use_hidden_tabs_for_min_size
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_use_hidden_tabs_for_min_size, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enabled bool }{enabled}))
}

//go:nosplit
func (self class) GetUseHiddenTabsForMinSize() bool { //gd:TabContainer.get_use_hidden_tabs_for_min_size
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.get_use_hidden_tabs_for_min_size, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetTabFocusMode(focus_mode Control.FocusMode) { //gd:TabContainer.set_tab_focus_mode
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_tab_focus_mode, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ focus_mode Control.FocusMode }{focus_mode}))
}

//go:nosplit
func (self class) GetTabFocusMode() Control.FocusMode { //gd:TabContainer.get_tab_focus_mode
	var r_ret = gdextension.Call[Control.FocusMode](gd.ObjectChecked(self.AsObject()), methods.get_tab_focus_mode, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetDeselectEnabled(enabled bool) { //gd:TabContainer.set_deselect_enabled
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_deselect_enabled, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enabled bool }{enabled}))
}

//go:nosplit
func (self class) GetDeselectEnabled() bool { //gd:TabContainer.get_deselect_enabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.get_deselect_enabled, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}
func (self Instance) OnActiveTabRearranged(cb func(idx_to int), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("active_tab_rearranged"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) ActiveTabRearranged() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`ActiveTabRearranged`))))
}

func (self Instance) OnTabChanged(cb func(tab int), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("tab_changed"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) TabChanged() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`TabChanged`))))
}

func (self Instance) OnTabClicked(cb func(tab int), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("tab_clicked"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) TabClicked() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`TabClicked`))))
}

func (self Instance) OnTabHovered(cb func(tab int), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("tab_hovered"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) TabHovered() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`TabHovered`))))
}

func (self Instance) OnTabSelected(cb func(tab int), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("tab_selected"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) TabSelected() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`TabSelected`))))
}

func (self Instance) OnTabButtonPressed(cb func(tab int), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("tab_button_pressed"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) TabButtonPressed() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`TabButtonPressed`))))
}

func (self Instance) OnPrePopupPressed(cb func(), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("pre_popup_pressed"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) PrePopupPressed() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`PrePopupPressed`))))
}

func (self class) AsTabContainer() Advanced {
	return Advanced{pointers.AsA[gdclass.TabContainer](self[0])}
}
func (self Instance) AsTabContainer() Instance {
	return Instance{pointers.AsA[gdclass.TabContainer](self[0])}
}
func (self *Extension[T]) AsTabContainer() Instance { return self.Super().AsTabContainer() }
func (self class) AsContainer() Container.Advanced {
	return Container.Advanced{pointers.AsA[gdclass.Container](self[0])}
}
func (self *Extension[T]) AsContainer() Container.Instance { return self.Super().AsContainer() }
func (self Instance) AsContainer() Container.Instance {
	return Container.Instance{pointers.AsA[gdclass.Container](self[0])}
}
func (self class) AsControl() Control.Advanced {
	return Control.Advanced{pointers.AsA[gdclass.Control](self[0])}
}
func (self *Extension[T]) AsControl() Control.Instance { return self.Super().AsControl() }
func (self Instance) AsControl() Control.Instance {
	return Control.Instance{pointers.AsA[gdclass.Control](self[0])}
}
func (self class) AsCanvasItem() CanvasItem.Advanced {
	return CanvasItem.Advanced{pointers.AsA[gdclass.CanvasItem](self[0])}
}
func (self *Extension[T]) AsCanvasItem() CanvasItem.Instance { return self.Super().AsCanvasItem() }
func (self Instance) AsCanvasItem() CanvasItem.Instance {
	return CanvasItem.Instance{pointers.AsA[gdclass.CanvasItem](self[0])}
}
func (self class) AsNode() Node.Advanced         { return Node.Advanced{pointers.AsA[gdclass.Node](self[0])} }
func (self *Extension[T]) AsNode() Node.Instance { return self.Super().AsNode() }
func (self Instance) AsNode() Node.Instance {
	return Node.Instance{pointers.AsA[gdclass.Node](self[0])}
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Container.Advanced(self.AsContainer()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Container.Instance(self.AsContainer()), name)
	}
}
func init() {
	gdclass.Register("TabContainer", func(ptr gd.Object) any { return Instance{pointers.AsA[gdclass.TabContainer](ptr)} })
}

type TabPosition int //gd:TabContainer.TabPosition

const (
	/*Places the tab bar at the top.*/
	PositionTop TabPosition = 0
	/*Places the tab bar at the bottom. The tab bar's [StyleBox] will be flipped vertically.*/
	PositionBottom TabPosition = 1
	/*Represents the size of the [enum TabPosition] enum.*/
	PositionMax TabPosition = 2
)
