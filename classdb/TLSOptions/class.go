// Code generated by the generate package DO NOT EDIT

// Package TLSOptions provides methods for working with TLSOptions object instances.
package TLSOptions

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/variant/Signal"
import "graphics.gd/classdb/CryptoKey"
import "graphics.gd/classdb/X509Certificate"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Signal.Any
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
TLSOptions abstracts the configuration options for the [StreamPeerTLS] and [PacketPeerDTLS] classes.
Objects of this class cannot be instantiated directly, and one of the static methods [method client], [method client_unsafe], or [method server] should be used instead.
[codeblocks]
[gdscript]
# Create a TLS client configuration which uses our custom trusted CA chain.
var client_trusted_cas = load("res://my_trusted_cas.crt")
var client_tls_options = TLSOptions.client(client_trusted_cas)

# Create a TLS server configuration.
var server_certs = load("res://my_server_cas.crt")
var server_key = load("res://my_server_key.key")
var server_tls_options = TLSOptions.server(server_key, server_certs)
[/gdscript]
[/codeblocks]
*/
type Instance [1]gdclass.TLSOptions

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	client                   gdextension.MethodForClass `hash:"3565000357"`
	client_unsafe            gdextension.MethodForClass `hash:"2090251749"`
	server                   gdextension.MethodForClass `hash:"36969539"`
	is_server                gdextension.MethodForClass `hash:"36873697"`
	is_unsafe_client         gdextension.MethodForClass `hash:"36873697"`
	get_common_name_override gdextension.MethodForClass `hash:"201670096"`
	get_trusted_ca_chain     gdextension.MethodForClass `hash:"1120709175"`
	get_private_key          gdextension.MethodForClass `hash:"2119971811"`
	get_own_certificate      gdextension.MethodForClass `hash:"1120709175"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("TLSOptions")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		gdextension.Free(gdextension.TypeStringName, &sname)
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsTLSOptions() Instance
}

/*
Creates a TLS client configuration which validates certificates and their common names (fully qualified domain names).
You can specify a custom [param trusted_chain] of certification authorities (the default CA list will be used if [code]null[/code]), and optionally provide a [param common_name_override] if you expect the certificate to have a common name other than the server FQDN.
[b]Note:[/b] On the Web platform, TLS verification is always enforced against the CA list of the web browser. This is considered a security feature.
*/
func Client(trusted_chain X509Certificate.Instance, common_name_override string) Instance { //gd:TLSOptions.client
	self := Instance{}
	return Instance(Advanced(self).Client(trusted_chain, String.New(common_name_override)))
}

/*
Creates a TLS client configuration which validates certificates and their common names (fully qualified domain names).
You can specify a custom [param trusted_chain] of certification authorities (the default CA list will be used if [code]null[/code]), and optionally provide a [param common_name_override] if you expect the certificate to have a common name other than the server FQDN.
[b]Note:[/b] On the Web platform, TLS verification is always enforced against the CA list of the web browser. This is considered a security feature.
*/
func ClientOptions(trusted_chain X509Certificate.Instance, common_name_override string) Instance { //gd:TLSOptions.client
	self := Instance{}
	return Instance(Advanced(self).Client(trusted_chain, String.New(common_name_override)))
}

/*
Creates an [b]unsafe[/b] TLS client configuration where certificate validation is optional. You can optionally provide a valid [param trusted_chain], but the common name of the certificates will never be checked. Using this configuration for purposes other than testing [b]is not recommended[/b].
[b]Note:[/b] On the Web platform, TLS verification is always enforced against the CA list of the web browser. This is considered a security feature.
*/
func ClientUnsafe(trusted_chain X509Certificate.Instance) Instance { //gd:TLSOptions.client_unsafe
	self := Instance{}
	return Instance(Advanced(self).ClientUnsafe(trusted_chain))
}

/*
Creates an [b]unsafe[/b] TLS client configuration where certificate validation is optional. You can optionally provide a valid [param trusted_chain], but the common name of the certificates will never be checked. Using this configuration for purposes other than testing [b]is not recommended[/b].
[b]Note:[/b] On the Web platform, TLS verification is always enforced against the CA list of the web browser. This is considered a security feature.
*/
func ClientUnsafeOptions(trusted_chain X509Certificate.Instance) Instance { //gd:TLSOptions.client_unsafe
	self := Instance{}
	return Instance(Advanced(self).ClientUnsafe(trusted_chain))
}

/*
Creates a TLS server configuration using the provided [param key] and [param certificate].
[b]Note:[/b] The [param certificate] should include the full certificate chain up to the signing CA (certificates file can be concatenated using a general purpose text editor).
*/
func Server(key CryptoKey.Instance, certificate X509Certificate.Instance) Instance { //gd:TLSOptions.server
	self := Instance{}
	return Instance(Advanced(self).Server(key, certificate))
}

/*
Returns [code]true[/code] if created with [method TLSOptions.server], [code]false[/code] otherwise.
*/
func (self Instance) IsServer() bool { //gd:TLSOptions.is_server
	return bool(Advanced(self).IsServer())
}

/*
Returns [code]true[/code] if created with [method TLSOptions.client_unsafe], [code]false[/code] otherwise.
*/
func (self Instance) IsUnsafeClient() bool { //gd:TLSOptions.is_unsafe_client
	return bool(Advanced(self).IsUnsafeClient())
}

/*
Returns the common name (domain name) override specified when creating with [method TLSOptions.client].
*/
func (self Instance) GetCommonNameOverride() string { //gd:TLSOptions.get_common_name_override
	return string(Advanced(self).GetCommonNameOverride().String())
}

/*
Returns the CA [X509Certificate] chain specified when creating with [method TLSOptions.client] or [method TLSOptions.client_unsafe].
*/
func (self Instance) GetTrustedCaChain() X509Certificate.Instance { //gd:TLSOptions.get_trusted_ca_chain
	return X509Certificate.Instance(Advanced(self).GetTrustedCaChain())
}

/*
Returns the [CryptoKey] specified when creating with [method TLSOptions.server].
*/
func (self Instance) GetPrivateKey() CryptoKey.Instance { //gd:TLSOptions.get_private_key
	return CryptoKey.Instance(Advanced(self).GetPrivateKey())
}

/*
Returns the [X509Certificate] specified when creating with [method TLSOptions.server].
*/
func (self Instance) GetOwnCertificate() X509Certificate.Instance { //gd:TLSOptions.get_own_certificate
	return X509Certificate.Instance(Advanced(self).GetOwnCertificate())
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.TLSOptions

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = pointers.AsA[gdclass.TLSOptions](obj[0])
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = pointers.AsA[gdclass.TLSOptions](obj[0])
		return true
	}
	return false
}
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }
func (self *Extension[T]) AsObject() [1]gd.Object { return self.Super().AsObject() }
func New() Instance {
	if !gd.Linked {
		var placeholder = Instance([1]gdclass.TLSOptions{pointers.Add[gdclass.TLSOptions]([3]uint64{})})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(pointers.AsA[gd.Object](placeholder[0]), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	casted := Instance([1]gdclass.TLSOptions{pointers.New[gdclass.TLSOptions]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})})
	casted.AsRefCounted()[0].InitRef()
	casted.AsObject()[0].Notification(0, false)
	return casted
}

/*
Creates a TLS client configuration which validates certificates and their common names (fully qualified domain names).
You can specify a custom [param trusted_chain] of certification authorities (the default CA list will be used if [code]null[/code]), and optionally provide a [param common_name_override] if you expect the certificate to have a common name other than the server FQDN.
[b]Note:[/b] On the Web platform, TLS verification is always enforced against the CA list of the web browser. This is considered a security feature.
*/
//go:nosplit
func (self class) Client(trusted_chain [1]gdclass.X509Certificate, common_name_override String.Readable) [1]gdclass.TLSOptions { //gd:TLSOptions.client
	var r_ret = gdextension.CallStatic[gdextension.Object](methods.client, gdextension.SizeObject|(gdextension.SizeObject<<4)|(gdextension.SizeString<<8), unsafe.Pointer(&struct {
		trusted_chain        gdextension.Object
		common_name_override gdextension.String
	}{gdextension.Object(gd.ObjectChecked(trusted_chain[0].AsObject())), pointers.Get(gd.InternalString(common_name_override))}))
	var ret = [1]gdclass.TLSOptions{gd.PointerWithOwnershipTransferredToGo[gdclass.TLSOptions](r_ret)}
	return ret
}

/*
Creates an [b]unsafe[/b] TLS client configuration where certificate validation is optional. You can optionally provide a valid [param trusted_chain], but the common name of the certificates will never be checked. Using this configuration for purposes other than testing [b]is not recommended[/b].
[b]Note:[/b] On the Web platform, TLS verification is always enforced against the CA list of the web browser. This is considered a security feature.
*/
//go:nosplit
func (self class) ClientUnsafe(trusted_chain [1]gdclass.X509Certificate) [1]gdclass.TLSOptions { //gd:TLSOptions.client_unsafe
	var r_ret = gdextension.CallStatic[gdextension.Object](methods.client_unsafe, gdextension.SizeObject|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ trusted_chain gdextension.Object }{gdextension.Object(gd.ObjectChecked(trusted_chain[0].AsObject()))}))
	var ret = [1]gdclass.TLSOptions{gd.PointerWithOwnershipTransferredToGo[gdclass.TLSOptions](r_ret)}
	return ret
}

/*
Creates a TLS server configuration using the provided [param key] and [param certificate].
[b]Note:[/b] The [param certificate] should include the full certificate chain up to the signing CA (certificates file can be concatenated using a general purpose text editor).
*/
//go:nosplit
func (self class) Server(key [1]gdclass.CryptoKey, certificate [1]gdclass.X509Certificate) [1]gdclass.TLSOptions { //gd:TLSOptions.server
	var r_ret = gdextension.CallStatic[gdextension.Object](methods.server, gdextension.SizeObject|(gdextension.SizeObject<<4)|(gdextension.SizeObject<<8), unsafe.Pointer(&struct {
		key         gdextension.Object
		certificate gdextension.Object
	}{gdextension.Object(gd.ObjectChecked(key[0].AsObject())), gdextension.Object(gd.ObjectChecked(certificate[0].AsObject()))}))
	var ret = [1]gdclass.TLSOptions{gd.PointerWithOwnershipTransferredToGo[gdclass.TLSOptions](r_ret)}
	return ret
}

/*
Returns [code]true[/code] if created with [method TLSOptions.server], [code]false[/code] otherwise.
*/
//go:nosplit
func (self class) IsServer() bool { //gd:TLSOptions.is_server
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_server, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if created with [method TLSOptions.client_unsafe], [code]false[/code] otherwise.
*/
//go:nosplit
func (self class) IsUnsafeClient() bool { //gd:TLSOptions.is_unsafe_client
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_unsafe_client, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the common name (domain name) override specified when creating with [method TLSOptions.client].
*/
//go:nosplit
func (self class) GetCommonNameOverride() String.Readable { //gd:TLSOptions.get_common_name_override
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_common_name_override, gdextension.SizeString, unsafe.Pointer(&struct{}{}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Returns the CA [X509Certificate] chain specified when creating with [method TLSOptions.client] or [method TLSOptions.client_unsafe].
*/
//go:nosplit
func (self class) GetTrustedCaChain() [1]gdclass.X509Certificate { //gd:TLSOptions.get_trusted_ca_chain
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_trusted_ca_chain, gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.X509Certificate{gd.PointerWithOwnershipTransferredToGo[gdclass.X509Certificate](r_ret)}
	return ret
}

/*
Returns the [CryptoKey] specified when creating with [method TLSOptions.server].
*/
//go:nosplit
func (self class) GetPrivateKey() [1]gdclass.CryptoKey { //gd:TLSOptions.get_private_key
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_private_key, gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.CryptoKey{gd.PointerWithOwnershipTransferredToGo[gdclass.CryptoKey](r_ret)}
	return ret
}

/*
Returns the [X509Certificate] specified when creating with [method TLSOptions.server].
*/
//go:nosplit
func (self class) GetOwnCertificate() [1]gdclass.X509Certificate { //gd:TLSOptions.get_own_certificate
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_own_certificate, gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.X509Certificate{gd.PointerWithOwnershipTransferredToGo[gdclass.X509Certificate](r_ret)}
	return ret
}
func (self class) AsTLSOptions() Advanced { return Advanced{pointers.AsA[gdclass.TLSOptions](self[0])} }
func (self Instance) AsTLSOptions() Instance {
	return Instance{pointers.AsA[gdclass.TLSOptions](self[0])}
}
func (self *Extension[T]) AsTLSOptions() Instance { return self.Super().AsTLSOptions() }
func (self class) AsRefCounted() [1]gd.RefCounted {
	return [1]gd.RefCounted{gd.RefCounted(pointers.AsA[gd.Object](self[0]))}
}
func (self *Extension[T]) AsRefCounted() [1]gd.RefCounted { return self.Super().AsRefCounted() }
func (self Instance) AsRefCounted() [1]gd.RefCounted {
	return [1]gd.RefCounted{gd.RefCounted(pointers.AsA[gd.Object](self[0]))}
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(RefCounted.Advanced(self.AsRefCounted()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(RefCounted.Instance(self.AsRefCounted()), name)
	}
}
func init() {
	gdclass.Register("TLSOptions", func(ptr gd.Object) any { return Instance{pointers.AsA[gdclass.TLSOptions](ptr)} })
}
