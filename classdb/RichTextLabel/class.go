// Code generated by the generate package DO NOT EDIT

// Package RichTextLabel provides methods for working with RichTextLabel object instances.
package RichTextLabel

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/CanvasItem"
import "graphics.gd/classdb/Control"
import "graphics.gd/classdb/Font"
import "graphics.gd/classdb/GUI"
import "graphics.gd/classdb/Node"
import "graphics.gd/classdb/PopupMenu"
import "graphics.gd/classdb/RichTextEffect"
import "graphics.gd/classdb/TextServer"
import "graphics.gd/classdb/Texture2D"
import "graphics.gd/classdb/VScrollBar"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Color"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/Rect2"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"
import "graphics.gd/variant/Vector2"
import "graphics.gd/variant/Vector2i"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
A control for displaying text that can contain custom fonts, images, and basic formatting. [RichTextLabel] manages these as an internal tag stack. It also adapts itself to given width/heights.
[b]Note:[/b] [method newline], [method push_paragraph], [code]"\n"[/code], [code]"\r\n"[/code], [code]p[/code] tag, and alignment tags start a new paragraph. Each paragraph is processed independently, in its own BiDi context. If you want to force line wrapping within paragraph, any other line breaking character can be used, for example, Form Feed (U+000C), Next Line (U+0085), Line Separator (U+2028).
[b]Note:[/b] Assignments to [member text] clear the tag stack and reconstruct it from the property's contents. Any edits made to [member text] will erase previous edits made from other manual sources such as [method append_text] and the [code]push_*[/code] / [method pop] methods.
[b]Note:[/b] RichTextLabel doesn't support entangled BBCode tags. For example, instead of using [code skip-lint][b]bold[i]bold italic[/b]italic[/i][/code], use [code skip-lint][b]bold[i]bold italic[/i][/b][i]italic[/i][/code].
[b]Note:[/b] [code]push_pop_*[/code] functions won't affect BBCode.
[b]Note:[/b] Unlike [Label], [RichTextLabel] doesn't have a [i]property[/i] to horizontally align text to the center. Instead, enable [member bbcode_enabled] and surround the text in a [code skip-lint][center][/code] tag as follows: [code skip-lint][center]Example[/center][/code]. There is currently no built-in way to vertically align text either, but this can be emulated by relying on anchors/containers and the [member fit_content] property.
*/
type Instance [1]gdclass.RichTextLabel

func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

type Expanded [1]gdclass.RichTextLabel

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsRichTextLabel() Instance
}

/*
Returns the text without BBCode mark-up.
*/
func (self Instance) GetParsedText() string { //gd:RichTextLabel.get_parsed_text
	return string(Advanced(self).GetParsedText().String())
}

/*
Adds raw non-BBCode-parsed text to the tag stack.
*/
func (self Instance) AddText(text string) { //gd:RichTextLabel.add_text
	Advanced(self).AddText(String.New(text))
}

/*
Adds an image's opening and closing tags to the tag stack, optionally providing a [param width] and [param height] to resize the image, a [param color] to tint the image and a [param region] to only use parts of the image.
If [param width] or [param height] is set to 0, the image size will be adjusted in order to keep the original aspect ratio.
If [param width] and [param height] are not set, but [param region] is, the region's rect will be used.
[param key] is an optional identifier, that can be used to modify the image via [method update_image].
If [param pad] is set, and the image is smaller than the size specified by [param width] and [param height], the image padding is added to match the size instead of upscaling.
If [param size_in_percent] is set, [param width] and [param height] values are percentages of the control width instead of pixels.
*/
func (self Instance) AddImage(image Texture2D.Instance) { //gd:RichTextLabel.add_image
	Advanced(self).AddImage(image, int64(0), int64(0), Color.RGBA(gd.Color{1, 1, 1, 1}), 5, Rect2.PositionSize(gd.NewRect2(0, 0, 0, 0)), variant.New([1]any{}[0]), false, String.New(""), false)
}

/*
Adds an image's opening and closing tags to the tag stack, optionally providing a [param width] and [param height] to resize the image, a [param color] to tint the image and a [param region] to only use parts of the image.
If [param width] or [param height] is set to 0, the image size will be adjusted in order to keep the original aspect ratio.
If [param width] and [param height] are not set, but [param region] is, the region's rect will be used.
[param key] is an optional identifier, that can be used to modify the image via [method update_image].
If [param pad] is set, and the image is smaller than the size specified by [param width] and [param height], the image padding is added to match the size instead of upscaling.
If [param size_in_percent] is set, [param width] and [param height] values are percentages of the control width instead of pixels.
*/
func (self Expanded) AddImage(image Texture2D.Instance, width int, height int, color Color.RGBA, inline_align GUI.InlineAlignment, region Rect2.PositionSize, key any, pad bool, tooltip string, size_in_percent bool) { //gd:RichTextLabel.add_image
	Advanced(self).AddImage(image, int64(width), int64(height), Color.RGBA(color), inline_align, Rect2.PositionSize(region), variant.New(key), pad, String.New(tooltip), size_in_percent)
}

/*
Updates the existing images with the key [param key]. Only properties specified by [param mask] bits are updated. See [method add_image].
*/
func (self Instance) UpdateImage(key any, mask ImageUpdateMask, image Texture2D.Instance) { //gd:RichTextLabel.update_image
	Advanced(self).UpdateImage(variant.New(key), mask, image, int64(0), int64(0), Color.RGBA(gd.Color{1, 1, 1, 1}), 5, Rect2.PositionSize(gd.NewRect2(0, 0, 0, 0)), false, String.New(""), false)
}

/*
Updates the existing images with the key [param key]. Only properties specified by [param mask] bits are updated. See [method add_image].
*/
func (self Expanded) UpdateImage(key any, mask ImageUpdateMask, image Texture2D.Instance, width int, height int, color Color.RGBA, inline_align GUI.InlineAlignment, region Rect2.PositionSize, pad bool, tooltip string, size_in_percent bool) { //gd:RichTextLabel.update_image
	Advanced(self).UpdateImage(variant.New(key), mask, image, int64(width), int64(height), Color.RGBA(color), inline_align, Rect2.PositionSize(region), pad, String.New(tooltip), size_in_percent)
}

/*
Adds a newline tag to the tag stack.
*/
func (self Instance) Newline() { //gd:RichTextLabel.newline
	Advanced(self).Newline()
}

/*
Removes a paragraph of content from the label. Returns [code]true[/code] if the paragraph exists.
The [param paragraph] argument is the index of the paragraph to remove, it can take values in the interval [code][0, get_paragraph_count() - 1][/code].
If [param no_invalidate] is set to [code]true[/code], cache for the subsequent paragraphs is not invalidated. Use it for faster updates if deleted paragraph is fully self-contained (have no unclosed tags), or this call is part of the complex edit operation and [method invalidate_paragraph] will be called at the end of operation.
*/
func (self Instance) RemoveParagraph(paragraph int) bool { //gd:RichTextLabel.remove_paragraph
	return bool(Advanced(self).RemoveParagraph(int64(paragraph), false))
}

/*
Removes a paragraph of content from the label. Returns [code]true[/code] if the paragraph exists.
The [param paragraph] argument is the index of the paragraph to remove, it can take values in the interval [code][0, get_paragraph_count() - 1][/code].
If [param no_invalidate] is set to [code]true[/code], cache for the subsequent paragraphs is not invalidated. Use it for faster updates if deleted paragraph is fully self-contained (have no unclosed tags), or this call is part of the complex edit operation and [method invalidate_paragraph] will be called at the end of operation.
*/
func (self Expanded) RemoveParagraph(paragraph int, no_invalidate bool) bool { //gd:RichTextLabel.remove_paragraph
	return bool(Advanced(self).RemoveParagraph(int64(paragraph), no_invalidate))
}

/*
Invalidates [param paragraph] and all subsequent paragraphs cache.
*/
func (self Instance) InvalidateParagraph(paragraph int) bool { //gd:RichTextLabel.invalidate_paragraph
	return bool(Advanced(self).InvalidateParagraph(int64(paragraph)))
}

/*
Adds a [code skip-lint][font][/code] tag to the tag stack. Overrides default fonts for its duration.
Passing [code]0[/code] to [param font_size] will use the existing default font size.
*/
func (self Instance) PushFont(font Font.Instance) { //gd:RichTextLabel.push_font
	Advanced(self).PushFont(font, int64(0))
}

/*
Adds a [code skip-lint][font][/code] tag to the tag stack. Overrides default fonts for its duration.
Passing [code]0[/code] to [param font_size] will use the existing default font size.
*/
func (self Expanded) PushFont(font Font.Instance, font_size int) { //gd:RichTextLabel.push_font
	Advanced(self).PushFont(font, int64(font_size))
}

/*
Adds a [code skip-lint][font_size][/code] tag to the tag stack. Overrides default font size for its duration.
*/
func (self Instance) PushFontSize(font_size int) { //gd:RichTextLabel.push_font_size
	Advanced(self).PushFontSize(int64(font_size))
}

/*
Adds a [code skip-lint][font][/code] tag with a normal font to the tag stack.
*/
func (self Instance) PushNormal() { //gd:RichTextLabel.push_normal
	Advanced(self).PushNormal()
}

/*
Adds a [code skip-lint][font][/code] tag with a bold font to the tag stack. This is the same as adding a [code skip-lint][b][/code] tag if not currently in a [code skip-lint][i][/code] tag.
*/
func (self Instance) PushBold() { //gd:RichTextLabel.push_bold
	Advanced(self).PushBold()
}

/*
Adds a [code skip-lint][font][/code] tag with a bold italics font to the tag stack.
*/
func (self Instance) PushBoldItalics() { //gd:RichTextLabel.push_bold_italics
	Advanced(self).PushBoldItalics()
}

/*
Adds a [code skip-lint][font][/code] tag with an italics font to the tag stack. This is the same as adding an [code skip-lint][i][/code] tag if not currently in a [code skip-lint][b][/code] tag.
*/
func (self Instance) PushItalics() { //gd:RichTextLabel.push_italics
	Advanced(self).PushItalics()
}

/*
Adds a [code skip-lint][font][/code] tag with a monospace font to the tag stack.
*/
func (self Instance) PushMono() { //gd:RichTextLabel.push_mono
	Advanced(self).PushMono()
}

/*
Adds a [code skip-lint][color][/code] tag to the tag stack.
*/
func (self Instance) PushColor(color Color.RGBA) { //gd:RichTextLabel.push_color
	Advanced(self).PushColor(Color.RGBA(color))
}

/*
Adds a [code skip-lint][outline_size][/code] tag to the tag stack. Overrides default text outline size for its duration.
*/
func (self Instance) PushOutlineSize(outline_size int) { //gd:RichTextLabel.push_outline_size
	Advanced(self).PushOutlineSize(int64(outline_size))
}

/*
Adds a [code skip-lint][outline_color][/code] tag to the tag stack. Adds text outline for its duration.
*/
func (self Instance) PushOutlineColor(color Color.RGBA) { //gd:RichTextLabel.push_outline_color
	Advanced(self).PushOutlineColor(Color.RGBA(color))
}

/*
Adds a [code skip-lint][p][/code] tag to the tag stack.
*/
func (self Instance) PushParagraph(alignment GUI.HorizontalAlignment) { //gd:RichTextLabel.push_paragraph
	Advanced(self).PushParagraph(alignment, 0, String.New(""), 0, 163, Packed.New([1][]float32{}[0]...))
}

/*
Adds a [code skip-lint][p][/code] tag to the tag stack.
*/
func (self Expanded) PushParagraph(alignment GUI.HorizontalAlignment, base_direction Control.TextDirection, language string, st_parser TextServer.StructuredTextParser, justification_flags TextServer.JustificationFlag, tab_stops []float32) { //gd:RichTextLabel.push_paragraph
	Advanced(self).PushParagraph(alignment, base_direction, String.New(language), st_parser, justification_flags, Packed.New(tab_stops...))
}

/*
Adds an [code skip-lint][indent][/code] tag to the tag stack. Multiplies [param level] by current [member tab_size] to determine new margin length.
*/
func (self Instance) PushIndent(level int) { //gd:RichTextLabel.push_indent
	Advanced(self).PushIndent(int64(level))
}

/*
Adds [code skip-lint][ol][/code] or [code skip-lint][ul][/code] tag to the tag stack. Multiplies [param level] by current [member tab_size] to determine new margin length.
*/
func (self Instance) PushList(level int, atype ListType, capitalize bool) { //gd:RichTextLabel.push_list
	Advanced(self).PushList(int64(level), atype, capitalize, String.New("•"))
}

/*
Adds [code skip-lint][ol][/code] or [code skip-lint][ul][/code] tag to the tag stack. Multiplies [param level] by current [member tab_size] to determine new margin length.
*/
func (self Expanded) PushList(level int, atype ListType, capitalize bool, bullet string) { //gd:RichTextLabel.push_list
	Advanced(self).PushList(int64(level), atype, capitalize, String.New(bullet))
}

/*
Adds a meta tag to the tag stack. Similar to the BBCode [code skip-lint][url=something]{text}[/url][/code], but supports non-[String] metadata types.
If [member meta_underlined] is [code]true[/code], meta tags display an underline. This behavior can be customized with [param underline_mode].
[b]Note:[/b] Meta tags do nothing by default when clicked. To assign behavior when clicked, connect [signal meta_clicked] to a function that is called when the meta tag is clicked.
*/
func (self Instance) PushMeta(data any) { //gd:RichTextLabel.push_meta
	Advanced(self).PushMeta(variant.New(data), 1, String.New(""))
}

/*
Adds a meta tag to the tag stack. Similar to the BBCode [code skip-lint][url=something]{text}[/url][/code], but supports non-[String] metadata types.
If [member meta_underlined] is [code]true[/code], meta tags display an underline. This behavior can be customized with [param underline_mode].
[b]Note:[/b] Meta tags do nothing by default when clicked. To assign behavior when clicked, connect [signal meta_clicked] to a function that is called when the meta tag is clicked.
*/
func (self Expanded) PushMeta(data any, underline_mode MetaUnderline, tooltip string) { //gd:RichTextLabel.push_meta
	Advanced(self).PushMeta(variant.New(data), underline_mode, String.New(tooltip))
}

/*
Adds a [code skip-lint][hint][/code] tag to the tag stack. Same as BBCode [code skip-lint][hint=something]{text}[/hint][/code].
*/
func (self Instance) PushHint(description string) { //gd:RichTextLabel.push_hint
	Advanced(self).PushHint(String.New(description))
}

/*
Adds language code used for text shaping algorithm and Open-Type font features.
*/
func (self Instance) PushLanguage(language string) { //gd:RichTextLabel.push_language
	Advanced(self).PushLanguage(String.New(language))
}

/*
Adds a [code skip-lint][u][/code] tag to the tag stack.
*/
func (self Instance) PushUnderline() { //gd:RichTextLabel.push_underline
	Advanced(self).PushUnderline()
}

/*
Adds a [code skip-lint][s][/code] tag to the tag stack.
*/
func (self Instance) PushStrikethrough() { //gd:RichTextLabel.push_strikethrough
	Advanced(self).PushStrikethrough()
}

/*
Adds a [code skip-lint][table=columns,inline_align][/code] tag to the tag stack. Use [method set_table_column_expand] to set column expansion ratio. Use [method push_cell] to add cells.
*/
func (self Instance) PushTable(columns int) { //gd:RichTextLabel.push_table
	Advanced(self).PushTable(int64(columns), 0, int64(-1))
}

/*
Adds a [code skip-lint][table=columns,inline_align][/code] tag to the tag stack. Use [method set_table_column_expand] to set column expansion ratio. Use [method push_cell] to add cells.
*/
func (self Expanded) PushTable(columns int, inline_align GUI.InlineAlignment, align_to_row int) { //gd:RichTextLabel.push_table
	Advanced(self).PushTable(int64(columns), inline_align, int64(align_to_row))
}

/*
Adds a [code skip-lint][dropcap][/code] tag to the tag stack. Drop cap (dropped capital) is a decorative element at the beginning of a paragraph that is larger than the rest of the text.
*/
func (self Instance) PushDropcap(s string, font Font.Instance, size int) { //gd:RichTextLabel.push_dropcap
	Advanced(self).PushDropcap(String.New(s), font, int64(size), Rect2.PositionSize(gd.NewRect2(0, 0, 0, 0)), Color.RGBA(gd.Color{1, 1, 1, 1}), int64(0), Color.RGBA(gd.Color{0, 0, 0, 0}))
}

/*
Adds a [code skip-lint][dropcap][/code] tag to the tag stack. Drop cap (dropped capital) is a decorative element at the beginning of a paragraph that is larger than the rest of the text.
*/
func (self Expanded) PushDropcap(s string, font Font.Instance, size int, dropcap_margins Rect2.PositionSize, color Color.RGBA, outline_size int, outline_color Color.RGBA) { //gd:RichTextLabel.push_dropcap
	Advanced(self).PushDropcap(String.New(s), font, int64(size), Rect2.PositionSize(dropcap_margins), Color.RGBA(color), int64(outline_size), Color.RGBA(outline_color))
}

/*
Edits the selected column's expansion options. If [param expand] is [code]true[/code], the column expands in proportion to its expansion ratio versus the other columns' ratios.
For example, 2 columns with ratios 3 and 4 plus 70 pixels in available width would expand 30 and 40 pixels, respectively.
If [param expand] is [code]false[/code], the column will not contribute to the total ratio.
*/
func (self Instance) SetTableColumnExpand(column int, expand bool) { //gd:RichTextLabel.set_table_column_expand
	Advanced(self).SetTableColumnExpand(int64(column), expand, int64(1), true)
}

/*
Edits the selected column's expansion options. If [param expand] is [code]true[/code], the column expands in proportion to its expansion ratio versus the other columns' ratios.
For example, 2 columns with ratios 3 and 4 plus 70 pixels in available width would expand 30 and 40 pixels, respectively.
If [param expand] is [code]false[/code], the column will not contribute to the total ratio.
*/
func (self Expanded) SetTableColumnExpand(column int, expand bool, ratio int, shrink bool) { //gd:RichTextLabel.set_table_column_expand
	Advanced(self).SetTableColumnExpand(int64(column), expand, int64(ratio), shrink)
}

/*
Sets color of a table cell. Separate colors for alternating rows can be specified.
*/
func (self Instance) SetCellRowBackgroundColor(odd_row_bg Color.RGBA, even_row_bg Color.RGBA) { //gd:RichTextLabel.set_cell_row_background_color
	Advanced(self).SetCellRowBackgroundColor(Color.RGBA(odd_row_bg), Color.RGBA(even_row_bg))
}

/*
Sets color of a table cell border.
*/
func (self Instance) SetCellBorderColor(color Color.RGBA) { //gd:RichTextLabel.set_cell_border_color
	Advanced(self).SetCellBorderColor(Color.RGBA(color))
}

/*
Sets minimum and maximum size overrides for a table cell.
*/
func (self Instance) SetCellSizeOverride(min_size Vector2.XY, max_size Vector2.XY) { //gd:RichTextLabel.set_cell_size_override
	Advanced(self).SetCellSizeOverride(Vector2.XY(min_size), Vector2.XY(max_size))
}

/*
Sets inner padding of a table cell.
*/
func (self Instance) SetCellPadding(padding Rect2.PositionSize) { //gd:RichTextLabel.set_cell_padding
	Advanced(self).SetCellPadding(Rect2.PositionSize(padding))
}

/*
Adds a [code skip-lint][cell][/code] tag to the tag stack. Must be inside a [code skip-lint][table][/code] tag. See [method push_table] for details. Use [method set_table_column_expand] to set column expansion ratio, [method set_cell_border_color] to set cell border, [method set_cell_row_background_color] to set cell background, [method set_cell_size_override] to override cell size, and [method set_cell_padding] to set padding.
*/
func (self Instance) PushCell() { //gd:RichTextLabel.push_cell
	Advanced(self).PushCell()
}

/*
Adds a [code skip-lint][fgcolor][/code] tag to the tag stack.
*/
func (self Instance) PushFgcolor(fgcolor Color.RGBA) { //gd:RichTextLabel.push_fgcolor
	Advanced(self).PushFgcolor(Color.RGBA(fgcolor))
}

/*
Adds a [code skip-lint][bgcolor][/code] tag to the tag stack.
*/
func (self Instance) PushBgcolor(bgcolor Color.RGBA) { //gd:RichTextLabel.push_bgcolor
	Advanced(self).PushBgcolor(Color.RGBA(bgcolor))
}

/*
Adds a custom effect tag to the tag stack. The effect does not need to be in [member custom_effects]. The environment is directly passed to the effect.
*/
func (self Instance) PushCustomfx(effect RichTextEffect.Instance, env map[string]interface{}) { //gd:RichTextLabel.push_customfx
	Advanced(self).PushCustomfx(effect, gd.DictionaryFromMap(env))
}

/*
Adds a context marker to the tag stack. See [method pop_context].
*/
func (self Instance) PushContext() { //gd:RichTextLabel.push_context
	Advanced(self).PushContext()
}

/*
Terminates tags opened after the last [method push_context] call (including context marker), or all tags if there's no context marker on the stack.
*/
func (self Instance) PopContext() { //gd:RichTextLabel.pop_context
	Advanced(self).PopContext()
}

/*
Terminates the current tag. Use after [code]push_*[/code] methods to close BBCodes manually. Does not need to follow [code]add_*[/code] methods.
*/
func (self Instance) Pop() { //gd:RichTextLabel.pop
	Advanced(self).Pop()
}

/*
Terminates all tags opened by [code]push_*[/code] methods.
*/
func (self Instance) PopAll() { //gd:RichTextLabel.pop_all
	Advanced(self).PopAll()
}

/*
Clears the tag stack, causing the label to display nothing.
[b]Note:[/b] This method does not affect [member text], and its contents will show again if the label is redrawn. However, setting [member text] to an empty [String] also clears the stack.
*/
func (self Instance) Clear() { //gd:RichTextLabel.clear
	Advanced(self).Clear()
}

/*
Returns the vertical scrollbar.
[b]Warning:[/b] This is a required internal node, removing and freeing it may cause a crash. If you wish to hide it or any of its children, use their [member CanvasItem.visible] property.
*/
func (self Instance) GetVScrollBar() VScrollBar.Instance { //gd:RichTextLabel.get_v_scroll_bar
	return VScrollBar.Instance(Advanced(self).GetVScrollBar())
}

/*
Scrolls the window's top line to match [param line].
*/
func (self Instance) ScrollToLine(line int) { //gd:RichTextLabel.scroll_to_line
	Advanced(self).ScrollToLine(int64(line))
}

/*
Scrolls the window's top line to match first line of the [param paragraph].
*/
func (self Instance) ScrollToParagraph(paragraph int) { //gd:RichTextLabel.scroll_to_paragraph
	Advanced(self).ScrollToParagraph(int64(paragraph))
}

/*
Scrolls to the beginning of the current selection.
*/
func (self Instance) ScrollToSelection() { //gd:RichTextLabel.scroll_to_selection
	Advanced(self).ScrollToSelection()
}

/*
Returns the current selection first character index if a selection is active, [code]-1[/code] otherwise. Does not include BBCodes.
*/
func (self Instance) GetSelectionFrom() int { //gd:RichTextLabel.get_selection_from
	return int(int(Advanced(self).GetSelectionFrom()))
}

/*
Returns the current selection last character index if a selection is active, [code]-1[/code] otherwise. Does not include BBCodes.
*/
func (self Instance) GetSelectionTo() int { //gd:RichTextLabel.get_selection_to
	return int(int(Advanced(self).GetSelectionTo()))
}

/*
Returns the current selection vertical line offset if a selection is active, [code]-1.0[/code] otherwise.
*/
func (self Instance) GetSelectionLineOffset() Float.X { //gd:RichTextLabel.get_selection_line_offset
	return Float.X(Float.X(Advanced(self).GetSelectionLineOffset()))
}

/*
Select all the text.
If [member selection_enabled] is [code]false[/code], no selection will occur.
*/
func (self Instance) SelectAll() { //gd:RichTextLabel.select_all
	Advanced(self).SelectAll()
}

/*
Returns the current selection text. Does not include BBCodes.
*/
func (self Instance) GetSelectedText() string { //gd:RichTextLabel.get_selected_text
	return string(Advanced(self).GetSelectedText().String())
}

/*
Clears the current selection.
*/
func (self Instance) Deselect() { //gd:RichTextLabel.deselect
	Advanced(self).Deselect()
}

/*
The assignment version of [method append_text]. Clears the tag stack and inserts the new content.
*/
func (self Instance) ParseBbcode(bbcode string) { //gd:RichTextLabel.parse_bbcode
	Advanced(self).ParseBbcode(String.New(bbcode))
}

/*
Parses [param bbcode] and adds tags to the tag stack as needed.
[b]Note:[/b] Using this method, you can't close a tag that was opened in a previous [method append_text] call. This is done to improve performance, especially when updating large RichTextLabels since rebuilding the whole BBCode every time would be slower. If you absolutely need to close a tag in a future method call, append the [member text] instead of using [method append_text].
*/
func (self Instance) AppendText(bbcode string) { //gd:RichTextLabel.append_text
	Advanced(self).AppendText(String.New(bbcode))
}

/*
If [member threaded] is enabled, returns [code]true[/code] if the background thread has finished text processing, otherwise always return [code]true[/code].
*/
func (self Instance) IsReady() bool { //gd:RichTextLabel.is_ready
	return bool(Advanced(self).IsReady())
}

/*
If [member threaded] is enabled, returns [code]true[/code] if the background thread has finished text processing, otherwise always return [code]true[/code].
*/
func (self Instance) IsFinished() bool { //gd:RichTextLabel.is_finished
	return bool(Advanced(self).IsFinished())
}

/*
Returns the line number of the character position provided. Line and character numbers are both zero-indexed.
[b]Note:[/b] If [member threaded] is enabled, this method returns a value for the loaded part of the document. Use [method is_finished] or [signal finished] to determine whether document is fully loaded.
*/
func (self Instance) GetCharacterLine(character int) int { //gd:RichTextLabel.get_character_line
	return int(int(Advanced(self).GetCharacterLine(int64(character))))
}

/*
Returns the paragraph number of the character position provided. Paragraph and character numbers are both zero-indexed.
[b]Note:[/b] If [member threaded] is enabled, this method returns a value for the loaded part of the document. Use [method is_finished] or [signal finished] to determine whether document is fully loaded.
*/
func (self Instance) GetCharacterParagraph(character int) int { //gd:RichTextLabel.get_character_paragraph
	return int(int(Advanced(self).GetCharacterParagraph(int64(character))))
}

/*
Returns the total number of characters from text tags. Does not include BBCodes.
*/
func (self Instance) GetTotalCharacterCount() int { //gd:RichTextLabel.get_total_character_count
	return int(int(Advanced(self).GetTotalCharacterCount()))
}

/*
Returns the total number of lines in the text. Wrapped text is counted as multiple lines.
[b]Note:[/b] If [member visible_characters_behavior] is set to [constant TextServer.VC_CHARS_BEFORE_SHAPING] only visible wrapped lines are counted.
[b]Note:[/b] If [member threaded] is enabled, this method returns a value for the loaded part of the document. Use [method is_finished] or [signal finished] to determine whether document is fully loaded.
*/
func (self Instance) GetLineCount() int { //gd:RichTextLabel.get_line_count
	return int(int(Advanced(self).GetLineCount()))
}

/*
Returns the indexes of the first and last visible characters for the given [param line], as a [Vector2i].
[b]Note:[/b] If [member visible_characters_behavior] is set to [constant TextServer.VC_CHARS_BEFORE_SHAPING] only visible wrapped lines are counted.
[b]Note:[/b] If [member threaded] is enabled, this method returns a value for the loaded part of the document. Use [method is_finished] or [signal finished] to determine whether document is fully loaded.
*/
func (self Instance) GetLineRange(line int) Vector2i.XY { //gd:RichTextLabel.get_line_range
	return Vector2i.XY(Advanced(self).GetLineRange(int64(line)))
}

/*
Returns the number of visible lines.
[b]Note:[/b] If [member threaded] is enabled, this method returns a value for the loaded part of the document. Use [method is_finished] or [signal finished] to determine whether document is fully loaded.
*/
func (self Instance) GetVisibleLineCount() int { //gd:RichTextLabel.get_visible_line_count
	return int(int(Advanced(self).GetVisibleLineCount()))
}

/*
Returns the total number of paragraphs (newlines or [code]p[/code] tags in the tag stack's text tags). Considers wrapped text as one paragraph.
*/
func (self Instance) GetParagraphCount() int { //gd:RichTextLabel.get_paragraph_count
	return int(int(Advanced(self).GetParagraphCount()))
}

/*
Returns the number of visible paragraphs. A paragraph is considered visible if at least one of its lines is visible.
[b]Note:[/b] If [member threaded] is enabled, this method returns a value for the loaded part of the document. Use [method is_finished] or [signal finished] to determine whether document is fully loaded.
*/
func (self Instance) GetVisibleParagraphCount() int { //gd:RichTextLabel.get_visible_paragraph_count
	return int(int(Advanced(self).GetVisibleParagraphCount()))
}

/*
Returns the height of the content.
[b]Note:[/b] If [member threaded] is enabled, this method returns a value for the loaded part of the document. Use [method is_finished] or [signal finished] to determine whether document is fully loaded.
*/
func (self Instance) GetContentHeight() int { //gd:RichTextLabel.get_content_height
	return int(int(Advanced(self).GetContentHeight()))
}

/*
Returns the width of the content.
[b]Note:[/b] If [member threaded] is enabled, this method returns a value for the loaded part of the document. Use [method is_finished] or [signal finished] to determine whether document is fully loaded.
*/
func (self Instance) GetContentWidth() int { //gd:RichTextLabel.get_content_width
	return int(int(Advanced(self).GetContentWidth()))
}

/*
Returns the vertical offset of the line found at the provided index.
[b]Note:[/b] If [member threaded] is enabled, this method returns a value for the loaded part of the document. Use [method is_finished] or [signal finished] to determine whether document is fully loaded.
*/
func (self Instance) GetLineOffset(line int) Float.X { //gd:RichTextLabel.get_line_offset
	return Float.X(Float.X(Advanced(self).GetLineOffset(int64(line))))
}

/*
Returns the vertical offset of the paragraph found at the provided index.
[b]Note:[/b] If [member threaded] is enabled, this method returns a value for the loaded part of the document. Use [method is_finished] or [signal finished] to determine whether document is fully loaded.
*/
func (self Instance) GetParagraphOffset(paragraph int) Float.X { //gd:RichTextLabel.get_paragraph_offset
	return Float.X(Float.X(Advanced(self).GetParagraphOffset(int64(paragraph))))
}

/*
Parses BBCode parameter [param expressions] into a dictionary.
*/
func (self Instance) ParseExpressionsForValues(expressions []string) map[string]interface{} { //gd:RichTextLabel.parse_expressions_for_values
	return map[string]interface{}(gd.DictionaryAs[map[string]interface{}](Advanced(self).ParseExpressionsForValues(Packed.MakeStrings(expressions...))))
}

/*
Installs a custom effect. This can also be done in the Inspector through the [member custom_effects] property. [param effect] should be a valid [RichTextEffect].
[b]Example:[/b] With the following script extending from [RichTextEffect]:
[codeblock]
# effect.gd
class_name MyCustomEffect
extends RichTextEffect

var bbcode = "my_custom_effect"

# ...
[/codeblock]
The above effect can be installed in [RichTextLabel] from a script:
[codeblock]
# rich_text_label.gd
extends RichTextLabel

func _ready():

	install_effect(MyCustomEffect.new())

	# Alternatively, if not using `class_name` in the script that extends RichTextEffect:
	install_effect(preload("res://effect.gd").new())

[/codeblock]
*/
func (self Instance) InstallEffect(effect any) { //gd:RichTextLabel.install_effect
	Advanced(self).InstallEffect(variant.New(effect))
}

/*
Returns the [PopupMenu] of this [RichTextLabel]. By default, this menu is displayed when right-clicking on the [RichTextLabel].
You can add custom menu items or remove standard ones. Make sure your IDs don't conflict with the standard ones (see [enum MenuItems]). For example:
[codeblocks]
[gdscript]
func _ready():

	var menu = get_menu()
	# Remove "Select All" item.
	menu.remove_item(MENU_SELECT_ALL)
	# Add custom items.
	menu.add_separator()
	menu.add_item("Duplicate Text", MENU_MAX + 1)
	# Connect callback.
	menu.id_pressed.connect(_on_item_pressed)

func _on_item_pressed(id):

	if id == MENU_MAX + 1:
	    add_text("\n" + get_parsed_text())

[/gdscript]
[csharp]
public override void _Ready()

	{
	    var menu = GetMenu();
	    // Remove "Select All" item.
	    menu.RemoveItem(RichTextLabel.MenuItems.SelectAll);
	    // Add custom items.
	    menu.AddSeparator();
	    menu.AddItem("Duplicate Text", RichTextLabel.MenuItems.Max + 1);
	    // Add event handler.
	    menu.IdPressed += OnItemPressed;
	}

public void OnItemPressed(int id)

	{
	    if (id == TextEdit.MenuItems.Max + 1)
	    {
	        AddText("\n" + GetParsedText());
	    }
	}

[/csharp]
[/codeblocks]
[b]Warning:[/b] This is a required internal node, removing and freeing it may cause a crash. If you wish to hide it or any of its children, use their [member Window.visible] property.
*/
func (self Instance) GetMenu() PopupMenu.Instance { //gd:RichTextLabel.get_menu
	return PopupMenu.Instance(Advanced(self).GetMenu())
}

/*
Returns whether the menu is visible. Use this instead of [code]get_menu().visible[/code] to improve performance (so the creation of the menu is avoided).
*/
func (self Instance) IsMenuVisible() bool { //gd:RichTextLabel.is_menu_visible
	return bool(Advanced(self).IsMenuVisible())
}

/*
Executes a given action as defined in the [enum MenuItems] enum.
*/
func (self Instance) MenuOption(option int) { //gd:RichTextLabel.menu_option
	Advanced(self).MenuOption(int64(option))
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.RichTextLabel

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {
	object := [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gdextension.Host.Objects.Make(pointers.Get(gd.NewStringName("RichTextLabel"))))})}
	casted := Instance{*(*gdclass.RichTextLabel)(unsafe.Pointer(&object))}
	object[0].Notification(0, false)
	return casted
}

func (self Instance) BbcodeEnabled() bool {
	return bool(class(self).IsUsingBbcode())
}

func (self Instance) SetBbcodeEnabled(value bool) {
	class(self).SetUseBbcode(value)
}

func (self Instance) Text() string {
	return string(class(self).GetText().String())
}

func (self Instance) SetText(value string) {
	class(self).SetText(String.New(value))
}

func (self Instance) FitContent() bool {
	return bool(class(self).IsFitContentEnabled())
}

func (self Instance) SetFitContent(value bool) {
	class(self).SetFitContent(value)
}

func (self Instance) ScrollActive() bool {
	return bool(class(self).IsScrollActive())
}

func (self Instance) SetScrollActive(value bool) {
	class(self).SetScrollActive(value)
}

func (self Instance) ScrollFollowing() bool {
	return bool(class(self).IsScrollFollowing())
}

func (self Instance) SetScrollFollowing(value bool) {
	class(self).SetScrollFollow(value)
}

func (self Instance) AutowrapMode() TextServer.AutowrapMode {
	return TextServer.AutowrapMode(class(self).GetAutowrapMode())
}

func (self Instance) SetAutowrapMode(value TextServer.AutowrapMode) {
	class(self).SetAutowrapMode(value)
}

func (self Instance) TabSize() int {
	return int(int(class(self).GetTabSize()))
}

func (self Instance) SetTabSize(value int) {
	class(self).SetTabSize(int64(value))
}

func (self Instance) ContextMenuEnabled() bool {
	return bool(class(self).IsContextMenuEnabled())
}

func (self Instance) SetContextMenuEnabled(value bool) {
	class(self).SetContextMenuEnabled(value)
}

func (self Instance) ShortcutKeysEnabled() bool {
	return bool(class(self).IsShortcutKeysEnabled())
}

func (self Instance) SetShortcutKeysEnabled(value bool) {
	class(self).SetShortcutKeysEnabled(value)
}

func (self Instance) HorizontalAlignment() GUI.HorizontalAlignment {
	return GUI.HorizontalAlignment(class(self).GetHorizontalAlignment())
}

func (self Instance) SetHorizontalAlignment(value GUI.HorizontalAlignment) {
	class(self).SetHorizontalAlignment(value)
}

func (self Instance) VerticalAlignment() GUI.VerticalAlignment {
	return GUI.VerticalAlignment(class(self).GetVerticalAlignment())
}

func (self Instance) SetVerticalAlignment(value GUI.VerticalAlignment) {
	class(self).SetVerticalAlignment(value)
}

func (self Instance) JustificationFlags() TextServer.JustificationFlag {
	return TextServer.JustificationFlag(class(self).GetJustificationFlags())
}

func (self Instance) SetJustificationFlags(value TextServer.JustificationFlag) {
	class(self).SetJustificationFlags(value)
}

func (self Instance) TabStops() []float32 {
	return []float32(slices.Collect(class(self).GetTabStops().Values()))
}

func (self Instance) SetTabStops(value []float32) {
	class(self).SetTabStops(Packed.New(value...))
}

func (self Instance) CustomEffects() []any {
	return []any(gd.ArrayAs[[]any](gd.InternalArray(class(self).GetEffects())))
}

func (self Instance) SetCustomEffects(value []any) {
	class(self).SetEffects(gd.EngineArrayFromSlice(value))
}

func (self Instance) MetaUnderlined() bool {
	return bool(class(self).IsMetaUnderlined())
}

func (self Instance) SetMetaUnderlined(value bool) {
	class(self).SetMetaUnderline(value)
}

func (self Instance) HintUnderlined() bool {
	return bool(class(self).IsHintUnderlined())
}

func (self Instance) SetHintUnderlined(value bool) {
	class(self).SetHintUnderline(value)
}

func (self Instance) Threaded() bool {
	return bool(class(self).IsThreaded())
}

func (self Instance) SetThreaded(value bool) {
	class(self).SetThreaded(value)
}

func (self Instance) ProgressBarDelay() int {
	return int(int(class(self).GetProgressBarDelay()))
}

func (self Instance) SetProgressBarDelay(value int) {
	class(self).SetProgressBarDelay(int64(value))
}

func (self Instance) SelectionEnabled() bool {
	return bool(class(self).IsSelectionEnabled())
}

func (self Instance) SetSelectionEnabled(value bool) {
	class(self).SetSelectionEnabled(value)
}

func (self Instance) DeselectOnFocusLossEnabled() bool {
	return bool(class(self).IsDeselectOnFocusLossEnabled())
}

func (self Instance) SetDeselectOnFocusLossEnabled(value bool) {
	class(self).SetDeselectOnFocusLossEnabled(value)
}

func (self Instance) DragAndDropSelectionEnabled() bool {
	return bool(class(self).IsDragAndDropSelectionEnabled())
}

func (self Instance) SetDragAndDropSelectionEnabled(value bool) {
	class(self).SetDragAndDropSelectionEnabled(value)
}

func (self Instance) VisibleCharacters() int {
	return int(int(class(self).GetVisibleCharacters()))
}

func (self Instance) SetVisibleCharacters(value int) {
	class(self).SetVisibleCharacters(int64(value))
}

func (self Instance) VisibleCharactersBehavior() TextServer.VisibleCharactersBehavior {
	return TextServer.VisibleCharactersBehavior(class(self).GetVisibleCharactersBehavior())
}

func (self Instance) SetVisibleCharactersBehavior(value TextServer.VisibleCharactersBehavior) {
	class(self).SetVisibleCharactersBehavior(value)
}

func (self Instance) VisibleRatio() Float.X {
	return Float.X(Float.X(class(self).GetVisibleRatio()))
}

func (self Instance) SetVisibleRatio(value Float.X) {
	class(self).SetVisibleRatio(float64(value))
}

func (self Instance) TextDirection() Control.TextDirection {
	return Control.TextDirection(class(self).GetTextDirection())
}

func (self Instance) SetTextDirection(value Control.TextDirection) {
	class(self).SetTextDirection(value)
}

func (self Instance) Language() string {
	return string(class(self).GetLanguage().String())
}

func (self Instance) SetLanguage(value string) {
	class(self).SetLanguage(String.New(value))
}

func (self Instance) StructuredTextBidiOverride() TextServer.StructuredTextParser {
	return TextServer.StructuredTextParser(class(self).GetStructuredTextBidiOverride())
}

func (self Instance) SetStructuredTextBidiOverride(value TextServer.StructuredTextParser) {
	class(self).SetStructuredTextBidiOverride(value)
}

func (self Instance) StructuredTextBidiOverrideOptions() []any {
	return []any(gd.ArrayAs[[]any](gd.InternalArray(class(self).GetStructuredTextBidiOverrideOptions())))
}

func (self Instance) SetStructuredTextBidiOverrideOptions(value []any) {
	class(self).SetStructuredTextBidiOverrideOptions(gd.EngineArrayFromSlice(value))
}

/*
Returns the text without BBCode mark-up.
*/
//go:nosplit
func (self class) GetParsedText() String.Readable { //gd:RichTextLabel.get_parsed_text
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_get_parsed_text), gdextension.SizeString, unsafe.Pointer(&struct{}{}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Adds raw non-BBCode-parsed text to the tag stack.
*/
//go:nosplit
func (self class) AddText(text String.Readable) { //gd:RichTextLabel.add_text
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_add_text), 0|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ text gdextension.String }{pointers.Get(gd.InternalString(text))}))
}

//go:nosplit
func (self class) SetText(text String.Readable) { //gd:RichTextLabel.set_text
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_set_text), 0|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ text gdextension.String }{pointers.Get(gd.InternalString(text))}))
}

/*
Adds an image's opening and closing tags to the tag stack, optionally providing a [param width] and [param height] to resize the image, a [param color] to tint the image and a [param region] to only use parts of the image.
If [param width] or [param height] is set to 0, the image size will be adjusted in order to keep the original aspect ratio.
If [param width] and [param height] are not set, but [param region] is, the region's rect will be used.
[param key] is an optional identifier, that can be used to modify the image via [method update_image].
If [param pad] is set, and the image is smaller than the size specified by [param width] and [param height], the image padding is added to match the size instead of upscaling.
If [param size_in_percent] is set, [param width] and [param height] values are percentages of the control width instead of pixels.
*/
//go:nosplit
func (self class) AddImage(image [1]gdclass.Texture2D, width int64, height int64, color Color.RGBA, inline_align GUI.InlineAlignment, region Rect2.PositionSize, key variant.Any, pad bool, tooltip String.Readable, size_in_percent bool) { //gd:RichTextLabel.add_image
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_add_image), 0|(gdextension.SizeObject<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeColor<<16)|(gdextension.SizeInt<<20)|(gdextension.SizeRect2<<24)|(gdextension.SizeVariant<<28)|(gdextension.SizeBool<<32)|(gdextension.SizeString<<36)|(gdextension.SizeBool<<40), unsafe.Pointer(&struct {
		image           gdextension.Object
		width           int64
		height          int64
		color           Color.RGBA
		inline_align    GUI.InlineAlignment
		region          Rect2.PositionSize
		key             gdextension.Variant
		pad             bool
		tooltip         gdextension.String
		size_in_percent bool
	}{gdextension.Object(gd.ObjectChecked(image[0].AsObject())), width, height, color, inline_align, region, gdextension.Variant(pointers.Get(gd.InternalVariant(key))), pad, pointers.Get(gd.InternalString(tooltip)), size_in_percent}))
}

/*
Updates the existing images with the key [param key]. Only properties specified by [param mask] bits are updated. See [method add_image].
*/
//go:nosplit
func (self class) UpdateImage(key variant.Any, mask ImageUpdateMask, image [1]gdclass.Texture2D, width int64, height int64, color Color.RGBA, inline_align GUI.InlineAlignment, region Rect2.PositionSize, pad bool, tooltip String.Readable, size_in_percent bool) { //gd:RichTextLabel.update_image
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_update_image), 0|(gdextension.SizeVariant<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeObject<<12)|(gdextension.SizeInt<<16)|(gdextension.SizeInt<<20)|(gdextension.SizeColor<<24)|(gdextension.SizeInt<<28)|(gdextension.SizeRect2<<32)|(gdextension.SizeBool<<36)|(gdextension.SizeString<<40)|(gdextension.SizeBool<<44), unsafe.Pointer(&struct {
		key             gdextension.Variant
		mask            ImageUpdateMask
		image           gdextension.Object
		width           int64
		height          int64
		color           Color.RGBA
		inline_align    GUI.InlineAlignment
		region          Rect2.PositionSize
		pad             bool
		tooltip         gdextension.String
		size_in_percent bool
	}{gdextension.Variant(pointers.Get(gd.InternalVariant(key))), mask, gdextension.Object(gd.ObjectChecked(image[0].AsObject())), width, height, color, inline_align, region, pad, pointers.Get(gd.InternalString(tooltip)), size_in_percent}))
}

/*
Adds a newline tag to the tag stack.
*/
//go:nosplit
func (self class) Newline() { //gd:RichTextLabel.newline
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_newline), 0, unsafe.Pointer(&struct{}{}))
}

/*
Removes a paragraph of content from the label. Returns [code]true[/code] if the paragraph exists.
The [param paragraph] argument is the index of the paragraph to remove, it can take values in the interval [code][0, get_paragraph_count() - 1][/code].
If [param no_invalidate] is set to [code]true[/code], cache for the subsequent paragraphs is not invalidated. Use it for faster updates if deleted paragraph is fully self-contained (have no unclosed tags), or this call is part of the complex edit operation and [method invalidate_paragraph] will be called at the end of operation.
*/
//go:nosplit
func (self class) RemoveParagraph(paragraph int64, no_invalidate bool) bool { //gd:RichTextLabel.remove_paragraph
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_remove_paragraph), gdextension.SizeBool|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		paragraph     int64
		no_invalidate bool
	}{paragraph, no_invalidate}))
	var ret = r_ret
	return ret
}

/*
Invalidates [param paragraph] and all subsequent paragraphs cache.
*/
//go:nosplit
func (self class) InvalidateParagraph(paragraph int64) bool { //gd:RichTextLabel.invalidate_paragraph
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_invalidate_paragraph), gdextension.SizeBool|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ paragraph int64 }{paragraph}))
	var ret = r_ret
	return ret
}

/*
Adds a [code skip-lint][font][/code] tag to the tag stack. Overrides default fonts for its duration.
Passing [code]0[/code] to [param font_size] will use the existing default font size.
*/
//go:nosplit
func (self class) PushFont(font [1]gdclass.Font, font_size int64) { //gd:RichTextLabel.push_font
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_push_font), 0|(gdextension.SizeObject<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		font      gdextension.Object
		font_size int64
	}{gdextension.Object(gd.ObjectChecked(font[0].AsObject())), font_size}))
}

/*
Adds a [code skip-lint][font_size][/code] tag to the tag stack. Overrides default font size for its duration.
*/
//go:nosplit
func (self class) PushFontSize(font_size int64) { //gd:RichTextLabel.push_font_size
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_push_font_size), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ font_size int64 }{font_size}))
}

/*
Adds a [code skip-lint][font][/code] tag with a normal font to the tag stack.
*/
//go:nosplit
func (self class) PushNormal() { //gd:RichTextLabel.push_normal
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_push_normal), 0, unsafe.Pointer(&struct{}{}))
}

/*
Adds a [code skip-lint][font][/code] tag with a bold font to the tag stack. This is the same as adding a [code skip-lint][b][/code] tag if not currently in a [code skip-lint][i][/code] tag.
*/
//go:nosplit
func (self class) PushBold() { //gd:RichTextLabel.push_bold
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_push_bold), 0, unsafe.Pointer(&struct{}{}))
}

/*
Adds a [code skip-lint][font][/code] tag with a bold italics font to the tag stack.
*/
//go:nosplit
func (self class) PushBoldItalics() { //gd:RichTextLabel.push_bold_italics
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_push_bold_italics), 0, unsafe.Pointer(&struct{}{}))
}

/*
Adds a [code skip-lint][font][/code] tag with an italics font to the tag stack. This is the same as adding an [code skip-lint][i][/code] tag if not currently in a [code skip-lint][b][/code] tag.
*/
//go:nosplit
func (self class) PushItalics() { //gd:RichTextLabel.push_italics
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_push_italics), 0, unsafe.Pointer(&struct{}{}))
}

/*
Adds a [code skip-lint][font][/code] tag with a monospace font to the tag stack.
*/
//go:nosplit
func (self class) PushMono() { //gd:RichTextLabel.push_mono
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_push_mono), 0, unsafe.Pointer(&struct{}{}))
}

/*
Adds a [code skip-lint][color][/code] tag to the tag stack.
*/
//go:nosplit
func (self class) PushColor(color Color.RGBA) { //gd:RichTextLabel.push_color
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_push_color), 0|(gdextension.SizeColor<<4), unsafe.Pointer(&struct{ color Color.RGBA }{color}))
}

/*
Adds a [code skip-lint][outline_size][/code] tag to the tag stack. Overrides default text outline size for its duration.
*/
//go:nosplit
func (self class) PushOutlineSize(outline_size int64) { //gd:RichTextLabel.push_outline_size
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_push_outline_size), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ outline_size int64 }{outline_size}))
}

/*
Adds a [code skip-lint][outline_color][/code] tag to the tag stack. Adds text outline for its duration.
*/
//go:nosplit
func (self class) PushOutlineColor(color Color.RGBA) { //gd:RichTextLabel.push_outline_color
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_push_outline_color), 0|(gdextension.SizeColor<<4), unsafe.Pointer(&struct{ color Color.RGBA }{color}))
}

/*
Adds a [code skip-lint][p][/code] tag to the tag stack.
*/
//go:nosplit
func (self class) PushParagraph(alignment GUI.HorizontalAlignment, base_direction Control.TextDirection, language String.Readable, st_parser TextServer.StructuredTextParser, justification_flags TextServer.JustificationFlag, tab_stops Packed.Array[float32]) { //gd:RichTextLabel.push_paragraph
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_push_paragraph), 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeString<<12)|(gdextension.SizeInt<<16)|(gdextension.SizeInt<<20)|(gdextension.SizePackedArray<<24), unsafe.Pointer(&struct {
		alignment           GUI.HorizontalAlignment
		base_direction      Control.TextDirection
		language            gdextension.String
		st_parser           TextServer.StructuredTextParser
		justification_flags TextServer.JustificationFlag
		tab_stops           gdextension.PackedArray[float32]
	}{alignment, base_direction, pointers.Get(gd.InternalString(language)), st_parser, justification_flags, pointers.Get(gd.InternalPacked[gd.PackedFloat32Array, float32](tab_stops))}))
}

/*
Adds an [code skip-lint][indent][/code] tag to the tag stack. Multiplies [param level] by current [member tab_size] to determine new margin length.
*/
//go:nosplit
func (self class) PushIndent(level int64) { //gd:RichTextLabel.push_indent
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_push_indent), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ level int64 }{level}))
}

/*
Adds [code skip-lint][ol][/code] or [code skip-lint][ul][/code] tag to the tag stack. Multiplies [param level] by current [member tab_size] to determine new margin length.
*/
//go:nosplit
func (self class) PushList(level int64, atype ListType, capitalize bool, bullet String.Readable) { //gd:RichTextLabel.push_list
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_push_list), 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeBool<<12)|(gdextension.SizeString<<16), unsafe.Pointer(&struct {
		level      int64
		atype      ListType
		capitalize bool
		bullet     gdextension.String
	}{level, atype, capitalize, pointers.Get(gd.InternalString(bullet))}))
}

/*
Adds a meta tag to the tag stack. Similar to the BBCode [code skip-lint][url=something]{text}[/url][/code], but supports non-[String] metadata types.
If [member meta_underlined] is [code]true[/code], meta tags display an underline. This behavior can be customized with [param underline_mode].
[b]Note:[/b] Meta tags do nothing by default when clicked. To assign behavior when clicked, connect [signal meta_clicked] to a function that is called when the meta tag is clicked.
*/
//go:nosplit
func (self class) PushMeta(data variant.Any, underline_mode MetaUnderline, tooltip String.Readable) { //gd:RichTextLabel.push_meta
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_push_meta), 0|(gdextension.SizeVariant<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeString<<12), unsafe.Pointer(&struct {
		data           gdextension.Variant
		underline_mode MetaUnderline
		tooltip        gdextension.String
	}{gdextension.Variant(pointers.Get(gd.InternalVariant(data))), underline_mode, pointers.Get(gd.InternalString(tooltip))}))
}

/*
Adds a [code skip-lint][hint][/code] tag to the tag stack. Same as BBCode [code skip-lint][hint=something]{text}[/hint][/code].
*/
//go:nosplit
func (self class) PushHint(description String.Readable) { //gd:RichTextLabel.push_hint
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_push_hint), 0|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ description gdextension.String }{pointers.Get(gd.InternalString(description))}))
}

/*
Adds language code used for text shaping algorithm and Open-Type font features.
*/
//go:nosplit
func (self class) PushLanguage(language String.Readable) { //gd:RichTextLabel.push_language
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_push_language), 0|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ language gdextension.String }{pointers.Get(gd.InternalString(language))}))
}

/*
Adds a [code skip-lint][u][/code] tag to the tag stack.
*/
//go:nosplit
func (self class) PushUnderline() { //gd:RichTextLabel.push_underline
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_push_underline), 0, unsafe.Pointer(&struct{}{}))
}

/*
Adds a [code skip-lint][s][/code] tag to the tag stack.
*/
//go:nosplit
func (self class) PushStrikethrough() { //gd:RichTextLabel.push_strikethrough
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_push_strikethrough), 0, unsafe.Pointer(&struct{}{}))
}

/*
Adds a [code skip-lint][table=columns,inline_align][/code] tag to the tag stack. Use [method set_table_column_expand] to set column expansion ratio. Use [method push_cell] to add cells.
*/
//go:nosplit
func (self class) PushTable(columns int64, inline_align GUI.InlineAlignment, align_to_row int64) { //gd:RichTextLabel.push_table
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_push_table), 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		columns      int64
		inline_align GUI.InlineAlignment
		align_to_row int64
	}{columns, inline_align, align_to_row}))
}

/*
Adds a [code skip-lint][dropcap][/code] tag to the tag stack. Drop cap (dropped capital) is a decorative element at the beginning of a paragraph that is larger than the rest of the text.
*/
//go:nosplit
func (self class) PushDropcap(s String.Readable, font [1]gdclass.Font, size int64, dropcap_margins Rect2.PositionSize, color Color.RGBA, outline_size int64, outline_color Color.RGBA) { //gd:RichTextLabel.push_dropcap
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_push_dropcap), 0|(gdextension.SizeString<<4)|(gdextension.SizeObject<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeRect2<<16)|(gdextension.SizeColor<<20)|(gdextension.SizeInt<<24)|(gdextension.SizeColor<<28), unsafe.Pointer(&struct {
		s               gdextension.String
		font            gdextension.Object
		size            int64
		dropcap_margins Rect2.PositionSize
		color           Color.RGBA
		outline_size    int64
		outline_color   Color.RGBA
	}{pointers.Get(gd.InternalString(s)), gdextension.Object(gd.ObjectChecked(font[0].AsObject())), size, dropcap_margins, color, outline_size, outline_color}))
}

/*
Edits the selected column's expansion options. If [param expand] is [code]true[/code], the column expands in proportion to its expansion ratio versus the other columns' ratios.
For example, 2 columns with ratios 3 and 4 plus 70 pixels in available width would expand 30 and 40 pixels, respectively.
If [param expand] is [code]false[/code], the column will not contribute to the total ratio.
*/
//go:nosplit
func (self class) SetTableColumnExpand(column int64, expand bool, ratio int64, shrink bool) { //gd:RichTextLabel.set_table_column_expand
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_set_table_column_expand), 0|(gdextension.SizeInt<<4)|(gdextension.SizeBool<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeBool<<16), unsafe.Pointer(&struct {
		column int64
		expand bool
		ratio  int64
		shrink bool
	}{column, expand, ratio, shrink}))
}

/*
Sets color of a table cell. Separate colors for alternating rows can be specified.
*/
//go:nosplit
func (self class) SetCellRowBackgroundColor(odd_row_bg Color.RGBA, even_row_bg Color.RGBA) { //gd:RichTextLabel.set_cell_row_background_color
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_set_cell_row_background_color), 0|(gdextension.SizeColor<<4)|(gdextension.SizeColor<<8), unsafe.Pointer(&struct {
		odd_row_bg  Color.RGBA
		even_row_bg Color.RGBA
	}{odd_row_bg, even_row_bg}))
}

/*
Sets color of a table cell border.
*/
//go:nosplit
func (self class) SetCellBorderColor(color Color.RGBA) { //gd:RichTextLabel.set_cell_border_color
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_set_cell_border_color), 0|(gdextension.SizeColor<<4), unsafe.Pointer(&struct{ color Color.RGBA }{color}))
}

/*
Sets minimum and maximum size overrides for a table cell.
*/
//go:nosplit
func (self class) SetCellSizeOverride(min_size Vector2.XY, max_size Vector2.XY) { //gd:RichTextLabel.set_cell_size_override
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_set_cell_size_override), 0|(gdextension.SizeVector2<<4)|(gdextension.SizeVector2<<8), unsafe.Pointer(&struct {
		min_size Vector2.XY
		max_size Vector2.XY
	}{min_size, max_size}))
}

/*
Sets inner padding of a table cell.
*/
//go:nosplit
func (self class) SetCellPadding(padding Rect2.PositionSize) { //gd:RichTextLabel.set_cell_padding
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_set_cell_padding), 0|(gdextension.SizeRect2<<4), unsafe.Pointer(&struct{ padding Rect2.PositionSize }{padding}))
}

/*
Adds a [code skip-lint][cell][/code] tag to the tag stack. Must be inside a [code skip-lint][table][/code] tag. See [method push_table] for details. Use [method set_table_column_expand] to set column expansion ratio, [method set_cell_border_color] to set cell border, [method set_cell_row_background_color] to set cell background, [method set_cell_size_override] to override cell size, and [method set_cell_padding] to set padding.
*/
//go:nosplit
func (self class) PushCell() { //gd:RichTextLabel.push_cell
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_push_cell), 0, unsafe.Pointer(&struct{}{}))
}

/*
Adds a [code skip-lint][fgcolor][/code] tag to the tag stack.
*/
//go:nosplit
func (self class) PushFgcolor(fgcolor Color.RGBA) { //gd:RichTextLabel.push_fgcolor
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_push_fgcolor), 0|(gdextension.SizeColor<<4), unsafe.Pointer(&struct{ fgcolor Color.RGBA }{fgcolor}))
}

/*
Adds a [code skip-lint][bgcolor][/code] tag to the tag stack.
*/
//go:nosplit
func (self class) PushBgcolor(bgcolor Color.RGBA) { //gd:RichTextLabel.push_bgcolor
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_push_bgcolor), 0|(gdextension.SizeColor<<4), unsafe.Pointer(&struct{ bgcolor Color.RGBA }{bgcolor}))
}

/*
Adds a custom effect tag to the tag stack. The effect does not need to be in [member custom_effects]. The environment is directly passed to the effect.
*/
//go:nosplit
func (self class) PushCustomfx(effect [1]gdclass.RichTextEffect, env Dictionary.Any) { //gd:RichTextLabel.push_customfx
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_push_customfx), 0|(gdextension.SizeObject<<4)|(gdextension.SizeDictionary<<8), unsafe.Pointer(&struct {
		effect gdextension.Object
		env    gdextension.Dictionary
	}{gdextension.Object(gd.ObjectChecked(effect[0].AsObject())), pointers.Get(gd.InternalDictionary(env))}))
}

/*
Adds a context marker to the tag stack. See [method pop_context].
*/
//go:nosplit
func (self class) PushContext() { //gd:RichTextLabel.push_context
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_push_context), 0, unsafe.Pointer(&struct{}{}))
}

/*
Terminates tags opened after the last [method push_context] call (including context marker), or all tags if there's no context marker on the stack.
*/
//go:nosplit
func (self class) PopContext() { //gd:RichTextLabel.pop_context
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_pop_context), 0, unsafe.Pointer(&struct{}{}))
}

/*
Terminates the current tag. Use after [code]push_*[/code] methods to close BBCodes manually. Does not need to follow [code]add_*[/code] methods.
*/
//go:nosplit
func (self class) Pop() { //gd:RichTextLabel.pop
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_pop), 0, unsafe.Pointer(&struct{}{}))
}

/*
Terminates all tags opened by [code]push_*[/code] methods.
*/
//go:nosplit
func (self class) PopAll() { //gd:RichTextLabel.pop_all
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_pop_all), 0, unsafe.Pointer(&struct{}{}))
}

/*
Clears the tag stack, causing the label to display nothing.
[b]Note:[/b] This method does not affect [member text], and its contents will show again if the label is redrawn. However, setting [member text] to an empty [String] also clears the stack.
*/
//go:nosplit
func (self class) Clear() { //gd:RichTextLabel.clear
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_clear), 0, unsafe.Pointer(&struct{}{}))
}

//go:nosplit
func (self class) SetStructuredTextBidiOverride(parser TextServer.StructuredTextParser) { //gd:RichTextLabel.set_structured_text_bidi_override
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_set_structured_text_bidi_override), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct {
		parser TextServer.StructuredTextParser
	}{parser}))
}

//go:nosplit
func (self class) GetStructuredTextBidiOverride() TextServer.StructuredTextParser { //gd:RichTextLabel.get_structured_text_bidi_override
	var r_ret = gdextension.Call[TextServer.StructuredTextParser](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_get_structured_text_bidi_override), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetStructuredTextBidiOverrideOptions(args Array.Any) { //gd:RichTextLabel.set_structured_text_bidi_override_options
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_set_structured_text_bidi_override_options), 0|(gdextension.SizeArray<<4), unsafe.Pointer(&struct{ args gdextension.Array }{pointers.Get(gd.InternalArray(args))}))
}

//go:nosplit
func (self class) GetStructuredTextBidiOverrideOptions() Array.Any { //gd:RichTextLabel.get_structured_text_bidi_override_options
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_get_structured_text_bidi_override_options), gdextension.SizeArray, unsafe.Pointer(&struct{}{}))
	var ret = Array.Through(gd.ArrayProxy[variant.Any]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

//go:nosplit
func (self class) SetTextDirection(direction Control.TextDirection) { //gd:RichTextLabel.set_text_direction
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_set_text_direction), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ direction Control.TextDirection }{direction}))
}

//go:nosplit
func (self class) GetTextDirection() Control.TextDirection { //gd:RichTextLabel.get_text_direction
	var r_ret = gdextension.Call[Control.TextDirection](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_get_text_direction), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetLanguage(language String.Readable) { //gd:RichTextLabel.set_language
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_set_language), 0|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ language gdextension.String }{pointers.Get(gd.InternalString(language))}))
}

//go:nosplit
func (self class) GetLanguage() String.Readable { //gd:RichTextLabel.get_language
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_get_language), gdextension.SizeString, unsafe.Pointer(&struct{}{}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

//go:nosplit
func (self class) SetHorizontalAlignment(alignment GUI.HorizontalAlignment) { //gd:RichTextLabel.set_horizontal_alignment
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_set_horizontal_alignment), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ alignment GUI.HorizontalAlignment }{alignment}))
}

//go:nosplit
func (self class) GetHorizontalAlignment() GUI.HorizontalAlignment { //gd:RichTextLabel.get_horizontal_alignment
	var r_ret = gdextension.Call[GUI.HorizontalAlignment](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_get_horizontal_alignment), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetVerticalAlignment(alignment GUI.VerticalAlignment) { //gd:RichTextLabel.set_vertical_alignment
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_set_vertical_alignment), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ alignment GUI.VerticalAlignment }{alignment}))
}

//go:nosplit
func (self class) GetVerticalAlignment() GUI.VerticalAlignment { //gd:RichTextLabel.get_vertical_alignment
	var r_ret = gdextension.Call[GUI.VerticalAlignment](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_get_vertical_alignment), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetJustificationFlags(justification_flags TextServer.JustificationFlag) { //gd:RichTextLabel.set_justification_flags
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_set_justification_flags), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ justification_flags TextServer.JustificationFlag }{justification_flags}))
}

//go:nosplit
func (self class) GetJustificationFlags() TextServer.JustificationFlag { //gd:RichTextLabel.get_justification_flags
	var r_ret = gdextension.Call[TextServer.JustificationFlag](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_get_justification_flags), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetTabStops(tab_stops Packed.Array[float32]) { //gd:RichTextLabel.set_tab_stops
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_set_tab_stops), 0|(gdextension.SizePackedArray<<4), unsafe.Pointer(&struct {
		tab_stops gdextension.PackedArray[float32]
	}{pointers.Get(gd.InternalPacked[gd.PackedFloat32Array, float32](tab_stops))}))
}

//go:nosplit
func (self class) GetTabStops() Packed.Array[float32] { //gd:RichTextLabel.get_tab_stops
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_get_tab_stops), gdextension.SizePackedArray, unsafe.Pointer(&struct{}{}))
	var ret = Packed.Array[float32](Array.Through(gd.PackedProxy[gd.PackedFloat32Array, float32]{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

//go:nosplit
func (self class) SetAutowrapMode(autowrap_mode TextServer.AutowrapMode) { //gd:RichTextLabel.set_autowrap_mode
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_set_autowrap_mode), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ autowrap_mode TextServer.AutowrapMode }{autowrap_mode}))
}

//go:nosplit
func (self class) GetAutowrapMode() TextServer.AutowrapMode { //gd:RichTextLabel.get_autowrap_mode
	var r_ret = gdextension.Call[TextServer.AutowrapMode](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_get_autowrap_mode), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetMetaUnderline(enable bool) { //gd:RichTextLabel.set_meta_underline
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_set_meta_underline), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

//go:nosplit
func (self class) IsMetaUnderlined() bool { //gd:RichTextLabel.is_meta_underlined
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_is_meta_underlined), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetHintUnderline(enable bool) { //gd:RichTextLabel.set_hint_underline
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_set_hint_underline), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

//go:nosplit
func (self class) IsHintUnderlined() bool { //gd:RichTextLabel.is_hint_underlined
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_is_hint_underlined), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetScrollActive(active bool) { //gd:RichTextLabel.set_scroll_active
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_set_scroll_active), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ active bool }{active}))
}

//go:nosplit
func (self class) IsScrollActive() bool { //gd:RichTextLabel.is_scroll_active
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_is_scroll_active), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetScrollFollow(follow bool) { //gd:RichTextLabel.set_scroll_follow
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_set_scroll_follow), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ follow bool }{follow}))
}

//go:nosplit
func (self class) IsScrollFollowing() bool { //gd:RichTextLabel.is_scroll_following
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_is_scroll_following), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the vertical scrollbar.
[b]Warning:[/b] This is a required internal node, removing and freeing it may cause a crash. If you wish to hide it or any of its children, use their [member CanvasItem.visible] property.
*/
//go:nosplit
func (self class) GetVScrollBar() [1]gdclass.VScrollBar { //gd:RichTextLabel.get_v_scroll_bar
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_get_v_scroll_bar), gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.VScrollBar{gd.PointerLifetimeBoundTo[gdclass.VScrollBar](self.AsObject(), r_ret)}
	return ret
}

/*
Scrolls the window's top line to match [param line].
*/
//go:nosplit
func (self class) ScrollToLine(line int64) { //gd:RichTextLabel.scroll_to_line
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_scroll_to_line), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ line int64 }{line}))
}

/*
Scrolls the window's top line to match first line of the [param paragraph].
*/
//go:nosplit
func (self class) ScrollToParagraph(paragraph int64) { //gd:RichTextLabel.scroll_to_paragraph
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_scroll_to_paragraph), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ paragraph int64 }{paragraph}))
}

/*
Scrolls to the beginning of the current selection.
*/
//go:nosplit
func (self class) ScrollToSelection() { //gd:RichTextLabel.scroll_to_selection
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_scroll_to_selection), 0, unsafe.Pointer(&struct{}{}))
}

//go:nosplit
func (self class) SetTabSize(spaces int64) { //gd:RichTextLabel.set_tab_size
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_set_tab_size), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ spaces int64 }{spaces}))
}

//go:nosplit
func (self class) GetTabSize() int64 { //gd:RichTextLabel.get_tab_size
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_get_tab_size), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetFitContent(enabled bool) { //gd:RichTextLabel.set_fit_content
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_set_fit_content), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enabled bool }{enabled}))
}

//go:nosplit
func (self class) IsFitContentEnabled() bool { //gd:RichTextLabel.is_fit_content_enabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_is_fit_content_enabled), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetSelectionEnabled(enabled bool) { //gd:RichTextLabel.set_selection_enabled
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_set_selection_enabled), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enabled bool }{enabled}))
}

//go:nosplit
func (self class) IsSelectionEnabled() bool { //gd:RichTextLabel.is_selection_enabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_is_selection_enabled), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetContextMenuEnabled(enabled bool) { //gd:RichTextLabel.set_context_menu_enabled
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_set_context_menu_enabled), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enabled bool }{enabled}))
}

//go:nosplit
func (self class) IsContextMenuEnabled() bool { //gd:RichTextLabel.is_context_menu_enabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_is_context_menu_enabled), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetShortcutKeysEnabled(enabled bool) { //gd:RichTextLabel.set_shortcut_keys_enabled
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_set_shortcut_keys_enabled), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enabled bool }{enabled}))
}

//go:nosplit
func (self class) IsShortcutKeysEnabled() bool { //gd:RichTextLabel.is_shortcut_keys_enabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_is_shortcut_keys_enabled), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetDeselectOnFocusLossEnabled(enable bool) { //gd:RichTextLabel.set_deselect_on_focus_loss_enabled
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_set_deselect_on_focus_loss_enabled), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

//go:nosplit
func (self class) IsDeselectOnFocusLossEnabled() bool { //gd:RichTextLabel.is_deselect_on_focus_loss_enabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_is_deselect_on_focus_loss_enabled), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetDragAndDropSelectionEnabled(enable bool) { //gd:RichTextLabel.set_drag_and_drop_selection_enabled
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_set_drag_and_drop_selection_enabled), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

//go:nosplit
func (self class) IsDragAndDropSelectionEnabled() bool { //gd:RichTextLabel.is_drag_and_drop_selection_enabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_is_drag_and_drop_selection_enabled), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the current selection first character index if a selection is active, [code]-1[/code] otherwise. Does not include BBCodes.
*/
//go:nosplit
func (self class) GetSelectionFrom() int64 { //gd:RichTextLabel.get_selection_from
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_get_selection_from), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the current selection last character index if a selection is active, [code]-1[/code] otherwise. Does not include BBCodes.
*/
//go:nosplit
func (self class) GetSelectionTo() int64 { //gd:RichTextLabel.get_selection_to
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_get_selection_to), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the current selection vertical line offset if a selection is active, [code]-1.0[/code] otherwise.
*/
//go:nosplit
func (self class) GetSelectionLineOffset() float64 { //gd:RichTextLabel.get_selection_line_offset
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_get_selection_line_offset), gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Select all the text.
If [member selection_enabled] is [code]false[/code], no selection will occur.
*/
//go:nosplit
func (self class) SelectAll() { //gd:RichTextLabel.select_all
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_select_all), 0, unsafe.Pointer(&struct{}{}))
}

/*
Returns the current selection text. Does not include BBCodes.
*/
//go:nosplit
func (self class) GetSelectedText() String.Readable { //gd:RichTextLabel.get_selected_text
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_get_selected_text), gdextension.SizeString, unsafe.Pointer(&struct{}{}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Clears the current selection.
*/
//go:nosplit
func (self class) Deselect() { //gd:RichTextLabel.deselect
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_deselect), 0, unsafe.Pointer(&struct{}{}))
}

/*
The assignment version of [method append_text]. Clears the tag stack and inserts the new content.
*/
//go:nosplit
func (self class) ParseBbcode(bbcode String.Readable) { //gd:RichTextLabel.parse_bbcode
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_parse_bbcode), 0|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ bbcode gdextension.String }{pointers.Get(gd.InternalString(bbcode))}))
}

/*
Parses [param bbcode] and adds tags to the tag stack as needed.
[b]Note:[/b] Using this method, you can't close a tag that was opened in a previous [method append_text] call. This is done to improve performance, especially when updating large RichTextLabels since rebuilding the whole BBCode every time would be slower. If you absolutely need to close a tag in a future method call, append the [member text] instead of using [method append_text].
*/
//go:nosplit
func (self class) AppendText(bbcode String.Readable) { //gd:RichTextLabel.append_text
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_append_text), 0|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ bbcode gdextension.String }{pointers.Get(gd.InternalString(bbcode))}))
}

//go:nosplit
func (self class) GetText() String.Readable { //gd:RichTextLabel.get_text
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_get_text), gdextension.SizeString, unsafe.Pointer(&struct{}{}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
If [member threaded] is enabled, returns [code]true[/code] if the background thread has finished text processing, otherwise always return [code]true[/code].
*/
//go:nosplit
func (self class) IsReady() bool { //gd:RichTextLabel.is_ready
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_is_ready), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
If [member threaded] is enabled, returns [code]true[/code] if the background thread has finished text processing, otherwise always return [code]true[/code].
*/
//go:nosplit
func (self class) IsFinished() bool { //gd:RichTextLabel.is_finished
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_is_finished), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetThreaded(threaded bool) { //gd:RichTextLabel.set_threaded
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_set_threaded), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ threaded bool }{threaded}))
}

//go:nosplit
func (self class) IsThreaded() bool { //gd:RichTextLabel.is_threaded
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_is_threaded), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetProgressBarDelay(delay_ms int64) { //gd:RichTextLabel.set_progress_bar_delay
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_set_progress_bar_delay), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ delay_ms int64 }{delay_ms}))
}

//go:nosplit
func (self class) GetProgressBarDelay() int64 { //gd:RichTextLabel.get_progress_bar_delay
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_get_progress_bar_delay), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetVisibleCharacters(amount int64) { //gd:RichTextLabel.set_visible_characters
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_set_visible_characters), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ amount int64 }{amount}))
}

//go:nosplit
func (self class) GetVisibleCharacters() int64 { //gd:RichTextLabel.get_visible_characters
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_get_visible_characters), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) GetVisibleCharactersBehavior() TextServer.VisibleCharactersBehavior { //gd:RichTextLabel.get_visible_characters_behavior
	var r_ret = gdextension.Call[TextServer.VisibleCharactersBehavior](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_get_visible_characters_behavior), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetVisibleCharactersBehavior(behavior TextServer.VisibleCharactersBehavior) { //gd:RichTextLabel.set_visible_characters_behavior
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_set_visible_characters_behavior), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct {
		behavior TextServer.VisibleCharactersBehavior
	}{behavior}))
}

//go:nosplit
func (self class) SetVisibleRatio(ratio float64) { //gd:RichTextLabel.set_visible_ratio
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_set_visible_ratio), 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ ratio float64 }{ratio}))
}

//go:nosplit
func (self class) GetVisibleRatio() float64 { //gd:RichTextLabel.get_visible_ratio
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_get_visible_ratio), gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the line number of the character position provided. Line and character numbers are both zero-indexed.
[b]Note:[/b] If [member threaded] is enabled, this method returns a value for the loaded part of the document. Use [method is_finished] or [signal finished] to determine whether document is fully loaded.
*/
//go:nosplit
func (self class) GetCharacterLine(character int64) int64 { //gd:RichTextLabel.get_character_line
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_get_character_line), gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ character int64 }{character}))
	var ret = r_ret
	return ret
}

/*
Returns the paragraph number of the character position provided. Paragraph and character numbers are both zero-indexed.
[b]Note:[/b] If [member threaded] is enabled, this method returns a value for the loaded part of the document. Use [method is_finished] or [signal finished] to determine whether document is fully loaded.
*/
//go:nosplit
func (self class) GetCharacterParagraph(character int64) int64 { //gd:RichTextLabel.get_character_paragraph
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_get_character_paragraph), gdextension.SizeInt|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ character int64 }{character}))
	var ret = r_ret
	return ret
}

/*
Returns the total number of characters from text tags. Does not include BBCodes.
*/
//go:nosplit
func (self class) GetTotalCharacterCount() int64 { //gd:RichTextLabel.get_total_character_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_get_total_character_count), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetUseBbcode(enable bool) { //gd:RichTextLabel.set_use_bbcode
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_set_use_bbcode), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

//go:nosplit
func (self class) IsUsingBbcode() bool { //gd:RichTextLabel.is_using_bbcode
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_is_using_bbcode), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the total number of lines in the text. Wrapped text is counted as multiple lines.
[b]Note:[/b] If [member visible_characters_behavior] is set to [constant TextServer.VC_CHARS_BEFORE_SHAPING] only visible wrapped lines are counted.
[b]Note:[/b] If [member threaded] is enabled, this method returns a value for the loaded part of the document. Use [method is_finished] or [signal finished] to determine whether document is fully loaded.
*/
//go:nosplit
func (self class) GetLineCount() int64 { //gd:RichTextLabel.get_line_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_get_line_count), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the indexes of the first and last visible characters for the given [param line], as a [Vector2i].
[b]Note:[/b] If [member visible_characters_behavior] is set to [constant TextServer.VC_CHARS_BEFORE_SHAPING] only visible wrapped lines are counted.
[b]Note:[/b] If [member threaded] is enabled, this method returns a value for the loaded part of the document. Use [method is_finished] or [signal finished] to determine whether document is fully loaded.
*/
//go:nosplit
func (self class) GetLineRange(line int64) Vector2i.XY { //gd:RichTextLabel.get_line_range
	var r_ret = gdextension.Call[Vector2i.XY](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_get_line_range), gdextension.SizeVector2i|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ line int64 }{line}))
	var ret = r_ret
	return ret
}

/*
Returns the number of visible lines.
[b]Note:[/b] If [member threaded] is enabled, this method returns a value for the loaded part of the document. Use [method is_finished] or [signal finished] to determine whether document is fully loaded.
*/
//go:nosplit
func (self class) GetVisibleLineCount() int64 { //gd:RichTextLabel.get_visible_line_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_get_visible_line_count), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the total number of paragraphs (newlines or [code]p[/code] tags in the tag stack's text tags). Considers wrapped text as one paragraph.
*/
//go:nosplit
func (self class) GetParagraphCount() int64 { //gd:RichTextLabel.get_paragraph_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_get_paragraph_count), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the number of visible paragraphs. A paragraph is considered visible if at least one of its lines is visible.
[b]Note:[/b] If [member threaded] is enabled, this method returns a value for the loaded part of the document. Use [method is_finished] or [signal finished] to determine whether document is fully loaded.
*/
//go:nosplit
func (self class) GetVisibleParagraphCount() int64 { //gd:RichTextLabel.get_visible_paragraph_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_get_visible_paragraph_count), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the height of the content.
[b]Note:[/b] If [member threaded] is enabled, this method returns a value for the loaded part of the document. Use [method is_finished] or [signal finished] to determine whether document is fully loaded.
*/
//go:nosplit
func (self class) GetContentHeight() int64 { //gd:RichTextLabel.get_content_height
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_get_content_height), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the width of the content.
[b]Note:[/b] If [member threaded] is enabled, this method returns a value for the loaded part of the document. Use [method is_finished] or [signal finished] to determine whether document is fully loaded.
*/
//go:nosplit
func (self class) GetContentWidth() int64 { //gd:RichTextLabel.get_content_width
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_get_content_width), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the vertical offset of the line found at the provided index.
[b]Note:[/b] If [member threaded] is enabled, this method returns a value for the loaded part of the document. Use [method is_finished] or [signal finished] to determine whether document is fully loaded.
*/
//go:nosplit
func (self class) GetLineOffset(line int64) float64 { //gd:RichTextLabel.get_line_offset
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_get_line_offset), gdextension.SizeFloat|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ line int64 }{line}))
	var ret = r_ret
	return ret
}

/*
Returns the vertical offset of the paragraph found at the provided index.
[b]Note:[/b] If [member threaded] is enabled, this method returns a value for the loaded part of the document. Use [method is_finished] or [signal finished] to determine whether document is fully loaded.
*/
//go:nosplit
func (self class) GetParagraphOffset(paragraph int64) float64 { //gd:RichTextLabel.get_paragraph_offset
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_get_paragraph_offset), gdextension.SizeFloat|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ paragraph int64 }{paragraph}))
	var ret = r_ret
	return ret
}

/*
Parses BBCode parameter [param expressions] into a dictionary.
*/
//go:nosplit
func (self class) ParseExpressionsForValues(expressions Packed.Strings) Dictionary.Any { //gd:RichTextLabel.parse_expressions_for_values
	var r_ret = gdextension.Call[gdextension.Dictionary](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_parse_expressions_for_values), gdextension.SizeDictionary|(gdextension.SizePackedArray<<4), unsafe.Pointer(&struct {
		expressions gdextension.PackedArray[gdextension.String]
	}{pointers.Get(gd.InternalPackedStrings(expressions))}))
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret)))
	return ret
}

//go:nosplit
func (self class) SetEffects(effects Array.Any) { //gd:RichTextLabel.set_effects
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_set_effects), 0|(gdextension.SizeArray<<4), unsafe.Pointer(&struct{ effects gdextension.Array }{pointers.Get(gd.InternalArray(effects))}))
}

//go:nosplit
func (self class) GetEffects() Array.Any { //gd:RichTextLabel.get_effects
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_get_effects), gdextension.SizeArray, unsafe.Pointer(&struct{}{}))
	var ret = Array.Through(gd.ArrayProxy[variant.Any]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

/*
Installs a custom effect. This can also be done in the Inspector through the [member custom_effects] property. [param effect] should be a valid [RichTextEffect].
[b]Example:[/b] With the following script extending from [RichTextEffect]:
[codeblock]
# effect.gd
class_name MyCustomEffect
extends RichTextEffect

var bbcode = "my_custom_effect"

# ...
[/codeblock]
The above effect can be installed in [RichTextLabel] from a script:
[codeblock]
# rich_text_label.gd
extends RichTextLabel

func _ready():
    install_effect(MyCustomEffect.new())

    # Alternatively, if not using `class_name` in the script that extends RichTextEffect:
    install_effect(preload("res://effect.gd").new())
[/codeblock]
*/
//go:nosplit
func (self class) InstallEffect(effect variant.Any) { //gd:RichTextLabel.install_effect
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_install_effect), 0|(gdextension.SizeVariant<<4), unsafe.Pointer(&struct{ effect gdextension.Variant }{gdextension.Variant(pointers.Get(gd.InternalVariant(effect)))}))
}

/*
Returns the [PopupMenu] of this [RichTextLabel]. By default, this menu is displayed when right-clicking on the [RichTextLabel].
You can add custom menu items or remove standard ones. Make sure your IDs don't conflict with the standard ones (see [enum MenuItems]). For example:
[codeblocks]
[gdscript]
func _ready():
    var menu = get_menu()
    # Remove "Select All" item.
    menu.remove_item(MENU_SELECT_ALL)
    # Add custom items.
    menu.add_separator()
    menu.add_item("Duplicate Text", MENU_MAX + 1)
    # Connect callback.
    menu.id_pressed.connect(_on_item_pressed)

func _on_item_pressed(id):
    if id == MENU_MAX + 1:
        add_text("\n" + get_parsed_text())
[/gdscript]
[csharp]
public override void _Ready()
{
    var menu = GetMenu();
    // Remove "Select All" item.
    menu.RemoveItem(RichTextLabel.MenuItems.SelectAll);
    // Add custom items.
    menu.AddSeparator();
    menu.AddItem("Duplicate Text", RichTextLabel.MenuItems.Max + 1);
    // Add event handler.
    menu.IdPressed += OnItemPressed;
}

public void OnItemPressed(int id)
{
    if (id == TextEdit.MenuItems.Max + 1)
    {
        AddText("\n" + GetParsedText());
    }
}
[/csharp]
[/codeblocks]
[b]Warning:[/b] This is a required internal node, removing and freeing it may cause a crash. If you wish to hide it or any of its children, use their [member Window.visible] property.
*/
//go:nosplit
func (self class) GetMenu() [1]gdclass.PopupMenu { //gd:RichTextLabel.get_menu
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_get_menu), gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.PopupMenu{gd.PointerLifetimeBoundTo[gdclass.PopupMenu](self.AsObject(), r_ret)}
	return ret
}

/*
Returns whether the menu is visible. Use this instead of [code]get_menu().visible[/code] to improve performance (so the creation of the menu is avoided).
*/
//go:nosplit
func (self class) IsMenuVisible() bool { //gd:RichTextLabel.is_menu_visible
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_is_menu_visible), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Executes a given action as defined in the [enum MenuItems] enum.
*/
//go:nosplit
func (self class) MenuOption(option int64) { //gd:RichTextLabel.menu_option
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.RichTextLabel.Bind_menu_option), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ option int64 }{option}))
}
func (self Instance) OnMetaClicked(cb func(meta any)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("meta_clicked"), gd.NewCallable(cb), 0)
}

func (self Instance) OnMetaHoverStarted(cb func(meta any)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("meta_hover_started"), gd.NewCallable(cb), 0)
}

func (self Instance) OnMetaHoverEnded(cb func(meta any)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("meta_hover_ended"), gd.NewCallable(cb), 0)
}

func (self Instance) OnFinished(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("finished"), gd.NewCallable(cb), 0)
}

func (self class) AsRichTextLabel() Advanced           { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsRichTextLabel() Instance        { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsRichTextLabel() Instance   { return self.Super().AsRichTextLabel() }
func (self class) AsControl() Control.Advanced         { return *((*Control.Advanced)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsControl() Control.Instance { return self.Super().AsControl() }
func (self Instance) AsControl() Control.Instance {
	return *((*Control.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsCanvasItem() CanvasItem.Advanced {
	return *((*CanvasItem.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsCanvasItem() CanvasItem.Instance { return self.Super().AsCanvasItem() }
func (self Instance) AsCanvasItem() CanvasItem.Instance {
	return *((*CanvasItem.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsNode() Node.Advanced         { return *((*Node.Advanced)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsNode() Node.Instance { return self.Super().AsNode() }
func (self Instance) AsNode() Node.Instance      { return *((*Node.Instance)(unsafe.Pointer(&self))) }

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Control.Advanced(self.AsControl()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Control.Instance(self.AsControl()), name)
	}
}
func init() {
	gdclass.Register("RichTextLabel", func(ptr gd.Object) any {
		return [1]gdclass.RichTextLabel{*(*gdclass.RichTextLabel)(unsafe.Pointer(&ptr))}
	})
}

type ListType int //gd:RichTextLabel.ListType

const (
	/*Each list item has a number marker.*/
	ListNumbers ListType = 0
	/*Each list item has a letter marker.*/
	ListLetters ListType = 1
	/*Each list item has a roman number marker.*/
	ListRoman ListType = 2
	/*Each list item has a filled circle marker.*/
	ListDots ListType = 3
)

type MenuItems int //gd:RichTextLabel.MenuItems

const (
	/*Copies the selected text.*/
	MenuCopy MenuItems = 0
	/*Selects the whole [RichTextLabel] text.*/
	MenuSelectAll MenuItems = 1
	/*Represents the size of the [enum MenuItems] enum.*/
	MenuMax MenuItems = 2
)

type MetaUnderline int //gd:RichTextLabel.MetaUnderline

const (
	/*Meta tag does not display an underline, even if [member meta_underlined] is [code]true[/code].*/
	MetaUnderlineNever MetaUnderline = 0
	/*If [member meta_underlined] is [code]true[/code], meta tag always display an underline.*/
	MetaUnderlineAlways MetaUnderline = 1
	/*If [member meta_underlined] is [code]true[/code], meta tag display an underline when the mouse cursor is over it.*/
	MetaUnderlineOnHover MetaUnderline = 2
)

type ImageUpdateMask int //gd:RichTextLabel.ImageUpdateMask

const (
	/*If this bit is set, [method update_image] changes image texture.*/
	UpdateTexture ImageUpdateMask = 1
	/*If this bit is set, [method update_image] changes image size.*/
	UpdateSize ImageUpdateMask = 2
	/*If this bit is set, [method update_image] changes image color.*/
	UpdateColor ImageUpdateMask = 4
	/*If this bit is set, [method update_image] changes image inline alignment.*/
	UpdateAlignment ImageUpdateMask = 8
	/*If this bit is set, [method update_image] changes image texture region.*/
	UpdateRegion ImageUpdateMask = 16
	/*If this bit is set, [method update_image] changes image padding.*/
	UpdatePad ImageUpdateMask = 32
	/*If this bit is set, [method update_image] changes image tooltip.*/
	UpdateTooltip ImageUpdateMask = 64
	/*If this bit is set, [method update_image] changes image width from/to percents.*/
	UpdateWidthInPercent ImageUpdateMask = 128
)
