// Code generated by the generate package DO NOT EDIT

// Package UPNP provides methods for working with UPNP object instances.
package UPNP

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/variant/Signal"
import "graphics.gd/classdb/UPNPDevice"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Signal.Any
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
This class can be used to discover compatible [UPNPDevice]s on the local network and execute commands on them, like managing port mappings (for port forwarding/NAT traversal) and querying the local and remote network IP address. Note that methods on this class are synchronous and block the calling thread.
To forward a specific port (here [code]7777[/code], note both [method discover] and [method add_port_mapping] can return errors that should be checked):
[codeblock]
var upnp = UPNP.new()
upnp.discover()
upnp.add_port_mapping(7777)
[/codeblock]
To close a specific port (e.g. after you have finished using it):
[codeblock]
upnp.delete_port_mapping(port)
[/codeblock]
[b]Note:[/b] UPnP discovery blocks the current thread. To perform discovery without blocking the main thread, use [Thread]s like this:
[codeblock]
# Emitted when UPnP port mapping setup is completed (regardless of success or failure).
signal upnp_completed(error)

# Replace this with your own server port number between 1024 and 65535.
const SERVER_PORT = 3928
var thread = null

func _upnp_setup(server_port):

	# UPNP queries take some time.
	var upnp = UPNP.new()
	var err = upnp.discover()

	if err != OK:
	    push_error(str(err))
	    upnp_completed.emit(err)
	    return

	if upnp.get_gateway() and upnp.get_gateway().is_valid_gateway():
	    upnp.add_port_mapping(server_port, server_port, ProjectSettings.get_setting("application/config/name"), "UDP")
	    upnp.add_port_mapping(server_port, server_port, ProjectSettings.get_setting("application/config/name"), "TCP")
	    upnp_completed.emit(OK)

func _ready():

	thread = Thread.new()
	thread.start(_upnp_setup.bind(SERVER_PORT))

func _exit_tree():

	# Wait for thread finish here to handle game exit while the thread is running.
	thread.wait_to_finish()

[/codeblock]
[b]Terminology:[/b] In the context of UPnP networking, "gateway" (or "internet gateway device", short IGD) refers to network devices that allow computers in the local network to access the internet ("wide area network", WAN). These gateways are often also called "routers".
[b]Pitfalls:[/b]
- As explained above, these calls are blocking and shouldn't be run on the main thread, especially as they can block for multiple seconds at a time. Use threading!
- Networking is physical and messy. Packets get lost in transit or get filtered, addresses, free ports and assigned mappings change, and devices may leave or join the network at any time. Be mindful of this, be diligent when checking and handling errors, and handle these gracefully if you can: add clear error UI, timeouts and re-try handling.
- Port mappings may change (and be removed) at any time, and the remote/external IP address of the gateway can change likewise. You should consider re-querying the external IP and try to update/refresh the port mapping periodically (for example, every 5 minutes and on networking failures).
- Not all devices support UPnP, and some users disable UPnP support. You need to handle this (e.g. documenting and requiring the user to manually forward ports, or adding alternative methods of NAT traversal, like a relay/mirror server, or NAT hole punching, STUN/TURN, etc.).
- Consider what happens on mapping conflicts. Maybe multiple users on the same network would like to play your game at the same time, or maybe another application uses the same port. Make the port configurable, and optimally choose a port automatically (re-trying with a different port on failure).
[b]Further reading:[/b] If you want to know more about UPnP (and the Internet Gateway Device (IGD) and Port Control Protocol (PCP) specifically), [url=https://en.wikipedia.org/wiki/Universal_Plug_and_Play]Wikipedia[/url] is a good first stop, the specification can be found at the [url=https://openconnectivity.org/developer/specifications/upnp-resources/upnp/]Open Connectivity Foundation[/url] and Godot's implementation is based on the [url=https://github.com/miniupnp/miniupnp]MiniUPnP client[/url].
*/
type Instance [1]gdclass.UPNP

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	get_device_count          gdextension.MethodForClass `hash:"3905245786"`
	get_device                gdextension.MethodForClass `hash:"2193290270"`
	add_device                gdextension.MethodForClass `hash:"986715920"`
	set_device                gdextension.MethodForClass `hash:"3015133723"`
	remove_device             gdextension.MethodForClass `hash:"1286410249"`
	clear_devices             gdextension.MethodForClass `hash:"3218959716"`
	get_gateway               gdextension.MethodForClass `hash:"2276800779"`
	discover                  gdextension.MethodForClass `hash:"1575334765"`
	query_external_address    gdextension.MethodForClass `hash:"201670096"`
	add_port_mapping          gdextension.MethodForClass `hash:"818314583"`
	delete_port_mapping       gdextension.MethodForClass `hash:"3444187325"`
	set_discover_multicast_if gdextension.MethodForClass `hash:"83702148"`
	get_discover_multicast_if gdextension.MethodForClass `hash:"201670096"`
	set_discover_local_port   gdextension.MethodForClass `hash:"1286410249"`
	get_discover_local_port   gdextension.MethodForClass `hash:"3905245786"`
	set_discover_ipv6         gdextension.MethodForClass `hash:"2586408642"`
	is_discover_ipv6          gdextension.MethodForClass `hash:"36873697"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("UPNP")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		gdextension.Free(gdextension.TypeStringName, &sname)
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

type Expanded [1]gdclass.UPNP

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsUPNP() Instance
}

/*
Returns the number of discovered [UPNPDevice]s.
*/
func (self Instance) GetDeviceCount() int { //gd:UPNP.get_device_count
	return int(int(Advanced(self).GetDeviceCount()))
}

/*
Returns the [UPNPDevice] at the given [param index].
*/
func (self Instance) GetDevice(index int) UPNPDevice.Instance { //gd:UPNP.get_device
	return UPNPDevice.Instance(Advanced(self).GetDevice(int64(index)))
}

/*
Adds the given [UPNPDevice] to the list of discovered devices.
*/
func (self Instance) AddDevice(device UPNPDevice.Instance) { //gd:UPNP.add_device
	Advanced(self).AddDevice(device)
}

/*
Sets the device at [param index] from the list of discovered devices to [param device].
*/
func (self Instance) SetDevice(index int, device UPNPDevice.Instance) { //gd:UPNP.set_device
	Advanced(self).SetDevice(int64(index), device)
}

/*
Removes the device at [param index] from the list of discovered devices.
*/
func (self Instance) RemoveDevice(index int) { //gd:UPNP.remove_device
	Advanced(self).RemoveDevice(int64(index))
}

/*
Clears the list of discovered devices.
*/
func (self Instance) ClearDevices() { //gd:UPNP.clear_devices
	Advanced(self).ClearDevices()
}

/*
Returns the default gateway. That is the first discovered [UPNPDevice] that is also a valid IGD (InternetGatewayDevice).
*/
func (self Instance) GetGateway() UPNPDevice.Instance { //gd:UPNP.get_gateway
	return UPNPDevice.Instance(Advanced(self).GetGateway())
}

/*
Discovers local [UPNPDevice]s. Clears the list of previously discovered devices.
Filters for IGD (InternetGatewayDevice) type devices by default, as those manage port forwarding. [param timeout] is the time to wait for responses in milliseconds. [param ttl] is the time-to-live; only touch this if you know what you're doing.
See [enum UPNPResult] for possible return values.
*/
func (self Instance) Discover() int { //gd:UPNP.discover
	return int(int(Advanced(self).Discover(int64(2000), int64(2), String.New("InternetGatewayDevice"))))
}

/*
Discovers local [UPNPDevice]s. Clears the list of previously discovered devices.
Filters for IGD (InternetGatewayDevice) type devices by default, as those manage port forwarding. [param timeout] is the time to wait for responses in milliseconds. [param ttl] is the time-to-live; only touch this if you know what you're doing.
See [enum UPNPResult] for possible return values.
*/
func (self Expanded) Discover(timeout int, ttl int, device_filter string) int { //gd:UPNP.discover
	return int(int(Advanced(self).Discover(int64(timeout), int64(ttl), String.New(device_filter))))
}

/*
Returns the external [IP] address of the default gateway (see [method get_gateway]) as string. Returns an empty string on error.
*/
func (self Instance) QueryExternalAddress() string { //gd:UPNP.query_external_address
	return string(Advanced(self).QueryExternalAddress().String())
}

/*
Adds a mapping to forward the external [param port] (between 1 and 65535, although recommended to use port 1024 or above) on the default gateway (see [method get_gateway]) to the [param port_internal] on the local machine for the given protocol [param proto] (either [code]"TCP"[/code] or [code]"UDP"[/code], with UDP being the default). If a port mapping for the given port and protocol combination already exists on that gateway device, this method tries to overwrite it. If that is not desired, you can retrieve the gateway manually with [method get_gateway] and call [method add_port_mapping] on it, if any. Note that forwarding a well-known port (below 1024) with UPnP may fail depending on the device.
Depending on the gateway device, if a mapping for that port already exists, it will either be updated or it will refuse this command due to that conflict, especially if the existing mapping for that port wasn't created via UPnP or points to a different network address (or device) than this one.
If [param port_internal] is [code]0[/code] (the default), the same port number is used for both the external and the internal port (the [param port] value).
The description ([param desc]) is shown in some routers management UIs and can be used to point out which application added the mapping.
The mapping's lease [param duration] can be limited by specifying a duration in seconds. The default of [code]0[/code] means no duration, i.e. a permanent lease and notably some devices only support these permanent leases. Note that whether permanent or not, this is only a request and the gateway may still decide at any point to remove the mapping (which usually happens on a reboot of the gateway, when its external IP address changes, or on some models when it detects a port mapping has become inactive, i.e. had no traffic for multiple minutes). If not [code]0[/code] (permanent), the allowed range according to spec is between [code]120[/code] (2 minutes) and [code]86400[/code] seconds (24 hours).
See [enum UPNPResult] for possible return values.
*/
func (self Instance) AddPortMapping(port int) int { //gd:UPNP.add_port_mapping
	return int(int(Advanced(self).AddPortMapping(int64(port), int64(0), String.New(""), String.New("UDP"), int64(0))))
}

/*
Adds a mapping to forward the external [param port] (between 1 and 65535, although recommended to use port 1024 or above) on the default gateway (see [method get_gateway]) to the [param port_internal] on the local machine for the given protocol [param proto] (either [code]"TCP"[/code] or [code]"UDP"[/code], with UDP being the default). If a port mapping for the given port and protocol combination already exists on that gateway device, this method tries to overwrite it. If that is not desired, you can retrieve the gateway manually with [method get_gateway] and call [method add_port_mapping] on it, if any. Note that forwarding a well-known port (below 1024) with UPnP may fail depending on the device.
Depending on the gateway device, if a mapping for that port already exists, it will either be updated or it will refuse this command due to that conflict, especially if the existing mapping for that port wasn't created via UPnP or points to a different network address (or device) than this one.
If [param port_internal] is [code]0[/code] (the default), the same port number is used for both the external and the internal port (the [param port] value).
The description ([param desc]) is shown in some routers management UIs and can be used to point out which application added the mapping.
The mapping's lease [param duration] can be limited by specifying a duration in seconds. The default of [code]0[/code] means no duration, i.e. a permanent lease and notably some devices only support these permanent leases. Note that whether permanent or not, this is only a request and the gateway may still decide at any point to remove the mapping (which usually happens on a reboot of the gateway, when its external IP address changes, or on some models when it detects a port mapping has become inactive, i.e. had no traffic for multiple minutes). If not [code]0[/code] (permanent), the allowed range according to spec is between [code]120[/code] (2 minutes) and [code]86400[/code] seconds (24 hours).
See [enum UPNPResult] for possible return values.
*/
func (self Expanded) AddPortMapping(port int, port_internal int, desc string, proto string, duration int) int { //gd:UPNP.add_port_mapping
	return int(int(Advanced(self).AddPortMapping(int64(port), int64(port_internal), String.New(desc), String.New(proto), int64(duration))))
}

/*
Deletes the port mapping for the given port and protocol combination on the default gateway (see [method get_gateway]) if one exists. [param port] must be a valid port between 1 and 65535, [param proto] can be either [code]"TCP"[/code] or [code]"UDP"[/code]. May be refused for mappings pointing to addresses other than this one, for well-known ports (below 1024), or for mappings not added via UPnP. See [enum UPNPResult] for possible return values.
*/
func (self Instance) DeletePortMapping(port int) int { //gd:UPNP.delete_port_mapping
	return int(int(Advanced(self).DeletePortMapping(int64(port), String.New("UDP"))))
}

/*
Deletes the port mapping for the given port and protocol combination on the default gateway (see [method get_gateway]) if one exists. [param port] must be a valid port between 1 and 65535, [param proto] can be either [code]"TCP"[/code] or [code]"UDP"[/code]. May be refused for mappings pointing to addresses other than this one, for well-known ports (below 1024), or for mappings not added via UPnP. See [enum UPNPResult] for possible return values.
*/
func (self Expanded) DeletePortMapping(port int, proto string) int { //gd:UPNP.delete_port_mapping
	return int(int(Advanced(self).DeletePortMapping(int64(port), String.New(proto))))
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.UPNP

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.UPNP)(unsafe.Pointer(&obj))
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.UPNP)(unsafe.Pointer(&obj))
		return true
	}
	return false
}

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {

	if !gd.Linked {
		var placeholder Instance
		*(*gd.Object)(unsafe.Pointer(&placeholder)) = pointers.Add[gd.Object]([3]uint64{})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(*(*gd.Object)(unsafe.Pointer(&placeholder)), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	object := [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})}
	casted := Instance{*(*gdclass.UPNP)(unsafe.Pointer(&object))}
	casted.AsRefCounted()[0].InitRef()
	object[0].Notification(0, false)
	return casted
}

func (self Instance) DiscoverMulticastIf() string {
	return string(class(self).GetDiscoverMulticastIf().String())
}

func (self Instance) SetDiscoverMulticastIf(value string) {
	class(self).SetDiscoverMulticastIf(String.New(value))
}

func (self Instance) DiscoverLocalPort() int {
	return int(int(class(self).GetDiscoverLocalPort()))
}

func (self Instance) SetDiscoverLocalPort(value int) {
	class(self).SetDiscoverLocalPort(int64(value))
}

func (self Instance) DiscoverIpv6() bool {
	return bool(class(self).IsDiscoverIpv6())
}

func (self Instance) SetDiscoverIpv6(value bool) {
	class(self).SetDiscoverIpv6(value)
}

/*
Returns the number of discovered [UPNPDevice]s.
*/
//go:nosplit
func (self class) GetDeviceCount() int64 { //gd:UPNP.get_device_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_device_count, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the [UPNPDevice] at the given [param index].
*/
//go:nosplit
func (self class) GetDevice(index int64) [1]gdclass.UPNPDevice { //gd:UPNP.get_device
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_device, gdextension.SizeObject|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ index int64 }{index}))
	var ret = [1]gdclass.UPNPDevice{gd.PointerWithOwnershipTransferredToGo[gdclass.UPNPDevice](r_ret)}
	return ret
}

/*
Adds the given [UPNPDevice] to the list of discovered devices.
*/
//go:nosplit
func (self class) AddDevice(device [1]gdclass.UPNPDevice) { //gd:UPNP.add_device
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_device, 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ device gdextension.Object }{gdextension.Object(gd.ObjectChecked(device[0].AsObject()))}))
}

/*
Sets the device at [param index] from the list of discovered devices to [param device].
*/
//go:nosplit
func (self class) SetDevice(index int64, device [1]gdclass.UPNPDevice) { //gd:UPNP.set_device
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_device, 0|(gdextension.SizeInt<<4)|(gdextension.SizeObject<<8), unsafe.Pointer(&struct {
		index  int64
		device gdextension.Object
	}{index, gdextension.Object(gd.ObjectChecked(device[0].AsObject()))}))
}

/*
Removes the device at [param index] from the list of discovered devices.
*/
//go:nosplit
func (self class) RemoveDevice(index int64) { //gd:UPNP.remove_device
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.remove_device, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ index int64 }{index}))
}

/*
Clears the list of discovered devices.
*/
//go:nosplit
func (self class) ClearDevices() { //gd:UPNP.clear_devices
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.clear_devices, 0, unsafe.Pointer(&struct{}{}))
}

/*
Returns the default gateway. That is the first discovered [UPNPDevice] that is also a valid IGD (InternetGatewayDevice).
*/
//go:nosplit
func (self class) GetGateway() [1]gdclass.UPNPDevice { //gd:UPNP.get_gateway
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_gateway, gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.UPNPDevice{gd.PointerWithOwnershipTransferredToGo[gdclass.UPNPDevice](r_ret)}
	return ret
}

/*
Discovers local [UPNPDevice]s. Clears the list of previously discovered devices.
Filters for IGD (InternetGatewayDevice) type devices by default, as those manage port forwarding. [param timeout] is the time to wait for responses in milliseconds. [param ttl] is the time-to-live; only touch this if you know what you're doing.
See [enum UPNPResult] for possible return values.
*/
//go:nosplit
func (self class) Discover(timeout int64, ttl int64, device_filter String.Readable) int64 { //gd:UPNP.discover
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.discover, gdextension.SizeInt|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeString<<12), unsafe.Pointer(&struct {
		timeout       int64
		ttl           int64
		device_filter gdextension.String
	}{timeout, ttl, pointers.Get(gd.InternalString(device_filter))}))
	var ret = r_ret
	return ret
}

/*
Returns the external [IP] address of the default gateway (see [method get_gateway]) as string. Returns an empty string on error.
*/
//go:nosplit
func (self class) QueryExternalAddress() String.Readable { //gd:UPNP.query_external_address
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.query_external_address, gdextension.SizeString, unsafe.Pointer(&struct{}{}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Adds a mapping to forward the external [param port] (between 1 and 65535, although recommended to use port 1024 or above) on the default gateway (see [method get_gateway]) to the [param port_internal] on the local machine for the given protocol [param proto] (either [code]"TCP"[/code] or [code]"UDP"[/code], with UDP being the default). If a port mapping for the given port and protocol combination already exists on that gateway device, this method tries to overwrite it. If that is not desired, you can retrieve the gateway manually with [method get_gateway] and call [method add_port_mapping] on it, if any. Note that forwarding a well-known port (below 1024) with UPnP may fail depending on the device.
Depending on the gateway device, if a mapping for that port already exists, it will either be updated or it will refuse this command due to that conflict, especially if the existing mapping for that port wasn't created via UPnP or points to a different network address (or device) than this one.
If [param port_internal] is [code]0[/code] (the default), the same port number is used for both the external and the internal port (the [param port] value).
The description ([param desc]) is shown in some routers management UIs and can be used to point out which application added the mapping.
The mapping's lease [param duration] can be limited by specifying a duration in seconds. The default of [code]0[/code] means no duration, i.e. a permanent lease and notably some devices only support these permanent leases. Note that whether permanent or not, this is only a request and the gateway may still decide at any point to remove the mapping (which usually happens on a reboot of the gateway, when its external IP address changes, or on some models when it detects a port mapping has become inactive, i.e. had no traffic for multiple minutes). If not [code]0[/code] (permanent), the allowed range according to spec is between [code]120[/code] (2 minutes) and [code]86400[/code] seconds (24 hours).
See [enum UPNPResult] for possible return values.
*/
//go:nosplit
func (self class) AddPortMapping(port int64, port_internal int64, desc String.Readable, proto String.Readable, duration int64) int64 { //gd:UPNP.add_port_mapping
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.add_port_mapping, gdextension.SizeInt|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeString<<12)|(gdextension.SizeString<<16)|(gdextension.SizeInt<<20), unsafe.Pointer(&struct {
		port          int64
		port_internal int64
		desc          gdextension.String
		proto         gdextension.String
		duration      int64
	}{port, port_internal, pointers.Get(gd.InternalString(desc)), pointers.Get(gd.InternalString(proto)), duration}))
	var ret = r_ret
	return ret
}

/*
Deletes the port mapping for the given port and protocol combination on the default gateway (see [method get_gateway]) if one exists. [param port] must be a valid port between 1 and 65535, [param proto] can be either [code]"TCP"[/code] or [code]"UDP"[/code]. May be refused for mappings pointing to addresses other than this one, for well-known ports (below 1024), or for mappings not added via UPnP. See [enum UPNPResult] for possible return values.
*/
//go:nosplit
func (self class) DeletePortMapping(port int64, proto String.Readable) int64 { //gd:UPNP.delete_port_mapping
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.delete_port_mapping, gdextension.SizeInt|(gdextension.SizeInt<<4)|(gdextension.SizeString<<8), unsafe.Pointer(&struct {
		port  int64
		proto gdextension.String
	}{port, pointers.Get(gd.InternalString(proto))}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetDiscoverMulticastIf(m_if String.Readable) { //gd:UPNP.set_discover_multicast_if
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_discover_multicast_if, 0|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ m_if gdextension.String }{pointers.Get(gd.InternalString(m_if))}))
}

//go:nosplit
func (self class) GetDiscoverMulticastIf() String.Readable { //gd:UPNP.get_discover_multicast_if
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_discover_multicast_if, gdextension.SizeString, unsafe.Pointer(&struct{}{}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

//go:nosplit
func (self class) SetDiscoverLocalPort(port int64) { //gd:UPNP.set_discover_local_port
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_discover_local_port, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ port int64 }{port}))
}

//go:nosplit
func (self class) GetDiscoverLocalPort() int64 { //gd:UPNP.get_discover_local_port
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_discover_local_port, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetDiscoverIpv6(ipv6 bool) { //gd:UPNP.set_discover_ipv6
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_discover_ipv6, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ ipv6 bool }{ipv6}))
}

//go:nosplit
func (self class) IsDiscoverIpv6() bool { //gd:UPNP.is_discover_ipv6
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_discover_ipv6, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}
func (self class) AsUPNP() Advanced         { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsUPNP() Instance      { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsUPNP() Instance { return self.Super().AsUPNP() }
func (self class) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsRefCounted() [1]gd.RefCounted { return self.Super().AsRefCounted() }
func (self Instance) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(RefCounted.Advanced(self.AsRefCounted()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(RefCounted.Instance(self.AsRefCounted()), name)
	}
}
func init() {
	gdclass.Register("UPNP", func(ptr gd.Object) any { return *(*Instance)(unsafe.Pointer(&ptr)) })
}

type UPNPResult int //gd:UPNP.UPNPResult

const (
	/*UPNP command or discovery was successful.*/
	UpnpResultSuccess UPNPResult = 0
	/*Not authorized to use the command on the [UPNPDevice]. May be returned when the user disabled UPNP on their router.*/
	UpnpResultNotAuthorized UPNPResult = 1
	/*No port mapping was found for the given port, protocol combination on the given [UPNPDevice].*/
	UpnpResultPortMappingNotFound UPNPResult = 2
	/*Inconsistent parameters.*/
	UpnpResultInconsistentParameters UPNPResult = 3
	/*No such entry in array. May be returned if a given port, protocol combination is not found on an [UPNPDevice].*/
	UpnpResultNoSuchEntryInArray UPNPResult = 4
	/*The action failed.*/
	UpnpResultActionFailed UPNPResult = 5
	/*The [UPNPDevice] does not allow wildcard values for the source IP address.*/
	UpnpResultSrcIpWildcardNotPermitted UPNPResult = 6
	/*The [UPNPDevice] does not allow wildcard values for the external port.*/
	UpnpResultExtPortWildcardNotPermitted UPNPResult = 7
	/*The [UPNPDevice] does not allow wildcard values for the internal port.*/
	UpnpResultIntPortWildcardNotPermitted UPNPResult = 8
	/*The remote host value must be a wildcard.*/
	UpnpResultRemoteHostMustBeWildcard UPNPResult = 9
	/*The external port value must be a wildcard.*/
	UpnpResultExtPortMustBeWildcard UPNPResult = 10
	/*No port maps are available. May also be returned if port mapping functionality is not available.*/
	UpnpResultNoPortMapsAvailable UPNPResult = 11
	/*Conflict with other mechanism. May be returned instead of [constant UPNP_RESULT_CONFLICT_WITH_OTHER_MAPPING] if a port mapping conflicts with an existing one.*/
	UpnpResultConflictWithOtherMechanism UPNPResult = 12
	/*Conflict with an existing port mapping.*/
	UpnpResultConflictWithOtherMapping UPNPResult = 13
	/*External and internal port values must be the same.*/
	UpnpResultSamePortValuesRequired UPNPResult = 14
	/*Only permanent leases are supported. Do not use the [code]duration[/code] parameter when adding port mappings.*/
	UpnpResultOnlyPermanentLeaseSupported UPNPResult = 15
	/*Invalid gateway.*/
	UpnpResultInvalidGateway UPNPResult = 16
	/*Invalid port.*/
	UpnpResultInvalidPort UPNPResult = 17
	/*Invalid protocol.*/
	UpnpResultInvalidProtocol UPNPResult = 18
	/*Invalid duration.*/
	UpnpResultInvalidDuration UPNPResult = 19
	/*Invalid arguments.*/
	UpnpResultInvalidArgs UPNPResult = 20
	/*Invalid response.*/
	UpnpResultInvalidResponse UPNPResult = 21
	/*Invalid parameter.*/
	UpnpResultInvalidParam UPNPResult = 22
	/*HTTP error.*/
	UpnpResultHttpError UPNPResult = 23
	/*Socket error.*/
	UpnpResultSocketError UPNPResult = 24
	/*Error allocating memory.*/
	UpnpResultMemAllocError UPNPResult = 25
	/*No gateway available. You may need to call [method discover] first, or discovery didn't detect any valid IGDs (InternetGatewayDevices).*/
	UpnpResultNoGateway UPNPResult = 26
	/*No devices available. You may need to call [method discover] first, or discovery didn't detect any valid [UPNPDevice]s.*/
	UpnpResultNoDevices UPNPResult = 27
	/*Unknown error.*/
	UpnpResultUnknownError UPNPResult = 28
)
