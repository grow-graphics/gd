// Code generated by the generate package DO NOT EDIT

// Package RigidBody2D provides methods for working with RigidBody2D object instances.
package RigidBody2D

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/CanvasItem"
import "graphics.gd/classdb/CollisionObject2D"
import "graphics.gd/classdb/Node"
import "graphics.gd/classdb/Node2D"
import "graphics.gd/classdb/PhysicsBody2D"
import "graphics.gd/classdb/PhysicsDirectBodyState2D"
import "graphics.gd/classdb/PhysicsMaterial"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"
import "graphics.gd/variant/Vector2"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
[RigidBody2D] implements full 2D physics. It cannot be controlled directly, instead, you must apply forces to it (gravity, impulses, etc.), and the physics simulation will calculate the resulting movement, rotation, react to collisions, and affect other physics bodies in its path.
The body's behavior can be adjusted via [member lock_rotation], [member freeze], and [member freeze_mode]. By changing various properties of the object, such as [member mass], you can control how the physics simulation acts on it.
A rigid body will always maintain its shape and size, even when forces are applied to it. It is useful for objects that can be interacted with in an environment, such as a tree that can be knocked over or a stack of crates that can be pushed around.
If you need to override the default physics behavior, you can write a custom force integration function. See [member custom_integrator].
[b]Note:[/b] Changing the 2D transform or [member linear_velocity] of a [RigidBody2D] very often may lead to some unpredictable behaviors. If you need to directly affect the body, prefer [method _integrate_forces] as it allows you to directly access the physics state.

	See [Interface] for methods that can be overridden by a [Class] that extends it.
*/
type Instance [1]gdclass.RigidBody2D

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	set_mass                                gdextension.MethodForClass `hash:"373806689"`
	get_mass                                gdextension.MethodForClass `hash:"1740695150"`
	get_inertia                             gdextension.MethodForClass `hash:"1740695150"`
	set_inertia                             gdextension.MethodForClass `hash:"373806689"`
	set_center_of_mass_mode                 gdextension.MethodForClass `hash:"1757235706"`
	get_center_of_mass_mode                 gdextension.MethodForClass `hash:"3277132817"`
	set_center_of_mass                      gdextension.MethodForClass `hash:"743155724"`
	get_center_of_mass                      gdextension.MethodForClass `hash:"3341600327"`
	set_physics_material_override           gdextension.MethodForClass `hash:"1784508650"`
	get_physics_material_override           gdextension.MethodForClass `hash:"2521850424"`
	set_gravity_scale                       gdextension.MethodForClass `hash:"373806689"`
	get_gravity_scale                       gdextension.MethodForClass `hash:"1740695150"`
	set_linear_damp_mode                    gdextension.MethodForClass `hash:"3406533708"`
	get_linear_damp_mode                    gdextension.MethodForClass `hash:"2970511462"`
	set_angular_damp_mode                   gdextension.MethodForClass `hash:"3406533708"`
	get_angular_damp_mode                   gdextension.MethodForClass `hash:"2970511462"`
	set_linear_damp                         gdextension.MethodForClass `hash:"373806689"`
	get_linear_damp                         gdextension.MethodForClass `hash:"1740695150"`
	set_angular_damp                        gdextension.MethodForClass `hash:"373806689"`
	get_angular_damp                        gdextension.MethodForClass `hash:"1740695150"`
	set_linear_velocity                     gdextension.MethodForClass `hash:"743155724"`
	get_linear_velocity                     gdextension.MethodForClass `hash:"3341600327"`
	set_angular_velocity                    gdextension.MethodForClass `hash:"373806689"`
	get_angular_velocity                    gdextension.MethodForClass `hash:"1740695150"`
	set_max_contacts_reported               gdextension.MethodForClass `hash:"1286410249"`
	get_max_contacts_reported               gdextension.MethodForClass `hash:"3905245786"`
	get_contact_count                       gdextension.MethodForClass `hash:"3905245786"`
	set_use_custom_integrator               gdextension.MethodForClass `hash:"2586408642"`
	is_using_custom_integrator              gdextension.MethodForClass `hash:"2240911060"`
	set_contact_monitor                     gdextension.MethodForClass `hash:"2586408642"`
	is_contact_monitor_enabled              gdextension.MethodForClass `hash:"36873697"`
	set_continuous_collision_detection_mode gdextension.MethodForClass `hash:"1000241384"`
	get_continuous_collision_detection_mode gdextension.MethodForClass `hash:"815214376"`
	set_axis_velocity                       gdextension.MethodForClass `hash:"743155724"`
	apply_central_impulse                   gdextension.MethodForClass `hash:"3862383994"`
	apply_impulse                           gdextension.MethodForClass `hash:"4288681949"`
	apply_torque_impulse                    gdextension.MethodForClass `hash:"373806689"`
	apply_central_force                     gdextension.MethodForClass `hash:"743155724"`
	apply_force                             gdextension.MethodForClass `hash:"4288681949"`
	apply_torque                            gdextension.MethodForClass `hash:"373806689"`
	add_constant_central_force              gdextension.MethodForClass `hash:"743155724"`
	add_constant_force                      gdextension.MethodForClass `hash:"4288681949"`
	add_constant_torque                     gdextension.MethodForClass `hash:"373806689"`
	set_constant_force                      gdextension.MethodForClass `hash:"743155724"`
	get_constant_force                      gdextension.MethodForClass `hash:"3341600327"`
	set_constant_torque                     gdextension.MethodForClass `hash:"373806689"`
	get_constant_torque                     gdextension.MethodForClass `hash:"1740695150"`
	set_sleeping                            gdextension.MethodForClass `hash:"2586408642"`
	is_sleeping                             gdextension.MethodForClass `hash:"36873697"`
	set_can_sleep                           gdextension.MethodForClass `hash:"2586408642"`
	is_able_to_sleep                        gdextension.MethodForClass `hash:"36873697"`
	set_lock_rotation_enabled               gdextension.MethodForClass `hash:"2586408642"`
	is_lock_rotation_enabled                gdextension.MethodForClass `hash:"36873697"`
	set_freeze_enabled                      gdextension.MethodForClass `hash:"2586408642"`
	is_freeze_enabled                       gdextension.MethodForClass `hash:"36873697"`
	set_freeze_mode                         gdextension.MethodForClass `hash:"1705112154"`
	get_freeze_mode                         gdextension.MethodForClass `hash:"2016872314"`
	get_colliding_bodies                    gdextension.MethodForClass `hash:"3995934104"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("RigidBody2D")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		pointers.Raw[gd.StringName](sname).Free()
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

type Expanded [1]gdclass.RigidBody2D

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsRigidBody2D() Instance
}
type Interface interface {
	//Called during physics processing, allowing you to read and safely modify the simulation state for the object. By default, it is called before the standard force integration, but the [member custom_integrator] property allows you to disable the standard force integration and do fully custom force integration for a body.
	IntegrateForces(state PhysicsDirectBodyState2D.Instance)
}

// Implementation implements [Interface] with empty methods.
type Implementation = implementation

type implementation struct{}

func (self implementation) IntegrateForces(state PhysicsDirectBodyState2D.Instance) { return }

/*
Called during physics processing, allowing you to read and safely modify the simulation state for the object. By default, it is called before the standard force integration, but the [member custom_integrator] property allows you to disable the standard force integration and do fully custom force integration for a body.
*/
func (Instance) _integrate_forces(impl func(ptr unsafe.Pointer, state PhysicsDirectBodyState2D.Instance)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var state = [1]gdclass.PhysicsDirectBodyState2D{pointers.New[gdclass.PhysicsDirectBodyState2D]([3]uint64{uint64(gd.UnsafeGet[gdextension.Object](p_args, 0))})}

		defer pointers.End(state[0])
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, state)
	}
}

/*
Returns the number of contacts this body has with other bodies. By default, this returns 0 unless bodies are configured to monitor contacts (see [member contact_monitor]).
[b]Note:[/b] To retrieve the colliding bodies, use [method get_colliding_bodies].
*/
func (self Instance) GetContactCount() int { //gd:RigidBody2D.get_contact_count
	return int(int(Advanced(self).GetContactCount()))
}

/*
Sets the body's velocity on the given axis. The velocity in the given vector axis will be set as the given vector length. This is useful for jumping behavior.
*/
func (self Instance) SetAxisVelocity(axis_velocity Vector2.XY) { //gd:RigidBody2D.set_axis_velocity
	Advanced(self).SetAxisVelocity(Vector2.XY(axis_velocity))
}

/*
Applies a directional impulse without affecting rotation.
An impulse is time-independent! Applying an impulse every frame would result in a framerate-dependent force. For this reason, it should only be used when simulating one-time impacts (use the "_force" functions otherwise).
This is equivalent to using [method apply_impulse] at the body's center of mass.
*/
func (self Instance) ApplyCentralImpulse() { //gd:RigidBody2D.apply_central_impulse
	Advanced(self).ApplyCentralImpulse(Vector2.XY(gd.Vector2{0, 0}))
}

/*
Applies a directional impulse without affecting rotation.
An impulse is time-independent! Applying an impulse every frame would result in a framerate-dependent force. For this reason, it should only be used when simulating one-time impacts (use the "_force" functions otherwise).
This is equivalent to using [method apply_impulse] at the body's center of mass.
*/
func (self Expanded) ApplyCentralImpulse(impulse Vector2.XY) { //gd:RigidBody2D.apply_central_impulse
	Advanced(self).ApplyCentralImpulse(Vector2.XY(impulse))
}

/*
Applies a positioned impulse to the body.
An impulse is time-independent! Applying an impulse every frame would result in a framerate-dependent force. For this reason, it should only be used when simulating one-time impacts (use the "_force" functions otherwise).
[param position] is the offset from the body origin in global coordinates.
*/
func (self Instance) ApplyImpulse(impulse Vector2.XY) { //gd:RigidBody2D.apply_impulse
	Advanced(self).ApplyImpulse(Vector2.XY(impulse), Vector2.XY(gd.Vector2{0, 0}))
}

/*
Applies a positioned impulse to the body.
An impulse is time-independent! Applying an impulse every frame would result in a framerate-dependent force. For this reason, it should only be used when simulating one-time impacts (use the "_force" functions otherwise).
[param position] is the offset from the body origin in global coordinates.
*/
func (self Expanded) ApplyImpulse(impulse Vector2.XY, position Vector2.XY) { //gd:RigidBody2D.apply_impulse
	Advanced(self).ApplyImpulse(Vector2.XY(impulse), Vector2.XY(position))
}

/*
Applies a rotational impulse to the body without affecting the position.
An impulse is time-independent! Applying an impulse every frame would result in a framerate-dependent force. For this reason, it should only be used when simulating one-time impacts (use the "_force" functions otherwise).
[b]Note:[/b] [member inertia] is required for this to work. To have [member inertia], an active [CollisionShape2D] must be a child of the node, or you can manually set [member inertia].
*/
func (self Instance) ApplyTorqueImpulse(torque Float.X) { //gd:RigidBody2D.apply_torque_impulse
	Advanced(self).ApplyTorqueImpulse(float64(torque))
}

/*
Applies a directional force without affecting rotation. A force is time dependent and meant to be applied every physics update.
This is equivalent to using [method apply_force] at the body's center of mass.
*/
func (self Instance) ApplyCentralForce(force Vector2.XY) { //gd:RigidBody2D.apply_central_force
	Advanced(self).ApplyCentralForce(Vector2.XY(force))
}

/*
Applies a positioned force to the body. A force is time dependent and meant to be applied every physics update.
[param position] is the offset from the body origin in global coordinates.
*/
func (self Instance) ApplyForce(force Vector2.XY) { //gd:RigidBody2D.apply_force
	Advanced(self).ApplyForce(Vector2.XY(force), Vector2.XY(gd.Vector2{0, 0}))
}

/*
Applies a positioned force to the body. A force is time dependent and meant to be applied every physics update.
[param position] is the offset from the body origin in global coordinates.
*/
func (self Expanded) ApplyForce(force Vector2.XY, position Vector2.XY) { //gd:RigidBody2D.apply_force
	Advanced(self).ApplyForce(Vector2.XY(force), Vector2.XY(position))
}

/*
Applies a rotational force without affecting position. A force is time dependent and meant to be applied every physics update.
[b]Note:[/b] [member inertia] is required for this to work. To have [member inertia], an active [CollisionShape2D] must be a child of the node, or you can manually set [member inertia].
*/
func (self Instance) ApplyTorque(torque Float.X) { //gd:RigidBody2D.apply_torque
	Advanced(self).ApplyTorque(float64(torque))
}

/*
Adds a constant directional force without affecting rotation that keeps being applied over time until cleared with [code]constant_force = Vector2(0, 0)[/code].
This is equivalent to using [method add_constant_force] at the body's center of mass.
*/
func (self Instance) AddConstantCentralForce(force Vector2.XY) { //gd:RigidBody2D.add_constant_central_force
	Advanced(self).AddConstantCentralForce(Vector2.XY(force))
}

/*
Adds a constant positioned force to the body that keeps being applied over time until cleared with [code]constant_force = Vector2(0, 0)[/code].
[param position] is the offset from the body origin in global coordinates.
*/
func (self Instance) AddConstantForce(force Vector2.XY) { //gd:RigidBody2D.add_constant_force
	Advanced(self).AddConstantForce(Vector2.XY(force), Vector2.XY(gd.Vector2{0, 0}))
}

/*
Adds a constant positioned force to the body that keeps being applied over time until cleared with [code]constant_force = Vector2(0, 0)[/code].
[param position] is the offset from the body origin in global coordinates.
*/
func (self Expanded) AddConstantForce(force Vector2.XY, position Vector2.XY) { //gd:RigidBody2D.add_constant_force
	Advanced(self).AddConstantForce(Vector2.XY(force), Vector2.XY(position))
}

/*
Adds a constant rotational force without affecting position that keeps being applied over time until cleared with [code]constant_torque = 0[/code].
*/
func (self Instance) AddConstantTorque(torque Float.X) { //gd:RigidBody2D.add_constant_torque
	Advanced(self).AddConstantTorque(float64(torque))
}

/*
Returns a list of the bodies colliding with this one. Requires [member contact_monitor] to be set to [code]true[/code] and [member max_contacts_reported] to be set high enough to detect all the collisions.
[b]Note:[/b] The result of this test is not immediate after moving objects. For performance, list of collisions is updated once per frame and before the physics step. Consider using signals instead.
*/
func (self Instance) GetCollidingBodies() []Node2D.Instance { //gd:RigidBody2D.get_colliding_bodies
	return []Node2D.Instance(gd.ArrayAs[[]Node2D.Instance](gd.InternalArray(Advanced(self).GetCollidingBodies())))
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.RigidBody2D

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.RigidBody2D)(unsafe.Pointer(&obj))
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.RigidBody2D)(unsafe.Pointer(&obj))
		return true
	}
	return false
}

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {

	if !gd.Linked {
		var placeholder Instance
		*(*gd.Object)(unsafe.Pointer(&placeholder)) = pointers.Add[gd.Object]([3]uint64{})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(*(*gd.Object)(unsafe.Pointer(&placeholder)), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	object := [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})}
	casted := Instance{*(*gdclass.RigidBody2D)(unsafe.Pointer(&object))}
	object[0].Notification(0, false)
	return casted
}

func (self Instance) Mass() Float.X {
	return Float.X(Float.X(class(self).GetMass()))
}

func (self Instance) SetMass(value Float.X) {
	class(self).SetMass(float64(value))
}

func (self Instance) PhysicsMaterialOverride() PhysicsMaterial.Instance {
	return PhysicsMaterial.Instance(class(self).GetPhysicsMaterialOverride())
}

func (self Instance) SetPhysicsMaterialOverride(value PhysicsMaterial.Instance) {
	class(self).SetPhysicsMaterialOverride(value)
}

func (self Instance) GravityScale() Float.X {
	return Float.X(Float.X(class(self).GetGravityScale()))
}

func (self Instance) SetGravityScale(value Float.X) {
	class(self).SetGravityScale(float64(value))
}

func (self Instance) CenterOfMassMode() CenterOfMassMode {
	return CenterOfMassMode(class(self).GetCenterOfMassMode())
}

func (self Instance) SetCenterOfMassMode(value CenterOfMassMode) {
	class(self).SetCenterOfMassMode(value)
}

func (self Instance) CenterOfMass() Vector2.XY {
	return Vector2.XY(class(self).GetCenterOfMass())
}

func (self Instance) SetCenterOfMass(value Vector2.XY) {
	class(self).SetCenterOfMass(Vector2.XY(value))
}

func (self Instance) Inertia() Float.X {
	return Float.X(Float.X(class(self).GetInertia()))
}

func (self Instance) SetInertia(value Float.X) {
	class(self).SetInertia(float64(value))
}

func (self Instance) Sleeping() bool {
	return bool(class(self).IsSleeping())
}

func (self Instance) SetSleeping(value bool) {
	class(self).SetSleeping(value)
}

func (self Instance) CanSleep() bool {
	return bool(class(self).IsAbleToSleep())
}

func (self Instance) SetCanSleep(value bool) {
	class(self).SetCanSleep(value)
}

func (self Instance) LockRotation() bool {
	return bool(class(self).IsLockRotationEnabled())
}

func (self Instance) SetLockRotation(value bool) {
	class(self).SetLockRotationEnabled(value)
}

func (self Instance) Freeze() bool {
	return bool(class(self).IsFreezeEnabled())
}

func (self Instance) SetFreeze(value bool) {
	class(self).SetFreezeEnabled(value)
}

func (self Instance) FreezeMode() FreezeMode {
	return FreezeMode(class(self).GetFreezeMode())
}

func (self Instance) SetFreezeMode(value FreezeMode) {
	class(self).SetFreezeMode(value)
}

func (self Instance) CustomIntegrator() bool {
	return bool(class(self).IsUsingCustomIntegrator())
}

func (self Instance) SetCustomIntegrator(value bool) {
	class(self).SetUseCustomIntegrator(value)
}

func (self Instance) ContinuousCd() CCDMode {
	return CCDMode(class(self).GetContinuousCollisionDetectionMode())
}

func (self Instance) SetContinuousCd(value CCDMode) {
	class(self).SetContinuousCollisionDetectionMode(value)
}

func (self Instance) ContactMonitor() bool {
	return bool(class(self).IsContactMonitorEnabled())
}

func (self Instance) SetContactMonitor(value bool) {
	class(self).SetContactMonitor(value)
}

func (self Instance) MaxContactsReported() int {
	return int(int(class(self).GetMaxContactsReported()))
}

func (self Instance) SetMaxContactsReported(value int) {
	class(self).SetMaxContactsReported(int64(value))
}

func (self Instance) LinearVelocity() Vector2.XY {
	return Vector2.XY(class(self).GetLinearVelocity())
}

func (self Instance) SetLinearVelocity(value Vector2.XY) {
	class(self).SetLinearVelocity(Vector2.XY(value))
}

func (self Instance) LinearDampMode() DampMode {
	return DampMode(class(self).GetLinearDampMode())
}

func (self Instance) SetLinearDampMode(value DampMode) {
	class(self).SetLinearDampMode(value)
}

func (self Instance) LinearDamp() Float.X {
	return Float.X(Float.X(class(self).GetLinearDamp()))
}

func (self Instance) SetLinearDamp(value Float.X) {
	class(self).SetLinearDamp(float64(value))
}

func (self Instance) AngularVelocity() Float.X {
	return Float.X(Float.X(class(self).GetAngularVelocity()))
}

func (self Instance) SetAngularVelocity(value Float.X) {
	class(self).SetAngularVelocity(float64(value))
}

func (self Instance) AngularDampMode() DampMode {
	return DampMode(class(self).GetAngularDampMode())
}

func (self Instance) SetAngularDampMode(value DampMode) {
	class(self).SetAngularDampMode(value)
}

func (self Instance) AngularDamp() Float.X {
	return Float.X(Float.X(class(self).GetAngularDamp()))
}

func (self Instance) SetAngularDamp(value Float.X) {
	class(self).SetAngularDamp(float64(value))
}

func (self Instance) ConstantForce() Vector2.XY {
	return Vector2.XY(class(self).GetConstantForce())
}

func (self Instance) SetConstantForce(value Vector2.XY) {
	class(self).SetConstantForce(Vector2.XY(value))
}

func (self Instance) ConstantTorque() Float.X {
	return Float.X(Float.X(class(self).GetConstantTorque()))
}

func (self Instance) SetConstantTorque(value Float.X) {
	class(self).SetConstantTorque(float64(value))
}

/*
Called during physics processing, allowing you to read and safely modify the simulation state for the object. By default, it is called before the standard force integration, but the [member custom_integrator] property allows you to disable the standard force integration and do fully custom force integration for a body.
*/
func (class) _integrate_forces(impl func(ptr unsafe.Pointer, state [1]gdclass.PhysicsDirectBodyState2D)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var state = [1]gdclass.PhysicsDirectBodyState2D{pointers.New[gdclass.PhysicsDirectBodyState2D]([3]uint64{uint64(gd.UnsafeGet[gdextension.Object](p_args, 0))})}

		defer pointers.End(state[0])
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, state)
	}
}

//go:nosplit
func (self class) SetMass(mass float64) { //gd:RigidBody2D.set_mass
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_mass, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ mass float64 }{mass}))
}

//go:nosplit
func (self class) GetMass() float64 { //gd:RigidBody2D.get_mass
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_mass, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) GetInertia() float64 { //gd:RigidBody2D.get_inertia
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_inertia, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetInertia(inertia float64) { //gd:RigidBody2D.set_inertia
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_inertia, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ inertia float64 }{inertia}))
}

//go:nosplit
func (self class) SetCenterOfMassMode(mode CenterOfMassMode) { //gd:RigidBody2D.set_center_of_mass_mode
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_center_of_mass_mode, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ mode CenterOfMassMode }{mode}))
}

//go:nosplit
func (self class) GetCenterOfMassMode() CenterOfMassMode { //gd:RigidBody2D.get_center_of_mass_mode
	var r_ret = gdextension.Call[CenterOfMassMode](gd.ObjectChecked(self.AsObject()), methods.get_center_of_mass_mode, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetCenterOfMass(center_of_mass Vector2.XY) { //gd:RigidBody2D.set_center_of_mass
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_center_of_mass, 0|(gdextension.SizeVector2<<4), unsafe.Pointer(&struct{ center_of_mass Vector2.XY }{center_of_mass}))
}

//go:nosplit
func (self class) GetCenterOfMass() Vector2.XY { //gd:RigidBody2D.get_center_of_mass
	var r_ret = gdextension.Call[Vector2.XY](gd.ObjectChecked(self.AsObject()), methods.get_center_of_mass, gdextension.SizeVector2, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetPhysicsMaterialOverride(physics_material_override [1]gdclass.PhysicsMaterial) { //gd:RigidBody2D.set_physics_material_override
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_physics_material_override, 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ physics_material_override gdextension.Object }{gdextension.Object(gd.ObjectChecked(physics_material_override[0].AsObject()))}))
}

//go:nosplit
func (self class) GetPhysicsMaterialOverride() [1]gdclass.PhysicsMaterial { //gd:RigidBody2D.get_physics_material_override
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_physics_material_override, gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.PhysicsMaterial{gd.PointerWithOwnershipTransferredToGo[gdclass.PhysicsMaterial](r_ret)}
	return ret
}

//go:nosplit
func (self class) SetGravityScale(gravity_scale float64) { //gd:RigidBody2D.set_gravity_scale
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_gravity_scale, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ gravity_scale float64 }{gravity_scale}))
}

//go:nosplit
func (self class) GetGravityScale() float64 { //gd:RigidBody2D.get_gravity_scale
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_gravity_scale, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetLinearDampMode(linear_damp_mode DampMode) { //gd:RigidBody2D.set_linear_damp_mode
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_linear_damp_mode, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ linear_damp_mode DampMode }{linear_damp_mode}))
}

//go:nosplit
func (self class) GetLinearDampMode() DampMode { //gd:RigidBody2D.get_linear_damp_mode
	var r_ret = gdextension.Call[DampMode](gd.ObjectChecked(self.AsObject()), methods.get_linear_damp_mode, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetAngularDampMode(angular_damp_mode DampMode) { //gd:RigidBody2D.set_angular_damp_mode
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_angular_damp_mode, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ angular_damp_mode DampMode }{angular_damp_mode}))
}

//go:nosplit
func (self class) GetAngularDampMode() DampMode { //gd:RigidBody2D.get_angular_damp_mode
	var r_ret = gdextension.Call[DampMode](gd.ObjectChecked(self.AsObject()), methods.get_angular_damp_mode, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetLinearDamp(linear_damp float64) { //gd:RigidBody2D.set_linear_damp
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_linear_damp, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ linear_damp float64 }{linear_damp}))
}

//go:nosplit
func (self class) GetLinearDamp() float64 { //gd:RigidBody2D.get_linear_damp
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_linear_damp, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetAngularDamp(angular_damp float64) { //gd:RigidBody2D.set_angular_damp
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_angular_damp, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ angular_damp float64 }{angular_damp}))
}

//go:nosplit
func (self class) GetAngularDamp() float64 { //gd:RigidBody2D.get_angular_damp
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_angular_damp, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetLinearVelocity(linear_velocity Vector2.XY) { //gd:RigidBody2D.set_linear_velocity
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_linear_velocity, 0|(gdextension.SizeVector2<<4), unsafe.Pointer(&struct{ linear_velocity Vector2.XY }{linear_velocity}))
}

//go:nosplit
func (self class) GetLinearVelocity() Vector2.XY { //gd:RigidBody2D.get_linear_velocity
	var r_ret = gdextension.Call[Vector2.XY](gd.ObjectChecked(self.AsObject()), methods.get_linear_velocity, gdextension.SizeVector2, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetAngularVelocity(angular_velocity float64) { //gd:RigidBody2D.set_angular_velocity
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_angular_velocity, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ angular_velocity float64 }{angular_velocity}))
}

//go:nosplit
func (self class) GetAngularVelocity() float64 { //gd:RigidBody2D.get_angular_velocity
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_angular_velocity, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetMaxContactsReported(amount int64) { //gd:RigidBody2D.set_max_contacts_reported
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_max_contacts_reported, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ amount int64 }{amount}))
}

//go:nosplit
func (self class) GetMaxContactsReported() int64 { //gd:RigidBody2D.get_max_contacts_reported
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_max_contacts_reported, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the number of contacts this body has with other bodies. By default, this returns 0 unless bodies are configured to monitor contacts (see [member contact_monitor]).
[b]Note:[/b] To retrieve the colliding bodies, use [method get_colliding_bodies].
*/
//go:nosplit
func (self class) GetContactCount() int64 { //gd:RigidBody2D.get_contact_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_contact_count, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetUseCustomIntegrator(enable bool) { //gd:RigidBody2D.set_use_custom_integrator
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_use_custom_integrator, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

//go:nosplit
func (self class) IsUsingCustomIntegrator() bool { //gd:RigidBody2D.is_using_custom_integrator
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_using_custom_integrator, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetContactMonitor(enabled bool) { //gd:RigidBody2D.set_contact_monitor
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_contact_monitor, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enabled bool }{enabled}))
}

//go:nosplit
func (self class) IsContactMonitorEnabled() bool { //gd:RigidBody2D.is_contact_monitor_enabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_contact_monitor_enabled, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetContinuousCollisionDetectionMode(mode CCDMode) { //gd:RigidBody2D.set_continuous_collision_detection_mode
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_continuous_collision_detection_mode, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ mode CCDMode }{mode}))
}

//go:nosplit
func (self class) GetContinuousCollisionDetectionMode() CCDMode { //gd:RigidBody2D.get_continuous_collision_detection_mode
	var r_ret = gdextension.Call[CCDMode](gd.ObjectChecked(self.AsObject()), methods.get_continuous_collision_detection_mode, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Sets the body's velocity on the given axis. The velocity in the given vector axis will be set as the given vector length. This is useful for jumping behavior.
*/
//go:nosplit
func (self class) SetAxisVelocity(axis_velocity Vector2.XY) { //gd:RigidBody2D.set_axis_velocity
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_axis_velocity, 0|(gdextension.SizeVector2<<4), unsafe.Pointer(&struct{ axis_velocity Vector2.XY }{axis_velocity}))
}

/*
Applies a directional impulse without affecting rotation.
An impulse is time-independent! Applying an impulse every frame would result in a framerate-dependent force. For this reason, it should only be used when simulating one-time impacts (use the "_force" functions otherwise).
This is equivalent to using [method apply_impulse] at the body's center of mass.
*/
//go:nosplit
func (self class) ApplyCentralImpulse(impulse Vector2.XY) { //gd:RigidBody2D.apply_central_impulse
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.apply_central_impulse, 0|(gdextension.SizeVector2<<4), unsafe.Pointer(&struct{ impulse Vector2.XY }{impulse}))
}

/*
Applies a positioned impulse to the body.
An impulse is time-independent! Applying an impulse every frame would result in a framerate-dependent force. For this reason, it should only be used when simulating one-time impacts (use the "_force" functions otherwise).
[param position] is the offset from the body origin in global coordinates.
*/
//go:nosplit
func (self class) ApplyImpulse(impulse Vector2.XY, position Vector2.XY) { //gd:RigidBody2D.apply_impulse
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.apply_impulse, 0|(gdextension.SizeVector2<<4)|(gdextension.SizeVector2<<8), unsafe.Pointer(&struct {
		impulse  Vector2.XY
		position Vector2.XY
	}{impulse, position}))
}

/*
Applies a rotational impulse to the body without affecting the position.
An impulse is time-independent! Applying an impulse every frame would result in a framerate-dependent force. For this reason, it should only be used when simulating one-time impacts (use the "_force" functions otherwise).
[b]Note:[/b] [member inertia] is required for this to work. To have [member inertia], an active [CollisionShape2D] must be a child of the node, or you can manually set [member inertia].
*/
//go:nosplit
func (self class) ApplyTorqueImpulse(torque float64) { //gd:RigidBody2D.apply_torque_impulse
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.apply_torque_impulse, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ torque float64 }{torque}))
}

/*
Applies a directional force without affecting rotation. A force is time dependent and meant to be applied every physics update.
This is equivalent to using [method apply_force] at the body's center of mass.
*/
//go:nosplit
func (self class) ApplyCentralForce(force Vector2.XY) { //gd:RigidBody2D.apply_central_force
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.apply_central_force, 0|(gdextension.SizeVector2<<4), unsafe.Pointer(&struct{ force Vector2.XY }{force}))
}

/*
Applies a positioned force to the body. A force is time dependent and meant to be applied every physics update.
[param position] is the offset from the body origin in global coordinates.
*/
//go:nosplit
func (self class) ApplyForce(force Vector2.XY, position Vector2.XY) { //gd:RigidBody2D.apply_force
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.apply_force, 0|(gdextension.SizeVector2<<4)|(gdextension.SizeVector2<<8), unsafe.Pointer(&struct {
		force    Vector2.XY
		position Vector2.XY
	}{force, position}))
}

/*
Applies a rotational force without affecting position. A force is time dependent and meant to be applied every physics update.
[b]Note:[/b] [member inertia] is required for this to work. To have [member inertia], an active [CollisionShape2D] must be a child of the node, or you can manually set [member inertia].
*/
//go:nosplit
func (self class) ApplyTorque(torque float64) { //gd:RigidBody2D.apply_torque
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.apply_torque, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ torque float64 }{torque}))
}

/*
Adds a constant directional force without affecting rotation that keeps being applied over time until cleared with [code]constant_force = Vector2(0, 0)[/code].
This is equivalent to using [method add_constant_force] at the body's center of mass.
*/
//go:nosplit
func (self class) AddConstantCentralForce(force Vector2.XY) { //gd:RigidBody2D.add_constant_central_force
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_constant_central_force, 0|(gdextension.SizeVector2<<4), unsafe.Pointer(&struct{ force Vector2.XY }{force}))
}

/*
Adds a constant positioned force to the body that keeps being applied over time until cleared with [code]constant_force = Vector2(0, 0)[/code].
[param position] is the offset from the body origin in global coordinates.
*/
//go:nosplit
func (self class) AddConstantForce(force Vector2.XY, position Vector2.XY) { //gd:RigidBody2D.add_constant_force
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_constant_force, 0|(gdextension.SizeVector2<<4)|(gdextension.SizeVector2<<8), unsafe.Pointer(&struct {
		force    Vector2.XY
		position Vector2.XY
	}{force, position}))
}

/*
Adds a constant rotational force without affecting position that keeps being applied over time until cleared with [code]constant_torque = 0[/code].
*/
//go:nosplit
func (self class) AddConstantTorque(torque float64) { //gd:RigidBody2D.add_constant_torque
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_constant_torque, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ torque float64 }{torque}))
}

//go:nosplit
func (self class) SetConstantForce(force Vector2.XY) { //gd:RigidBody2D.set_constant_force
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_constant_force, 0|(gdextension.SizeVector2<<4), unsafe.Pointer(&struct{ force Vector2.XY }{force}))
}

//go:nosplit
func (self class) GetConstantForce() Vector2.XY { //gd:RigidBody2D.get_constant_force
	var r_ret = gdextension.Call[Vector2.XY](gd.ObjectChecked(self.AsObject()), methods.get_constant_force, gdextension.SizeVector2, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetConstantTorque(torque float64) { //gd:RigidBody2D.set_constant_torque
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_constant_torque, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ torque float64 }{torque}))
}

//go:nosplit
func (self class) GetConstantTorque() float64 { //gd:RigidBody2D.get_constant_torque
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_constant_torque, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetSleeping(sleeping bool) { //gd:RigidBody2D.set_sleeping
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_sleeping, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ sleeping bool }{sleeping}))
}

//go:nosplit
func (self class) IsSleeping() bool { //gd:RigidBody2D.is_sleeping
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_sleeping, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetCanSleep(able_to_sleep bool) { //gd:RigidBody2D.set_can_sleep
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_can_sleep, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ able_to_sleep bool }{able_to_sleep}))
}

//go:nosplit
func (self class) IsAbleToSleep() bool { //gd:RigidBody2D.is_able_to_sleep
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_able_to_sleep, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetLockRotationEnabled(lock_rotation bool) { //gd:RigidBody2D.set_lock_rotation_enabled
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_lock_rotation_enabled, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ lock_rotation bool }{lock_rotation}))
}

//go:nosplit
func (self class) IsLockRotationEnabled() bool { //gd:RigidBody2D.is_lock_rotation_enabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_lock_rotation_enabled, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetFreezeEnabled(freeze_mode bool) { //gd:RigidBody2D.set_freeze_enabled
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_freeze_enabled, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ freeze_mode bool }{freeze_mode}))
}

//go:nosplit
func (self class) IsFreezeEnabled() bool { //gd:RigidBody2D.is_freeze_enabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_freeze_enabled, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetFreezeMode(freeze_mode FreezeMode) { //gd:RigidBody2D.set_freeze_mode
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_freeze_mode, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ freeze_mode FreezeMode }{freeze_mode}))
}

//go:nosplit
func (self class) GetFreezeMode() FreezeMode { //gd:RigidBody2D.get_freeze_mode
	var r_ret = gdextension.Call[FreezeMode](gd.ObjectChecked(self.AsObject()), methods.get_freeze_mode, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns a list of the bodies colliding with this one. Requires [member contact_monitor] to be set to [code]true[/code] and [member max_contacts_reported] to be set high enough to detect all the collisions.
[b]Note:[/b] The result of this test is not immediate after moving objects. For performance, list of collisions is updated once per frame and before the physics step. Consider using signals instead.
*/
//go:nosplit
func (self class) GetCollidingBodies() Array.Contains[[1]gdclass.Node2D] { //gd:RigidBody2D.get_colliding_bodies
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), methods.get_colliding_bodies, gdextension.SizeArray, unsafe.Pointer(&struct{}{}))
	var ret = Array.Through(gd.ArrayProxy[[1]gdclass.Node2D]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}
func (self Instance) OnBodyShapeEntered(cb func(body_rid RID.Any, body Node.Instance, body_shape_index int, local_shape_index int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("body_shape_entered"), gd.NewCallable(cb), 0)
}

func (self Instance) OnBodyShapeExited(cb func(body_rid RID.Any, body Node.Instance, body_shape_index int, local_shape_index int)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("body_shape_exited"), gd.NewCallable(cb), 0)
}

func (self Instance) OnBodyEntered(cb func(body Node.Instance)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("body_entered"), gd.NewCallable(cb), 0)
}

func (self Instance) OnBodyExited(cb func(body Node.Instance)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("body_exited"), gd.NewCallable(cb), 0)
}

func (self Instance) OnSleepingStateChanged(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("sleeping_state_changed"), gd.NewCallable(cb), 0)
}

func (self class) AsRigidBody2D() Advanced         { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsRigidBody2D() Instance      { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsRigidBody2D() Instance { return self.Super().AsRigidBody2D() }
func (self class) AsPhysicsBody2D() PhysicsBody2D.Advanced {
	return *((*PhysicsBody2D.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsPhysicsBody2D() PhysicsBody2D.Instance {
	return self.Super().AsPhysicsBody2D()
}
func (self Instance) AsPhysicsBody2D() PhysicsBody2D.Instance {
	return *((*PhysicsBody2D.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsCollisionObject2D() CollisionObject2D.Advanced {
	return *((*CollisionObject2D.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsCollisionObject2D() CollisionObject2D.Instance {
	return self.Super().AsCollisionObject2D()
}
func (self Instance) AsCollisionObject2D() CollisionObject2D.Instance {
	return *((*CollisionObject2D.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsNode2D() Node2D.Advanced         { return *((*Node2D.Advanced)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsNode2D() Node2D.Instance { return self.Super().AsNode2D() }
func (self Instance) AsNode2D() Node2D.Instance      { return *((*Node2D.Instance)(unsafe.Pointer(&self))) }
func (self class) AsCanvasItem() CanvasItem.Advanced {
	return *((*CanvasItem.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsCanvasItem() CanvasItem.Instance { return self.Super().AsCanvasItem() }
func (self Instance) AsCanvasItem() CanvasItem.Instance {
	return *((*CanvasItem.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsNode() Node.Advanced         { return *((*Node.Advanced)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsNode() Node.Instance { return self.Super().AsNode() }
func (self Instance) AsNode() Node.Instance      { return *((*Node.Instance)(unsafe.Pointer(&self))) }

func (self class) Virtual(name string) reflect.Value {
	switch name {
	case "_integrate_forces":
		return reflect.ValueOf(self._integrate_forces)
	default:
		return gd.VirtualByName(PhysicsBody2D.Advanced(self.AsPhysicsBody2D()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	case "_integrate_forces":
		return reflect.ValueOf(self._integrate_forces)
	default:
		return gd.VirtualByName(PhysicsBody2D.Instance(self.AsPhysicsBody2D()), name)
	}
}
func init() {
	gdclass.Register("RigidBody2D", func(ptr gd.Object) any { return *(*Instance)(unsafe.Pointer(&ptr)) })
}

type FreezeMode int //gd:RigidBody2D.FreezeMode

const (
	/*Static body freeze mode (default). The body is not affected by gravity and forces. It can be only moved by user code and doesn't collide with other bodies along its path.*/
	FreezeModeStatic FreezeMode = 0
	/*Kinematic body freeze mode. Similar to [constant FREEZE_MODE_STATIC], but collides with other bodies along its path when moved. Useful for a frozen body that needs to be animated.*/
	FreezeModeKinematic FreezeMode = 1
)

type CenterOfMassMode int //gd:RigidBody2D.CenterOfMassMode

const (
	/*In this mode, the body's center of mass is calculated automatically based on its shapes. This assumes that the shapes' origins are also their center of mass.*/
	CenterOfMassModeAuto CenterOfMassMode = 0
	/*In this mode, the body's center of mass is set through [member center_of_mass]. Defaults to the body's origin position.*/
	CenterOfMassModeCustom CenterOfMassMode = 1
)

type DampMode int //gd:RigidBody2D.DampMode

const (
	/*In this mode, the body's damping value is added to any value set in areas or the default value.*/
	DampModeCombine DampMode = 0
	/*In this mode, the body's damping value replaces any value set in areas or the default value.*/
	DampModeReplace DampMode = 1
)

type CCDMode int //gd:RigidBody2D.CCDMode

const (
	/*Continuous collision detection disabled. This is the fastest way to detect body collisions, but can miss small, fast-moving objects.*/
	CcdModeDisabled CCDMode = 0
	/*Continuous collision detection enabled using raycasting. This is faster than shapecasting but less precise.*/
	CcdModeCastRay CCDMode = 1
	/*Continuous collision detection enabled using shapecasting. This is the slowest CCD method and the most precise.*/
	CcdModeCastShape CCDMode = 2
)
