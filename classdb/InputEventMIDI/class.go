// Code generated by the generate package DO NOT EDIT

// Package InputEventMIDI provides methods for working with InputEventMIDI object instances.
package InputEventMIDI

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/variant/Signal"
import "graphics.gd/classdb/InputEvent"
import "graphics.gd/classdb/Resource"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Signal.Any
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
InputEventMIDI stores information about messages from [url=https://en.wikipedia.org/wiki/MIDI]MIDI[/url] (Musical Instrument Digital Interface) devices. These may include musical keyboards, synthesizers, and drum machines.
MIDI messages can be received over a 5-pin MIDI connector or over USB. If your device supports both be sure to check the settings in the device to see which output it is using.
By default, Godot does not detect MIDI devices. You need to call [method OS.open_midi_inputs], first. You can check which devices are detected with [method OS.get_connected_midi_inputs], and close the connection with [method OS.close_midi_inputs].
[codeblocks]
[gdscript]
func _ready():

	OS.open_midi_inputs()
	print(OS.get_connected_midi_inputs())

func _input(input_event):

	if input_event is InputEventMIDI:
	    _print_midi_info(input_event)

func _print_midi_info(midi_event):

	print(midi_event)
	print("Channel ", midi_event.channel)
	print("Message ", midi_event.message)
	print("Pitch ", midi_event.pitch)
	print("Velocity ", midi_event.velocity)
	print("Instrument ", midi_event.instrument)
	print("Pressure ", midi_event.pressure)
	print("Controller number: ", midi_event.controller_number)
	print("Controller value: ", midi_event.controller_value)

[/gdscript]
[csharp]
public override void _Ready()

	{
	    OS.OpenMidiInputs();
	    GD.Print(OS.GetConnectedMidiInputs());
	}

public override void _Input(InputEvent inputEvent)

	{
	    if (inputEvent is InputEventMidi midiEvent)
	    {
	        PrintMIDIInfo(midiEvent);
	    }
	}

private void PrintMIDIInfo(InputEventMidi midiEvent)

	{
	    GD.Print(midiEvent);
	    GD.Print($"Channel {midiEvent.Channel}");
	    GD.Print($"Message {midiEvent.Message}");
	    GD.Print($"Pitch {midiEvent.Pitch}");
	    GD.Print($"Velocity {midiEvent.Velocity}");
	    GD.Print($"Instrument {midiEvent.Instrument}");
	    GD.Print($"Pressure {midiEvent.Pressure}");
	    GD.Print($"Controller number: {midiEvent.ControllerNumber}");
	    GD.Print($"Controller value: {midiEvent.ControllerValue}");
	}

[/csharp]
[/codeblocks]
[b]Note:[/b] Godot does not support MIDI output, so there is no way to emit MIDI messages from Godot. Only MIDI input is supported.
[b]Note:[/b] On the Web platform, using MIDI input requires a browser permission to be granted first. This permission request is performed when calling [method OS.open_midi_inputs]. MIDI input will not work until the user accepts the permission request.
*/
type Instance [1]gdclass.InputEventMIDI

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	set_channel           gdextension.MethodForClass `hash:"1286410249"`
	get_channel           gdextension.MethodForClass `hash:"3905245786"`
	set_message           gdextension.MethodForClass `hash:"1064271510"`
	get_message           gdextension.MethodForClass `hash:"1936512097"`
	set_pitch             gdextension.MethodForClass `hash:"1286410249"`
	get_pitch             gdextension.MethodForClass `hash:"3905245786"`
	set_velocity          gdextension.MethodForClass `hash:"1286410249"`
	get_velocity          gdextension.MethodForClass `hash:"3905245786"`
	set_instrument        gdextension.MethodForClass `hash:"1286410249"`
	get_instrument        gdextension.MethodForClass `hash:"3905245786"`
	set_pressure          gdextension.MethodForClass `hash:"1286410249"`
	get_pressure          gdextension.MethodForClass `hash:"3905245786"`
	set_controller_number gdextension.MethodForClass `hash:"1286410249"`
	get_controller_number gdextension.MethodForClass `hash:"3905245786"`
	set_controller_value  gdextension.MethodForClass `hash:"1286410249"`
	get_controller_value  gdextension.MethodForClass `hash:"3905245786"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("InputEventMIDI")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		gdextension.Free(gdextension.TypeStringName, &sname)
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsInputEventMIDI() Instance
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.InputEventMIDI

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.InputEventMIDI)(unsafe.Pointer(&obj))
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.InputEventMIDI)(unsafe.Pointer(&obj))
		return true
	}
	return false
}

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {

	if !gd.Linked {
		var placeholder Instance
		*(*gd.Object)(unsafe.Pointer(&placeholder)) = pointers.Add[gd.Object]([3]uint64{})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(*(*gd.Object)(unsafe.Pointer(&placeholder)), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	object := [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})}
	casted := Instance{*(*gdclass.InputEventMIDI)(unsafe.Pointer(&object))}
	casted.AsRefCounted()[0].InitRef()
	object[0].Notification(0, false)
	return casted
}

func (self Instance) Channel() int {
	return int(int(class(self).GetChannel()))
}

func (self Instance) SetChannel(value int) {
	class(self).SetChannel(int64(value))
}

func (self Instance) Message() Message {
	return Message(class(self).GetMessage())
}

func (self Instance) SetMessage(value Message) {
	class(self).SetMessage(value)
}

func (self Instance) Pitch() int {
	return int(int(class(self).GetPitch()))
}

func (self Instance) SetPitch(value int) {
	class(self).SetPitch(int64(value))
}

func (self Instance) Velocity() int {
	return int(int(class(self).GetVelocity()))
}

func (self Instance) SetVelocity(value int) {
	class(self).SetVelocity(int64(value))
}

func (self Instance) Instrument() int {
	return int(int(class(self).GetInstrument()))
}

func (self Instance) SetInstrument(value int) {
	class(self).SetInstrument(int64(value))
}

func (self Instance) Pressure() int {
	return int(int(class(self).GetPressure()))
}

func (self Instance) SetPressure(value int) {
	class(self).SetPressure(int64(value))
}

func (self Instance) ControllerNumber() int {
	return int(int(class(self).GetControllerNumber()))
}

func (self Instance) SetControllerNumber(value int) {
	class(self).SetControllerNumber(int64(value))
}

func (self Instance) ControllerValue() int {
	return int(int(class(self).GetControllerValue()))
}

func (self Instance) SetControllerValue(value int) {
	class(self).SetControllerValue(int64(value))
}

//go:nosplit
func (self class) SetChannel(channel int64) { //gd:InputEventMIDI.set_channel
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_channel, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ channel int64 }{channel}))
}

//go:nosplit
func (self class) GetChannel() int64 { //gd:InputEventMIDI.get_channel
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_channel, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetMessage(message Message) { //gd:InputEventMIDI.set_message
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_message, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ message Message }{message}))
}

//go:nosplit
func (self class) GetMessage() Message { //gd:InputEventMIDI.get_message
	var r_ret = gdextension.Call[Message](gd.ObjectChecked(self.AsObject()), methods.get_message, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetPitch(pitch int64) { //gd:InputEventMIDI.set_pitch
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_pitch, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ pitch int64 }{pitch}))
}

//go:nosplit
func (self class) GetPitch() int64 { //gd:InputEventMIDI.get_pitch
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_pitch, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetVelocity(velocity int64) { //gd:InputEventMIDI.set_velocity
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_velocity, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ velocity int64 }{velocity}))
}

//go:nosplit
func (self class) GetVelocity() int64 { //gd:InputEventMIDI.get_velocity
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_velocity, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetInstrument(instrument int64) { //gd:InputEventMIDI.set_instrument
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_instrument, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ instrument int64 }{instrument}))
}

//go:nosplit
func (self class) GetInstrument() int64 { //gd:InputEventMIDI.get_instrument
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_instrument, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetPressure(pressure int64) { //gd:InputEventMIDI.set_pressure
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_pressure, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ pressure int64 }{pressure}))
}

//go:nosplit
func (self class) GetPressure() int64 { //gd:InputEventMIDI.get_pressure
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_pressure, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetControllerNumber(controller_number int64) { //gd:InputEventMIDI.set_controller_number
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_controller_number, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ controller_number int64 }{controller_number}))
}

//go:nosplit
func (self class) GetControllerNumber() int64 { //gd:InputEventMIDI.get_controller_number
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_controller_number, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetControllerValue(controller_value int64) { //gd:InputEventMIDI.set_controller_value
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_controller_value, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ controller_value int64 }{controller_value}))
}

//go:nosplit
func (self class) GetControllerValue() int64 { //gd:InputEventMIDI.get_controller_value
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_controller_value, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}
func (self class) AsInputEventMIDI() Advanced         { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsInputEventMIDI() Instance      { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsInputEventMIDI() Instance { return self.Super().AsInputEventMIDI() }
func (self class) AsInputEvent() InputEvent.Advanced {
	return *((*InputEvent.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsInputEvent() InputEvent.Instance { return self.Super().AsInputEvent() }
func (self Instance) AsInputEvent() InputEvent.Instance {
	return *((*InputEvent.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsResource() Resource.Advanced {
	return *((*Resource.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsResource() Resource.Instance { return self.Super().AsResource() }
func (self Instance) AsResource() Resource.Instance {
	return *((*Resource.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsRefCounted() [1]gd.RefCounted { return self.Super().AsRefCounted() }
func (self Instance) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(InputEvent.Advanced(self.AsInputEvent()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(InputEvent.Instance(self.AsInputEvent()), name)
	}
}
func init() {
	gdclass.Register("InputEventMIDI", func(ptr gd.Object) any { return *(*Instance)(unsafe.Pointer(&ptr)) })
}

type Message int //gd:MIDIMessage

const (
	/*Does not correspond to any MIDI message. This is the default value of [member InputEventMIDI.message].*/
	MidiMessageNone Message = 0
	/*MIDI message sent when a note is released.
	  [b]Note:[/b] Not all MIDI devices send this message; some may send [constant MIDI_MESSAGE_NOTE_ON] with [member InputEventMIDI.velocity] set to [code]0[/code].*/
	MidiMessageNoteOff Message = 8
	/*MIDI message sent when a note is pressed.*/
	MidiMessageNoteOn Message = 9
	/*MIDI message sent to indicate a change in pressure while a note is being pressed down, also called aftertouch.*/
	MidiMessageAftertouch Message = 10
	/*MIDI message sent when a controller value changes. In a MIDI device, a controller is any input that doesn't play notes. These may include sliders for volume, balance, and panning, as well as switches and pedals. See the [url=https://en.wikipedia.org/wiki/General_MIDI#Controller_events]General MIDI specification[/url] for a small list.*/
	MidiMessageControlChange Message = 11
	/*MIDI message sent when the MIDI device changes its current instrument (also called [i]program[/i] or [i]preset[/i]).*/
	MidiMessageProgramChange Message = 12
	/*MIDI message sent to indicate a change in pressure for the whole channel. Some MIDI devices may send this instead of [constant MIDI_MESSAGE_AFTERTOUCH].*/
	MidiMessageChannelPressure Message = 13
	/*MIDI message sent when the value of the pitch bender changes, usually a wheel on the MIDI device.*/
	MidiMessagePitchBend Message = 14
	/*MIDI system exclusive (SysEx) message. This type of message is not standardized and it's highly dependent on the MIDI device sending it.
	  [b]Note:[/b] Getting this message's data from [InputEventMIDI] is not implemented.*/
	MidiMessageSystemExclusive Message = 240
	/*MIDI message sent every quarter frame to keep connected MIDI devices synchronized. Related to [constant MIDI_MESSAGE_TIMING_CLOCK].
	  [b]Note:[/b] Getting this message's data from [InputEventMIDI] is not implemented.*/
	MidiMessageQuarterFrame Message = 241
	/*MIDI message sent to jump onto a new position in the current sequence or song.
	  [b]Note:[/b] Getting this message's data from [InputEventMIDI] is not implemented.*/
	MidiMessageSongPositionPointer Message = 242
	/*MIDI message sent to select a sequence or song to play.
	  [b]Note:[/b] Getting this message's data from [InputEventMIDI] is not implemented.*/
	MidiMessageSongSelect Message = 243
	/*MIDI message sent to request a tuning calibration. Used on analog synthesizers. Most modern MIDI devices do not need this message.*/
	MidiMessageTuneRequest Message = 246
	/*MIDI message sent 24 times after [constant MIDI_MESSAGE_QUARTER_FRAME], to keep connected MIDI devices synchronized.*/
	MidiMessageTimingClock Message = 248
	/*MIDI message sent to start the current sequence or song from the beginning.*/
	MidiMessageStart Message = 250
	/*MIDI message sent to resume from the point the current sequence or song was paused.*/
	MidiMessageContinue Message = 251
	/*MIDI message sent to pause the current sequence or song.*/
	MidiMessageStop Message = 252
	/*MIDI message sent repeatedly while the MIDI device is idle, to tell the receiver that the connection is alive. Most MIDI devices do not send this message.*/
	MidiMessageActiveSensing Message = 254
	/*MIDI message sent to reset a MIDI device to its default state, as if it was just turned on. It should not be sent when the MIDI device is being turned on.*/
	MidiMessageSystemReset Message = 255
)
