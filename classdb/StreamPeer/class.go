// Code generated by the generate package DO NOT EDIT

// Package StreamPeer provides methods for working with StreamPeer object instances.
package StreamPeer

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
StreamPeer is an abstract base class mostly used for stream-based protocols (such as TCP). It provides an API for sending and receiving data through streams as raw data or strings.
[b]Note:[/b] When exporting to Android, make sure to enable the [code]INTERNET[/code] permission in the Android export preset before exporting the project or using one-click deploy. Otherwise, network communication of any kind will be blocked by Android.
*/
type Instance [1]gdclass.StreamPeer

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	put_data              gdextension.MethodForClass `hash:"680677267"`
	put_partial_data      gdextension.MethodForClass `hash:"2934048347"`
	get_data              gdextension.MethodForClass `hash:"1171824711"`
	get_partial_data      gdextension.MethodForClass `hash:"1171824711"`
	get_available_bytes   gdextension.MethodForClass `hash:"3905245786"`
	set_big_endian        gdextension.MethodForClass `hash:"2586408642"`
	is_big_endian_enabled gdextension.MethodForClass `hash:"36873697"`
	put_8                 gdextension.MethodForClass `hash:"1286410249"`
	put_u8                gdextension.MethodForClass `hash:"1286410249"`
	put_16                gdextension.MethodForClass `hash:"1286410249"`
	put_u16               gdextension.MethodForClass `hash:"1286410249"`
	put_32                gdextension.MethodForClass `hash:"1286410249"`
	put_u32               gdextension.MethodForClass `hash:"1286410249"`
	put_64                gdextension.MethodForClass `hash:"1286410249"`
	put_u64               gdextension.MethodForClass `hash:"1286410249"`
	put_half              gdextension.MethodForClass `hash:"373806689"`
	put_float             gdextension.MethodForClass `hash:"373806689"`
	put_double            gdextension.MethodForClass `hash:"373806689"`
	put_string            gdextension.MethodForClass `hash:"83702148"`
	put_utf8_string       gdextension.MethodForClass `hash:"83702148"`
	put_var               gdextension.MethodForClass `hash:"738511890"`
	get_8                 gdextension.MethodForClass `hash:"2455072627"`
	get_u8                gdextension.MethodForClass `hash:"2455072627"`
	get_16                gdextension.MethodForClass `hash:"2455072627"`
	get_u16               gdextension.MethodForClass `hash:"2455072627"`
	get_32                gdextension.MethodForClass `hash:"2455072627"`
	get_u32               gdextension.MethodForClass `hash:"2455072627"`
	get_64                gdextension.MethodForClass `hash:"2455072627"`
	get_u64               gdextension.MethodForClass `hash:"2455072627"`
	get_half              gdextension.MethodForClass `hash:"191475506"`
	get_float             gdextension.MethodForClass `hash:"191475506"`
	get_double            gdextension.MethodForClass `hash:"191475506"`
	get_string            gdextension.MethodForClass `hash:"2309358862"`
	get_utf8_string       gdextension.MethodForClass `hash:"2309358862"`
	get_var               gdextension.MethodForClass `hash:"3442865206"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("StreamPeer")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		gdextension.Free(gdextension.TypeStringName, &sname)
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

type Expanded [1]gdclass.StreamPeer

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsStreamPeer() Instance
}

/*
Sends a chunk of data through the connection, blocking if necessary until the data is done sending. This function returns an [enum Error] code.
*/
func (self Instance) PutData(data []byte) error { //gd:StreamPeer.put_data
	return error(gd.ToError(Advanced(self).PutData(Packed.Bytes(Packed.New(data...)))))
}

/*
Sends a chunk of data through the connection. If all the data could not be sent at once, only part of it will. This function returns two values, an [enum Error] code and an integer, describing how much data was actually sent.
*/
func (self Instance) PutPartialData(data []byte) []any { //gd:StreamPeer.put_partial_data
	return []any(gd.ArrayAs[[]any](gd.InternalArray(Advanced(self).PutPartialData(Packed.Bytes(Packed.New(data...))))))
}

/*
Returns a chunk data with the received bytes. The number of bytes to be received can be requested in the [param bytes] argument. If not enough bytes are available, the function will block until the desired amount is received. This function returns two values, an [enum Error] code and a data array.
*/
func (self Instance) GetData(bytes int) []any { //gd:StreamPeer.get_data
	return []any(gd.ArrayAs[[]any](gd.InternalArray(Advanced(self).GetData(int64(bytes)))))
}

/*
Returns a chunk data with the received bytes. The number of bytes to be received can be requested in the "bytes" argument. If not enough bytes are available, the function will return how many were actually received. This function returns two values, an [enum Error] code, and a data array.
*/
func (self Instance) GetPartialData(bytes int) []any { //gd:StreamPeer.get_partial_data
	return []any(gd.ArrayAs[[]any](gd.InternalArray(Advanced(self).GetPartialData(int64(bytes)))))
}

/*
Returns the number of bytes this [StreamPeer] has available.
*/
func (self Instance) GetAvailableBytes() int { //gd:StreamPeer.get_available_bytes
	return int(int(Advanced(self).GetAvailableBytes()))
}

/*
Puts a signed byte into the stream.
*/
func (self Instance) Put8(value int) { //gd:StreamPeer.put_8
	Advanced(self).Put8(int64(value))
}

/*
Puts an unsigned byte into the stream.
*/
func (self Instance) PutU8(value int) { //gd:StreamPeer.put_u8
	Advanced(self).PutU8(int64(value))
}

/*
Puts a signed 16-bit value into the stream.
*/
func (self Instance) Put16(value int) { //gd:StreamPeer.put_16
	Advanced(self).Put16(int64(value))
}

/*
Puts an unsigned 16-bit value into the stream.
*/
func (self Instance) PutU16(value int) { //gd:StreamPeer.put_u16
	Advanced(self).PutU16(int64(value))
}

/*
Puts a signed 32-bit value into the stream.
*/
func (self Instance) Put32(value int) { //gd:StreamPeer.put_32
	Advanced(self).Put32(int64(value))
}

/*
Puts an unsigned 32-bit value into the stream.
*/
func (self Instance) PutU32(value int) { //gd:StreamPeer.put_u32
	Advanced(self).PutU32(int64(value))
}

/*
Puts a signed 64-bit value into the stream.
*/
func (self Instance) Put64(value int) { //gd:StreamPeer.put_64
	Advanced(self).Put64(int64(value))
}

/*
Puts an unsigned 64-bit value into the stream.
*/
func (self Instance) PutU64(value int) { //gd:StreamPeer.put_u64
	Advanced(self).PutU64(int64(value))
}

/*
Puts a half-precision float into the stream.
*/
func (self Instance) PutHalf(value Float.X) { //gd:StreamPeer.put_half
	Advanced(self).PutHalf(float64(value))
}

/*
Puts a single-precision float into the stream.
*/
func (self Instance) PutFloat(value Float.X) { //gd:StreamPeer.put_float
	Advanced(self).PutFloat(float64(value))
}

/*
Puts a double-precision float into the stream.
*/
func (self Instance) PutDouble(value Float.X) { //gd:StreamPeer.put_double
	Advanced(self).PutDouble(float64(value))
}

/*
Puts a zero-terminated ASCII string into the stream prepended by a 32-bit unsigned integer representing its size.
[b]Note:[/b] To put an ASCII string without prepending its size, you can use [method put_data]:
[codeblocks]
[gdscript]
put_data("Hello world".to_ascii_buffer())
[/gdscript]
[csharp]
PutData("Hello World".ToAsciiBuffer());
[/csharp]
[/codeblocks]
*/
func (self Instance) PutString(value string) { //gd:StreamPeer.put_string
	Advanced(self).PutString(String.New(value))
}

/*
Puts a zero-terminated UTF-8 string into the stream prepended by a 32 bits unsigned integer representing its size.
[b]Note:[/b] To put a UTF-8 string without prepending its size, you can use [method put_data]:
[codeblocks]
[gdscript]
put_data("Hello world".to_utf8_buffer())
[/gdscript]
[csharp]
PutData("Hello World".ToUtf8Buffer());
[/csharp]
[/codeblocks]
*/
func (self Instance) PutUtf8String(value string) { //gd:StreamPeer.put_utf8_string
	Advanced(self).PutUtf8String(String.New(value))
}

/*
Puts a Variant into the stream. If [param full_objects] is [code]true[/code] encoding objects is allowed (and can potentially include code).
Internally, this uses the same encoding mechanism as the [method @GlobalScope.var_to_bytes] method.
*/
func (self Instance) PutVar(value any) { //gd:StreamPeer.put_var
	Advanced(self).PutVar(variant.New(value), false)
}

/*
Puts a Variant into the stream. If [param full_objects] is [code]true[/code] encoding objects is allowed (and can potentially include code).
Internally, this uses the same encoding mechanism as the [method @GlobalScope.var_to_bytes] method.
*/
func (self Expanded) PutVar(value any, full_objects bool) { //gd:StreamPeer.put_var
	Advanced(self).PutVar(variant.New(value), full_objects)
}

/*
Gets a signed byte from the stream.
*/
func (self Instance) Get8() int { //gd:StreamPeer.get_8
	return int(int(Advanced(self).Get8()))
}

/*
Gets an unsigned byte from the stream.
*/
func (self Instance) GetU8() int { //gd:StreamPeer.get_u8
	return int(int(Advanced(self).GetU8()))
}

/*
Gets a signed 16-bit value from the stream.
*/
func (self Instance) Get16() int { //gd:StreamPeer.get_16
	return int(int(Advanced(self).Get16()))
}

/*
Gets an unsigned 16-bit value from the stream.
*/
func (self Instance) GetU16() int { //gd:StreamPeer.get_u16
	return int(int(Advanced(self).GetU16()))
}

/*
Gets a signed 32-bit value from the stream.
*/
func (self Instance) Get32() int { //gd:StreamPeer.get_32
	return int(int(Advanced(self).Get32()))
}

/*
Gets an unsigned 32-bit value from the stream.
*/
func (self Instance) GetU32() int { //gd:StreamPeer.get_u32
	return int(int(Advanced(self).GetU32()))
}

/*
Gets a signed 64-bit value from the stream.
*/
func (self Instance) Get64() int { //gd:StreamPeer.get_64
	return int(int(Advanced(self).Get64()))
}

/*
Gets an unsigned 64-bit value from the stream.
*/
func (self Instance) GetU64() int { //gd:StreamPeer.get_u64
	return int(int(Advanced(self).GetU64()))
}

/*
Gets a half-precision float from the stream.
*/
func (self Instance) GetHalf() Float.X { //gd:StreamPeer.get_half
	return Float.X(Float.X(Advanced(self).GetHalf()))
}

/*
Gets a single-precision float from the stream.
*/
func (self Instance) GetFloat() Float.X { //gd:StreamPeer.get_float
	return Float.X(Float.X(Advanced(self).GetFloat()))
}

/*
Gets a double-precision float from the stream.
*/
func (self Instance) GetDouble() Float.X { //gd:StreamPeer.get_double
	return Float.X(Float.X(Advanced(self).GetDouble()))
}

/*
Gets an ASCII string with byte-length [param bytes] from the stream. If [param bytes] is negative (default) the length will be read from the stream using the reverse process of [method put_string].
*/
func (self Instance) GetString() string { //gd:StreamPeer.get_string
	return string(Advanced(self).GetString(int64(-1)).String())
}

/*
Gets an ASCII string with byte-length [param bytes] from the stream. If [param bytes] is negative (default) the length will be read from the stream using the reverse process of [method put_string].
*/
func (self Expanded) GetString(bytes int) string { //gd:StreamPeer.get_string
	return string(Advanced(self).GetString(int64(bytes)).String())
}

/*
Gets a UTF-8 string with byte-length [param bytes] from the stream (this decodes the string sent as UTF-8). If [param bytes] is negative (default) the length will be read from the stream using the reverse process of [method put_utf8_string].
*/
func (self Instance) GetUtf8String() string { //gd:StreamPeer.get_utf8_string
	return string(Advanced(self).GetUtf8String(int64(-1)).String())
}

/*
Gets a UTF-8 string with byte-length [param bytes] from the stream (this decodes the string sent as UTF-8). If [param bytes] is negative (default) the length will be read from the stream using the reverse process of [method put_utf8_string].
*/
func (self Expanded) GetUtf8String(bytes int) string { //gd:StreamPeer.get_utf8_string
	return string(Advanced(self).GetUtf8String(int64(bytes)).String())
}

/*
Gets a Variant from the stream. If [param allow_objects] is [code]true[/code], decoding objects is allowed.
Internally, this uses the same decoding mechanism as the [method @GlobalScope.bytes_to_var] method.
[b]Warning:[/b] Deserialized objects can contain code which gets executed. Do not use this option if the serialized object comes from untrusted sources to avoid potential security threats such as remote code execution.
*/
func (self Instance) GetVar() any { //gd:StreamPeer.get_var
	return any(Advanced(self).GetVar(false).Interface())
}

/*
Gets a Variant from the stream. If [param allow_objects] is [code]true[/code], decoding objects is allowed.
Internally, this uses the same decoding mechanism as the [method @GlobalScope.bytes_to_var] method.
[b]Warning:[/b] Deserialized objects can contain code which gets executed. Do not use this option if the serialized object comes from untrusted sources to avoid potential security threats such as remote code execution.
*/
func (self Expanded) GetVar(allow_objects bool) any { //gd:StreamPeer.get_var
	return any(Advanced(self).GetVar(allow_objects).Interface())
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.StreamPeer

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.StreamPeer)(unsafe.Pointer(&obj))
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.StreamPeer)(unsafe.Pointer(&obj))
		return true
	}
	return false
}

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {

	if !gd.Linked {
		var placeholder Instance
		*(*gd.Object)(unsafe.Pointer(&placeholder)) = pointers.Add[gd.Object]([3]uint64{})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(*(*gd.Object)(unsafe.Pointer(&placeholder)), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	object := [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})}
	casted := Instance{*(*gdclass.StreamPeer)(unsafe.Pointer(&object))}
	casted.AsRefCounted()[0].InitRef()
	object[0].Notification(0, false)
	return casted
}

func (self Instance) BigEndian() bool {
	return bool(class(self).IsBigEndianEnabled())
}

func (self Instance) SetBigEndian(value bool) {
	class(self).SetBigEndian(value)
}

/*
Sends a chunk of data through the connection, blocking if necessary until the data is done sending. This function returns an [enum Error] code.
*/
//go:nosplit
func (self class) PutData(data Packed.Bytes) Error.Code { //gd:StreamPeer.put_data
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.put_data, gdextension.SizeInt|(gdextension.SizePackedArray<<4), unsafe.Pointer(&struct{ data gdextension.PackedArray[byte] }{pointers.Get(gd.InternalPacked[gd.PackedByteArray, byte](Packed.Array[byte](data)))}))
	var ret = Error.Code(r_ret)
	return ret
}

/*
Sends a chunk of data through the connection. If all the data could not be sent at once, only part of it will. This function returns two values, an [enum Error] code and an integer, describing how much data was actually sent.
*/
//go:nosplit
func (self class) PutPartialData(data Packed.Bytes) Array.Any { //gd:StreamPeer.put_partial_data
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), methods.put_partial_data, gdextension.SizeArray|(gdextension.SizePackedArray<<4), unsafe.Pointer(&struct{ data gdextension.PackedArray[byte] }{pointers.Get(gd.InternalPacked[gd.PackedByteArray, byte](Packed.Array[byte](data)))}))
	var ret = Array.Through(gd.ArrayProxy[variant.Any]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

/*
Returns a chunk data with the received bytes. The number of bytes to be received can be requested in the [param bytes] argument. If not enough bytes are available, the function will block until the desired amount is received. This function returns two values, an [enum Error] code and a data array.
*/
//go:nosplit
func (self class) GetData(bytes int64) Array.Any { //gd:StreamPeer.get_data
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), methods.get_data, gdextension.SizeArray|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ bytes int64 }{bytes}))
	var ret = Array.Through(gd.ArrayProxy[variant.Any]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

/*
Returns a chunk data with the received bytes. The number of bytes to be received can be requested in the "bytes" argument. If not enough bytes are available, the function will return how many were actually received. This function returns two values, an [enum Error] code, and a data array.
*/
//go:nosplit
func (self class) GetPartialData(bytes int64) Array.Any { //gd:StreamPeer.get_partial_data
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), methods.get_partial_data, gdextension.SizeArray|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ bytes int64 }{bytes}))
	var ret = Array.Through(gd.ArrayProxy[variant.Any]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

/*
Returns the number of bytes this [StreamPeer] has available.
*/
//go:nosplit
func (self class) GetAvailableBytes() int64 { //gd:StreamPeer.get_available_bytes
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_available_bytes, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetBigEndian(enable bool) { //gd:StreamPeer.set_big_endian
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_big_endian, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

//go:nosplit
func (self class) IsBigEndianEnabled() bool { //gd:StreamPeer.is_big_endian_enabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_big_endian_enabled, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Puts a signed byte into the stream.
*/
//go:nosplit
func (self class) Put8(value int64) { //gd:StreamPeer.put_8
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.put_8, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ value int64 }{value}))
}

/*
Puts an unsigned byte into the stream.
*/
//go:nosplit
func (self class) PutU8(value int64) { //gd:StreamPeer.put_u8
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.put_u8, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ value int64 }{value}))
}

/*
Puts a signed 16-bit value into the stream.
*/
//go:nosplit
func (self class) Put16(value int64) { //gd:StreamPeer.put_16
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.put_16, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ value int64 }{value}))
}

/*
Puts an unsigned 16-bit value into the stream.
*/
//go:nosplit
func (self class) PutU16(value int64) { //gd:StreamPeer.put_u16
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.put_u16, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ value int64 }{value}))
}

/*
Puts a signed 32-bit value into the stream.
*/
//go:nosplit
func (self class) Put32(value int64) { //gd:StreamPeer.put_32
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.put_32, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ value int64 }{value}))
}

/*
Puts an unsigned 32-bit value into the stream.
*/
//go:nosplit
func (self class) PutU32(value int64) { //gd:StreamPeer.put_u32
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.put_u32, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ value int64 }{value}))
}

/*
Puts a signed 64-bit value into the stream.
*/
//go:nosplit
func (self class) Put64(value int64) { //gd:StreamPeer.put_64
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.put_64, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ value int64 }{value}))
}

/*
Puts an unsigned 64-bit value into the stream.
*/
//go:nosplit
func (self class) PutU64(value int64) { //gd:StreamPeer.put_u64
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.put_u64, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ value int64 }{value}))
}

/*
Puts a half-precision float into the stream.
*/
//go:nosplit
func (self class) PutHalf(value float64) { //gd:StreamPeer.put_half
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.put_half, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ value float64 }{value}))
}

/*
Puts a single-precision float into the stream.
*/
//go:nosplit
func (self class) PutFloat(value float64) { //gd:StreamPeer.put_float
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.put_float, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ value float64 }{value}))
}

/*
Puts a double-precision float into the stream.
*/
//go:nosplit
func (self class) PutDouble(value float64) { //gd:StreamPeer.put_double
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.put_double, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ value float64 }{value}))
}

/*
Puts a zero-terminated ASCII string into the stream prepended by a 32-bit unsigned integer representing its size.
[b]Note:[/b] To put an ASCII string without prepending its size, you can use [method put_data]:
[codeblocks]
[gdscript]
put_data("Hello world".to_ascii_buffer())
[/gdscript]
[csharp]
PutData("Hello World".ToAsciiBuffer());
[/csharp]
[/codeblocks]
*/
//go:nosplit
func (self class) PutString(value String.Readable) { //gd:StreamPeer.put_string
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.put_string, 0|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ value gdextension.String }{pointers.Get(gd.InternalString(value))}))
}

/*
Puts a zero-terminated UTF-8 string into the stream prepended by a 32 bits unsigned integer representing its size.
[b]Note:[/b] To put a UTF-8 string without prepending its size, you can use [method put_data]:
[codeblocks]
[gdscript]
put_data("Hello world".to_utf8_buffer())
[/gdscript]
[csharp]
PutData("Hello World".ToUtf8Buffer());
[/csharp]
[/codeblocks]
*/
//go:nosplit
func (self class) PutUtf8String(value String.Readable) { //gd:StreamPeer.put_utf8_string
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.put_utf8_string, 0|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ value gdextension.String }{pointers.Get(gd.InternalString(value))}))
}

/*
Puts a Variant into the stream. If [param full_objects] is [code]true[/code] encoding objects is allowed (and can potentially include code).
Internally, this uses the same encoding mechanism as the [method @GlobalScope.var_to_bytes] method.
*/
//go:nosplit
func (self class) PutVar(value variant.Any, full_objects bool) { //gd:StreamPeer.put_var
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.put_var, 0|(gdextension.SizeVariant<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		value        gdextension.Variant
		full_objects bool
	}{gdextension.Variant(pointers.Get(gd.InternalVariant(value))), full_objects}))
}

/*
Gets a signed byte from the stream.
*/
//go:nosplit
func (self class) Get8() int64 { //gd:StreamPeer.get_8
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_8, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Gets an unsigned byte from the stream.
*/
//go:nosplit
func (self class) GetU8() int64 { //gd:StreamPeer.get_u8
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_u8, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Gets a signed 16-bit value from the stream.
*/
//go:nosplit
func (self class) Get16() int64 { //gd:StreamPeer.get_16
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_16, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Gets an unsigned 16-bit value from the stream.
*/
//go:nosplit
func (self class) GetU16() int64 { //gd:StreamPeer.get_u16
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_u16, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Gets a signed 32-bit value from the stream.
*/
//go:nosplit
func (self class) Get32() int64 { //gd:StreamPeer.get_32
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_32, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Gets an unsigned 32-bit value from the stream.
*/
//go:nosplit
func (self class) GetU32() int64 { //gd:StreamPeer.get_u32
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_u32, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Gets a signed 64-bit value from the stream.
*/
//go:nosplit
func (self class) Get64() int64 { //gd:StreamPeer.get_64
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_64, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Gets an unsigned 64-bit value from the stream.
*/
//go:nosplit
func (self class) GetU64() int64 { //gd:StreamPeer.get_u64
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_u64, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Gets a half-precision float from the stream.
*/
//go:nosplit
func (self class) GetHalf() float64 { //gd:StreamPeer.get_half
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_half, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Gets a single-precision float from the stream.
*/
//go:nosplit
func (self class) GetFloat() float64 { //gd:StreamPeer.get_float
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_float, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Gets a double-precision float from the stream.
*/
//go:nosplit
func (self class) GetDouble() float64 { //gd:StreamPeer.get_double
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_double, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Gets an ASCII string with byte-length [param bytes] from the stream. If [param bytes] is negative (default) the length will be read from the stream using the reverse process of [method put_string].
*/
//go:nosplit
func (self class) GetString(bytes int64) String.Readable { //gd:StreamPeer.get_string
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_string, gdextension.SizeString|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ bytes int64 }{bytes}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Gets a UTF-8 string with byte-length [param bytes] from the stream (this decodes the string sent as UTF-8). If [param bytes] is negative (default) the length will be read from the stream using the reverse process of [method put_utf8_string].
*/
//go:nosplit
func (self class) GetUtf8String(bytes int64) String.Readable { //gd:StreamPeer.get_utf8_string
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_utf8_string, gdextension.SizeString|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ bytes int64 }{bytes}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Gets a Variant from the stream. If [param allow_objects] is [code]true[/code], decoding objects is allowed.
Internally, this uses the same decoding mechanism as the [method @GlobalScope.bytes_to_var] method.
[b]Warning:[/b] Deserialized objects can contain code which gets executed. Do not use this option if the serialized object comes from untrusted sources to avoid potential security threats such as remote code execution.
*/
//go:nosplit
func (self class) GetVar(allow_objects bool) variant.Any { //gd:StreamPeer.get_var
	var r_ret = gdextension.Call[gdextension.Variant](gd.ObjectChecked(self.AsObject()), methods.get_var, gdextension.SizeVariant|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ allow_objects bool }{allow_objects}))
	var ret = variant.Implementation(gd.VariantProxy{}, pointers.Pack(pointers.New[gd.Variant](r_ret)))
	return ret
}
func (self class) AsStreamPeer() Advanced         { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsStreamPeer() Instance      { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsStreamPeer() Instance { return self.Super().AsStreamPeer() }
func (self class) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsRefCounted() [1]gd.RefCounted { return self.Super().AsRefCounted() }
func (self Instance) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(RefCounted.Advanced(self.AsRefCounted()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(RefCounted.Instance(self.AsRefCounted()), name)
	}
}
func init() {
	gdclass.Register("StreamPeer", func(ptr gd.Object) any { return *(*Instance)(unsafe.Pointer(&ptr)) })
}
