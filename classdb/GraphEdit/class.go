// Code generated by the generate package DO NOT EDIT

// Package GraphEdit provides methods for working with GraphEdit object instances.
package GraphEdit

import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/variant/Signal"
import "graphics.gd/classdb/CanvasItem"
import "graphics.gd/classdb/Control"
import "graphics.gd/classdb/GraphFrame"
import "graphics.gd/classdb/HBoxContainer"
import "graphics.gd/classdb/Node"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/Rect2"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"
import "graphics.gd/variant/Vector2"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Signal.Any
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
[GraphEdit] provides tools for creation, manipulation, and display of various graphs. Its main purpose in the engine is to power the visual programming systems, such as visual shaders, but it is also available for use in user projects.
[GraphEdit] by itself is only an empty container, representing an infinite grid where [GraphNode]s can be placed. Each [GraphNode] represents a node in the graph, a single unit of data in the connected scheme. [GraphEdit], in turn, helps to control various interactions with nodes and between nodes. When the user attempts to connect, disconnect, or delete a [GraphNode], a signal is emitted in the [GraphEdit], but no action is taken by default. It is the responsibility of the programmer utilizing this control to implement the necessary logic to determine how each request should be handled.
[b]Performance:[/b] It is greatly advised to enable low-processor usage mode (see [member OS.low_processor_usage_mode]) when using GraphEdits.
[b]Note:[/b] Keep in mind that [method Node.get_children] will also return the connection layer node named [code]_connection_layer[/code] due to technical limitations. This behavior may change in future releases.

	See [Interface] for methods that can be overridden by a [Class] that extends it.
*/
type Instance [1]gdclass.GraphEdit

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	connect_node                           gdextension.MethodForClass `hash:"1376144231"`
	is_node_connected                      gdextension.MethodForClass `hash:"4216241294"`
	disconnect_node                        gdextension.MethodForClass `hash:"1933654315"`
	set_connection_activity                gdextension.MethodForClass `hash:"1141899943"`
	set_connections                        gdextension.MethodForClass `hash:"381264803"`
	get_connection_list                    gdextension.MethodForClass `hash:"3995934104"`
	get_connection_count                   gdextension.MethodForClass `hash:"861718734"`
	get_closest_connection_at_point        gdextension.MethodForClass `hash:"453879819"`
	get_connections_intersecting_with_rect gdextension.MethodForClass `hash:"2709748719"`
	clear_connections                      gdextension.MethodForClass `hash:"3218959716"`
	force_connection_drag_end              gdextension.MethodForClass `hash:"3218959716"`
	get_scroll_offset                      gdextension.MethodForClass `hash:"3341600327"`
	set_scroll_offset                      gdextension.MethodForClass `hash:"743155724"`
	add_valid_right_disconnect_type        gdextension.MethodForClass `hash:"1286410249"`
	remove_valid_right_disconnect_type     gdextension.MethodForClass `hash:"1286410249"`
	add_valid_left_disconnect_type         gdextension.MethodForClass `hash:"1286410249"`
	remove_valid_left_disconnect_type      gdextension.MethodForClass `hash:"1286410249"`
	add_valid_connection_type              gdextension.MethodForClass `hash:"3937882851"`
	remove_valid_connection_type           gdextension.MethodForClass `hash:"3937882851"`
	is_valid_connection_type               gdextension.MethodForClass `hash:"2522259332"`
	get_connection_line                    gdextension.MethodForClass `hash:"3932192302"`
	attach_graph_element_to_frame          gdextension.MethodForClass `hash:"3740211285"`
	detach_graph_element_from_frame        gdextension.MethodForClass `hash:"3304788590"`
	get_element_frame                      gdextension.MethodForClass `hash:"988084372"`
	get_attached_nodes_of_frame            gdextension.MethodForClass `hash:"689397652"`
	set_panning_scheme                     gdextension.MethodForClass `hash:"18893313"`
	get_panning_scheme                     gdextension.MethodForClass `hash:"549924446"`
	set_zoom                               gdextension.MethodForClass `hash:"373806689"`
	get_zoom                               gdextension.MethodForClass `hash:"1740695150"`
	set_zoom_min                           gdextension.MethodForClass `hash:"373806689"`
	get_zoom_min                           gdextension.MethodForClass `hash:"1740695150"`
	set_zoom_max                           gdextension.MethodForClass `hash:"373806689"`
	get_zoom_max                           gdextension.MethodForClass `hash:"1740695150"`
	set_zoom_step                          gdextension.MethodForClass `hash:"373806689"`
	get_zoom_step                          gdextension.MethodForClass `hash:"1740695150"`
	set_show_grid                          gdextension.MethodForClass `hash:"2586408642"`
	is_showing_grid                        gdextension.MethodForClass `hash:"36873697"`
	set_grid_pattern                       gdextension.MethodForClass `hash:"1074098205"`
	get_grid_pattern                       gdextension.MethodForClass `hash:"1286127528"`
	set_snapping_enabled                   gdextension.MethodForClass `hash:"2586408642"`
	is_snapping_enabled                    gdextension.MethodForClass `hash:"36873697"`
	set_snapping_distance                  gdextension.MethodForClass `hash:"1286410249"`
	get_snapping_distance                  gdextension.MethodForClass `hash:"3905245786"`
	set_connection_lines_curvature         gdextension.MethodForClass `hash:"373806689"`
	get_connection_lines_curvature         gdextension.MethodForClass `hash:"1740695150"`
	set_connection_lines_thickness         gdextension.MethodForClass `hash:"373806689"`
	get_connection_lines_thickness         gdextension.MethodForClass `hash:"1740695150"`
	set_connection_lines_antialiased       gdextension.MethodForClass `hash:"2586408642"`
	is_connection_lines_antialiased        gdextension.MethodForClass `hash:"36873697"`
	set_minimap_size                       gdextension.MethodForClass `hash:"743155724"`
	get_minimap_size                       gdextension.MethodForClass `hash:"3341600327"`
	set_minimap_opacity                    gdextension.MethodForClass `hash:"373806689"`
	get_minimap_opacity                    gdextension.MethodForClass `hash:"1740695150"`
	set_minimap_enabled                    gdextension.MethodForClass `hash:"2586408642"`
	is_minimap_enabled                     gdextension.MethodForClass `hash:"36873697"`
	set_show_menu                          gdextension.MethodForClass `hash:"2586408642"`
	is_showing_menu                        gdextension.MethodForClass `hash:"36873697"`
	set_show_zoom_label                    gdextension.MethodForClass `hash:"2586408642"`
	is_showing_zoom_label                  gdextension.MethodForClass `hash:"36873697"`
	set_show_grid_buttons                  gdextension.MethodForClass `hash:"2586408642"`
	is_showing_grid_buttons                gdextension.MethodForClass `hash:"36873697"`
	set_show_zoom_buttons                  gdextension.MethodForClass `hash:"2586408642"`
	is_showing_zoom_buttons                gdextension.MethodForClass `hash:"36873697"`
	set_show_minimap_button                gdextension.MethodForClass `hash:"2586408642"`
	is_showing_minimap_button              gdextension.MethodForClass `hash:"36873697"`
	set_show_arrange_button                gdextension.MethodForClass `hash:"2586408642"`
	is_showing_arrange_button              gdextension.MethodForClass `hash:"36873697"`
	set_right_disconnects                  gdextension.MethodForClass `hash:"2586408642"`
	is_right_disconnects_enabled           gdextension.MethodForClass `hash:"36873697"`
	get_menu_hbox                          gdextension.MethodForClass `hash:"3590609951"`
	arrange_nodes                          gdextension.MethodForClass `hash:"3218959716"`
	set_selected                           gdextension.MethodForClass `hash:"1078189570"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("GraphEdit")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		gdextension.Free(gdextension.TypeStringName, &sname)
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

type Expanded [1]gdclass.GraphEdit

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsGraphEdit() Instance
}
type Interface interface {
	//Returns whether the [param mouse_position] is in the input hot zone.
	//By default, a hot zone is a [Rect2] positioned such that its center is at [param in_node].[method GraphNode.get_input_port_position]([param in_port]) (For output's case, call [method GraphNode.get_output_port_position] instead). The hot zone's width is twice the Theme Property [code]port_grab_distance_horizontal[/code], and its height is twice the [code]port_grab_distance_vertical[/code].
	//Below is a sample code to help get started:
	//[codeblock]
	//func _is_in_input_hotzone(in_node, in_port, mouse_position):
	//    var port_size = Vector2(get_theme_constant("port_grab_distance_horizontal"), get_theme_constant("port_grab_distance_vertical"))
	//    var port_pos = in_node.get_position() + in_node.get_input_port_position(in_port) - port_size / 2
	//    var rect = Rect2(port_pos, port_size)
	//
	//    return rect.has_point(mouse_position)
	//[/codeblock]
	IsInInputHotzone(in_node Object.Instance, in_port int, mouse_position Vector2.XY) bool
	//Returns whether the [param mouse_position] is in the output hot zone. For more information on hot zones, see [method _is_in_input_hotzone].
	//Below is a sample code to help get started:
	//[codeblock]
	//func _is_in_output_hotzone(in_node, in_port, mouse_position):
	//    var port_size = Vector2(get_theme_constant("port_grab_distance_horizontal"), get_theme_constant("port_grab_distance_vertical"))
	//    var port_pos = in_node.get_position() + in_node.get_output_port_position(in_port) - port_size / 2
	//    var rect = Rect2(port_pos, port_size)
	//
	//    return rect.has_point(mouse_position)
	//[/codeblock]
	IsInOutputHotzone(in_node Object.Instance, in_port int, mouse_position Vector2.XY) bool
	//Virtual method which can be overridden to customize how connections are drawn.
	GetConnectionLine(from_position Vector2.XY, to_position Vector2.XY) []Vector2.XY
	//This virtual method can be used to insert additional error detection while the user is dragging a connection over a valid port.
	//Return [code]true[/code] if the connection is indeed valid or return [code]false[/code] if the connection is impossible. If the connection is impossible, no snapping to the port and thus no connection request to that port will happen.
	//In this example a connection to same node is suppressed:
	//[codeblocks]
	//[gdscript]
	//func _is_node_hover_valid(from, from_port, to, to_port):
	//    return from != to
	//[/gdscript]
	//[csharp]
	//public override bool _IsNodeHoverValid(StringName fromNode, int fromPort, StringName toNode, int toPort)
	//{
	//    return fromNode != toNode;
	//}
	//[/csharp]
	//[/codeblocks]
	IsNodeHoverValid(from_node string, from_port int, to_node string, to_port int) bool
}

// Implementation implements [Interface] with empty methods.
type Implementation = implementation

type implementation struct{}

func (self implementation) IsInInputHotzone(in_node Object.Instance, in_port int, mouse_position Vector2.XY) (_ bool) {
	return
}
func (self implementation) IsInOutputHotzone(in_node Object.Instance, in_port int, mouse_position Vector2.XY) (_ bool) {
	return
}
func (self implementation) GetConnectionLine(from_position Vector2.XY, to_position Vector2.XY) (_ []Vector2.XY) {
	return
}
func (self implementation) IsNodeHoverValid(from_node string, from_port int, to_node string, to_port int) (_ bool) {
	return
}

/*
Returns whether the [param mouse_position] is in the input hot zone.
By default, a hot zone is a [Rect2] positioned such that its center is at [param in_node].[method GraphNode.get_input_port_position]([param in_port]) (For output's case, call [method GraphNode.get_output_port_position] instead). The hot zone's width is twice the Theme Property [code]port_grab_distance_horizontal[/code], and its height is twice the [code]port_grab_distance_vertical[/code].
Below is a sample code to help get started:
[codeblock]
func _is_in_input_hotzone(in_node, in_port, mouse_position):

	var port_size = Vector2(get_theme_constant("port_grab_distance_horizontal"), get_theme_constant("port_grab_distance_vertical"))
	var port_pos = in_node.get_position() + in_node.get_input_port_position(in_port) - port_size / 2
	var rect = Rect2(port_pos, port_size)

	return rect.has_point(mouse_position)

[/codeblock]
*/
func (Instance) _is_in_input_hotzone(impl func(ptr gdclass.Receiver, in_node Object.Instance, in_port int, mouse_position Vector2.XY) bool) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args, p_back gdextension.Pointer) {
		var in_node = [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gd.UnsafeGet[gdextension.Object](p_args, 0))})}
		defer pointers.End(in_node[0])
		var in_port = gd.UnsafeGet[int64](p_args, 1)
		var mouse_position = gd.UnsafeGet[Vector2.XY](p_args, 2)
		self := gdclass.Receiver(reflect.ValueOf(class).UnsafePointer())
		ret := impl(self, in_node, int(in_port), mouse_position)
		gd.UnsafeSet(p_back, ret)
	}
}

/*
Returns whether the [param mouse_position] is in the output hot zone. For more information on hot zones, see [method _is_in_input_hotzone].
Below is a sample code to help get started:
[codeblock]
func _is_in_output_hotzone(in_node, in_port, mouse_position):

	var port_size = Vector2(get_theme_constant("port_grab_distance_horizontal"), get_theme_constant("port_grab_distance_vertical"))
	var port_pos = in_node.get_position() + in_node.get_output_port_position(in_port) - port_size / 2
	var rect = Rect2(port_pos, port_size)

	return rect.has_point(mouse_position)

[/codeblock]
*/
func (Instance) _is_in_output_hotzone(impl func(ptr gdclass.Receiver, in_node Object.Instance, in_port int, mouse_position Vector2.XY) bool) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args, p_back gdextension.Pointer) {
		var in_node = [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gd.UnsafeGet[gdextension.Object](p_args, 0))})}
		defer pointers.End(in_node[0])
		var in_port = gd.UnsafeGet[int64](p_args, 1)
		var mouse_position = gd.UnsafeGet[Vector2.XY](p_args, 2)
		self := gdclass.Receiver(reflect.ValueOf(class).UnsafePointer())
		ret := impl(self, in_node, int(in_port), mouse_position)
		gd.UnsafeSet(p_back, ret)
	}
}

/*
Virtual method which can be overridden to customize how connections are drawn.
*/
func (Instance) _get_connection_line(impl func(ptr gdclass.Receiver, from_position Vector2.XY, to_position Vector2.XY) []Vector2.XY) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args, p_back gdextension.Pointer) {
		var from_position = gd.UnsafeGet[Vector2.XY](p_args, 0)
		var to_position = gd.UnsafeGet[Vector2.XY](p_args, 1)
		self := gdclass.Receiver(reflect.ValueOf(class).UnsafePointer())
		ret := impl(self, from_position, to_position)
		ptr, ok := pointers.End(gd.InternalPacked[gd.PackedVector2Array, Vector2.XY](Packed.New(ret...)))

		if !ok {
			return
		}
		gd.UnsafeSet(p_back, ptr)
	}
}

/*
This virtual method can be used to insert additional error detection while the user is dragging a connection over a valid port.
Return [code]true[/code] if the connection is indeed valid or return [code]false[/code] if the connection is impossible. If the connection is impossible, no snapping to the port and thus no connection request to that port will happen.
In this example a connection to same node is suppressed:
[codeblocks]
[gdscript]
func _is_node_hover_valid(from, from_port, to, to_port):

	return from != to

[/gdscript]
[csharp]
public override bool _IsNodeHoverValid(StringName fromNode, int fromPort, StringName toNode, int toPort)

	{
	    return fromNode != toNode;
	}

[/csharp]
[/codeblocks]
*/
func (Instance) _is_node_hover_valid(impl func(ptr gdclass.Receiver, from_node string, from_port int, to_node string, to_port int) bool) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args, p_back gdextension.Pointer) {
		var from_node = String.Name(String.Via(gd.StringNameProxy{}, pointers.Pack(pointers.New[gd.StringName](gd.UnsafeGet[gdextension.StringName](p_args, 0)))))
		defer pointers.End(gd.InternalStringName(from_node))
		var from_port = gd.UnsafeGet[int64](p_args, 1)
		var to_node = String.Name(String.Via(gd.StringNameProxy{}, pointers.Pack(pointers.New[gd.StringName](gd.UnsafeGet[gdextension.StringName](p_args, 2)))))
		defer pointers.End(gd.InternalStringName(to_node))
		var to_port = gd.UnsafeGet[int64](p_args, 3)
		self := gdclass.Receiver(reflect.ValueOf(class).UnsafePointer())
		ret := impl(self, from_node.String(), int(from_port), to_node.String(), int(to_port))
		gd.UnsafeSet(p_back, ret)
	}
}

/*
Create a connection between the [param from_port] of the [param from_node] [GraphNode] and the [param to_port] of the [param to_node] [GraphNode]. If the connection already exists, no connection is created.
Connections with [param keep_alive] set to [code]false[/code] may be deleted automatically if invalid during a redraw.
*/
func (self Instance) ConnectNode(from_node string, from_port int, to_node string, to_port int) error { //gd:GraphEdit.connect_node
	return error(gd.ToError(Advanced(self).ConnectNode(String.Name(String.New(from_node)), int64(from_port), String.Name(String.New(to_node)), int64(to_port), false)))
}

/*
Create a connection between the [param from_port] of the [param from_node] [GraphNode] and the [param to_port] of the [param to_node] [GraphNode]. If the connection already exists, no connection is created.
Connections with [param keep_alive] set to [code]false[/code] may be deleted automatically if invalid during a redraw.
*/
func (self Expanded) ConnectNode(from_node string, from_port int, to_node string, to_port int, keep_alive bool) error { //gd:GraphEdit.connect_node
	return error(gd.ToError(Advanced(self).ConnectNode(String.Name(String.New(from_node)), int64(from_port), String.Name(String.New(to_node)), int64(to_port), keep_alive)))
}

/*
Returns [code]true[/code] if the [param from_port] of the [param from_node] [GraphNode] is connected to the [param to_port] of the [param to_node] [GraphNode].
*/
func (self Instance) IsNodeConnected(from_node string, from_port int, to_node string, to_port int) bool { //gd:GraphEdit.is_node_connected
	return bool(Advanced(self).IsNodeConnected(String.Name(String.New(from_node)), int64(from_port), String.Name(String.New(to_node)), int64(to_port)))
}

/*
Removes the connection between the [param from_port] of the [param from_node] [GraphNode] and the [param to_port] of the [param to_node] [GraphNode]. If the connection does not exist, no connection is removed.
*/
func (self Instance) DisconnectNode(from_node string, from_port int, to_node string, to_port int) { //gd:GraphEdit.disconnect_node
	Advanced(self).DisconnectNode(String.Name(String.New(from_node)), int64(from_port), String.Name(String.New(to_node)), int64(to_port))
}

/*
Sets the coloration of the connection between [param from_node]'s [param from_port] and [param to_node]'s [param to_port] with the color provided in the [theme_item activity] theme property. The color is linearly interpolated between the connection color and the activity color using [param amount] as weight.
*/
func (self Instance) SetConnectionActivity(from_node string, from_port int, to_node string, to_port int, amount Float.X) { //gd:GraphEdit.set_connection_activity
	Advanced(self).SetConnectionActivity(String.Name(String.New(from_node)), int64(from_port), String.Name(String.New(to_node)), int64(to_port), float64(amount))
}

/*
Returns the number of connections from [param from_port] of [param from_node].
*/
func (self Instance) GetConnectionCount(from_node string, from_port int) int { //gd:GraphEdit.get_connection_count
	return int(int(Advanced(self).GetConnectionCount(String.Name(String.New(from_node)), int64(from_port))))
}

/*
Returns the closest connection to the given point in screen space. If no connection is found within [param max_distance] pixels, an empty [Dictionary] is returned.
A connection is represented as a [Dictionary] in the form of:
[codeblock]

	{
	    from_node: StringName,
	    from_port: int,
	    to_node: StringName,
	    to_port: int,
	    keep_alive: bool
	}

[/codeblock]
For example, getting a connection at a given mouse position can be achieved like this:
[codeblocks]
[gdscript]
var connection = get_closest_connection_at_point(mouse_event.get_position())
[/gdscript]
[/codeblocks]
*/
func (self Instance) GetClosestConnectionAtPoint(point Vector2.XY) Connection { //gd:GraphEdit.get_closest_connection_at_point
	return Connection(gd.DictionaryAs[Connection](Advanced(self).GetClosestConnectionAtPoint(Vector2.XY(point), float64(4.0))))
}

/*
Returns the closest connection to the given point in screen space. If no connection is found within [param max_distance] pixels, an empty [Dictionary] is returned.
A connection is represented as a [Dictionary] in the form of:
[codeblock]

	{
	    from_node: StringName,
	    from_port: int,
	    to_node: StringName,
	    to_port: int,
	    keep_alive: bool
	}

[/codeblock]
For example, getting a connection at a given mouse position can be achieved like this:
[codeblocks]
[gdscript]
var connection = get_closest_connection_at_point(mouse_event.get_position())
[/gdscript]
[/codeblocks]
*/
func (self Expanded) GetClosestConnectionAtPoint(point Vector2.XY, max_distance Float.X) Connection { //gd:GraphEdit.get_closest_connection_at_point
	return Connection(gd.DictionaryAs[Connection](Advanced(self).GetClosestConnectionAtPoint(Vector2.XY(point), float64(max_distance))))
}

/*
Returns an [Array] containing the list of connections that intersect with the given [Rect2].
A connection is represented as a [Dictionary] in the form of:
[codeblock]

	{
	    from_node: StringName,
	    from_port: int,
	    to_node: StringName,
	    to_port: int,
	    keep_alive: bool
	}

[/codeblock]
*/
func (self Instance) GetConnectionsIntersectingWithRect(rect Rect2.PositionSize) []Connection { //gd:GraphEdit.get_connections_intersecting_with_rect
	return []Connection(gd.ArrayAs[[]Connection](gd.InternalArray(Advanced(self).GetConnectionsIntersectingWithRect(Rect2.PositionSize(rect)))))
}

/*
Removes all connections between nodes.
*/
func (self Instance) ClearConnections() { //gd:GraphEdit.clear_connections
	Advanced(self).ClearConnections()
}

/*
Ends the creation of the current connection. In other words, if you are dragging a connection you can use this method to abort the process and remove the line that followed your cursor.
This is best used together with [signal connection_drag_started] and [signal connection_drag_ended] to add custom behavior like node addition through shortcuts.
[b]Note:[/b] This method suppresses any other connection request signals apart from [signal connection_drag_ended].
*/
func (self Instance) ForceConnectionDragEnd() { //gd:GraphEdit.force_connection_drag_end
	Advanced(self).ForceConnectionDragEnd()
}

/*
Allows to disconnect nodes when dragging from the right port of the [GraphNode]'s slot if it has the specified type. See also [method remove_valid_right_disconnect_type].
*/
func (self Instance) AddValidRightDisconnectType(atype int) { //gd:GraphEdit.add_valid_right_disconnect_type
	Advanced(self).AddValidRightDisconnectType(int64(atype))
}

/*
Disallows to disconnect nodes when dragging from the right port of the [GraphNode]'s slot if it has the specified type. Use this to disable disconnection previously allowed with [method add_valid_right_disconnect_type].
*/
func (self Instance) RemoveValidRightDisconnectType(atype int) { //gd:GraphEdit.remove_valid_right_disconnect_type
	Advanced(self).RemoveValidRightDisconnectType(int64(atype))
}

/*
Allows to disconnect nodes when dragging from the left port of the [GraphNode]'s slot if it has the specified type. See also [method remove_valid_left_disconnect_type].
*/
func (self Instance) AddValidLeftDisconnectType(atype int) { //gd:GraphEdit.add_valid_left_disconnect_type
	Advanced(self).AddValidLeftDisconnectType(int64(atype))
}

/*
Disallows to disconnect nodes when dragging from the left port of the [GraphNode]'s slot if it has the specified type. Use this to disable disconnection previously allowed with [method add_valid_left_disconnect_type].
*/
func (self Instance) RemoveValidLeftDisconnectType(atype int) { //gd:GraphEdit.remove_valid_left_disconnect_type
	Advanced(self).RemoveValidLeftDisconnectType(int64(atype))
}

/*
Allows the connection between two different port types. The port type is defined individually for the left and the right port of each slot with the [method GraphNode.set_slot] method.
See also [method is_valid_connection_type] and [method remove_valid_connection_type].
*/
func (self Instance) AddValidConnectionType(from_type int, to_type int) { //gd:GraphEdit.add_valid_connection_type
	Advanced(self).AddValidConnectionType(int64(from_type), int64(to_type))
}

/*
Disallows the connection between two different port types previously allowed by [method add_valid_connection_type]. The port type is defined individually for the left and the right port of each slot with the [method GraphNode.set_slot] method.
See also [method is_valid_connection_type].
*/
func (self Instance) RemoveValidConnectionType(from_type int, to_type int) { //gd:GraphEdit.remove_valid_connection_type
	Advanced(self).RemoveValidConnectionType(int64(from_type), int64(to_type))
}

/*
Returns whether it's possible to make a connection between two different port types. The port type is defined individually for the left and the right port of each slot with the [method GraphNode.set_slot] method.
See also [method add_valid_connection_type] and [method remove_valid_connection_type].
*/
func (self Instance) IsValidConnectionType(from_type int, to_type int) bool { //gd:GraphEdit.is_valid_connection_type
	return bool(Advanced(self).IsValidConnectionType(int64(from_type), int64(to_type)))
}

/*
Returns the points which would make up a connection between [param from_node] and [param to_node].
*/
func (self Instance) GetConnectionLine(from_node Vector2.XY, to_node Vector2.XY) []Vector2.XY { //gd:GraphEdit.get_connection_line
	return []Vector2.XY(slices.Collect(Advanced(self).GetConnectionLine(Vector2.XY(from_node), Vector2.XY(to_node)).Values()))
}

/*
Attaches the [param element] [GraphElement] to the [param frame] [GraphFrame].
*/
func (self Instance) AttachGraphElementToFrame(element string, frame_ string) { //gd:GraphEdit.attach_graph_element_to_frame
	Advanced(self).AttachGraphElementToFrame(String.Name(String.New(element)), String.Name(String.New(frame_)))
}

/*
Detaches the [param element] [GraphElement] from the [GraphFrame] it is currently attached to.
*/
func (self Instance) DetachGraphElementFromFrame(element string) { //gd:GraphEdit.detach_graph_element_from_frame
	Advanced(self).DetachGraphElementFromFrame(String.Name(String.New(element)))
}

/*
Returns the [GraphFrame] that contains the [GraphElement] with the given name.
*/
func (self Instance) GetElementFrame(element string) GraphFrame.Instance { //gd:GraphEdit.get_element_frame
	return GraphFrame.Instance(Advanced(self).GetElementFrame(String.Name(String.New(element))))
}

/*
Returns an array of node names that are attached to the [GraphFrame] with the given name.
*/
func (self Instance) GetAttachedNodesOfFrame(frame_ string) []string { //gd:GraphEdit.get_attached_nodes_of_frame
	return []string(gd.ArrayAs[[]string](gd.InternalArray(Advanced(self).GetAttachedNodesOfFrame(String.Name(String.New(frame_))))))
}

/*
Gets the [HBoxContainer] that contains the zooming and grid snap controls in the top left of the graph. You can use this method to reposition the toolbar or to add your own custom controls to it.
[b]Warning:[/b] This is a required internal node, removing and freeing it may cause a crash. If you wish to hide it or any of its children, use their [member CanvasItem.visible] property.
*/
func (self Instance) GetMenuHbox() HBoxContainer.Instance { //gd:GraphEdit.get_menu_hbox
	return HBoxContainer.Instance(Advanced(self).GetMenuHbox())
}

/*
Rearranges selected nodes in a layout with minimum crossings between connections and uniform horizontal and vertical gap between nodes.
*/
func (self Instance) ArrangeNodes() { //gd:GraphEdit.arrange_nodes
	Advanced(self).ArrangeNodes()
}

/*
Sets the specified [param node] as the one selected.
*/
func (self Instance) SetSelected(node Node.Instance) { //gd:GraphEdit.set_selected
	Advanced(self).SetSelected(node)
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.GraphEdit

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = pointers.AsA[gdclass.GraphEdit](obj[0])
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = pointers.AsA[gdclass.GraphEdit](obj[0])
		return true
	}
	return false
}
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }
func (self *Extension[T]) AsObject() [1]gd.Object { return self.Super().AsObject() }
func New() Instance {
	if !gd.Linked {
		var placeholder = Instance([1]gdclass.GraphEdit{pointers.Add[gdclass.GraphEdit]([3]uint64{})})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(pointers.AsA[gd.Object](placeholder[0]), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	casted := Instance([1]gdclass.GraphEdit{pointers.New[gdclass.GraphEdit]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})})
	casted.AsObject()[0].Notification(0, false)
	return casted
}

func (self Instance) ScrollOffset() Vector2.XY {
	return Vector2.XY(class(self).GetScrollOffset())
}

func (self Instance) SetScrollOffset(value Vector2.XY) {
	class(self).SetScrollOffset(Vector2.XY(value))
}

func (self Instance) ShowGrid() bool {
	return bool(class(self).IsShowingGrid())
}

func (self Instance) SetShowGrid(value bool) {
	class(self).SetShowGrid(value)
}

func (self Instance) GridPattern() GridPattern {
	return GridPattern(class(self).GetGridPattern())
}

func (self Instance) SetGridPattern(value GridPattern) {
	class(self).SetGridPattern(value)
}

func (self Instance) SnappingEnabled() bool {
	return bool(class(self).IsSnappingEnabled())
}

func (self Instance) SetSnappingEnabled(value bool) {
	class(self).SetSnappingEnabled(value)
}

func (self Instance) SnappingDistance() int {
	return int(int(class(self).GetSnappingDistance()))
}

func (self Instance) SetSnappingDistance(value int) {
	class(self).SetSnappingDistance(int64(value))
}

func (self Instance) PanningScheme() PanningScheme {
	return PanningScheme(class(self).GetPanningScheme())
}

func (self Instance) SetPanningScheme(value PanningScheme) {
	class(self).SetPanningScheme(value)
}

func (self Instance) RightDisconnects() bool {
	return bool(class(self).IsRightDisconnectsEnabled())
}

func (self Instance) SetRightDisconnects(value bool) {
	class(self).SetRightDisconnects(value)
}

func (self Instance) ConnectionLinesCurvature() Float.X {
	return Float.X(Float.X(class(self).GetConnectionLinesCurvature()))
}

func (self Instance) SetConnectionLinesCurvature(value Float.X) {
	class(self).SetConnectionLinesCurvature(float64(value))
}

func (self Instance) ConnectionLinesThickness() Float.X {
	return Float.X(Float.X(class(self).GetConnectionLinesThickness()))
}

func (self Instance) SetConnectionLinesThickness(value Float.X) {
	class(self).SetConnectionLinesThickness(float64(value))
}

func (self Instance) ConnectionLinesAntialiased() bool {
	return bool(class(self).IsConnectionLinesAntialiased())
}

func (self Instance) SetConnectionLinesAntialiased(value bool) {
	class(self).SetConnectionLinesAntialiased(value)
}

func (self Instance) Connections() []map[any]any {
	return []map[any]any(gd.ArrayAs[[]map[any]any](gd.InternalArray(class(self).GetConnectionList())))
}

func (self Instance) SetConnections(value []map[any]any) {
	class(self).SetConnections(gd.ArrayFromSlice[Array.Contains[Dictionary.Any]](value))
}

func (self Instance) Zoom() Float.X {
	return Float.X(Float.X(class(self).GetZoom()))
}

func (self Instance) SetZoom(value Float.X) {
	class(self).SetZoom(float64(value))
}

func (self Instance) ZoomMin() Float.X {
	return Float.X(Float.X(class(self).GetZoomMin()))
}

func (self Instance) SetZoomMin(value Float.X) {
	class(self).SetZoomMin(float64(value))
}

func (self Instance) ZoomMax() Float.X {
	return Float.X(Float.X(class(self).GetZoomMax()))
}

func (self Instance) SetZoomMax(value Float.X) {
	class(self).SetZoomMax(float64(value))
}

func (self Instance) ZoomStep() Float.X {
	return Float.X(Float.X(class(self).GetZoomStep()))
}

func (self Instance) SetZoomStep(value Float.X) {
	class(self).SetZoomStep(float64(value))
}

func (self Instance) MinimapEnabled() bool {
	return bool(class(self).IsMinimapEnabled())
}

func (self Instance) SetMinimapEnabled(value bool) {
	class(self).SetMinimapEnabled(value)
}

func (self Instance) MinimapSize() Vector2.XY {
	return Vector2.XY(class(self).GetMinimapSize())
}

func (self Instance) SetMinimapSize(value Vector2.XY) {
	class(self).SetMinimapSize(Vector2.XY(value))
}

func (self Instance) MinimapOpacity() Float.X {
	return Float.X(Float.X(class(self).GetMinimapOpacity()))
}

func (self Instance) SetMinimapOpacity(value Float.X) {
	class(self).SetMinimapOpacity(float64(value))
}

func (self Instance) ShowMenu() bool {
	return bool(class(self).IsShowingMenu())
}

func (self Instance) SetShowMenu(value bool) {
	class(self).SetShowMenu(value)
}

func (self Instance) ShowZoomLabel() bool {
	return bool(class(self).IsShowingZoomLabel())
}

func (self Instance) SetShowZoomLabel(value bool) {
	class(self).SetShowZoomLabel(value)
}

func (self Instance) ShowZoomButtons() bool {
	return bool(class(self).IsShowingZoomButtons())
}

func (self Instance) SetShowZoomButtons(value bool) {
	class(self).SetShowZoomButtons(value)
}

func (self Instance) ShowGridButtons() bool {
	return bool(class(self).IsShowingGridButtons())
}

func (self Instance) SetShowGridButtons(value bool) {
	class(self).SetShowGridButtons(value)
}

func (self Instance) ShowMinimapButton() bool {
	return bool(class(self).IsShowingMinimapButton())
}

func (self Instance) SetShowMinimapButton(value bool) {
	class(self).SetShowMinimapButton(value)
}

func (self Instance) ShowArrangeButton() bool {
	return bool(class(self).IsShowingArrangeButton())
}

func (self Instance) SetShowArrangeButton(value bool) {
	class(self).SetShowArrangeButton(value)
}

/*
Returns whether the [param mouse_position] is in the input hot zone.
By default, a hot zone is a [Rect2] positioned such that its center is at [param in_node].[method GraphNode.get_input_port_position]([param in_port]) (For output's case, call [method GraphNode.get_output_port_position] instead). The hot zone's width is twice the Theme Property [code]port_grab_distance_horizontal[/code], and its height is twice the [code]port_grab_distance_vertical[/code].
Below is a sample code to help get started:
[codeblock]
func _is_in_input_hotzone(in_node, in_port, mouse_position):

	var port_size = Vector2(get_theme_constant("port_grab_distance_horizontal"), get_theme_constant("port_grab_distance_vertical"))
	var port_pos = in_node.get_position() + in_node.get_input_port_position(in_port) - port_size / 2
	var rect = Rect2(port_pos, port_size)

	return rect.has_point(mouse_position)

[/codeblock]
*/
func (class) _is_in_input_hotzone(impl func(ptr gdclass.Receiver, in_node [1]gd.Object, in_port int64, mouse_position Vector2.XY) bool) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args, p_back gdextension.Pointer) {
		var in_node = [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gd.UnsafeGet[gdextension.Object](p_args, 0))})}
		defer pointers.End(in_node[0])
		var in_port = gd.UnsafeGet[int64](p_args, 1)
		var mouse_position = gd.UnsafeGet[Vector2.XY](p_args, 2)
		self := gdclass.Receiver(reflect.ValueOf(class).UnsafePointer())
		ret := impl(self, in_node, in_port, mouse_position)
		gd.UnsafeSet(p_back, ret)
	}
}

/*
Returns whether the [param mouse_position] is in the output hot zone. For more information on hot zones, see [method _is_in_input_hotzone].
Below is a sample code to help get started:
[codeblock]
func _is_in_output_hotzone(in_node, in_port, mouse_position):

	var port_size = Vector2(get_theme_constant("port_grab_distance_horizontal"), get_theme_constant("port_grab_distance_vertical"))
	var port_pos = in_node.get_position() + in_node.get_output_port_position(in_port) - port_size / 2
	var rect = Rect2(port_pos, port_size)

	return rect.has_point(mouse_position)

[/codeblock]
*/
func (class) _is_in_output_hotzone(impl func(ptr gdclass.Receiver, in_node [1]gd.Object, in_port int64, mouse_position Vector2.XY) bool) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args, p_back gdextension.Pointer) {
		var in_node = [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gd.UnsafeGet[gdextension.Object](p_args, 0))})}
		defer pointers.End(in_node[0])
		var in_port = gd.UnsafeGet[int64](p_args, 1)
		var mouse_position = gd.UnsafeGet[Vector2.XY](p_args, 2)
		self := gdclass.Receiver(reflect.ValueOf(class).UnsafePointer())
		ret := impl(self, in_node, in_port, mouse_position)
		gd.UnsafeSet(p_back, ret)
	}
}

/*
Virtual method which can be overridden to customize how connections are drawn.
*/
func (class) _get_connection_line(impl func(ptr gdclass.Receiver, from_position Vector2.XY, to_position Vector2.XY) Packed.Array[Vector2.XY]) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args, p_back gdextension.Pointer) {
		var from_position = gd.UnsafeGet[Vector2.XY](p_args, 0)
		var to_position = gd.UnsafeGet[Vector2.XY](p_args, 1)
		self := gdclass.Receiver(reflect.ValueOf(class).UnsafePointer())
		ret := impl(self, from_position, to_position)
		ptr, ok := pointers.End(gd.InternalPacked[gd.PackedVector2Array, Vector2.XY](ret))

		if !ok {
			return
		}
		gd.UnsafeSet(p_back, ptr)
	}
}

/*
This virtual method can be used to insert additional error detection while the user is dragging a connection over a valid port.
Return [code]true[/code] if the connection is indeed valid or return [code]false[/code] if the connection is impossible. If the connection is impossible, no snapping to the port and thus no connection request to that port will happen.
In this example a connection to same node is suppressed:
[codeblocks]
[gdscript]
func _is_node_hover_valid(from, from_port, to, to_port):

	return from != to

[/gdscript]
[csharp]
public override bool _IsNodeHoverValid(StringName fromNode, int fromPort, StringName toNode, int toPort)

	{
	    return fromNode != toNode;
	}

[/csharp]
[/codeblocks]
*/
func (class) _is_node_hover_valid(impl func(ptr gdclass.Receiver, from_node String.Name, from_port int64, to_node String.Name, to_port int64) bool) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args, p_back gdextension.Pointer) {
		var from_node = String.Name(String.Via(gd.StringNameProxy{}, pointers.Pack(pointers.New[gd.StringName](gd.UnsafeGet[gdextension.StringName](p_args, 0)))))
		defer pointers.End(gd.InternalStringName(from_node))
		var from_port = gd.UnsafeGet[int64](p_args, 1)
		var to_node = String.Name(String.Via(gd.StringNameProxy{}, pointers.Pack(pointers.New[gd.StringName](gd.UnsafeGet[gdextension.StringName](p_args, 2)))))
		defer pointers.End(gd.InternalStringName(to_node))
		var to_port = gd.UnsafeGet[int64](p_args, 3)
		self := gdclass.Receiver(reflect.ValueOf(class).UnsafePointer())
		ret := impl(self, from_node, from_port, to_node, to_port)
		gd.UnsafeSet(p_back, ret)
	}
}

/*
Create a connection between the [param from_port] of the [param from_node] [GraphNode] and the [param to_port] of the [param to_node] [GraphNode]. If the connection already exists, no connection is created.
Connections with [param keep_alive] set to [code]false[/code] may be deleted automatically if invalid during a redraw.
*/
//go:nosplit
func (self class) ConnectNode(from_node String.Name, from_port int64, to_node String.Name, to_port int64, keep_alive bool) Error.Code { //gd:GraphEdit.connect_node
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.connect_node, gdextension.SizeInt|(gdextension.SizeStringName<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeStringName<<12)|(gdextension.SizeInt<<16)|(gdextension.SizeBool<<20), &struct {
		from_node  gdextension.StringName
		from_port  int64
		to_node    gdextension.StringName
		to_port    int64
		keep_alive bool
	}{pointers.Get(gd.InternalStringName(from_node)), from_port, pointers.Get(gd.InternalStringName(to_node)), to_port, keep_alive})
	var ret = Error.Code(r_ret)
	return ret
}

/*
Returns [code]true[/code] if the [param from_port] of the [param from_node] [GraphNode] is connected to the [param to_port] of the [param to_node] [GraphNode].
*/
//go:nosplit
func (self class) IsNodeConnected(from_node String.Name, from_port int64, to_node String.Name, to_port int64) bool { //gd:GraphEdit.is_node_connected
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_node_connected, gdextension.SizeBool|(gdextension.SizeStringName<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeStringName<<12)|(gdextension.SizeInt<<16), &struct {
		from_node gdextension.StringName
		from_port int64
		to_node   gdextension.StringName
		to_port   int64
	}{pointers.Get(gd.InternalStringName(from_node)), from_port, pointers.Get(gd.InternalStringName(to_node)), to_port})
	var ret = r_ret
	return ret
}

/*
Removes the connection between the [param from_port] of the [param from_node] [GraphNode] and the [param to_port] of the [param to_node] [GraphNode]. If the connection does not exist, no connection is removed.
*/
//go:nosplit
func (self class) DisconnectNode(from_node String.Name, from_port int64, to_node String.Name, to_port int64) { //gd:GraphEdit.disconnect_node
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.disconnect_node, 0|(gdextension.SizeStringName<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeStringName<<12)|(gdextension.SizeInt<<16), &struct {
		from_node gdextension.StringName
		from_port int64
		to_node   gdextension.StringName
		to_port   int64
	}{pointers.Get(gd.InternalStringName(from_node)), from_port, pointers.Get(gd.InternalStringName(to_node)), to_port})
}

/*
Sets the coloration of the connection between [param from_node]'s [param from_port] and [param to_node]'s [param to_port] with the color provided in the [theme_item activity] theme property. The color is linearly interpolated between the connection color and the activity color using [param amount] as weight.
*/
//go:nosplit
func (self class) SetConnectionActivity(from_node String.Name, from_port int64, to_node String.Name, to_port int64, amount float64) { //gd:GraphEdit.set_connection_activity
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_connection_activity, 0|(gdextension.SizeStringName<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeStringName<<12)|(gdextension.SizeInt<<16)|(gdextension.SizeFloat<<20), &struct {
		from_node gdextension.StringName
		from_port int64
		to_node   gdextension.StringName
		to_port   int64
		amount    float64
	}{pointers.Get(gd.InternalStringName(from_node)), from_port, pointers.Get(gd.InternalStringName(to_node)), to_port, amount})
}

//go:nosplit
func (self class) SetConnections(connections Array.Contains[Dictionary.Any]) { //gd:GraphEdit.set_connections
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_connections, 0|(gdextension.SizeArray<<4), &struct{ connections gdextension.Array }{pointers.Get(gd.InternalArray(connections))})
}

//go:nosplit
func (self class) GetConnectionList() Array.Contains[Dictionary.Any] { //gd:GraphEdit.get_connection_list
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), methods.get_connection_list, gdextension.SizeArray, &struct{}{})
	var ret = Array.Through(gd.ArrayProxy[Dictionary.Any]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

/*
Returns the number of connections from [param from_port] of [param from_node].
*/
//go:nosplit
func (self class) GetConnectionCount(from_node String.Name, from_port int64) int64 { //gd:GraphEdit.get_connection_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_connection_count, gdextension.SizeInt|(gdextension.SizeStringName<<4)|(gdextension.SizeInt<<8), &struct {
		from_node gdextension.StringName
		from_port int64
	}{pointers.Get(gd.InternalStringName(from_node)), from_port})
	var ret = r_ret
	return ret
}

/*
Returns the closest connection to the given point in screen space. If no connection is found within [param max_distance] pixels, an empty [Dictionary] is returned.
A connection is represented as a [Dictionary] in the form of:
[codeblock]
{
    from_node: StringName,
    from_port: int,
    to_node: StringName,
    to_port: int,
    keep_alive: bool
}
[/codeblock]
For example, getting a connection at a given mouse position can be achieved like this:
[codeblocks]
[gdscript]
var connection = get_closest_connection_at_point(mouse_event.get_position())
[/gdscript]
[/codeblocks]
*/
//go:nosplit
func (self class) GetClosestConnectionAtPoint(point Vector2.XY, max_distance float64) Dictionary.Any { //gd:GraphEdit.get_closest_connection_at_point
	var r_ret = gdextension.Call[gdextension.Dictionary](gd.ObjectChecked(self.AsObject()), methods.get_closest_connection_at_point, gdextension.SizeDictionary|(gdextension.SizeVector2<<4)|(gdextension.SizeFloat<<8), &struct {
		point        Vector2.XY
		max_distance float64
	}{point, max_distance})
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret)))
	return ret
}

/*
Returns an [Array] containing the list of connections that intersect with the given [Rect2].
A connection is represented as a [Dictionary] in the form of:
[codeblock]
{
    from_node: StringName,
    from_port: int,
    to_node: StringName,
    to_port: int,
    keep_alive: bool
}
[/codeblock]
*/
//go:nosplit
func (self class) GetConnectionsIntersectingWithRect(rect Rect2.PositionSize) Array.Contains[Dictionary.Any] { //gd:GraphEdit.get_connections_intersecting_with_rect
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), methods.get_connections_intersecting_with_rect, gdextension.SizeArray|(gdextension.SizeRect2<<4), &struct{ rect Rect2.PositionSize }{rect})
	var ret = Array.Through(gd.ArrayProxy[Dictionary.Any]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

/*
Removes all connections between nodes.
*/
//go:nosplit
func (self class) ClearConnections() { //gd:GraphEdit.clear_connections
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.clear_connections, 0, &struct{}{})
}

/*
Ends the creation of the current connection. In other words, if you are dragging a connection you can use this method to abort the process and remove the line that followed your cursor.
This is best used together with [signal connection_drag_started] and [signal connection_drag_ended] to add custom behavior like node addition through shortcuts.
[b]Note:[/b] This method suppresses any other connection request signals apart from [signal connection_drag_ended].
*/
//go:nosplit
func (self class) ForceConnectionDragEnd() { //gd:GraphEdit.force_connection_drag_end
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.force_connection_drag_end, 0, &struct{}{})
}

//go:nosplit
func (self class) GetScrollOffset() Vector2.XY { //gd:GraphEdit.get_scroll_offset
	var r_ret = gdextension.Call[Vector2.XY](gd.ObjectChecked(self.AsObject()), methods.get_scroll_offset, gdextension.SizeVector2, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetScrollOffset(offset Vector2.XY) { //gd:GraphEdit.set_scroll_offset
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_scroll_offset, 0|(gdextension.SizeVector2<<4), &struct{ offset Vector2.XY }{offset})
}

/*
Allows to disconnect nodes when dragging from the right port of the [GraphNode]'s slot if it has the specified type. See also [method remove_valid_right_disconnect_type].
*/
//go:nosplit
func (self class) AddValidRightDisconnectType(atype int64) { //gd:GraphEdit.add_valid_right_disconnect_type
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_valid_right_disconnect_type, 0|(gdextension.SizeInt<<4), &struct{ atype int64 }{atype})
}

/*
Disallows to disconnect nodes when dragging from the right port of the [GraphNode]'s slot if it has the specified type. Use this to disable disconnection previously allowed with [method add_valid_right_disconnect_type].
*/
//go:nosplit
func (self class) RemoveValidRightDisconnectType(atype int64) { //gd:GraphEdit.remove_valid_right_disconnect_type
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.remove_valid_right_disconnect_type, 0|(gdextension.SizeInt<<4), &struct{ atype int64 }{atype})
}

/*
Allows to disconnect nodes when dragging from the left port of the [GraphNode]'s slot if it has the specified type. See also [method remove_valid_left_disconnect_type].
*/
//go:nosplit
func (self class) AddValidLeftDisconnectType(atype int64) { //gd:GraphEdit.add_valid_left_disconnect_type
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_valid_left_disconnect_type, 0|(gdextension.SizeInt<<4), &struct{ atype int64 }{atype})
}

/*
Disallows to disconnect nodes when dragging from the left port of the [GraphNode]'s slot if it has the specified type. Use this to disable disconnection previously allowed with [method add_valid_left_disconnect_type].
*/
//go:nosplit
func (self class) RemoveValidLeftDisconnectType(atype int64) { //gd:GraphEdit.remove_valid_left_disconnect_type
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.remove_valid_left_disconnect_type, 0|(gdextension.SizeInt<<4), &struct{ atype int64 }{atype})
}

/*
Allows the connection between two different port types. The port type is defined individually for the left and the right port of each slot with the [method GraphNode.set_slot] method.
See also [method is_valid_connection_type] and [method remove_valid_connection_type].
*/
//go:nosplit
func (self class) AddValidConnectionType(from_type int64, to_type int64) { //gd:GraphEdit.add_valid_connection_type
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.add_valid_connection_type, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), &struct {
		from_type int64
		to_type   int64
	}{from_type, to_type})
}

/*
Disallows the connection between two different port types previously allowed by [method add_valid_connection_type]. The port type is defined individually for the left and the right port of each slot with the [method GraphNode.set_slot] method.
See also [method is_valid_connection_type].
*/
//go:nosplit
func (self class) RemoveValidConnectionType(from_type int64, to_type int64) { //gd:GraphEdit.remove_valid_connection_type
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.remove_valid_connection_type, 0|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), &struct {
		from_type int64
		to_type   int64
	}{from_type, to_type})
}

/*
Returns whether it's possible to make a connection between two different port types. The port type is defined individually for the left and the right port of each slot with the [method GraphNode.set_slot] method.
See also [method add_valid_connection_type] and [method remove_valid_connection_type].
*/
//go:nosplit
func (self class) IsValidConnectionType(from_type int64, to_type int64) bool { //gd:GraphEdit.is_valid_connection_type
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_valid_connection_type, gdextension.SizeBool|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), &struct {
		from_type int64
		to_type   int64
	}{from_type, to_type})
	var ret = r_ret
	return ret
}

/*
Returns the points which would make up a connection between [param from_node] and [param to_node].
*/
//go:nosplit
func (self class) GetConnectionLine(from_node Vector2.XY, to_node Vector2.XY) Packed.Array[Vector2.XY] { //gd:GraphEdit.get_connection_line
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.get_connection_line, gdextension.SizePackedArray|(gdextension.SizeVector2<<4)|(gdextension.SizeVector2<<8), &struct {
		from_node Vector2.XY
		to_node   Vector2.XY
	}{from_node, to_node})
	var ret = Packed.Array[Vector2.XY](Array.Through(gd.PackedProxy[gd.PackedVector2Array, Vector2.XY]{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

/*
Attaches the [param element] [GraphElement] to the [param frame] [GraphFrame].
*/
//go:nosplit
func (self class) AttachGraphElementToFrame(element String.Name, frame_ String.Name) { //gd:GraphEdit.attach_graph_element_to_frame
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.attach_graph_element_to_frame, 0|(gdextension.SizeStringName<<4)|(gdextension.SizeStringName<<8), &struct {
		element gdextension.StringName
		frame_  gdextension.StringName
	}{pointers.Get(gd.InternalStringName(element)), pointers.Get(gd.InternalStringName(frame_))})
}

/*
Detaches the [param element] [GraphElement] from the [GraphFrame] it is currently attached to.
*/
//go:nosplit
func (self class) DetachGraphElementFromFrame(element String.Name) { //gd:GraphEdit.detach_graph_element_from_frame
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.detach_graph_element_from_frame, 0|(gdextension.SizeStringName<<4), &struct{ element gdextension.StringName }{pointers.Get(gd.InternalStringName(element))})
}

/*
Returns the [GraphFrame] that contains the [GraphElement] with the given name.
*/
//go:nosplit
func (self class) GetElementFrame(element String.Name) [1]gdclass.GraphFrame { //gd:GraphEdit.get_element_frame
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_element_frame, gdextension.SizeObject|(gdextension.SizeStringName<<4), &struct{ element gdextension.StringName }{pointers.Get(gd.InternalStringName(element))})
	var ret = [1]gdclass.GraphFrame{gd.PointerLifetimeBoundTo[gdclass.GraphFrame](self.AsObject(), r_ret)}
	return ret
}

/*
Returns an array of node names that are attached to the [GraphFrame] with the given name.
*/
//go:nosplit
func (self class) GetAttachedNodesOfFrame(frame_ String.Name) Array.Contains[String.Name] { //gd:GraphEdit.get_attached_nodes_of_frame
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), methods.get_attached_nodes_of_frame, gdextension.SizeArray|(gdextension.SizeStringName<<4), &struct{ frame_ gdextension.StringName }{pointers.Get(gd.InternalStringName(frame_))})
	var ret = Array.Through(gd.ArrayProxy[String.Name]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

//go:nosplit
func (self class) SetPanningScheme(scheme PanningScheme) { //gd:GraphEdit.set_panning_scheme
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_panning_scheme, 0|(gdextension.SizeInt<<4), &struct{ scheme PanningScheme }{scheme})
}

//go:nosplit
func (self class) GetPanningScheme() PanningScheme { //gd:GraphEdit.get_panning_scheme
	var r_ret = gdextension.Call[PanningScheme](gd.ObjectChecked(self.AsObject()), methods.get_panning_scheme, gdextension.SizeInt, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetZoom(zoom float64) { //gd:GraphEdit.set_zoom
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_zoom, 0|(gdextension.SizeFloat<<4), &struct{ zoom float64 }{zoom})
}

//go:nosplit
func (self class) GetZoom() float64 { //gd:GraphEdit.get_zoom
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_zoom, gdextension.SizeFloat, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetZoomMin(zoom_min float64) { //gd:GraphEdit.set_zoom_min
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_zoom_min, 0|(gdextension.SizeFloat<<4), &struct{ zoom_min float64 }{zoom_min})
}

//go:nosplit
func (self class) GetZoomMin() float64 { //gd:GraphEdit.get_zoom_min
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_zoom_min, gdextension.SizeFloat, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetZoomMax(zoom_max float64) { //gd:GraphEdit.set_zoom_max
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_zoom_max, 0|(gdextension.SizeFloat<<4), &struct{ zoom_max float64 }{zoom_max})
}

//go:nosplit
func (self class) GetZoomMax() float64 { //gd:GraphEdit.get_zoom_max
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_zoom_max, gdextension.SizeFloat, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetZoomStep(zoom_step float64) { //gd:GraphEdit.set_zoom_step
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_zoom_step, 0|(gdextension.SizeFloat<<4), &struct{ zoom_step float64 }{zoom_step})
}

//go:nosplit
func (self class) GetZoomStep() float64 { //gd:GraphEdit.get_zoom_step
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_zoom_step, gdextension.SizeFloat, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetShowGrid(enable bool) { //gd:GraphEdit.set_show_grid
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_show_grid, 0|(gdextension.SizeBool<<4), &struct{ enable bool }{enable})
}

//go:nosplit
func (self class) IsShowingGrid() bool { //gd:GraphEdit.is_showing_grid
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_showing_grid, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetGridPattern(pattern GridPattern) { //gd:GraphEdit.set_grid_pattern
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_grid_pattern, 0|(gdextension.SizeInt<<4), &struct{ pattern GridPattern }{pattern})
}

//go:nosplit
func (self class) GetGridPattern() GridPattern { //gd:GraphEdit.get_grid_pattern
	var r_ret = gdextension.Call[GridPattern](gd.ObjectChecked(self.AsObject()), methods.get_grid_pattern, gdextension.SizeInt, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetSnappingEnabled(enable bool) { //gd:GraphEdit.set_snapping_enabled
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_snapping_enabled, 0|(gdextension.SizeBool<<4), &struct{ enable bool }{enable})
}

//go:nosplit
func (self class) IsSnappingEnabled() bool { //gd:GraphEdit.is_snapping_enabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_snapping_enabled, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetSnappingDistance(pixels int64) { //gd:GraphEdit.set_snapping_distance
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_snapping_distance, 0|(gdextension.SizeInt<<4), &struct{ pixels int64 }{pixels})
}

//go:nosplit
func (self class) GetSnappingDistance() int64 { //gd:GraphEdit.get_snapping_distance
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_snapping_distance, gdextension.SizeInt, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetConnectionLinesCurvature(curvature float64) { //gd:GraphEdit.set_connection_lines_curvature
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_connection_lines_curvature, 0|(gdextension.SizeFloat<<4), &struct{ curvature float64 }{curvature})
}

//go:nosplit
func (self class) GetConnectionLinesCurvature() float64 { //gd:GraphEdit.get_connection_lines_curvature
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_connection_lines_curvature, gdextension.SizeFloat, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetConnectionLinesThickness(pixels float64) { //gd:GraphEdit.set_connection_lines_thickness
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_connection_lines_thickness, 0|(gdextension.SizeFloat<<4), &struct{ pixels float64 }{pixels})
}

//go:nosplit
func (self class) GetConnectionLinesThickness() float64 { //gd:GraphEdit.get_connection_lines_thickness
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_connection_lines_thickness, gdextension.SizeFloat, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetConnectionLinesAntialiased(pixels bool) { //gd:GraphEdit.set_connection_lines_antialiased
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_connection_lines_antialiased, 0|(gdextension.SizeBool<<4), &struct{ pixels bool }{pixels})
}

//go:nosplit
func (self class) IsConnectionLinesAntialiased() bool { //gd:GraphEdit.is_connection_lines_antialiased
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_connection_lines_antialiased, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetMinimapSize(size Vector2.XY) { //gd:GraphEdit.set_minimap_size
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_minimap_size, 0|(gdextension.SizeVector2<<4), &struct{ size Vector2.XY }{size})
}

//go:nosplit
func (self class) GetMinimapSize() Vector2.XY { //gd:GraphEdit.get_minimap_size
	var r_ret = gdextension.Call[Vector2.XY](gd.ObjectChecked(self.AsObject()), methods.get_minimap_size, gdextension.SizeVector2, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetMinimapOpacity(opacity float64) { //gd:GraphEdit.set_minimap_opacity
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_minimap_opacity, 0|(gdextension.SizeFloat<<4), &struct{ opacity float64 }{opacity})
}

//go:nosplit
func (self class) GetMinimapOpacity() float64 { //gd:GraphEdit.get_minimap_opacity
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_minimap_opacity, gdextension.SizeFloat, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetMinimapEnabled(enable bool) { //gd:GraphEdit.set_minimap_enabled
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_minimap_enabled, 0|(gdextension.SizeBool<<4), &struct{ enable bool }{enable})
}

//go:nosplit
func (self class) IsMinimapEnabled() bool { //gd:GraphEdit.is_minimap_enabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_minimap_enabled, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetShowMenu(hidden bool) { //gd:GraphEdit.set_show_menu
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_show_menu, 0|(gdextension.SizeBool<<4), &struct{ hidden bool }{hidden})
}

//go:nosplit
func (self class) IsShowingMenu() bool { //gd:GraphEdit.is_showing_menu
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_showing_menu, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetShowZoomLabel(enable bool) { //gd:GraphEdit.set_show_zoom_label
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_show_zoom_label, 0|(gdextension.SizeBool<<4), &struct{ enable bool }{enable})
}

//go:nosplit
func (self class) IsShowingZoomLabel() bool { //gd:GraphEdit.is_showing_zoom_label
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_showing_zoom_label, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetShowGridButtons(hidden bool) { //gd:GraphEdit.set_show_grid_buttons
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_show_grid_buttons, 0|(gdextension.SizeBool<<4), &struct{ hidden bool }{hidden})
}

//go:nosplit
func (self class) IsShowingGridButtons() bool { //gd:GraphEdit.is_showing_grid_buttons
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_showing_grid_buttons, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetShowZoomButtons(hidden bool) { //gd:GraphEdit.set_show_zoom_buttons
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_show_zoom_buttons, 0|(gdextension.SizeBool<<4), &struct{ hidden bool }{hidden})
}

//go:nosplit
func (self class) IsShowingZoomButtons() bool { //gd:GraphEdit.is_showing_zoom_buttons
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_showing_zoom_buttons, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetShowMinimapButton(hidden bool) { //gd:GraphEdit.set_show_minimap_button
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_show_minimap_button, 0|(gdextension.SizeBool<<4), &struct{ hidden bool }{hidden})
}

//go:nosplit
func (self class) IsShowingMinimapButton() bool { //gd:GraphEdit.is_showing_minimap_button
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_showing_minimap_button, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetShowArrangeButton(hidden bool) { //gd:GraphEdit.set_show_arrange_button
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_show_arrange_button, 0|(gdextension.SizeBool<<4), &struct{ hidden bool }{hidden})
}

//go:nosplit
func (self class) IsShowingArrangeButton() bool { //gd:GraphEdit.is_showing_arrange_button
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_showing_arrange_button, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetRightDisconnects(enable bool) { //gd:GraphEdit.set_right_disconnects
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_right_disconnects, 0|(gdextension.SizeBool<<4), &struct{ enable bool }{enable})
}

//go:nosplit
func (self class) IsRightDisconnectsEnabled() bool { //gd:GraphEdit.is_right_disconnects_enabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_right_disconnects_enabled, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

/*
Gets the [HBoxContainer] that contains the zooming and grid snap controls in the top left of the graph. You can use this method to reposition the toolbar or to add your own custom controls to it.
[b]Warning:[/b] This is a required internal node, removing and freeing it may cause a crash. If you wish to hide it or any of its children, use their [member CanvasItem.visible] property.
*/
//go:nosplit
func (self class) GetMenuHbox() [1]gdclass.HBoxContainer { //gd:GraphEdit.get_menu_hbox
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.get_menu_hbox, gdextension.SizeObject, &struct{}{})
	var ret = [1]gdclass.HBoxContainer{gd.PointerLifetimeBoundTo[gdclass.HBoxContainer](self.AsObject(), r_ret)}
	return ret
}

/*
Rearranges selected nodes in a layout with minimum crossings between connections and uniform horizontal and vertical gap between nodes.
*/
//go:nosplit
func (self class) ArrangeNodes() { //gd:GraphEdit.arrange_nodes
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.arrange_nodes, 0, &struct{}{})
}

/*
Sets the specified [param node] as the one selected.
*/
//go:nosplit
func (self class) SetSelected(node [1]gdclass.Node) { //gd:GraphEdit.set_selected
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_selected, 0|(gdextension.SizeObject<<4), &struct{ node gdextension.Object }{gdextension.Object(gd.ObjectChecked(node[0].AsObject()))})
}
func (self Instance) OnConnectionRequest(cb func(from_node string, from_port int, to_node string, to_port int), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("connection_request"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) ConnectionRequest() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`ConnectionRequest`))))
}

func (self Instance) OnDisconnectionRequest(cb func(from_node string, from_port int, to_node string, to_port int), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("disconnection_request"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) DisconnectionRequest() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`DisconnectionRequest`))))
}

func (self Instance) OnConnectionToEmpty(cb func(from_node string, from_port int, release_position Vector2.XY), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("connection_to_empty"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) ConnectionToEmpty() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`ConnectionToEmpty`))))
}

func (self Instance) OnConnectionFromEmpty(cb func(to_node string, to_port int, release_position Vector2.XY), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("connection_from_empty"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) ConnectionFromEmpty() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`ConnectionFromEmpty`))))
}

func (self Instance) OnConnectionDragStarted(cb func(from_node string, from_port int, is_output bool), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("connection_drag_started"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) ConnectionDragStarted() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`ConnectionDragStarted`))))
}

func (self Instance) OnConnectionDragEnded(cb func(), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("connection_drag_ended"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) ConnectionDragEnded() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`ConnectionDragEnded`))))
}

func (self Instance) OnCopyNodesRequest(cb func(), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("copy_nodes_request"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) CopyNodesRequest() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`CopyNodesRequest`))))
}

func (self Instance) OnCutNodesRequest(cb func(), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("cut_nodes_request"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) CutNodesRequest() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`CutNodesRequest`))))
}

func (self Instance) OnPasteNodesRequest(cb func(), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("paste_nodes_request"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) PasteNodesRequest() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`PasteNodesRequest`))))
}

func (self Instance) OnDuplicateNodesRequest(cb func(), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("duplicate_nodes_request"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) DuplicateNodesRequest() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`DuplicateNodesRequest`))))
}

func (self Instance) OnDeleteNodesRequest(cb func(nodes []string), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("delete_nodes_request"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) DeleteNodesRequest() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`DeleteNodesRequest`))))
}

func (self Instance) OnNodeSelected(cb func(node Node.Instance), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("node_selected"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) NodeSelected() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`NodeSelected`))))
}

func (self Instance) OnNodeDeselected(cb func(node Node.Instance), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("node_deselected"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) NodeDeselected() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`NodeDeselected`))))
}

func (self Instance) OnFrameRectChanged(cb func(frame_ GraphFrame.Instance, new_rect Rect2.PositionSize), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("frame_rect_changed"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) FrameRectChanged() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`FrameRectChanged`))))
}

func (self Instance) OnPopupRequest(cb func(at_position Vector2.XY), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("popup_request"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) PopupRequest() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`PopupRequest`))))
}

func (self Instance) OnBeginNodeMove(cb func(), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("begin_node_move"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) BeginNodeMove() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`BeginNodeMove`))))
}

func (self Instance) OnEndNodeMove(cb func(), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("end_node_move"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) EndNodeMove() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`EndNodeMove`))))
}

func (self Instance) OnGraphElementsLinkedToFrameRequest(cb func(elements []any, frame_ string), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("graph_elements_linked_to_frame_request"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) GraphElementsLinkedToFrameRequest() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`GraphElementsLinkedToFrameRequest`))))
}

func (self Instance) OnScrollOffsetChanged(cb func(offset Vector2.XY), flags ...Signal.Flags) {
	var flags_together Signal.Flags
	for _, flag := range flags {
		flags_together |= flag
	}
	self[0].AsObject()[0].Connect(gd.NewStringName("scroll_offset_changed"), gd.NewCallable(cb), int64(flags_together))
}

func (self class) ScrollOffsetChanged() Signal.Any {
	return Signal.Via(gd.SignalProxy{}, pointers.Pack(gd.NewSignalOf(self.AsObject(), gd.NewStringName(`ScrollOffsetChanged`))))
}

func (self class) AsGraphEdit() Advanced { return Advanced{pointers.AsA[gdclass.GraphEdit](self[0])} }
func (self Instance) AsGraphEdit() Instance {
	return Instance{pointers.AsA[gdclass.GraphEdit](self[0])}
}
func (self *Extension[T]) AsGraphEdit() Instance { return self.Super().AsGraphEdit() }
func (self class) AsControl() Control.Advanced {
	return Control.Advanced{pointers.AsA[gdclass.Control](self[0])}
}
func (self *Extension[T]) AsControl() Control.Instance { return self.Super().AsControl() }
func (self Instance) AsControl() Control.Instance {
	return Control.Instance{pointers.AsA[gdclass.Control](self[0])}
}
func (self class) AsCanvasItem() CanvasItem.Advanced {
	return CanvasItem.Advanced{pointers.AsA[gdclass.CanvasItem](self[0])}
}
func (self *Extension[T]) AsCanvasItem() CanvasItem.Instance { return self.Super().AsCanvasItem() }
func (self Instance) AsCanvasItem() CanvasItem.Instance {
	return CanvasItem.Instance{pointers.AsA[gdclass.CanvasItem](self[0])}
}
func (self class) AsNode() Node.Advanced         { return Node.Advanced{pointers.AsA[gdclass.Node](self[0])} }
func (self *Extension[T]) AsNode() Node.Instance { return self.Super().AsNode() }
func (self Instance) AsNode() Node.Instance {
	return Node.Instance{pointers.AsA[gdclass.Node](self[0])}
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	case "_is_in_input_hotzone":
		return reflect.ValueOf(self._is_in_input_hotzone)
	case "_is_in_output_hotzone":
		return reflect.ValueOf(self._is_in_output_hotzone)
	case "_get_connection_line":
		return reflect.ValueOf(self._get_connection_line)
	case "_is_node_hover_valid":
		return reflect.ValueOf(self._is_node_hover_valid)
	default:
		return gd.VirtualByName(Control.Advanced(self.AsControl()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	case "_is_in_input_hotzone":
		return reflect.ValueOf(self._is_in_input_hotzone)
	case "_is_in_output_hotzone":
		return reflect.ValueOf(self._is_in_output_hotzone)
	case "_get_connection_line":
		return reflect.ValueOf(self._get_connection_line)
	case "_is_node_hover_valid":
		return reflect.ValueOf(self._is_node_hover_valid)
	default:
		return gd.VirtualByName(Control.Instance(self.AsControl()), name)
	}
}
func init() {
	gdclass.Register("GraphEdit", func(ptr gd.Object) any { return Instance{pointers.AsA[gdclass.GraphEdit](ptr)} })
}

type PanningScheme int //gd:GraphEdit.PanningScheme

const (
	/*[kbd]Mouse Wheel[/kbd] will zoom, [kbd]Ctrl + Mouse Wheel[/kbd] will move the view.*/
	ScrollZooms PanningScheme = 0
	/*[kbd]Mouse Wheel[/kbd] will move the view, [kbd]Ctrl + Mouse Wheel[/kbd] will zoom.*/
	ScrollPans PanningScheme = 1
)

type GridPattern int //gd:GraphEdit.GridPattern

const (
	/*Draw the grid using solid lines.*/
	GridPatternLines GridPattern = 0
	/*Draw the grid using dots.*/
	GridPatternDots GridPattern = 1
)

type Connection struct {
	FromNode  string `gd:"from_node"`
	FromPort  int    `gd:"from_port"`
	ToNode    string `gd:"to_node"`
	ToPort    int    `gd:"to_port"`
	KeepAlive bool   `gd:"keep_alive"`
}
