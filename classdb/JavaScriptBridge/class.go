// Code generated by the generate package DO NOT EDIT

// Package JavaScriptBridge provides methods for working with JavaScriptBridge object instances.
package JavaScriptBridge

import "unsafe"
import "sync"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/JavaScriptObject"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
The JavaScriptBridge singleton is implemented only in the Web export. It's used to access the browser's JavaScript context. This allows interaction with embedding pages or calling third-party JavaScript APIs.
[b]Note:[/b] This singleton can be disabled at build-time to improve security. By default, the JavaScriptBridge singleton is enabled. Official export templates also have the JavaScriptBridge singleton enabled. See [url=$DOCS_URL/contributing/development/compiling/compiling_for_web.html]Compiling for the Web[/url] in the documentation for more information.
*/
type Instance [1]gdclass.JavaScriptBridge

func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

var self [1]gdclass.JavaScriptBridge
var once sync.Once

func singleton() {
	obj := gd.Global.Object.GetSingleton(gd.Global.Singletons.JavaScriptBridge)
	self = *(*[1]gdclass.JavaScriptBridge)(unsafe.Pointer(&obj))
}

/*
Execute the string [param code] as JavaScript code within the browser window. This is a call to the actual global JavaScript function [code skip-lint]eval()[/code].
If [param use_global_execution_context] is [code]true[/code], the code will be evaluated in the global execution context. Otherwise, it is evaluated in the execution context of a function within the engine's runtime environment.
*/
func Eval(code string, use_global_execution_context bool) any { //gd:JavaScriptBridge.eval
	once.Do(singleton)
	return any(Advanced().Eval(String.New(code), use_global_execution_context).Interface())
}

/*
Execute the string [param code] as JavaScript code within the browser window. This is a call to the actual global JavaScript function [code skip-lint]eval()[/code].
If [param use_global_execution_context] is [code]true[/code], the code will be evaluated in the global execution context. Otherwise, it is evaluated in the execution context of a function within the engine's runtime environment.
*/
func EvalOptions(code string, use_global_execution_context bool) any { //gd:JavaScriptBridge.eval
	once.Do(singleton)
	return any(Advanced().Eval(String.New(code), use_global_execution_context).Interface())
}

/*
Returns an interface to a JavaScript object that can be used by scripts. The [param interface] must be a valid property of the JavaScript [code]window[/code]. The callback must accept a single [Array] argument, which will contain the JavaScript [code]arguments[/code]. See [JavaScriptObject] for usage.
*/
func GetInterface(intf string) JavaScriptObject.Instance { //gd:JavaScriptBridge.get_interface
	once.Do(singleton)
	return JavaScriptObject.Instance(Advanced().GetInterface(String.New(intf)))
}

/*
Creates a reference to a [Callable] that can be used as a callback by JavaScript. The reference must be kept until the callback happens, or it won't be called at all. See [JavaScriptObject] for usage.
[b]Note:[/b] The callback function must take exactly one [Array] argument, which is going to be the JavaScript [url=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments]arguments object[/url] converted to an array.
*/
func CreateCallback(callable Callable.Function) JavaScriptObject.Instance { //gd:JavaScriptBridge.create_callback
	once.Do(singleton)
	return JavaScriptObject.Instance(Advanced().CreateCallback(Callable.New(callable)))
}

/*
Returns [code]true[/code] if the given [param javascript_object] is of type [url=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer][code]ArrayBuffer[/code][/url], [url=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView][code]DataView[/code][/url], or one of the many [url=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray]typed array objects[/url].
*/
func IsJsBuffer(javascript_object JavaScriptObject.Instance) bool { //gd:JavaScriptBridge.is_js_buffer
	once.Do(singleton)
	return bool(Advanced().IsJsBuffer(javascript_object))
}

/*
Returns a copy of [param javascript_buffer]'s contents as a [PackedByteArray]. See also [method is_js_buffer].
*/
func JsBufferToPackedByteArray(javascript_buffer JavaScriptObject.Instance) []byte { //gd:JavaScriptBridge.js_buffer_to_packed_byte_array
	once.Do(singleton)
	return []byte(Advanced().JsBufferToPackedByteArray(javascript_buffer).Bytes())
}

/*
Creates a new JavaScript object using the [code]new[/code] constructor. The [param object] must a valid property of the JavaScript [code]window[/code]. See [JavaScriptObject] for usage.
*/
func CreateObject(obj string, args ...any) any { //gd:JavaScriptBridge.create_object
	once.Do(singleton)
	var converted_variants = make([]gd.Variant, len(args))
	for i, arg := range args {
		converted_variants[i] = gd.NewVariant(arg)
	}
	return any(Advanced().CreateObject(String.New(obj), converted_variants...).Interface())
}

/*
Prompts the user to download a file containing the specified [param buffer]. The file will have the given [param name] and [param mime] type.
[b]Note:[/b] The browser may override the [url=https://en.wikipedia.org/wiki/Media_type]MIME type[/url] provided based on the file [param name]'s extension.
[b]Note:[/b] Browsers might block the download if [method download_buffer] is not being called from a user interaction (e.g. button click).
[b]Note:[/b] Browsers might ask the user for permission or block the download if multiple download requests are made in a quick succession.
*/
func DownloadBuffer(buffer []byte, name string) { //gd:JavaScriptBridge.download_buffer
	once.Do(singleton)
	Advanced().DownloadBuffer(Packed.Bytes(Packed.New(buffer...)), String.New(name), String.New("application/octet-stream"))
}

/*
Prompts the user to download a file containing the specified [param buffer]. The file will have the given [param name] and [param mime] type.
[b]Note:[/b] The browser may override the [url=https://en.wikipedia.org/wiki/Media_type]MIME type[/url] provided based on the file [param name]'s extension.
[b]Note:[/b] Browsers might block the download if [method download_buffer] is not being called from a user interaction (e.g. button click).
[b]Note:[/b] Browsers might ask the user for permission or block the download if multiple download requests are made in a quick succession.
*/
func DownloadBufferOptions(buffer []byte, name string, mime string) { //gd:JavaScriptBridge.download_buffer
	once.Do(singleton)
	Advanced().DownloadBuffer(Packed.Bytes(Packed.New(buffer...)), String.New(name), String.New(mime))
}

/*
Returns [code]true[/code] if a new version of the progressive web app is waiting to be activated.
[b]Note:[/b] Only relevant when exported as a Progressive Web App.
*/
func PwaNeedsUpdate() bool { //gd:JavaScriptBridge.pwa_needs_update
	once.Do(singleton)
	return bool(Advanced().PwaNeedsUpdate())
}

/*
Performs the live update of the progressive web app. Forcing the new version to be installed and the page to be reloaded.
[b]Note:[/b] Your application will be [b]reloaded in all browser tabs[/b].
[b]Note:[/b] Only relevant when exported as a Progressive Web App and [method pwa_needs_update] returns [code]true[/code].
*/
func PwaUpdate() error { //gd:JavaScriptBridge.pwa_update
	once.Do(singleton)
	return error(gd.ToError(Advanced().PwaUpdate()))
}

/*
Force synchronization of the persistent file system (when enabled).
[b]Note:[/b] This is only useful for modules or extensions that can't use [FileAccess] to write files.
*/
func ForceFsSync() { //gd:JavaScriptBridge.force_fs_sync
	once.Do(singleton)
	Advanced().ForceFsSync()
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
func Advanced() class { once.Do(singleton); return self }

type class [1]gdclass.JavaScriptBridge

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }

/*
Execute the string [param code] as JavaScript code within the browser window. This is a call to the actual global JavaScript function [code skip-lint]eval()[/code].
If [param use_global_execution_context] is [code]true[/code], the code will be evaluated in the global execution context. Otherwise, it is evaluated in the execution context of a function within the engine's runtime environment.
*/
//go:nosplit
func (self class) Eval(code String.Readable, use_global_execution_context bool) variant.Any { //gd:JavaScriptBridge.eval
	var r_ret = gdextension.Call[[3]uint64](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.JavaScriptBridge.Bind_eval), gdextension.SizeVariant|(gdextension.SizeString<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		code                         gdextension.String
		use_global_execution_context bool
	}{gdextension.String(pointers.Get(gd.InternalString(code))[0]), use_global_execution_context}))
	var ret = variant.Implementation(gd.VariantProxy{}, pointers.Pack(pointers.New[gd.Variant](r_ret)))
	return ret
}

/*
Returns an interface to a JavaScript object that can be used by scripts. The [param interface] must be a valid property of the JavaScript [code]window[/code]. The callback must accept a single [Array] argument, which will contain the JavaScript [code]arguments[/code]. See [JavaScriptObject] for usage.
*/
//go:nosplit
func (self class) GetInterface(intf String.Readable) [1]gdclass.JavaScriptObject { //gd:JavaScriptBridge.get_interface
	var r_ret = gdextension.Call[gd.EnginePointer](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.JavaScriptBridge.Bind_get_interface), gdextension.SizeObject|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ intf gdextension.String }{gdextension.String(pointers.Get(gd.InternalString(intf))[0])}))
	var ret = [1]gdclass.JavaScriptObject{gd.PointerWithOwnershipTransferredToGo[gdclass.JavaScriptObject](r_ret)}
	return ret
}

/*
Creates a reference to a [Callable] that can be used as a callback by JavaScript. The reference must be kept until the callback happens, or it won't be called at all. See [JavaScriptObject] for usage.
[b]Note:[/b] The callback function must take exactly one [Array] argument, which is going to be the JavaScript [url=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments]arguments object[/url] converted to an array.
*/
//go:nosplit
func (self class) CreateCallback(callable Callable.Function) [1]gdclass.JavaScriptObject { //gd:JavaScriptBridge.create_callback
	var r_ret = gdextension.Call[gd.EnginePointer](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.JavaScriptBridge.Bind_create_callback), gdextension.SizeObject|(gdextension.SizeCallable<<4), unsafe.Pointer(&struct{ callable gdextension.Callable }{gdextension.Callable(pointers.Get(gd.InternalCallable(callable)))}))
	var ret = [1]gdclass.JavaScriptObject{gd.PointerWithOwnershipTransferredToGo[gdclass.JavaScriptObject](r_ret)}
	return ret
}

/*
Returns [code]true[/code] if the given [param javascript_object] is of type [url=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer][code]ArrayBuffer[/code][/url], [url=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView][code]DataView[/code][/url], or one of the many [url=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray]typed array objects[/url].
*/
//go:nosplit
func (self class) IsJsBuffer(javascript_object [1]gdclass.JavaScriptObject) bool { //gd:JavaScriptBridge.is_js_buffer
	var r_ret = gdextension.Call[bool](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.JavaScriptBridge.Bind_is_js_buffer), gdextension.SizeBool|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ javascript_object gdextension.Object }{gdextension.Object(gd.ObjectChecked(javascript_object[0].AsObject()))}))
	var ret = r_ret
	return ret
}

/*
Returns a copy of [param javascript_buffer]'s contents as a [PackedByteArray]. See also [method is_js_buffer].
*/
//go:nosplit
func (self class) JsBufferToPackedByteArray(javascript_buffer [1]gdclass.JavaScriptObject) Packed.Bytes { //gd:JavaScriptBridge.js_buffer_to_packed_byte_array
	var r_ret = gdextension.Call[gd.PackedPointers](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.JavaScriptBridge.Bind_js_buffer_to_packed_byte_array), gdextension.SizePackedArray|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ javascript_buffer gdextension.Object }{gdextension.Object(gd.ObjectChecked(javascript_buffer[0].AsObject()))}))
	var ret = Packed.Bytes(Array.Through(gd.PackedProxy[gd.PackedByteArray, byte]{}, pointers.Pack(pointers.Let[gd.PackedByteArray](r_ret))))
	return ret
}

/*
Creates a new JavaScript object using the [code]new[/code] constructor. The [param object] must a valid property of the JavaScript [code]window[/code]. See [JavaScriptObject] for usage.
*/
//go:nosplit
func (self class) CreateObject(obj String.Readable, args ...gd.Variant) variant.Any { //gd:JavaScriptBridge.create_object
	var fixed = [...]gdextension.Variant{gdextension.Variant(pointers.Get(gd.NewVariant(obj)))}
	ret, err := gdextension.MethodForClass(gd.Global.Methods.JavaScriptBridge.Bind_create_object).Call(gdextension.Object(gd.ObjectChecked(self.AsObject())), fixed[:]...)
	if err != nil {
		panic(err)
	}
	return gd.VariantAs[variant.Any](pointers.New[gd.Variant]([3]uint64(ret)))
}

/*
Prompts the user to download a file containing the specified [param buffer]. The file will have the given [param name] and [param mime] type.
[b]Note:[/b] The browser may override the [url=https://en.wikipedia.org/wiki/Media_type]MIME type[/url] provided based on the file [param name]'s extension.
[b]Note:[/b] Browsers might block the download if [method download_buffer] is not being called from a user interaction (e.g. button click).
[b]Note:[/b] Browsers might ask the user for permission or block the download if multiple download requests are made in a quick succession.
*/
//go:nosplit
func (self class) DownloadBuffer(buffer Packed.Bytes, name String.Readable, mime String.Readable) { //gd:JavaScriptBridge.download_buffer
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.JavaScriptBridge.Bind_download_buffer), 0|(gdextension.SizePackedArray<<4)|(gdextension.SizeString<<8)|(gdextension.SizeString<<12), unsafe.Pointer(&struct {
		buffer gdextension.PackedArray
		name   gdextension.String
		mime   gdextension.String
	}{gdextension.ToPackedArray(pointers.Get(gd.InternalPacked[gd.PackedByteArray, byte](Packed.Array[byte](buffer)))), gdextension.String(pointers.Get(gd.InternalString(name))[0]), gdextension.String(pointers.Get(gd.InternalString(mime))[0])}))
}

/*
Returns [code]true[/code] if a new version of the progressive web app is waiting to be activated.
[b]Note:[/b] Only relevant when exported as a Progressive Web App.
*/
//go:nosplit
func (self class) PwaNeedsUpdate() bool { //gd:JavaScriptBridge.pwa_needs_update
	var r_ret = gdextension.Call[bool](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.JavaScriptBridge.Bind_pwa_needs_update), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Performs the live update of the progressive web app. Forcing the new version to be installed and the page to be reloaded.
[b]Note:[/b] Your application will be [b]reloaded in all browser tabs[/b].
[b]Note:[/b] Only relevant when exported as a Progressive Web App and [method pwa_needs_update] returns [code]true[/code].
*/
//go:nosplit
func (self class) PwaUpdate() Error.Code { //gd:JavaScriptBridge.pwa_update
	var r_ret = gdextension.Call[int64](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.JavaScriptBridge.Bind_pwa_update), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = Error.Code(r_ret)
	return ret
}

/*
Force synchronization of the persistent file system (when enabled).
[b]Note:[/b] This is only useful for modules or extensions that can't use [FileAccess] to write files.
*/
//go:nosplit
func (self class) ForceFsSync() { //gd:JavaScriptBridge.force_fs_sync
	gdextension.Call[struct{}](gdextension.Object(gd.ObjectChecked(self.AsObject())), gdextension.MethodForClass(gd.Global.Methods.JavaScriptBridge.Bind_force_fs_sync), 0, unsafe.Pointer(&struct{}{}))
}
func OnPwaUpdateAvailable(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("pwa_update_available"), gd.NewCallable(cb), 0)
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Object.Advanced(self.AsObject()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Object.Instance(self.AsObject()), name)
	}
}
func init() {
	gdclass.Register("JavaScriptBridge", func(ptr gd.Object) any {
		return [1]gdclass.JavaScriptBridge{*(*gdclass.JavaScriptBridge)(unsafe.Pointer(&ptr))}
	})
}
