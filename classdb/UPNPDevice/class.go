// Code generated by the generate package DO NOT EDIT

// Package UPNPDevice provides methods for working with UPNPDevice object instances.
package UPNPDevice

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
Universal Plug and Play (UPnP) device. See [UPNP] for UPnP discovery and utility functions. Provides low-level access to UPNP control commands. Allows to manage port mappings (port forwarding) and to query network information of the device (like local and external IP address and status). Note that methods on this class are synchronous and block the calling thread.
*/
type Instance [1]gdclass.UPNPDevice

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	is_valid_gateway       gdextension.MethodForClass `hash:"36873697"`
	query_external_address gdextension.MethodForClass `hash:"201670096"`
	add_port_mapping       gdextension.MethodForClass `hash:"818314583"`
	delete_port_mapping    gdextension.MethodForClass `hash:"3444187325"`
	set_description_url    gdextension.MethodForClass `hash:"83702148"`
	get_description_url    gdextension.MethodForClass `hash:"201670096"`
	set_service_type       gdextension.MethodForClass `hash:"83702148"`
	get_service_type       gdextension.MethodForClass `hash:"201670096"`
	set_igd_control_url    gdextension.MethodForClass `hash:"83702148"`
	get_igd_control_url    gdextension.MethodForClass `hash:"201670096"`
	set_igd_service_type   gdextension.MethodForClass `hash:"83702148"`
	get_igd_service_type   gdextension.MethodForClass `hash:"201670096"`
	set_igd_our_addr       gdextension.MethodForClass `hash:"83702148"`
	get_igd_our_addr       gdextension.MethodForClass `hash:"201670096"`
	set_igd_status         gdextension.MethodForClass `hash:"519504122"`
	get_igd_status         gdextension.MethodForClass `hash:"180887011"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("UPNPDevice")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		pointers.Raw[gd.StringName](sname).Free()
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

type Expanded [1]gdclass.UPNPDevice

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsUPNPDevice() Instance
}

/*
Returns [code]true[/code] if this is a valid IGD (InternetGatewayDevice) which potentially supports port forwarding.
*/
func (self Instance) IsValidGateway() bool { //gd:UPNPDevice.is_valid_gateway
	return bool(Advanced(self).IsValidGateway())
}

/*
Returns the external IP address of this [UPNPDevice] or an empty string.
*/
func (self Instance) QueryExternalAddress() string { //gd:UPNPDevice.query_external_address
	return string(Advanced(self).QueryExternalAddress().String())
}

/*
Adds a port mapping to forward the given external port on this [UPNPDevice] for the given protocol to the local machine. See [method UPNP.add_port_mapping].
*/
func (self Instance) AddPortMapping(port int) int { //gd:UPNPDevice.add_port_mapping
	return int(int(Advanced(self).AddPortMapping(int64(port), int64(0), String.New(""), String.New("UDP"), int64(0))))
}

/*
Adds a port mapping to forward the given external port on this [UPNPDevice] for the given protocol to the local machine. See [method UPNP.add_port_mapping].
*/
func (self Expanded) AddPortMapping(port int, port_internal int, desc string, proto string, duration int) int { //gd:UPNPDevice.add_port_mapping
	return int(int(Advanced(self).AddPortMapping(int64(port), int64(port_internal), String.New(desc), String.New(proto), int64(duration))))
}

/*
Deletes the port mapping identified by the given port and protocol combination on this device. See [method UPNP.delete_port_mapping].
*/
func (self Instance) DeletePortMapping(port int) int { //gd:UPNPDevice.delete_port_mapping
	return int(int(Advanced(self).DeletePortMapping(int64(port), String.New("UDP"))))
}

/*
Deletes the port mapping identified by the given port and protocol combination on this device. See [method UPNP.delete_port_mapping].
*/
func (self Expanded) DeletePortMapping(port int, proto string) int { //gd:UPNPDevice.delete_port_mapping
	return int(int(Advanced(self).DeletePortMapping(int64(port), String.New(proto))))
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.UPNPDevice

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.UPNPDevice)(unsafe.Pointer(&obj))
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.UPNPDevice)(unsafe.Pointer(&obj))
		return true
	}
	return false
}

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {

	if !gd.Linked {
		var placeholder Instance
		*(*gd.Object)(unsafe.Pointer(&placeholder)) = pointers.Add[gd.Object]([3]uint64{})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(*(*gd.Object)(unsafe.Pointer(&placeholder)), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	object := [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})}
	casted := Instance{*(*gdclass.UPNPDevice)(unsafe.Pointer(&object))}
	casted.AsRefCounted()[0].Reference()
	object[0].Notification(0, false)
	return casted
}

func (self Instance) DescriptionUrl() string {
	return string(class(self).GetDescriptionUrl().String())
}

func (self Instance) SetDescriptionUrl(value string) {
	class(self).SetDescriptionUrl(String.New(value))
}

func (self Instance) ServiceType() string {
	return string(class(self).GetServiceType().String())
}

func (self Instance) SetServiceType(value string) {
	class(self).SetServiceType(String.New(value))
}

func (self Instance) IgdControlUrl() string {
	return string(class(self).GetIgdControlUrl().String())
}

func (self Instance) SetIgdControlUrl(value string) {
	class(self).SetIgdControlUrl(String.New(value))
}

func (self Instance) IgdServiceType() string {
	return string(class(self).GetIgdServiceType().String())
}

func (self Instance) SetIgdServiceType(value string) {
	class(self).SetIgdServiceType(String.New(value))
}

func (self Instance) IgdOurAddr() string {
	return string(class(self).GetIgdOurAddr().String())
}

func (self Instance) SetIgdOurAddr(value string) {
	class(self).SetIgdOurAddr(String.New(value))
}

func (self Instance) IgdStatus() IGDStatus {
	return IGDStatus(class(self).GetIgdStatus())
}

func (self Instance) SetIgdStatus(value IGDStatus) {
	class(self).SetIgdStatus(value)
}

/*
Returns [code]true[/code] if this is a valid IGD (InternetGatewayDevice) which potentially supports port forwarding.
*/
//go:nosplit
func (self class) IsValidGateway() bool { //gd:UPNPDevice.is_valid_gateway
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_valid_gateway, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the external IP address of this [UPNPDevice] or an empty string.
*/
//go:nosplit
func (self class) QueryExternalAddress() String.Readable { //gd:UPNPDevice.query_external_address
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.query_external_address, gdextension.SizeString, unsafe.Pointer(&struct{}{}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Adds a port mapping to forward the given external port on this [UPNPDevice] for the given protocol to the local machine. See [method UPNP.add_port_mapping].
*/
//go:nosplit
func (self class) AddPortMapping(port int64, port_internal int64, desc String.Readable, proto String.Readable, duration int64) int64 { //gd:UPNPDevice.add_port_mapping
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.add_port_mapping, gdextension.SizeInt|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeString<<12)|(gdextension.SizeString<<16)|(gdextension.SizeInt<<20), unsafe.Pointer(&struct {
		port          int64
		port_internal int64
		desc          gdextension.String
		proto         gdextension.String
		duration      int64
	}{port, port_internal, pointers.Get(gd.InternalString(desc)), pointers.Get(gd.InternalString(proto)), duration}))
	var ret = r_ret
	return ret
}

/*
Deletes the port mapping identified by the given port and protocol combination on this device. See [method UPNP.delete_port_mapping].
*/
//go:nosplit
func (self class) DeletePortMapping(port int64, proto String.Readable) int64 { //gd:UPNPDevice.delete_port_mapping
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.delete_port_mapping, gdextension.SizeInt|(gdextension.SizeInt<<4)|(gdextension.SizeString<<8), unsafe.Pointer(&struct {
		port  int64
		proto gdextension.String
	}{port, pointers.Get(gd.InternalString(proto))}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetDescriptionUrl(url String.Readable) { //gd:UPNPDevice.set_description_url
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_description_url, 0|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ url gdextension.String }{pointers.Get(gd.InternalString(url))}))
}

//go:nosplit
func (self class) GetDescriptionUrl() String.Readable { //gd:UPNPDevice.get_description_url
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_description_url, gdextension.SizeString, unsafe.Pointer(&struct{}{}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

//go:nosplit
func (self class) SetServiceType(atype String.Readable) { //gd:UPNPDevice.set_service_type
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_service_type, 0|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ atype gdextension.String }{pointers.Get(gd.InternalString(atype))}))
}

//go:nosplit
func (self class) GetServiceType() String.Readable { //gd:UPNPDevice.get_service_type
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_service_type, gdextension.SizeString, unsafe.Pointer(&struct{}{}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

//go:nosplit
func (self class) SetIgdControlUrl(url String.Readable) { //gd:UPNPDevice.set_igd_control_url
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_igd_control_url, 0|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ url gdextension.String }{pointers.Get(gd.InternalString(url))}))
}

//go:nosplit
func (self class) GetIgdControlUrl() String.Readable { //gd:UPNPDevice.get_igd_control_url
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_igd_control_url, gdextension.SizeString, unsafe.Pointer(&struct{}{}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

//go:nosplit
func (self class) SetIgdServiceType(atype String.Readable) { //gd:UPNPDevice.set_igd_service_type
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_igd_service_type, 0|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ atype gdextension.String }{pointers.Get(gd.InternalString(atype))}))
}

//go:nosplit
func (self class) GetIgdServiceType() String.Readable { //gd:UPNPDevice.get_igd_service_type
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_igd_service_type, gdextension.SizeString, unsafe.Pointer(&struct{}{}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

//go:nosplit
func (self class) SetIgdOurAddr(addr String.Readable) { //gd:UPNPDevice.set_igd_our_addr
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_igd_our_addr, 0|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ addr gdextension.String }{pointers.Get(gd.InternalString(addr))}))
}

//go:nosplit
func (self class) GetIgdOurAddr() String.Readable { //gd:UPNPDevice.get_igd_our_addr
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_igd_our_addr, gdextension.SizeString, unsafe.Pointer(&struct{}{}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

//go:nosplit
func (self class) SetIgdStatus(status IGDStatus) { //gd:UPNPDevice.set_igd_status
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_igd_status, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ status IGDStatus }{status}))
}

//go:nosplit
func (self class) GetIgdStatus() IGDStatus { //gd:UPNPDevice.get_igd_status
	var r_ret = gdextension.Call[IGDStatus](gd.ObjectChecked(self.AsObject()), methods.get_igd_status, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}
func (self class) AsUPNPDevice() Advanced         { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsUPNPDevice() Instance      { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsUPNPDevice() Instance { return self.Super().AsUPNPDevice() }
func (self class) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsRefCounted() [1]gd.RefCounted { return self.Super().AsRefCounted() }
func (self Instance) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(RefCounted.Advanced(self.AsRefCounted()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(RefCounted.Instance(self.AsRefCounted()), name)
	}
}
func init() {
	gdclass.Register("UPNPDevice", func(ptr gd.Object) any { return *(*Instance)(unsafe.Pointer(&ptr)) })
}

type IGDStatus int //gd:UPNPDevice.IGDStatus

const (
	/*OK.*/
	IgdStatusOk IGDStatus = 0
	/*HTTP error.*/
	IgdStatusHttpError IGDStatus = 1
	/*Empty HTTP response.*/
	IgdStatusHttpEmpty IGDStatus = 2
	/*Returned response contained no URLs.*/
	IgdStatusNoUrls IGDStatus = 3
	/*Not a valid IGD.*/
	IgdStatusNoIgd IGDStatus = 4
	/*Disconnected.*/
	IgdStatusDisconnected IGDStatus = 5
	/*Unknown device.*/
	IgdStatusUnknownDevice IGDStatus = 6
	/*Invalid control.*/
	IgdStatusInvalidControl IGDStatus = 7
	/*Memory allocation error.*/
	IgdStatusMallocError IGDStatus = 8
	/*Unknown error.*/
	IgdStatusUnknownError IGDStatus = 9
)
