// Code generated by the generate package DO NOT EDIT

// Package AnimationNode provides methods for working with AnimationNode object instances.
package AnimationNode

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdunsafe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/Animation"
import "graphics.gd/classdb/Resource"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = gdunsafe.Use{}
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
Base resource for [AnimationTree] nodes. In general, it's not used directly, but you can create custom ones with custom blending formulas.
Inherit this when creating animation nodes mainly for use in [AnimationNodeBlendTree], otherwise [AnimationRootNode] should be used instead.
You can access the time information as read-only parameter which is processed and stored in the previous frame for all nodes except [AnimationNodeOutput].
[b]Note:[/b] If multiple inputs exist in the [AnimationNode], which time information takes precedence depends on the type of [AnimationNode].
[codeblock]
var current_length = $AnimationTree[parameters/AnimationNodeName/current_length]
var current_position = $AnimationTree[parameters/AnimationNodeName/current_position]
var current_delta = $AnimationTree[parameters/AnimationNodeName/current_delta]
[/codeblock]

	See [Interface] for methods that can be overridden by a [Class] that extends it.
*/
type Instance [1]gdclass.AnimationNode

func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

type Expanded [1]gdclass.AnimationNode

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsAnimationNode() Instance
}
type Interface interface {
	//When inheriting from [AnimationRootNode], implement this virtual method to return all child animation nodes in order as a [code]name: node[/code] dictionary.
	GetChildNodes() map[any]any
	//When inheriting from [AnimationRootNode], implement this virtual method to return a list of the properties on this animation node. Parameters are custom local memory used for your animation nodes, given a resource can be reused in multiple trees. Format is similar to [method Object.get_property_list].
	GetParameterList() []any
	//When inheriting from [AnimationRootNode], implement this virtual method to return a child animation node by its [param name].
	GetChildByName(name string) Instance
	//When inheriting from [AnimationRootNode], implement this virtual method to return the default value of a [param parameter]. Parameters are custom local memory used for your animation nodes, given a resource can be reused in multiple trees.
	GetParameterDefaultValue(parameter string) any
	//When inheriting from [AnimationRootNode], implement this virtual method to return whether the [param parameter] is read-only. Parameters are custom local memory used for your animation nodes, given a resource can be reused in multiple trees.
	IsParameterReadOnly(parameter string) bool
	//When inheriting from [AnimationRootNode], implement this virtual method to run some code when this animation node is processed. The [param time] parameter is a relative delta, unless [param seek] is [code]true[/code], in which case it is absolute.
	//Here, call the [method blend_input], [method blend_node] or [method blend_animation] functions. You can also use [method get_parameter] and [method set_parameter] to modify local memory.
	//This function should return the delta.
	Process(time Float.X, seek bool, is_external_seeking bool, test_only bool) Float.X
	//When inheriting from [AnimationRootNode], implement this virtual method to override the text caption for this animation node.
	GetCaption() string
	//When inheriting from [AnimationRootNode], implement this virtual method to return whether the blend tree editor should display filter editing on this animation node.
	HasFilter() bool
}

// Implementation implements [Interface] with empty methods.
type Implementation = implementation

type implementation struct{}

func (self implementation) GetChildNodes() (_ map[any]any)                    { return }
func (self implementation) GetParameterList() (_ []any)                       { return }
func (self implementation) GetChildByName(name string) (_ Instance)           { return }
func (self implementation) GetParameterDefaultValue(parameter string) (_ any) { return }
func (self implementation) IsParameterReadOnly(parameter string) (_ bool)     { return }
func (self implementation) Process(time Float.X, seek bool, is_external_seeking bool, test_only bool) (_ Float.X) {
	return
}
func (self implementation) GetCaption() (_ string) { return }
func (self implementation) HasFilter() (_ bool)    { return }

/*
When inheriting from [AnimationRootNode], implement this virtual method to return all child animation nodes in order as a [code]name: node[/code] dictionary.
*/
func (Instance) _get_child_nodes(impl func(ptr unsafe.Pointer) map[any]any) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		ptr, ok := pointers.End(gd.InternalDictionary(gd.DictionaryFromMap(ret)))

		if !ok {
			return
		}
		gd.UnsafeSet(p_back, ptr)
	}
}

/*
When inheriting from [AnimationRootNode], implement this virtual method to return a list of the properties on this animation node. Parameters are custom local memory used for your animation nodes, given a resource can be reused in multiple trees. Format is similar to [method Object.get_property_list].
*/
func (Instance) _get_parameter_list(impl func(ptr unsafe.Pointer) []any) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		ptr, ok := pointers.End(gd.InternalArray(gd.EngineArrayFromSlice(ret)))

		if !ok {
			return
		}
		gd.UnsafeSet(p_back, ptr)
	}
}

/*
When inheriting from [AnimationRootNode], implement this virtual method to return a child animation node by its [param name].
*/
func (Instance) _get_child_by_name(impl func(ptr unsafe.Pointer, name string) Instance) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var name = String.Name(String.Via(gd.StringNameProxy{}, pointers.Pack(pointers.New[gd.StringName](gd.UnsafeGet[[1]gd.EnginePointer](p_args, 0)))))
		defer pointers.End(gd.InternalStringName(name))
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self, name.String())
		ptr, ok := pointers.End(ret[0])

		if !ok {
			return
		}
		gd.UnsafeSet(p_back, ptr)
	}
}

/*
When inheriting from [AnimationRootNode], implement this virtual method to return the default value of a [param parameter]. Parameters are custom local memory used for your animation nodes, given a resource can be reused in multiple trees.
*/
func (Instance) _get_parameter_default_value(impl func(ptr unsafe.Pointer, parameter string) any) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var parameter = String.Name(String.Via(gd.StringNameProxy{}, pointers.Pack(pointers.New[gd.StringName](gd.UnsafeGet[[1]gd.EnginePointer](p_args, 0)))))
		defer pointers.End(gd.InternalStringName(parameter))
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self, parameter.String())
		ptr, ok := pointers.End(gd.InternalVariant(variant.New(ret)))

		if !ok {
			return
		}
		gd.UnsafeSet(p_back, ptr)
	}
}

/*
When inheriting from [AnimationRootNode], implement this virtual method to return whether the [param parameter] is read-only. Parameters are custom local memory used for your animation nodes, given a resource can be reused in multiple trees.
*/
func (Instance) _is_parameter_read_only(impl func(ptr unsafe.Pointer, parameter string) bool) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var parameter = String.Name(String.Via(gd.StringNameProxy{}, pointers.Pack(pointers.New[gd.StringName](gd.UnsafeGet[[1]gd.EnginePointer](p_args, 0)))))
		defer pointers.End(gd.InternalStringName(parameter))
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self, parameter.String())
		gd.UnsafeSet(p_back, ret)
	}
}

/*
When inheriting from [AnimationRootNode], implement this virtual method to run some code when this animation node is processed. The [param time] parameter is a relative delta, unless [param seek] is [code]true[/code], in which case it is absolute.
Here, call the [method blend_input], [method blend_node] or [method blend_animation] functions. You can also use [method get_parameter] and [method set_parameter] to modify local memory.
This function should return the delta.
*/
func (Instance) _process(impl func(ptr unsafe.Pointer, time Float.X, seek bool, is_external_seeking bool, test_only bool) Float.X) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var time = gd.UnsafeGet[float64](p_args, 0)
		var seek = gd.UnsafeGet[bool](p_args, 1)
		var is_external_seeking = gd.UnsafeGet[bool](p_args, 2)
		var test_only = gd.UnsafeGet[bool](p_args, 3)
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self, Float.X(time), seek, is_external_seeking, test_only)
		gd.UnsafeSet(p_back, float64(ret))
	}
}

/*
When inheriting from [AnimationRootNode], implement this virtual method to override the text caption for this animation node.
*/
func (Instance) _get_caption(impl func(ptr unsafe.Pointer) string) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		ptr, ok := pointers.End(gd.InternalString(String.New(ret)))

		if !ok {
			return
		}
		gd.UnsafeSet(p_back, ptr)
	}
}

/*
When inheriting from [AnimationRootNode], implement this virtual method to return whether the blend tree editor should display filter editing on this animation node.
*/
func (Instance) _has_filter(impl func(ptr unsafe.Pointer) bool) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		gd.UnsafeSet(p_back, ret)
	}
}

/*
Adds an input to the animation node. This is only useful for animation nodes created for use in an [AnimationNodeBlendTree]. If the addition fails, returns [code]false[/code].
*/
func (self Instance) AddInput(name string) bool { //gd:AnimationNode.add_input
	return bool(Advanced(self).AddInput(String.New(name)))
}

/*
Removes an input, call this only when inactive.
*/
func (self Instance) RemoveInput(index int) { //gd:AnimationNode.remove_input
	Advanced(self).RemoveInput(int64(index))
}

/*
Sets the name of the input at the given [param input] index. If the setting fails, returns [code]false[/code].
*/
func (self Instance) SetInputName(input int, name string) bool { //gd:AnimationNode.set_input_name
	return bool(Advanced(self).SetInputName(int64(input), String.New(name)))
}

/*
Gets the name of an input by index.
*/
func (self Instance) GetInputName(input int) string { //gd:AnimationNode.get_input_name
	return string(Advanced(self).GetInputName(int64(input)).String())
}

/*
Amount of inputs in this animation node, only useful for animation nodes that go into [AnimationNodeBlendTree].
*/
func (self Instance) GetInputCount() int { //gd:AnimationNode.get_input_count
	return int(int(Advanced(self).GetInputCount()))
}

/*
Returns the input index which corresponds to [param name]. If not found, returns [code]-1[/code].
*/
func (self Instance) FindInput(name string) int { //gd:AnimationNode.find_input
	return int(int(Advanced(self).FindInput(String.New(name))))
}

/*
Adds or removes a path for the filter.
*/
func (self Instance) SetFilterPath(path string, enable bool) { //gd:AnimationNode.set_filter_path
	Advanced(self).SetFilterPath(Path.ToNode(String.New(path)), enable)
}

/*
Returns [code]true[/code] if the given path is filtered.
*/
func (self Instance) IsPathFiltered(path string) bool { //gd:AnimationNode.is_path_filtered
	return bool(Advanced(self).IsPathFiltered(Path.ToNode(String.New(path))))
}

/*
Returns the object id of the [AnimationTree] that owns this node.
[b]Note:[/b] This method should only be called from within the [method AnimationNodeExtension._process_animation_node] method, and will return an invalid id otherwise.
*/
func (self Instance) GetProcessingAnimationTreeInstanceId() int { //gd:AnimationNode.get_processing_animation_tree_instance_id
	return int(int(Advanced(self).GetProcessingAnimationTreeInstanceId()))
}

/*
Returns [code]true[/code] if this animation node is being processed in test-only mode.
*/
func (self Instance) IsProcessTesting() bool { //gd:AnimationNode.is_process_testing
	return bool(Advanced(self).IsProcessTesting())
}

/*
Blend an animation by [param blend] amount (name must be valid in the linked [AnimationPlayer]). A [param time] and [param delta] may be passed, as well as whether [param seeked] happened.
A [param looped_flag] is used by internal processing immediately after the loop. See also [enum Animation.LoopedFlag].
*/
func (self Instance) BlendAnimation(animation string, time Float.X, delta Float.X, seeked bool, is_external_seeking bool, blend Float.X) { //gd:AnimationNode.blend_animation
	Advanced(self).BlendAnimation(String.Name(String.New(animation)), float64(time), float64(delta), seeked, is_external_seeking, float64(blend), 0)
}

/*
Blend an animation by [param blend] amount (name must be valid in the linked [AnimationPlayer]). A [param time] and [param delta] may be passed, as well as whether [param seeked] happened.
A [param looped_flag] is used by internal processing immediately after the loop. See also [enum Animation.LoopedFlag].
*/
func (self Expanded) BlendAnimation(animation string, time Float.X, delta Float.X, seeked bool, is_external_seeking bool, blend Float.X, looped_flag Animation.LoopedFlag) { //gd:AnimationNode.blend_animation
	Advanced(self).BlendAnimation(String.Name(String.New(animation)), float64(time), float64(delta), seeked, is_external_seeking, float64(blend), looped_flag)
}

/*
Blend another animation node (in case this animation node contains child animation nodes). This function is only useful if you inherit from [AnimationRootNode] instead, otherwise editors will not display your animation node for addition.
*/
func (self Instance) BlendNode(name string, node Instance, time Float.X, seek bool, is_external_seeking bool, blend Float.X) Float.X { //gd:AnimationNode.blend_node
	return Float.X(Float.X(Advanced(self).BlendNode(String.Name(String.New(name)), node, float64(time), seek, is_external_seeking, float64(blend), 0, true, false)))
}

/*
Blend another animation node (in case this animation node contains child animation nodes). This function is only useful if you inherit from [AnimationRootNode] instead, otherwise editors will not display your animation node for addition.
*/
func (self Expanded) BlendNode(name string, node Instance, time Float.X, seek bool, is_external_seeking bool, blend Float.X, filter FilterAction, sync bool, test_only bool) Float.X { //gd:AnimationNode.blend_node
	return Float.X(Float.X(Advanced(self).BlendNode(String.Name(String.New(name)), node, float64(time), seek, is_external_seeking, float64(blend), filter, sync, test_only)))
}

/*
Blend an input. This is only useful for animation nodes created for an [AnimationNodeBlendTree]. The [param time] parameter is a relative delta, unless [param seek] is [code]true[/code], in which case it is absolute. A filter mode may be optionally passed (see [enum FilterAction] for options).
*/
func (self Instance) BlendInput(input_index int, time Float.X, seek bool, is_external_seeking bool, blend Float.X) Float.X { //gd:AnimationNode.blend_input
	return Float.X(Float.X(Advanced(self).BlendInput(int64(input_index), float64(time), seek, is_external_seeking, float64(blend), 0, true, false)))
}

/*
Blend an input. This is only useful for animation nodes created for an [AnimationNodeBlendTree]. The [param time] parameter is a relative delta, unless [param seek] is [code]true[/code], in which case it is absolute. A filter mode may be optionally passed (see [enum FilterAction] for options).
*/
func (self Expanded) BlendInput(input_index int, time Float.X, seek bool, is_external_seeking bool, blend Float.X, filter FilterAction, sync bool, test_only bool) Float.X { //gd:AnimationNode.blend_input
	return Float.X(Float.X(Advanced(self).BlendInput(int64(input_index), float64(time), seek, is_external_seeking, float64(blend), filter, sync, test_only)))
}

/*
Sets a custom parameter. These are used as local memory, because resources can be reused across the tree or scenes.
*/
func (self Instance) SetParameter(name string, value any) { //gd:AnimationNode.set_parameter
	Advanced(self).SetParameter(String.Name(String.New(name)), variant.New(value))
}

/*
Gets the value of a parameter. Parameters are custom local memory used for your animation nodes, given a resource can be reused in multiple trees.
*/
func (self Instance) GetParameter(name string) any { //gd:AnimationNode.get_parameter
	return any(Advanced(self).GetParameter(String.Name(String.New(name))).Interface())
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.AnimationNode

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {
	object := gd.Global.ClassDB.ConstructObject(gd.NewStringName("AnimationNode"))
	casted := Instance{*(*gdclass.AnimationNode)(unsafe.Pointer(&object))}
	casted.AsRefCounted()[0].Reference()
	return casted
}

func (self Instance) FilterEnabled() bool {
	return bool(class(self).IsFilterEnabled())
}

func (self Instance) SetFilterEnabled(value bool) {
	class(self).SetFilterEnabled(value)
}

/*
When inheriting from [AnimationRootNode], implement this virtual method to return all child animation nodes in order as a [code]name: node[/code] dictionary.
*/
func (class) _get_child_nodes(impl func(ptr unsafe.Pointer) Dictionary.Any) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		ptr, ok := pointers.End(gd.InternalDictionary(ret))

		if !ok {
			return
		}
		gd.UnsafeSet(p_back, ptr)
	}
}

/*
When inheriting from [AnimationRootNode], implement this virtual method to return a list of the properties on this animation node. Parameters are custom local memory used for your animation nodes, given a resource can be reused in multiple trees. Format is similar to [method Object.get_property_list].
*/
func (class) _get_parameter_list(impl func(ptr unsafe.Pointer) Array.Any) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		ptr, ok := pointers.End(gd.InternalArray(ret))

		if !ok {
			return
		}
		gd.UnsafeSet(p_back, ptr)
	}
}

/*
When inheriting from [AnimationRootNode], implement this virtual method to return a child animation node by its [param name].
*/
func (class) _get_child_by_name(impl func(ptr unsafe.Pointer, name String.Name) [1]gdclass.AnimationNode) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var name = String.Name(String.Via(gd.StringNameProxy{}, pointers.Pack(pointers.New[gd.StringName](gd.UnsafeGet[[1]gd.EnginePointer](p_args, 0)))))
		defer pointers.End(gd.InternalStringName(name))
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self, name)
		ptr, ok := pointers.End(ret[0])

		if !ok {
			return
		}
		gd.UnsafeSet(p_back, ptr)
	}
}

/*
When inheriting from [AnimationRootNode], implement this virtual method to return the default value of a [param parameter]. Parameters are custom local memory used for your animation nodes, given a resource can be reused in multiple trees.
*/
func (class) _get_parameter_default_value(impl func(ptr unsafe.Pointer, parameter String.Name) variant.Any) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var parameter = String.Name(String.Via(gd.StringNameProxy{}, pointers.Pack(pointers.New[gd.StringName](gd.UnsafeGet[[1]gd.EnginePointer](p_args, 0)))))
		defer pointers.End(gd.InternalStringName(parameter))
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self, parameter)
		ptr, ok := pointers.End(gd.InternalVariant(ret))

		if !ok {
			return
		}
		gd.UnsafeSet(p_back, ptr)
	}
}

/*
When inheriting from [AnimationRootNode], implement this virtual method to return whether the [param parameter] is read-only. Parameters are custom local memory used for your animation nodes, given a resource can be reused in multiple trees.
*/
func (class) _is_parameter_read_only(impl func(ptr unsafe.Pointer, parameter String.Name) bool) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var parameter = String.Name(String.Via(gd.StringNameProxy{}, pointers.Pack(pointers.New[gd.StringName](gd.UnsafeGet[[1]gd.EnginePointer](p_args, 0)))))
		defer pointers.End(gd.InternalStringName(parameter))
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self, parameter)
		gd.UnsafeSet(p_back, ret)
	}
}

/*
When inheriting from [AnimationRootNode], implement this virtual method to run some code when this animation node is processed. The [param time] parameter is a relative delta, unless [param seek] is [code]true[/code], in which case it is absolute.
Here, call the [method blend_input], [method blend_node] or [method blend_animation] functions. You can also use [method get_parameter] and [method set_parameter] to modify local memory.
This function should return the delta.
*/
func (class) _process(impl func(ptr unsafe.Pointer, time float64, seek bool, is_external_seeking bool, test_only bool) float64) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var time = gd.UnsafeGet[float64](p_args, 0)
		var seek = gd.UnsafeGet[bool](p_args, 1)
		var is_external_seeking = gd.UnsafeGet[bool](p_args, 2)
		var test_only = gd.UnsafeGet[bool](p_args, 3)
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self, time, seek, is_external_seeking, test_only)
		gd.UnsafeSet(p_back, ret)
	}
}

/*
When inheriting from [AnimationRootNode], implement this virtual method to override the text caption for this animation node.
*/
func (class) _get_caption(impl func(ptr unsafe.Pointer) String.Readable) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		ptr, ok := pointers.End(gd.InternalString(ret))

		if !ok {
			return
		}
		gd.UnsafeSet(p_back, ptr)
	}
}

/*
When inheriting from [AnimationRootNode], implement this virtual method to return whether the blend tree editor should display filter editing on this animation node.
*/
func (class) _has_filter(impl func(ptr unsafe.Pointer) bool) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		self := reflect.ValueOf(class).UnsafePointer()
		ret := impl(self)
		gd.UnsafeSet(p_back, ret)
	}
}

/*
Adds an input to the animation node. This is only useful for animation nodes created for use in an [AnimationNodeBlendTree]. If the addition fails, returns [code]false[/code].
*/
//go:nosplit
func (self class) AddInput(name String.Readable) bool { //gd:AnimationNode.add_input
	var r_ret = gdunsafe.Call[bool](self.AsObject(), gd.Global.Methods.AnimationNode.Bind_add_input, gdextension.SizeBool|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ name gdextension.String }{gdextension.String(pointers.Get(gd.InternalString(name))[0])}))
	var ret = r_ret
	return ret
}

/*
Removes an input, call this only when inactive.
*/
//go:nosplit
func (self class) RemoveInput(index int64) { //gd:AnimationNode.remove_input
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.AnimationNode.Bind_remove_input, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ index int64 }{index}))
}

/*
Sets the name of the input at the given [param input] index. If the setting fails, returns [code]false[/code].
*/
//go:nosplit
func (self class) SetInputName(input int64, name String.Readable) bool { //gd:AnimationNode.set_input_name
	var r_ret = gdunsafe.Call[bool](self.AsObject(), gd.Global.Methods.AnimationNode.Bind_set_input_name, gdextension.SizeBool|(gdextension.SizeInt<<4)|(gdextension.SizeString<<8), unsafe.Pointer(&struct {
		input int64
		name  gdextension.String
	}{input, gdextension.String(pointers.Get(gd.InternalString(name))[0])}))
	var ret = r_ret
	return ret
}

/*
Gets the name of an input by index.
*/
//go:nosplit
func (self class) GetInputName(input int64) String.Readable { //gd:AnimationNode.get_input_name
	var r_ret = gdunsafe.Call[[1]gd.EnginePointer](self.AsObject(), gd.Global.Methods.AnimationNode.Bind_get_input_name, gdextension.SizeString|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ input int64 }{input}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Amount of inputs in this animation node, only useful for animation nodes that go into [AnimationNodeBlendTree].
*/
//go:nosplit
func (self class) GetInputCount() int64 { //gd:AnimationNode.get_input_count
	var r_ret = gdunsafe.Call[int64](self.AsObject(), gd.Global.Methods.AnimationNode.Bind_get_input_count, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the input index which corresponds to [param name]. If not found, returns [code]-1[/code].
*/
//go:nosplit
func (self class) FindInput(name String.Readable) int64 { //gd:AnimationNode.find_input
	var r_ret = gdunsafe.Call[int64](self.AsObject(), gd.Global.Methods.AnimationNode.Bind_find_input, gdextension.SizeInt|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ name gdextension.String }{gdextension.String(pointers.Get(gd.InternalString(name))[0])}))
	var ret = r_ret
	return ret
}

/*
Adds or removes a path for the filter.
*/
//go:nosplit
func (self class) SetFilterPath(path Path.ToNode, enable bool) { //gd:AnimationNode.set_filter_path
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.AnimationNode.Bind_set_filter_path, 0|(gdextension.SizeNodePath<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		path   gdextension.NodePath
		enable bool
	}{gdextension.NodePath(pointers.Get(gd.InternalNodePath(path))[0]), enable}))
}

/*
Returns [code]true[/code] if the given path is filtered.
*/
//go:nosplit
func (self class) IsPathFiltered(path Path.ToNode) bool { //gd:AnimationNode.is_path_filtered
	var r_ret = gdunsafe.Call[bool](self.AsObject(), gd.Global.Methods.AnimationNode.Bind_is_path_filtered, gdextension.SizeBool|(gdextension.SizeNodePath<<4), unsafe.Pointer(&struct{ path gdextension.NodePath }{gdextension.NodePath(pointers.Get(gd.InternalNodePath(path))[0])}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetFilterEnabled(enable bool) { //gd:AnimationNode.set_filter_enabled
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.AnimationNode.Bind_set_filter_enabled, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

//go:nosplit
func (self class) IsFilterEnabled() bool { //gd:AnimationNode.is_filter_enabled
	var r_ret = gdunsafe.Call[bool](self.AsObject(), gd.Global.Methods.AnimationNode.Bind_is_filter_enabled, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the object id of the [AnimationTree] that owns this node.
[b]Note:[/b] This method should only be called from within the [method AnimationNodeExtension._process_animation_node] method, and will return an invalid id otherwise.
*/
//go:nosplit
func (self class) GetProcessingAnimationTreeInstanceId() int64 { //gd:AnimationNode.get_processing_animation_tree_instance_id
	var r_ret = gdunsafe.Call[int64](self.AsObject(), gd.Global.Methods.AnimationNode.Bind_get_processing_animation_tree_instance_id, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if this animation node is being processed in test-only mode.
*/
//go:nosplit
func (self class) IsProcessTesting() bool { //gd:AnimationNode.is_process_testing
	var r_ret = gdunsafe.Call[bool](self.AsObject(), gd.Global.Methods.AnimationNode.Bind_is_process_testing, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Blend an animation by [param blend] amount (name must be valid in the linked [AnimationPlayer]). A [param time] and [param delta] may be passed, as well as whether [param seeked] happened.
A [param looped_flag] is used by internal processing immediately after the loop. See also [enum Animation.LoopedFlag].
*/
//go:nosplit
func (self class) BlendAnimation(animation String.Name, time float64, delta float64, seeked bool, is_external_seeking bool, blend float64, looped_flag Animation.LoopedFlag) { //gd:AnimationNode.blend_animation
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.AnimationNode.Bind_blend_animation, 0|(gdextension.SizeStringName<<4)|(gdextension.SizeFloat<<8)|(gdextension.SizeFloat<<12)|(gdextension.SizeBool<<16)|(gdextension.SizeBool<<20)|(gdextension.SizeFloat<<24)|(gdextension.SizeInt<<28), unsafe.Pointer(&struct {
		animation           gdextension.StringName
		time                float64
		delta               float64
		seeked              bool
		is_external_seeking bool
		blend               float64
		looped_flag         Animation.LoopedFlag
	}{gdextension.StringName(pointers.Get(gd.InternalStringName(animation))[0]), time, delta, seeked, is_external_seeking, blend, looped_flag}))
}

/*
Blend another animation node (in case this animation node contains child animation nodes). This function is only useful if you inherit from [AnimationRootNode] instead, otherwise editors will not display your animation node for addition.
*/
//go:nosplit
func (self class) BlendNode(name String.Name, node [1]gdclass.AnimationNode, time float64, seek bool, is_external_seeking bool, blend float64, filter FilterAction, sync bool, test_only bool) float64 { //gd:AnimationNode.blend_node
	var r_ret = gdunsafe.Call[float64](self.AsObject(), gd.Global.Methods.AnimationNode.Bind_blend_node, gdextension.SizeFloat|(gdextension.SizeStringName<<4)|(gdextension.SizeObject<<8)|(gdextension.SizeFloat<<12)|(gdextension.SizeBool<<16)|(gdextension.SizeBool<<20)|(gdextension.SizeFloat<<24)|(gdextension.SizeInt<<28)|(gdextension.SizeBool<<32)|(gdextension.SizeBool<<36), unsafe.Pointer(&struct {
		name                gdextension.StringName
		node                gdextension.Object
		time                float64
		seek                bool
		is_external_seeking bool
		blend               float64
		filter              FilterAction
		sync                bool
		test_only           bool
	}{gdextension.StringName(pointers.Get(gd.InternalStringName(name))[0]), gdextension.Object(gd.ObjectChecked(node[0].AsObject())), time, seek, is_external_seeking, blend, filter, sync, test_only}))
	var ret = r_ret
	return ret
}

/*
Blend an input. This is only useful for animation nodes created for an [AnimationNodeBlendTree]. The [param time] parameter is a relative delta, unless [param seek] is [code]true[/code], in which case it is absolute. A filter mode may be optionally passed (see [enum FilterAction] for options).
*/
//go:nosplit
func (self class) BlendInput(input_index int64, time float64, seek bool, is_external_seeking bool, blend float64, filter FilterAction, sync bool, test_only bool) float64 { //gd:AnimationNode.blend_input
	var r_ret = gdunsafe.Call[float64](self.AsObject(), gd.Global.Methods.AnimationNode.Bind_blend_input, gdextension.SizeFloat|(gdextension.SizeInt<<4)|(gdextension.SizeFloat<<8)|(gdextension.SizeBool<<12)|(gdextension.SizeBool<<16)|(gdextension.SizeFloat<<20)|(gdextension.SizeInt<<24)|(gdextension.SizeBool<<28)|(gdextension.SizeBool<<32), unsafe.Pointer(&struct {
		input_index         int64
		time                float64
		seek                bool
		is_external_seeking bool
		blend               float64
		filter              FilterAction
		sync                bool
		test_only           bool
	}{input_index, time, seek, is_external_seeking, blend, filter, sync, test_only}))
	var ret = r_ret
	return ret
}

/*
Sets a custom parameter. These are used as local memory, because resources can be reused across the tree or scenes.
*/
//go:nosplit
func (self class) SetParameter(name String.Name, value variant.Any) { //gd:AnimationNode.set_parameter
	gdunsafe.Call[struct{}](self.AsObject(), gd.Global.Methods.AnimationNode.Bind_set_parameter, 0|(gdextension.SizeStringName<<4)|(gdextension.SizeVariant<<8), unsafe.Pointer(&struct {
		name  gdextension.StringName
		value gdextension.Variant
	}{gdextension.StringName(pointers.Get(gd.InternalStringName(name))[0]), gdextension.Variant(pointers.Get(gd.InternalVariant(value)))}))
}

/*
Gets the value of a parameter. Parameters are custom local memory used for your animation nodes, given a resource can be reused in multiple trees.
*/
//go:nosplit
func (self class) GetParameter(name String.Name) variant.Any { //gd:AnimationNode.get_parameter
	var r_ret = gdunsafe.Call[[3]uint64](self.AsObject(), gd.Global.Methods.AnimationNode.Bind_get_parameter, gdextension.SizeVariant|(gdextension.SizeStringName<<4), unsafe.Pointer(&struct{ name gdextension.StringName }{gdextension.StringName(pointers.Get(gd.InternalStringName(name))[0])}))
	var ret = variant.Implementation(gd.VariantProxy{}, pointers.Pack(pointers.New[gd.Variant](r_ret)))
	return ret
}
func (self Instance) OnTreeChanged(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("tree_changed"), gd.NewCallable(cb), 0)
}

func (self Instance) OnAnimationNodeRenamed(cb func(object_id int, old_name string, new_name string)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("animation_node_renamed"), gd.NewCallable(cb), 0)
}

func (self Instance) OnAnimationNodeRemoved(cb func(object_id int, name string)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("animation_node_removed"), gd.NewCallable(cb), 0)
}

func (self class) AsAnimationNode() Advanced         { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsAnimationNode() Instance      { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsAnimationNode() Instance { return self.Super().AsAnimationNode() }
func (self class) AsResource() Resource.Advanced {
	return *((*Resource.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsResource() Resource.Instance { return self.Super().AsResource() }
func (self Instance) AsResource() Resource.Instance {
	return *((*Resource.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsRefCounted() [1]gd.RefCounted { return self.Super().AsRefCounted() }
func (self Instance) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	case "_get_child_nodes":
		return reflect.ValueOf(self._get_child_nodes)
	case "_get_parameter_list":
		return reflect.ValueOf(self._get_parameter_list)
	case "_get_child_by_name":
		return reflect.ValueOf(self._get_child_by_name)
	case "_get_parameter_default_value":
		return reflect.ValueOf(self._get_parameter_default_value)
	case "_is_parameter_read_only":
		return reflect.ValueOf(self._is_parameter_read_only)
	case "_process":
		return reflect.ValueOf(self._process)
	case "_get_caption":
		return reflect.ValueOf(self._get_caption)
	case "_has_filter":
		return reflect.ValueOf(self._has_filter)
	default:
		return gd.VirtualByName(Resource.Advanced(self.AsResource()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	case "_get_child_nodes":
		return reflect.ValueOf(self._get_child_nodes)
	case "_get_parameter_list":
		return reflect.ValueOf(self._get_parameter_list)
	case "_get_child_by_name":
		return reflect.ValueOf(self._get_child_by_name)
	case "_get_parameter_default_value":
		return reflect.ValueOf(self._get_parameter_default_value)
	case "_is_parameter_read_only":
		return reflect.ValueOf(self._is_parameter_read_only)
	case "_process":
		return reflect.ValueOf(self._process)
	case "_get_caption":
		return reflect.ValueOf(self._get_caption)
	case "_has_filter":
		return reflect.ValueOf(self._has_filter)
	default:
		return gd.VirtualByName(Resource.Instance(self.AsResource()), name)
	}
}
func init() {
	gdclass.Register("AnimationNode", func(ptr gd.Object) any {
		return [1]gdclass.AnimationNode{*(*gdclass.AnimationNode)(unsafe.Pointer(&ptr))}
	})
}

type FilterAction int //gd:AnimationNode.FilterAction

const (
	/*Do not use filtering.*/
	FilterIgnore FilterAction = 0
	/*Paths matching the filter will be allowed to pass.*/
	FilterPass FilterAction = 1
	/*Paths matching the filter will be discarded.*/
	FilterStop FilterAction = 2
	/*Paths matching the filter will be blended (by the blend value).*/
	FilterBlend FilterAction = 3
)
