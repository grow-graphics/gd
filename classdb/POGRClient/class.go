// Code generated by the generate package DO NOT EDIT

// Package POGRClient provides methods for working with POGRClient object instances.
package POGRClient

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/BlaziumClient"
import "graphics.gd/classdb/Node"
import "graphics.gd/classdb/POGRResponse"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
The [POGRClient] node provides an interface for connecting to the POGR analytics service. Find out more on the [url=https://pogr.gg]pogr.gg[/url] website.
The normal flow is as follows:
1. Initiate a session using [method init] method.
2. Send data using [method data], [method event], [method logs], [method metrics] and [method monitor] methods, depending on use case.
3. Close the session using [method end] method at the end of the game.
[b]Note:[/b] All methods are non blocking and can be awaited in order to get the result.

For tags parameter, valid tags are:
[codeblocks]
[gdscript]
var valid_tags = ["steam_id", "twitch_id", "association_id", "pogr_game_session", "xbox_id", "battlenet_id", "twitter_id", "linkedin_id", "pogr_player_id", "discord_id", "override_timestamp"]
[/gdscript]
[/codeblocks]
*/
type Instance [1]gdclass.POGRClient

func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

type Expanded [1]gdclass.POGRClient

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsPOGRClient() Instance
}

/*
Send init request. Needs to be called first. Needs to have set before [member client_id] and [member build_id].
Returns a [POGRResponse] object that has a [signal POGRResponse.finished] signal that is emitted when finished.

[codeblocks]
[gdscript]
var res :POGRResult = await init().finished
if res.has_error():

	print(res.error)

[/gdscript]
[/codeblocks]
*/
func (self Instance) Init(association_id string) POGRResponse.Instance { //gd:POGRClient.init
	return POGRResponse.Instance(Advanced(self).Init(String.New(association_id)))
}

/*
Send end request. Call [method init] first.
Returns a [POGRResponse] object that has a [signal POGRResponse.finished] signal that is emitted when finished.

[codeblocks]
[gdscript]
var res :POGRResult = await end().finished
if res.has_error():

	print(res.error)

[/gdscript]
[/codeblocks]
*/
func (self Instance) End() POGRResponse.Instance { //gd:POGRClient.end
	return POGRResponse.Instance(Advanced(self).End())
}

/*
Send unstructured data. Call [method init] first.
Returns a [POGRResponse] object that has a [signal POGRResponse.finished] signal that is emitted when finished.

[codeblocks]
[gdscript]
var res :POGRResult = await data({"custom_data": "my_data"}).finished
if res.has_error():

	print(res.error)

[/gdscript]
[/codeblocks]
*/
func (self Instance) Data(tags map[any]any, data map[any]any) POGRResponse.Instance { //gd:POGRClient.data
	return POGRResponse.Instance(Advanced(self).Data(gd.DictionaryFromMap(tags), gd.DictionaryFromMap(data)))
}

/*
Send event with unstructured data. Call [method init] first.
Returns a [POGRResponse] object that has a [signal POGRResponse.finished] signal that is emitted when finished.

[codeblocks]
[gdscript]
var res :POGRResult = await event("combat", "enemy_killed", "attack", "completed", "user-event").finished
if res.has_error():

	print(res.error)

[/gdscript]
[/codeblocks]
*/
func (self Instance) Event(event_name string, sub_event string, event_key string, flag string) POGRResponse.Instance { //gd:POGRClient.event
	return POGRResponse.Instance(Advanced(self).Event(String.New(event_name), String.New(sub_event), String.New(event_key), String.New(flag), String.New("user-event"), Dictionary.Nil, Dictionary.Nil))
}

/*
Send event with unstructured data. Call [method init] first.
Returns a [POGRResponse] object that has a [signal POGRResponse.finished] signal that is emitted when finished.

[codeblocks]
[gdscript]
var res :POGRResult = await event("combat", "enemy_killed", "attack", "completed", "user-event").finished
if res.has_error():

	print(res.error)

[/gdscript]
[/codeblocks]
*/
func (self Expanded) Event(event_name string, sub_event string, event_key string, flag string, atype string, tags map[any]any, data map[any]any) POGRResponse.Instance { //gd:POGRClient.event
	return POGRResponse.Instance(Advanced(self).Event(String.New(event_name), String.New(sub_event), String.New(event_key), String.New(flag), String.New(atype), gd.DictionaryFromMap(tags), gd.DictionaryFromMap(data)))
}

/*
Add logs to the analytics. Call [method init] first.
Returns a [POGRResponse] object that has a [signal POGRResponse.finished] signal that is emitted when finished.

[codeblocks]
[gdscript]
var res :POGRResult = await logs("logs 123").finished
if res.has_error():

	print(res.error)

[/gdscript]
[/codeblocks]
*/
func (self Instance) Logs(log string) POGRResponse.Instance { //gd:POGRClient.logs
	return POGRResponse.Instance(Advanced(self).Logs(String.New(log), String.New("info"), String.New("dev"), String.New("gameclient"), String.New("user-event"), Dictionary.Nil, Dictionary.Nil))
}

/*
Add logs to the analytics. Call [method init] first.
Returns a [POGRResponse] object that has a [signal POGRResponse.finished] signal that is emitted when finished.

[codeblocks]
[gdscript]
var res :POGRResult = await logs("logs 123").finished
if res.has_error():

	print(res.error)

[/gdscript]
[/codeblocks]
*/
func (self Expanded) Logs(log string, severity string, environment string, service string, atype string, tags map[any]any, data map[any]any) POGRResponse.Instance { //gd:POGRClient.logs
	return POGRResponse.Instance(Advanced(self).Logs(String.New(log), String.New(severity), String.New(environment), String.New(service), String.New(atype), gd.DictionaryFromMap(tags), gd.DictionaryFromMap(data)))
}

/*
Add metrics to the analytics. Call [method init] first.
Returns a [POGRResponse] object that has a [signal POGRResponse.finished] signal that is emitted when finished.

[codeblocks]
[gdscript]
var res :POGRResult = await metrics({"FPS": Engine.get_frames_per_second()}).finished
if res.has_error():

	print(res.error)

[/gdscript]
[/codeblocks]
*/
func (self Instance) Metrics(metrics map[any]any) POGRResponse.Instance { //gd:POGRClient.metrics
	return POGRResponse.Instance(Advanced(self).Metrics(gd.DictionaryFromMap(metrics), String.New("dev"), String.New("gameclient"), Dictionary.Nil))
}

/*
Add metrics to the analytics. Call [method init] first.
Returns a [POGRResponse] object that has a [signal POGRResponse.finished] signal that is emitted when finished.

[codeblocks]
[gdscript]
var res :POGRResult = await metrics({"FPS": Engine.get_frames_per_second()}).finished
if res.has_error():

	print(res.error)

[/gdscript]
[/codeblocks]
*/
func (self Expanded) Metrics(metrics map[any]any, environment string, service string, tags map[any]any) POGRResponse.Instance { //gd:POGRClient.metrics
	return POGRResponse.Instance(Advanced(self).Metrics(gd.DictionaryFromMap(metrics), String.New(environment), String.New(service), gd.DictionaryFromMap(tags)))
}

/*
Send monitor request.
Returns a [POGRResponse] object that has a [signal POGRResponse.finished] signal that is emitted when finished.

[codeblocks]
[gdscript]
var res :POGRResult = await monitor({"my_setting": "test"}).finished
if res.has_error():

	print(res.error)

[/gdscript]
[/codeblocks]
*/
func (self Instance) Monitor(settings map[any]any) POGRResponse.Instance { //gd:POGRClient.monitor
	return POGRResponse.Instance(Advanced(self).Monitor(gd.DictionaryFromMap(settings)))
}

/*
Get the session id. This is a unique identifier for the current session generated after [method init] is called.
*/
func (self Instance) GetSessionId() string { //gd:POGRClient.get_session_id
	return string(Advanced(self).GetSessionId().String())
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.POGRClient

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {
	object := gd.Global.ClassDB.ConstructObject(gd.NewStringName("POGRClient"))
	casted := Instance{*(*gdclass.POGRClient)(unsafe.Pointer(&object))}
	return casted
}

func (self Instance) ClientId() string {
	return string(class(self).GetClientId().String())
}

func (self Instance) SetClientId(value string) {
	class(self).SetClientId(String.New(value))
}

func (self Instance) BuildId() string {
	return string(class(self).GetBuildId().String())
}

func (self Instance) SetBuildId(value string) {
	class(self).SetBuildId(String.New(value))
}

func (self Instance) PogrUrl() string {
	return string(class(self).GetPogrUrl().String())
}

func (self Instance) SetPogrUrl(value string) {
	class(self).SetPogrUrl(String.New(value))
}

/*
Send init request. Needs to be called first. Needs to have set before [member client_id] and [member build_id].
Returns a [POGRResponse] object that has a [signal POGRResponse.finished] signal that is emitted when finished.

[codeblocks]
[gdscript]
var res :POGRResult = await init().finished
if res.has_error():
    print(res.error)
[/gdscript]
[/codeblocks]
*/
//go:nosplit
func (self class) Init(association_id String.Readable) [1]gdclass.POGRResponse { //gd:POGRClient.init
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(association_id)))
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.POGRClient.Bind_init, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.POGRResponse{gd.PointerWithOwnershipTransferredToGo[gdclass.POGRResponse](r_ret.Get())}
	frame.Free()
	return ret
}

/*
Send end request. Call [method init] first.
Returns a [POGRResponse] object that has a [signal POGRResponse.finished] signal that is emitted when finished.

[codeblocks]
[gdscript]
var res :POGRResult = await end().finished
if res.has_error():
    print(res.error)
[/gdscript]
[/codeblocks]
*/
//go:nosplit
func (self class) End() [1]gdclass.POGRResponse { //gd:POGRClient.end
	var frame = callframe.New()
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.POGRClient.Bind_end, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.POGRResponse{gd.PointerWithOwnershipTransferredToGo[gdclass.POGRResponse](r_ret.Get())}
	frame.Free()
	return ret
}

/*
Send unstructured data. Call [method init] first.
Returns a [POGRResponse] object that has a [signal POGRResponse.finished] signal that is emitted when finished.

[codeblocks]
[gdscript]
var res :POGRResult = await data({"custom_data": "my_data"}).finished
if res.has_error():
    print(res.error)
[/gdscript]
[/codeblocks]
*/
//go:nosplit
func (self class) Data(tags Dictionary.Any, data Dictionary.Any) [1]gdclass.POGRResponse { //gd:POGRClient.data
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalDictionary(tags)))
	callframe.Arg(frame, pointers.Get(gd.InternalDictionary(data)))
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.POGRClient.Bind_data, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.POGRResponse{gd.PointerWithOwnershipTransferredToGo[gdclass.POGRResponse](r_ret.Get())}
	frame.Free()
	return ret
}

/*
Send event with unstructured data. Call [method init] first.
Returns a [POGRResponse] object that has a [signal POGRResponse.finished] signal that is emitted when finished.

[codeblocks]
[gdscript]
var res :POGRResult = await event("combat", "enemy_killed", "attack", "completed", "user-event").finished
if res.has_error():
    print(res.error)
[/gdscript]
[/codeblocks]
*/
//go:nosplit
func (self class) Event(event_name String.Readable, sub_event String.Readable, event_key String.Readable, flag String.Readable, atype String.Readable, tags Dictionary.Any, data Dictionary.Any) [1]gdclass.POGRResponse { //gd:POGRClient.event
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(event_name)))
	callframe.Arg(frame, pointers.Get(gd.InternalString(sub_event)))
	callframe.Arg(frame, pointers.Get(gd.InternalString(event_key)))
	callframe.Arg(frame, pointers.Get(gd.InternalString(flag)))
	callframe.Arg(frame, pointers.Get(gd.InternalString(atype)))
	callframe.Arg(frame, pointers.Get(gd.InternalDictionary(tags)))
	callframe.Arg(frame, pointers.Get(gd.InternalDictionary(data)))
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.POGRClient.Bind_event, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.POGRResponse{gd.PointerWithOwnershipTransferredToGo[gdclass.POGRResponse](r_ret.Get())}
	frame.Free()
	return ret
}

/*
Add logs to the analytics. Call [method init] first.
Returns a [POGRResponse] object that has a [signal POGRResponse.finished] signal that is emitted when finished.

[codeblocks]
[gdscript]
var res :POGRResult = await logs("logs 123").finished
if res.has_error():
    print(res.error)
[/gdscript]
[/codeblocks]
*/
//go:nosplit
func (self class) Logs(log String.Readable, severity String.Readable, environment String.Readable, service String.Readable, atype String.Readable, tags Dictionary.Any, data Dictionary.Any) [1]gdclass.POGRResponse { //gd:POGRClient.logs
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(log)))
	callframe.Arg(frame, pointers.Get(gd.InternalString(severity)))
	callframe.Arg(frame, pointers.Get(gd.InternalString(environment)))
	callframe.Arg(frame, pointers.Get(gd.InternalString(service)))
	callframe.Arg(frame, pointers.Get(gd.InternalString(atype)))
	callframe.Arg(frame, pointers.Get(gd.InternalDictionary(tags)))
	callframe.Arg(frame, pointers.Get(gd.InternalDictionary(data)))
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.POGRClient.Bind_logs, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.POGRResponse{gd.PointerWithOwnershipTransferredToGo[gdclass.POGRResponse](r_ret.Get())}
	frame.Free()
	return ret
}

/*
Add metrics to the analytics. Call [method init] first.
Returns a [POGRResponse] object that has a [signal POGRResponse.finished] signal that is emitted when finished.

[codeblocks]
[gdscript]
var res :POGRResult = await metrics({"FPS": Engine.get_frames_per_second()}).finished
if res.has_error():
    print(res.error)
[/gdscript]
[/codeblocks]
*/
//go:nosplit
func (self class) Metrics(metrics Dictionary.Any, environment String.Readable, service String.Readable, tags Dictionary.Any) [1]gdclass.POGRResponse { //gd:POGRClient.metrics
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalDictionary(metrics)))
	callframe.Arg(frame, pointers.Get(gd.InternalString(environment)))
	callframe.Arg(frame, pointers.Get(gd.InternalString(service)))
	callframe.Arg(frame, pointers.Get(gd.InternalDictionary(tags)))
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.POGRClient.Bind_metrics, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.POGRResponse{gd.PointerWithOwnershipTransferredToGo[gdclass.POGRResponse](r_ret.Get())}
	frame.Free()
	return ret
}

/*
Send monitor request.
Returns a [POGRResponse] object that has a [signal POGRResponse.finished] signal that is emitted when finished.

[codeblocks]
[gdscript]
var res :POGRResult = await monitor({"my_setting": "test"}).finished
if res.has_error():
    print(res.error)
[/gdscript]
[/codeblocks]
*/
//go:nosplit
func (self class) Monitor(settings Dictionary.Any) [1]gdclass.POGRResponse { //gd:POGRClient.monitor
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalDictionary(settings)))
	var r_ret = callframe.Ret[gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.POGRClient.Bind_monitor, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = [1]gdclass.POGRResponse{gd.PointerWithOwnershipTransferredToGo[gdclass.POGRResponse](r_ret.Get())}
	frame.Free()
	return ret
}

//go:nosplit
func (self class) GetClientId() String.Readable { //gd:POGRClient.get_client_id
	var frame = callframe.New()
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.POGRClient.Bind_get_client_id, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

//go:nosplit
func (self class) SetClientId(client_id String.Readable) { //gd:POGRClient.set_client_id
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(client_id)))
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.POGRClient.Bind_set_client_id, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) GetBuildId() String.Readable { //gd:POGRClient.get_build_id
	var frame = callframe.New()
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.POGRClient.Bind_get_build_id, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

//go:nosplit
func (self class) SetBuildId(build_id String.Readable) { //gd:POGRClient.set_build_id
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(build_id)))
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.POGRClient.Bind_set_build_id, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

//go:nosplit
func (self class) GetPogrUrl() String.Readable { //gd:POGRClient.get_pogr_url
	var frame = callframe.New()
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.POGRClient.Bind_get_pogr_url, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}

//go:nosplit
func (self class) SetPogrUrl(pogr_url String.Readable) { //gd:POGRClient.set_pogr_url
	var frame = callframe.New()
	callframe.Arg(frame, pointers.Get(gd.InternalString(pogr_url)))
	var r_ret = callframe.Nil
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.POGRClient.Bind_set_pogr_url, self.AsObject(), frame.Array(0), r_ret.Addr())
	frame.Free()
}

/*
Get the session id. This is a unique identifier for the current session generated after [method init] is called.
*/
//go:nosplit
func (self class) GetSessionId() String.Readable { //gd:POGRClient.get_session_id
	var frame = callframe.New()
	var r_ret = callframe.Ret[[1]gd.EnginePointer](frame)
	gd.Global.Object.MethodBindPointerCall(gd.Global.Methods.POGRClient.Bind_get_session_id, self.AsObject(), frame.Array(0), r_ret.Addr())
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret.Get())))
	frame.Free()
	return ret
}
func (self Instance) OnLogUpdated(cb func(command string, logs string)) {
	self[0].AsObject()[0].Connect(gd.NewStringName("log_updated"), gd.NewCallable(cb), 0)
}

func (self class) AsPOGRClient() Advanced         { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsPOGRClient() Instance      { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsPOGRClient() Instance { return self.Super().AsPOGRClient() }
func (self class) AsBlaziumClient() BlaziumClient.Advanced {
	return *((*BlaziumClient.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsBlaziumClient() BlaziumClient.Instance {
	return self.Super().AsBlaziumClient()
}
func (self Instance) AsBlaziumClient() BlaziumClient.Instance {
	return *((*BlaziumClient.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsNode() Node.Advanced         { return *((*Node.Advanced)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsNode() Node.Instance { return self.Super().AsNode() }
func (self Instance) AsNode() Node.Instance      { return *((*Node.Instance)(unsafe.Pointer(&self))) }

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(BlaziumClient.Advanced(self.AsBlaziumClient()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(BlaziumClient.Instance(self.AsBlaziumClient()), name)
	}
}
func init() {
	gdclass.Register("POGRClient", func(ptr gd.Object) any { return [1]gdclass.POGRClient{*(*gdclass.POGRClient)(unsafe.Pointer(&ptr))} })
}
