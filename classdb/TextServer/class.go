// Code generated by the generate package DO NOT EDIT

// Package TextServer provides methods for working with TextServer object instances.
package TextServer

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/GUI"
import "graphics.gd/classdb/Image"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Color"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/Rect2"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"
import "graphics.gd/variant/Transform2D"
import "graphics.gd/variant/Vector2"
import "graphics.gd/variant/Vector2i"
import "graphics.gd/variant/Vector3i"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
[TextServer] is the API backend for managing fonts and rendering text.
[b]Note:[/b] This is a low-level API, consider using [TextLine], [TextParagraph], and [Font] classes instead.
This is an abstract class, so to get the currently active [TextServer] instance, use the following code:
[codeblocks]
[gdscript]
var ts = TextServerManager.get_primary_interface()
[/gdscript]
[csharp]
var ts = TextServerManager.GetPrimaryInterface();
[/csharp]
[/codeblocks]
*/
type Instance [1]gdclass.TextServer

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	has_feature                                 gdextension.MethodForClass `hash:"3967367083"`
	get_name                                    gdextension.MethodForClass `hash:"201670096"`
	get_features                                gdextension.MethodForClass `hash:"3905245786"`
	load_support_data                           gdextension.MethodForClass `hash:"2323990056"`
	get_support_data_filename                   gdextension.MethodForClass `hash:"201670096"`
	get_support_data_info                       gdextension.MethodForClass `hash:"201670096"`
	save_support_data                           gdextension.MethodForClass `hash:"3927539163"`
	get_support_data                            gdextension.MethodForClass `hash:"2362200018"`
	is_locale_right_to_left                     gdextension.MethodForClass `hash:"3927539163"`
	name_to_tag                                 gdextension.MethodForClass `hash:"1321353865"`
	tag_to_name                                 gdextension.MethodForClass `hash:"844755477"`
	has                                         gdextension.MethodForClass `hash:"3521089500"`
	free_rid                                    gdextension.MethodForClass `hash:"2722037293"`
	create_font                                 gdextension.MethodForClass `hash:"529393457"`
	create_font_linked_variation                gdextension.MethodForClass `hash:"41030802"`
	font_set_data                               gdextension.MethodForClass `hash:"1355495400"`
	font_set_face_index                         gdextension.MethodForClass `hash:"3411492887"`
	font_get_face_index                         gdextension.MethodForClass `hash:"2198884583"`
	font_get_face_count                         gdextension.MethodForClass `hash:"2198884583"`
	font_set_style                              gdextension.MethodForClass `hash:"898466325"`
	font_get_style                              gdextension.MethodForClass `hash:"3082502592"`
	font_set_name                               gdextension.MethodForClass `hash:"2726140452"`
	font_get_name                               gdextension.MethodForClass `hash:"642473191"`
	font_get_ot_name_strings                    gdextension.MethodForClass `hash:"1882737106"`
	font_set_style_name                         gdextension.MethodForClass `hash:"2726140452"`
	font_get_style_name                         gdextension.MethodForClass `hash:"642473191"`
	font_set_weight                             gdextension.MethodForClass `hash:"3411492887"`
	font_get_weight                             gdextension.MethodForClass `hash:"2198884583"`
	font_set_stretch                            gdextension.MethodForClass `hash:"3411492887"`
	font_get_stretch                            gdextension.MethodForClass `hash:"2198884583"`
	font_set_antialiasing                       gdextension.MethodForClass `hash:"958337235"`
	font_get_antialiasing                       gdextension.MethodForClass `hash:"3389420495"`
	font_set_disable_embedded_bitmaps           gdextension.MethodForClass `hash:"1265174801"`
	font_get_disable_embedded_bitmaps           gdextension.MethodForClass `hash:"4155700596"`
	font_set_generate_mipmaps                   gdextension.MethodForClass `hash:"1265174801"`
	font_get_generate_mipmaps                   gdextension.MethodForClass `hash:"4155700596"`
	font_set_multichannel_signed_distance_field gdextension.MethodForClass `hash:"1265174801"`
	font_is_multichannel_signed_distance_field  gdextension.MethodForClass `hash:"4155700596"`
	font_set_msdf_pixel_range                   gdextension.MethodForClass `hash:"3411492887"`
	font_get_msdf_pixel_range                   gdextension.MethodForClass `hash:"2198884583"`
	font_set_msdf_size                          gdextension.MethodForClass `hash:"3411492887"`
	font_get_msdf_size                          gdextension.MethodForClass `hash:"2198884583"`
	font_set_fixed_size                         gdextension.MethodForClass `hash:"3411492887"`
	font_get_fixed_size                         gdextension.MethodForClass `hash:"2198884583"`
	font_set_fixed_size_scale_mode              gdextension.MethodForClass `hash:"1029390307"`
	font_get_fixed_size_scale_mode              gdextension.MethodForClass `hash:"4113120379"`
	font_set_allow_system_fallback              gdextension.MethodForClass `hash:"1265174801"`
	font_is_allow_system_fallback               gdextension.MethodForClass `hash:"4155700596"`
	font_set_force_autohinter                   gdextension.MethodForClass `hash:"1265174801"`
	font_is_force_autohinter                    gdextension.MethodForClass `hash:"4155700596"`
	font_set_hinting                            gdextension.MethodForClass `hash:"1520010864"`
	font_get_hinting                            gdextension.MethodForClass `hash:"3971592737"`
	font_set_subpixel_positioning               gdextension.MethodForClass `hash:"3830459669"`
	font_get_subpixel_positioning               gdextension.MethodForClass `hash:"2752233671"`
	font_set_keep_rounding_remainders           gdextension.MethodForClass `hash:"1265174801"`
	font_get_keep_rounding_remainders           gdextension.MethodForClass `hash:"4155700596"`
	font_set_embolden                           gdextension.MethodForClass `hash:"1794382983"`
	font_get_embolden                           gdextension.MethodForClass `hash:"866169185"`
	font_set_spacing                            gdextension.MethodForClass `hash:"1307259930"`
	font_get_spacing                            gdextension.MethodForClass `hash:"1213653558"`
	font_set_baseline_offset                    gdextension.MethodForClass `hash:"1794382983"`
	font_get_baseline_offset                    gdextension.MethodForClass `hash:"866169185"`
	font_set_transform                          gdextension.MethodForClass `hash:"1246044741"`
	font_get_transform                          gdextension.MethodForClass `hash:"213527486"`
	font_set_variation_coordinates              gdextension.MethodForClass `hash:"1217542888"`
	font_get_variation_coordinates              gdextension.MethodForClass `hash:"1882737106"`
	font_set_oversampling                       gdextension.MethodForClass `hash:"1794382983"`
	font_get_oversampling                       gdextension.MethodForClass `hash:"866169185"`
	font_get_size_cache_list                    gdextension.MethodForClass `hash:"2684255073"`
	font_clear_size_cache                       gdextension.MethodForClass `hash:"2722037293"`
	font_remove_size_cache                      gdextension.MethodForClass `hash:"2450610377"`
	font_set_ascent                             gdextension.MethodForClass `hash:"1892459533"`
	font_get_ascent                             gdextension.MethodForClass `hash:"755457166"`
	font_set_descent                            gdextension.MethodForClass `hash:"1892459533"`
	font_get_descent                            gdextension.MethodForClass `hash:"755457166"`
	font_set_underline_position                 gdextension.MethodForClass `hash:"1892459533"`
	font_get_underline_position                 gdextension.MethodForClass `hash:"755457166"`
	font_set_underline_thickness                gdextension.MethodForClass `hash:"1892459533"`
	font_get_underline_thickness                gdextension.MethodForClass `hash:"755457166"`
	font_set_scale                              gdextension.MethodForClass `hash:"1892459533"`
	font_get_scale                              gdextension.MethodForClass `hash:"755457166"`
	font_get_texture_count                      gdextension.MethodForClass `hash:"1311001310"`
	font_clear_textures                         gdextension.MethodForClass `hash:"2450610377"`
	font_remove_texture                         gdextension.MethodForClass `hash:"3810512262"`
	font_set_texture_image                      gdextension.MethodForClass `hash:"2354485091"`
	font_get_texture_image                      gdextension.MethodForClass `hash:"2451761155"`
	font_set_texture_offsets                    gdextension.MethodForClass `hash:"3005398047"`
	font_get_texture_offsets                    gdextension.MethodForClass `hash:"3420028887"`
	font_get_glyph_list                         gdextension.MethodForClass `hash:"46086620"`
	font_clear_glyphs                           gdextension.MethodForClass `hash:"2450610377"`
	font_remove_glyph                           gdextension.MethodForClass `hash:"3810512262"`
	font_get_glyph_advance                      gdextension.MethodForClass `hash:"2555689501"`
	font_set_glyph_advance                      gdextension.MethodForClass `hash:"3219397315"`
	font_get_glyph_offset                       gdextension.MethodForClass `hash:"513728628"`
	font_set_glyph_offset                       gdextension.MethodForClass `hash:"1812632090"`
	font_get_glyph_size                         gdextension.MethodForClass `hash:"513728628"`
	font_set_glyph_size                         gdextension.MethodForClass `hash:"1812632090"`
	font_get_glyph_uv_rect                      gdextension.MethodForClass `hash:"2274268786"`
	font_set_glyph_uv_rect                      gdextension.MethodForClass `hash:"1973324081"`
	font_get_glyph_texture_idx                  gdextension.MethodForClass `hash:"4292800474"`
	font_set_glyph_texture_idx                  gdextension.MethodForClass `hash:"4254580980"`
	font_get_glyph_texture_rid                  gdextension.MethodForClass `hash:"1451696141"`
	font_get_glyph_texture_size                 gdextension.MethodForClass `hash:"513728628"`
	font_get_glyph_contours                     gdextension.MethodForClass `hash:"2903964473"`
	font_get_kerning_list                       gdextension.MethodForClass `hash:"1778388067"`
	font_clear_kerning_map                      gdextension.MethodForClass `hash:"3411492887"`
	font_remove_kerning                         gdextension.MethodForClass `hash:"2141860016"`
	font_set_kerning                            gdextension.MethodForClass `hash:"3630965883"`
	font_get_kerning                            gdextension.MethodForClass `hash:"1019980169"`
	font_get_glyph_index                        gdextension.MethodForClass `hash:"1765635060"`
	font_get_char_from_glyph_index              gdextension.MethodForClass `hash:"2156738276"`
	font_has_char                               gdextension.MethodForClass `hash:"3120086654"`
	font_get_supported_chars                    gdextension.MethodForClass `hash:"642473191"`
	font_get_supported_glyphs                   gdextension.MethodForClass `hash:"788230395"`
	font_render_range                           gdextension.MethodForClass `hash:"4254580980"`
	font_render_glyph                           gdextension.MethodForClass `hash:"3810512262"`
	font_draw_glyph                             gdextension.MethodForClass `hash:"1339057948"`
	font_draw_glyph_outline                     gdextension.MethodForClass `hash:"2626165733"`
	font_is_language_supported                  gdextension.MethodForClass `hash:"3199320846"`
	font_set_language_support_override          gdextension.MethodForClass `hash:"2313957094"`
	font_get_language_support_override          gdextension.MethodForClass `hash:"2829184646"`
	font_remove_language_support_override       gdextension.MethodForClass `hash:"2726140452"`
	font_get_language_support_overrides         gdextension.MethodForClass `hash:"2801473409"`
	font_is_script_supported                    gdextension.MethodForClass `hash:"3199320846"`
	font_set_script_support_override            gdextension.MethodForClass `hash:"2313957094"`
	font_get_script_support_override            gdextension.MethodForClass `hash:"2829184646"`
	font_remove_script_support_override         gdextension.MethodForClass `hash:"2726140452"`
	font_get_script_support_overrides           gdextension.MethodForClass `hash:"2801473409"`
	font_set_opentype_feature_overrides         gdextension.MethodForClass `hash:"1217542888"`
	font_get_opentype_feature_overrides         gdextension.MethodForClass `hash:"1882737106"`
	font_supported_feature_list                 gdextension.MethodForClass `hash:"1882737106"`
	font_supported_variation_list               gdextension.MethodForClass `hash:"1882737106"`
	font_get_global_oversampling                gdextension.MethodForClass `hash:"1740695150"`
	font_set_global_oversampling                gdextension.MethodForClass `hash:"373806689"`
	get_hex_code_box_size                       gdextension.MethodForClass `hash:"3016396712"`
	draw_hex_code_box                           gdextension.MethodForClass `hash:"1602046441"`
	create_shaped_text                          gdextension.MethodForClass `hash:"1231398698"`
	shaped_text_clear                           gdextension.MethodForClass `hash:"2722037293"`
	shaped_text_set_direction                   gdextension.MethodForClass `hash:"1551430183"`
	shaped_text_get_direction                   gdextension.MethodForClass `hash:"3065904362"`
	shaped_text_get_inferred_direction          gdextension.MethodForClass `hash:"3065904362"`
	shaped_text_set_bidi_override               gdextension.MethodForClass `hash:"684822712"`
	shaped_text_set_custom_punctuation          gdextension.MethodForClass `hash:"2726140452"`
	shaped_text_get_custom_punctuation          gdextension.MethodForClass `hash:"642473191"`
	shaped_text_set_custom_ellipsis             gdextension.MethodForClass `hash:"3411492887"`
	shaped_text_get_custom_ellipsis             gdextension.MethodForClass `hash:"2198884583"`
	shaped_text_set_orientation                 gdextension.MethodForClass `hash:"3019609126"`
	shaped_text_get_orientation                 gdextension.MethodForClass `hash:"3142708106"`
	shaped_text_set_preserve_invalid            gdextension.MethodForClass `hash:"1265174801"`
	shaped_text_get_preserve_invalid            gdextension.MethodForClass `hash:"4155700596"`
	shaped_text_set_preserve_control            gdextension.MethodForClass `hash:"1265174801"`
	shaped_text_get_preserve_control            gdextension.MethodForClass `hash:"4155700596"`
	shaped_text_set_spacing                     gdextension.MethodForClass `hash:"1307259930"`
	shaped_text_get_spacing                     gdextension.MethodForClass `hash:"1213653558"`
	shaped_text_add_string                      gdextension.MethodForClass `hash:"623473029"`
	shaped_text_add_object                      gdextension.MethodForClass `hash:"3664424789"`
	shaped_text_resize_object                   gdextension.MethodForClass `hash:"790361552"`
	shaped_get_span_count                       gdextension.MethodForClass `hash:"2198884583"`
	shaped_get_span_meta                        gdextension.MethodForClass `hash:"4069510997"`
	shaped_get_span_embedded_object             gdextension.MethodForClass `hash:"4069510997"`
	shaped_set_span_update_font                 gdextension.MethodForClass `hash:"2022725822"`
	shaped_text_substr                          gdextension.MethodForClass `hash:"1937682086"`
	shaped_text_get_parent                      gdextension.MethodForClass `hash:"3814569979"`
	shaped_text_fit_to_width                    gdextension.MethodForClass `hash:"530670926"`
	shaped_text_tab_align                       gdextension.MethodForClass `hash:"1283669550"`
	shaped_text_shape                           gdextension.MethodForClass `hash:"3521089500"`
	shaped_text_is_ready                        gdextension.MethodForClass `hash:"4155700596"`
	shaped_text_has_visible_chars               gdextension.MethodForClass `hash:"4155700596"`
	shaped_text_get_glyphs                      gdextension.MethodForClass `hash:"2684255073"`
	shaped_text_sort_logical                    gdextension.MethodForClass `hash:"2670461153"`
	shaped_text_get_glyph_count                 gdextension.MethodForClass `hash:"2198884583"`
	shaped_text_get_range                       gdextension.MethodForClass `hash:"733700038"`
	shaped_text_get_line_breaks_adv             gdextension.MethodForClass `hash:"2376991424"`
	shaped_text_get_line_breaks                 gdextension.MethodForClass `hash:"2651359741"`
	shaped_text_get_word_breaks                 gdextension.MethodForClass `hash:"4099476853"`
	shaped_text_get_trim_pos                    gdextension.MethodForClass `hash:"2198884583"`
	shaped_text_get_ellipsis_pos                gdextension.MethodForClass `hash:"2198884583"`
	shaped_text_get_ellipsis_glyphs             gdextension.MethodForClass `hash:"2684255073"`
	shaped_text_get_ellipsis_glyph_count        gdextension.MethodForClass `hash:"2198884583"`
	shaped_text_overrun_trim_to_width           gdextension.MethodForClass `hash:"2723146520"`
	shaped_text_get_objects                     gdextension.MethodForClass `hash:"2684255073"`
	shaped_text_get_object_rect                 gdextension.MethodForClass `hash:"447978354"`
	shaped_text_get_object_range                gdextension.MethodForClass `hash:"2524675647"`
	shaped_text_get_object_glyph                gdextension.MethodForClass `hash:"1260085030"`
	shaped_text_get_size                        gdextension.MethodForClass `hash:"2440833711"`
	shaped_text_get_ascent                      gdextension.MethodForClass `hash:"866169185"`
	shaped_text_get_descent                     gdextension.MethodForClass `hash:"866169185"`
	shaped_text_get_width                       gdextension.MethodForClass `hash:"866169185"`
	shaped_text_get_underline_position          gdextension.MethodForClass `hash:"866169185"`
	shaped_text_get_underline_thickness         gdextension.MethodForClass `hash:"866169185"`
	shaped_text_get_carets                      gdextension.MethodForClass `hash:"1574219346"`
	shaped_text_get_selection                   gdextension.MethodForClass `hash:"3714187733"`
	shaped_text_hit_test_grapheme               gdextension.MethodForClass `hash:"3149310417"`
	shaped_text_hit_test_position               gdextension.MethodForClass `hash:"3149310417"`
	shaped_text_get_grapheme_bounds             gdextension.MethodForClass `hash:"2546185844"`
	shaped_text_next_grapheme_pos               gdextension.MethodForClass `hash:"1120910005"`
	shaped_text_prev_grapheme_pos               gdextension.MethodForClass `hash:"1120910005"`
	shaped_text_get_character_breaks            gdextension.MethodForClass `hash:"788230395"`
	shaped_text_next_character_pos              gdextension.MethodForClass `hash:"1120910005"`
	shaped_text_prev_character_pos              gdextension.MethodForClass `hash:"1120910005"`
	shaped_text_closest_character_pos           gdextension.MethodForClass `hash:"1120910005"`
	shaped_text_draw                            gdextension.MethodForClass `hash:"880389142"`
	shaped_text_draw_outline                    gdextension.MethodForClass `hash:"2559184194"`
	shaped_text_get_dominant_direction_in_range gdextension.MethodForClass `hash:"3326907668"`
	format_number                               gdextension.MethodForClass `hash:"2664628024"`
	parse_number                                gdextension.MethodForClass `hash:"2664628024"`
	percent_sign                                gdextension.MethodForClass `hash:"993269549"`
	string_get_word_breaks                      gdextension.MethodForClass `hash:"581857818"`
	string_get_character_breaks                 gdextension.MethodForClass `hash:"2333794773"`
	is_confusable                               gdextension.MethodForClass `hash:"1433197768"`
	spoof_check                                 gdextension.MethodForClass `hash:"3927539163"`
	strip_diacritics                            gdextension.MethodForClass `hash:"3135753539"`
	is_valid_identifier                         gdextension.MethodForClass `hash:"3927539163"`
	is_valid_letter                             gdextension.MethodForClass `hash:"1116898809"`
	string_to_upper                             gdextension.MethodForClass `hash:"2664628024"`
	string_to_lower                             gdextension.MethodForClass `hash:"2664628024"`
	string_to_title                             gdextension.MethodForClass `hash:"2664628024"`
	parse_structured_text                       gdextension.MethodForClass `hash:"3310685015"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("TextServer")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		gdextension.Free(gdextension.TypeStringName, &sname)
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

type Expanded [1]gdclass.TextServer

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsTextServer() Instance
}

/*
Returns [code]true[/code] if the server supports a feature.
*/
func (self Instance) HasFeature(feature Feature) bool { //gd:TextServer.has_feature
	return bool(Advanced(self).HasFeature(feature))
}

/*
Returns the name of the server interface.
*/
func (self Instance) GetName() string { //gd:TextServer.get_name
	return string(Advanced(self).GetName().String())
}

/*
Returns text server features, see [enum Feature].
*/
func (self Instance) GetFeatures() int { //gd:TextServer.get_features
	return int(int(Advanced(self).GetFeatures()))
}

/*
Loads optional TextServer database (e.g. ICU break iterators and dictionaries).
[b]Note:[/b] This function should be called before any other TextServer functions used, otherwise it won't have any effect.
*/
func (self Instance) LoadSupportData(filename string) bool { //gd:TextServer.load_support_data
	return bool(Advanced(self).LoadSupportData(String.New(filename)))
}

/*
Returns default TextServer database (e.g. ICU break iterators and dictionaries) filename.
*/
func (self Instance) GetSupportDataFilename() string { //gd:TextServer.get_support_data_filename
	return string(Advanced(self).GetSupportDataFilename().String())
}

/*
Returns TextServer database (e.g. ICU break iterators and dictionaries) description.
*/
func (self Instance) GetSupportDataInfo() string { //gd:TextServer.get_support_data_info
	return string(Advanced(self).GetSupportDataInfo().String())
}

/*
Saves optional TextServer database (e.g. ICU break iterators and dictionaries) to the file.
[b]Note:[/b] This function is used by during project export, to include TextServer database.
*/
func (self Instance) SaveSupportData(filename string) bool { //gd:TextServer.save_support_data
	return bool(Advanced(self).SaveSupportData(String.New(filename)))
}

/*
Returns default TextServer database (e.g. ICU break iterators and dictionaries).
*/
func (self Instance) GetSupportData() []byte { //gd:TextServer.get_support_data
	return []byte(Advanced(self).GetSupportData().Bytes())
}

/*
Returns [code]true[/code] if locale is right-to-left.
*/
func (self Instance) IsLocaleRightToLeft(locale string) bool { //gd:TextServer.is_locale_right_to_left
	return bool(Advanced(self).IsLocaleRightToLeft(String.New(locale)))
}

/*
Converts readable feature, variation, script, or language name to OpenType tag.
*/
func (self Instance) NameToTag(name string) int { //gd:TextServer.name_to_tag
	return int(int(Advanced(self).NameToTag(String.New(name))))
}

/*
Converts OpenType tag to readable feature, variation, script, or language name.
*/
func (self Instance) TagToName(tag int) string { //gd:TextServer.tag_to_name
	return string(Advanced(self).TagToName(int64(tag)).String())
}

/*
Returns [code]true[/code] if [param rid] is valid resource owned by this text server.
*/
func (self Instance) Has(rid RID.Any) bool { //gd:TextServer.has
	return bool(Advanced(self).Has(RID.Any(rid)))
}

/*
Frees an object created by this [TextServer].
*/
func (self Instance) FreeRid(rid RID.Any) { //gd:TextServer.free_rid
	Advanced(self).FreeRid(RID.Any(rid))
}

/*
Creates a new, empty font cache entry resource. To free the resulting resource, use the [method free_rid] method.
*/
func (self Instance) CreateFont() RID.Font { //gd:TextServer.create_font
	return RID.Font(Advanced(self).CreateFont())
}

/*
Creates a new variation existing font which is reusing the same glyph cache and font data. To free the resulting resource, use the [method free_rid] method.
*/
func (self Instance) CreateFontLinkedVariation(font_rid RID.Font) RID.Font { //gd:TextServer.create_font_linked_variation
	return RID.Font(Advanced(self).CreateFontLinkedVariation(RID.Any(font_rid)))
}

/*
Sets font source data, e.g contents of the dynamic font source file.
*/
func (self Instance) FontSetData(font_rid RID.Font, data []byte) { //gd:TextServer.font_set_data
	Advanced(self).FontSetData(RID.Any(font_rid), Packed.Bytes(Packed.New(data...)))
}

/*
Sets an active face index in the TrueType / OpenType collection.
*/
func (self Instance) FontSetFaceIndex(font_rid RID.Font, face_index int) { //gd:TextServer.font_set_face_index
	Advanced(self).FontSetFaceIndex(RID.Any(font_rid), int64(face_index))
}

/*
Returns an active face index in the TrueType / OpenType collection.
*/
func (self Instance) FontGetFaceIndex(font_rid RID.Font) int { //gd:TextServer.font_get_face_index
	return int(int(Advanced(self).FontGetFaceIndex(RID.Any(font_rid))))
}

/*
Returns number of faces in the TrueType / OpenType collection.
*/
func (self Instance) FontGetFaceCount(font_rid RID.Font) int { //gd:TextServer.font_get_face_count
	return int(int(Advanced(self).FontGetFaceCount(RID.Any(font_rid))))
}

/*
Sets the font style flags, see [enum FontStyle].
[b]Note:[/b] This value is used for font matching only and will not affect font rendering. Use [method font_set_face_index], [method font_set_variation_coordinates], [method font_set_embolden], or [method font_set_transform] instead.
*/
func (self Instance) FontSetStyle(font_rid RID.Font, style FontStyle) { //gd:TextServer.font_set_style
	Advanced(self).FontSetStyle(RID.Any(font_rid), style)
}

/*
Returns font style flags, see [enum FontStyle].
*/
func (self Instance) FontGetStyle(font_rid RID.Font) FontStyle { //gd:TextServer.font_get_style
	return FontStyle(Advanced(self).FontGetStyle(RID.Any(font_rid)))
}

/*
Sets the font family name.
*/
func (self Instance) FontSetName(font_rid RID.Font, name string) { //gd:TextServer.font_set_name
	Advanced(self).FontSetName(RID.Any(font_rid), String.New(name))
}

/*
Returns font family name.
*/
func (self Instance) FontGetName(font_rid RID.Font) string { //gd:TextServer.font_get_name
	return string(Advanced(self).FontGetName(RID.Any(font_rid)).String())
}

/*
Returns [Dictionary] with OpenType font name strings (localized font names, version, description, license information, sample text, etc.).
*/
func (self Instance) FontGetOtNameStrings(font_rid RID.Font) map[string]string { //gd:TextServer.font_get_ot_name_strings
	return map[string]string(gd.DictionaryAs[map[string]string](Advanced(self).FontGetOtNameStrings(RID.Any(font_rid))))
}

/*
Sets the font style name.
*/
func (self Instance) FontSetStyleName(font_rid RID.Font, name string) { //gd:TextServer.font_set_style_name
	Advanced(self).FontSetStyleName(RID.Any(font_rid), String.New(name))
}

/*
Returns font style name.
*/
func (self Instance) FontGetStyleName(font_rid RID.Font) string { //gd:TextServer.font_get_style_name
	return string(Advanced(self).FontGetStyleName(RID.Any(font_rid)).String())
}

/*
Sets weight (boldness) of the font. A value in the [code]100...999[/code] range, normal font weight is [code]400[/code], bold font weight is [code]700[/code].
[b]Note:[/b] This value is used for font matching only and will not affect font rendering. Use [method font_set_face_index], [method font_set_variation_coordinates], or [method font_set_embolden] instead.
*/
func (self Instance) FontSetWeight(font_rid RID.Font, weight int) { //gd:TextServer.font_set_weight
	Advanced(self).FontSetWeight(RID.Any(font_rid), int64(weight))
}

/*
Returns weight (boldness) of the font. A value in the [code]100...999[/code] range, normal font weight is [code]400[/code], bold font weight is [code]700[/code].
*/
func (self Instance) FontGetWeight(font_rid RID.Font) int { //gd:TextServer.font_get_weight
	return int(int(Advanced(self).FontGetWeight(RID.Any(font_rid))))
}

/*
Sets font stretch amount, compared to a normal width. A percentage value between [code]50%[/code] and [code]200%[/code].
[b]Note:[/b] This value is used for font matching only and will not affect font rendering. Use [method font_set_face_index], [method font_set_variation_coordinates], or [method font_set_transform] instead.
*/
func (self Instance) FontSetStretch(font_rid RID.Font, weight int) { //gd:TextServer.font_set_stretch
	Advanced(self).FontSetStretch(RID.Any(font_rid), int64(weight))
}

/*
Returns font stretch amount, compared to a normal width. A percentage value between [code]50%[/code] and [code]200%[/code].
*/
func (self Instance) FontGetStretch(font_rid RID.Font) int { //gd:TextServer.font_get_stretch
	return int(int(Advanced(self).FontGetStretch(RID.Any(font_rid))))
}

/*
Sets font anti-aliasing mode.
*/
func (self Instance) FontSetAntialiasing(font_rid RID.Font, antialiasing FontAntialiasing) { //gd:TextServer.font_set_antialiasing
	Advanced(self).FontSetAntialiasing(RID.Any(font_rid), antialiasing)
}

/*
Returns font anti-aliasing mode.
*/
func (self Instance) FontGetAntialiasing(font_rid RID.Font) FontAntialiasing { //gd:TextServer.font_get_antialiasing
	return FontAntialiasing(Advanced(self).FontGetAntialiasing(RID.Any(font_rid)))
}

/*
If set to [code]true[/code], embedded font bitmap loading is disabled (bitmap-only and color fonts ignore this property).
*/
func (self Instance) FontSetDisableEmbeddedBitmaps(font_rid RID.Font, disable_embedded_bitmaps bool) { //gd:TextServer.font_set_disable_embedded_bitmaps
	Advanced(self).FontSetDisableEmbeddedBitmaps(RID.Any(font_rid), disable_embedded_bitmaps)
}

/*
Returns whether the font's embedded bitmap loading is disabled.
*/
func (self Instance) FontGetDisableEmbeddedBitmaps(font_rid RID.Font) bool { //gd:TextServer.font_get_disable_embedded_bitmaps
	return bool(Advanced(self).FontGetDisableEmbeddedBitmaps(RID.Any(font_rid)))
}

/*
If set to [code]true[/code] font texture mipmap generation is enabled.
*/
func (self Instance) FontSetGenerateMipmaps(font_rid RID.Font, generate_mipmaps bool) { //gd:TextServer.font_set_generate_mipmaps
	Advanced(self).FontSetGenerateMipmaps(RID.Any(font_rid), generate_mipmaps)
}

/*
Returns [code]true[/code] if font texture mipmap generation is enabled.
*/
func (self Instance) FontGetGenerateMipmaps(font_rid RID.Font) bool { //gd:TextServer.font_get_generate_mipmaps
	return bool(Advanced(self).FontGetGenerateMipmaps(RID.Any(font_rid)))
}

/*
If set to [code]true[/code], glyphs of all sizes are rendered using single multichannel signed distance field generated from the dynamic font vector data. MSDF rendering allows displaying the font at any scaling factor without blurriness, and without incurring a CPU cost when the font size changes (since the font no longer needs to be rasterized on the CPU). As a downside, font hinting is not available with MSDF. The lack of font hinting may result in less crisp and less readable fonts at small sizes.
[b]Note:[/b] MSDF font rendering does not render glyphs with overlapping shapes correctly. Overlapping shapes are not valid per the OpenType standard, but are still commonly found in many font files, especially those converted by Google Fonts. To avoid issues with overlapping glyphs, consider downloading the font file directly from the type foundry instead of relying on Google Fonts.
*/
func (self Instance) FontSetMultichannelSignedDistanceField(font_rid RID.Font, msdf bool) { //gd:TextServer.font_set_multichannel_signed_distance_field
	Advanced(self).FontSetMultichannelSignedDistanceField(RID.Any(font_rid), msdf)
}

/*
Returns [code]true[/code] if glyphs of all sizes are rendered using single multichannel signed distance field generated from the dynamic font vector data.
*/
func (self Instance) FontIsMultichannelSignedDistanceField(font_rid RID.Font) bool { //gd:TextServer.font_is_multichannel_signed_distance_field
	return bool(Advanced(self).FontIsMultichannelSignedDistanceField(RID.Any(font_rid)))
}

/*
Sets the width of the range around the shape between the minimum and maximum representable signed distance.
*/
func (self Instance) FontSetMsdfPixelRange(font_rid RID.Font, msdf_pixel_range int) { //gd:TextServer.font_set_msdf_pixel_range
	Advanced(self).FontSetMsdfPixelRange(RID.Any(font_rid), int64(msdf_pixel_range))
}

/*
Returns the width of the range around the shape between the minimum and maximum representable signed distance.
*/
func (self Instance) FontGetMsdfPixelRange(font_rid RID.Font) int { //gd:TextServer.font_get_msdf_pixel_range
	return int(int(Advanced(self).FontGetMsdfPixelRange(RID.Any(font_rid))))
}

/*
Sets source font size used to generate MSDF textures.
*/
func (self Instance) FontSetMsdfSize(font_rid RID.Font, msdf_size int) { //gd:TextServer.font_set_msdf_size
	Advanced(self).FontSetMsdfSize(RID.Any(font_rid), int64(msdf_size))
}

/*
Returns source font size used to generate MSDF textures.
*/
func (self Instance) FontGetMsdfSize(font_rid RID.Font) int { //gd:TextServer.font_get_msdf_size
	return int(int(Advanced(self).FontGetMsdfSize(RID.Any(font_rid))))
}

/*
Sets bitmap font fixed size. If set to value greater than zero, same cache entry will be used for all font sizes.
*/
func (self Instance) FontSetFixedSize(font_rid RID.Font, fixed_size int) { //gd:TextServer.font_set_fixed_size
	Advanced(self).FontSetFixedSize(RID.Any(font_rid), int64(fixed_size))
}

/*
Returns bitmap font fixed size.
*/
func (self Instance) FontGetFixedSize(font_rid RID.Font) int { //gd:TextServer.font_get_fixed_size
	return int(int(Advanced(self).FontGetFixedSize(RID.Any(font_rid))))
}

/*
Sets bitmap font scaling mode. This property is used only if [code]fixed_size[/code] is greater than zero.
*/
func (self Instance) FontSetFixedSizeScaleMode(font_rid RID.Font, fixed_size_scale_mode FixedSizeScaleMode) { //gd:TextServer.font_set_fixed_size_scale_mode
	Advanced(self).FontSetFixedSizeScaleMode(RID.Any(font_rid), fixed_size_scale_mode)
}

/*
Returns bitmap font scaling mode.
*/
func (self Instance) FontGetFixedSizeScaleMode(font_rid RID.Font) FixedSizeScaleMode { //gd:TextServer.font_get_fixed_size_scale_mode
	return FixedSizeScaleMode(Advanced(self).FontGetFixedSizeScaleMode(RID.Any(font_rid)))
}

/*
If set to [code]true[/code], system fonts can be automatically used as fallbacks.
*/
func (self Instance) FontSetAllowSystemFallback(font_rid RID.Font, allow_system_fallback bool) { //gd:TextServer.font_set_allow_system_fallback
	Advanced(self).FontSetAllowSystemFallback(RID.Any(font_rid), allow_system_fallback)
}

/*
Returns [code]true[/code] if system fonts can be automatically used as fallbacks.
*/
func (self Instance) FontIsAllowSystemFallback(font_rid RID.Font) bool { //gd:TextServer.font_is_allow_system_fallback
	return bool(Advanced(self).FontIsAllowSystemFallback(RID.Any(font_rid)))
}

/*
If set to [code]true[/code] auto-hinting is preferred over font built-in hinting.
*/
func (self Instance) FontSetForceAutohinter(font_rid RID.Font, force_autohinter bool) { //gd:TextServer.font_set_force_autohinter
	Advanced(self).FontSetForceAutohinter(RID.Any(font_rid), force_autohinter)
}

/*
Returns [code]true[/code] if auto-hinting is supported and preferred over font built-in hinting. Used by dynamic fonts only.
*/
func (self Instance) FontIsForceAutohinter(font_rid RID.Font) bool { //gd:TextServer.font_is_force_autohinter
	return bool(Advanced(self).FontIsForceAutohinter(RID.Any(font_rid)))
}

/*
Sets font hinting mode. Used by dynamic fonts only.
*/
func (self Instance) FontSetHinting(font_rid RID.Font, hinting Hinting) { //gd:TextServer.font_set_hinting
	Advanced(self).FontSetHinting(RID.Any(font_rid), hinting)
}

/*
Returns the font hinting mode. Used by dynamic fonts only.
*/
func (self Instance) FontGetHinting(font_rid RID.Font) Hinting { //gd:TextServer.font_get_hinting
	return Hinting(Advanced(self).FontGetHinting(RID.Any(font_rid)))
}

/*
Sets font subpixel glyph positioning mode.
*/
func (self Instance) FontSetSubpixelPositioning(font_rid RID.Font, subpixel_positioning SubpixelPositioning) { //gd:TextServer.font_set_subpixel_positioning
	Advanced(self).FontSetSubpixelPositioning(RID.Any(font_rid), subpixel_positioning)
}

/*
Returns font subpixel glyph positioning mode.
*/
func (self Instance) FontGetSubpixelPositioning(font_rid RID.Font) SubpixelPositioning { //gd:TextServer.font_get_subpixel_positioning
	return SubpixelPositioning(Advanced(self).FontGetSubpixelPositioning(RID.Any(font_rid)))
}

/*
Sets glyph position rounding behavior. If set to [code]true[/code], when aligning glyphs to the pixel boundaries rounding remainders are accumulated to ensure more uniform glyph distribution. This setting has no effect if subpixel positioning is enabled.
*/
func (self Instance) FontSetKeepRoundingRemainders(font_rid RID.Font, keep_rounding_remainders bool) { //gd:TextServer.font_set_keep_rounding_remainders
	Advanced(self).FontSetKeepRoundingRemainders(RID.Any(font_rid), keep_rounding_remainders)
}

/*
Returns glyph position rounding behavior. If set to [code]true[/code], when aligning glyphs to the pixel boundaries rounding remainders are accumulated to ensure more uniform glyph distribution. This setting has no effect if subpixel positioning is enabled.
*/
func (self Instance) FontGetKeepRoundingRemainders(font_rid RID.Font) bool { //gd:TextServer.font_get_keep_rounding_remainders
	return bool(Advanced(self).FontGetKeepRoundingRemainders(RID.Any(font_rid)))
}

/*
Sets font embolden strength. If [param strength] is not equal to zero, emboldens the font outlines. Negative values reduce the outline thickness.
*/
func (self Instance) FontSetEmbolden(font_rid RID.Font, strength Float.X) { //gd:TextServer.font_set_embolden
	Advanced(self).FontSetEmbolden(RID.Any(font_rid), float64(strength))
}

/*
Returns font embolden strength.
*/
func (self Instance) FontGetEmbolden(font_rid RID.Font) Float.X { //gd:TextServer.font_get_embolden
	return Float.X(Float.X(Advanced(self).FontGetEmbolden(RID.Any(font_rid))))
}

/*
Sets the spacing for [param spacing] (see [enum TextServer.SpacingType]) to [param value] in pixels (not relative to the font size).
*/
func (self Instance) FontSetSpacing(font_rid RID.Font, spacing SpacingType, value int) { //gd:TextServer.font_set_spacing
	Advanced(self).FontSetSpacing(RID.Any(font_rid), spacing, int64(value))
}

/*
Returns the spacing for [param spacing] (see [enum TextServer.SpacingType]) in pixels (not relative to the font size).
*/
func (self Instance) FontGetSpacing(font_rid RID.Font, spacing SpacingType) int { //gd:TextServer.font_get_spacing
	return int(int(Advanced(self).FontGetSpacing(RID.Any(font_rid), spacing)))
}

/*
Sets extra baseline offset (as a fraction of font height).
*/
func (self Instance) FontSetBaselineOffset(font_rid RID.Font, baseline_offset Float.X) { //gd:TextServer.font_set_baseline_offset
	Advanced(self).FontSetBaselineOffset(RID.Any(font_rid), float64(baseline_offset))
}

/*
Returns extra baseline offset (as a fraction of font height).
*/
func (self Instance) FontGetBaselineOffset(font_rid RID.Font) Float.X { //gd:TextServer.font_get_baseline_offset
	return Float.X(Float.X(Advanced(self).FontGetBaselineOffset(RID.Any(font_rid))))
}

/*
Sets 2D transform, applied to the font outlines, can be used for slanting, flipping, and rotating glyphs.
For example, to simulate italic typeface by slanting, apply the following transform [code]Transform2D(1.0, slant, 0.0, 1.0, 0.0, 0.0)[/code].
*/
func (self Instance) FontSetTransform(font_rid RID.Font, transform Transform2D.OriginXY) { //gd:TextServer.font_set_transform
	Advanced(self).FontSetTransform(RID.Any(font_rid), Transform2D.OriginXY(transform))
}

/*
Returns 2D transform applied to the font outlines.
*/
func (self Instance) FontGetTransform(font_rid RID.Font) Transform2D.OriginXY { //gd:TextServer.font_get_transform
	return Transform2D.OriginXY(Advanced(self).FontGetTransform(RID.Any(font_rid)))
}

/*
Sets variation coordinates for the specified font cache entry. See [method font_supported_variation_list] for more info.
*/
func (self Instance) FontSetVariationCoordinates(font_rid RID.Font, variation_coordinates map[string]float32) { //gd:TextServer.font_set_variation_coordinates
	Advanced(self).FontSetVariationCoordinates(RID.Any(font_rid), gd.DictionaryFromMap(variation_coordinates))
}

/*
Returns variation coordinates for the specified font cache entry. See [method font_supported_variation_list] for more info.
*/
func (self Instance) FontGetVariationCoordinates(font_rid RID.Font) map[string]float32 { //gd:TextServer.font_get_variation_coordinates
	return map[string]float32(gd.DictionaryAs[map[string]float32](Advanced(self).FontGetVariationCoordinates(RID.Any(font_rid))))
}

/*
Sets font oversampling factor, if set to [code]0.0[/code] global oversampling factor is used instead. Used by dynamic fonts only.
*/
func (self Instance) FontSetOversampling(font_rid RID.Font, oversampling Float.X) { //gd:TextServer.font_set_oversampling
	Advanced(self).FontSetOversampling(RID.Any(font_rid), float64(oversampling))
}

/*
Returns font oversampling factor, if set to [code]0.0[/code] global oversampling factor is used instead. Used by dynamic fonts only.
*/
func (self Instance) FontGetOversampling(font_rid RID.Font) Float.X { //gd:TextServer.font_get_oversampling
	return Float.X(Float.X(Advanced(self).FontGetOversampling(RID.Any(font_rid))))
}

/*
Returns list of the font sizes in the cache. Each size is [Vector2i] with font size and outline size.
*/
func (self Instance) FontGetSizeCacheList(font_rid RID.Font) []Vector2i.XY { //gd:TextServer.font_get_size_cache_list
	return []Vector2i.XY(gd.ArrayAs[[]Vector2i.XY](gd.InternalArray(Advanced(self).FontGetSizeCacheList(RID.Any(font_rid)))))
}

/*
Removes all font sizes from the cache entry.
*/
func (self Instance) FontClearSizeCache(font_rid RID.Font) { //gd:TextServer.font_clear_size_cache
	Advanced(self).FontClearSizeCache(RID.Any(font_rid))
}

/*
Removes specified font size from the cache entry.
*/
func (self Instance) FontRemoveSizeCache(font_rid RID.Font, size Vector2i.XY) { //gd:TextServer.font_remove_size_cache
	Advanced(self).FontRemoveSizeCache(RID.Any(font_rid), Vector2i.XY(size))
}

/*
Sets the font ascent (number of pixels above the baseline).
*/
func (self Instance) FontSetAscent(font_rid RID.Font, size int, ascent Float.X) { //gd:TextServer.font_set_ascent
	Advanced(self).FontSetAscent(RID.Any(font_rid), int64(size), float64(ascent))
}

/*
Returns the font ascent (number of pixels above the baseline).
*/
func (self Instance) FontGetAscent(font_rid RID.Font, size int) Float.X { //gd:TextServer.font_get_ascent
	return Float.X(Float.X(Advanced(self).FontGetAscent(RID.Any(font_rid), int64(size))))
}

/*
Sets the font descent (number of pixels below the baseline).
*/
func (self Instance) FontSetDescent(font_rid RID.Font, size int, descent Float.X) { //gd:TextServer.font_set_descent
	Advanced(self).FontSetDescent(RID.Any(font_rid), int64(size), float64(descent))
}

/*
Returns the font descent (number of pixels below the baseline).
*/
func (self Instance) FontGetDescent(font_rid RID.Font, size int) Float.X { //gd:TextServer.font_get_descent
	return Float.X(Float.X(Advanced(self).FontGetDescent(RID.Any(font_rid), int64(size))))
}

/*
Sets pixel offset of the underline below the baseline.
*/
func (self Instance) FontSetUnderlinePosition(font_rid RID.Font, size int, underline_position Float.X) { //gd:TextServer.font_set_underline_position
	Advanced(self).FontSetUnderlinePosition(RID.Any(font_rid), int64(size), float64(underline_position))
}

/*
Returns pixel offset of the underline below the baseline.
*/
func (self Instance) FontGetUnderlinePosition(font_rid RID.Font, size int) Float.X { //gd:TextServer.font_get_underline_position
	return Float.X(Float.X(Advanced(self).FontGetUnderlinePosition(RID.Any(font_rid), int64(size))))
}

/*
Sets thickness of the underline in pixels.
*/
func (self Instance) FontSetUnderlineThickness(font_rid RID.Font, size int, underline_thickness Float.X) { //gd:TextServer.font_set_underline_thickness
	Advanced(self).FontSetUnderlineThickness(RID.Any(font_rid), int64(size), float64(underline_thickness))
}

/*
Returns thickness of the underline in pixels.
*/
func (self Instance) FontGetUnderlineThickness(font_rid RID.Font, size int) Float.X { //gd:TextServer.font_get_underline_thickness
	return Float.X(Float.X(Advanced(self).FontGetUnderlineThickness(RID.Any(font_rid), int64(size))))
}

/*
Sets scaling factor of the color bitmap font.
*/
func (self Instance) FontSetScale(font_rid RID.Font, size int, scale Float.X) { //gd:TextServer.font_set_scale
	Advanced(self).FontSetScale(RID.Any(font_rid), int64(size), float64(scale))
}

/*
Returns scaling factor of the color bitmap font.
*/
func (self Instance) FontGetScale(font_rid RID.Font, size int) Float.X { //gd:TextServer.font_get_scale
	return Float.X(Float.X(Advanced(self).FontGetScale(RID.Any(font_rid), int64(size))))
}

/*
Returns number of textures used by font cache entry.
*/
func (self Instance) FontGetTextureCount(font_rid RID.Font, size Vector2i.XY) int { //gd:TextServer.font_get_texture_count
	return int(int(Advanced(self).FontGetTextureCount(RID.Any(font_rid), Vector2i.XY(size))))
}

/*
Removes all textures from font cache entry.
[b]Note:[/b] This function will not remove glyphs associated with the texture, use [method font_remove_glyph] to remove them manually.
*/
func (self Instance) FontClearTextures(font_rid RID.Font, size Vector2i.XY) { //gd:TextServer.font_clear_textures
	Advanced(self).FontClearTextures(RID.Any(font_rid), Vector2i.XY(size))
}

/*
Removes specified texture from the cache entry.
[b]Note:[/b] This function will not remove glyphs associated with the texture, remove them manually, using [method font_remove_glyph].
*/
func (self Instance) FontRemoveTexture(font_rid RID.Font, size Vector2i.XY, texture_index int) { //gd:TextServer.font_remove_texture
	Advanced(self).FontRemoveTexture(RID.Any(font_rid), Vector2i.XY(size), int64(texture_index))
}

/*
Sets font cache texture image data.
*/
func (self Instance) FontSetTextureImage(font_rid RID.Font, size Vector2i.XY, texture_index int, image Image.Instance) { //gd:TextServer.font_set_texture_image
	Advanced(self).FontSetTextureImage(RID.Any(font_rid), Vector2i.XY(size), int64(texture_index), image)
}

/*
Returns font cache texture image data.
*/
func (self Instance) FontGetTextureImage(font_rid RID.Font, size Vector2i.XY, texture_index int) Image.Instance { //gd:TextServer.font_get_texture_image
	return Image.Instance(Advanced(self).FontGetTextureImage(RID.Any(font_rid), Vector2i.XY(size), int64(texture_index)))
}

/*
Sets array containing glyph packing data.
*/
func (self Instance) FontSetTextureOffsets(font_rid RID.Font, size Vector2i.XY, texture_index int, offset []int32) { //gd:TextServer.font_set_texture_offsets
	Advanced(self).FontSetTextureOffsets(RID.Any(font_rid), Vector2i.XY(size), int64(texture_index), Packed.New(offset...))
}

/*
Returns array containing glyph packing data.
*/
func (self Instance) FontGetTextureOffsets(font_rid RID.Font, size Vector2i.XY, texture_index int) []int32 { //gd:TextServer.font_get_texture_offsets
	return []int32(slices.Collect(Advanced(self).FontGetTextureOffsets(RID.Any(font_rid), Vector2i.XY(size), int64(texture_index)).Values()))
}

/*
Returns list of rendered glyphs in the cache entry.
*/
func (self Instance) FontGetGlyphList(font_rid RID.Font, size Vector2i.XY) []int32 { //gd:TextServer.font_get_glyph_list
	return []int32(slices.Collect(Advanced(self).FontGetGlyphList(RID.Any(font_rid), Vector2i.XY(size)).Values()))
}

/*
Removes all rendered glyph information from the cache entry.
[b]Note:[/b] This function will not remove textures associated with the glyphs, use [method font_remove_texture] to remove them manually.
*/
func (self Instance) FontClearGlyphs(font_rid RID.Font, size Vector2i.XY) { //gd:TextServer.font_clear_glyphs
	Advanced(self).FontClearGlyphs(RID.Any(font_rid), Vector2i.XY(size))
}

/*
Removes specified rendered glyph information from the cache entry.
[b]Note:[/b] This function will not remove textures associated with the glyphs, use [method font_remove_texture] to remove them manually.
*/
func (self Instance) FontRemoveGlyph(font_rid RID.Font, size Vector2i.XY, glyph int) { //gd:TextServer.font_remove_glyph
	Advanced(self).FontRemoveGlyph(RID.Any(font_rid), Vector2i.XY(size), int64(glyph))
}

/*
Returns glyph advance (offset of the next glyph).
[b]Note:[/b] Advance for glyphs outlines is the same as the base glyph advance and is not saved.
*/
func (self Instance) FontGetGlyphAdvance(font_rid RID.Font, size int, glyph int) Vector2.XY { //gd:TextServer.font_get_glyph_advance
	return Vector2.XY(Advanced(self).FontGetGlyphAdvance(RID.Any(font_rid), int64(size), int64(glyph)))
}

/*
Sets glyph advance (offset of the next glyph).
[b]Note:[/b] Advance for glyphs outlines is the same as the base glyph advance and is not saved.
*/
func (self Instance) FontSetGlyphAdvance(font_rid RID.Font, size int, glyph int, advance Vector2.XY) { //gd:TextServer.font_set_glyph_advance
	Advanced(self).FontSetGlyphAdvance(RID.Any(font_rid), int64(size), int64(glyph), Vector2.XY(advance))
}

/*
Returns glyph offset from the baseline.
*/
func (self Instance) FontGetGlyphOffset(font_rid RID.Font, size Vector2i.XY, glyph int) Vector2.XY { //gd:TextServer.font_get_glyph_offset
	return Vector2.XY(Advanced(self).FontGetGlyphOffset(RID.Any(font_rid), Vector2i.XY(size), int64(glyph)))
}

/*
Sets glyph offset from the baseline.
*/
func (self Instance) FontSetGlyphOffset(font_rid RID.Font, size Vector2i.XY, glyph int, offset Vector2.XY) { //gd:TextServer.font_set_glyph_offset
	Advanced(self).FontSetGlyphOffset(RID.Any(font_rid), Vector2i.XY(size), int64(glyph), Vector2.XY(offset))
}

/*
Returns size of the glyph.
*/
func (self Instance) FontGetGlyphSize(font_rid RID.Font, size Vector2i.XY, glyph int) Vector2.XY { //gd:TextServer.font_get_glyph_size
	return Vector2.XY(Advanced(self).FontGetGlyphSize(RID.Any(font_rid), Vector2i.XY(size), int64(glyph)))
}

/*
Sets size of the glyph.
*/
func (self Instance) FontSetGlyphSize(font_rid RID.Font, size Vector2i.XY, glyph int, gl_size Vector2.XY) { //gd:TextServer.font_set_glyph_size
	Advanced(self).FontSetGlyphSize(RID.Any(font_rid), Vector2i.XY(size), int64(glyph), Vector2.XY(gl_size))
}

/*
Returns rectangle in the cache texture containing the glyph.
*/
func (self Instance) FontGetGlyphUvRect(font_rid RID.Font, size Vector2i.XY, glyph int) Rect2.PositionSize { //gd:TextServer.font_get_glyph_uv_rect
	return Rect2.PositionSize(Advanced(self).FontGetGlyphUvRect(RID.Any(font_rid), Vector2i.XY(size), int64(glyph)))
}

/*
Sets rectangle in the cache texture containing the glyph.
*/
func (self Instance) FontSetGlyphUvRect(font_rid RID.Font, size Vector2i.XY, glyph int, uv_rect Rect2.PositionSize) { //gd:TextServer.font_set_glyph_uv_rect
	Advanced(self).FontSetGlyphUvRect(RID.Any(font_rid), Vector2i.XY(size), int64(glyph), Rect2.PositionSize(uv_rect))
}

/*
Returns index of the cache texture containing the glyph.
*/
func (self Instance) FontGetGlyphTextureIdx(font_rid RID.Font, size Vector2i.XY, glyph int) int { //gd:TextServer.font_get_glyph_texture_idx
	return int(int(Advanced(self).FontGetGlyphTextureIdx(RID.Any(font_rid), Vector2i.XY(size), int64(glyph))))
}

/*
Sets index of the cache texture containing the glyph.
*/
func (self Instance) FontSetGlyphTextureIdx(font_rid RID.Font, size Vector2i.XY, glyph int, texture_idx int) { //gd:TextServer.font_set_glyph_texture_idx
	Advanced(self).FontSetGlyphTextureIdx(RID.Any(font_rid), Vector2i.XY(size), int64(glyph), int64(texture_idx))
}

/*
Returns resource ID of the cache texture containing the glyph.
[b]Note:[/b] If there are pending glyphs to render, calling this function might trigger the texture cache update.
*/
func (self Instance) FontGetGlyphTextureRid(font_rid RID.Font, size Vector2i.XY, glyph int) RID.Texture { //gd:TextServer.font_get_glyph_texture_rid
	return RID.Texture(Advanced(self).FontGetGlyphTextureRid(RID.Any(font_rid), Vector2i.XY(size), int64(glyph)))
}

/*
Returns size of the cache texture containing the glyph.
[b]Note:[/b] If there are pending glyphs to render, calling this function might trigger the texture cache update.
*/
func (self Instance) FontGetGlyphTextureSize(font_rid RID.Font, size Vector2i.XY, glyph int) Vector2.XY { //gd:TextServer.font_get_glyph_texture_size
	return Vector2.XY(Advanced(self).FontGetGlyphTextureSize(RID.Any(font_rid), Vector2i.XY(size), int64(glyph)))
}

/*
Returns outline contours of the glyph as a [Dictionary] with the following contents:
[code]points[/code]         - [PackedVector3Array], containing outline points. [code]x[/code] and [code]y[/code] are point coordinates. [code]z[/code] is the type of the point, using the [enum ContourPointTag] values.
[code]contours[/code]       - [PackedInt32Array], containing indices the end points of each contour.
[code]orientation[/code]    - [bool], contour orientation. If [code]true[/code], clockwise contours must be filled.
- Two successive [constant CONTOUR_CURVE_TAG_ON] points indicate a line segment.
- One [constant CONTOUR_CURVE_TAG_OFF_CONIC] point between two [constant CONTOUR_CURVE_TAG_ON] points indicates a single conic (quadratic) Bzier arc.
- Two [constant CONTOUR_CURVE_TAG_OFF_CUBIC] points between two [constant CONTOUR_CURVE_TAG_ON] points indicate a single cubic Bzier arc.
- Two successive [constant CONTOUR_CURVE_TAG_OFF_CONIC] points indicate two successive conic (quadratic) Bzier arcs with a virtual [constant CONTOUR_CURVE_TAG_ON] point at their middle.
- Each contour is closed. The last point of a contour uses the first point of a contour as its next point, and vice versa. The first point can be [constant CONTOUR_CURVE_TAG_OFF_CONIC] point.
*/
func (self Instance) FontGetGlyphContours(font RID.Font, size int, index int) map[string]interface{} { //gd:TextServer.font_get_glyph_contours
	return map[string]interface{}(gd.DictionaryAs[map[string]interface{}](Advanced(self).FontGetGlyphContours(RID.Any(font), int64(size), int64(index))))
}

/*
Returns list of the kerning overrides.
*/
func (self Instance) FontGetKerningList(font_rid RID.Font, size int) []Vector2i.XY { //gd:TextServer.font_get_kerning_list
	return []Vector2i.XY(gd.ArrayAs[[]Vector2i.XY](gd.InternalArray(Advanced(self).FontGetKerningList(RID.Any(font_rid), int64(size)))))
}

/*
Removes all kerning overrides.
*/
func (self Instance) FontClearKerningMap(font_rid RID.Font, size int) { //gd:TextServer.font_clear_kerning_map
	Advanced(self).FontClearKerningMap(RID.Any(font_rid), int64(size))
}

/*
Removes kerning override for the pair of glyphs.
*/
func (self Instance) FontRemoveKerning(font_rid RID.Font, size int, glyph_pair Vector2i.XY) { //gd:TextServer.font_remove_kerning
	Advanced(self).FontRemoveKerning(RID.Any(font_rid), int64(size), Vector2i.XY(glyph_pair))
}

/*
Sets kerning for the pair of glyphs.
*/
func (self Instance) FontSetKerning(font_rid RID.Font, size int, glyph_pair Vector2i.XY, kerning Vector2.XY) { //gd:TextServer.font_set_kerning
	Advanced(self).FontSetKerning(RID.Any(font_rid), int64(size), Vector2i.XY(glyph_pair), Vector2.XY(kerning))
}

/*
Returns kerning for the pair of glyphs.
*/
func (self Instance) FontGetKerning(font_rid RID.Font, size int, glyph_pair Vector2i.XY) Vector2.XY { //gd:TextServer.font_get_kerning
	return Vector2.XY(Advanced(self).FontGetKerning(RID.Any(font_rid), int64(size), Vector2i.XY(glyph_pair)))
}

/*
Returns the glyph index of a [param char], optionally modified by the [param variation_selector]. See [method font_get_char_from_glyph_index].
*/
func (self Instance) FontGetGlyphIndex(font_rid RID.Font, size int, char int, variation_selector int) int { //gd:TextServer.font_get_glyph_index
	return int(int(Advanced(self).FontGetGlyphIndex(RID.Any(font_rid), int64(size), int64(char), int64(variation_selector))))
}

/*
Returns character code associated with [param glyph_index], or [code]0[/code] if [param glyph_index] is invalid. See [method font_get_glyph_index].
*/
func (self Instance) FontGetCharFromGlyphIndex(font_rid RID.Font, size int, glyph_index int) int { //gd:TextServer.font_get_char_from_glyph_index
	return int(int(Advanced(self).FontGetCharFromGlyphIndex(RID.Any(font_rid), int64(size), int64(glyph_index))))
}

/*
Returns [code]true[/code] if a Unicode [param char] is available in the font.
*/
func (self Instance) FontHasChar(font_rid RID.Font, char int) bool { //gd:TextServer.font_has_char
	return bool(Advanced(self).FontHasChar(RID.Any(font_rid), int64(char)))
}

/*
Returns a string containing all the characters available in the font.
*/
func (self Instance) FontGetSupportedChars(font_rid RID.Font) string { //gd:TextServer.font_get_supported_chars
	return string(Advanced(self).FontGetSupportedChars(RID.Any(font_rid)).String())
}

/*
Returns an array containing all glyph indices in the font.
*/
func (self Instance) FontGetSupportedGlyphs(font_rid RID.Font) []int32 { //gd:TextServer.font_get_supported_glyphs
	return []int32(slices.Collect(Advanced(self).FontGetSupportedGlyphs(RID.Any(font_rid)).Values()))
}

/*
Renders the range of characters to the font cache texture.
*/
func (self Instance) FontRenderRange(font_rid RID.Font, size Vector2i.XY, start int, end int) { //gd:TextServer.font_render_range
	Advanced(self).FontRenderRange(RID.Any(font_rid), Vector2i.XY(size), int64(start), int64(end))
}

/*
Renders specified glyph to the font cache texture.
*/
func (self Instance) FontRenderGlyph(font_rid RID.Font, size Vector2i.XY, index int) { //gd:TextServer.font_render_glyph
	Advanced(self).FontRenderGlyph(RID.Any(font_rid), Vector2i.XY(size), int64(index))
}

/*
Draws single glyph into a canvas item at the position, using [param font_rid] at the size [param size].
[b]Note:[/b] Glyph index is specific to the font, use glyphs indices returned by [method shaped_text_get_glyphs] or [method font_get_glyph_index].
[b]Note:[/b] If there are pending glyphs to render, calling this function might trigger the texture cache update.
*/
func (self Instance) FontDrawGlyph(font_rid RID.Font, canvas RID.Canvas, size int, pos Vector2.XY, index int) { //gd:TextServer.font_draw_glyph
	Advanced(self).FontDrawGlyph(RID.Any(font_rid), RID.Any(canvas), int64(size), Vector2.XY(pos), int64(index), Color.RGBA(gd.Color{1, 1, 1, 1}))
}

/*
Draws single glyph into a canvas item at the position, using [param font_rid] at the size [param size].
[b]Note:[/b] Glyph index is specific to the font, use glyphs indices returned by [method shaped_text_get_glyphs] or [method font_get_glyph_index].
[b]Note:[/b] If there are pending glyphs to render, calling this function might trigger the texture cache update.
*/
func (self Expanded) FontDrawGlyph(font_rid RID.Font, canvas RID.Canvas, size int, pos Vector2.XY, index int, color Color.RGBA) { //gd:TextServer.font_draw_glyph
	Advanced(self).FontDrawGlyph(RID.Any(font_rid), RID.Any(canvas), int64(size), Vector2.XY(pos), int64(index), Color.RGBA(color))
}

/*
Draws single glyph outline of size [param outline_size] into a canvas item at the position, using [param font_rid] at the size [param size].
[b]Note:[/b] Glyph index is specific to the font, use glyphs indices returned by [method shaped_text_get_glyphs] or [method font_get_glyph_index].
[b]Note:[/b] If there are pending glyphs to render, calling this function might trigger the texture cache update.
*/
func (self Instance) FontDrawGlyphOutline(font_rid RID.Font, canvas RID.Canvas, size int, outline_size int, pos Vector2.XY, index int) { //gd:TextServer.font_draw_glyph_outline
	Advanced(self).FontDrawGlyphOutline(RID.Any(font_rid), RID.Any(canvas), int64(size), int64(outline_size), Vector2.XY(pos), int64(index), Color.RGBA(gd.Color{1, 1, 1, 1}))
}

/*
Draws single glyph outline of size [param outline_size] into a canvas item at the position, using [param font_rid] at the size [param size].
[b]Note:[/b] Glyph index is specific to the font, use glyphs indices returned by [method shaped_text_get_glyphs] or [method font_get_glyph_index].
[b]Note:[/b] If there are pending glyphs to render, calling this function might trigger the texture cache update.
*/
func (self Expanded) FontDrawGlyphOutline(font_rid RID.Font, canvas RID.Canvas, size int, outline_size int, pos Vector2.XY, index int, color Color.RGBA) { //gd:TextServer.font_draw_glyph_outline
	Advanced(self).FontDrawGlyphOutline(RID.Any(font_rid), RID.Any(canvas), int64(size), int64(outline_size), Vector2.XY(pos), int64(index), Color.RGBA(color))
}

/*
Returns [code]true[/code], if font supports given language ([url=https://en.wikipedia.org/wiki/ISO_639-1]ISO 639[/url] code).
*/
func (self Instance) FontIsLanguageSupported(font_rid RID.Font, language string) bool { //gd:TextServer.font_is_language_supported
	return bool(Advanced(self).FontIsLanguageSupported(RID.Any(font_rid), String.New(language)))
}

/*
Adds override for [method font_is_language_supported].
*/
func (self Instance) FontSetLanguageSupportOverride(font_rid RID.Font, language string, supported bool) { //gd:TextServer.font_set_language_support_override
	Advanced(self).FontSetLanguageSupportOverride(RID.Any(font_rid), String.New(language), supported)
}

/*
Returns [code]true[/code] if support override is enabled for the [param language].
*/
func (self Instance) FontGetLanguageSupportOverride(font_rid RID.Font, language string) bool { //gd:TextServer.font_get_language_support_override
	return bool(Advanced(self).FontGetLanguageSupportOverride(RID.Any(font_rid), String.New(language)))
}

/*
Remove language support override.
*/
func (self Instance) FontRemoveLanguageSupportOverride(font_rid RID.Font, language string) { //gd:TextServer.font_remove_language_support_override
	Advanced(self).FontRemoveLanguageSupportOverride(RID.Any(font_rid), String.New(language))
}

/*
Returns list of language support overrides.
*/
func (self Instance) FontGetLanguageSupportOverrides(font_rid RID.Font) []string { //gd:TextServer.font_get_language_support_overrides
	return []string(Advanced(self).FontGetLanguageSupportOverrides(RID.Any(font_rid)).Strings())
}

/*
Returns [code]true[/code], if font supports given script (ISO 15924 code).
*/
func (self Instance) FontIsScriptSupported(font_rid RID.Font, script string) bool { //gd:TextServer.font_is_script_supported
	return bool(Advanced(self).FontIsScriptSupported(RID.Any(font_rid), String.New(script)))
}

/*
Adds override for [method font_is_script_supported].
*/
func (self Instance) FontSetScriptSupportOverride(font_rid RID.Font, script string, supported bool) { //gd:TextServer.font_set_script_support_override
	Advanced(self).FontSetScriptSupportOverride(RID.Any(font_rid), String.New(script), supported)
}

/*
Returns [code]true[/code] if support override is enabled for the [param script].
*/
func (self Instance) FontGetScriptSupportOverride(font_rid RID.Font, script string) bool { //gd:TextServer.font_get_script_support_override
	return bool(Advanced(self).FontGetScriptSupportOverride(RID.Any(font_rid), String.New(script)))
}

/*
Removes script support override.
*/
func (self Instance) FontRemoveScriptSupportOverride(font_rid RID.Font, script string) { //gd:TextServer.font_remove_script_support_override
	Advanced(self).FontRemoveScriptSupportOverride(RID.Any(font_rid), String.New(script))
}

/*
Returns list of script support overrides.
*/
func (self Instance) FontGetScriptSupportOverrides(font_rid RID.Font) []string { //gd:TextServer.font_get_script_support_overrides
	return []string(Advanced(self).FontGetScriptSupportOverrides(RID.Any(font_rid)).Strings())
}

/*
Sets font OpenType feature set override.
*/
func (self Instance) FontSetOpentypeFeatureOverrides(font_rid RID.Font, overrides map[string]string) { //gd:TextServer.font_set_opentype_feature_overrides
	Advanced(self).FontSetOpentypeFeatureOverrides(RID.Any(font_rid), gd.DictionaryFromMap(overrides))
}

/*
Returns font OpenType feature set override.
*/
func (self Instance) FontGetOpentypeFeatureOverrides(font_rid RID.Font) map[string]string { //gd:TextServer.font_get_opentype_feature_overrides
	return map[string]string(gd.DictionaryAs[map[string]string](Advanced(self).FontGetOpentypeFeatureOverrides(RID.Any(font_rid))))
}

/*
Returns the dictionary of the supported OpenType features.
*/
func (self Instance) FontSupportedFeatureList(font_rid RID.Font) map[string]string { //gd:TextServer.font_supported_feature_list
	return map[string]string(gd.DictionaryAs[map[string]string](Advanced(self).FontSupportedFeatureList(RID.Any(font_rid))))
}

/*
Returns the dictionary of the supported OpenType variation coordinates.
*/
func (self Instance) FontSupportedVariationList(font_rid RID.Font) map[string]string { //gd:TextServer.font_supported_variation_list
	return map[string]string(gd.DictionaryAs[map[string]string](Advanced(self).FontSupportedVariationList(RID.Any(font_rid))))
}

/*
Returns the font oversampling factor, shared by all fonts in the TextServer.
*/
func (self Instance) FontGetGlobalOversampling() Float.X { //gd:TextServer.font_get_global_oversampling
	return Float.X(Float.X(Advanced(self).FontGetGlobalOversampling()))
}

/*
Sets oversampling factor, shared by all font in the TextServer.
[b]Note:[/b] This value can be automatically changed by display server.
*/
func (self Instance) FontSetGlobalOversampling(oversampling Float.X) { //gd:TextServer.font_set_global_oversampling
	Advanced(self).FontSetGlobalOversampling(float64(oversampling))
}

/*
Returns size of the replacement character (box with character hexadecimal code that is drawn in place of invalid characters).
*/
func (self Instance) GetHexCodeBoxSize(size int, index int) Vector2.XY { //gd:TextServer.get_hex_code_box_size
	return Vector2.XY(Advanced(self).GetHexCodeBoxSize(int64(size), int64(index)))
}

/*
Draws box displaying character hexadecimal code. Used for replacing missing characters.
*/
func (self Instance) DrawHexCodeBox(canvas RID.Canvas, size int, pos Vector2.XY, index int, color Color.RGBA) { //gd:TextServer.draw_hex_code_box
	Advanced(self).DrawHexCodeBox(RID.Any(canvas), int64(size), Vector2.XY(pos), int64(index), Color.RGBA(color))
}

/*
Creates a new buffer for complex text layout, with the given [param direction] and [param orientation]. To free the resulting buffer, use [method free_rid] method.
[b]Note:[/b] Direction is ignored if server does not support [constant FEATURE_BIDI_LAYOUT] feature (supported by [TextServerAdvanced]).
[b]Note:[/b] Orientation is ignored if server does not support [constant FEATURE_VERTICAL_LAYOUT] feature (supported by [TextServerAdvanced]).
*/
func (self Instance) CreateShapedText() RID.TextBuffer { //gd:TextServer.create_shaped_text
	return RID.TextBuffer(Advanced(self).CreateShapedText(0, 0))
}

/*
Creates a new buffer for complex text layout, with the given [param direction] and [param orientation]. To free the resulting buffer, use [method free_rid] method.
[b]Note:[/b] Direction is ignored if server does not support [constant FEATURE_BIDI_LAYOUT] feature (supported by [TextServerAdvanced]).
[b]Note:[/b] Orientation is ignored if server does not support [constant FEATURE_VERTICAL_LAYOUT] feature (supported by [TextServerAdvanced]).
*/
func (self Expanded) CreateShapedText(direction Direction, orientation Orientation) RID.TextBuffer { //gd:TextServer.create_shaped_text
	return RID.TextBuffer(Advanced(self).CreateShapedText(direction, orientation))
}

/*
Clears text buffer (removes text and inline objects).
*/
func (self Instance) ShapedTextClear(rid RID.TextBuffer) { //gd:TextServer.shaped_text_clear
	Advanced(self).ShapedTextClear(RID.Any(rid))
}

/*
Sets desired text direction. If set to [constant DIRECTION_AUTO], direction will be detected based on the buffer contents and current locale.
[b]Note:[/b] Direction is ignored if server does not support [constant FEATURE_BIDI_LAYOUT] feature (supported by [TextServerAdvanced]).
*/
func (self Instance) ShapedTextSetDirection(shaped RID.TextBuffer) { //gd:TextServer.shaped_text_set_direction
	Advanced(self).ShapedTextSetDirection(RID.Any(shaped), 0)
}

/*
Sets desired text direction. If set to [constant DIRECTION_AUTO], direction will be detected based on the buffer contents and current locale.
[b]Note:[/b] Direction is ignored if server does not support [constant FEATURE_BIDI_LAYOUT] feature (supported by [TextServerAdvanced]).
*/
func (self Expanded) ShapedTextSetDirection(shaped RID.TextBuffer, direction Direction) { //gd:TextServer.shaped_text_set_direction
	Advanced(self).ShapedTextSetDirection(RID.Any(shaped), direction)
}

/*
Returns direction of the text.
*/
func (self Instance) ShapedTextGetDirection(shaped RID.TextBuffer) Direction { //gd:TextServer.shaped_text_get_direction
	return Direction(Advanced(self).ShapedTextGetDirection(RID.Any(shaped)))
}

/*
Returns direction of the text, inferred by the BiDi algorithm.
*/
func (self Instance) ShapedTextGetInferredDirection(shaped RID.TextBuffer) Direction { //gd:TextServer.shaped_text_get_inferred_direction
	return Direction(Advanced(self).ShapedTextGetInferredDirection(RID.Any(shaped)))
}

/*
Overrides BiDi for the structured text.
Override ranges should cover full source text without overlaps. BiDi algorithm will be used on each range separately.
*/
func (self Instance) ShapedTextSetBidiOverride(shaped RID.TextBuffer, override []any) { //gd:TextServer.shaped_text_set_bidi_override
	Advanced(self).ShapedTextSetBidiOverride(RID.Any(shaped), gd.EngineArrayFromSlice(override))
}

/*
Sets custom punctuation character list, used for word breaking. If set to empty string, server defaults are used.
*/
func (self Instance) ShapedTextSetCustomPunctuation(shaped RID.TextBuffer, punct string) { //gd:TextServer.shaped_text_set_custom_punctuation
	Advanced(self).ShapedTextSetCustomPunctuation(RID.Any(shaped), String.New(punct))
}

/*
Returns custom punctuation character list, used for word breaking. If set to empty string, server defaults are used.
*/
func (self Instance) ShapedTextGetCustomPunctuation(shaped RID.TextBuffer) string { //gd:TextServer.shaped_text_get_custom_punctuation
	return string(Advanced(self).ShapedTextGetCustomPunctuation(RID.Any(shaped)).String())
}

/*
Sets ellipsis character used for text clipping.
*/
func (self Instance) ShapedTextSetCustomEllipsis(shaped RID.TextBuffer, char int) { //gd:TextServer.shaped_text_set_custom_ellipsis
	Advanced(self).ShapedTextSetCustomEllipsis(RID.Any(shaped), int64(char))
}

/*
Returns ellipsis character used for text clipping.
*/
func (self Instance) ShapedTextGetCustomEllipsis(shaped RID.TextBuffer) int { //gd:TextServer.shaped_text_get_custom_ellipsis
	return int(int(Advanced(self).ShapedTextGetCustomEllipsis(RID.Any(shaped))))
}

/*
Sets desired text orientation.
[b]Note:[/b] Orientation is ignored if server does not support [constant FEATURE_VERTICAL_LAYOUT] feature (supported by [TextServerAdvanced]).
*/
func (self Instance) ShapedTextSetOrientation(shaped RID.TextBuffer) { //gd:TextServer.shaped_text_set_orientation
	Advanced(self).ShapedTextSetOrientation(RID.Any(shaped), 0)
}

/*
Sets desired text orientation.
[b]Note:[/b] Orientation is ignored if server does not support [constant FEATURE_VERTICAL_LAYOUT] feature (supported by [TextServerAdvanced]).
*/
func (self Expanded) ShapedTextSetOrientation(shaped RID.TextBuffer, orientation Orientation) { //gd:TextServer.shaped_text_set_orientation
	Advanced(self).ShapedTextSetOrientation(RID.Any(shaped), orientation)
}

/*
Returns text orientation.
*/
func (self Instance) ShapedTextGetOrientation(shaped RID.TextBuffer) Orientation { //gd:TextServer.shaped_text_get_orientation
	return Orientation(Advanced(self).ShapedTextGetOrientation(RID.Any(shaped)))
}

/*
If set to [code]true[/code] text buffer will display invalid characters as hexadecimal codes, otherwise nothing is displayed.
*/
func (self Instance) ShapedTextSetPreserveInvalid(shaped RID.TextBuffer, enabled bool) { //gd:TextServer.shaped_text_set_preserve_invalid
	Advanced(self).ShapedTextSetPreserveInvalid(RID.Any(shaped), enabled)
}

/*
Returns [code]true[/code] if text buffer is configured to display hexadecimal codes in place of invalid characters.
[b]Note:[/b] If set to [code]false[/code], nothing is displayed in place of invalid characters.
*/
func (self Instance) ShapedTextGetPreserveInvalid(shaped RID.TextBuffer) bool { //gd:TextServer.shaped_text_get_preserve_invalid
	return bool(Advanced(self).ShapedTextGetPreserveInvalid(RID.Any(shaped)))
}

/*
If set to [code]true[/code] text buffer will display control characters.
*/
func (self Instance) ShapedTextSetPreserveControl(shaped RID.TextBuffer, enabled bool) { //gd:TextServer.shaped_text_set_preserve_control
	Advanced(self).ShapedTextSetPreserveControl(RID.Any(shaped), enabled)
}

/*
Returns [code]true[/code] if text buffer is configured to display control characters.
*/
func (self Instance) ShapedTextGetPreserveControl(shaped RID.TextBuffer) bool { //gd:TextServer.shaped_text_get_preserve_control
	return bool(Advanced(self).ShapedTextGetPreserveControl(RID.Any(shaped)))
}

/*
Sets extra spacing added between glyphs or lines in pixels.
*/
func (self Instance) ShapedTextSetSpacing(shaped RID.TextBuffer, spacing SpacingType, value int) { //gd:TextServer.shaped_text_set_spacing
	Advanced(self).ShapedTextSetSpacing(RID.Any(shaped), spacing, int64(value))
}

/*
Returns extra spacing added between glyphs or lines in pixels.
*/
func (self Instance) ShapedTextGetSpacing(shaped RID.TextBuffer, spacing SpacingType) int { //gd:TextServer.shaped_text_get_spacing
	return int(int(Advanced(self).ShapedTextGetSpacing(RID.Any(shaped), spacing)))
}

/*
Adds text span and font to draw it to the text buffer.
*/
func (self Instance) ShapedTextAddString(shaped RID.TextBuffer, text string, fonts []RID.TextBuffer, size int) bool { //gd:TextServer.shaped_text_add_string
	return bool(Advanced(self).ShapedTextAddString(RID.Any(shaped), String.New(text), gd.ArrayFromSlice[Array.Contains[RID.Any]](fonts), int64(size), Dictionary.Nil, String.New(""), variant.New([1]any{}[0])))
}

/*
Adds text span and font to draw it to the text buffer.
*/
func (self Expanded) ShapedTextAddString(shaped RID.TextBuffer, text string, fonts []RID.TextBuffer, size int, opentype_features map[string]string, language string, meta any) bool { //gd:TextServer.shaped_text_add_string
	return bool(Advanced(self).ShapedTextAddString(RID.Any(shaped), String.New(text), gd.ArrayFromSlice[Array.Contains[RID.Any]](fonts), int64(size), gd.DictionaryFromMap(opentype_features), String.New(language), variant.New(meta)))
}

/*
Adds inline object to the text buffer, [param key] must be unique. In the text, object is represented as [param length] object replacement characters.
*/
func (self Instance) ShapedTextAddObject(shaped RID.TextBuffer, key any, size Vector2.XY) bool { //gd:TextServer.shaped_text_add_object
	return bool(Advanced(self).ShapedTextAddObject(RID.Any(shaped), variant.New(key), Vector2.XY(size), 5, int64(1), float64(0.0)))
}

/*
Adds inline object to the text buffer, [param key] must be unique. In the text, object is represented as [param length] object replacement characters.
*/
func (self Expanded) ShapedTextAddObject(shaped RID.TextBuffer, key any, size Vector2.XY, inline_align GUI.InlineAlignment, length int, baseline Float.X) bool { //gd:TextServer.shaped_text_add_object
	return bool(Advanced(self).ShapedTextAddObject(RID.Any(shaped), variant.New(key), Vector2.XY(size), inline_align, int64(length), float64(baseline)))
}

/*
Sets new size and alignment of embedded object.
*/
func (self Instance) ShapedTextResizeObject(shaped RID.TextBuffer, key any, size Vector2.XY) bool { //gd:TextServer.shaped_text_resize_object
	return bool(Advanced(self).ShapedTextResizeObject(RID.Any(shaped), variant.New(key), Vector2.XY(size), 5, float64(0.0)))
}

/*
Sets new size and alignment of embedded object.
*/
func (self Expanded) ShapedTextResizeObject(shaped RID.TextBuffer, key any, size Vector2.XY, inline_align GUI.InlineAlignment, baseline Float.X) bool { //gd:TextServer.shaped_text_resize_object
	return bool(Advanced(self).ShapedTextResizeObject(RID.Any(shaped), variant.New(key), Vector2.XY(size), inline_align, float64(baseline)))
}

/*
Returns number of text spans added using [method shaped_text_add_string] or [method shaped_text_add_object].
*/
func (self Instance) ShapedGetSpanCount(shaped RID.TextBuffer) int { //gd:TextServer.shaped_get_span_count
	return int(int(Advanced(self).ShapedGetSpanCount(RID.Any(shaped))))
}

/*
Returns text span metadata.
*/
func (self Instance) ShapedGetSpanMeta(shaped RID.TextBuffer, index int) any { //gd:TextServer.shaped_get_span_meta
	return any(Advanced(self).ShapedGetSpanMeta(RID.Any(shaped), int64(index)).Interface())
}

/*
Returns text embedded object key.
*/
func (self Instance) ShapedGetSpanEmbeddedObject(shaped RID.TextBuffer, index int) any { //gd:TextServer.shaped_get_span_embedded_object
	return any(Advanced(self).ShapedGetSpanEmbeddedObject(RID.Any(shaped), int64(index)).Interface())
}

/*
Changes text span font, font size, and OpenType features, without changing the text.
*/
func (self Instance) ShapedSetSpanUpdateFont(shaped RID.TextBuffer, index int, fonts [][]RID.Font, size int) { //gd:TextServer.shaped_set_span_update_font
	Advanced(self).ShapedSetSpanUpdateFont(RID.Any(shaped), int64(index), gd.ArrayFromSlice[Array.Contains[RID.Any]](fonts), int64(size), Dictionary.Nil)
}

/*
Changes text span font, font size, and OpenType features, without changing the text.
*/
func (self Expanded) ShapedSetSpanUpdateFont(shaped RID.TextBuffer, index int, fonts [][]RID.Font, size int, opentype_features map[string]string) { //gd:TextServer.shaped_set_span_update_font
	Advanced(self).ShapedSetSpanUpdateFont(RID.Any(shaped), int64(index), gd.ArrayFromSlice[Array.Contains[RID.Any]](fonts), int64(size), gd.DictionaryFromMap(opentype_features))
}

/*
Returns text buffer for the substring of the text in the [param shaped] text buffer (including inline objects).
*/
func (self Instance) ShapedTextSubstr(shaped RID.TextBuffer, start int, length int) RID.TextBuffer { //gd:TextServer.shaped_text_substr
	return RID.TextBuffer(Advanced(self).ShapedTextSubstr(RID.Any(shaped), int64(start), int64(length)))
}

/*
Returns the parent buffer from which the substring originates.
*/
func (self Instance) ShapedTextGetParent(shaped RID.TextBuffer) RID.TextBuffer { //gd:TextServer.shaped_text_get_parent
	return RID.TextBuffer(Advanced(self).ShapedTextGetParent(RID.Any(shaped)))
}

/*
Adjusts text width to fit to specified width, returns new text width.
*/
func (self Instance) ShapedTextFitToWidth(shaped RID.TextBuffer, width Float.X) Float.X { //gd:TextServer.shaped_text_fit_to_width
	return Float.X(Float.X(Advanced(self).ShapedTextFitToWidth(RID.Any(shaped), float64(width), 3)))
}

/*
Adjusts text width to fit to specified width, returns new text width.
*/
func (self Expanded) ShapedTextFitToWidth(shaped RID.TextBuffer, width Float.X, justification_flags JustificationFlag) Float.X { //gd:TextServer.shaped_text_fit_to_width
	return Float.X(Float.X(Advanced(self).ShapedTextFitToWidth(RID.Any(shaped), float64(width), justification_flags)))
}

/*
Aligns shaped text to the given tab-stops.
*/
func (self Instance) ShapedTextTabAlign(shaped RID.TextBuffer, tab_stops []float32) Float.X { //gd:TextServer.shaped_text_tab_align
	return Float.X(Float.X(Advanced(self).ShapedTextTabAlign(RID.Any(shaped), Packed.New(tab_stops...))))
}

/*
Shapes buffer if it's not shaped. Returns [code]true[/code] if the string is shaped successfully.
[b]Note:[/b] It is not necessary to call this function manually, buffer will be shaped automatically as soon as any of its output data is requested.
*/
func (self Instance) ShapedTextShape(shaped RID.TextBuffer) bool { //gd:TextServer.shaped_text_shape
	return bool(Advanced(self).ShapedTextShape(RID.Any(shaped)))
}

/*
Returns [code]true[/code] if buffer is successfully shaped.
*/
func (self Instance) ShapedTextIsReady(shaped RID.TextBuffer) bool { //gd:TextServer.shaped_text_is_ready
	return bool(Advanced(self).ShapedTextIsReady(RID.Any(shaped)))
}

/*
Returns [code]true[/code] if text buffer contains any visible characters.
*/
func (self Instance) ShapedTextHasVisibleChars(shaped RID.TextBuffer) bool { //gd:TextServer.shaped_text_has_visible_chars
	return bool(Advanced(self).ShapedTextHasVisibleChars(RID.Any(shaped)))
}

/*
Returns an array of glyphs in the visual order.
*/
func (self Instance) ShapedTextGetGlyphs(shaped RID.TextBuffer) []map[int]struct {
	X float32
	Y float32
} { //gd:TextServer.shaped_text_get_glyphs
	return []map[int]struct {
		X float32
		Y float32
	}(gd.ArrayAs[[]map[int]struct {
		X float32
		Y float32
	}](gd.InternalArray(Advanced(self).ShapedTextGetGlyphs(RID.Any(shaped)))))
}

/*
Returns text glyphs in the logical order.
*/
func (self Instance) ShapedTextSortLogical(shaped RID.TextBuffer) []map[int]int { //gd:TextServer.shaped_text_sort_logical
	return []map[int]int(gd.ArrayAs[[]map[int]int](gd.InternalArray(Advanced(self).ShapedTextSortLogical(RID.Any(shaped)))))
}

/*
Returns number of glyphs in the buffer.
*/
func (self Instance) ShapedTextGetGlyphCount(shaped RID.TextBuffer) int { //gd:TextServer.shaped_text_get_glyph_count
	return int(int(Advanced(self).ShapedTextGetGlyphCount(RID.Any(shaped))))
}

/*
Returns substring buffer character range in the parent buffer.
*/
func (self Instance) ShapedTextGetRange(shaped RID.TextBuffer) Vector2i.XY { //gd:TextServer.shaped_text_get_range
	return Vector2i.XY(Advanced(self).ShapedTextGetRange(RID.Any(shaped)))
}

/*
Breaks text to the lines and columns. Returns character ranges for each segment.
*/
func (self Instance) ShapedTextGetLineBreaksAdv(shaped RID.TextBuffer, width []float32) []int32 { //gd:TextServer.shaped_text_get_line_breaks_adv
	return []int32(slices.Collect(Advanced(self).ShapedTextGetLineBreaksAdv(RID.Any(shaped), Packed.New(width...), int64(0), true, 3).Values()))
}

/*
Breaks text to the lines and columns. Returns character ranges for each segment.
*/
func (self Expanded) ShapedTextGetLineBreaksAdv(shaped RID.TextBuffer, width []float32, start int, once bool, break_flags LineBreakFlag) []int32 { //gd:TextServer.shaped_text_get_line_breaks_adv
	return []int32(slices.Collect(Advanced(self).ShapedTextGetLineBreaksAdv(RID.Any(shaped), Packed.New(width...), int64(start), once, break_flags).Values()))
}

/*
Breaks text to the lines and returns character ranges for each line.
*/
func (self Instance) ShapedTextGetLineBreaks(shaped RID.TextBuffer, width Float.X) []int32 { //gd:TextServer.shaped_text_get_line_breaks
	return []int32(slices.Collect(Advanced(self).ShapedTextGetLineBreaks(RID.Any(shaped), float64(width), int64(0), 3).Values()))
}

/*
Breaks text to the lines and returns character ranges for each line.
*/
func (self Expanded) ShapedTextGetLineBreaks(shaped RID.TextBuffer, width Float.X, start int, break_flags LineBreakFlag) []int32 { //gd:TextServer.shaped_text_get_line_breaks
	return []int32(slices.Collect(Advanced(self).ShapedTextGetLineBreaks(RID.Any(shaped), float64(width), int64(start), break_flags).Values()))
}

/*
Breaks text into words and returns array of character ranges. Use [param grapheme_flags] to set what characters are used for breaking (see [enum GraphemeFlag]).
*/
func (self Instance) ShapedTextGetWordBreaks(shaped RID.TextBuffer) []int32 { //gd:TextServer.shaped_text_get_word_breaks
	return []int32(slices.Collect(Advanced(self).ShapedTextGetWordBreaks(RID.Any(shaped), 264, 4).Values()))
}

/*
Breaks text into words and returns array of character ranges. Use [param grapheme_flags] to set what characters are used for breaking (see [enum GraphemeFlag]).
*/
func (self Expanded) ShapedTextGetWordBreaks(shaped RID.TextBuffer, grapheme_flags GraphemeFlag, skip_grapheme_flags GraphemeFlag) []int32 { //gd:TextServer.shaped_text_get_word_breaks
	return []int32(slices.Collect(Advanced(self).ShapedTextGetWordBreaks(RID.Any(shaped), grapheme_flags, skip_grapheme_flags).Values()))
}

/*
Returns the position of the overrun trim.
*/
func (self Instance) ShapedTextGetTrimPos(shaped RID.TextBuffer) int { //gd:TextServer.shaped_text_get_trim_pos
	return int(int(Advanced(self).ShapedTextGetTrimPos(RID.Any(shaped))))
}

/*
Returns position of the ellipsis.
*/
func (self Instance) ShapedTextGetEllipsisPos(shaped RID.TextBuffer) int { //gd:TextServer.shaped_text_get_ellipsis_pos
	return int(int(Advanced(self).ShapedTextGetEllipsisPos(RID.Any(shaped))))
}

/*
Returns array of the glyphs in the ellipsis.
*/
func (self Instance) ShapedTextGetEllipsisGlyphs(shaped RID.TextBuffer) []map[int]struct {
	X float32
	Y float32
} { //gd:TextServer.shaped_text_get_ellipsis_glyphs
	return []map[int]struct {
		X float32
		Y float32
	}(gd.ArrayAs[[]map[int]struct {
		X float32
		Y float32
	}](gd.InternalArray(Advanced(self).ShapedTextGetEllipsisGlyphs(RID.Any(shaped)))))
}

/*
Returns number of glyphs in the ellipsis.
*/
func (self Instance) ShapedTextGetEllipsisGlyphCount(shaped RID.TextBuffer) int { //gd:TextServer.shaped_text_get_ellipsis_glyph_count
	return int(int(Advanced(self).ShapedTextGetEllipsisGlyphCount(RID.Any(shaped))))
}

/*
Trims text if it exceeds the given width.
*/
func (self Instance) ShapedTextOverrunTrimToWidth(shaped RID.TextBuffer) { //gd:TextServer.shaped_text_overrun_trim_to_width
	Advanced(self).ShapedTextOverrunTrimToWidth(RID.Any(shaped), float64(0), 0)
}

/*
Trims text if it exceeds the given width.
*/
func (self Expanded) ShapedTextOverrunTrimToWidth(shaped RID.TextBuffer, width Float.X, overrun_trim_flags TextOverrunFlag) { //gd:TextServer.shaped_text_overrun_trim_to_width
	Advanced(self).ShapedTextOverrunTrimToWidth(RID.Any(shaped), float64(width), overrun_trim_flags)
}

/*
Returns array of inline objects.
*/
func (self Instance) ShapedTextGetObjects(shaped RID.TextBuffer) []any { //gd:TextServer.shaped_text_get_objects
	return []any(gd.ArrayAs[[]any](gd.InternalArray(Advanced(self).ShapedTextGetObjects(RID.Any(shaped)))))
}

/*
Returns bounding rectangle of the inline object.
*/
func (self Instance) ShapedTextGetObjectRect(shaped RID.TextBuffer, key any) Rect2.PositionSize { //gd:TextServer.shaped_text_get_object_rect
	return Rect2.PositionSize(Advanced(self).ShapedTextGetObjectRect(RID.Any(shaped), variant.New(key)))
}

/*
Returns the character range of the inline object.
*/
func (self Instance) ShapedTextGetObjectRange(shaped RID.TextBuffer, key any) Vector2i.XY { //gd:TextServer.shaped_text_get_object_range
	return Vector2i.XY(Advanced(self).ShapedTextGetObjectRange(RID.Any(shaped), variant.New(key)))
}

/*
Returns the glyph index of the inline object.
*/
func (self Instance) ShapedTextGetObjectGlyph(shaped RID.TextBuffer, key any) int { //gd:TextServer.shaped_text_get_object_glyph
	return int(int(Advanced(self).ShapedTextGetObjectGlyph(RID.Any(shaped), variant.New(key))))
}

/*
Returns size of the text.
*/
func (self Instance) ShapedTextGetSize(shaped RID.TextBuffer) Vector2.XY { //gd:TextServer.shaped_text_get_size
	return Vector2.XY(Advanced(self).ShapedTextGetSize(RID.Any(shaped)))
}

/*
Returns the text ascent (number of pixels above the baseline for horizontal layout or to the left of baseline for vertical).
[b]Note:[/b] Overall ascent can be higher than font ascent, if some glyphs are displaced from the baseline.
*/
func (self Instance) ShapedTextGetAscent(shaped RID.TextBuffer) Float.X { //gd:TextServer.shaped_text_get_ascent
	return Float.X(Float.X(Advanced(self).ShapedTextGetAscent(RID.Any(shaped))))
}

/*
Returns the text descent (number of pixels below the baseline for horizontal layout or to the right of baseline for vertical).
[b]Note:[/b] Overall descent can be higher than font descent, if some glyphs are displaced from the baseline.
*/
func (self Instance) ShapedTextGetDescent(shaped RID.TextBuffer) Float.X { //gd:TextServer.shaped_text_get_descent
	return Float.X(Float.X(Advanced(self).ShapedTextGetDescent(RID.Any(shaped))))
}

/*
Returns width (for horizontal layout) or height (for vertical) of the text.
*/
func (self Instance) ShapedTextGetWidth(shaped RID.TextBuffer) Float.X { //gd:TextServer.shaped_text_get_width
	return Float.X(Float.X(Advanced(self).ShapedTextGetWidth(RID.Any(shaped))))
}

/*
Returns pixel offset of the underline below the baseline.
*/
func (self Instance) ShapedTextGetUnderlinePosition(shaped RID.TextBuffer) Float.X { //gd:TextServer.shaped_text_get_underline_position
	return Float.X(Float.X(Advanced(self).ShapedTextGetUnderlinePosition(RID.Any(shaped))))
}

/*
Returns thickness of the underline.
*/
func (self Instance) ShapedTextGetUnderlineThickness(shaped RID.TextBuffer) Float.X { //gd:TextServer.shaped_text_get_underline_thickness
	return Float.X(Float.X(Advanced(self).ShapedTextGetUnderlineThickness(RID.Any(shaped))))
}

/*
Returns shapes of the carets corresponding to the character offset [param position] in the text. Returned caret shape is 1 pixel wide rectangle.
*/
func (self Instance) ShapedTextGetCarets(shaped RID.TextBuffer, position int) map[int]struct {
	X float32
	Y float32
} { //gd:TextServer.shaped_text_get_carets
	return map[int]struct {
		X float32
		Y float32
	}(gd.DictionaryAs[map[int]struct {
		X float32
		Y float32
	}](Advanced(self).ShapedTextGetCarets(RID.Any(shaped), int64(position))))
}

/*
Returns selection rectangles for the specified character range.
*/
func (self Instance) ShapedTextGetSelection(shaped RID.TextBuffer, start int, end int) []Vector2.XY { //gd:TextServer.shaped_text_get_selection
	return []Vector2.XY(slices.Collect(Advanced(self).ShapedTextGetSelection(RID.Any(shaped), int64(start), int64(end)).Values()))
}

/*
Returns grapheme index at the specified pixel offset at the baseline, or [code]-1[/code] if none is found.
*/
func (self Instance) ShapedTextHitTestGrapheme(shaped RID.TextBuffer, coords Float.X) int { //gd:TextServer.shaped_text_hit_test_grapheme
	return int(int(Advanced(self).ShapedTextHitTestGrapheme(RID.Any(shaped), float64(coords))))
}

/*
Returns caret character offset at the specified pixel offset at the baseline. This function always returns a valid position.
*/
func (self Instance) ShapedTextHitTestPosition(shaped RID.TextBuffer, coords Float.X) int { //gd:TextServer.shaped_text_hit_test_position
	return int(int(Advanced(self).ShapedTextHitTestPosition(RID.Any(shaped), float64(coords))))
}

/*
Returns composite character's bounds as offsets from the start of the line.
*/
func (self Instance) ShapedTextGetGraphemeBounds(shaped RID.TextBuffer, pos int) Vector2.XY { //gd:TextServer.shaped_text_get_grapheme_bounds
	return Vector2.XY(Advanced(self).ShapedTextGetGraphemeBounds(RID.Any(shaped), int64(pos)))
}

/*
Returns grapheme end position closest to the [param pos].
*/
func (self Instance) ShapedTextNextGraphemePos(shaped RID.TextBuffer, pos int) int { //gd:TextServer.shaped_text_next_grapheme_pos
	return int(int(Advanced(self).ShapedTextNextGraphemePos(RID.Any(shaped), int64(pos))))
}

/*
Returns grapheme start position closest to the [param pos].
*/
func (self Instance) ShapedTextPrevGraphemePos(shaped RID.TextBuffer, pos int) int { //gd:TextServer.shaped_text_prev_grapheme_pos
	return int(int(Advanced(self).ShapedTextPrevGraphemePos(RID.Any(shaped), int64(pos))))
}

/*
Returns array of the composite character boundaries.
*/
func (self Instance) ShapedTextGetCharacterBreaks(shaped RID.TextBuffer) []int32 { //gd:TextServer.shaped_text_get_character_breaks
	return []int32(slices.Collect(Advanced(self).ShapedTextGetCharacterBreaks(RID.Any(shaped)).Values()))
}

/*
Returns composite character end position closest to the [param pos].
*/
func (self Instance) ShapedTextNextCharacterPos(shaped RID.TextBuffer, pos int) int { //gd:TextServer.shaped_text_next_character_pos
	return int(int(Advanced(self).ShapedTextNextCharacterPos(RID.Any(shaped), int64(pos))))
}

/*
Returns composite character start position closest to the [param pos].
*/
func (self Instance) ShapedTextPrevCharacterPos(shaped RID.TextBuffer, pos int) int { //gd:TextServer.shaped_text_prev_character_pos
	return int(int(Advanced(self).ShapedTextPrevCharacterPos(RID.Any(shaped), int64(pos))))
}

/*
Returns composite character position closest to the [param pos].
*/
func (self Instance) ShapedTextClosestCharacterPos(shaped RID.TextBuffer, pos int) int { //gd:TextServer.shaped_text_closest_character_pos
	return int(int(Advanced(self).ShapedTextClosestCharacterPos(RID.Any(shaped), int64(pos))))
}

/*
Draw shaped text into a canvas item at a given position, with [param color]. [param pos] specifies the leftmost point of the baseline (for horizontal layout) or topmost point of the baseline (for vertical layout).
*/
func (self Instance) ShapedTextDraw(shaped RID.TextBuffer, canvas RID.Canvas, pos Vector2.XY) { //gd:TextServer.shaped_text_draw
	Advanced(self).ShapedTextDraw(RID.Any(shaped), RID.Any(canvas), Vector2.XY(pos), float64(-1), float64(-1), Color.RGBA(gd.Color{1, 1, 1, 1}))
}

/*
Draw shaped text into a canvas item at a given position, with [param color]. [param pos] specifies the leftmost point of the baseline (for horizontal layout) or topmost point of the baseline (for vertical layout).
*/
func (self Expanded) ShapedTextDraw(shaped RID.TextBuffer, canvas RID.Canvas, pos Vector2.XY, clip_l Float.X, clip_r Float.X, color Color.RGBA) { //gd:TextServer.shaped_text_draw
	Advanced(self).ShapedTextDraw(RID.Any(shaped), RID.Any(canvas), Vector2.XY(pos), float64(clip_l), float64(clip_r), Color.RGBA(color))
}

/*
Draw the outline of the shaped text into a canvas item at a given position, with [param color]. [param pos] specifies the leftmost point of the baseline (for horizontal layout) or topmost point of the baseline (for vertical layout).
*/
func (self Instance) ShapedTextDrawOutline(shaped RID.TextBuffer, canvas RID.Canvas, pos Vector2.XY) { //gd:TextServer.shaped_text_draw_outline
	Advanced(self).ShapedTextDrawOutline(RID.Any(shaped), RID.Any(canvas), Vector2.XY(pos), float64(-1), float64(-1), int64(1), Color.RGBA(gd.Color{1, 1, 1, 1}))
}

/*
Draw the outline of the shaped text into a canvas item at a given position, with [param color]. [param pos] specifies the leftmost point of the baseline (for horizontal layout) or topmost point of the baseline (for vertical layout).
*/
func (self Expanded) ShapedTextDrawOutline(shaped RID.TextBuffer, canvas RID.Canvas, pos Vector2.XY, clip_l Float.X, clip_r Float.X, outline_size int, color Color.RGBA) { //gd:TextServer.shaped_text_draw_outline
	Advanced(self).ShapedTextDrawOutline(RID.Any(shaped), RID.Any(canvas), Vector2.XY(pos), float64(clip_l), float64(clip_r), int64(outline_size), Color.RGBA(color))
}

/*
Returns dominant direction of in the range of text.
*/
func (self Instance) ShapedTextGetDominantDirectionInRange(shaped RID.TextBuffer, start int, end int) Direction { //gd:TextServer.shaped_text_get_dominant_direction_in_range
	return Direction(Advanced(self).ShapedTextGetDominantDirectionInRange(RID.Any(shaped), int64(start), int64(end)))
}

/*
Converts a number from the Western Arabic (0..9) to the numeral systems used in [param language].
If [param language] is omitted, the active locale will be used.
*/
func (self Instance) FormatNumber(number string) string { //gd:TextServer.format_number
	return string(Advanced(self).FormatNumber(String.New(number), String.New("")).String())
}

/*
Converts a number from the Western Arabic (0..9) to the numeral systems used in [param language].
If [param language] is omitted, the active locale will be used.
*/
func (self Expanded) FormatNumber(number string, language string) string { //gd:TextServer.format_number
	return string(Advanced(self).FormatNumber(String.New(number), String.New(language)).String())
}

/*
Converts [param number] from the numeral systems used in [param language] to Western Arabic (0..9).
*/
func (self Instance) ParseNumber(number string) string { //gd:TextServer.parse_number
	return string(Advanced(self).ParseNumber(String.New(number), String.New("")).String())
}

/*
Converts [param number] from the numeral systems used in [param language] to Western Arabic (0..9).
*/
func (self Expanded) ParseNumber(number string, language string) string { //gd:TextServer.parse_number
	return string(Advanced(self).ParseNumber(String.New(number), String.New(language)).String())
}

/*
Returns percent sign used in the [param language].
*/
func (self Instance) PercentSign() string { //gd:TextServer.percent_sign
	return string(Advanced(self).PercentSign(String.New("")).String())
}

/*
Returns percent sign used in the [param language].
*/
func (self Expanded) PercentSign(language string) string { //gd:TextServer.percent_sign
	return string(Advanced(self).PercentSign(String.New(language)).String())
}

/*
Returns an array of the word break boundaries. Elements in the returned array are the offsets of the start and end of words. Therefore the length of the array is always even.
When [param chars_per_line] is greater than zero, line break boundaries are returned instead.
[codeblock]
var ts = TextServerManager.get_primary_interface()
# Corresponds to the substrings "The", "Godot", "Engine", and "4".
print(ts.string_get_word_breaks("The Godot Engine, 4")) # Prints [0, 3, 4, 9, 10, 16, 18, 19]
# Corresponds to the substrings "The", "Godot", "Engin", and "e, 4".
print(ts.string_get_word_breaks("The Godot Engine, 4", "en", 5)) # Prints [0, 3, 4, 9, 10, 15, 15, 19]
# Corresponds to the substrings "The Godot" and "Engine, 4".
print(ts.string_get_word_breaks("The Godot Engine, 4", "en", 10)) # Prints [0, 9, 10, 19]
[/codeblock]
*/
func (self Instance) StringGetWordBreaks(s string) []int32 { //gd:TextServer.string_get_word_breaks
	return []int32(slices.Collect(Advanced(self).StringGetWordBreaks(String.New(s), String.New(""), int64(0)).Values()))
}

/*
Returns an array of the word break boundaries. Elements in the returned array are the offsets of the start and end of words. Therefore the length of the array is always even.
When [param chars_per_line] is greater than zero, line break boundaries are returned instead.
[codeblock]
var ts = TextServerManager.get_primary_interface()
# Corresponds to the substrings "The", "Godot", "Engine", and "4".
print(ts.string_get_word_breaks("The Godot Engine, 4")) # Prints [0, 3, 4, 9, 10, 16, 18, 19]
# Corresponds to the substrings "The", "Godot", "Engin", and "e, 4".
print(ts.string_get_word_breaks("The Godot Engine, 4", "en", 5)) # Prints [0, 3, 4, 9, 10, 15, 15, 19]
# Corresponds to the substrings "The Godot" and "Engine, 4".
print(ts.string_get_word_breaks("The Godot Engine, 4", "en", 10)) # Prints [0, 9, 10, 19]
[/codeblock]
*/
func (self Expanded) StringGetWordBreaks(s string, language string, chars_per_line int) []int32 { //gd:TextServer.string_get_word_breaks
	return []int32(slices.Collect(Advanced(self).StringGetWordBreaks(String.New(s), String.New(language), int64(chars_per_line)).Values()))
}

/*
Returns array of the composite character boundaries.
[codeblock]
var ts = TextServerManager.get_primary_interface()
print(ts.string_get_character_breaks("Test  Test")) # Prints [1, 2, 3, 4, 5, 9, 10, 11, 12, 13, 14]
[/codeblock]
*/
func (self Instance) StringGetCharacterBreaks(s string) []int32 { //gd:TextServer.string_get_character_breaks
	return []int32(slices.Collect(Advanced(self).StringGetCharacterBreaks(String.New(s), String.New("")).Values()))
}

/*
Returns array of the composite character boundaries.
[codeblock]
var ts = TextServerManager.get_primary_interface()
print(ts.string_get_character_breaks("Test  Test")) # Prints [1, 2, 3, 4, 5, 9, 10, 11, 12, 13, 14]
[/codeblock]
*/
func (self Expanded) StringGetCharacterBreaks(s string, language string) []int32 { //gd:TextServer.string_get_character_breaks
	return []int32(slices.Collect(Advanced(self).StringGetCharacterBreaks(String.New(s), String.New(language)).Values()))
}

/*
Returns index of the first string in [param dict] which is visually confusable with the [param string], or [code]-1[/code] if none is found.
[b]Note:[/b] This method doesn't detect invisible characters, for spoof detection use it in combination with [method spoof_check].
[b]Note:[/b] Always returns [code]-1[/code] if the server does not support the [constant FEATURE_UNICODE_SECURITY] feature.
*/
func (self Instance) IsConfusable(s string, dict []string) int { //gd:TextServer.is_confusable
	return int(int(Advanced(self).IsConfusable(String.New(s), Packed.MakeStrings(dict...))))
}

/*
Returns [code]true[/code] if [param string] is likely to be an attempt at confusing the reader.
[b]Note:[/b] Always returns [code]false[/code] if the server does not support the [constant FEATURE_UNICODE_SECURITY] feature.
*/
func (self Instance) SpoofCheck(s string) bool { //gd:TextServer.spoof_check
	return bool(Advanced(self).SpoofCheck(String.New(s)))
}

/*
Strips diacritics from the string.
[b]Note:[/b] The result may be longer or shorter than the original.
*/
func (self Instance) StripDiacritics(s string) string { //gd:TextServer.strip_diacritics
	return string(Advanced(self).StripDiacritics(String.New(s)).String())
}

/*
Returns [code]true[/code] if [param string] is a valid identifier.
If the text server supports the [constant FEATURE_UNICODE_IDENTIFIERS] feature, a valid identifier must:
- Conform to normalization form C.
- Begin with a Unicode character of class XID_Start or [code]"_"[/code].
- May contain Unicode characters of class XID_Continue in the other positions.
- Use UAX #31 recommended scripts only (mixed scripts are allowed).
If the [constant FEATURE_UNICODE_IDENTIFIERS] feature is not supported, a valid identifier must:
- Begin with a Unicode character of class XID_Start or [code]"_"[/code].
- May contain Unicode characters of class XID_Continue in the other positions.
*/
func (self Instance) IsValidIdentifier(s string) bool { //gd:TextServer.is_valid_identifier
	return bool(Advanced(self).IsValidIdentifier(String.New(s)))
}

/*
Returns [code]true[/code] if the given code point is a valid letter, i.e. it belongs to the Unicode category "L".
*/
func (self Instance) IsValidLetter(unicode int) bool { //gd:TextServer.is_valid_letter
	return bool(Advanced(self).IsValidLetter(int64(unicode)))
}

/*
Returns the string converted to uppercase.
[b]Note:[/b] Casing is locale dependent and context sensitive if server support [constant FEATURE_CONTEXT_SENSITIVE_CASE_CONVERSION] feature (supported by [TextServerAdvanced]).
[b]Note:[/b] The result may be longer or shorter than the original.
*/
func (self Instance) StringToUpper(s string) string { //gd:TextServer.string_to_upper
	return string(Advanced(self).StringToUpper(String.New(s), String.New("")).String())
}

/*
Returns the string converted to uppercase.
[b]Note:[/b] Casing is locale dependent and context sensitive if server support [constant FEATURE_CONTEXT_SENSITIVE_CASE_CONVERSION] feature (supported by [TextServerAdvanced]).
[b]Note:[/b] The result may be longer or shorter than the original.
*/
func (self Expanded) StringToUpper(s string, language string) string { //gd:TextServer.string_to_upper
	return string(Advanced(self).StringToUpper(String.New(s), String.New(language)).String())
}

/*
Returns the string converted to lowercase.
[b]Note:[/b] Casing is locale dependent and context sensitive if server support [constant FEATURE_CONTEXT_SENSITIVE_CASE_CONVERSION] feature (supported by [TextServerAdvanced]).
[b]Note:[/b] The result may be longer or shorter than the original.
*/
func (self Instance) StringToLower(s string) string { //gd:TextServer.string_to_lower
	return string(Advanced(self).StringToLower(String.New(s), String.New("")).String())
}

/*
Returns the string converted to lowercase.
[b]Note:[/b] Casing is locale dependent and context sensitive if server support [constant FEATURE_CONTEXT_SENSITIVE_CASE_CONVERSION] feature (supported by [TextServerAdvanced]).
[b]Note:[/b] The result may be longer or shorter than the original.
*/
func (self Expanded) StringToLower(s string, language string) string { //gd:TextServer.string_to_lower
	return string(Advanced(self).StringToLower(String.New(s), String.New(language)).String())
}

/*
Returns the string converted to title case.
[b]Note:[/b] Casing is locale dependent and context sensitive if server support [constant FEATURE_CONTEXT_SENSITIVE_CASE_CONVERSION] feature (supported by [TextServerAdvanced]).
[b]Note:[/b] The result may be longer or shorter than the original.
*/
func (self Instance) StringToTitle(s string) string { //gd:TextServer.string_to_title
	return string(Advanced(self).StringToTitle(String.New(s), String.New("")).String())
}

/*
Returns the string converted to title case.
[b]Note:[/b] Casing is locale dependent and context sensitive if server support [constant FEATURE_CONTEXT_SENSITIVE_CASE_CONVERSION] feature (supported by [TextServerAdvanced]).
[b]Note:[/b] The result may be longer or shorter than the original.
*/
func (self Expanded) StringToTitle(s string, language string) string { //gd:TextServer.string_to_title
	return string(Advanced(self).StringToTitle(String.New(s), String.New(language)).String())
}

/*
Default implementation of the BiDi algorithm override function. See [enum StructuredTextParser] for more info.
*/
func (self Instance) ParseStructuredText(parser_type StructuredTextParser, args []any, text string) []Vector3i.XYZ { //gd:TextServer.parse_structured_text
	return []Vector3i.XYZ(gd.ArrayAs[[]Vector3i.XYZ](gd.InternalArray(Advanced(self).ParseStructuredText(parser_type, gd.EngineArrayFromSlice(args), String.New(text)))))
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.TextServer

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.TextServer)(unsafe.Pointer(&obj))
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.TextServer)(unsafe.Pointer(&obj))
		return true
	}
	return false
}

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {

	if !gd.Linked {
		var placeholder Instance
		*(*gd.Object)(unsafe.Pointer(&placeholder)) = pointers.Add[gd.Object]([3]uint64{})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(*(*gd.Object)(unsafe.Pointer(&placeholder)), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	object := [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})}
	casted := Instance{*(*gdclass.TextServer)(unsafe.Pointer(&object))}
	object[0].Notification(0, false)
	return casted
}

/*
Returns [code]true[/code] if the server supports a feature.
*/
//go:nosplit
func (self class) HasFeature(feature Feature) bool { //gd:TextServer.has_feature
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.has_feature, gdextension.SizeBool|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ feature Feature }{feature}))
	var ret = r_ret
	return ret
}

/*
Returns the name of the server interface.
*/
//go:nosplit
func (self class) GetName() String.Readable { //gd:TextServer.get_name
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_name, gdextension.SizeString, unsafe.Pointer(&struct{}{}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Returns text server features, see [enum Feature].
*/
//go:nosplit
func (self class) GetFeatures() int64 { //gd:TextServer.get_features
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_features, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Loads optional TextServer database (e.g. ICU break iterators and dictionaries).
[b]Note:[/b] This function should be called before any other TextServer functions used, otherwise it won't have any effect.
*/
//go:nosplit
func (self class) LoadSupportData(filename String.Readable) bool { //gd:TextServer.load_support_data
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.load_support_data, gdextension.SizeBool|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ filename gdextension.String }{pointers.Get(gd.InternalString(filename))}))
	var ret = r_ret
	return ret
}

/*
Returns default TextServer database (e.g. ICU break iterators and dictionaries) filename.
*/
//go:nosplit
func (self class) GetSupportDataFilename() String.Readable { //gd:TextServer.get_support_data_filename
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_support_data_filename, gdextension.SizeString, unsafe.Pointer(&struct{}{}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Returns TextServer database (e.g. ICU break iterators and dictionaries) description.
*/
//go:nosplit
func (self class) GetSupportDataInfo() String.Readable { //gd:TextServer.get_support_data_info
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.get_support_data_info, gdextension.SizeString, unsafe.Pointer(&struct{}{}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Saves optional TextServer database (e.g. ICU break iterators and dictionaries) to the file.
[b]Note:[/b] This function is used by during project export, to include TextServer database.
*/
//go:nosplit
func (self class) SaveSupportData(filename String.Readable) bool { //gd:TextServer.save_support_data
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.save_support_data, gdextension.SizeBool|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ filename gdextension.String }{pointers.Get(gd.InternalString(filename))}))
	var ret = r_ret
	return ret
}

/*
Returns default TextServer database (e.g. ICU break iterators and dictionaries).
*/
//go:nosplit
func (self class) GetSupportData() Packed.Bytes { //gd:TextServer.get_support_data
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.get_support_data, gdextension.SizePackedArray, unsafe.Pointer(&struct{}{}))
	var ret = Packed.Bytes(Array.Through(gd.PackedProxy[gd.PackedByteArray, byte]{}, pointers.Pack(pointers.Let[gd.PackedByteArray](r_ret))))
	return ret
}

/*
Returns [code]true[/code] if locale is right-to-left.
*/
//go:nosplit
func (self class) IsLocaleRightToLeft(locale String.Readable) bool { //gd:TextServer.is_locale_right_to_left
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_locale_right_to_left, gdextension.SizeBool|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ locale gdextension.String }{pointers.Get(gd.InternalString(locale))}))
	var ret = r_ret
	return ret
}

/*
Converts readable feature, variation, script, or language name to OpenType tag.
*/
//go:nosplit
func (self class) NameToTag(name String.Readable) int64 { //gd:TextServer.name_to_tag
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.name_to_tag, gdextension.SizeInt|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ name gdextension.String }{pointers.Get(gd.InternalString(name))}))
	var ret = r_ret
	return ret
}

/*
Converts OpenType tag to readable feature, variation, script, or language name.
*/
//go:nosplit
func (self class) TagToName(tag int64) String.Readable { //gd:TextServer.tag_to_name
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.tag_to_name, gdextension.SizeString|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ tag int64 }{tag}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Returns [code]true[/code] if [param rid] is valid resource owned by this text server.
*/
//go:nosplit
func (self class) Has(rid RID.Any) bool { //gd:TextServer.has
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.has, gdextension.SizeBool|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ rid RID.Any }{rid}))
	var ret = r_ret
	return ret
}

/*
Frees an object created by this [TextServer].
*/
//go:nosplit
func (self class) FreeRid(rid RID.Any) { //gd:TextServer.free_rid
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.free_rid, 0|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ rid RID.Any }{rid}))
}

/*
Creates a new, empty font cache entry resource. To free the resulting resource, use the [method free_rid] method.
*/
//go:nosplit
func (self class) CreateFont() RID.Any { //gd:TextServer.create_font
	var r_ret = gdextension.Call[RID.Any](gd.ObjectChecked(self.AsObject()), methods.create_font, gdextension.SizeRID, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Creates a new variation existing font which is reusing the same glyph cache and font data. To free the resulting resource, use the [method free_rid] method.
*/
//go:nosplit
func (self class) CreateFontLinkedVariation(font_rid RID.Any) RID.Any { //gd:TextServer.create_font_linked_variation
	var r_ret = gdextension.Call[RID.Any](gd.ObjectChecked(self.AsObject()), methods.create_font_linked_variation, gdextension.SizeRID|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ font_rid RID.Any }{font_rid}))
	var ret = r_ret
	return ret
}

/*
Sets font source data, e.g contents of the dynamic font source file.
*/
//go:nosplit
func (self class) FontSetData(font_rid RID.Any, data Packed.Bytes) { //gd:TextServer.font_set_data
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.font_set_data, 0|(gdextension.SizeRID<<4)|(gdextension.SizePackedArray<<8), unsafe.Pointer(&struct {
		font_rid RID.Any
		data     gdextension.PackedArray[byte]
	}{font_rid, pointers.Get(gd.InternalPacked[gd.PackedByteArray, byte](Packed.Array[byte](data)))}))
}

/*
Sets an active face index in the TrueType / OpenType collection.
*/
//go:nosplit
func (self class) FontSetFaceIndex(font_rid RID.Any, face_index int64) { //gd:TextServer.font_set_face_index
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.font_set_face_index, 0|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		font_rid   RID.Any
		face_index int64
	}{font_rid, face_index}))
}

/*
Returns an active face index in the TrueType / OpenType collection.
*/
//go:nosplit
func (self class) FontGetFaceIndex(font_rid RID.Any) int64 { //gd:TextServer.font_get_face_index
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.font_get_face_index, gdextension.SizeInt|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ font_rid RID.Any }{font_rid}))
	var ret = r_ret
	return ret
}

/*
Returns number of faces in the TrueType / OpenType collection.
*/
//go:nosplit
func (self class) FontGetFaceCount(font_rid RID.Any) int64 { //gd:TextServer.font_get_face_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.font_get_face_count, gdextension.SizeInt|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ font_rid RID.Any }{font_rid}))
	var ret = r_ret
	return ret
}

/*
Sets the font style flags, see [enum FontStyle].
[b]Note:[/b] This value is used for font matching only and will not affect font rendering. Use [method font_set_face_index], [method font_set_variation_coordinates], [method font_set_embolden], or [method font_set_transform] instead.
*/
//go:nosplit
func (self class) FontSetStyle(font_rid RID.Any, style FontStyle) { //gd:TextServer.font_set_style
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.font_set_style, 0|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		font_rid RID.Any
		style    FontStyle
	}{font_rid, style}))
}

/*
Returns font style flags, see [enum FontStyle].
*/
//go:nosplit
func (self class) FontGetStyle(font_rid RID.Any) FontStyle { //gd:TextServer.font_get_style
	var r_ret = gdextension.Call[FontStyle](gd.ObjectChecked(self.AsObject()), methods.font_get_style, gdextension.SizeInt|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ font_rid RID.Any }{font_rid}))
	var ret = r_ret
	return ret
}

/*
Sets the font family name.
*/
//go:nosplit
func (self class) FontSetName(font_rid RID.Any, name String.Readable) { //gd:TextServer.font_set_name
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.font_set_name, 0|(gdextension.SizeRID<<4)|(gdextension.SizeString<<8), unsafe.Pointer(&struct {
		font_rid RID.Any
		name     gdextension.String
	}{font_rid, pointers.Get(gd.InternalString(name))}))
}

/*
Returns font family name.
*/
//go:nosplit
func (self class) FontGetName(font_rid RID.Any) String.Readable { //gd:TextServer.font_get_name
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.font_get_name, gdextension.SizeString|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ font_rid RID.Any }{font_rid}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Returns [Dictionary] with OpenType font name strings (localized font names, version, description, license information, sample text, etc.).
*/
//go:nosplit
func (self class) FontGetOtNameStrings(font_rid RID.Any) Dictionary.Any { //gd:TextServer.font_get_ot_name_strings
	var r_ret = gdextension.Call[gdextension.Dictionary](gd.ObjectChecked(self.AsObject()), methods.font_get_ot_name_strings, gdextension.SizeDictionary|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ font_rid RID.Any }{font_rid}))
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret)))
	return ret
}

/*
Sets the font style name.
*/
//go:nosplit
func (self class) FontSetStyleName(font_rid RID.Any, name String.Readable) { //gd:TextServer.font_set_style_name
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.font_set_style_name, 0|(gdextension.SizeRID<<4)|(gdextension.SizeString<<8), unsafe.Pointer(&struct {
		font_rid RID.Any
		name     gdextension.String
	}{font_rid, pointers.Get(gd.InternalString(name))}))
}

/*
Returns font style name.
*/
//go:nosplit
func (self class) FontGetStyleName(font_rid RID.Any) String.Readable { //gd:TextServer.font_get_style_name
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.font_get_style_name, gdextension.SizeString|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ font_rid RID.Any }{font_rid}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Sets weight (boldness) of the font. A value in the [code]100...999[/code] range, normal font weight is [code]400[/code], bold font weight is [code]700[/code].
[b]Note:[/b] This value is used for font matching only and will not affect font rendering. Use [method font_set_face_index], [method font_set_variation_coordinates], or [method font_set_embolden] instead.
*/
//go:nosplit
func (self class) FontSetWeight(font_rid RID.Any, weight int64) { //gd:TextServer.font_set_weight
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.font_set_weight, 0|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		font_rid RID.Any
		weight   int64
	}{font_rid, weight}))
}

/*
Returns weight (boldness) of the font. A value in the [code]100...999[/code] range, normal font weight is [code]400[/code], bold font weight is [code]700[/code].
*/
//go:nosplit
func (self class) FontGetWeight(font_rid RID.Any) int64 { //gd:TextServer.font_get_weight
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.font_get_weight, gdextension.SizeInt|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ font_rid RID.Any }{font_rid}))
	var ret = r_ret
	return ret
}

/*
Sets font stretch amount, compared to a normal width. A percentage value between [code]50%[/code] and [code]200%[/code].
[b]Note:[/b] This value is used for font matching only and will not affect font rendering. Use [method font_set_face_index], [method font_set_variation_coordinates], or [method font_set_transform] instead.
*/
//go:nosplit
func (self class) FontSetStretch(font_rid RID.Any, weight int64) { //gd:TextServer.font_set_stretch
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.font_set_stretch, 0|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		font_rid RID.Any
		weight   int64
	}{font_rid, weight}))
}

/*
Returns font stretch amount, compared to a normal width. A percentage value between [code]50%[/code] and [code]200%[/code].
*/
//go:nosplit
func (self class) FontGetStretch(font_rid RID.Any) int64 { //gd:TextServer.font_get_stretch
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.font_get_stretch, gdextension.SizeInt|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ font_rid RID.Any }{font_rid}))
	var ret = r_ret
	return ret
}

/*
Sets font anti-aliasing mode.
*/
//go:nosplit
func (self class) FontSetAntialiasing(font_rid RID.Any, antialiasing FontAntialiasing) { //gd:TextServer.font_set_antialiasing
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.font_set_antialiasing, 0|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		font_rid     RID.Any
		antialiasing FontAntialiasing
	}{font_rid, antialiasing}))
}

/*
Returns font anti-aliasing mode.
*/
//go:nosplit
func (self class) FontGetAntialiasing(font_rid RID.Any) FontAntialiasing { //gd:TextServer.font_get_antialiasing
	var r_ret = gdextension.Call[FontAntialiasing](gd.ObjectChecked(self.AsObject()), methods.font_get_antialiasing, gdextension.SizeInt|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ font_rid RID.Any }{font_rid}))
	var ret = r_ret
	return ret
}

/*
If set to [code]true[/code], embedded font bitmap loading is disabled (bitmap-only and color fonts ignore this property).
*/
//go:nosplit
func (self class) FontSetDisableEmbeddedBitmaps(font_rid RID.Any, disable_embedded_bitmaps bool) { //gd:TextServer.font_set_disable_embedded_bitmaps
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.font_set_disable_embedded_bitmaps, 0|(gdextension.SizeRID<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		font_rid                 RID.Any
		disable_embedded_bitmaps bool
	}{font_rid, disable_embedded_bitmaps}))
}

/*
Returns whether the font's embedded bitmap loading is disabled.
*/
//go:nosplit
func (self class) FontGetDisableEmbeddedBitmaps(font_rid RID.Any) bool { //gd:TextServer.font_get_disable_embedded_bitmaps
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.font_get_disable_embedded_bitmaps, gdextension.SizeBool|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ font_rid RID.Any }{font_rid}))
	var ret = r_ret
	return ret
}

/*
If set to [code]true[/code] font texture mipmap generation is enabled.
*/
//go:nosplit
func (self class) FontSetGenerateMipmaps(font_rid RID.Any, generate_mipmaps bool) { //gd:TextServer.font_set_generate_mipmaps
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.font_set_generate_mipmaps, 0|(gdextension.SizeRID<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		font_rid         RID.Any
		generate_mipmaps bool
	}{font_rid, generate_mipmaps}))
}

/*
Returns [code]true[/code] if font texture mipmap generation is enabled.
*/
//go:nosplit
func (self class) FontGetGenerateMipmaps(font_rid RID.Any) bool { //gd:TextServer.font_get_generate_mipmaps
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.font_get_generate_mipmaps, gdextension.SizeBool|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ font_rid RID.Any }{font_rid}))
	var ret = r_ret
	return ret
}

/*
If set to [code]true[/code], glyphs of all sizes are rendered using single multichannel signed distance field generated from the dynamic font vector data. MSDF rendering allows displaying the font at any scaling factor without blurriness, and without incurring a CPU cost when the font size changes (since the font no longer needs to be rasterized on the CPU). As a downside, font hinting is not available with MSDF. The lack of font hinting may result in less crisp and less readable fonts at small sizes.
[b]Note:[/b] MSDF font rendering does not render glyphs with overlapping shapes correctly. Overlapping shapes are not valid per the OpenType standard, but are still commonly found in many font files, especially those converted by Google Fonts. To avoid issues with overlapping glyphs, consider downloading the font file directly from the type foundry instead of relying on Google Fonts.
*/
//go:nosplit
func (self class) FontSetMultichannelSignedDistanceField(font_rid RID.Any, msdf bool) { //gd:TextServer.font_set_multichannel_signed_distance_field
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.font_set_multichannel_signed_distance_field, 0|(gdextension.SizeRID<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		font_rid RID.Any
		msdf     bool
	}{font_rid, msdf}))
}

/*
Returns [code]true[/code] if glyphs of all sizes are rendered using single multichannel signed distance field generated from the dynamic font vector data.
*/
//go:nosplit
func (self class) FontIsMultichannelSignedDistanceField(font_rid RID.Any) bool { //gd:TextServer.font_is_multichannel_signed_distance_field
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.font_is_multichannel_signed_distance_field, gdextension.SizeBool|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ font_rid RID.Any }{font_rid}))
	var ret = r_ret
	return ret
}

/*
Sets the width of the range around the shape between the minimum and maximum representable signed distance.
*/
//go:nosplit
func (self class) FontSetMsdfPixelRange(font_rid RID.Any, msdf_pixel_range int64) { //gd:TextServer.font_set_msdf_pixel_range
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.font_set_msdf_pixel_range, 0|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		font_rid         RID.Any
		msdf_pixel_range int64
	}{font_rid, msdf_pixel_range}))
}

/*
Returns the width of the range around the shape between the minimum and maximum representable signed distance.
*/
//go:nosplit
func (self class) FontGetMsdfPixelRange(font_rid RID.Any) int64 { //gd:TextServer.font_get_msdf_pixel_range
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.font_get_msdf_pixel_range, gdextension.SizeInt|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ font_rid RID.Any }{font_rid}))
	var ret = r_ret
	return ret
}

/*
Sets source font size used to generate MSDF textures.
*/
//go:nosplit
func (self class) FontSetMsdfSize(font_rid RID.Any, msdf_size int64) { //gd:TextServer.font_set_msdf_size
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.font_set_msdf_size, 0|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		font_rid  RID.Any
		msdf_size int64
	}{font_rid, msdf_size}))
}

/*
Returns source font size used to generate MSDF textures.
*/
//go:nosplit
func (self class) FontGetMsdfSize(font_rid RID.Any) int64 { //gd:TextServer.font_get_msdf_size
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.font_get_msdf_size, gdextension.SizeInt|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ font_rid RID.Any }{font_rid}))
	var ret = r_ret
	return ret
}

/*
Sets bitmap font fixed size. If set to value greater than zero, same cache entry will be used for all font sizes.
*/
//go:nosplit
func (self class) FontSetFixedSize(font_rid RID.Any, fixed_size int64) { //gd:TextServer.font_set_fixed_size
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.font_set_fixed_size, 0|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		font_rid   RID.Any
		fixed_size int64
	}{font_rid, fixed_size}))
}

/*
Returns bitmap font fixed size.
*/
//go:nosplit
func (self class) FontGetFixedSize(font_rid RID.Any) int64 { //gd:TextServer.font_get_fixed_size
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.font_get_fixed_size, gdextension.SizeInt|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ font_rid RID.Any }{font_rid}))
	var ret = r_ret
	return ret
}

/*
Sets bitmap font scaling mode. This property is used only if [code]fixed_size[/code] is greater than zero.
*/
//go:nosplit
func (self class) FontSetFixedSizeScaleMode(font_rid RID.Any, fixed_size_scale_mode FixedSizeScaleMode) { //gd:TextServer.font_set_fixed_size_scale_mode
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.font_set_fixed_size_scale_mode, 0|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		font_rid              RID.Any
		fixed_size_scale_mode FixedSizeScaleMode
	}{font_rid, fixed_size_scale_mode}))
}

/*
Returns bitmap font scaling mode.
*/
//go:nosplit
func (self class) FontGetFixedSizeScaleMode(font_rid RID.Any) FixedSizeScaleMode { //gd:TextServer.font_get_fixed_size_scale_mode
	var r_ret = gdextension.Call[FixedSizeScaleMode](gd.ObjectChecked(self.AsObject()), methods.font_get_fixed_size_scale_mode, gdextension.SizeInt|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ font_rid RID.Any }{font_rid}))
	var ret = r_ret
	return ret
}

/*
If set to [code]true[/code], system fonts can be automatically used as fallbacks.
*/
//go:nosplit
func (self class) FontSetAllowSystemFallback(font_rid RID.Any, allow_system_fallback bool) { //gd:TextServer.font_set_allow_system_fallback
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.font_set_allow_system_fallback, 0|(gdextension.SizeRID<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		font_rid              RID.Any
		allow_system_fallback bool
	}{font_rid, allow_system_fallback}))
}

/*
Returns [code]true[/code] if system fonts can be automatically used as fallbacks.
*/
//go:nosplit
func (self class) FontIsAllowSystemFallback(font_rid RID.Any) bool { //gd:TextServer.font_is_allow_system_fallback
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.font_is_allow_system_fallback, gdextension.SizeBool|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ font_rid RID.Any }{font_rid}))
	var ret = r_ret
	return ret
}

/*
If set to [code]true[/code] auto-hinting is preferred over font built-in hinting.
*/
//go:nosplit
func (self class) FontSetForceAutohinter(font_rid RID.Any, force_autohinter bool) { //gd:TextServer.font_set_force_autohinter
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.font_set_force_autohinter, 0|(gdextension.SizeRID<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		font_rid         RID.Any
		force_autohinter bool
	}{font_rid, force_autohinter}))
}

/*
Returns [code]true[/code] if auto-hinting is supported and preferred over font built-in hinting. Used by dynamic fonts only.
*/
//go:nosplit
func (self class) FontIsForceAutohinter(font_rid RID.Any) bool { //gd:TextServer.font_is_force_autohinter
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.font_is_force_autohinter, gdextension.SizeBool|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ font_rid RID.Any }{font_rid}))
	var ret = r_ret
	return ret
}

/*
Sets font hinting mode. Used by dynamic fonts only.
*/
//go:nosplit
func (self class) FontSetHinting(font_rid RID.Any, hinting Hinting) { //gd:TextServer.font_set_hinting
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.font_set_hinting, 0|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		font_rid RID.Any
		hinting  Hinting
	}{font_rid, hinting}))
}

/*
Returns the font hinting mode. Used by dynamic fonts only.
*/
//go:nosplit
func (self class) FontGetHinting(font_rid RID.Any) Hinting { //gd:TextServer.font_get_hinting
	var r_ret = gdextension.Call[Hinting](gd.ObjectChecked(self.AsObject()), methods.font_get_hinting, gdextension.SizeInt|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ font_rid RID.Any }{font_rid}))
	var ret = r_ret
	return ret
}

/*
Sets font subpixel glyph positioning mode.
*/
//go:nosplit
func (self class) FontSetSubpixelPositioning(font_rid RID.Any, subpixel_positioning SubpixelPositioning) { //gd:TextServer.font_set_subpixel_positioning
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.font_set_subpixel_positioning, 0|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		font_rid             RID.Any
		subpixel_positioning SubpixelPositioning
	}{font_rid, subpixel_positioning}))
}

/*
Returns font subpixel glyph positioning mode.
*/
//go:nosplit
func (self class) FontGetSubpixelPositioning(font_rid RID.Any) SubpixelPositioning { //gd:TextServer.font_get_subpixel_positioning
	var r_ret = gdextension.Call[SubpixelPositioning](gd.ObjectChecked(self.AsObject()), methods.font_get_subpixel_positioning, gdextension.SizeInt|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ font_rid RID.Any }{font_rid}))
	var ret = r_ret
	return ret
}

/*
Sets glyph position rounding behavior. If set to [code]true[/code], when aligning glyphs to the pixel boundaries rounding remainders are accumulated to ensure more uniform glyph distribution. This setting has no effect if subpixel positioning is enabled.
*/
//go:nosplit
func (self class) FontSetKeepRoundingRemainders(font_rid RID.Any, keep_rounding_remainders bool) { //gd:TextServer.font_set_keep_rounding_remainders
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.font_set_keep_rounding_remainders, 0|(gdextension.SizeRID<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		font_rid                 RID.Any
		keep_rounding_remainders bool
	}{font_rid, keep_rounding_remainders}))
}

/*
Returns glyph position rounding behavior. If set to [code]true[/code], when aligning glyphs to the pixel boundaries rounding remainders are accumulated to ensure more uniform glyph distribution. This setting has no effect if subpixel positioning is enabled.
*/
//go:nosplit
func (self class) FontGetKeepRoundingRemainders(font_rid RID.Any) bool { //gd:TextServer.font_get_keep_rounding_remainders
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.font_get_keep_rounding_remainders, gdextension.SizeBool|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ font_rid RID.Any }{font_rid}))
	var ret = r_ret
	return ret
}

/*
Sets font embolden strength. If [param strength] is not equal to zero, emboldens the font outlines. Negative values reduce the outline thickness.
*/
//go:nosplit
func (self class) FontSetEmbolden(font_rid RID.Any, strength float64) { //gd:TextServer.font_set_embolden
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.font_set_embolden, 0|(gdextension.SizeRID<<4)|(gdextension.SizeFloat<<8), unsafe.Pointer(&struct {
		font_rid RID.Any
		strength float64
	}{font_rid, strength}))
}

/*
Returns font embolden strength.
*/
//go:nosplit
func (self class) FontGetEmbolden(font_rid RID.Any) float64 { //gd:TextServer.font_get_embolden
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.font_get_embolden, gdextension.SizeFloat|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ font_rid RID.Any }{font_rid}))
	var ret = r_ret
	return ret
}

/*
Sets the spacing for [param spacing] (see [enum TextServer.SpacingType]) to [param value] in pixels (not relative to the font size).
*/
//go:nosplit
func (self class) FontSetSpacing(font_rid RID.Any, spacing SpacingType, value int64) { //gd:TextServer.font_set_spacing
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.font_set_spacing, 0|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		font_rid RID.Any
		spacing  SpacingType
		value    int64
	}{font_rid, spacing, value}))
}

/*
Returns the spacing for [param spacing] (see [enum TextServer.SpacingType]) in pixels (not relative to the font size).
*/
//go:nosplit
func (self class) FontGetSpacing(font_rid RID.Any, spacing SpacingType) int64 { //gd:TextServer.font_get_spacing
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.font_get_spacing, gdextension.SizeInt|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		font_rid RID.Any
		spacing  SpacingType
	}{font_rid, spacing}))
	var ret = r_ret
	return ret
}

/*
Sets extra baseline offset (as a fraction of font height).
*/
//go:nosplit
func (self class) FontSetBaselineOffset(font_rid RID.Any, baseline_offset float64) { //gd:TextServer.font_set_baseline_offset
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.font_set_baseline_offset, 0|(gdextension.SizeRID<<4)|(gdextension.SizeFloat<<8), unsafe.Pointer(&struct {
		font_rid        RID.Any
		baseline_offset float64
	}{font_rid, baseline_offset}))
}

/*
Returns extra baseline offset (as a fraction of font height).
*/
//go:nosplit
func (self class) FontGetBaselineOffset(font_rid RID.Any) float64 { //gd:TextServer.font_get_baseline_offset
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.font_get_baseline_offset, gdextension.SizeFloat|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ font_rid RID.Any }{font_rid}))
	var ret = r_ret
	return ret
}

/*
Sets 2D transform, applied to the font outlines, can be used for slanting, flipping, and rotating glyphs.
For example, to simulate italic typeface by slanting, apply the following transform [code]Transform2D(1.0, slant, 0.0, 1.0, 0.0, 0.0)[/code].
*/
//go:nosplit
func (self class) FontSetTransform(font_rid RID.Any, transform Transform2D.OriginXY) { //gd:TextServer.font_set_transform
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.font_set_transform, 0|(gdextension.SizeRID<<4)|(gdextension.SizeTransform2D<<8), unsafe.Pointer(&struct {
		font_rid  RID.Any
		transform Transform2D.OriginXY
	}{font_rid, transform}))
}

/*
Returns 2D transform applied to the font outlines.
*/
//go:nosplit
func (self class) FontGetTransform(font_rid RID.Any) Transform2D.OriginXY { //gd:TextServer.font_get_transform
	var r_ret = gdextension.Call[Transform2D.OriginXY](gd.ObjectChecked(self.AsObject()), methods.font_get_transform, gdextension.SizeTransform2D|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ font_rid RID.Any }{font_rid}))
	var ret = r_ret
	return ret
}

/*
Sets variation coordinates for the specified font cache entry. See [method font_supported_variation_list] for more info.
*/
//go:nosplit
func (self class) FontSetVariationCoordinates(font_rid RID.Any, variation_coordinates Dictionary.Any) { //gd:TextServer.font_set_variation_coordinates
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.font_set_variation_coordinates, 0|(gdextension.SizeRID<<4)|(gdextension.SizeDictionary<<8), unsafe.Pointer(&struct {
		font_rid              RID.Any
		variation_coordinates gdextension.Dictionary
	}{font_rid, pointers.Get(gd.InternalDictionary(variation_coordinates))}))
}

/*
Returns variation coordinates for the specified font cache entry. See [method font_supported_variation_list] for more info.
*/
//go:nosplit
func (self class) FontGetVariationCoordinates(font_rid RID.Any) Dictionary.Any { //gd:TextServer.font_get_variation_coordinates
	var r_ret = gdextension.Call[gdextension.Dictionary](gd.ObjectChecked(self.AsObject()), methods.font_get_variation_coordinates, gdextension.SizeDictionary|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ font_rid RID.Any }{font_rid}))
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret)))
	return ret
}

/*
Sets font oversampling factor, if set to [code]0.0[/code] global oversampling factor is used instead. Used by dynamic fonts only.
*/
//go:nosplit
func (self class) FontSetOversampling(font_rid RID.Any, oversampling float64) { //gd:TextServer.font_set_oversampling
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.font_set_oversampling, 0|(gdextension.SizeRID<<4)|(gdextension.SizeFloat<<8), unsafe.Pointer(&struct {
		font_rid     RID.Any
		oversampling float64
	}{font_rid, oversampling}))
}

/*
Returns font oversampling factor, if set to [code]0.0[/code] global oversampling factor is used instead. Used by dynamic fonts only.
*/
//go:nosplit
func (self class) FontGetOversampling(font_rid RID.Any) float64 { //gd:TextServer.font_get_oversampling
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.font_get_oversampling, gdextension.SizeFloat|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ font_rid RID.Any }{font_rid}))
	var ret = r_ret
	return ret
}

/*
Returns list of the font sizes in the cache. Each size is [Vector2i] with font size and outline size.
*/
//go:nosplit
func (self class) FontGetSizeCacheList(font_rid RID.Any) Array.Contains[Vector2i.XY] { //gd:TextServer.font_get_size_cache_list
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), methods.font_get_size_cache_list, gdextension.SizeArray|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ font_rid RID.Any }{font_rid}))
	var ret = Array.Through(gd.ArrayProxy[Vector2i.XY]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

/*
Removes all font sizes from the cache entry.
*/
//go:nosplit
func (self class) FontClearSizeCache(font_rid RID.Any) { //gd:TextServer.font_clear_size_cache
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.font_clear_size_cache, 0|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ font_rid RID.Any }{font_rid}))
}

/*
Removes specified font size from the cache entry.
*/
//go:nosplit
func (self class) FontRemoveSizeCache(font_rid RID.Any, size Vector2i.XY) { //gd:TextServer.font_remove_size_cache
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.font_remove_size_cache, 0|(gdextension.SizeRID<<4)|(gdextension.SizeVector2i<<8), unsafe.Pointer(&struct {
		font_rid RID.Any
		size     Vector2i.XY
	}{font_rid, size}))
}

/*
Sets the font ascent (number of pixels above the baseline).
*/
//go:nosplit
func (self class) FontSetAscent(font_rid RID.Any, size int64, ascent float64) { //gd:TextServer.font_set_ascent
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.font_set_ascent, 0|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeFloat<<12), unsafe.Pointer(&struct {
		font_rid RID.Any
		size     int64
		ascent   float64
	}{font_rid, size, ascent}))
}

/*
Returns the font ascent (number of pixels above the baseline).
*/
//go:nosplit
func (self class) FontGetAscent(font_rid RID.Any, size int64) float64 { //gd:TextServer.font_get_ascent
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.font_get_ascent, gdextension.SizeFloat|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		font_rid RID.Any
		size     int64
	}{font_rid, size}))
	var ret = r_ret
	return ret
}

/*
Sets the font descent (number of pixels below the baseline).
*/
//go:nosplit
func (self class) FontSetDescent(font_rid RID.Any, size int64, descent float64) { //gd:TextServer.font_set_descent
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.font_set_descent, 0|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeFloat<<12), unsafe.Pointer(&struct {
		font_rid RID.Any
		size     int64
		descent  float64
	}{font_rid, size, descent}))
}

/*
Returns the font descent (number of pixels below the baseline).
*/
//go:nosplit
func (self class) FontGetDescent(font_rid RID.Any, size int64) float64 { //gd:TextServer.font_get_descent
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.font_get_descent, gdextension.SizeFloat|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		font_rid RID.Any
		size     int64
	}{font_rid, size}))
	var ret = r_ret
	return ret
}

/*
Sets pixel offset of the underline below the baseline.
*/
//go:nosplit
func (self class) FontSetUnderlinePosition(font_rid RID.Any, size int64, underline_position float64) { //gd:TextServer.font_set_underline_position
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.font_set_underline_position, 0|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeFloat<<12), unsafe.Pointer(&struct {
		font_rid           RID.Any
		size               int64
		underline_position float64
	}{font_rid, size, underline_position}))
}

/*
Returns pixel offset of the underline below the baseline.
*/
//go:nosplit
func (self class) FontGetUnderlinePosition(font_rid RID.Any, size int64) float64 { //gd:TextServer.font_get_underline_position
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.font_get_underline_position, gdextension.SizeFloat|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		font_rid RID.Any
		size     int64
	}{font_rid, size}))
	var ret = r_ret
	return ret
}

/*
Sets thickness of the underline in pixels.
*/
//go:nosplit
func (self class) FontSetUnderlineThickness(font_rid RID.Any, size int64, underline_thickness float64) { //gd:TextServer.font_set_underline_thickness
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.font_set_underline_thickness, 0|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeFloat<<12), unsafe.Pointer(&struct {
		font_rid            RID.Any
		size                int64
		underline_thickness float64
	}{font_rid, size, underline_thickness}))
}

/*
Returns thickness of the underline in pixels.
*/
//go:nosplit
func (self class) FontGetUnderlineThickness(font_rid RID.Any, size int64) float64 { //gd:TextServer.font_get_underline_thickness
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.font_get_underline_thickness, gdextension.SizeFloat|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		font_rid RID.Any
		size     int64
	}{font_rid, size}))
	var ret = r_ret
	return ret
}

/*
Sets scaling factor of the color bitmap font.
*/
//go:nosplit
func (self class) FontSetScale(font_rid RID.Any, size int64, scale float64) { //gd:TextServer.font_set_scale
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.font_set_scale, 0|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeFloat<<12), unsafe.Pointer(&struct {
		font_rid RID.Any
		size     int64
		scale    float64
	}{font_rid, size, scale}))
}

/*
Returns scaling factor of the color bitmap font.
*/
//go:nosplit
func (self class) FontGetScale(font_rid RID.Any, size int64) float64 { //gd:TextServer.font_get_scale
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.font_get_scale, gdextension.SizeFloat|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		font_rid RID.Any
		size     int64
	}{font_rid, size}))
	var ret = r_ret
	return ret
}

/*
Returns number of textures used by font cache entry.
*/
//go:nosplit
func (self class) FontGetTextureCount(font_rid RID.Any, size Vector2i.XY) int64 { //gd:TextServer.font_get_texture_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.font_get_texture_count, gdextension.SizeInt|(gdextension.SizeRID<<4)|(gdextension.SizeVector2i<<8), unsafe.Pointer(&struct {
		font_rid RID.Any
		size     Vector2i.XY
	}{font_rid, size}))
	var ret = r_ret
	return ret
}

/*
Removes all textures from font cache entry.
[b]Note:[/b] This function will not remove glyphs associated with the texture, use [method font_remove_glyph] to remove them manually.
*/
//go:nosplit
func (self class) FontClearTextures(font_rid RID.Any, size Vector2i.XY) { //gd:TextServer.font_clear_textures
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.font_clear_textures, 0|(gdextension.SizeRID<<4)|(gdextension.SizeVector2i<<8), unsafe.Pointer(&struct {
		font_rid RID.Any
		size     Vector2i.XY
	}{font_rid, size}))
}

/*
Removes specified texture from the cache entry.
[b]Note:[/b] This function will not remove glyphs associated with the texture, remove them manually, using [method font_remove_glyph].
*/
//go:nosplit
func (self class) FontRemoveTexture(font_rid RID.Any, size Vector2i.XY, texture_index int64) { //gd:TextServer.font_remove_texture
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.font_remove_texture, 0|(gdextension.SizeRID<<4)|(gdextension.SizeVector2i<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		font_rid      RID.Any
		size          Vector2i.XY
		texture_index int64
	}{font_rid, size, texture_index}))
}

/*
Sets font cache texture image data.
*/
//go:nosplit
func (self class) FontSetTextureImage(font_rid RID.Any, size Vector2i.XY, texture_index int64, image [1]gdclass.Image) { //gd:TextServer.font_set_texture_image
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.font_set_texture_image, 0|(gdextension.SizeRID<<4)|(gdextension.SizeVector2i<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeObject<<16), unsafe.Pointer(&struct {
		font_rid      RID.Any
		size          Vector2i.XY
		texture_index int64
		image         gdextension.Object
	}{font_rid, size, texture_index, gdextension.Object(gd.CallerIncrements(image[0].AsObject()))}))
}

/*
Returns font cache texture image data.
*/
//go:nosplit
func (self class) FontGetTextureImage(font_rid RID.Any, size Vector2i.XY, texture_index int64) [1]gdclass.Image { //gd:TextServer.font_get_texture_image
	var r_ret = gdextension.Call[gdextension.Object](gd.ObjectChecked(self.AsObject()), methods.font_get_texture_image, gdextension.SizeObject|(gdextension.SizeRID<<4)|(gdextension.SizeVector2i<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		font_rid      RID.Any
		size          Vector2i.XY
		texture_index int64
	}{font_rid, size, texture_index}))
	var ret = [1]gdclass.Image{gd.PointerWithOwnershipTransferredToGo[gdclass.Image](r_ret)}
	return ret
}

/*
Sets array containing glyph packing data.
*/
//go:nosplit
func (self class) FontSetTextureOffsets(font_rid RID.Any, size Vector2i.XY, texture_index int64, offset Packed.Array[int32]) { //gd:TextServer.font_set_texture_offsets
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.font_set_texture_offsets, 0|(gdextension.SizeRID<<4)|(gdextension.SizeVector2i<<8)|(gdextension.SizeInt<<12)|(gdextension.SizePackedArray<<16), unsafe.Pointer(&struct {
		font_rid      RID.Any
		size          Vector2i.XY
		texture_index int64
		offset        gdextension.PackedArray[int32]
	}{font_rid, size, texture_index, pointers.Get(gd.InternalPacked[gd.PackedInt32Array, int32](offset))}))
}

/*
Returns array containing glyph packing data.
*/
//go:nosplit
func (self class) FontGetTextureOffsets(font_rid RID.Any, size Vector2i.XY, texture_index int64) Packed.Array[int32] { //gd:TextServer.font_get_texture_offsets
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.font_get_texture_offsets, gdextension.SizePackedArray|(gdextension.SizeRID<<4)|(gdextension.SizeVector2i<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		font_rid      RID.Any
		size          Vector2i.XY
		texture_index int64
	}{font_rid, size, texture_index}))
	var ret = Packed.Array[int32](Array.Through(gd.PackedProxy[gd.PackedInt32Array, int32]{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

/*
Returns list of rendered glyphs in the cache entry.
*/
//go:nosplit
func (self class) FontGetGlyphList(font_rid RID.Any, size Vector2i.XY) Packed.Array[int32] { //gd:TextServer.font_get_glyph_list
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.font_get_glyph_list, gdextension.SizePackedArray|(gdextension.SizeRID<<4)|(gdextension.SizeVector2i<<8), unsafe.Pointer(&struct {
		font_rid RID.Any
		size     Vector2i.XY
	}{font_rid, size}))
	var ret = Packed.Array[int32](Array.Through(gd.PackedProxy[gd.PackedInt32Array, int32]{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

/*
Removes all rendered glyph information from the cache entry.
[b]Note:[/b] This function will not remove textures associated with the glyphs, use [method font_remove_texture] to remove them manually.
*/
//go:nosplit
func (self class) FontClearGlyphs(font_rid RID.Any, size Vector2i.XY) { //gd:TextServer.font_clear_glyphs
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.font_clear_glyphs, 0|(gdextension.SizeRID<<4)|(gdextension.SizeVector2i<<8), unsafe.Pointer(&struct {
		font_rid RID.Any
		size     Vector2i.XY
	}{font_rid, size}))
}

/*
Removes specified rendered glyph information from the cache entry.
[b]Note:[/b] This function will not remove textures associated with the glyphs, use [method font_remove_texture] to remove them manually.
*/
//go:nosplit
func (self class) FontRemoveGlyph(font_rid RID.Any, size Vector2i.XY, glyph int64) { //gd:TextServer.font_remove_glyph
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.font_remove_glyph, 0|(gdextension.SizeRID<<4)|(gdextension.SizeVector2i<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		font_rid RID.Any
		size     Vector2i.XY
		glyph    int64
	}{font_rid, size, glyph}))
}

/*
Returns glyph advance (offset of the next glyph).
[b]Note:[/b] Advance for glyphs outlines is the same as the base glyph advance and is not saved.
*/
//go:nosplit
func (self class) FontGetGlyphAdvance(font_rid RID.Any, size int64, glyph int64) Vector2.XY { //gd:TextServer.font_get_glyph_advance
	var r_ret = gdextension.Call[Vector2.XY](gd.ObjectChecked(self.AsObject()), methods.font_get_glyph_advance, gdextension.SizeVector2|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		font_rid RID.Any
		size     int64
		glyph    int64
	}{font_rid, size, glyph}))
	var ret = r_ret
	return ret
}

/*
Sets glyph advance (offset of the next glyph).
[b]Note:[/b] Advance for glyphs outlines is the same as the base glyph advance and is not saved.
*/
//go:nosplit
func (self class) FontSetGlyphAdvance(font_rid RID.Any, size int64, glyph int64, advance Vector2.XY) { //gd:TextServer.font_set_glyph_advance
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.font_set_glyph_advance, 0|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeVector2<<16), unsafe.Pointer(&struct {
		font_rid RID.Any
		size     int64
		glyph    int64
		advance  Vector2.XY
	}{font_rid, size, glyph, advance}))
}

/*
Returns glyph offset from the baseline.
*/
//go:nosplit
func (self class) FontGetGlyphOffset(font_rid RID.Any, size Vector2i.XY, glyph int64) Vector2.XY { //gd:TextServer.font_get_glyph_offset
	var r_ret = gdextension.Call[Vector2.XY](gd.ObjectChecked(self.AsObject()), methods.font_get_glyph_offset, gdextension.SizeVector2|(gdextension.SizeRID<<4)|(gdextension.SizeVector2i<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		font_rid RID.Any
		size     Vector2i.XY
		glyph    int64
	}{font_rid, size, glyph}))
	var ret = r_ret
	return ret
}

/*
Sets glyph offset from the baseline.
*/
//go:nosplit
func (self class) FontSetGlyphOffset(font_rid RID.Any, size Vector2i.XY, glyph int64, offset Vector2.XY) { //gd:TextServer.font_set_glyph_offset
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.font_set_glyph_offset, 0|(gdextension.SizeRID<<4)|(gdextension.SizeVector2i<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeVector2<<16), unsafe.Pointer(&struct {
		font_rid RID.Any
		size     Vector2i.XY
		glyph    int64
		offset   Vector2.XY
	}{font_rid, size, glyph, offset}))
}

/*
Returns size of the glyph.
*/
//go:nosplit
func (self class) FontGetGlyphSize(font_rid RID.Any, size Vector2i.XY, glyph int64) Vector2.XY { //gd:TextServer.font_get_glyph_size
	var r_ret = gdextension.Call[Vector2.XY](gd.ObjectChecked(self.AsObject()), methods.font_get_glyph_size, gdextension.SizeVector2|(gdextension.SizeRID<<4)|(gdextension.SizeVector2i<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		font_rid RID.Any
		size     Vector2i.XY
		glyph    int64
	}{font_rid, size, glyph}))
	var ret = r_ret
	return ret
}

/*
Sets size of the glyph.
*/
//go:nosplit
func (self class) FontSetGlyphSize(font_rid RID.Any, size Vector2i.XY, glyph int64, gl_size Vector2.XY) { //gd:TextServer.font_set_glyph_size
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.font_set_glyph_size, 0|(gdextension.SizeRID<<4)|(gdextension.SizeVector2i<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeVector2<<16), unsafe.Pointer(&struct {
		font_rid RID.Any
		size     Vector2i.XY
		glyph    int64
		gl_size  Vector2.XY
	}{font_rid, size, glyph, gl_size}))
}

/*
Returns rectangle in the cache texture containing the glyph.
*/
//go:nosplit
func (self class) FontGetGlyphUvRect(font_rid RID.Any, size Vector2i.XY, glyph int64) Rect2.PositionSize { //gd:TextServer.font_get_glyph_uv_rect
	var r_ret = gdextension.Call[Rect2.PositionSize](gd.ObjectChecked(self.AsObject()), methods.font_get_glyph_uv_rect, gdextension.SizeRect2|(gdextension.SizeRID<<4)|(gdextension.SizeVector2i<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		font_rid RID.Any
		size     Vector2i.XY
		glyph    int64
	}{font_rid, size, glyph}))
	var ret = r_ret
	return ret
}

/*
Sets rectangle in the cache texture containing the glyph.
*/
//go:nosplit
func (self class) FontSetGlyphUvRect(font_rid RID.Any, size Vector2i.XY, glyph int64, uv_rect Rect2.PositionSize) { //gd:TextServer.font_set_glyph_uv_rect
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.font_set_glyph_uv_rect, 0|(gdextension.SizeRID<<4)|(gdextension.SizeVector2i<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeRect2<<16), unsafe.Pointer(&struct {
		font_rid RID.Any
		size     Vector2i.XY
		glyph    int64
		uv_rect  Rect2.PositionSize
	}{font_rid, size, glyph, uv_rect}))
}

/*
Returns index of the cache texture containing the glyph.
*/
//go:nosplit
func (self class) FontGetGlyphTextureIdx(font_rid RID.Any, size Vector2i.XY, glyph int64) int64 { //gd:TextServer.font_get_glyph_texture_idx
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.font_get_glyph_texture_idx, gdextension.SizeInt|(gdextension.SizeRID<<4)|(gdextension.SizeVector2i<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		font_rid RID.Any
		size     Vector2i.XY
		glyph    int64
	}{font_rid, size, glyph}))
	var ret = r_ret
	return ret
}

/*
Sets index of the cache texture containing the glyph.
*/
//go:nosplit
func (self class) FontSetGlyphTextureIdx(font_rid RID.Any, size Vector2i.XY, glyph int64, texture_idx int64) { //gd:TextServer.font_set_glyph_texture_idx
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.font_set_glyph_texture_idx, 0|(gdextension.SizeRID<<4)|(gdextension.SizeVector2i<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeInt<<16), unsafe.Pointer(&struct {
		font_rid    RID.Any
		size        Vector2i.XY
		glyph       int64
		texture_idx int64
	}{font_rid, size, glyph, texture_idx}))
}

/*
Returns resource ID of the cache texture containing the glyph.
[b]Note:[/b] If there are pending glyphs to render, calling this function might trigger the texture cache update.
*/
//go:nosplit
func (self class) FontGetGlyphTextureRid(font_rid RID.Any, size Vector2i.XY, glyph int64) RID.Any { //gd:TextServer.font_get_glyph_texture_rid
	var r_ret = gdextension.Call[RID.Any](gd.ObjectChecked(self.AsObject()), methods.font_get_glyph_texture_rid, gdextension.SizeRID|(gdextension.SizeRID<<4)|(gdextension.SizeVector2i<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		font_rid RID.Any
		size     Vector2i.XY
		glyph    int64
	}{font_rid, size, glyph}))
	var ret = r_ret
	return ret
}

/*
Returns size of the cache texture containing the glyph.
[b]Note:[/b] If there are pending glyphs to render, calling this function might trigger the texture cache update.
*/
//go:nosplit
func (self class) FontGetGlyphTextureSize(font_rid RID.Any, size Vector2i.XY, glyph int64) Vector2.XY { //gd:TextServer.font_get_glyph_texture_size
	var r_ret = gdextension.Call[Vector2.XY](gd.ObjectChecked(self.AsObject()), methods.font_get_glyph_texture_size, gdextension.SizeVector2|(gdextension.SizeRID<<4)|(gdextension.SizeVector2i<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		font_rid RID.Any
		size     Vector2i.XY
		glyph    int64
	}{font_rid, size, glyph}))
	var ret = r_ret
	return ret
}

/*
Returns outline contours of the glyph as a [Dictionary] with the following contents:
[code]points[/code]         - [PackedVector3Array], containing outline points. [code]x[/code] and [code]y[/code] are point coordinates. [code]z[/code] is the type of the point, using the [enum ContourPointTag] values.
[code]contours[/code]       - [PackedInt32Array], containing indices the end points of each contour.
[code]orientation[/code]    - [bool], contour orientation. If [code]true[/code], clockwise contours must be filled.
- Two successive [constant CONTOUR_CURVE_TAG_ON] points indicate a line segment.
- One [constant CONTOUR_CURVE_TAG_OFF_CONIC] point between two [constant CONTOUR_CURVE_TAG_ON] points indicates a single conic (quadratic) Bzier arc.
- Two [constant CONTOUR_CURVE_TAG_OFF_CUBIC] points between two [constant CONTOUR_CURVE_TAG_ON] points indicate a single cubic Bzier arc.
- Two successive [constant CONTOUR_CURVE_TAG_OFF_CONIC] points indicate two successive conic (quadratic) Bzier arcs with a virtual [constant CONTOUR_CURVE_TAG_ON] point at their middle.
- Each contour is closed. The last point of a contour uses the first point of a contour as its next point, and vice versa. The first point can be [constant CONTOUR_CURVE_TAG_OFF_CONIC] point.
*/
//go:nosplit
func (self class) FontGetGlyphContours(font RID.Any, size int64, index int64) Dictionary.Any { //gd:TextServer.font_get_glyph_contours
	var r_ret = gdextension.Call[gdextension.Dictionary](gd.ObjectChecked(self.AsObject()), methods.font_get_glyph_contours, gdextension.SizeDictionary|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		font  RID.Any
		size  int64
		index int64
	}{font, size, index}))
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret)))
	return ret
}

/*
Returns list of the kerning overrides.
*/
//go:nosplit
func (self class) FontGetKerningList(font_rid RID.Any, size int64) Array.Contains[Vector2i.XY] { //gd:TextServer.font_get_kerning_list
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), methods.font_get_kerning_list, gdextension.SizeArray|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		font_rid RID.Any
		size     int64
	}{font_rid, size}))
	var ret = Array.Through(gd.ArrayProxy[Vector2i.XY]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

/*
Removes all kerning overrides.
*/
//go:nosplit
func (self class) FontClearKerningMap(font_rid RID.Any, size int64) { //gd:TextServer.font_clear_kerning_map
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.font_clear_kerning_map, 0|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		font_rid RID.Any
		size     int64
	}{font_rid, size}))
}

/*
Removes kerning override for the pair of glyphs.
*/
//go:nosplit
func (self class) FontRemoveKerning(font_rid RID.Any, size int64, glyph_pair Vector2i.XY) { //gd:TextServer.font_remove_kerning
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.font_remove_kerning, 0|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeVector2i<<12), unsafe.Pointer(&struct {
		font_rid   RID.Any
		size       int64
		glyph_pair Vector2i.XY
	}{font_rid, size, glyph_pair}))
}

/*
Sets kerning for the pair of glyphs.
*/
//go:nosplit
func (self class) FontSetKerning(font_rid RID.Any, size int64, glyph_pair Vector2i.XY, kerning Vector2.XY) { //gd:TextServer.font_set_kerning
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.font_set_kerning, 0|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeVector2i<<12)|(gdextension.SizeVector2<<16), unsafe.Pointer(&struct {
		font_rid   RID.Any
		size       int64
		glyph_pair Vector2i.XY
		kerning    Vector2.XY
	}{font_rid, size, glyph_pair, kerning}))
}

/*
Returns kerning for the pair of glyphs.
*/
//go:nosplit
func (self class) FontGetKerning(font_rid RID.Any, size int64, glyph_pair Vector2i.XY) Vector2.XY { //gd:TextServer.font_get_kerning
	var r_ret = gdextension.Call[Vector2.XY](gd.ObjectChecked(self.AsObject()), methods.font_get_kerning, gdextension.SizeVector2|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeVector2i<<12), unsafe.Pointer(&struct {
		font_rid   RID.Any
		size       int64
		glyph_pair Vector2i.XY
	}{font_rid, size, glyph_pair}))
	var ret = r_ret
	return ret
}

/*
Returns the glyph index of a [param char], optionally modified by the [param variation_selector]. See [method font_get_char_from_glyph_index].
*/
//go:nosplit
func (self class) FontGetGlyphIndex(font_rid RID.Any, size int64, char int64, variation_selector int64) int64 { //gd:TextServer.font_get_glyph_index
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.font_get_glyph_index, gdextension.SizeInt|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeInt<<16), unsafe.Pointer(&struct {
		font_rid           RID.Any
		size               int64
		char               int64
		variation_selector int64
	}{font_rid, size, char, variation_selector}))
	var ret = r_ret
	return ret
}

/*
Returns character code associated with [param glyph_index], or [code]0[/code] if [param glyph_index] is invalid. See [method font_get_glyph_index].
*/
//go:nosplit
func (self class) FontGetCharFromGlyphIndex(font_rid RID.Any, size int64, glyph_index int64) int64 { //gd:TextServer.font_get_char_from_glyph_index
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.font_get_char_from_glyph_index, gdextension.SizeInt|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		font_rid    RID.Any
		size        int64
		glyph_index int64
	}{font_rid, size, glyph_index}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if a Unicode [param char] is available in the font.
*/
//go:nosplit
func (self class) FontHasChar(font_rid RID.Any, char int64) bool { //gd:TextServer.font_has_char
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.font_has_char, gdextension.SizeBool|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		font_rid RID.Any
		char     int64
	}{font_rid, char}))
	var ret = r_ret
	return ret
}

/*
Returns a string containing all the characters available in the font.
*/
//go:nosplit
func (self class) FontGetSupportedChars(font_rid RID.Any) String.Readable { //gd:TextServer.font_get_supported_chars
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.font_get_supported_chars, gdextension.SizeString|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ font_rid RID.Any }{font_rid}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Returns an array containing all glyph indices in the font.
*/
//go:nosplit
func (self class) FontGetSupportedGlyphs(font_rid RID.Any) Packed.Array[int32] { //gd:TextServer.font_get_supported_glyphs
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.font_get_supported_glyphs, gdextension.SizePackedArray|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ font_rid RID.Any }{font_rid}))
	var ret = Packed.Array[int32](Array.Through(gd.PackedProxy[gd.PackedInt32Array, int32]{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

/*
Renders the range of characters to the font cache texture.
*/
//go:nosplit
func (self class) FontRenderRange(font_rid RID.Any, size Vector2i.XY, start int64, end int64) { //gd:TextServer.font_render_range
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.font_render_range, 0|(gdextension.SizeRID<<4)|(gdextension.SizeVector2i<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeInt<<16), unsafe.Pointer(&struct {
		font_rid RID.Any
		size     Vector2i.XY
		start    int64
		end      int64
	}{font_rid, size, start, end}))
}

/*
Renders specified glyph to the font cache texture.
*/
//go:nosplit
func (self class) FontRenderGlyph(font_rid RID.Any, size Vector2i.XY, index int64) { //gd:TextServer.font_render_glyph
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.font_render_glyph, 0|(gdextension.SizeRID<<4)|(gdextension.SizeVector2i<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		font_rid RID.Any
		size     Vector2i.XY
		index    int64
	}{font_rid, size, index}))
}

/*
Draws single glyph into a canvas item at the position, using [param font_rid] at the size [param size].
[b]Note:[/b] Glyph index is specific to the font, use glyphs indices returned by [method shaped_text_get_glyphs] or [method font_get_glyph_index].
[b]Note:[/b] If there are pending glyphs to render, calling this function might trigger the texture cache update.
*/
//go:nosplit
func (self class) FontDrawGlyph(font_rid RID.Any, canvas RID.Any, size int64, pos Vector2.XY, index int64, color Color.RGBA) { //gd:TextServer.font_draw_glyph
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.font_draw_glyph, 0|(gdextension.SizeRID<<4)|(gdextension.SizeRID<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeVector2<<16)|(gdextension.SizeInt<<20)|(gdextension.SizeColor<<24), unsafe.Pointer(&struct {
		font_rid RID.Any
		canvas   RID.Any
		size     int64
		pos      Vector2.XY
		index    int64
		color    Color.RGBA
	}{font_rid, canvas, size, pos, index, color}))
}

/*
Draws single glyph outline of size [param outline_size] into a canvas item at the position, using [param font_rid] at the size [param size].
[b]Note:[/b] Glyph index is specific to the font, use glyphs indices returned by [method shaped_text_get_glyphs] or [method font_get_glyph_index].
[b]Note:[/b] If there are pending glyphs to render, calling this function might trigger the texture cache update.
*/
//go:nosplit
func (self class) FontDrawGlyphOutline(font_rid RID.Any, canvas RID.Any, size int64, outline_size int64, pos Vector2.XY, index int64, color Color.RGBA) { //gd:TextServer.font_draw_glyph_outline
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.font_draw_glyph_outline, 0|(gdextension.SizeRID<<4)|(gdextension.SizeRID<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeInt<<16)|(gdextension.SizeVector2<<20)|(gdextension.SizeInt<<24)|(gdextension.SizeColor<<28), unsafe.Pointer(&struct {
		font_rid     RID.Any
		canvas       RID.Any
		size         int64
		outline_size int64
		pos          Vector2.XY
		index        int64
		color        Color.RGBA
	}{font_rid, canvas, size, outline_size, pos, index, color}))
}

/*
Returns [code]true[/code], if font supports given language ([url=https://en.wikipedia.org/wiki/ISO_639-1]ISO 639[/url] code).
*/
//go:nosplit
func (self class) FontIsLanguageSupported(font_rid RID.Any, language String.Readable) bool { //gd:TextServer.font_is_language_supported
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.font_is_language_supported, gdextension.SizeBool|(gdextension.SizeRID<<4)|(gdextension.SizeString<<8), unsafe.Pointer(&struct {
		font_rid RID.Any
		language gdextension.String
	}{font_rid, pointers.Get(gd.InternalString(language))}))
	var ret = r_ret
	return ret
}

/*
Adds override for [method font_is_language_supported].
*/
//go:nosplit
func (self class) FontSetLanguageSupportOverride(font_rid RID.Any, language String.Readable, supported bool) { //gd:TextServer.font_set_language_support_override
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.font_set_language_support_override, 0|(gdextension.SizeRID<<4)|(gdextension.SizeString<<8)|(gdextension.SizeBool<<12), unsafe.Pointer(&struct {
		font_rid  RID.Any
		language  gdextension.String
		supported bool
	}{font_rid, pointers.Get(gd.InternalString(language)), supported}))
}

/*
Returns [code]true[/code] if support override is enabled for the [param language].
*/
//go:nosplit
func (self class) FontGetLanguageSupportOverride(font_rid RID.Any, language String.Readable) bool { //gd:TextServer.font_get_language_support_override
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.font_get_language_support_override, gdextension.SizeBool|(gdextension.SizeRID<<4)|(gdextension.SizeString<<8), unsafe.Pointer(&struct {
		font_rid RID.Any
		language gdextension.String
	}{font_rid, pointers.Get(gd.InternalString(language))}))
	var ret = r_ret
	return ret
}

/*
Remove language support override.
*/
//go:nosplit
func (self class) FontRemoveLanguageSupportOverride(font_rid RID.Any, language String.Readable) { //gd:TextServer.font_remove_language_support_override
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.font_remove_language_support_override, 0|(gdextension.SizeRID<<4)|(gdextension.SizeString<<8), unsafe.Pointer(&struct {
		font_rid RID.Any
		language gdextension.String
	}{font_rid, pointers.Get(gd.InternalString(language))}))
}

/*
Returns list of language support overrides.
*/
//go:nosplit
func (self class) FontGetLanguageSupportOverrides(font_rid RID.Any) Packed.Strings { //gd:TextServer.font_get_language_support_overrides
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.font_get_language_support_overrides, gdextension.SizePackedArray|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ font_rid RID.Any }{font_rid}))
	var ret = Packed.Strings(Array.Through(gd.PackedStringArrayProxy{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

/*
Returns [code]true[/code], if font supports given script (ISO 15924 code).
*/
//go:nosplit
func (self class) FontIsScriptSupported(font_rid RID.Any, script String.Readable) bool { //gd:TextServer.font_is_script_supported
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.font_is_script_supported, gdextension.SizeBool|(gdextension.SizeRID<<4)|(gdextension.SizeString<<8), unsafe.Pointer(&struct {
		font_rid RID.Any
		script   gdextension.String
	}{font_rid, pointers.Get(gd.InternalString(script))}))
	var ret = r_ret
	return ret
}

/*
Adds override for [method font_is_script_supported].
*/
//go:nosplit
func (self class) FontSetScriptSupportOverride(font_rid RID.Any, script String.Readable, supported bool) { //gd:TextServer.font_set_script_support_override
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.font_set_script_support_override, 0|(gdextension.SizeRID<<4)|(gdextension.SizeString<<8)|(gdextension.SizeBool<<12), unsafe.Pointer(&struct {
		font_rid  RID.Any
		script    gdextension.String
		supported bool
	}{font_rid, pointers.Get(gd.InternalString(script)), supported}))
}

/*
Returns [code]true[/code] if support override is enabled for the [param script].
*/
//go:nosplit
func (self class) FontGetScriptSupportOverride(font_rid RID.Any, script String.Readable) bool { //gd:TextServer.font_get_script_support_override
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.font_get_script_support_override, gdextension.SizeBool|(gdextension.SizeRID<<4)|(gdextension.SizeString<<8), unsafe.Pointer(&struct {
		font_rid RID.Any
		script   gdextension.String
	}{font_rid, pointers.Get(gd.InternalString(script))}))
	var ret = r_ret
	return ret
}

/*
Removes script support override.
*/
//go:nosplit
func (self class) FontRemoveScriptSupportOverride(font_rid RID.Any, script String.Readable) { //gd:TextServer.font_remove_script_support_override
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.font_remove_script_support_override, 0|(gdextension.SizeRID<<4)|(gdextension.SizeString<<8), unsafe.Pointer(&struct {
		font_rid RID.Any
		script   gdextension.String
	}{font_rid, pointers.Get(gd.InternalString(script))}))
}

/*
Returns list of script support overrides.
*/
//go:nosplit
func (self class) FontGetScriptSupportOverrides(font_rid RID.Any) Packed.Strings { //gd:TextServer.font_get_script_support_overrides
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.font_get_script_support_overrides, gdextension.SizePackedArray|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ font_rid RID.Any }{font_rid}))
	var ret = Packed.Strings(Array.Through(gd.PackedStringArrayProxy{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

/*
Sets font OpenType feature set override.
*/
//go:nosplit
func (self class) FontSetOpentypeFeatureOverrides(font_rid RID.Any, overrides Dictionary.Any) { //gd:TextServer.font_set_opentype_feature_overrides
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.font_set_opentype_feature_overrides, 0|(gdextension.SizeRID<<4)|(gdextension.SizeDictionary<<8), unsafe.Pointer(&struct {
		font_rid  RID.Any
		overrides gdextension.Dictionary
	}{font_rid, pointers.Get(gd.InternalDictionary(overrides))}))
}

/*
Returns font OpenType feature set override.
*/
//go:nosplit
func (self class) FontGetOpentypeFeatureOverrides(font_rid RID.Any) Dictionary.Any { //gd:TextServer.font_get_opentype_feature_overrides
	var r_ret = gdextension.Call[gdextension.Dictionary](gd.ObjectChecked(self.AsObject()), methods.font_get_opentype_feature_overrides, gdextension.SizeDictionary|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ font_rid RID.Any }{font_rid}))
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret)))
	return ret
}

/*
Returns the dictionary of the supported OpenType features.
*/
//go:nosplit
func (self class) FontSupportedFeatureList(font_rid RID.Any) Dictionary.Any { //gd:TextServer.font_supported_feature_list
	var r_ret = gdextension.Call[gdextension.Dictionary](gd.ObjectChecked(self.AsObject()), methods.font_supported_feature_list, gdextension.SizeDictionary|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ font_rid RID.Any }{font_rid}))
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret)))
	return ret
}

/*
Returns the dictionary of the supported OpenType variation coordinates.
*/
//go:nosplit
func (self class) FontSupportedVariationList(font_rid RID.Any) Dictionary.Any { //gd:TextServer.font_supported_variation_list
	var r_ret = gdextension.Call[gdextension.Dictionary](gd.ObjectChecked(self.AsObject()), methods.font_supported_variation_list, gdextension.SizeDictionary|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ font_rid RID.Any }{font_rid}))
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret)))
	return ret
}

/*
Returns the font oversampling factor, shared by all fonts in the TextServer.
*/
//go:nosplit
func (self class) FontGetGlobalOversampling() float64 { //gd:TextServer.font_get_global_oversampling
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.font_get_global_oversampling, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Sets oversampling factor, shared by all font in the TextServer.
[b]Note:[/b] This value can be automatically changed by display server.
*/
//go:nosplit
func (self class) FontSetGlobalOversampling(oversampling float64) { //gd:TextServer.font_set_global_oversampling
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.font_set_global_oversampling, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ oversampling float64 }{oversampling}))
}

/*
Returns size of the replacement character (box with character hexadecimal code that is drawn in place of invalid characters).
*/
//go:nosplit
func (self class) GetHexCodeBoxSize(size int64, index int64) Vector2.XY { //gd:TextServer.get_hex_code_box_size
	var r_ret = gdextension.Call[Vector2.XY](gd.ObjectChecked(self.AsObject()), methods.get_hex_code_box_size, gdextension.SizeVector2|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		size  int64
		index int64
	}{size, index}))
	var ret = r_ret
	return ret
}

/*
Draws box displaying character hexadecimal code. Used for replacing missing characters.
*/
//go:nosplit
func (self class) DrawHexCodeBox(canvas RID.Any, size int64, pos Vector2.XY, index int64, color Color.RGBA) { //gd:TextServer.draw_hex_code_box
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.draw_hex_code_box, 0|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeVector2<<12)|(gdextension.SizeInt<<16)|(gdextension.SizeColor<<20), unsafe.Pointer(&struct {
		canvas RID.Any
		size   int64
		pos    Vector2.XY
		index  int64
		color  Color.RGBA
	}{canvas, size, pos, index, color}))
}

/*
Creates a new buffer for complex text layout, with the given [param direction] and [param orientation]. To free the resulting buffer, use [method free_rid] method.
[b]Note:[/b] Direction is ignored if server does not support [constant FEATURE_BIDI_LAYOUT] feature (supported by [TextServerAdvanced]).
[b]Note:[/b] Orientation is ignored if server does not support [constant FEATURE_VERTICAL_LAYOUT] feature (supported by [TextServerAdvanced]).
*/
//go:nosplit
func (self class) CreateShapedText(direction Direction, orientation Orientation) RID.Any { //gd:TextServer.create_shaped_text
	var r_ret = gdextension.Call[RID.Any](gd.ObjectChecked(self.AsObject()), methods.create_shaped_text, gdextension.SizeRID|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		direction   Direction
		orientation int64
	}{direction, int64(orientation)}))
	var ret = r_ret
	return ret
}

/*
Clears text buffer (removes text and inline objects).
*/
//go:nosplit
func (self class) ShapedTextClear(rid RID.Any) { //gd:TextServer.shaped_text_clear
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.shaped_text_clear, 0|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ rid RID.Any }{rid}))
}

/*
Sets desired text direction. If set to [constant DIRECTION_AUTO], direction will be detected based on the buffer contents and current locale.
[b]Note:[/b] Direction is ignored if server does not support [constant FEATURE_BIDI_LAYOUT] feature (supported by [TextServerAdvanced]).
*/
//go:nosplit
func (self class) ShapedTextSetDirection(shaped RID.Any, direction Direction) { //gd:TextServer.shaped_text_set_direction
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.shaped_text_set_direction, 0|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		shaped    RID.Any
		direction Direction
	}{shaped, direction}))
}

/*
Returns direction of the text.
*/
//go:nosplit
func (self class) ShapedTextGetDirection(shaped RID.Any) Direction { //gd:TextServer.shaped_text_get_direction
	var r_ret = gdextension.Call[Direction](gd.ObjectChecked(self.AsObject()), methods.shaped_text_get_direction, gdextension.SizeInt|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ shaped RID.Any }{shaped}))
	var ret = r_ret
	return ret
}

/*
Returns direction of the text, inferred by the BiDi algorithm.
*/
//go:nosplit
func (self class) ShapedTextGetInferredDirection(shaped RID.Any) Direction { //gd:TextServer.shaped_text_get_inferred_direction
	var r_ret = gdextension.Call[Direction](gd.ObjectChecked(self.AsObject()), methods.shaped_text_get_inferred_direction, gdextension.SizeInt|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ shaped RID.Any }{shaped}))
	var ret = r_ret
	return ret
}

/*
Overrides BiDi for the structured text.
Override ranges should cover full source text without overlaps. BiDi algorithm will be used on each range separately.
*/
//go:nosplit
func (self class) ShapedTextSetBidiOverride(shaped RID.Any, override Array.Any) { //gd:TextServer.shaped_text_set_bidi_override
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.shaped_text_set_bidi_override, 0|(gdextension.SizeRID<<4)|(gdextension.SizeArray<<8), unsafe.Pointer(&struct {
		shaped   RID.Any
		override gdextension.Array
	}{shaped, pointers.Get(gd.InternalArray(override))}))
}

/*
Sets custom punctuation character list, used for word breaking. If set to empty string, server defaults are used.
*/
//go:nosplit
func (self class) ShapedTextSetCustomPunctuation(shaped RID.Any, punct String.Readable) { //gd:TextServer.shaped_text_set_custom_punctuation
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.shaped_text_set_custom_punctuation, 0|(gdextension.SizeRID<<4)|(gdextension.SizeString<<8), unsafe.Pointer(&struct {
		shaped RID.Any
		punct  gdextension.String
	}{shaped, pointers.Get(gd.InternalString(punct))}))
}

/*
Returns custom punctuation character list, used for word breaking. If set to empty string, server defaults are used.
*/
//go:nosplit
func (self class) ShapedTextGetCustomPunctuation(shaped RID.Any) String.Readable { //gd:TextServer.shaped_text_get_custom_punctuation
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.shaped_text_get_custom_punctuation, gdextension.SizeString|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ shaped RID.Any }{shaped}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Sets ellipsis character used for text clipping.
*/
//go:nosplit
func (self class) ShapedTextSetCustomEllipsis(shaped RID.Any, char int64) { //gd:TextServer.shaped_text_set_custom_ellipsis
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.shaped_text_set_custom_ellipsis, 0|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		shaped RID.Any
		char   int64
	}{shaped, char}))
}

/*
Returns ellipsis character used for text clipping.
*/
//go:nosplit
func (self class) ShapedTextGetCustomEllipsis(shaped RID.Any) int64 { //gd:TextServer.shaped_text_get_custom_ellipsis
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.shaped_text_get_custom_ellipsis, gdextension.SizeInt|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ shaped RID.Any }{shaped}))
	var ret = r_ret
	return ret
}

/*
Sets desired text orientation.
[b]Note:[/b] Orientation is ignored if server does not support [constant FEATURE_VERTICAL_LAYOUT] feature (supported by [TextServerAdvanced]).
*/
//go:nosplit
func (self class) ShapedTextSetOrientation(shaped RID.Any, orientation Orientation) { //gd:TextServer.shaped_text_set_orientation
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.shaped_text_set_orientation, 0|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		shaped      RID.Any
		orientation int64
	}{shaped, int64(orientation)}))
}

/*
Returns text orientation.
*/
//go:nosplit
func (self class) ShapedTextGetOrientation(shaped RID.Any) Orientation { //gd:TextServer.shaped_text_get_orientation
	var r_ret = gdextension.Call[Orientation](gd.ObjectChecked(self.AsObject()), methods.shaped_text_get_orientation, gdextension.SizeInt|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ shaped RID.Any }{shaped}))
	var ret = r_ret
	return ret
}

/*
If set to [code]true[/code] text buffer will display invalid characters as hexadecimal codes, otherwise nothing is displayed.
*/
//go:nosplit
func (self class) ShapedTextSetPreserveInvalid(shaped RID.Any, enabled bool) { //gd:TextServer.shaped_text_set_preserve_invalid
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.shaped_text_set_preserve_invalid, 0|(gdextension.SizeRID<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		shaped  RID.Any
		enabled bool
	}{shaped, enabled}))
}

/*
Returns [code]true[/code] if text buffer is configured to display hexadecimal codes in place of invalid characters.
[b]Note:[/b] If set to [code]false[/code], nothing is displayed in place of invalid characters.
*/
//go:nosplit
func (self class) ShapedTextGetPreserveInvalid(shaped RID.Any) bool { //gd:TextServer.shaped_text_get_preserve_invalid
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.shaped_text_get_preserve_invalid, gdextension.SizeBool|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ shaped RID.Any }{shaped}))
	var ret = r_ret
	return ret
}

/*
If set to [code]true[/code] text buffer will display control characters.
*/
//go:nosplit
func (self class) ShapedTextSetPreserveControl(shaped RID.Any, enabled bool) { //gd:TextServer.shaped_text_set_preserve_control
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.shaped_text_set_preserve_control, 0|(gdextension.SizeRID<<4)|(gdextension.SizeBool<<8), unsafe.Pointer(&struct {
		shaped  RID.Any
		enabled bool
	}{shaped, enabled}))
}

/*
Returns [code]true[/code] if text buffer is configured to display control characters.
*/
//go:nosplit
func (self class) ShapedTextGetPreserveControl(shaped RID.Any) bool { //gd:TextServer.shaped_text_get_preserve_control
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.shaped_text_get_preserve_control, gdextension.SizeBool|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ shaped RID.Any }{shaped}))
	var ret = r_ret
	return ret
}

/*
Sets extra spacing added between glyphs or lines in pixels.
*/
//go:nosplit
func (self class) ShapedTextSetSpacing(shaped RID.Any, spacing SpacingType, value int64) { //gd:TextServer.shaped_text_set_spacing
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.shaped_text_set_spacing, 0|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		shaped  RID.Any
		spacing SpacingType
		value   int64
	}{shaped, spacing, value}))
}

/*
Returns extra spacing added between glyphs or lines in pixels.
*/
//go:nosplit
func (self class) ShapedTextGetSpacing(shaped RID.Any, spacing SpacingType) int64 { //gd:TextServer.shaped_text_get_spacing
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.shaped_text_get_spacing, gdextension.SizeInt|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		shaped  RID.Any
		spacing SpacingType
	}{shaped, spacing}))
	var ret = r_ret
	return ret
}

/*
Adds text span and font to draw it to the text buffer.
*/
//go:nosplit
func (self class) ShapedTextAddString(shaped RID.Any, text String.Readable, fonts Array.Contains[RID.Any], size int64, opentype_features Dictionary.Any, language String.Readable, meta variant.Any) bool { //gd:TextServer.shaped_text_add_string
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.shaped_text_add_string, gdextension.SizeBool|(gdextension.SizeRID<<4)|(gdextension.SizeString<<8)|(gdextension.SizeArray<<12)|(gdextension.SizeInt<<16)|(gdextension.SizeDictionary<<20)|(gdextension.SizeString<<24)|(gdextension.SizeVariant<<28), unsafe.Pointer(&struct {
		shaped            RID.Any
		text              gdextension.String
		fonts             gdextension.Array
		size              int64
		opentype_features gdextension.Dictionary
		language          gdextension.String
		meta              gdextension.Variant
	}{shaped, pointers.Get(gd.InternalString(text)), pointers.Get(gd.InternalArray(fonts)), size, pointers.Get(gd.InternalDictionary(opentype_features)), pointers.Get(gd.InternalString(language)), gdextension.Variant(pointers.Get(gd.InternalVariant(meta)))}))
	var ret = r_ret
	return ret
}

/*
Adds inline object to the text buffer, [param key] must be unique. In the text, object is represented as [param length] object replacement characters.
*/
//go:nosplit
func (self class) ShapedTextAddObject(shaped RID.Any, key variant.Any, size Vector2.XY, inline_align GUI.InlineAlignment, length int64, baseline float64) bool { //gd:TextServer.shaped_text_add_object
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.shaped_text_add_object, gdextension.SizeBool|(gdextension.SizeRID<<4)|(gdextension.SizeVariant<<8)|(gdextension.SizeVector2<<12)|(gdextension.SizeInt<<16)|(gdextension.SizeInt<<20)|(gdextension.SizeFloat<<24), unsafe.Pointer(&struct {
		shaped       RID.Any
		key          gdextension.Variant
		size         Vector2.XY
		inline_align GUI.InlineAlignment
		length       int64
		baseline     float64
	}{shaped, gdextension.Variant(pointers.Get(gd.InternalVariant(key))), size, inline_align, length, baseline}))
	var ret = r_ret
	return ret
}

/*
Sets new size and alignment of embedded object.
*/
//go:nosplit
func (self class) ShapedTextResizeObject(shaped RID.Any, key variant.Any, size Vector2.XY, inline_align GUI.InlineAlignment, baseline float64) bool { //gd:TextServer.shaped_text_resize_object
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.shaped_text_resize_object, gdextension.SizeBool|(gdextension.SizeRID<<4)|(gdextension.SizeVariant<<8)|(gdextension.SizeVector2<<12)|(gdextension.SizeInt<<16)|(gdextension.SizeFloat<<20), unsafe.Pointer(&struct {
		shaped       RID.Any
		key          gdextension.Variant
		size         Vector2.XY
		inline_align GUI.InlineAlignment
		baseline     float64
	}{shaped, gdextension.Variant(pointers.Get(gd.InternalVariant(key))), size, inline_align, baseline}))
	var ret = r_ret
	return ret
}

/*
Returns number of text spans added using [method shaped_text_add_string] or [method shaped_text_add_object].
*/
//go:nosplit
func (self class) ShapedGetSpanCount(shaped RID.Any) int64 { //gd:TextServer.shaped_get_span_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.shaped_get_span_count, gdextension.SizeInt|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ shaped RID.Any }{shaped}))
	var ret = r_ret
	return ret
}

/*
Returns text span metadata.
*/
//go:nosplit
func (self class) ShapedGetSpanMeta(shaped RID.Any, index int64) variant.Any { //gd:TextServer.shaped_get_span_meta
	var r_ret = gdextension.Call[gdextension.Variant](gd.ObjectChecked(self.AsObject()), methods.shaped_get_span_meta, gdextension.SizeVariant|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		shaped RID.Any
		index  int64
	}{shaped, index}))
	var ret = variant.Implementation(gd.VariantProxy{}, pointers.Pack(pointers.New[gd.Variant](r_ret)))
	return ret
}

/*
Returns text embedded object key.
*/
//go:nosplit
func (self class) ShapedGetSpanEmbeddedObject(shaped RID.Any, index int64) variant.Any { //gd:TextServer.shaped_get_span_embedded_object
	var r_ret = gdextension.Call[gdextension.Variant](gd.ObjectChecked(self.AsObject()), methods.shaped_get_span_embedded_object, gdextension.SizeVariant|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		shaped RID.Any
		index  int64
	}{shaped, index}))
	var ret = variant.Implementation(gd.VariantProxy{}, pointers.Pack(pointers.New[gd.Variant](r_ret)))
	return ret
}

/*
Changes text span font, font size, and OpenType features, without changing the text.
*/
//go:nosplit
func (self class) ShapedSetSpanUpdateFont(shaped RID.Any, index int64, fonts Array.Contains[RID.Any], size int64, opentype_features Dictionary.Any) { //gd:TextServer.shaped_set_span_update_font
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.shaped_set_span_update_font, 0|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeArray<<12)|(gdextension.SizeInt<<16)|(gdextension.SizeDictionary<<20), unsafe.Pointer(&struct {
		shaped            RID.Any
		index             int64
		fonts             gdextension.Array
		size              int64
		opentype_features gdextension.Dictionary
	}{shaped, index, pointers.Get(gd.InternalArray(fonts)), size, pointers.Get(gd.InternalDictionary(opentype_features))}))
}

/*
Returns text buffer for the substring of the text in the [param shaped] text buffer (including inline objects).
*/
//go:nosplit
func (self class) ShapedTextSubstr(shaped RID.Any, start int64, length int64) RID.Any { //gd:TextServer.shaped_text_substr
	var r_ret = gdextension.Call[RID.Any](gd.ObjectChecked(self.AsObject()), methods.shaped_text_substr, gdextension.SizeRID|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		shaped RID.Any
		start  int64
		length int64
	}{shaped, start, length}))
	var ret = r_ret
	return ret
}

/*
Returns the parent buffer from which the substring originates.
*/
//go:nosplit
func (self class) ShapedTextGetParent(shaped RID.Any) RID.Any { //gd:TextServer.shaped_text_get_parent
	var r_ret = gdextension.Call[RID.Any](gd.ObjectChecked(self.AsObject()), methods.shaped_text_get_parent, gdextension.SizeRID|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ shaped RID.Any }{shaped}))
	var ret = r_ret
	return ret
}

/*
Adjusts text width to fit to specified width, returns new text width.
*/
//go:nosplit
func (self class) ShapedTextFitToWidth(shaped RID.Any, width float64, justification_flags JustificationFlag) float64 { //gd:TextServer.shaped_text_fit_to_width
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.shaped_text_fit_to_width, gdextension.SizeFloat|(gdextension.SizeRID<<4)|(gdextension.SizeFloat<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		shaped              RID.Any
		width               float64
		justification_flags JustificationFlag
	}{shaped, width, justification_flags}))
	var ret = r_ret
	return ret
}

/*
Aligns shaped text to the given tab-stops.
*/
//go:nosplit
func (self class) ShapedTextTabAlign(shaped RID.Any, tab_stops Packed.Array[float32]) float64 { //gd:TextServer.shaped_text_tab_align
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.shaped_text_tab_align, gdextension.SizeFloat|(gdextension.SizeRID<<4)|(gdextension.SizePackedArray<<8), unsafe.Pointer(&struct {
		shaped    RID.Any
		tab_stops gdextension.PackedArray[float32]
	}{shaped, pointers.Get(gd.InternalPacked[gd.PackedFloat32Array, float32](tab_stops))}))
	var ret = r_ret
	return ret
}

/*
Shapes buffer if it's not shaped. Returns [code]true[/code] if the string is shaped successfully.
[b]Note:[/b] It is not necessary to call this function manually, buffer will be shaped automatically as soon as any of its output data is requested.
*/
//go:nosplit
func (self class) ShapedTextShape(shaped RID.Any) bool { //gd:TextServer.shaped_text_shape
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.shaped_text_shape, gdextension.SizeBool|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ shaped RID.Any }{shaped}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if buffer is successfully shaped.
*/
//go:nosplit
func (self class) ShapedTextIsReady(shaped RID.Any) bool { //gd:TextServer.shaped_text_is_ready
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.shaped_text_is_ready, gdextension.SizeBool|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ shaped RID.Any }{shaped}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if text buffer contains any visible characters.
*/
//go:nosplit
func (self class) ShapedTextHasVisibleChars(shaped RID.Any) bool { //gd:TextServer.shaped_text_has_visible_chars
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.shaped_text_has_visible_chars, gdextension.SizeBool|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ shaped RID.Any }{shaped}))
	var ret = r_ret
	return ret
}

/*
Returns an array of glyphs in the visual order.
*/
//go:nosplit
func (self class) ShapedTextGetGlyphs(shaped RID.Any) Array.Contains[Dictionary.Any] { //gd:TextServer.shaped_text_get_glyphs
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), methods.shaped_text_get_glyphs, gdextension.SizeArray|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ shaped RID.Any }{shaped}))
	var ret = Array.Through(gd.ArrayProxy[Dictionary.Any]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

/*
Returns text glyphs in the logical order.
*/
//go:nosplit
func (self class) ShapedTextSortLogical(shaped RID.Any) Array.Contains[Dictionary.Any] { //gd:TextServer.shaped_text_sort_logical
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), methods.shaped_text_sort_logical, gdextension.SizeArray|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ shaped RID.Any }{shaped}))
	var ret = Array.Through(gd.ArrayProxy[Dictionary.Any]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

/*
Returns number of glyphs in the buffer.
*/
//go:nosplit
func (self class) ShapedTextGetGlyphCount(shaped RID.Any) int64 { //gd:TextServer.shaped_text_get_glyph_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.shaped_text_get_glyph_count, gdextension.SizeInt|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ shaped RID.Any }{shaped}))
	var ret = r_ret
	return ret
}

/*
Returns substring buffer character range in the parent buffer.
*/
//go:nosplit
func (self class) ShapedTextGetRange(shaped RID.Any) Vector2i.XY { //gd:TextServer.shaped_text_get_range
	var r_ret = gdextension.Call[Vector2i.XY](gd.ObjectChecked(self.AsObject()), methods.shaped_text_get_range, gdextension.SizeVector2i|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ shaped RID.Any }{shaped}))
	var ret = r_ret
	return ret
}

/*
Breaks text to the lines and columns. Returns character ranges for each segment.
*/
//go:nosplit
func (self class) ShapedTextGetLineBreaksAdv(shaped RID.Any, width Packed.Array[float32], start int64, once bool, break_flags LineBreakFlag) Packed.Array[int32] { //gd:TextServer.shaped_text_get_line_breaks_adv
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.shaped_text_get_line_breaks_adv, gdextension.SizePackedArray|(gdextension.SizeRID<<4)|(gdextension.SizePackedArray<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeBool<<16)|(gdextension.SizeInt<<20), unsafe.Pointer(&struct {
		shaped      RID.Any
		width       gdextension.PackedArray[float32]
		start       int64
		once        bool
		break_flags LineBreakFlag
	}{shaped, pointers.Get(gd.InternalPacked[gd.PackedFloat32Array, float32](width)), start, once, break_flags}))
	var ret = Packed.Array[int32](Array.Through(gd.PackedProxy[gd.PackedInt32Array, int32]{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

/*
Breaks text to the lines and returns character ranges for each line.
*/
//go:nosplit
func (self class) ShapedTextGetLineBreaks(shaped RID.Any, width float64, start int64, break_flags LineBreakFlag) Packed.Array[int32] { //gd:TextServer.shaped_text_get_line_breaks
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.shaped_text_get_line_breaks, gdextension.SizePackedArray|(gdextension.SizeRID<<4)|(gdextension.SizeFloat<<8)|(gdextension.SizeInt<<12)|(gdextension.SizeInt<<16), unsafe.Pointer(&struct {
		shaped      RID.Any
		width       float64
		start       int64
		break_flags LineBreakFlag
	}{shaped, width, start, break_flags}))
	var ret = Packed.Array[int32](Array.Through(gd.PackedProxy[gd.PackedInt32Array, int32]{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

/*
Breaks text into words and returns array of character ranges. Use [param grapheme_flags] to set what characters are used for breaking (see [enum GraphemeFlag]).
*/
//go:nosplit
func (self class) ShapedTextGetWordBreaks(shaped RID.Any, grapheme_flags GraphemeFlag, skip_grapheme_flags GraphemeFlag) Packed.Array[int32] { //gd:TextServer.shaped_text_get_word_breaks
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.shaped_text_get_word_breaks, gdextension.SizePackedArray|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		shaped              RID.Any
		grapheme_flags      GraphemeFlag
		skip_grapheme_flags GraphemeFlag
	}{shaped, grapheme_flags, skip_grapheme_flags}))
	var ret = Packed.Array[int32](Array.Through(gd.PackedProxy[gd.PackedInt32Array, int32]{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

/*
Returns the position of the overrun trim.
*/
//go:nosplit
func (self class) ShapedTextGetTrimPos(shaped RID.Any) int64 { //gd:TextServer.shaped_text_get_trim_pos
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.shaped_text_get_trim_pos, gdextension.SizeInt|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ shaped RID.Any }{shaped}))
	var ret = r_ret
	return ret
}

/*
Returns position of the ellipsis.
*/
//go:nosplit
func (self class) ShapedTextGetEllipsisPos(shaped RID.Any) int64 { //gd:TextServer.shaped_text_get_ellipsis_pos
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.shaped_text_get_ellipsis_pos, gdextension.SizeInt|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ shaped RID.Any }{shaped}))
	var ret = r_ret
	return ret
}

/*
Returns array of the glyphs in the ellipsis.
*/
//go:nosplit
func (self class) ShapedTextGetEllipsisGlyphs(shaped RID.Any) Array.Contains[Dictionary.Any] { //gd:TextServer.shaped_text_get_ellipsis_glyphs
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), methods.shaped_text_get_ellipsis_glyphs, gdextension.SizeArray|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ shaped RID.Any }{shaped}))
	var ret = Array.Through(gd.ArrayProxy[Dictionary.Any]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

/*
Returns number of glyphs in the ellipsis.
*/
//go:nosplit
func (self class) ShapedTextGetEllipsisGlyphCount(shaped RID.Any) int64 { //gd:TextServer.shaped_text_get_ellipsis_glyph_count
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.shaped_text_get_ellipsis_glyph_count, gdextension.SizeInt|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ shaped RID.Any }{shaped}))
	var ret = r_ret
	return ret
}

/*
Trims text if it exceeds the given width.
*/
//go:nosplit
func (self class) ShapedTextOverrunTrimToWidth(shaped RID.Any, width float64, overrun_trim_flags TextOverrunFlag) { //gd:TextServer.shaped_text_overrun_trim_to_width
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.shaped_text_overrun_trim_to_width, 0|(gdextension.SizeRID<<4)|(gdextension.SizeFloat<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		shaped             RID.Any
		width              float64
		overrun_trim_flags TextOverrunFlag
	}{shaped, width, overrun_trim_flags}))
}

/*
Returns array of inline objects.
*/
//go:nosplit
func (self class) ShapedTextGetObjects(shaped RID.Any) Array.Any { //gd:TextServer.shaped_text_get_objects
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), methods.shaped_text_get_objects, gdextension.SizeArray|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ shaped RID.Any }{shaped}))
	var ret = Array.Through(gd.ArrayProxy[variant.Any]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

/*
Returns bounding rectangle of the inline object.
*/
//go:nosplit
func (self class) ShapedTextGetObjectRect(shaped RID.Any, key variant.Any) Rect2.PositionSize { //gd:TextServer.shaped_text_get_object_rect
	var r_ret = gdextension.Call[Rect2.PositionSize](gd.ObjectChecked(self.AsObject()), methods.shaped_text_get_object_rect, gdextension.SizeRect2|(gdextension.SizeRID<<4)|(gdextension.SizeVariant<<8), unsafe.Pointer(&struct {
		shaped RID.Any
		key    gdextension.Variant
	}{shaped, gdextension.Variant(pointers.Get(gd.InternalVariant(key)))}))
	var ret = r_ret
	return ret
}

/*
Returns the character range of the inline object.
*/
//go:nosplit
func (self class) ShapedTextGetObjectRange(shaped RID.Any, key variant.Any) Vector2i.XY { //gd:TextServer.shaped_text_get_object_range
	var r_ret = gdextension.Call[Vector2i.XY](gd.ObjectChecked(self.AsObject()), methods.shaped_text_get_object_range, gdextension.SizeVector2i|(gdextension.SizeRID<<4)|(gdextension.SizeVariant<<8), unsafe.Pointer(&struct {
		shaped RID.Any
		key    gdextension.Variant
	}{shaped, gdextension.Variant(pointers.Get(gd.InternalVariant(key)))}))
	var ret = r_ret
	return ret
}

/*
Returns the glyph index of the inline object.
*/
//go:nosplit
func (self class) ShapedTextGetObjectGlyph(shaped RID.Any, key variant.Any) int64 { //gd:TextServer.shaped_text_get_object_glyph
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.shaped_text_get_object_glyph, gdextension.SizeInt|(gdextension.SizeRID<<4)|(gdextension.SizeVariant<<8), unsafe.Pointer(&struct {
		shaped RID.Any
		key    gdextension.Variant
	}{shaped, gdextension.Variant(pointers.Get(gd.InternalVariant(key)))}))
	var ret = r_ret
	return ret
}

/*
Returns size of the text.
*/
//go:nosplit
func (self class) ShapedTextGetSize(shaped RID.Any) Vector2.XY { //gd:TextServer.shaped_text_get_size
	var r_ret = gdextension.Call[Vector2.XY](gd.ObjectChecked(self.AsObject()), methods.shaped_text_get_size, gdextension.SizeVector2|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ shaped RID.Any }{shaped}))
	var ret = r_ret
	return ret
}

/*
Returns the text ascent (number of pixels above the baseline for horizontal layout or to the left of baseline for vertical).
[b]Note:[/b] Overall ascent can be higher than font ascent, if some glyphs are displaced from the baseline.
*/
//go:nosplit
func (self class) ShapedTextGetAscent(shaped RID.Any) float64 { //gd:TextServer.shaped_text_get_ascent
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.shaped_text_get_ascent, gdextension.SizeFloat|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ shaped RID.Any }{shaped}))
	var ret = r_ret
	return ret
}

/*
Returns the text descent (number of pixels below the baseline for horizontal layout or to the right of baseline for vertical).
[b]Note:[/b] Overall descent can be higher than font descent, if some glyphs are displaced from the baseline.
*/
//go:nosplit
func (self class) ShapedTextGetDescent(shaped RID.Any) float64 { //gd:TextServer.shaped_text_get_descent
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.shaped_text_get_descent, gdextension.SizeFloat|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ shaped RID.Any }{shaped}))
	var ret = r_ret
	return ret
}

/*
Returns width (for horizontal layout) or height (for vertical) of the text.
*/
//go:nosplit
func (self class) ShapedTextGetWidth(shaped RID.Any) float64 { //gd:TextServer.shaped_text_get_width
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.shaped_text_get_width, gdextension.SizeFloat|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ shaped RID.Any }{shaped}))
	var ret = r_ret
	return ret
}

/*
Returns pixel offset of the underline below the baseline.
*/
//go:nosplit
func (self class) ShapedTextGetUnderlinePosition(shaped RID.Any) float64 { //gd:TextServer.shaped_text_get_underline_position
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.shaped_text_get_underline_position, gdextension.SizeFloat|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ shaped RID.Any }{shaped}))
	var ret = r_ret
	return ret
}

/*
Returns thickness of the underline.
*/
//go:nosplit
func (self class) ShapedTextGetUnderlineThickness(shaped RID.Any) float64 { //gd:TextServer.shaped_text_get_underline_thickness
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.shaped_text_get_underline_thickness, gdextension.SizeFloat|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ shaped RID.Any }{shaped}))
	var ret = r_ret
	return ret
}

/*
Returns shapes of the carets corresponding to the character offset [param position] in the text. Returned caret shape is 1 pixel wide rectangle.
*/
//go:nosplit
func (self class) ShapedTextGetCarets(shaped RID.Any, position int64) Dictionary.Any { //gd:TextServer.shaped_text_get_carets
	var r_ret = gdextension.Call[gdextension.Dictionary](gd.ObjectChecked(self.AsObject()), methods.shaped_text_get_carets, gdextension.SizeDictionary|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		shaped   RID.Any
		position int64
	}{shaped, position}))
	var ret = Dictionary.Through(gd.DictionaryProxy[variant.Any, variant.Any]{}, pointers.Pack(pointers.New[gd.Dictionary](r_ret)))
	return ret
}

/*
Returns selection rectangles for the specified character range.
*/
//go:nosplit
func (self class) ShapedTextGetSelection(shaped RID.Any, start int64, end int64) Packed.Array[Vector2.XY] { //gd:TextServer.shaped_text_get_selection
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.shaped_text_get_selection, gdextension.SizePackedArray|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		shaped RID.Any
		start  int64
		end    int64
	}{shaped, start, end}))
	var ret = Packed.Array[Vector2.XY](Array.Through(gd.PackedProxy[gd.PackedVector2Array, Vector2.XY]{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

/*
Returns grapheme index at the specified pixel offset at the baseline, or [code]-1[/code] if none is found.
*/
//go:nosplit
func (self class) ShapedTextHitTestGrapheme(shaped RID.Any, coords float64) int64 { //gd:TextServer.shaped_text_hit_test_grapheme
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.shaped_text_hit_test_grapheme, gdextension.SizeInt|(gdextension.SizeRID<<4)|(gdextension.SizeFloat<<8), unsafe.Pointer(&struct {
		shaped RID.Any
		coords float64
	}{shaped, coords}))
	var ret = r_ret
	return ret
}

/*
Returns caret character offset at the specified pixel offset at the baseline. This function always returns a valid position.
*/
//go:nosplit
func (self class) ShapedTextHitTestPosition(shaped RID.Any, coords float64) int64 { //gd:TextServer.shaped_text_hit_test_position
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.shaped_text_hit_test_position, gdextension.SizeInt|(gdextension.SizeRID<<4)|(gdextension.SizeFloat<<8), unsafe.Pointer(&struct {
		shaped RID.Any
		coords float64
	}{shaped, coords}))
	var ret = r_ret
	return ret
}

/*
Returns composite character's bounds as offsets from the start of the line.
*/
//go:nosplit
func (self class) ShapedTextGetGraphemeBounds(shaped RID.Any, pos int64) Vector2.XY { //gd:TextServer.shaped_text_get_grapheme_bounds
	var r_ret = gdextension.Call[Vector2.XY](gd.ObjectChecked(self.AsObject()), methods.shaped_text_get_grapheme_bounds, gdextension.SizeVector2|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		shaped RID.Any
		pos    int64
	}{shaped, pos}))
	var ret = r_ret
	return ret
}

/*
Returns grapheme end position closest to the [param pos].
*/
//go:nosplit
func (self class) ShapedTextNextGraphemePos(shaped RID.Any, pos int64) int64 { //gd:TextServer.shaped_text_next_grapheme_pos
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.shaped_text_next_grapheme_pos, gdextension.SizeInt|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		shaped RID.Any
		pos    int64
	}{shaped, pos}))
	var ret = r_ret
	return ret
}

/*
Returns grapheme start position closest to the [param pos].
*/
//go:nosplit
func (self class) ShapedTextPrevGraphemePos(shaped RID.Any, pos int64) int64 { //gd:TextServer.shaped_text_prev_grapheme_pos
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.shaped_text_prev_grapheme_pos, gdextension.SizeInt|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		shaped RID.Any
		pos    int64
	}{shaped, pos}))
	var ret = r_ret
	return ret
}

/*
Returns array of the composite character boundaries.
*/
//go:nosplit
func (self class) ShapedTextGetCharacterBreaks(shaped RID.Any) Packed.Array[int32] { //gd:TextServer.shaped_text_get_character_breaks
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.shaped_text_get_character_breaks, gdextension.SizePackedArray|(gdextension.SizeRID<<4), unsafe.Pointer(&struct{ shaped RID.Any }{shaped}))
	var ret = Packed.Array[int32](Array.Through(gd.PackedProxy[gd.PackedInt32Array, int32]{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

/*
Returns composite character end position closest to the [param pos].
*/
//go:nosplit
func (self class) ShapedTextNextCharacterPos(shaped RID.Any, pos int64) int64 { //gd:TextServer.shaped_text_next_character_pos
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.shaped_text_next_character_pos, gdextension.SizeInt|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		shaped RID.Any
		pos    int64
	}{shaped, pos}))
	var ret = r_ret
	return ret
}

/*
Returns composite character start position closest to the [param pos].
*/
//go:nosplit
func (self class) ShapedTextPrevCharacterPos(shaped RID.Any, pos int64) int64 { //gd:TextServer.shaped_text_prev_character_pos
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.shaped_text_prev_character_pos, gdextension.SizeInt|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		shaped RID.Any
		pos    int64
	}{shaped, pos}))
	var ret = r_ret
	return ret
}

/*
Returns composite character position closest to the [param pos].
*/
//go:nosplit
func (self class) ShapedTextClosestCharacterPos(shaped RID.Any, pos int64) int64 { //gd:TextServer.shaped_text_closest_character_pos
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.shaped_text_closest_character_pos, gdextension.SizeInt|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8), unsafe.Pointer(&struct {
		shaped RID.Any
		pos    int64
	}{shaped, pos}))
	var ret = r_ret
	return ret
}

/*
Draw shaped text into a canvas item at a given position, with [param color]. [param pos] specifies the leftmost point of the baseline (for horizontal layout) or topmost point of the baseline (for vertical layout).
*/
//go:nosplit
func (self class) ShapedTextDraw(shaped RID.Any, canvas RID.Any, pos Vector2.XY, clip_l float64, clip_r float64, color Color.RGBA) { //gd:TextServer.shaped_text_draw
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.shaped_text_draw, 0|(gdextension.SizeRID<<4)|(gdextension.SizeRID<<8)|(gdextension.SizeVector2<<12)|(gdextension.SizeFloat<<16)|(gdextension.SizeFloat<<20)|(gdextension.SizeColor<<24), unsafe.Pointer(&struct {
		shaped RID.Any
		canvas RID.Any
		pos    Vector2.XY
		clip_l float64
		clip_r float64
		color  Color.RGBA
	}{shaped, canvas, pos, clip_l, clip_r, color}))
}

/*
Draw the outline of the shaped text into a canvas item at a given position, with [param color]. [param pos] specifies the leftmost point of the baseline (for horizontal layout) or topmost point of the baseline (for vertical layout).
*/
//go:nosplit
func (self class) ShapedTextDrawOutline(shaped RID.Any, canvas RID.Any, pos Vector2.XY, clip_l float64, clip_r float64, outline_size int64, color Color.RGBA) { //gd:TextServer.shaped_text_draw_outline
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.shaped_text_draw_outline, 0|(gdextension.SizeRID<<4)|(gdextension.SizeRID<<8)|(gdextension.SizeVector2<<12)|(gdextension.SizeFloat<<16)|(gdextension.SizeFloat<<20)|(gdextension.SizeInt<<24)|(gdextension.SizeColor<<28), unsafe.Pointer(&struct {
		shaped       RID.Any
		canvas       RID.Any
		pos          Vector2.XY
		clip_l       float64
		clip_r       float64
		outline_size int64
		color        Color.RGBA
	}{shaped, canvas, pos, clip_l, clip_r, outline_size, color}))
}

/*
Returns dominant direction of in the range of text.
*/
//go:nosplit
func (self class) ShapedTextGetDominantDirectionInRange(shaped RID.Any, start int64, end int64) Direction { //gd:TextServer.shaped_text_get_dominant_direction_in_range
	var r_ret = gdextension.Call[Direction](gd.ObjectChecked(self.AsObject()), methods.shaped_text_get_dominant_direction_in_range, gdextension.SizeInt|(gdextension.SizeRID<<4)|(gdextension.SizeInt<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		shaped RID.Any
		start  int64
		end    int64
	}{shaped, start, end}))
	var ret = r_ret
	return ret
}

/*
Converts a number from the Western Arabic (0..9) to the numeral systems used in [param language].
If [param language] is omitted, the active locale will be used.
*/
//go:nosplit
func (self class) FormatNumber(number String.Readable, language String.Readable) String.Readable { //gd:TextServer.format_number
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.format_number, gdextension.SizeString|(gdextension.SizeString<<4)|(gdextension.SizeString<<8), unsafe.Pointer(&struct {
		number   gdextension.String
		language gdextension.String
	}{pointers.Get(gd.InternalString(number)), pointers.Get(gd.InternalString(language))}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Converts [param number] from the numeral systems used in [param language] to Western Arabic (0..9).
*/
//go:nosplit
func (self class) ParseNumber(number String.Readable, language String.Readable) String.Readable { //gd:TextServer.parse_number
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.parse_number, gdextension.SizeString|(gdextension.SizeString<<4)|(gdextension.SizeString<<8), unsafe.Pointer(&struct {
		number   gdextension.String
		language gdextension.String
	}{pointers.Get(gd.InternalString(number)), pointers.Get(gd.InternalString(language))}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Returns percent sign used in the [param language].
*/
//go:nosplit
func (self class) PercentSign(language String.Readable) String.Readable { //gd:TextServer.percent_sign
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.percent_sign, gdextension.SizeString|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ language gdextension.String }{pointers.Get(gd.InternalString(language))}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Returns an array of the word break boundaries. Elements in the returned array are the offsets of the start and end of words. Therefore the length of the array is always even.
When [param chars_per_line] is greater than zero, line break boundaries are returned instead.
[codeblock]
var ts = TextServerManager.get_primary_interface()
# Corresponds to the substrings "The", "Godot", "Engine", and "4".
print(ts.string_get_word_breaks("The Godot Engine, 4")) # Prints [0, 3, 4, 9, 10, 16, 18, 19]
# Corresponds to the substrings "The", "Godot", "Engin", and "e, 4".
print(ts.string_get_word_breaks("The Godot Engine, 4", "en", 5)) # Prints [0, 3, 4, 9, 10, 15, 15, 19]
# Corresponds to the substrings "The Godot" and "Engine, 4".
print(ts.string_get_word_breaks("The Godot Engine, 4", "en", 10)) # Prints [0, 9, 10, 19]
[/codeblock]
*/
//go:nosplit
func (self class) StringGetWordBreaks(s String.Readable, language String.Readable, chars_per_line int64) Packed.Array[int32] { //gd:TextServer.string_get_word_breaks
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.string_get_word_breaks, gdextension.SizePackedArray|(gdextension.SizeString<<4)|(gdextension.SizeString<<8)|(gdextension.SizeInt<<12), unsafe.Pointer(&struct {
		s              gdextension.String
		language       gdextension.String
		chars_per_line int64
	}{pointers.Get(gd.InternalString(s)), pointers.Get(gd.InternalString(language)), chars_per_line}))
	var ret = Packed.Array[int32](Array.Through(gd.PackedProxy[gd.PackedInt32Array, int32]{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

/*
Returns array of the composite character boundaries.
[codeblock]
var ts = TextServerManager.get_primary_interface()
print(ts.string_get_character_breaks("Test  Test")) # Prints [1, 2, 3, 4, 5, 9, 10, 11, 12, 13, 14]
[/codeblock]
*/
//go:nosplit
func (self class) StringGetCharacterBreaks(s String.Readable, language String.Readable) Packed.Array[int32] { //gd:TextServer.string_get_character_breaks
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.string_get_character_breaks, gdextension.SizePackedArray|(gdextension.SizeString<<4)|(gdextension.SizeString<<8), unsafe.Pointer(&struct {
		s        gdextension.String
		language gdextension.String
	}{pointers.Get(gd.InternalString(s)), pointers.Get(gd.InternalString(language))}))
	var ret = Packed.Array[int32](Array.Through(gd.PackedProxy[gd.PackedInt32Array, int32]{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

/*
Returns index of the first string in [param dict] which is visually confusable with the [param string], or [code]-1[/code] if none is found.
[b]Note:[/b] This method doesn't detect invisible characters, for spoof detection use it in combination with [method spoof_check].
[b]Note:[/b] Always returns [code]-1[/code] if the server does not support the [constant FEATURE_UNICODE_SECURITY] feature.
*/
//go:nosplit
func (self class) IsConfusable(s String.Readable, dict Packed.Strings) int64 { //gd:TextServer.is_confusable
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.is_confusable, gdextension.SizeInt|(gdextension.SizeString<<4)|(gdextension.SizePackedArray<<8), unsafe.Pointer(&struct {
		s    gdextension.String
		dict gdextension.PackedArray[gdextension.String]
	}{pointers.Get(gd.InternalString(s)), pointers.Get(gd.InternalPackedStrings(dict))}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if [param string] is likely to be an attempt at confusing the reader.
[b]Note:[/b] Always returns [code]false[/code] if the server does not support the [constant FEATURE_UNICODE_SECURITY] feature.
*/
//go:nosplit
func (self class) SpoofCheck(s String.Readable) bool { //gd:TextServer.spoof_check
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.spoof_check, gdextension.SizeBool|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ s gdextension.String }{pointers.Get(gd.InternalString(s))}))
	var ret = r_ret
	return ret
}

/*
Strips diacritics from the string.
[b]Note:[/b] The result may be longer or shorter than the original.
*/
//go:nosplit
func (self class) StripDiacritics(s String.Readable) String.Readable { //gd:TextServer.strip_diacritics
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.strip_diacritics, gdextension.SizeString|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ s gdextension.String }{pointers.Get(gd.InternalString(s))}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Returns [code]true[/code] if [param string] is a valid identifier.
If the text server supports the [constant FEATURE_UNICODE_IDENTIFIERS] feature, a valid identifier must:
- Conform to normalization form C.
- Begin with a Unicode character of class XID_Start or [code]"_"[/code].
- May contain Unicode characters of class XID_Continue in the other positions.
- Use UAX #31 recommended scripts only (mixed scripts are allowed).
If the [constant FEATURE_UNICODE_IDENTIFIERS] feature is not supported, a valid identifier must:
- Begin with a Unicode character of class XID_Start or [code]"_"[/code].
- May contain Unicode characters of class XID_Continue in the other positions.
*/
//go:nosplit
func (self class) IsValidIdentifier(s String.Readable) bool { //gd:TextServer.is_valid_identifier
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_valid_identifier, gdextension.SizeBool|(gdextension.SizeString<<4), unsafe.Pointer(&struct{ s gdextension.String }{pointers.Get(gd.InternalString(s))}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if the given code point is a valid letter, i.e. it belongs to the Unicode category "L".
*/
//go:nosplit
func (self class) IsValidLetter(unicode int64) bool { //gd:TextServer.is_valid_letter
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_valid_letter, gdextension.SizeBool|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ unicode int64 }{unicode}))
	var ret = r_ret
	return ret
}

/*
Returns the string converted to uppercase.
[b]Note:[/b] Casing is locale dependent and context sensitive if server support [constant FEATURE_CONTEXT_SENSITIVE_CASE_CONVERSION] feature (supported by [TextServerAdvanced]).
[b]Note:[/b] The result may be longer or shorter than the original.
*/
//go:nosplit
func (self class) StringToUpper(s String.Readable, language String.Readable) String.Readable { //gd:TextServer.string_to_upper
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.string_to_upper, gdextension.SizeString|(gdextension.SizeString<<4)|(gdextension.SizeString<<8), unsafe.Pointer(&struct {
		s        gdextension.String
		language gdextension.String
	}{pointers.Get(gd.InternalString(s)), pointers.Get(gd.InternalString(language))}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Returns the string converted to lowercase.
[b]Note:[/b] Casing is locale dependent and context sensitive if server support [constant FEATURE_CONTEXT_SENSITIVE_CASE_CONVERSION] feature (supported by [TextServerAdvanced]).
[b]Note:[/b] The result may be longer or shorter than the original.
*/
//go:nosplit
func (self class) StringToLower(s String.Readable, language String.Readable) String.Readable { //gd:TextServer.string_to_lower
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.string_to_lower, gdextension.SizeString|(gdextension.SizeString<<4)|(gdextension.SizeString<<8), unsafe.Pointer(&struct {
		s        gdextension.String
		language gdextension.String
	}{pointers.Get(gd.InternalString(s)), pointers.Get(gd.InternalString(language))}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Returns the string converted to title case.
[b]Note:[/b] Casing is locale dependent and context sensitive if server support [constant FEATURE_CONTEXT_SENSITIVE_CASE_CONVERSION] feature (supported by [TextServerAdvanced]).
[b]Note:[/b] The result may be longer or shorter than the original.
*/
//go:nosplit
func (self class) StringToTitle(s String.Readable, language String.Readable) String.Readable { //gd:TextServer.string_to_title
	var r_ret = gdextension.Call[gdextension.String](gd.ObjectChecked(self.AsObject()), methods.string_to_title, gdextension.SizeString|(gdextension.SizeString<<4)|(gdextension.SizeString<<8), unsafe.Pointer(&struct {
		s        gdextension.String
		language gdextension.String
	}{pointers.Get(gd.InternalString(s)), pointers.Get(gd.InternalString(language))}))
	var ret = String.Via(gd.StringProxy{}, pointers.Pack(pointers.New[gd.String](r_ret)))
	return ret
}

/*
Default implementation of the BiDi algorithm override function. See [enum StructuredTextParser] for more info.
*/
//go:nosplit
func (self class) ParseStructuredText(parser_type StructuredTextParser, args Array.Any, text String.Readable) Array.Contains[Vector3i.XYZ] { //gd:TextServer.parse_structured_text
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), methods.parse_structured_text, gdextension.SizeArray|(gdextension.SizeInt<<4)|(gdextension.SizeArray<<8)|(gdextension.SizeString<<12), unsafe.Pointer(&struct {
		parser_type StructuredTextParser
		args        gdextension.Array
		text        gdextension.String
	}{parser_type, pointers.Get(gd.InternalArray(args)), pointers.Get(gd.InternalString(text))}))
	var ret = Array.Through(gd.ArrayProxy[Vector3i.XYZ]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}
func (self class) AsTextServer() Advanced         { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsTextServer() Instance      { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsTextServer() Instance { return self.Super().AsTextServer() }
func (self class) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsRefCounted() [1]gd.RefCounted { return self.Super().AsRefCounted() }
func (self Instance) AsRefCounted() [1]gd.RefCounted {
	return *((*[1]gd.RefCounted)(unsafe.Pointer(&self)))
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(RefCounted.Advanced(self.AsRefCounted()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(RefCounted.Instance(self.AsRefCounted()), name)
	}
}
func init() {
	gdclass.Register("TextServer", func(ptr gd.Object) any { return *(*Instance)(unsafe.Pointer(&ptr)) })
}

type FontAntialiasing int //gd:TextServer.FontAntialiasing

const (
	/*Font glyphs are rasterized as 1-bit bitmaps.*/
	FontAntialiasingNone FontAntialiasing = 0
	/*Font glyphs are rasterized as 8-bit grayscale anti-aliased bitmaps.*/
	FontAntialiasingGray FontAntialiasing = 1
	/*Font glyphs are rasterized for LCD screens.
	  LCD subpixel layout is determined by the value of [code]gui/theme/lcd_subpixel_layout[/code] project settings.
	  LCD subpixel anti-aliasing mode is suitable only for rendering horizontal, unscaled text in 2D.*/
	FontAntialiasingLcd FontAntialiasing = 2
)

type FontLCDSubpixelLayout int //gd:TextServer.FontLCDSubpixelLayout

const (
	/*Unknown or unsupported subpixel layout, LCD subpixel antialiasing is disabled.*/
	FontLcdSubpixelLayoutNone FontLCDSubpixelLayout = 0
	/*Horizontal RGB subpixel layout.*/
	FontLcdSubpixelLayoutHrgb FontLCDSubpixelLayout = 1
	/*Horizontal BGR subpixel layout.*/
	FontLcdSubpixelLayoutHbgr FontLCDSubpixelLayout = 2
	/*Vertical RGB subpixel layout.*/
	FontLcdSubpixelLayoutVrgb FontLCDSubpixelLayout = 3
	/*Vertical BGR subpixel layout.*/
	FontLcdSubpixelLayoutVbgr FontLCDSubpixelLayout = 4
	/*Represents the size of the [enum FontLCDSubpixelLayout] enum.*/
	FontLcdSubpixelLayoutMax FontLCDSubpixelLayout = 5
)

type Direction int //gd:TextServer.Direction

const (
	/*Text direction is determined based on contents and current locale.*/
	DirectionAuto Direction = 0
	/*Text is written from left to right.*/
	DirectionLtr Direction = 1
	/*Text is written from right to left.*/
	DirectionRtl Direction = 2
	/*Text writing direction is the same as base string writing direction. Used for BiDi override only.*/
	DirectionInherited Direction = 3
)

type Orientation int //gd:TextServer.Orientation

const (
	/*Text is written horizontally.*/
	OrientationHorizontal Orientation = 0
	/*Left to right text is written vertically from top to bottom.
	  Right to left text is written vertically from bottom to top.*/
	OrientationVertical Orientation = 1
)

type JustificationFlag int //gd:TextServer.JustificationFlag

const (
	/*Do not justify text.*/
	JustificationNone JustificationFlag = 0
	/*Justify text by adding and removing kashidas.*/
	JustificationKashida JustificationFlag = 1
	/*Justify text by changing width of the spaces between the words.*/
	JustificationWordBound JustificationFlag = 2
	/*Remove trailing and leading spaces from the justified text.*/
	JustificationTrimEdgeSpaces JustificationFlag = 4
	/*Only apply justification to the part of the text after the last tab.*/
	JustificationAfterLastTab JustificationFlag = 8
	/*Apply justification to the trimmed line with ellipsis.*/
	JustificationConstrainEllipsis JustificationFlag = 16
	/*Do not apply justification to the last line of the paragraph.*/
	JustificationSkipLastLine JustificationFlag = 32
	/*Do not apply justification to the last line of the paragraph with visible characters (takes precedence over [constant JUSTIFICATION_SKIP_LAST_LINE]).*/
	JustificationSkipLastLineWithVisibleChars JustificationFlag = 64
	/*Always apply justification to the paragraphs with a single line ([constant JUSTIFICATION_SKIP_LAST_LINE] and [constant JUSTIFICATION_SKIP_LAST_LINE_WITH_VISIBLE_CHARS] are ignored).*/
	JustificationDoNotSkipSingleLine JustificationFlag = 128
)

type AutowrapMode int //gd:TextServer.AutowrapMode

const (
	/*Autowrap is disabled.*/
	AutowrapOff AutowrapMode = 0
	/*Wraps the text inside the node's bounding rectangle by allowing to break lines at arbitrary positions, which is useful when very limited space is available.*/
	AutowrapArbitrary AutowrapMode = 1
	/*Wraps the text inside the node's bounding rectangle by soft-breaking between words.*/
	AutowrapWord AutowrapMode = 2
	/*Behaves similarly to [constant AUTOWRAP_WORD], but force-breaks a word if that single word does not fit in one line.*/
	AutowrapWordSmart AutowrapMode = 3
)

type LineBreakFlag int //gd:TextServer.LineBreakFlag

const (
	/*Do not break the line.*/
	BreakNone LineBreakFlag = 0
	/*Break the line at the line mandatory break characters (e.g. [code]"\n"[/code]).*/
	BreakMandatory LineBreakFlag = 1
	/*Break the line between the words.*/
	BreakWordBound LineBreakFlag = 2
	/*Break the line between any unconnected graphemes.*/
	BreakGraphemeBound LineBreakFlag = 4
	/*Should be used only in conjunction with [constant BREAK_WORD_BOUND], break the line between any unconnected graphemes, if it's impossible to break it between the words.*/
	BreakAdaptive LineBreakFlag = 8
	/*Remove edge spaces from the broken line segments.*/
	BreakTrimEdgeSpaces LineBreakFlag = 16
	/*Subtract first line indentation width from all lines after the first one.*/
	BreakTrimIndent LineBreakFlag = 32
)

type VisibleCharactersBehavior int //gd:TextServer.VisibleCharactersBehavior

const (
	/*Trims text before the shaping. e.g, increasing [member Label.visible_characters] or [member RichTextLabel.visible_characters] value is visually identical to typing the text.
	  [b]Note:[/b] In this mode, trimmed text is not processed at all. It is not accounted for in line breaking and size calculations.*/
	VcCharsBeforeShaping VisibleCharactersBehavior = 0
	/*Displays glyphs that are mapped to the first [member Label.visible_characters] or [member RichTextLabel.visible_characters] characters from the beginning of the text.*/
	VcCharsAfterShaping VisibleCharactersBehavior = 1
	/*Displays [member Label.visible_ratio] or [member RichTextLabel.visible_ratio] glyphs, starting from the left or from the right, depending on [member Control.layout_direction] value.*/
	VcGlyphsAuto VisibleCharactersBehavior = 2
	/*Displays [member Label.visible_ratio] or [member RichTextLabel.visible_ratio] glyphs, starting from the left.*/
	VcGlyphsLtr VisibleCharactersBehavior = 3
	/*Displays [member Label.visible_ratio] or [member RichTextLabel.visible_ratio] glyphs, starting from the right.*/
	VcGlyphsRtl VisibleCharactersBehavior = 4
)

type OverrunBehavior int //gd:TextServer.OverrunBehavior

const (
	/*No text trimming is performed.*/
	OverrunNoTrimming OverrunBehavior = 0
	/*Trims the text per character.*/
	OverrunTrimChar OverrunBehavior = 1
	/*Trims the text per word.*/
	OverrunTrimWord OverrunBehavior = 2
	/*Trims the text per character and adds an ellipsis to indicate that parts are hidden.*/
	OverrunTrimEllipsis OverrunBehavior = 3
	/*Trims the text per word and adds an ellipsis to indicate that parts are hidden.*/
	OverrunTrimWordEllipsis OverrunBehavior = 4
)

type TextOverrunFlag int //gd:TextServer.TextOverrunFlag

const (
	/*No trimming is performed.*/
	OverrunNoTrim TextOverrunFlag = 0
	/*Trims the text when it exceeds the given width.*/
	OverrunTrim TextOverrunFlag = 1
	/*Trims the text per word instead of per grapheme.*/
	OverrunTrimWordOnly TextOverrunFlag = 2
	/*Determines whether an ellipsis should be added at the end of the text.*/
	OverrunAddEllipsis TextOverrunFlag = 4
	/*Determines whether the ellipsis at the end of the text is enforced and may not be hidden.*/
	OverrunEnforceEllipsis TextOverrunFlag = 8
	/*Accounts for the text being justified before attempting to trim it (see [enum JustificationFlag]).*/
	OverrunJustificationAware TextOverrunFlag = 16
)

type GraphemeFlag int //gd:TextServer.GraphemeFlag

const (
	/*Grapheme is supported by the font, and can be drawn.*/
	GraphemeIsValid GraphemeFlag = 1
	/*Grapheme is part of right-to-left or bottom-to-top run.*/
	GraphemeIsRtl GraphemeFlag = 2
	/*Grapheme is not part of source text, it was added by justification process.*/
	GraphemeIsVirtual GraphemeFlag = 4
	/*Grapheme is whitespace.*/
	GraphemeIsSpace GraphemeFlag = 8
	/*Grapheme is mandatory break point (e.g. [code]"\n"[/code]).*/
	GraphemeIsBreakHard GraphemeFlag = 16
	/*Grapheme is optional break point (e.g. space).*/
	GraphemeIsBreakSoft GraphemeFlag = 32
	/*Grapheme is the tabulation character.*/
	GraphemeIsTab GraphemeFlag = 64
	/*Grapheme is kashida.*/
	GraphemeIsElongation GraphemeFlag = 128
	/*Grapheme is punctuation character.*/
	GraphemeIsPunctuation GraphemeFlag = 256
	/*Grapheme is underscore character.*/
	GraphemeIsUnderscore GraphemeFlag = 512
	/*Grapheme is connected to the previous grapheme. Breaking line before this grapheme is not safe.*/
	GraphemeIsConnected GraphemeFlag = 1024
	/*It is safe to insert a U+0640 before this grapheme for elongation.*/
	GraphemeIsSafeToInsertTatweel GraphemeFlag = 2048
	/*Grapheme is an object replacement character for the embedded object.*/
	GraphemeIsEmbeddedObject GraphemeFlag = 4096
	/*Grapheme is a soft hyphen.*/
	GraphemeIsSoftHyphen GraphemeFlag = 8192
)

type Hinting int //gd:TextServer.Hinting

const (
	/*Disables font hinting (smoother but less crisp).*/
	HintingNone Hinting = 0
	/*Use the light font hinting mode.*/
	HintingLight Hinting = 1
	/*Use the default font hinting mode (crisper but less smooth).
	  [b]Note:[/b] This hinting mode changes both horizontal and vertical glyph metrics. If applied to monospace font, some glyphs might have different width.*/
	HintingNormal Hinting = 2
)

type SubpixelPositioning int //gd:TextServer.SubpixelPositioning

const (
	/*Glyph horizontal position is rounded to the whole pixel size, each glyph is rasterized once.*/
	SubpixelPositioningDisabled SubpixelPositioning = 0
	/*Glyph horizontal position is rounded based on font size.
	  - To one quarter of the pixel size if font size is smaller or equal to [constant SUBPIXEL_POSITIONING_ONE_QUARTER_MAX_SIZE].
	  - To one half of the pixel size if font size is smaller or equal to [constant SUBPIXEL_POSITIONING_ONE_HALF_MAX_SIZE].
	  - To the whole pixel size for larger fonts.*/
	SubpixelPositioningAuto SubpixelPositioning = 1
	/*Glyph horizontal position is rounded to one half of the pixel size, each glyph is rasterized up to two times.*/
	SubpixelPositioningOneHalf SubpixelPositioning = 2
	/*Glyph horizontal position is rounded to one quarter of the pixel size, each glyph is rasterized up to four times.*/
	SubpixelPositioningOneQuarter SubpixelPositioning = 3
	/*Maximum font size which will use one half of the pixel subpixel positioning in [constant SUBPIXEL_POSITIONING_AUTO] mode.*/
	SubpixelPositioningOneHalfMaxSize SubpixelPositioning = 20
	/*Maximum font size which will use one quarter of the pixel subpixel positioning in [constant SUBPIXEL_POSITIONING_AUTO] mode.*/
	SubpixelPositioningOneQuarterMaxSize SubpixelPositioning = 16
)

type Feature int //gd:TextServer.Feature

const (
	/*TextServer supports simple text layouts.*/
	FeatureSimpleLayout Feature = 1
	/*TextServer supports bidirectional text layouts.*/
	FeatureBidiLayout Feature = 2
	/*TextServer supports vertical layouts.*/
	FeatureVerticalLayout Feature = 4
	/*TextServer supports complex text shaping.*/
	FeatureShaping Feature = 8
	/*TextServer supports justification using kashidas.*/
	FeatureKashidaJustification Feature = 16
	/*TextServer supports complex line/word breaking rules (e.g. dictionary based).*/
	FeatureBreakIterators Feature = 32
	/*TextServer supports loading bitmap fonts.*/
	FeatureFontBitmap Feature = 64
	/*TextServer supports loading dynamic (TrueType, OpeType, etc.) fonts.*/
	FeatureFontDynamic Feature = 128
	/*TextServer supports multichannel signed distance field dynamic font rendering.*/
	FeatureFontMsdf Feature = 256
	/*TextServer supports loading system fonts.*/
	FeatureFontSystem Feature = 512
	/*TextServer supports variable fonts.*/
	FeatureFontVariable Feature = 1024
	/*TextServer supports locale dependent and context sensitive case conversion.*/
	FeatureContextSensitiveCaseConversion Feature = 2048
	/*TextServer require external data file for some features, see [method load_support_data].*/
	FeatureUseSupportData Feature = 4096
	/*TextServer supports UAX #31 identifier validation, see [method is_valid_identifier].*/
	FeatureUnicodeIdentifiers Feature = 8192
	/*TextServer supports [url=https://unicode.org/reports/tr36/]Unicode Technical Report #36[/url] and [url=https://unicode.org/reports/tr39/]Unicode Technical Standard #39[/url] based spoof detection features.*/
	FeatureUnicodeSecurity Feature = 16384
)

type ContourPointTag int //gd:TextServer.ContourPointTag

const (
	/*Contour point is on the curve.*/
	ContourCurveTagOn ContourPointTag = 1
	/*Contour point isn't on the curve, but serves as a control point for a conic (quadratic) Bzier arc.*/
	ContourCurveTagOffConic ContourPointTag = 0
	/*Contour point isn't on the curve, but serves as a control point for a cubic Bzier arc.*/
	ContourCurveTagOffCubic ContourPointTag = 2
)

type SpacingType int //gd:TextServer.SpacingType

const (
	/*Spacing for each glyph.*/
	SpacingGlyph SpacingType = 0
	/*Spacing for the space character.*/
	SpacingSpace SpacingType = 1
	/*Spacing at the top of the line.*/
	SpacingTop SpacingType = 2
	/*Spacing at the bottom of the line.*/
	SpacingBottom SpacingType = 3
	/*Represents the size of the [enum SpacingType] enum.*/
	SpacingMax SpacingType = 4
)

type FontStyle int //gd:TextServer.FontStyle

const (
	/*Font is bold.*/
	FontBold FontStyle = 1
	/*Font is italic or oblique.*/
	FontItalic FontStyle = 2
	/*Font have fixed-width characters.*/
	FontFixedWidth FontStyle = 4
)

type StructuredTextParser int //gd:TextServer.StructuredTextParser

const (
	/*Use default Unicode BiDi algorithm.*/
	StructuredTextDefault StructuredTextParser = 0
	/*BiDi override for URI.*/
	StructuredTextUri StructuredTextParser = 1
	/*BiDi override for file path.*/
	StructuredTextFile StructuredTextParser = 2
	/*BiDi override for email.*/
	StructuredTextEmail StructuredTextParser = 3
	/*BiDi override for lists. Structured text options: list separator [String].*/
	StructuredTextList StructuredTextParser = 4
	/*BiDi override for GDScript.*/
	StructuredTextGdscript StructuredTextParser = 5
	/*User defined structured text BiDi override function.*/
	StructuredTextCustom StructuredTextParser = 6
)

type FixedSizeScaleMode int //gd:TextServer.FixedSizeScaleMode

const (
	/*Bitmap font is not scaled.*/
	FixedSizeScaleDisable FixedSizeScaleMode = 0
	/*Bitmap font is scaled to the closest integer multiple of the font's fixed size. This is the recommended option for pixel art fonts.*/
	FixedSizeScaleIntegerOnly FixedSizeScaleMode = 1
	/*Bitmap font is scaled to an arbitrary (fractional) size. This is the recommended option for non-pixel art fonts.*/
	FixedSizeScaleEnabled FixedSizeScaleMode = 2
)
