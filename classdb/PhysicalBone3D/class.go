// Code generated by the generate package DO NOT EDIT

// Package PhysicalBone3D provides methods for working with PhysicalBone3D object instances.
package PhysicalBone3D

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/CollisionObject3D"
import "graphics.gd/classdb/Node"
import "graphics.gd/classdb/Node3D"
import "graphics.gd/classdb/PhysicsBody3D"
import "graphics.gd/classdb/PhysicsDirectBodyState3D"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"
import "graphics.gd/variant/Transform3D"
import "graphics.gd/variant/Vector3"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
The [PhysicalBone3D] node is a physics body that can be used to make bones in a [Skeleton3D] react to physics.
[b]Note:[/b] In order to detect physical bones with raycasts, the [member SkeletonModifier3D.active] property of the parent [PhysicalBoneSimulator3D] must be [code]true[/code] and the [Skeleton3D]'s bone must be assigned to [PhysicalBone3D] correctly; it means that [method get_bone_id] should return a valid id ([code]>= 0[/code]).

	See [Interface] for methods that can be overridden by a [Class] that extends it.
*/
type Instance [1]gdclass.PhysicalBone3D

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	apply_central_impulse      gdextension.MethodForClass `hash:"3460891852"`
	apply_impulse              gdextension.MethodForClass `hash:"2754756483"`
	set_joint_type             gdextension.MethodForClass `hash:"2289552604"`
	get_joint_type             gdextension.MethodForClass `hash:"931347320"`
	set_joint_offset           gdextension.MethodForClass `hash:"2952846383"`
	get_joint_offset           gdextension.MethodForClass `hash:"3229777777"`
	set_joint_rotation         gdextension.MethodForClass `hash:"3460891852"`
	get_joint_rotation         gdextension.MethodForClass `hash:"3360562783"`
	set_body_offset            gdextension.MethodForClass `hash:"2952846383"`
	get_body_offset            gdextension.MethodForClass `hash:"3229777777"`
	get_simulate_physics       gdextension.MethodForClass `hash:"2240911060"`
	is_simulating_physics      gdextension.MethodForClass `hash:"2240911060"`
	get_bone_id                gdextension.MethodForClass `hash:"3905245786"`
	set_mass                   gdextension.MethodForClass `hash:"373806689"`
	get_mass                   gdextension.MethodForClass `hash:"1740695150"`
	set_friction               gdextension.MethodForClass `hash:"373806689"`
	get_friction               gdextension.MethodForClass `hash:"1740695150"`
	set_bounce                 gdextension.MethodForClass `hash:"373806689"`
	get_bounce                 gdextension.MethodForClass `hash:"1740695150"`
	set_gravity_scale          gdextension.MethodForClass `hash:"373806689"`
	get_gravity_scale          gdextension.MethodForClass `hash:"1740695150"`
	set_linear_damp_mode       gdextension.MethodForClass `hash:"1244972221"`
	get_linear_damp_mode       gdextension.MethodForClass `hash:"205884699"`
	set_angular_damp_mode      gdextension.MethodForClass `hash:"1244972221"`
	get_angular_damp_mode      gdextension.MethodForClass `hash:"205884699"`
	set_linear_damp            gdextension.MethodForClass `hash:"373806689"`
	get_linear_damp            gdextension.MethodForClass `hash:"1740695150"`
	set_angular_damp           gdextension.MethodForClass `hash:"373806689"`
	get_angular_damp           gdextension.MethodForClass `hash:"1740695150"`
	set_linear_velocity        gdextension.MethodForClass `hash:"3460891852"`
	get_linear_velocity        gdextension.MethodForClass `hash:"3360562783"`
	set_angular_velocity       gdextension.MethodForClass `hash:"3460891852"`
	get_angular_velocity       gdextension.MethodForClass `hash:"3360562783"`
	set_use_custom_integrator  gdextension.MethodForClass `hash:"2586408642"`
	is_using_custom_integrator gdextension.MethodForClass `hash:"2240911060"`
	set_can_sleep              gdextension.MethodForClass `hash:"2586408642"`
	is_able_to_sleep           gdextension.MethodForClass `hash:"36873697"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("PhysicalBone3D")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		pointers.Raw[gd.StringName](sname).Free()
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

type Expanded [1]gdclass.PhysicalBone3D

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsPhysicalBone3D() Instance
}
type Interface interface {
	//Called during physics processing, allowing you to read and safely modify the simulation state for the object. By default, it is called before the standard force integration, but the [member custom_integrator] property allows you to disable the standard force integration and do fully custom force integration for a body.
	IntegrateForces(state PhysicsDirectBodyState3D.Instance)
}

// Implementation implements [Interface] with empty methods.
type Implementation = implementation

type implementation struct{}

func (self implementation) IntegrateForces(state PhysicsDirectBodyState3D.Instance) { return }

/*
Called during physics processing, allowing you to read and safely modify the simulation state for the object. By default, it is called before the standard force integration, but the [member custom_integrator] property allows you to disable the standard force integration and do fully custom force integration for a body.
*/
func (Instance) _integrate_forces(impl func(ptr unsafe.Pointer, state PhysicsDirectBodyState3D.Instance)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var state = [1]gdclass.PhysicsDirectBodyState3D{pointers.New[gdclass.PhysicsDirectBodyState3D]([3]uint64{uint64(gd.UnsafeGet[gdextension.Object](p_args, 0))})}

		defer pointers.End(state[0])
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, state)
	}
}

/*
Applies a directional impulse without affecting rotation.
An impulse is time-independent! Applying an impulse every frame would result in a framerate-dependent force. For this reason, it should only be used when simulating one-time impacts (use the "_integrate_forces" functions otherwise).
This is equivalent to using [method apply_impulse] at the body's center of mass.
*/
func (self Instance) ApplyCentralImpulse(impulse Vector3.XYZ) { //gd:PhysicalBone3D.apply_central_impulse
	Advanced(self).ApplyCentralImpulse(Vector3.XYZ(impulse))
}

/*
Applies a positioned impulse to the PhysicsBone3D.
An impulse is time-independent! Applying an impulse every frame would result in a framerate-dependent force. For this reason, it should only be used when simulating one-time impacts (use the "_integrate_forces" functions otherwise).
[param position] is the offset from the PhysicsBone3D origin in global coordinates.
*/
func (self Instance) ApplyImpulse(impulse Vector3.XYZ) { //gd:PhysicalBone3D.apply_impulse
	Advanced(self).ApplyImpulse(Vector3.XYZ(impulse), Vector3.XYZ(gd.Vector3{0, 0, 0}))
}

/*
Applies a positioned impulse to the PhysicsBone3D.
An impulse is time-independent! Applying an impulse every frame would result in a framerate-dependent force. For this reason, it should only be used when simulating one-time impacts (use the "_integrate_forces" functions otherwise).
[param position] is the offset from the PhysicsBone3D origin in global coordinates.
*/
func (self Expanded) ApplyImpulse(impulse Vector3.XYZ, position Vector3.XYZ) { //gd:PhysicalBone3D.apply_impulse
	Advanced(self).ApplyImpulse(Vector3.XYZ(impulse), Vector3.XYZ(position))
}

/*
Returns [code]true[/code] if the PhysicsBone3D is allowed to simulate physics.
*/
func (self Instance) GetSimulatePhysics() bool { //gd:PhysicalBone3D.get_simulate_physics
	return bool(Advanced(self).GetSimulatePhysics())
}

/*
Returns [code]true[/code] if the PhysicsBone3D is currently simulating physics.
*/
func (self Instance) IsSimulatingPhysics() bool { //gd:PhysicalBone3D.is_simulating_physics
	return bool(Advanced(self).IsSimulatingPhysics())
}

/*
Returns the unique identifier of the PhysicsBone3D.
*/
func (self Instance) GetBoneId() int { //gd:PhysicalBone3D.get_bone_id
	return int(int(Advanced(self).GetBoneId()))
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.PhysicalBone3D

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.PhysicalBone3D)(unsafe.Pointer(&obj))
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = *(*gdclass.PhysicalBone3D)(unsafe.Pointer(&obj))
		return true
	}
	return false
}

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {
	object := [1]gd.Object{pointers.New[gd.Object]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})}
	casted := Instance{*(*gdclass.PhysicalBone3D)(unsafe.Pointer(&object))}
	object[0].Notification(0, false)
	return casted
}

func (self Instance) JointType() JointType {
	return JointType(class(self).GetJointType())
}

func (self Instance) SetJointType(value JointType) {
	class(self).SetJointType(value)
}

func (self Instance) JointOffset() Transform3D.BasisOrigin {
	return Transform3D.BasisOrigin(class(self).GetJointOffset())
}

func (self Instance) SetJointOffset(value Transform3D.BasisOrigin) {
	class(self).SetJointOffset(Transform3D.BasisOrigin(value))
}

func (self Instance) JointRotation() Euler.Radians {
	return Euler.Radians(Vector3.EulerRadians(class(self).GetJointRotation()))
}

func (self Instance) SetJointRotation(value Euler.Radians) {
	class(self).SetJointRotation(value.Vector3())
}

func (self Instance) BodyOffset() Transform3D.BasisOrigin {
	return Transform3D.BasisOrigin(class(self).GetBodyOffset())
}

func (self Instance) SetBodyOffset(value Transform3D.BasisOrigin) {
	class(self).SetBodyOffset(Transform3D.BasisOrigin(value))
}

func (self Instance) Mass() Float.X {
	return Float.X(Float.X(class(self).GetMass()))
}

func (self Instance) SetMass(value Float.X) {
	class(self).SetMass(float64(value))
}

func (self Instance) Friction() Float.X {
	return Float.X(Float.X(class(self).GetFriction()))
}

func (self Instance) SetFriction(value Float.X) {
	class(self).SetFriction(float64(value))
}

func (self Instance) Bounce() Float.X {
	return Float.X(Float.X(class(self).GetBounce()))
}

func (self Instance) SetBounce(value Float.X) {
	class(self).SetBounce(float64(value))
}

func (self Instance) GravityScale() Float.X {
	return Float.X(Float.X(class(self).GetGravityScale()))
}

func (self Instance) SetGravityScale(value Float.X) {
	class(self).SetGravityScale(float64(value))
}

func (self Instance) CustomIntegrator() bool {
	return bool(class(self).IsUsingCustomIntegrator())
}

func (self Instance) SetCustomIntegrator(value bool) {
	class(self).SetUseCustomIntegrator(value)
}

func (self Instance) LinearDampMode() DampMode {
	return DampMode(class(self).GetLinearDampMode())
}

func (self Instance) SetLinearDampMode(value DampMode) {
	class(self).SetLinearDampMode(value)
}

func (self Instance) LinearDamp() Float.X {
	return Float.X(Float.X(class(self).GetLinearDamp()))
}

func (self Instance) SetLinearDamp(value Float.X) {
	class(self).SetLinearDamp(float64(value))
}

func (self Instance) AngularDampMode() DampMode {
	return DampMode(class(self).GetAngularDampMode())
}

func (self Instance) SetAngularDampMode(value DampMode) {
	class(self).SetAngularDampMode(value)
}

func (self Instance) AngularDamp() Float.X {
	return Float.X(Float.X(class(self).GetAngularDamp()))
}

func (self Instance) SetAngularDamp(value Float.X) {
	class(self).SetAngularDamp(float64(value))
}

func (self Instance) LinearVelocity() Vector3.XYZ {
	return Vector3.XYZ(class(self).GetLinearVelocity())
}

func (self Instance) SetLinearVelocity(value Vector3.XYZ) {
	class(self).SetLinearVelocity(Vector3.XYZ(value))
}

func (self Instance) AngularVelocity() Vector3.XYZ {
	return Vector3.XYZ(class(self).GetAngularVelocity())
}

func (self Instance) SetAngularVelocity(value Vector3.XYZ) {
	class(self).SetAngularVelocity(Vector3.XYZ(value))
}

func (self Instance) CanSleep() bool {
	return bool(class(self).IsAbleToSleep())
}

func (self Instance) SetCanSleep(value bool) {
	class(self).SetCanSleep(value)
}

/*
Called during physics processing, allowing you to read and safely modify the simulation state for the object. By default, it is called before the standard force integration, but the [member custom_integrator] property allows you to disable the standard force integration and do fully custom force integration for a body.
*/
func (class) _integrate_forces(impl func(ptr unsafe.Pointer, state [1]gdclass.PhysicsDirectBodyState3D)) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args gd.Address, p_back gd.Address) {
		var state = [1]gdclass.PhysicsDirectBodyState3D{pointers.New[gdclass.PhysicsDirectBodyState3D]([3]uint64{uint64(gd.UnsafeGet[gdextension.Object](p_args, 0))})}

		defer pointers.End(state[0])
		self := reflect.ValueOf(class).UnsafePointer()
		impl(self, state)
	}
}

/*
Applies a directional impulse without affecting rotation.
An impulse is time-independent! Applying an impulse every frame would result in a framerate-dependent force. For this reason, it should only be used when simulating one-time impacts (use the "_integrate_forces" functions otherwise).
This is equivalent to using [method apply_impulse] at the body's center of mass.
*/
//go:nosplit
func (self class) ApplyCentralImpulse(impulse Vector3.XYZ) { //gd:PhysicalBone3D.apply_central_impulse
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.apply_central_impulse, 0|(gdextension.SizeVector3<<4), unsafe.Pointer(&struct{ impulse Vector3.XYZ }{impulse}))
}

/*
Applies a positioned impulse to the PhysicsBone3D.
An impulse is time-independent! Applying an impulse every frame would result in a framerate-dependent force. For this reason, it should only be used when simulating one-time impacts (use the "_integrate_forces" functions otherwise).
[param position] is the offset from the PhysicsBone3D origin in global coordinates.
*/
//go:nosplit
func (self class) ApplyImpulse(impulse Vector3.XYZ, position Vector3.XYZ) { //gd:PhysicalBone3D.apply_impulse
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.apply_impulse, 0|(gdextension.SizeVector3<<4)|(gdextension.SizeVector3<<8), unsafe.Pointer(&struct {
		impulse  Vector3.XYZ
		position Vector3.XYZ
	}{impulse, position}))
}

//go:nosplit
func (self class) SetJointType(joint_type JointType) { //gd:PhysicalBone3D.set_joint_type
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_joint_type, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ joint_type JointType }{joint_type}))
}

//go:nosplit
func (self class) GetJointType() JointType { //gd:PhysicalBone3D.get_joint_type
	var r_ret = gdextension.Call[JointType](gd.ObjectChecked(self.AsObject()), methods.get_joint_type, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetJointOffset(offset Transform3D.BasisOrigin) { //gd:PhysicalBone3D.set_joint_offset
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_joint_offset, 0|(gdextension.SizeTransform3D<<4), unsafe.Pointer(&struct{ offset Transform3D.BasisOrigin }{gd.Transposed(offset)}))
}

//go:nosplit
func (self class) GetJointOffset() Transform3D.BasisOrigin { //gd:PhysicalBone3D.get_joint_offset
	var r_ret = gdextension.Call[Transform3D.BasisOrigin](gd.ObjectChecked(self.AsObject()), methods.get_joint_offset, gdextension.SizeTransform3D, unsafe.Pointer(&struct{}{}))
	var ret = gd.Transposed(r_ret)
	return ret
}

//go:nosplit
func (self class) SetJointRotation(euler Vector3.XYZ) { //gd:PhysicalBone3D.set_joint_rotation
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_joint_rotation, 0|(gdextension.SizeVector3<<4), unsafe.Pointer(&struct{ euler Vector3.XYZ }{euler}))
}

//go:nosplit
func (self class) GetJointRotation() Vector3.XYZ { //gd:PhysicalBone3D.get_joint_rotation
	var r_ret = gdextension.Call[Vector3.XYZ](gd.ObjectChecked(self.AsObject()), methods.get_joint_rotation, gdextension.SizeVector3, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetBodyOffset(offset Transform3D.BasisOrigin) { //gd:PhysicalBone3D.set_body_offset
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_body_offset, 0|(gdextension.SizeTransform3D<<4), unsafe.Pointer(&struct{ offset Transform3D.BasisOrigin }{gd.Transposed(offset)}))
}

//go:nosplit
func (self class) GetBodyOffset() Transform3D.BasisOrigin { //gd:PhysicalBone3D.get_body_offset
	var r_ret = gdextension.Call[Transform3D.BasisOrigin](gd.ObjectChecked(self.AsObject()), methods.get_body_offset, gdextension.SizeTransform3D, unsafe.Pointer(&struct{}{}))
	var ret = gd.Transposed(r_ret)
	return ret
}

/*
Returns [code]true[/code] if the PhysicsBone3D is allowed to simulate physics.
*/
//go:nosplit
func (self class) GetSimulatePhysics() bool { //gd:PhysicalBone3D.get_simulate_physics
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.get_simulate_physics, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if the PhysicsBone3D is currently simulating physics.
*/
//go:nosplit
func (self class) IsSimulatingPhysics() bool { //gd:PhysicalBone3D.is_simulating_physics
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_simulating_physics, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the unique identifier of the PhysicsBone3D.
*/
//go:nosplit
func (self class) GetBoneId() int64 { //gd:PhysicalBone3D.get_bone_id
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), methods.get_bone_id, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetMass(mass float64) { //gd:PhysicalBone3D.set_mass
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_mass, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ mass float64 }{mass}))
}

//go:nosplit
func (self class) GetMass() float64 { //gd:PhysicalBone3D.get_mass
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_mass, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetFriction(friction float64) { //gd:PhysicalBone3D.set_friction
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_friction, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ friction float64 }{friction}))
}

//go:nosplit
func (self class) GetFriction() float64 { //gd:PhysicalBone3D.get_friction
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_friction, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetBounce(bounce float64) { //gd:PhysicalBone3D.set_bounce
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_bounce, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ bounce float64 }{bounce}))
}

//go:nosplit
func (self class) GetBounce() float64 { //gd:PhysicalBone3D.get_bounce
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_bounce, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetGravityScale(gravity_scale float64) { //gd:PhysicalBone3D.set_gravity_scale
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_gravity_scale, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ gravity_scale float64 }{gravity_scale}))
}

//go:nosplit
func (self class) GetGravityScale() float64 { //gd:PhysicalBone3D.get_gravity_scale
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_gravity_scale, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetLinearDampMode(linear_damp_mode DampMode) { //gd:PhysicalBone3D.set_linear_damp_mode
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_linear_damp_mode, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ linear_damp_mode DampMode }{linear_damp_mode}))
}

//go:nosplit
func (self class) GetLinearDampMode() DampMode { //gd:PhysicalBone3D.get_linear_damp_mode
	var r_ret = gdextension.Call[DampMode](gd.ObjectChecked(self.AsObject()), methods.get_linear_damp_mode, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetAngularDampMode(angular_damp_mode DampMode) { //gd:PhysicalBone3D.set_angular_damp_mode
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_angular_damp_mode, 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ angular_damp_mode DampMode }{angular_damp_mode}))
}

//go:nosplit
func (self class) GetAngularDampMode() DampMode { //gd:PhysicalBone3D.get_angular_damp_mode
	var r_ret = gdextension.Call[DampMode](gd.ObjectChecked(self.AsObject()), methods.get_angular_damp_mode, gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetLinearDamp(linear_damp float64) { //gd:PhysicalBone3D.set_linear_damp
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_linear_damp, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ linear_damp float64 }{linear_damp}))
}

//go:nosplit
func (self class) GetLinearDamp() float64 { //gd:PhysicalBone3D.get_linear_damp
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_linear_damp, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetAngularDamp(angular_damp float64) { //gd:PhysicalBone3D.set_angular_damp
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_angular_damp, 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ angular_damp float64 }{angular_damp}))
}

//go:nosplit
func (self class) GetAngularDamp() float64 { //gd:PhysicalBone3D.get_angular_damp
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_angular_damp, gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetLinearVelocity(linear_velocity Vector3.XYZ) { //gd:PhysicalBone3D.set_linear_velocity
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_linear_velocity, 0|(gdextension.SizeVector3<<4), unsafe.Pointer(&struct{ linear_velocity Vector3.XYZ }{linear_velocity}))
}

//go:nosplit
func (self class) GetLinearVelocity() Vector3.XYZ { //gd:PhysicalBone3D.get_linear_velocity
	var r_ret = gdextension.Call[Vector3.XYZ](gd.ObjectChecked(self.AsObject()), methods.get_linear_velocity, gdextension.SizeVector3, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetAngularVelocity(angular_velocity Vector3.XYZ) { //gd:PhysicalBone3D.set_angular_velocity
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_angular_velocity, 0|(gdextension.SizeVector3<<4), unsafe.Pointer(&struct{ angular_velocity Vector3.XYZ }{angular_velocity}))
}

//go:nosplit
func (self class) GetAngularVelocity() Vector3.XYZ { //gd:PhysicalBone3D.get_angular_velocity
	var r_ret = gdextension.Call[Vector3.XYZ](gd.ObjectChecked(self.AsObject()), methods.get_angular_velocity, gdextension.SizeVector3, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetUseCustomIntegrator(enable bool) { //gd:PhysicalBone3D.set_use_custom_integrator
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_use_custom_integrator, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

//go:nosplit
func (self class) IsUsingCustomIntegrator() bool { //gd:PhysicalBone3D.is_using_custom_integrator
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_using_custom_integrator, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetCanSleep(able_to_sleep bool) { //gd:PhysicalBone3D.set_can_sleep
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_can_sleep, 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ able_to_sleep bool }{able_to_sleep}))
}

//go:nosplit
func (self class) IsAbleToSleep() bool { //gd:PhysicalBone3D.is_able_to_sleep
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_able_to_sleep, gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}
func (self class) AsPhysicalBone3D() Advanced         { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsPhysicalBone3D() Instance      { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsPhysicalBone3D() Instance { return self.Super().AsPhysicalBone3D() }
func (self class) AsPhysicsBody3D() PhysicsBody3D.Advanced {
	return *((*PhysicsBody3D.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsPhysicsBody3D() PhysicsBody3D.Instance {
	return self.Super().AsPhysicsBody3D()
}
func (self Instance) AsPhysicsBody3D() PhysicsBody3D.Instance {
	return *((*PhysicsBody3D.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsCollisionObject3D() CollisionObject3D.Advanced {
	return *((*CollisionObject3D.Advanced)(unsafe.Pointer(&self)))
}
func (self *Extension[T]) AsCollisionObject3D() CollisionObject3D.Instance {
	return self.Super().AsCollisionObject3D()
}
func (self Instance) AsCollisionObject3D() CollisionObject3D.Instance {
	return *((*CollisionObject3D.Instance)(unsafe.Pointer(&self)))
}
func (self class) AsNode3D() Node3D.Advanced         { return *((*Node3D.Advanced)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsNode3D() Node3D.Instance { return self.Super().AsNode3D() }
func (self Instance) AsNode3D() Node3D.Instance      { return *((*Node3D.Instance)(unsafe.Pointer(&self))) }
func (self class) AsNode() Node.Advanced             { return *((*Node.Advanced)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsNode() Node.Instance     { return self.Super().AsNode() }
func (self Instance) AsNode() Node.Instance          { return *((*Node.Instance)(unsafe.Pointer(&self))) }

func (self class) Virtual(name string) reflect.Value {
	switch name {
	case "_integrate_forces":
		return reflect.ValueOf(self._integrate_forces)
	default:
		return gd.VirtualByName(PhysicsBody3D.Advanced(self.AsPhysicsBody3D()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	case "_integrate_forces":
		return reflect.ValueOf(self._integrate_forces)
	default:
		return gd.VirtualByName(PhysicsBody3D.Instance(self.AsPhysicsBody3D()), name)
	}
}
func init() {
	gdclass.Register("PhysicalBone3D", func(ptr gd.Object) any { return *(*Instance)(unsafe.Pointer(&ptr)) })
}

type DampMode int //gd:PhysicalBone3D.DampMode

const (
	/*In this mode, the body's damping value is added to any value set in areas or the default value.*/
	DampModeCombine DampMode = 0
	/*In this mode, the body's damping value replaces any value set in areas or the default value.*/
	DampModeReplace DampMode = 1
)

type JointType int //gd:PhysicalBone3D.JointType

const (
	/*No joint is applied to the PhysicsBone3D.*/
	JointTypeNone JointType = 0
	/*A pin joint is applied to the PhysicsBone3D.*/
	JointTypePin JointType = 1
	/*A cone joint is applied to the PhysicsBone3D.*/
	JointTypeCone JointType = 2
	/*A hinge joint is applied to the PhysicsBone3D.*/
	JointTypeHinge JointType = 3
	/*A slider joint is applied to the PhysicsBone3D.*/
	JointTypeSlider JointType = 4
	/*A 6 degrees of freedom joint is applied to the PhysicsBone3D.*/
	JointType6dof JointType = 5
)
