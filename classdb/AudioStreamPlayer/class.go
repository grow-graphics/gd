// Code generated by the generate package DO NOT EDIT

// Package AudioStreamPlayer provides methods for working with AudioStreamPlayer object instances.
package AudioStreamPlayer

import "unsafe"
import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/classdb/AudioServer"
import "graphics.gd/classdb/AudioStream"
import "graphics.gd/classdb/AudioStreamPlayback"
import "graphics.gd/classdb/Node"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ unsafe.Pointer
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
The [AudioStreamPlayer] node plays an audio stream non-positionally. It is ideal for user interfaces, menus, or background music.
To use this node, [member stream] needs to be set to a valid [AudioStream] resource. Playing more than one sound at the same time is also supported, see [member max_polyphony].
If you need to play audio at a specific position, use [AudioStreamPlayer2D] or [AudioStreamPlayer3D] instead.
*/
type Instance [1]gdclass.AudioStreamPlayer

func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

type Expanded [1]gdclass.AudioStreamPlayer

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsAudioStreamPlayer() Instance
}

/*
Plays a sound from the beginning, or the given [param from_position] in seconds.
*/
func (self Instance) Play() { //gd:AudioStreamPlayer.play
	Advanced(self).Play(float64(0.0))
}

/*
Plays a sound from the beginning, or the given [param from_position] in seconds.
*/
func (self Expanded) Play(from_position Float.X) { //gd:AudioStreamPlayer.play
	Advanced(self).Play(float64(from_position))
}

/*
Restarts all sounds to be played from the given [param to_position], in seconds. Does nothing if no sounds are playing.
*/
func (self Instance) SeekTo(to_position Float.X) { //gd:AudioStreamPlayer.seek
	Advanced(self).SeekTo(float64(to_position))
}

/*
Stops all sounds from this node.
*/
func (self Instance) Stop() { //gd:AudioStreamPlayer.stop
	Advanced(self).Stop()
}

/*
Returns the position in the [AudioStream] of the latest sound, in seconds. Returns [code]0.0[/code] if no sounds are playing.
[b]Note:[/b] The position is not always accurate, as the [AudioServer] does not mix audio every processed frame. To get more accurate results, add [method AudioServer.get_time_since_last_mix] to the returned position.
[b]Note:[/b] This method always returns [code]0.0[/code] if the [member stream] is an [AudioStreamInteractive], since it can have multiple clips playing at once.
*/
func (self Instance) GetPlaybackPosition() Float.X { //gd:AudioStreamPlayer.get_playback_position
	return Float.X(Float.X(Advanced(self).GetPlaybackPosition()))
}

/*
Returns [code]true[/code] if any sound is active, even if [member stream_paused] is set to [code]true[/code]. See also [member playing] and [method get_stream_playback].
*/
func (self Instance) HasStreamPlayback() bool { //gd:AudioStreamPlayer.has_stream_playback
	return bool(Advanced(self).HasStreamPlayback())
}

/*
Returns the latest [AudioStreamPlayback] of this node, usually the most recently created by [method play]. If no sounds are playing, this method fails and returns an empty playback.
*/
func (self Instance) GetStreamPlayback() AudioStreamPlayback.Instance { //gd:AudioStreamPlayer.get_stream_playback
	return AudioStreamPlayback.Instance(Advanced(self).GetStreamPlayback())
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.AudioStreamPlayer

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }

//go:nosplit
func (self *class) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }

//go:nosplit
func (self *Instance) UnsafePointer() unsafe.Pointer { return unsafe.Pointer(self) }
func (self *Extension[T]) AsObject() [1]gd.Object    { return self.Super().AsObject() }
func New() Instance {
	object := gd.Global.ClassDB.ConstructObject(gd.NewStringName("AudioStreamPlayer"))
	casted := Instance{*(*gdclass.AudioStreamPlayer)(unsafe.Pointer(&object))}
	return casted
}

func (self Instance) Stream() AudioStream.Instance {
	return AudioStream.Instance(class(self).GetStream())
}

func (self Instance) SetStream(value AudioStream.Instance) {
	class(self).SetStream(value)
}

func (self Instance) VolumeDb() Float.X {
	return Float.X(Float.X(class(self).GetVolumeDb()))
}

func (self Instance) SetVolumeDb(value Float.X) {
	class(self).SetVolumeDb(float64(value))
}

func (self Instance) VolumeLinear() Float.X {
	return Float.X(Float.X(class(self).GetVolumeLinear()))
}

func (self Instance) SetVolumeLinear(value Float.X) {
	class(self).SetVolumeLinear(float64(value))
}

func (self Instance) PitchScale() Float.X {
	return Float.X(Float.X(class(self).GetPitchScale()))
}

func (self Instance) SetPitchScale(value Float.X) {
	class(self).SetPitchScale(float64(value))
}

func (self Instance) Playing() bool {
	return bool(class(self).IsPlaying())
}

func (self Instance) SetPlaying(value bool) {
	class(self).SetPlaying(value)
}

func (self Instance) Autoplay() bool {
	return bool(class(self).IsAutoplayEnabled())
}

func (self Instance) SetAutoplay(value bool) {
	class(self).SetAutoplay(value)
}

func (self Instance) StreamPaused() bool {
	return bool(class(self).GetStreamPaused())
}

func (self Instance) SetStreamPaused(value bool) {
	class(self).SetStreamPaused(value)
}

func (self Instance) MixTarget() MixTarget {
	return MixTarget(class(self).GetMixTarget())
}

func (self Instance) SetMixTarget(value MixTarget) {
	class(self).SetMixTarget(value)
}

func (self Instance) MaxPolyphony() int {
	return int(int(class(self).GetMaxPolyphony()))
}

func (self Instance) SetMaxPolyphony(value int) {
	class(self).SetMaxPolyphony(int64(value))
}

func (self Instance) Bus() string {
	return string(class(self).GetBus().String())
}

func (self Instance) SetBus(value string) {
	class(self).SetBus(String.Name(String.New(value)))
}

func (self Instance) PlaybackType() AudioServer.PlaybackType {
	return AudioServer.PlaybackType(class(self).GetPlaybackType())
}

func (self Instance) SetPlaybackType(value AudioServer.PlaybackType) {
	class(self).SetPlaybackType(value)
}

//go:nosplit
func (self class) SetStream(stream [1]gdclass.AudioStream) { //gd:AudioStreamPlayer.set_stream
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.AudioStreamPlayer.Bind_set_stream), 0|(gdextension.SizeObject<<4), unsafe.Pointer(&struct{ stream gdextension.Object }{gdextension.Object(gd.ObjectChecked(stream[0].AsObject()))}))
}

//go:nosplit
func (self class) GetStream() [1]gdclass.AudioStream { //gd:AudioStreamPlayer.get_stream
	var r_ret = gdextension.Call[gd.EnginePointer](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.AudioStreamPlayer.Bind_get_stream), gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.AudioStream{gd.PointerWithOwnershipTransferredToGo[gdclass.AudioStream](r_ret)}
	return ret
}

//go:nosplit
func (self class) SetVolumeDb(volume_db float64) { //gd:AudioStreamPlayer.set_volume_db
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.AudioStreamPlayer.Bind_set_volume_db), 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ volume_db float64 }{volume_db}))
}

//go:nosplit
func (self class) GetVolumeDb() float64 { //gd:AudioStreamPlayer.get_volume_db
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.AudioStreamPlayer.Bind_get_volume_db), gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetVolumeLinear(volume_linear float64) { //gd:AudioStreamPlayer.set_volume_linear
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.AudioStreamPlayer.Bind_set_volume_linear), 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ volume_linear float64 }{volume_linear}))
}

//go:nosplit
func (self class) GetVolumeLinear() float64 { //gd:AudioStreamPlayer.get_volume_linear
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.AudioStreamPlayer.Bind_get_volume_linear), gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetPitchScale(pitch_scale float64) { //gd:AudioStreamPlayer.set_pitch_scale
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.AudioStreamPlayer.Bind_set_pitch_scale), 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ pitch_scale float64 }{pitch_scale}))
}

//go:nosplit
func (self class) GetPitchScale() float64 { //gd:AudioStreamPlayer.get_pitch_scale
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.AudioStreamPlayer.Bind_get_pitch_scale), gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Plays a sound from the beginning, or the given [param from_position] in seconds.
*/
//go:nosplit
func (self class) Play(from_position float64) { //gd:AudioStreamPlayer.play
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.AudioStreamPlayer.Bind_play), 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ from_position float64 }{from_position}))
}

/*
Restarts all sounds to be played from the given [param to_position], in seconds. Does nothing if no sounds are playing.
*/
//go:nosplit
func (self class) SeekTo(to_position float64) { //gd:AudioStreamPlayer.seek
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.AudioStreamPlayer.Bind_seek), 0|(gdextension.SizeFloat<<4), unsafe.Pointer(&struct{ to_position float64 }{to_position}))
}

/*
Stops all sounds from this node.
*/
//go:nosplit
func (self class) Stop() { //gd:AudioStreamPlayer.stop
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.AudioStreamPlayer.Bind_stop), 0, unsafe.Pointer(&struct{}{}))
}

//go:nosplit
func (self class) IsPlaying() bool { //gd:AudioStreamPlayer.is_playing
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.AudioStreamPlayer.Bind_is_playing), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the position in the [AudioStream] of the latest sound, in seconds. Returns [code]0.0[/code] if no sounds are playing.
[b]Note:[/b] The position is not always accurate, as the [AudioServer] does not mix audio every processed frame. To get more accurate results, add [method AudioServer.get_time_since_last_mix] to the returned position.
[b]Note:[/b] This method always returns [code]0.0[/code] if the [member stream] is an [AudioStreamInteractive], since it can have multiple clips playing at once.
*/
//go:nosplit
func (self class) GetPlaybackPosition() float64 { //gd:AudioStreamPlayer.get_playback_position
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.AudioStreamPlayer.Bind_get_playback_position), gdextension.SizeFloat, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetBus(bus String.Name) { //gd:AudioStreamPlayer.set_bus
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.AudioStreamPlayer.Bind_set_bus), 0|(gdextension.SizeStringName<<4), unsafe.Pointer(&struct{ bus gdextension.StringName }{gdextension.StringName(pointers.Get(gd.InternalStringName(bus))[0])}))
}

//go:nosplit
func (self class) GetBus() String.Name { //gd:AudioStreamPlayer.get_bus
	var r_ret = gdextension.Call[[1]gd.EnginePointer](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.AudioStreamPlayer.Bind_get_bus), gdextension.SizeStringName, unsafe.Pointer(&struct{}{}))
	var ret = String.Name(String.Via(gd.StringNameProxy{}, pointers.Pack(pointers.New[gd.StringName](r_ret))))
	return ret
}

//go:nosplit
func (self class) SetAutoplay(enable bool) { //gd:AudioStreamPlayer.set_autoplay
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.AudioStreamPlayer.Bind_set_autoplay), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

//go:nosplit
func (self class) IsAutoplayEnabled() bool { //gd:AudioStreamPlayer.is_autoplay_enabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.AudioStreamPlayer.Bind_is_autoplay_enabled), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetMixTarget(mix_target MixTarget) { //gd:AudioStreamPlayer.set_mix_target
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.AudioStreamPlayer.Bind_set_mix_target), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ mix_target MixTarget }{mix_target}))
}

//go:nosplit
func (self class) GetMixTarget() MixTarget { //gd:AudioStreamPlayer.get_mix_target
	var r_ret = gdextension.Call[MixTarget](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.AudioStreamPlayer.Bind_get_mix_target), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetPlaying(enable bool) { //gd:AudioStreamPlayer.set_playing
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.AudioStreamPlayer.Bind_set_playing), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ enable bool }{enable}))
}

//go:nosplit
func (self class) SetStreamPaused(pause bool) { //gd:AudioStreamPlayer.set_stream_paused
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.AudioStreamPlayer.Bind_set_stream_paused), 0|(gdextension.SizeBool<<4), unsafe.Pointer(&struct{ pause bool }{pause}))
}

//go:nosplit
func (self class) GetStreamPaused() bool { //gd:AudioStreamPlayer.get_stream_paused
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.AudioStreamPlayer.Bind_get_stream_paused), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetMaxPolyphony(max_polyphony int64) { //gd:AudioStreamPlayer.set_max_polyphony
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.AudioStreamPlayer.Bind_set_max_polyphony), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ max_polyphony int64 }{max_polyphony}))
}

//go:nosplit
func (self class) GetMaxPolyphony() int64 { //gd:AudioStreamPlayer.get_max_polyphony
	var r_ret = gdextension.Call[int64](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.AudioStreamPlayer.Bind_get_max_polyphony), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if any sound is active, even if [member stream_paused] is set to [code]true[/code]. See also [member playing] and [method get_stream_playback].
*/
//go:nosplit
func (self class) HasStreamPlayback() bool { //gd:AudioStreamPlayer.has_stream_playback
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.AudioStreamPlayer.Bind_has_stream_playback), gdextension.SizeBool, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}

/*
Returns the latest [AudioStreamPlayback] of this node, usually the most recently created by [method play]. If no sounds are playing, this method fails and returns an empty playback.
*/
//go:nosplit
func (self class) GetStreamPlayback() [1]gdclass.AudioStreamPlayback { //gd:AudioStreamPlayer.get_stream_playback
	var r_ret = gdextension.Call[gd.EnginePointer](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.AudioStreamPlayer.Bind_get_stream_playback), gdextension.SizeObject, unsafe.Pointer(&struct{}{}))
	var ret = [1]gdclass.AudioStreamPlayback{gd.PointerWithOwnershipTransferredToGo[gdclass.AudioStreamPlayback](r_ret)}
	return ret
}

//go:nosplit
func (self class) SetPlaybackType(playback_type AudioServer.PlaybackType) { //gd:AudioStreamPlayer.set_playback_type
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.AudioStreamPlayer.Bind_set_playback_type), 0|(gdextension.SizeInt<<4), unsafe.Pointer(&struct{ playback_type AudioServer.PlaybackType }{playback_type}))
}

//go:nosplit
func (self class) GetPlaybackType() AudioServer.PlaybackType { //gd:AudioStreamPlayer.get_playback_type
	var r_ret = gdextension.Call[AudioServer.PlaybackType](gd.ObjectChecked(self.AsObject()), gdextension.MethodForClass(gd.Global.Methods.AudioStreamPlayer.Bind_get_playback_type), gdextension.SizeInt, unsafe.Pointer(&struct{}{}))
	var ret = r_ret
	return ret
}
func (self Instance) OnFinished(cb func()) {
	self[0].AsObject()[0].Connect(gd.NewStringName("finished"), gd.NewCallable(cb), 0)
}

func (self class) AsAudioStreamPlayer() Advanced         { return *((*Advanced)(unsafe.Pointer(&self))) }
func (self Instance) AsAudioStreamPlayer() Instance      { return *((*Instance)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsAudioStreamPlayer() Instance { return self.Super().AsAudioStreamPlayer() }
func (self class) AsNode() Node.Advanced                 { return *((*Node.Advanced)(unsafe.Pointer(&self))) }
func (self *Extension[T]) AsNode() Node.Instance         { return self.Super().AsNode() }
func (self Instance) AsNode() Node.Instance              { return *((*Node.Instance)(unsafe.Pointer(&self))) }

func (self class) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Node.Advanced(self.AsNode()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	default:
		return gd.VirtualByName(Node.Instance(self.AsNode()), name)
	}
}
func init() {
	gdclass.Register("AudioStreamPlayer", func(ptr gd.Object) any {
		return [1]gdclass.AudioStreamPlayer{*(*gdclass.AudioStreamPlayer)(unsafe.Pointer(&ptr))}
	})
}

type MixTarget int //gd:AudioStreamPlayer.MixTarget

const (
	/*The audio will be played only on the first channel. This is the default.*/
	MixTargetStereo MixTarget = 0
	/*The audio will be played on all surround channels.*/
	MixTargetSurround MixTarget = 1
	/*The audio will be played on the second channel, which is usually the center.*/
	MixTargetCenter MixTarget = 2
)
