// Code generated by the generate package DO NOT EDIT

// Package AStarGrid2D provides methods for working with AStarGrid2D object instances.
package AStarGrid2D

import "reflect"
import "slices"
import "graphics.gd/internal/pointers"
import "graphics.gd/internal/callframe"
import "graphics.gd/internal/gdextension"
import gd "graphics.gd/internal"
import "graphics.gd/internal/gdclass"
import "graphics.gd/variant"
import "graphics.gd/variant/Angle"
import "graphics.gd/variant/Euler"
import "graphics.gd/variant/Signal"
import "graphics.gd/variant/Array"
import "graphics.gd/variant/Callable"
import "graphics.gd/variant/Dictionary"
import "graphics.gd/variant/Error"
import "graphics.gd/variant/Float"
import "graphics.gd/variant/Object"
import "graphics.gd/variant/Packed"
import "graphics.gd/variant/Path"
import "graphics.gd/variant/RID"
import "graphics.gd/variant/Rect2i"
import "graphics.gd/variant/RefCounted"
import "graphics.gd/variant/String"
import "graphics.gd/variant/Vector2"
import "graphics.gd/variant/Vector2i"

var _ Object.ID

type _ gdclass.Node

var _ gd.Object
var _ RefCounted.Instance
var _ reflect.Type
var _ callframe.Frame
var _ = pointers.Cycle
var _ = Array.Nil
var _ variant.Any
var _ Callable.Function
var _ Dictionary.Any
var _ RID.Any
var _ String.Readable
var _ Path.ToNode
var _ Packed.Bytes
var _ Error.Code
var _ Float.X
var _ Signal.Any
var _ Angle.Radians
var _ Euler.Radians
var _ gdextension.Object
var _ = slices.Delete[[]struct{}, struct{}]

/*
ID is a typed object ID (reference) to an instance of this class, use it to store references to objects with
unknown lifetimes, as an ID will not panic on use if the underlying object has been destroyed.
*/
type ID Object.ID

func (id ID) Instance() (Instance, bool) { return Object.As[Instance](Object.ID(id).Instance()) }

/*
Extension can be embedded in a new struct to create an extension of this class.
T should be the type that is embedding this [Extension]
*/
type Extension[T gdclass.Interface] struct{ gdclass.Extension[T, Instance] }

/*
[AStarGrid2D] is a variant of [AStar2D] that is specialized for partial 2D grids. It is simpler to use because it doesn't require you to manually create points and connect them together. This class also supports multiple types of heuristics, modes for diagonal movement, and a jumping mode to speed up calculations.
To use [AStarGrid2D], you only need to set the [member region] of the grid, optionally set the [member cell_size], and then call the [method update] method:
[codeblocks]
[gdscript]
var astar_grid = AStarGrid2D.new()
astar_grid.region = Rect2i(0, 0, 32, 32)
astar_grid.cell_size = Vector2(16, 16)
astar_grid.update()
print(astar_grid.get_id_path(Vector2i(0, 0), Vector2i(3, 4))) # Prints [(0, 0), (1, 1), (2, 2), (3, 3), (3, 4)]
print(astar_grid.get_point_path(Vector2i(0, 0), Vector2i(3, 4))) # Prints [(0, 0), (16, 16), (32, 32), (48, 48), (48, 64)]
[/gdscript]
[csharp]
AStarGrid2D astarGrid = new AStarGrid2D();
astarGrid.Region = new Rect2I(0, 0, 32, 32);
astarGrid.CellSize = new Vector2I(16, 16);
astarGrid.Update();
GD.Print(astarGrid.GetIdPath(Vector2I.Zero, new Vector2I(3, 4))); // Prints [(0, 0), (1, 1), (2, 2), (3, 3), (3, 4)]
GD.Print(astarGrid.GetPointPath(Vector2I.Zero, new Vector2I(3, 4))); // Prints [(0, 0), (16, 16), (32, 32), (48, 48), (48, 64)]
[/csharp]
[/codeblocks]
To remove a point from the pathfinding grid, it must be set as "solid" with [method set_point_solid].

	See [Interface] for methods that can be overridden by a [Class] that extends it.
*/
type Instance [1]gdclass.AStarGrid2D

var otype gdextension.ObjectType
var sname gdextension.StringName
var methods struct {
	set_region                     gdextension.MethodForClass `hash:"1763793166"`
	get_region                     gdextension.MethodForClass `hash:"410525958"`
	set_size                       gdextension.MethodForClass `hash:"1130785943"`
	get_size                       gdextension.MethodForClass `hash:"3690982128"`
	set_offset                     gdextension.MethodForClass `hash:"743155724"`
	get_offset                     gdextension.MethodForClass `hash:"3341600327"`
	set_cell_size                  gdextension.MethodForClass `hash:"743155724"`
	get_cell_size                  gdextension.MethodForClass `hash:"3341600327"`
	set_cell_shape                 gdextension.MethodForClass `hash:"4130591146"`
	get_cell_shape                 gdextension.MethodForClass `hash:"3293463634"`
	is_in_bounds                   gdextension.MethodForClass `hash:"2522259332"`
	is_in_boundsv                  gdextension.MethodForClass `hash:"3900751641"`
	is_dirty                       gdextension.MethodForClass `hash:"36873697"`
	update                         gdextension.MethodForClass `hash:"3218959716"`
	set_jumping_enabled            gdextension.MethodForClass `hash:"2586408642"`
	is_jumping_enabled             gdextension.MethodForClass `hash:"36873697"`
	set_diagonal_mode              gdextension.MethodForClass `hash:"1017829798"`
	get_diagonal_mode              gdextension.MethodForClass `hash:"3129282674"`
	set_default_compute_heuristic  gdextension.MethodForClass `hash:"1044375519"`
	get_default_compute_heuristic  gdextension.MethodForClass `hash:"2074731422"`
	set_default_estimate_heuristic gdextension.MethodForClass `hash:"1044375519"`
	get_default_estimate_heuristic gdextension.MethodForClass `hash:"2074731422"`
	set_point_solid                gdextension.MethodForClass `hash:"1765703753"`
	is_point_solid                 gdextension.MethodForClass `hash:"3900751641"`
	set_point_weight_scale         gdextension.MethodForClass `hash:"2262553149"`
	get_point_weight_scale         gdextension.MethodForClass `hash:"719993801"`
	fill_solid_region              gdextension.MethodForClass `hash:"2261970063"`
	fill_weight_scale_region       gdextension.MethodForClass `hash:"2793244083"`
	clear                          gdextension.MethodForClass `hash:"3218959716"`
	get_point_position             gdextension.MethodForClass `hash:"108438297"`
	get_point_data_in_region       gdextension.MethodForClass `hash:"3893818462"`
	get_point_path                 gdextension.MethodForClass `hash:"1641925693"`
	get_id_path                    gdextension.MethodForClass `hash:"1918132273"`
}

func init() {
	gd.Links = append(gd.Links, func() {
		sname = gdextension.Host.Strings.Intern.UTF8("AStarGrid2D")
		otype = gdextension.Host.Objects.Type(sname)
		gd.LinkMethods(sname, &methods, false)
	})
	gd.RegisterCleanup(func() {
		gdextension.Free(gdextension.TypeStringName, &sname)
	})
}
func (self Instance) ID() ID { return ID(Object.Instance(self.AsObject()).ID()) }

type Expanded [1]gdclass.AStarGrid2D

// Nil is a nil/null instance of the class. Equivalent to the zero value.
var Nil Instance

type Any interface {
	gd.IsClass
	AsAStarGrid2D() Instance
}
type Interface interface {
	//Called when estimating the cost between a point and the path's ending point.
	//Note that this function is hidden in the default [AStarGrid2D] class.
	EstimateCost(from_id Point, end_id Point) Float.X
	//Called when computing the cost between two connected points.
	//Note that this function is hidden in the default [AStarGrid2D] class.
	ComputeCost(from_id Point, to_id Point) Float.X
}

// Implementation implements [Interface] with empty methods.
type Implementation = implementation

type implementation struct{}

func (self implementation) EstimateCost(from_id Point, end_id Point) (_ Float.X) { return }
func (self implementation) ComputeCost(from_id Point, to_id Point) (_ Float.X)   { return }

/*
Called when estimating the cost between a point and the path's ending point.
Note that this function is hidden in the default [AStarGrid2D] class.
*/
func (Instance) _estimate_cost(impl func(ptr gdclass.Receiver, from_id Vector2i.XY, end_id Vector2i.XY) Float.X) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args, p_back gdextension.Pointer) {
		var from_id = gd.UnsafeGet[Vector2i.XY](p_args, 0)
		var end_id = gd.UnsafeGet[Vector2i.XY](p_args, 1)
		self := gdclass.Receiver(reflect.ValueOf(class).UnsafePointer())
		ret := impl(self, from_id, end_id)
		gd.UnsafeSet(p_back, float64(ret))
	}
}

/*
Called when computing the cost between two connected points.
Note that this function is hidden in the default [AStarGrid2D] class.
*/
func (Instance) _compute_cost(impl func(ptr gdclass.Receiver, from_id Vector2i.XY, to_id Vector2i.XY) Float.X) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args, p_back gdextension.Pointer) {
		var from_id = gd.UnsafeGet[Vector2i.XY](p_args, 0)
		var to_id = gd.UnsafeGet[Vector2i.XY](p_args, 1)
		self := gdclass.Receiver(reflect.ValueOf(class).UnsafePointer())
		ret := impl(self, from_id, to_id)
		gd.UnsafeSet(p_back, float64(ret))
	}
}

/*
Returns [code]true[/code] if the [param x] and [param y] is a valid grid coordinate (id), i.e. if it is inside [member region]. Equivalent to [code]region.has_point(Vector2i(x, y))[/code].
*/
func (self Instance) IsInBounds(x int, y int) bool { //gd:AStarGrid2D.is_in_bounds
	return bool(Advanced(self).IsInBounds(int64(x), int64(y)))
}

/*
Returns [code]true[/code] if the [param id] vector is a valid grid coordinate, i.e. if it is inside [member region]. Equivalent to [code]region.has_point(id)[/code].
*/
func (self Instance) IsInBoundsv(id Point) bool { //gd:AStarGrid2D.is_in_boundsv
	return bool(Advanced(self).IsInBoundsv(Vector2i.XY(id)))
}

/*
Indicates that the grid parameters were changed and [method update] needs to be called.
*/
func (self Instance) IsDirty() bool { //gd:AStarGrid2D.is_dirty
	return bool(Advanced(self).IsDirty())
}

/*
Updates the internal state of the grid according to the parameters to prepare it to search the path. Needs to be called if parameters like [member region], [member cell_size] or [member offset] are changed. [method is_dirty] will return [code]true[/code] if this is the case and this needs to be called.
[b]Note:[/b] All point data (solidity and weight scale) will be cleared.
*/
func (self Instance) Update() { //gd:AStarGrid2D.update
	Advanced(self).Update()
}

/*
Disables or enables the specified point for pathfinding. Useful for making an obstacle. By default, all points are enabled.
[b]Note:[/b] Calling [method update] is not needed after the call of this function.
*/
func (self Instance) SetPointSolid(id Point) { //gd:AStarGrid2D.set_point_solid
	Advanced(self).SetPointSolid(Vector2i.XY(id), true)
}

/*
Disables or enables the specified point for pathfinding. Useful for making an obstacle. By default, all points are enabled.
[b]Note:[/b] Calling [method update] is not needed after the call of this function.
*/
func (self Expanded) SetPointSolid(id Point, solid bool) { //gd:AStarGrid2D.set_point_solid
	Advanced(self).SetPointSolid(Vector2i.XY(id), solid)
}

/*
Returns [code]true[/code] if a point is disabled for pathfinding. By default, all points are enabled.
*/
func (self Instance) IsPointSolid(id Point) bool { //gd:AStarGrid2D.is_point_solid
	return bool(Advanced(self).IsPointSolid(Vector2i.XY(id)))
}

/*
Sets the [param weight_scale] for the point with the given [param id]. The [param weight_scale] is multiplied by the result of [method _compute_cost] when determining the overall cost of traveling across a segment from a neighboring point to this point.
[b]Note:[/b] Calling [method update] is not needed after the call of this function.
*/
func (self Instance) SetPointWeightScale(id Point, weight_scale Float.X) { //gd:AStarGrid2D.set_point_weight_scale
	Advanced(self).SetPointWeightScale(Vector2i.XY(id), float64(weight_scale))
}

/*
Returns the weight scale of the point associated with the given [param id].
*/
func (self Instance) GetPointWeightScale(id Point) Float.X { //gd:AStarGrid2D.get_point_weight_scale
	return Float.X(Float.X(Advanced(self).GetPointWeightScale(Vector2i.XY(id))))
}

/*
Fills the given [param region] on the grid with the specified value for the solid flag.
[b]Note:[/b] Calling [method update] is not needed after the call of this function.
*/
func (self Instance) FillSolidRegion(region Rect2i.PositionSize) { //gd:AStarGrid2D.fill_solid_region
	Advanced(self).FillSolidRegion(Rect2i.PositionSize(region), true)
}

/*
Fills the given [param region] on the grid with the specified value for the solid flag.
[b]Note:[/b] Calling [method update] is not needed after the call of this function.
*/
func (self Expanded) FillSolidRegion(region Rect2i.PositionSize, solid bool) { //gd:AStarGrid2D.fill_solid_region
	Advanced(self).FillSolidRegion(Rect2i.PositionSize(region), solid)
}

/*
Fills the given [param region] on the grid with the specified value for the weight scale.
[b]Note:[/b] Calling [method update] is not needed after the call of this function.
*/
func (self Instance) FillWeightScaleRegion(region Rect2i.PositionSize, weight_scale Float.X) { //gd:AStarGrid2D.fill_weight_scale_region
	Advanced(self).FillWeightScaleRegion(Rect2i.PositionSize(region), float64(weight_scale))
}

/*
Clears the grid and sets the [member region] to [code]Rect2i(0, 0, 0, 0)[/code].
*/
func (self Instance) Clear() { //gd:AStarGrid2D.clear
	Advanced(self).Clear()
}

/*
Returns the position of the point associated with the given [param id].
*/
func (self Instance) GetPointPosition(id Point) Vector2.XY { //gd:AStarGrid2D.get_point_position
	return Vector2.XY(Advanced(self).GetPointPosition(Vector2i.XY(id)))
}

/*
Returns an array of dictionaries with point data ([code]id[/code]: [Vector2i], [code]position[/code]: [Vector2], [code]solid[/code]: [bool], [code]weight_scale[/code]: [float]) within a [param region].
*/
func (self Instance) GetPointDataInRegion(region Rect2i.PositionSize) []PointData { //gd:AStarGrid2D.get_point_data_in_region
	return []PointData(gd.ArrayAs[[]PointData](gd.InternalArray(Advanced(self).GetPointDataInRegion(Rect2i.PositionSize(region)))))
}

/*
Returns an array with the points that are in the path found by [AStarGrid2D] between the given points. The array is ordered from the starting point to the ending point of the path.
If there is no valid path to the target, and [param allow_partial_path] is [code]true[/code], returns a path to the point closest to the target that can be reached.
[b]Note:[/b] This method is not thread-safe. If called from a [Thread], it will return an empty array and will print an error message.
Additionally, when [param allow_partial_path] is [code]true[/code] and [param to_id] is solid the search may take an unusually long time to finish.
*/
func (self Instance) GetPointPath(from_id Point, to_id Point) []Vector2.XY { //gd:AStarGrid2D.get_point_path
	return []Vector2.XY(slices.Collect(Advanced(self).GetPointPath(Vector2i.XY(from_id), Vector2i.XY(to_id), false).Values()))
}

/*
Returns an array with the points that are in the path found by [AStarGrid2D] between the given points. The array is ordered from the starting point to the ending point of the path.
If there is no valid path to the target, and [param allow_partial_path] is [code]true[/code], returns a path to the point closest to the target that can be reached.
[b]Note:[/b] This method is not thread-safe. If called from a [Thread], it will return an empty array and will print an error message.
Additionally, when [param allow_partial_path] is [code]true[/code] and [param to_id] is solid the search may take an unusually long time to finish.
*/
func (self Expanded) GetPointPath(from_id Point, to_id Point, allow_partial_path bool) []Vector2.XY { //gd:AStarGrid2D.get_point_path
	return []Vector2.XY(slices.Collect(Advanced(self).GetPointPath(Vector2i.XY(from_id), Vector2i.XY(to_id), allow_partial_path).Values()))
}

/*
Returns an array with the IDs of the points that form the path found by AStar2D between the given points. The array is ordered from the starting point to the ending point of the path.
If there is no valid path to the target, and [param allow_partial_path] is [code]true[/code], returns a path to the point closest to the target that can be reached.
[b]Note:[/b] When [param allow_partial_path] is [code]true[/code] and [param to_id] is solid the search may take an unusually long time to finish.
*/
func (self Instance) GetIdPath(from_id Point, to_id Point) []Point { //gd:AStarGrid2D.get_id_path
	return []Point(gd.ArrayAs[[]Point](gd.InternalArray(Advanced(self).GetIdPath(Vector2i.XY(from_id), Vector2i.XY(to_id), false))))
}

/*
Returns an array with the IDs of the points that form the path found by AStar2D between the given points. The array is ordered from the starting point to the ending point of the path.
If there is no valid path to the target, and [param allow_partial_path] is [code]true[/code], returns a path to the point closest to the target that can be reached.
[b]Note:[/b] When [param allow_partial_path] is [code]true[/code] and [param to_id] is solid the search may take an unusually long time to finish.
*/
func (self Expanded) GetIdPath(from_id Point, to_id Point, allow_partial_path bool) []Point { //gd:AStarGrid2D.get_id_path
	return []Point(gd.ArrayAs[[]Point](gd.InternalArray(Advanced(self).GetIdPath(Vector2i.XY(from_id), Vector2i.XY(to_id), allow_partial_path))))
}

// Advanced exposes a 1:1 low-level instance of the class, undocumented, for those who know what they are doing.
type Advanced = class
type class [1]gdclass.AStarGrid2D

func (self class) AsObject() [1]gd.Object { return self[0].AsObject() }
func (self *class) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = pointers.AsA[gdclass.AStarGrid2D](obj[0])
		return true
	}
	return false
}
func (self *Instance) SetObject(obj [1]gd.Object) bool {
	if gdextension.Host.Objects.Cast(gdextension.Object(pointers.Get(obj[0])[0]), otype) != 0 {
		self[0] = pointers.AsA[gdclass.AStarGrid2D](obj[0])
		return true
	}
	return false
}
func (self Instance) AsObject() [1]gd.Object      { return self[0].AsObject() }
func (self *Extension[T]) AsObject() [1]gd.Object { return self.Super().AsObject() }
func New() Instance {
	if !gd.Linked {
		var placeholder = Instance([1]gdclass.AStarGrid2D{pointers.Add[gdclass.AStarGrid2D]([3]uint64{})})
		gd.StartupFunctions = append(gd.StartupFunctions, func() {
			if gd.Linked {
				raw, _ := pointers.End(New().AsObject()[0])
				pointers.Set(pointers.AsA[gd.Object](placeholder[0]), raw)
				gd.RegisterCleanup(func() {
					if raw := pointers.Get[gd.Object](placeholder.AsObject()[0]); raw[0] != 0 && raw[1] == 0 {
						gdextension.Host.Objects.Unsafe.Free(gdextension.Object(raw[0]))
					}
				})
			}
		})
		return placeholder
	}
	casted := Instance([1]gdclass.AStarGrid2D{pointers.New[gdclass.AStarGrid2D]([3]uint64{uint64(gdextension.Host.Objects.Make(sname))})})
	casted.AsRefCounted()[0].InitRef()
	casted.AsObject()[0].Notification(0, false)
	return casted
}

func (self Instance) Region() Rect2i.PositionSize {
	return Rect2i.PositionSize(class(self).GetRegion())
}

func (self Instance) SetRegion(value Rect2i.PositionSize) {
	class(self).SetRegion(Rect2i.PositionSize(value))
}

func (self Instance) Size() Vector2i.XY {
	return Vector2i.XY(class(self).GetSize())
}

func (self Instance) SetSize(value Vector2i.XY) {
	class(self).SetSize(Vector2i.XY(value))
}

func (self Instance) Offset() Vector2.XY {
	return Vector2.XY(class(self).GetOffset())
}

func (self Instance) SetOffset(value Vector2.XY) {
	class(self).SetOffset(Vector2.XY(value))
}

func (self Instance) CellSize() Vector2.XY {
	return Vector2.XY(class(self).GetCellSize())
}

func (self Instance) SetCellSize(value Vector2.XY) {
	class(self).SetCellSize(Vector2.XY(value))
}

func (self Instance) CellShape() CellShape {
	return CellShape(class(self).GetCellShape())
}

func (self Instance) SetCellShape(value CellShape) {
	class(self).SetCellShape(value)
}

func (self Instance) JumpingEnabled() bool {
	return bool(class(self).IsJumpingEnabled())
}

func (self Instance) SetJumpingEnabled(value bool) {
	class(self).SetJumpingEnabled(value)
}

func (self Instance) DefaultComputeHeuristic() Heuristic {
	return Heuristic(class(self).GetDefaultComputeHeuristic())
}

func (self Instance) SetDefaultComputeHeuristic(value Heuristic) {
	class(self).SetDefaultComputeHeuristic(value)
}

func (self Instance) DefaultEstimateHeuristic() Heuristic {
	return Heuristic(class(self).GetDefaultEstimateHeuristic())
}

func (self Instance) SetDefaultEstimateHeuristic(value Heuristic) {
	class(self).SetDefaultEstimateHeuristic(value)
}

func (self Instance) DiagonalMode() DiagonalMode {
	return DiagonalMode(class(self).GetDiagonalMode())
}

func (self Instance) SetDiagonalMode(value DiagonalMode) {
	class(self).SetDiagonalMode(value)
}

/*
Called when estimating the cost between a point and the path's ending point.
Note that this function is hidden in the default [AStarGrid2D] class.
*/
func (class) _estimate_cost(impl func(ptr gdclass.Receiver, from_id Vector2i.XY, end_id Vector2i.XY) float64) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args, p_back gdextension.Pointer) {
		var from_id = gd.UnsafeGet[Vector2i.XY](p_args, 0)
		var end_id = gd.UnsafeGet[Vector2i.XY](p_args, 1)
		self := gdclass.Receiver(reflect.ValueOf(class).UnsafePointer())
		ret := impl(self, from_id, end_id)
		gd.UnsafeSet(p_back, ret)
	}
}

/*
Called when computing the cost between two connected points.
Note that this function is hidden in the default [AStarGrid2D] class.
*/
func (class) _compute_cost(impl func(ptr gdclass.Receiver, from_id Vector2i.XY, to_id Vector2i.XY) float64) (cb gd.ExtensionClassCallVirtualFunc) {
	return func(class any, p_args, p_back gdextension.Pointer) {
		var from_id = gd.UnsafeGet[Vector2i.XY](p_args, 0)
		var to_id = gd.UnsafeGet[Vector2i.XY](p_args, 1)
		self := gdclass.Receiver(reflect.ValueOf(class).UnsafePointer())
		ret := impl(self, from_id, to_id)
		gd.UnsafeSet(p_back, ret)
	}
}

//go:nosplit
func (self class) SetRegion(region Rect2i.PositionSize) { //gd:AStarGrid2D.set_region
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_region, 0|(gdextension.SizeRect2i<<4), &struct{ region Rect2i.PositionSize }{region})
}

//go:nosplit
func (self class) GetRegion() Rect2i.PositionSize { //gd:AStarGrid2D.get_region
	var r_ret = gdextension.Call[Rect2i.PositionSize](gd.ObjectChecked(self.AsObject()), methods.get_region, gdextension.SizeRect2i, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetSize(size Vector2i.XY) { //gd:AStarGrid2D.set_size
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_size, 0|(gdextension.SizeVector2i<<4), &struct{ size Vector2i.XY }{size})
}

//go:nosplit
func (self class) GetSize() Vector2i.XY { //gd:AStarGrid2D.get_size
	var r_ret = gdextension.Call[Vector2i.XY](gd.ObjectChecked(self.AsObject()), methods.get_size, gdextension.SizeVector2i, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetOffset(offset Vector2.XY) { //gd:AStarGrid2D.set_offset
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_offset, 0|(gdextension.SizeVector2<<4), &struct{ offset Vector2.XY }{offset})
}

//go:nosplit
func (self class) GetOffset() Vector2.XY { //gd:AStarGrid2D.get_offset
	var r_ret = gdextension.Call[Vector2.XY](gd.ObjectChecked(self.AsObject()), methods.get_offset, gdextension.SizeVector2, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetCellSize(cell_size Vector2.XY) { //gd:AStarGrid2D.set_cell_size
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_cell_size, 0|(gdextension.SizeVector2<<4), &struct{ cell_size Vector2.XY }{cell_size})
}

//go:nosplit
func (self class) GetCellSize() Vector2.XY { //gd:AStarGrid2D.get_cell_size
	var r_ret = gdextension.Call[Vector2.XY](gd.ObjectChecked(self.AsObject()), methods.get_cell_size, gdextension.SizeVector2, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetCellShape(cell_shape CellShape) { //gd:AStarGrid2D.set_cell_shape
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_cell_shape, 0|(gdextension.SizeInt<<4), &struct{ cell_shape CellShape }{cell_shape})
}

//go:nosplit
func (self class) GetCellShape() CellShape { //gd:AStarGrid2D.get_cell_shape
	var r_ret = gdextension.Call[CellShape](gd.ObjectChecked(self.AsObject()), methods.get_cell_shape, gdextension.SizeInt, &struct{}{})
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if the [param x] and [param y] is a valid grid coordinate (id), i.e. if it is inside [member region]. Equivalent to [code]region.has_point(Vector2i(x, y))[/code].
*/
//go:nosplit
func (self class) IsInBounds(x int64, y int64) bool { //gd:AStarGrid2D.is_in_bounds
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_in_bounds, gdextension.SizeBool|(gdextension.SizeInt<<4)|(gdextension.SizeInt<<8), &struct {
		x int64
		y int64
	}{x, y})
	var ret = r_ret
	return ret
}

/*
Returns [code]true[/code] if the [param id] vector is a valid grid coordinate, i.e. if it is inside [member region]. Equivalent to [code]region.has_point(id)[/code].
*/
//go:nosplit
func (self class) IsInBoundsv(id Vector2i.XY) bool { //gd:AStarGrid2D.is_in_boundsv
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_in_boundsv, gdextension.SizeBool|(gdextension.SizeVector2i<<4), &struct{ id Vector2i.XY }{id})
	var ret = r_ret
	return ret
}

/*
Indicates that the grid parameters were changed and [method update] needs to be called.
*/
//go:nosplit
func (self class) IsDirty() bool { //gd:AStarGrid2D.is_dirty
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_dirty, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

/*
Updates the internal state of the grid according to the parameters to prepare it to search the path. Needs to be called if parameters like [member region], [member cell_size] or [member offset] are changed. [method is_dirty] will return [code]true[/code] if this is the case and this needs to be called.
[b]Note:[/b] All point data (solidity and weight scale) will be cleared.
*/
//go:nosplit
func (self class) Update() { //gd:AStarGrid2D.update
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.update, 0, &struct{}{})
}

//go:nosplit
func (self class) SetJumpingEnabled(enabled bool) { //gd:AStarGrid2D.set_jumping_enabled
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_jumping_enabled, 0|(gdextension.SizeBool<<4), &struct{ enabled bool }{enabled})
}

//go:nosplit
func (self class) IsJumpingEnabled() bool { //gd:AStarGrid2D.is_jumping_enabled
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_jumping_enabled, gdextension.SizeBool, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetDiagonalMode(mode DiagonalMode) { //gd:AStarGrid2D.set_diagonal_mode
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_diagonal_mode, 0|(gdextension.SizeInt<<4), &struct{ mode DiagonalMode }{mode})
}

//go:nosplit
func (self class) GetDiagonalMode() DiagonalMode { //gd:AStarGrid2D.get_diagonal_mode
	var r_ret = gdextension.Call[DiagonalMode](gd.ObjectChecked(self.AsObject()), methods.get_diagonal_mode, gdextension.SizeInt, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetDefaultComputeHeuristic(heuristic Heuristic) { //gd:AStarGrid2D.set_default_compute_heuristic
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_default_compute_heuristic, 0|(gdextension.SizeInt<<4), &struct{ heuristic Heuristic }{heuristic})
}

//go:nosplit
func (self class) GetDefaultComputeHeuristic() Heuristic { //gd:AStarGrid2D.get_default_compute_heuristic
	var r_ret = gdextension.Call[Heuristic](gd.ObjectChecked(self.AsObject()), methods.get_default_compute_heuristic, gdextension.SizeInt, &struct{}{})
	var ret = r_ret
	return ret
}

//go:nosplit
func (self class) SetDefaultEstimateHeuristic(heuristic Heuristic) { //gd:AStarGrid2D.set_default_estimate_heuristic
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_default_estimate_heuristic, 0|(gdextension.SizeInt<<4), &struct{ heuristic Heuristic }{heuristic})
}

//go:nosplit
func (self class) GetDefaultEstimateHeuristic() Heuristic { //gd:AStarGrid2D.get_default_estimate_heuristic
	var r_ret = gdextension.Call[Heuristic](gd.ObjectChecked(self.AsObject()), methods.get_default_estimate_heuristic, gdextension.SizeInt, &struct{}{})
	var ret = r_ret
	return ret
}

/*
Disables or enables the specified point for pathfinding. Useful for making an obstacle. By default, all points are enabled.
[b]Note:[/b] Calling [method update] is not needed after the call of this function.
*/
//go:nosplit
func (self class) SetPointSolid(id Vector2i.XY, solid bool) { //gd:AStarGrid2D.set_point_solid
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_point_solid, 0|(gdextension.SizeVector2i<<4)|(gdextension.SizeBool<<8), &struct {
		id    Vector2i.XY
		solid bool
	}{id, solid})
}

/*
Returns [code]true[/code] if a point is disabled for pathfinding. By default, all points are enabled.
*/
//go:nosplit
func (self class) IsPointSolid(id Vector2i.XY) bool { //gd:AStarGrid2D.is_point_solid
	var r_ret = gdextension.Call[bool](gd.ObjectChecked(self.AsObject()), methods.is_point_solid, gdextension.SizeBool|(gdextension.SizeVector2i<<4), &struct{ id Vector2i.XY }{id})
	var ret = r_ret
	return ret
}

/*
Sets the [param weight_scale] for the point with the given [param id]. The [param weight_scale] is multiplied by the result of [method _compute_cost] when determining the overall cost of traveling across a segment from a neighboring point to this point.
[b]Note:[/b] Calling [method update] is not needed after the call of this function.
*/
//go:nosplit
func (self class) SetPointWeightScale(id Vector2i.XY, weight_scale float64) { //gd:AStarGrid2D.set_point_weight_scale
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.set_point_weight_scale, 0|(gdextension.SizeVector2i<<4)|(gdextension.SizeFloat<<8), &struct {
		id           Vector2i.XY
		weight_scale float64
	}{id, weight_scale})
}

/*
Returns the weight scale of the point associated with the given [param id].
*/
//go:nosplit
func (self class) GetPointWeightScale(id Vector2i.XY) float64 { //gd:AStarGrid2D.get_point_weight_scale
	var r_ret = gdextension.Call[float64](gd.ObjectChecked(self.AsObject()), methods.get_point_weight_scale, gdextension.SizeFloat|(gdextension.SizeVector2i<<4), &struct{ id Vector2i.XY }{id})
	var ret = r_ret
	return ret
}

/*
Fills the given [param region] on the grid with the specified value for the solid flag.
[b]Note:[/b] Calling [method update] is not needed after the call of this function.
*/
//go:nosplit
func (self class) FillSolidRegion(region Rect2i.PositionSize, solid bool) { //gd:AStarGrid2D.fill_solid_region
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.fill_solid_region, 0|(gdextension.SizeRect2i<<4)|(gdextension.SizeBool<<8), &struct {
		region Rect2i.PositionSize
		solid  bool
	}{region, solid})
}

/*
Fills the given [param region] on the grid with the specified value for the weight scale.
[b]Note:[/b] Calling [method update] is not needed after the call of this function.
*/
//go:nosplit
func (self class) FillWeightScaleRegion(region Rect2i.PositionSize, weight_scale float64) { //gd:AStarGrid2D.fill_weight_scale_region
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.fill_weight_scale_region, 0|(gdextension.SizeRect2i<<4)|(gdextension.SizeFloat<<8), &struct {
		region       Rect2i.PositionSize
		weight_scale float64
	}{region, weight_scale})
}

/*
Clears the grid and sets the [member region] to [code]Rect2i(0, 0, 0, 0)[/code].
*/
//go:nosplit
func (self class) Clear() { //gd:AStarGrid2D.clear
	gdextension.Call[struct{}](gd.ObjectChecked(self.AsObject()), methods.clear, 0, &struct{}{})
}

/*
Returns the position of the point associated with the given [param id].
*/
//go:nosplit
func (self class) GetPointPosition(id Vector2i.XY) Vector2.XY { //gd:AStarGrid2D.get_point_position
	var r_ret = gdextension.Call[Vector2.XY](gd.ObjectChecked(self.AsObject()), methods.get_point_position, gdextension.SizeVector2|(gdextension.SizeVector2i<<4), &struct{ id Vector2i.XY }{id})
	var ret = r_ret
	return ret
}

/*
Returns an array of dictionaries with point data ([code]id[/code]: [Vector2i], [code]position[/code]: [Vector2], [code]solid[/code]: [bool], [code]weight_scale[/code]: [float]) within a [param region].
*/
//go:nosplit
func (self class) GetPointDataInRegion(region Rect2i.PositionSize) Array.Contains[Dictionary.Any] { //gd:AStarGrid2D.get_point_data_in_region
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), methods.get_point_data_in_region, gdextension.SizeArray|(gdextension.SizeRect2i<<4), &struct{ region Rect2i.PositionSize }{region})
	var ret = Array.Through(gd.ArrayProxy[Dictionary.Any]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}

/*
Returns an array with the points that are in the path found by [AStarGrid2D] between the given points. The array is ordered from the starting point to the ending point of the path.
If there is no valid path to the target, and [param allow_partial_path] is [code]true[/code], returns a path to the point closest to the target that can be reached.
[b]Note:[/b] This method is not thread-safe. If called from a [Thread], it will return an empty array and will print an error message.
Additionally, when [param allow_partial_path] is [code]true[/code] and [param to_id] is solid the search may take an unusually long time to finish.
*/
//go:nosplit
func (self class) GetPointPath(from_id Vector2i.XY, to_id Vector2i.XY, allow_partial_path bool) Packed.Array[Vector2.XY] { //gd:AStarGrid2D.get_point_path
	var r_ret = gdextension.Call[gd.PackedPointers](gd.ObjectChecked(self.AsObject()), methods.get_point_path, gdextension.SizePackedArray|(gdextension.SizeVector2i<<4)|(gdextension.SizeVector2i<<8)|(gdextension.SizeBool<<12), &struct {
		from_id            Vector2i.XY
		to_id              Vector2i.XY
		allow_partial_path bool
	}{from_id, to_id, allow_partial_path})
	var ret = Packed.Array[Vector2.XY](Array.Through(gd.PackedProxy[gd.PackedVector2Array, Vector2.XY]{}, pointers.Pack(pointers.Let[gd.PackedStringArray](r_ret))))
	return ret
}

/*
Returns an array with the IDs of the points that form the path found by AStar2D between the given points. The array is ordered from the starting point to the ending point of the path.
If there is no valid path to the target, and [param allow_partial_path] is [code]true[/code], returns a path to the point closest to the target that can be reached.
[b]Note:[/b] When [param allow_partial_path] is [code]true[/code] and [param to_id] is solid the search may take an unusually long time to finish.
*/
//go:nosplit
func (self class) GetIdPath(from_id Vector2i.XY, to_id Vector2i.XY, allow_partial_path bool) Array.Contains[Vector2i.XY] { //gd:AStarGrid2D.get_id_path
	var r_ret = gdextension.Call[gdextension.Array](gd.ObjectChecked(self.AsObject()), methods.get_id_path, gdextension.SizeArray|(gdextension.SizeVector2i<<4)|(gdextension.SizeVector2i<<8)|(gdextension.SizeBool<<12), &struct {
		from_id            Vector2i.XY
		to_id              Vector2i.XY
		allow_partial_path bool
	}{from_id, to_id, allow_partial_path})
	var ret = Array.Through(gd.ArrayProxy[Vector2i.XY]{}, pointers.Pack(pointers.New[gd.Array](r_ret)))
	return ret
}
func (self class) AsAStarGrid2D() Advanced {
	return Advanced{pointers.AsA[gdclass.AStarGrid2D](self[0])}
}
func (self Instance) AsAStarGrid2D() Instance {
	return Instance{pointers.AsA[gdclass.AStarGrid2D](self[0])}
}
func (self *Extension[T]) AsAStarGrid2D() Instance { return self.Super().AsAStarGrid2D() }
func (self class) AsRefCounted() [1]gd.RefCounted {
	return [1]gd.RefCounted{gd.RefCounted(pointers.AsA[gd.Object](self[0]))}
}
func (self *Extension[T]) AsRefCounted() [1]gd.RefCounted { return self.Super().AsRefCounted() }
func (self Instance) AsRefCounted() [1]gd.RefCounted {
	return [1]gd.RefCounted{gd.RefCounted(pointers.AsA[gd.Object](self[0]))}
}

func (self class) Virtual(name string) reflect.Value {
	switch name {
	case "_estimate_cost":
		return reflect.ValueOf(self._estimate_cost)
	case "_compute_cost":
		return reflect.ValueOf(self._compute_cost)
	default:
		return gd.VirtualByName(RefCounted.Advanced(self.AsRefCounted()), name)
	}
}

func (self Instance) Virtual(name string) reflect.Value {
	switch name {
	case "_estimate_cost":
		return reflect.ValueOf(self._estimate_cost)
	case "_compute_cost":
		return reflect.ValueOf(self._compute_cost)
	default:
		return gd.VirtualByName(RefCounted.Instance(self.AsRefCounted()), name)
	}
}
func init() {
	gdclass.Register("AStarGrid2D", func(ptr gd.Object) any { return Instance{pointers.AsA[gdclass.AStarGrid2D](ptr)} })
}

type Heuristic int //gd:AStarGrid2D.Heuristic

const (
	/*The [url=https://en.wikipedia.org/wiki/Euclidean_distance]Euclidean heuristic[/url] to be used for the pathfinding using the following formula:
	  [codeblock]
	  dx = abs(to_id.x - from_id.x)
	  dy = abs(to_id.y - from_id.y)
	  result = sqrt(dx * dx + dy * dy)
	  [/codeblock]
	  [b]Note:[/b] This is also the internal heuristic used in [AStar3D] and [AStar2D] by default (with the inclusion of possible z-axis coordinate).*/
	HeuristicEuclidean Heuristic = 0
	/*The [url=https://en.wikipedia.org/wiki/Taxicab_geometry]Manhattan heuristic[/url] to be used for the pathfinding using the following formula:
	  [codeblock]
	  dx = abs(to_id.x - from_id.x)
	  dy = abs(to_id.y - from_id.y)
	  result = dx + dy
	  [/codeblock]
	  [b]Note:[/b] This heuristic is intended to be used with 4-side orthogonal movements, provided by setting the [member diagonal_mode] to [constant DIAGONAL_MODE_NEVER].*/
	HeuristicManhattan Heuristic = 1
	/*The Octile heuristic to be used for the pathfinding using the following formula:
	  [codeblock]
	  dx = abs(to_id.x - from_id.x)
	  dy = abs(to_id.y - from_id.y)
	  f = sqrt(2) - 1
	  result = (dx < dy) ? f * dx + dy : f * dy + dx;
	  [/codeblock]*/
	HeuristicOctile Heuristic = 2
	/*The [url=https://en.wikipedia.org/wiki/Chebyshev_distance]Chebyshev heuristic[/url] to be used for the pathfinding using the following formula:
	  [codeblock]
	  dx = abs(to_id.x - from_id.x)
	  dy = abs(to_id.y - from_id.y)
	  result = max(dx, dy)
	  [/codeblock]*/
	HeuristicChebyshev Heuristic = 3
	/*Represents the size of the [enum Heuristic] enum.*/
	HeuristicMax Heuristic = 4
)

type DiagonalMode int //gd:AStarGrid2D.DiagonalMode

const (
	/*The pathfinding algorithm will ignore solid neighbors around the target cell and allow passing using diagonals.*/
	DiagonalModeAlways DiagonalMode = 0
	/*The pathfinding algorithm will ignore all diagonals and the way will be always orthogonal.*/
	DiagonalModeNever DiagonalMode = 1
	/*The pathfinding algorithm will avoid using diagonals if at least two obstacles have been placed around the neighboring cells of the specific path segment.*/
	DiagonalModeAtLeastOneWalkable DiagonalMode = 2
	/*The pathfinding algorithm will avoid using diagonals if any obstacle has been placed around the neighboring cells of the specific path segment.*/
	DiagonalModeOnlyIfNoObstacles DiagonalMode = 3
	/*Represents the size of the [enum DiagonalMode] enum.*/
	DiagonalModeMax DiagonalMode = 4
)

type CellShape int //gd:AStarGrid2D.CellShape

const (
	/*Rectangular cell shape.*/
	CellShapeSquare CellShape = 0
	/*Diamond cell shape (for isometric look). Cell coordinates layout where the horizontal axis goes up-right, and the vertical one goes down-right.*/
	CellShapeIsometricRight CellShape = 1
	/*Diamond cell shape (for isometric look). Cell coordinates layout where the horizontal axis goes down-right, and the vertical one goes down-left.*/
	CellShapeIsometricDown CellShape = 2
	/*Represents the size of the [enum CellShape] enum.*/
	CellShapeMax CellShape = 3
)

type PointData struct {
	ID struct {
		X int32
		Y int32
	} `gd:"id"`
	Position struct {
		X float32
		Y float32
	} `gd:"position"`
	Solid       bool    `gd:"solid"`
	WeightScale float32 `gd:"weight_scale"`
}
