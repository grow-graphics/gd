package docgen

import (
	"encoding/xml"
	"errors"
	"fmt"
	"os"
	"path/filepath"
)

var initTemplate = `// Code generated by gd DO NOT EDIT
//
// This file is generated by the gd tool; it is regenerated every time you run gd run / gd build
// It is responsible for registering documentation for defined packages.
// Documentation data is stored in the file docs.gob

package main

import _ "embed"
import "graphics.gd/docgen"
import "fmt"

//go:embed docs.gob
var docsData []byte

func init() {
	err := docgen.RegisterDocs(docsData)
	if err != nil {
		fmt.Printf("Register docs init error: %v\n", err)
	}
}
`

func getDocPaths(basePath string) (string, string) {
	gobPath := filepath.Clean(filepath.Join(basePath, "docs.gob"))
	initPath := filepath.Clean(filepath.Join(basePath, "docs.go"))
	return gobPath, initPath
}

func deleteFile(path string) error {
	if err := os.Remove(path); err != nil {
		if os.IsNotExist(err) {
			return nil
		}
		return fmt.Errorf("could not delete %q: %w", path, err)
	}
	return nil
}

func cleanFiles(basePath string) error {
	gobPath, initPath := getDocPaths(basePath)
	err1 := deleteFile(gobPath)
	err2 := deleteFile(initPath)

	err := errors.Join(err1, err2)
	if err != nil {
		return fmt.Errorf("failed to clean files: %w", err)
	}
	return nil
}

func writeInit(outPath string) error {
	file, err := os.Create(outPath)
	if err != nil {
		return fmt.Errorf("failed to create doc init file: %w", err)
	}
	defer file.Close()
	_, err = file.WriteString(initTemplate)
	if err != nil {
		return fmt.Errorf("failed to write doc init file: %w", err)
	}
	return nil
}

func serializeDocs(docs []Class, outPath string) error {
	file, err := os.Create(outPath)
	if err != nil {
		return fmt.Errorf("failed to create doc gob file: %w", err)
	}
	defer file.Close()
	enc := xml.NewEncoder(file)
	enc.Indent("", "\t")
	if err := enc.Encode(docs); err != nil {
		return fmt.Errorf("failed to encode docs: %w", err)
	}
	return nil
}
