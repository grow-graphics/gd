//go:build !generate

// Code generated by the generate package DO NOT EDIT
package gd

import "unsafe"
import "reflect"
import "grow.graphics/gd/internal/mmm"
import "grow.graphics/gd/internal/callframe"


type Corner int64

type Orientation int64

type ClockDirection int64

type HorizontalAlignment int64

type VerticalAlignment int64

type InlineAlignment int64

type Key int64

type KeyModifierMask int64

type KeyLocation int64

type MouseButton int64

type MouseButtonMask int64

type JoyButton int64

type JoyAxis int64

type MIDIMessage int64

type Error int64

const (
/*Methods that return [enum Error] return [constant OK] when no error occurred.
Since [constant OK] has value 0, and all other error constants are positive integers, it can also be used in boolean checks.
[b]Example:[/b]
[codeblock]
var error = method_that_returns_error()
if error != OK:
    printerr("Failure!")

# Or, alternatively:
if error:
    printerr("Still failing!")
[/codeblock]
[b]Note:[/b] Many functions do not return an error code, but will print error messages to standard output.*/
	Ok Error = 0
/*Generic error.*/
	Failed Error = 1
/*Unavailable error.*/
	ErrUnavailable Error = 2
/*Unconfigured error.*/
	ErrUnconfigured Error = 3
/*Unauthorized error.*/
	ErrUnauthorized Error = 4
/*Parameter range error.*/
	ErrParameterRangeError Error = 5
/*Out of memory (OOM) error.*/
	ErrOutOfMemory Error = 6
/*File: Not found error.*/
	ErrFileNotFound Error = 7
/*File: Bad drive error.*/
	ErrFileBadDrive Error = 8
/*File: Bad path error.*/
	ErrFileBadPath Error = 9
/*File: No permission error.*/
	ErrFileNoPermission Error = 10
/*File: Already in use error.*/
	ErrFileAlreadyInUse Error = 11
/*File: Can't open error.*/
	ErrFileCantOpen Error = 12
/*File: Can't write error.*/
	ErrFileCantWrite Error = 13
/*File: Can't read error.*/
	ErrFileCantRead Error = 14
/*File: Unrecognized error.*/
	ErrFileUnrecognized Error = 15
/*File: Corrupt error.*/
	ErrFileCorrupt Error = 16
/*File: Missing dependencies error.*/
	ErrFileMissingDependencies Error = 17
/*File: End of file (EOF) error.*/
	ErrFileEof Error = 18
/*Can't open error.*/
	ErrCantOpen Error = 19
/*Can't create error.*/
	ErrCantCreate Error = 20
/*Query failed error.*/
	ErrQueryFailed Error = 21
/*Already in use error.*/
	ErrAlreadyInUse Error = 22
/*Locked error.*/
	ErrLocked Error = 23
/*Timeout error.*/
	ErrTimeout Error = 24
/*Can't connect error.*/
	ErrCantConnect Error = 25
/*Can't resolve error.*/
	ErrCantResolve Error = 26
/*Connection error.*/
	ErrConnectionError Error = 27
/*Can't acquire resource error.*/
	ErrCantAcquireResource Error = 28
/*Can't fork process error.*/
	ErrCantFork Error = 29
/*Invalid data error.*/
	ErrInvalidData Error = 30
/*Invalid parameter error.*/
	ErrInvalidParameter Error = 31
/*Already exists error.*/
	ErrAlreadyExists Error = 32
/*Does not exist error.*/
	ErrDoesNotExist Error = 33
/*Database: Read error.*/
	ErrDatabaseCantRead Error = 34
/*Database: Write error.*/
	ErrDatabaseCantWrite Error = 35
/*Compilation failed error.*/
	ErrCompilationFailed Error = 36
/*Method not found error.*/
	ErrMethodNotFound Error = 37
/*Linking failed error.*/
	ErrLinkFailed Error = 38
/*Script failed error.*/
	ErrScriptFailed Error = 39
/*Cycling link (import cycle) error.*/
	ErrCyclicLink Error = 40
/*Invalid declaration error.*/
	ErrInvalidDeclaration Error = 41
/*Duplicate symbol error.*/
	ErrDuplicateSymbol Error = 42
/*Parse error.*/
	ErrParseError Error = 43
/*Busy error.*/
	ErrBusy Error = 44
/*Skip error.*/
	ErrSkip Error = 45
/*Help error. Used internally when passing [code]--version[/code] or [code]--help[/code] as executable options.*/
	ErrHelp Error = 46
/*Bug error, caused by an implementation issue in the method.
[b]Note:[/b] If a built-in method returns this code, please open an issue on [url=https://github.com/godotengine/godot/issues]the GitHub Issue Tracker[/url].*/
	ErrBug Error = 47
/*Printer on fire error (This is an easter egg, no built-in methods return this error code).*/
	ErrPrinterOnFire Error = 48
)

type PropertyHint int64

type PropertyUsageFlags int64

type MethodFlags int64

type VariantType int64

const (
/*Variable is [code]null[/code].*/
	TypeNil VariantType = 0
/*Variable is of type [bool].*/
	TypeBool VariantType = 1
/*Variable is of type [int].*/
	TypeInt VariantType = 2
/*Variable is of type [float].*/
	TypeFloat VariantType = 3
/*Variable is of type [String].*/
	TypeString VariantType = 4
/*Variable is of type [Vector2].*/
	TypeVector2 VariantType = 5
/*Variable is of type [Vector2i].*/
	TypeVector2i VariantType = 6
/*Variable is of type [Rect2].*/
	TypeRect2 VariantType = 7
/*Variable is of type [Rect2i].*/
	TypeRect2i VariantType = 8
/*Variable is of type [Vector3].*/
	TypeVector3 VariantType = 9
/*Variable is of type [Vector3i].*/
	TypeVector3i VariantType = 10
/*Variable is of type [Transform2D].*/
	TypeTransform2d VariantType = 11
/*Variable is of type [Vector4].*/
	TypeVector4 VariantType = 12
/*Variable is of type [Vector4i].*/
	TypeVector4i VariantType = 13
/*Variable is of type [Plane].*/
	TypePlane VariantType = 14
/*Variable is of type [Quaternion].*/
	TypeQuaternion VariantType = 15
/*Variable is of type [AABB].*/
	TypeAabb VariantType = 16
/*Variable is of type [Basis].*/
	TypeBasis VariantType = 17
/*Variable is of type [Transform3D].*/
	TypeTransform3d VariantType = 18
/*Variable is of type [Projection].*/
	TypeProjection VariantType = 19
/*Variable is of type [Color].*/
	TypeColor VariantType = 20
/*Variable is of type [StringName].*/
	TypeStringName VariantType = 21
/*Variable is of type [NodePath].*/
	TypeNodePath VariantType = 22
/*Variable is of type [RID].*/
	TypeRid VariantType = 23
/*Variable is of type [Object].*/
	TypeObject VariantType = 24
/*Variable is of type [Callable].*/
	TypeCallable VariantType = 25
/*Variable is of type [Signal].*/
	TypeSignal VariantType = 26
/*Variable is of type [Dictionary].*/
	TypeDictionary VariantType = 27
/*Variable is of type [Array].*/
	TypeArray VariantType = 28
/*Variable is of type [PackedByteArray].*/
	TypePackedByteArray VariantType = 29
/*Variable is of type [PackedInt32Array].*/
	TypePackedInt32Array VariantType = 30
/*Variable is of type [PackedInt64Array].*/
	TypePackedInt64Array VariantType = 31
/*Variable is of type [PackedFloat32Array].*/
	TypePackedFloat32Array VariantType = 32
/*Variable is of type [PackedFloat64Array].*/
	TypePackedFloat64Array VariantType = 33
/*Variable is of type [PackedStringArray].*/
	TypePackedStringArray VariantType = 34
/*Variable is of type [PackedVector2Array].*/
	TypePackedVector2Array VariantType = 35
/*Variable is of type [PackedVector3Array].*/
	TypePackedVector3Array VariantType = 36
/*Variable is of type [PackedColorArray].*/
	TypePackedColorArray VariantType = 37
/*Variable is of type [PackedVector4Array].*/
	TypePackedVector4Array VariantType = 38
/*Represents the size of the [enum Variant.Type] enum.*/
	TypeMax VariantType = 39
)

type VariantOperator int64

func (ctx Lifetime) Sin(angle_rad Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, angle_rad)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.sin(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) Cos(angle_rad Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, angle_rad)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.cos(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) Tan(angle_rad Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, angle_rad)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.tan(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) Sinh(x Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, x)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.sinh(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) Cosh(x Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, x)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.cosh(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) Tanh(x Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, x)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.tanh(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) Asin(x Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, x)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.asin(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) Acos(x Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, x)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.acos(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) Atan(x Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, x)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.atan(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) Atan2(y Float, x Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, y)
	callframe.Arg(frame, x)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.atan2(r_ret.Uintptr(), frame.Array(0), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) Asinh(x Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, x)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.asinh(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) Acosh(x Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, x)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.acosh(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) Atanh(x Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, x)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.atanh(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) Sqrt(x Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, x)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.sqrt(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) Fmod(x Float, y Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, x)
	callframe.Arg(frame, y)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.fmod(r_ret.Uintptr(), frame.Array(0), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) Fposmod(x Float, y Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, x)
	callframe.Arg(frame, y)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.fposmod(r_ret.Uintptr(), frame.Array(0), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) Posmod(x Int, y Int) Int {
	var frame = callframe.New()
	callframe.Arg(frame, x)
	callframe.Arg(frame, y)
	var r_ret = callframe.Ret[Int](frame)
	ctx.API.utility.posmod(r_ret.Uintptr(), frame.Array(0), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) Floor(x Variant) Variant {
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(x))
	var r_ret = callframe.Ret[[3]uintptr](frame)
	ctx.API.utility.floor(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

func (ctx Lifetime) Floorf(x Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, x)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.floorf(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) Floori(x Float) Int {
	var frame = callframe.New()
	callframe.Arg(frame, x)
	var r_ret = callframe.Ret[Int](frame)
	ctx.API.utility.floori(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) Ceil(x Variant) Variant {
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(x))
	var r_ret = callframe.Ret[[3]uintptr](frame)
	ctx.API.utility.ceil(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

func (ctx Lifetime) Ceilf(x Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, x)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.ceilf(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) Ceili(x Float) Int {
	var frame = callframe.New()
	callframe.Arg(frame, x)
	var r_ret = callframe.Ret[Int](frame)
	ctx.API.utility.ceili(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) Round(x Variant) Variant {
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(x))
	var r_ret = callframe.Ret[[3]uintptr](frame)
	ctx.API.utility.round(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

func (ctx Lifetime) Roundf(x Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, x)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.roundf(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) Roundi(x Float) Int {
	var frame = callframe.New()
	callframe.Arg(frame, x)
	var r_ret = callframe.Ret[Int](frame)
	ctx.API.utility.roundi(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) Abs(x Variant) Variant {
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(x))
	var r_ret = callframe.Ret[[3]uintptr](frame)
	ctx.API.utility.abs(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

func (ctx Lifetime) Absf(x Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, x)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.absf(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) Absi(x Int) Int {
	var frame = callframe.New()
	callframe.Arg(frame, x)
	var r_ret = callframe.Ret[Int](frame)
	ctx.API.utility.absi(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) Sign(x Variant) Variant {
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(x))
	var r_ret = callframe.Ret[[3]uintptr](frame)
	ctx.API.utility.sign(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

func (ctx Lifetime) Signf(x Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, x)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.signf(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) Signi(x Int) Int {
	var frame = callframe.New()
	callframe.Arg(frame, x)
	var r_ret = callframe.Ret[Int](frame)
	ctx.API.utility.signi(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) Snapped(x Variant, step Variant) Variant {
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(x))
	callframe.Arg(frame, mmm.Get(step))
	var r_ret = callframe.Ret[[3]uintptr](frame)
	ctx.API.utility.snapped(r_ret.Uintptr(), frame.Array(0), 2)
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

func (ctx Lifetime) Snappedf(x Float, step Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, x)
	callframe.Arg(frame, step)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.snappedf(r_ret.Uintptr(), frame.Array(0), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) Snappedi(x Float, step Int) Int {
	var frame = callframe.New()
	callframe.Arg(frame, x)
	callframe.Arg(frame, step)
	var r_ret = callframe.Ret[Int](frame)
	ctx.API.utility.snappedi(r_ret.Uintptr(), frame.Array(0), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) Pow(base Float, exp Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, base)
	callframe.Arg(frame, exp)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.pow(r_ret.Uintptr(), frame.Array(0), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) Log(x Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, x)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.log(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) Exp(x Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, x)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.exp(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) IsNan(x Float) bool {
	var frame = callframe.New()
	callframe.Arg(frame, x)
	var r_ret = callframe.Ret[bool](frame)
	ctx.API.utility.is_nan(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) IsInf(x Float) bool {
	var frame = callframe.New()
	callframe.Arg(frame, x)
	var r_ret = callframe.Ret[bool](frame)
	ctx.API.utility.is_inf(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) IsEqualApprox(a Float, b Float) bool {
	var frame = callframe.New()
	callframe.Arg(frame, a)
	callframe.Arg(frame, b)
	var r_ret = callframe.Ret[bool](frame)
	ctx.API.utility.is_equal_approx(r_ret.Uintptr(), frame.Array(0), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) IsZeroApprox(x Float) bool {
	var frame = callframe.New()
	callframe.Arg(frame, x)
	var r_ret = callframe.Ret[bool](frame)
	ctx.API.utility.is_zero_approx(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) IsFinite(x Float) bool {
	var frame = callframe.New()
	callframe.Arg(frame, x)
	var r_ret = callframe.Ret[bool](frame)
	ctx.API.utility.is_finite(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) Ease(x Float, curve Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, x)
	callframe.Arg(frame, curve)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.ease(r_ret.Uintptr(), frame.Array(0), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) StepDecimals(x Float) Int {
	var frame = callframe.New()
	callframe.Arg(frame, x)
	var r_ret = callframe.Ret[Int](frame)
	ctx.API.utility.step_decimals(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) Lerp(from Variant, to Variant, weight Variant) Variant {
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(from))
	callframe.Arg(frame, mmm.Get(to))
	callframe.Arg(frame, mmm.Get(weight))
	var r_ret = callframe.Ret[[3]uintptr](frame)
	ctx.API.utility.lerp(r_ret.Uintptr(), frame.Array(0), 3)
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

func (ctx Lifetime) Lerpf(from Float, to Float, weight Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, from)
	callframe.Arg(frame, to)
	callframe.Arg(frame, weight)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.lerpf(r_ret.Uintptr(), frame.Array(0), 3)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) CubicInterpolate(from Float, to Float, pre Float, post Float, weight Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, from)
	callframe.Arg(frame, to)
	callframe.Arg(frame, pre)
	callframe.Arg(frame, post)
	callframe.Arg(frame, weight)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.cubic_interpolate(r_ret.Uintptr(), frame.Array(0), 5)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) CubicInterpolateAngle(from Float, to Float, pre Float, post Float, weight Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, from)
	callframe.Arg(frame, to)
	callframe.Arg(frame, pre)
	callframe.Arg(frame, post)
	callframe.Arg(frame, weight)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.cubic_interpolate_angle(r_ret.Uintptr(), frame.Array(0), 5)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) CubicInterpolateInTime(from Float, to Float, pre Float, post Float, weight Float, to_t Float, pre_t Float, post_t Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, from)
	callframe.Arg(frame, to)
	callframe.Arg(frame, pre)
	callframe.Arg(frame, post)
	callframe.Arg(frame, weight)
	callframe.Arg(frame, to_t)
	callframe.Arg(frame, pre_t)
	callframe.Arg(frame, post_t)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.cubic_interpolate_in_time(r_ret.Uintptr(), frame.Array(0), 8)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) CubicInterpolateAngleInTime(from Float, to Float, pre Float, post Float, weight Float, to_t Float, pre_t Float, post_t Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, from)
	callframe.Arg(frame, to)
	callframe.Arg(frame, pre)
	callframe.Arg(frame, post)
	callframe.Arg(frame, weight)
	callframe.Arg(frame, to_t)
	callframe.Arg(frame, pre_t)
	callframe.Arg(frame, post_t)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.cubic_interpolate_angle_in_time(r_ret.Uintptr(), frame.Array(0), 8)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) BezierInterpolate(start Float, control_1 Float, control_2 Float, end Float, t Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, start)
	callframe.Arg(frame, control_1)
	callframe.Arg(frame, control_2)
	callframe.Arg(frame, end)
	callframe.Arg(frame, t)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.bezier_interpolate(r_ret.Uintptr(), frame.Array(0), 5)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) BezierDerivative(start Float, control_1 Float, control_2 Float, end Float, t Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, start)
	callframe.Arg(frame, control_1)
	callframe.Arg(frame, control_2)
	callframe.Arg(frame, end)
	callframe.Arg(frame, t)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.bezier_derivative(r_ret.Uintptr(), frame.Array(0), 5)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) AngleDifference(from Float, to Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, from)
	callframe.Arg(frame, to)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.angle_difference(r_ret.Uintptr(), frame.Array(0), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) LerpAngle(from Float, to Float, weight Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, from)
	callframe.Arg(frame, to)
	callframe.Arg(frame, weight)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.lerp_angle(r_ret.Uintptr(), frame.Array(0), 3)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) InverseLerp(from Float, to Float, weight Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, from)
	callframe.Arg(frame, to)
	callframe.Arg(frame, weight)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.inverse_lerp(r_ret.Uintptr(), frame.Array(0), 3)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) Remap(value Float, istart Float, istop Float, ostart Float, ostop Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, value)
	callframe.Arg(frame, istart)
	callframe.Arg(frame, istop)
	callframe.Arg(frame, ostart)
	callframe.Arg(frame, ostop)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.remap(r_ret.Uintptr(), frame.Array(0), 5)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) Smoothstep(from Float, to Float, x Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, from)
	callframe.Arg(frame, to)
	callframe.Arg(frame, x)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.smoothstep(r_ret.Uintptr(), frame.Array(0), 3)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) MoveToward(from Float, to Float, delta Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, from)
	callframe.Arg(frame, to)
	callframe.Arg(frame, delta)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.move_toward(r_ret.Uintptr(), frame.Array(0), 3)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) RotateToward(from Float, to Float, delta Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, from)
	callframe.Arg(frame, to)
	callframe.Arg(frame, delta)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.rotate_toward(r_ret.Uintptr(), frame.Array(0), 3)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) DegToRad(deg Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, deg)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.deg_to_rad(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) RadToDeg(rad Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, rad)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.rad_to_deg(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) LinearToDb(lin Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, lin)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.linear_to_db(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) DbToLinear(db Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, db)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.db_to_linear(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) Wrap(value Variant, min Variant, max Variant) Variant {
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(value))
	callframe.Arg(frame, mmm.Get(min))
	callframe.Arg(frame, mmm.Get(max))
	var r_ret = callframe.Ret[[3]uintptr](frame)
	ctx.API.utility.wrap(r_ret.Uintptr(), frame.Array(0), 3)
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

func (ctx Lifetime) Wrapi(value Int, min Int, max Int) Int {
	var frame = callframe.New()
	callframe.Arg(frame, value)
	callframe.Arg(frame, min)
	callframe.Arg(frame, max)
	var r_ret = callframe.Ret[Int](frame)
	ctx.API.utility.wrapi(r_ret.Uintptr(), frame.Array(0), 3)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) Wrapf(value Float, min Float, max Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, value)
	callframe.Arg(frame, min)
	callframe.Arg(frame, max)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.wrapf(r_ret.Uintptr(), frame.Array(0), 3)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) Max(arg1 Variant, arg2 Variant, args ...Variant) Variant {
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(arg1))
	callframe.Arg(frame, mmm.Get(arg2))
	for _, arg := range args {
		callframe.Arg(frame, mmm.Get(arg))
	}
	var r_ret = callframe.Ret[[3]uintptr](frame)
	ctx.API.utility.max(r_ret.Uintptr(), frame.Array(0), 2)
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

func (ctx Lifetime) Maxi(a Int, b Int) Int {
	var frame = callframe.New()
	callframe.Arg(frame, a)
	callframe.Arg(frame, b)
	var r_ret = callframe.Ret[Int](frame)
	ctx.API.utility.maxi(r_ret.Uintptr(), frame.Array(0), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) Maxf(a Float, b Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, a)
	callframe.Arg(frame, b)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.maxf(r_ret.Uintptr(), frame.Array(0), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) Min(arg1 Variant, arg2 Variant, args ...Variant) Variant {
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(arg1))
	callframe.Arg(frame, mmm.Get(arg2))
	for _, arg := range args {
		callframe.Arg(frame, mmm.Get(arg))
	}
	var r_ret = callframe.Ret[[3]uintptr](frame)
	ctx.API.utility.min(r_ret.Uintptr(), frame.Array(0), 2)
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

func (ctx Lifetime) Mini(a Int, b Int) Int {
	var frame = callframe.New()
	callframe.Arg(frame, a)
	callframe.Arg(frame, b)
	var r_ret = callframe.Ret[Int](frame)
	ctx.API.utility.mini(r_ret.Uintptr(), frame.Array(0), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) Minf(a Float, b Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, a)
	callframe.Arg(frame, b)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.minf(r_ret.Uintptr(), frame.Array(0), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) Clamp(value Variant, min Variant, max Variant) Variant {
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(value))
	callframe.Arg(frame, mmm.Get(min))
	callframe.Arg(frame, mmm.Get(max))
	var r_ret = callframe.Ret[[3]uintptr](frame)
	ctx.API.utility.clamp(r_ret.Uintptr(), frame.Array(0), 3)
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

func (ctx Lifetime) Clampi(value Int, min Int, max Int) Int {
	var frame = callframe.New()
	callframe.Arg(frame, value)
	callframe.Arg(frame, min)
	callframe.Arg(frame, max)
	var r_ret = callframe.Ret[Int](frame)
	ctx.API.utility.clampi(r_ret.Uintptr(), frame.Array(0), 3)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) Clampf(value Float, min Float, max Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, value)
	callframe.Arg(frame, min)
	callframe.Arg(frame, max)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.clampf(r_ret.Uintptr(), frame.Array(0), 3)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) NearestPo2(value Int) Int {
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[Int](frame)
	ctx.API.utility.nearest_po2(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) Pingpong(value Float, length Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, value)
	callframe.Arg(frame, length)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.pingpong(r_ret.Uintptr(), frame.Array(0), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) Randomize() {
	var frame = callframe.New()
	var r_ret callframe.Nil
	ctx.API.utility.randomize(r_ret.Uintptr(), frame.Array(0), 0)
	frame.Free()
}

func (ctx Lifetime) Randi() Int {
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	ctx.API.utility.randi(r_ret.Uintptr(), frame.Array(0), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) Randf() Float {
	var frame = callframe.New()
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.randf(r_ret.Uintptr(), frame.Array(0), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) RandiRange(from Int, to Int) Int {
	var frame = callframe.New()
	callframe.Arg(frame, from)
	callframe.Arg(frame, to)
	var r_ret = callframe.Ret[Int](frame)
	ctx.API.utility.randi_range(r_ret.Uintptr(), frame.Array(0), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) RandfRange(from Float, to Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, from)
	callframe.Arg(frame, to)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.randf_range(r_ret.Uintptr(), frame.Array(0), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) Randfn(mean Float, deviation Float) Float {
	var frame = callframe.New()
	callframe.Arg(frame, mean)
	callframe.Arg(frame, deviation)
	var r_ret = callframe.Ret[Float](frame)
	ctx.API.utility.randfn(r_ret.Uintptr(), frame.Array(0), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) Seed(base Int) {
	var frame = callframe.New()
	callframe.Arg(frame, base)
	var r_ret callframe.Nil
	ctx.API.utility.seed(r_ret.Uintptr(), frame.Array(0), 1)
	frame.Free()
}

func (ctx Lifetime) RandFromSeed(seed Int) PackedInt64Array {
	var frame = callframe.New()
	callframe.Arg(frame, seed)
	var r_ret = callframe.Ret[[2]uintptr](frame)
	ctx.API.utility.rand_from_seed(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = mmm.New[PackedInt64Array](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

func (ctx Lifetime) Weakref(obj Variant) Variant {
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(obj))
	var r_ret = callframe.Ret[[3]uintptr](frame)
	ctx.API.utility.weakref(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

func (ctx Lifetime) Typeof(variable Variant) Int {
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(variable))
	var r_ret = callframe.Ret[Int](frame)
	ctx.API.utility.typeof(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) TypeConvert(variant Variant, atype Int) Variant {
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(variant))
	callframe.Arg(frame, atype)
	var r_ret = callframe.Ret[[3]uintptr](frame)
	ctx.API.utility.type_convert(r_ret.Uintptr(), frame.Array(0), 2)
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

func (ctx Lifetime) Str(arg1 Variant, args ...Variant) String {
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(arg1))
	for _, arg := range args {
		callframe.Arg(frame, mmm.Get(arg))
	}
	var r_ret = callframe.Ret[uintptr](frame)
	ctx.API.utility.str(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

func (ctx Lifetime) ErrorString(error Int) String {
	var frame = callframe.New()
	callframe.Arg(frame, error)
	var r_ret = callframe.Ret[uintptr](frame)
	ctx.API.utility.error_string(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

func (ctx Lifetime) TypeToString(atype Int) String {
	var frame = callframe.New()
	callframe.Arg(frame, atype)
	var r_ret = callframe.Ret[uintptr](frame)
	ctx.API.utility.type_string(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

func (ctx Lifetime) Print(arg1 Variant, args ...Variant) {
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(arg1))
	for _, arg := range args {
		callframe.Arg(frame, mmm.Get(arg))
	}
	var r_ret callframe.Nil
	ctx.API.utility.print(r_ret.Uintptr(), frame.Array(0), 1)
	frame.Free()
}

func (ctx Lifetime) PrintRich(arg1 Variant, args ...Variant) {
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(arg1))
	for _, arg := range args {
		callframe.Arg(frame, mmm.Get(arg))
	}
	var r_ret callframe.Nil
	ctx.API.utility.print_rich(r_ret.Uintptr(), frame.Array(0), 1)
	frame.Free()
}

func (ctx Lifetime) Printerr(arg1 Variant, args ...Variant) {
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(arg1))
	for _, arg := range args {
		callframe.Arg(frame, mmm.Get(arg))
	}
	var r_ret callframe.Nil
	ctx.API.utility.printerr(r_ret.Uintptr(), frame.Array(0), 1)
	frame.Free()
}

func (ctx Lifetime) Printt(arg1 Variant, args ...Variant) {
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(arg1))
	for _, arg := range args {
		callframe.Arg(frame, mmm.Get(arg))
	}
	var r_ret callframe.Nil
	ctx.API.utility.printt(r_ret.Uintptr(), frame.Array(0), 1)
	frame.Free()
}

func (ctx Lifetime) Prints(arg1 Variant, args ...Variant) {
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(arg1))
	for _, arg := range args {
		callframe.Arg(frame, mmm.Get(arg))
	}
	var r_ret callframe.Nil
	ctx.API.utility.prints(r_ret.Uintptr(), frame.Array(0), 1)
	frame.Free()
}

func (ctx Lifetime) Printraw(arg1 Variant, args ...Variant) {
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(arg1))
	for _, arg := range args {
		callframe.Arg(frame, mmm.Get(arg))
	}
	var r_ret callframe.Nil
	ctx.API.utility.printraw(r_ret.Uintptr(), frame.Array(0), 1)
	frame.Free()
}

func (ctx Lifetime) PrintVerbose(arg1 Variant, args ...Variant) {
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(arg1))
	for _, arg := range args {
		callframe.Arg(frame, mmm.Get(arg))
	}
	var r_ret callframe.Nil
	ctx.API.utility.print_verbose(r_ret.Uintptr(), frame.Array(0), 1)
	frame.Free()
}

func (ctx Lifetime) PushError(arg1 Variant, args ...Variant) {
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(arg1))
	for _, arg := range args {
		callframe.Arg(frame, mmm.Get(arg))
	}
	var r_ret callframe.Nil
	ctx.API.utility.push_error(r_ret.Uintptr(), frame.Array(0), 1)
	frame.Free()
}

func (ctx Lifetime) PushWarning(arg1 Variant, args ...Variant) {
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(arg1))
	for _, arg := range args {
		callframe.Arg(frame, mmm.Get(arg))
	}
	var r_ret callframe.Nil
	ctx.API.utility.push_warning(r_ret.Uintptr(), frame.Array(0), 1)
	frame.Free()
}

func (ctx Lifetime) VarToStr(variable Variant) String {
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(variable))
	var r_ret = callframe.Ret[uintptr](frame)
	ctx.API.utility.var_to_str(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

func (ctx Lifetime) StrToVar(s String) Variant {
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(s))
	var r_ret = callframe.Ret[[3]uintptr](frame)
	ctx.API.utility.str_to_var(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

func (ctx Lifetime) VarToBytes(variable Variant) PackedByteArray {
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(variable))
	var r_ret = callframe.Ret[[2]uintptr](frame)
	ctx.API.utility.var_to_bytes(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = mmm.New[PackedByteArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

func (ctx Lifetime) BytesToVar(bytes PackedByteArray) Variant {
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(bytes))
	var r_ret = callframe.Ret[[3]uintptr](frame)
	ctx.API.utility.bytes_to_var(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

func (ctx Lifetime) VarToBytesWithObjects(variable Variant) PackedByteArray {
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(variable))
	var r_ret = callframe.Ret[[2]uintptr](frame)
	ctx.API.utility.var_to_bytes_with_objects(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = mmm.New[PackedByteArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

func (ctx Lifetime) BytesToVarWithObjects(bytes PackedByteArray) Variant {
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(bytes))
	var r_ret = callframe.Ret[[3]uintptr](frame)
	ctx.API.utility.bytes_to_var_with_objects(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}

func (ctx Lifetime) Hash(variable Variant) Int {
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(variable))
	var r_ret = callframe.Ret[Int](frame)
	ctx.API.utility.hash(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) InstanceFromId(instance_id Int) Object {
	var frame = callframe.New()
	callframe.Arg(frame, instance_id)
	var r_ret = callframe.Ret[uintptr](frame)
	ctx.API.utility.instance_from_id(r_ret.Uintptr(), frame.Array(0), 1)
	var ret Object
	ret.SetPointer(PointerMustAssertInstanceID(ctx, r_ret.Get()))
	frame.Free()
	return ret
}

func (ctx Lifetime) IsInstanceIdValid(id Int) bool {
	var frame = callframe.New()
	callframe.Arg(frame, id)
	var r_ret = callframe.Ret[bool](frame)
	ctx.API.utility.is_instance_id_valid(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) IsInstanceValid(instance Variant) bool {
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(instance))
	var r_ret = callframe.Ret[bool](frame)
	ctx.API.utility.is_instance_valid(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) RidAllocateId() Int {
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	ctx.API.utility.rid_allocate_id(r_ret.Uintptr(), frame.Array(0), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) RidFromInt64(base Int) RID {
	var frame = callframe.New()
	callframe.Arg(frame, base)
	var r_ret = callframe.Ret[RID](frame)
	ctx.API.utility.rid_from_int64(r_ret.Uintptr(), frame.Array(0), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

func (ctx Lifetime) IsSame(a Variant, b Variant) bool {
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(a))
	callframe.Arg(frame, mmm.Get(b))
	var r_ret = callframe.Ret[bool](frame)
	ctx.API.utility.is_same(r_ret.Uintptr(), frame.Array(0), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}

type Vector2Axis int64

type Vector2iAxis int64

type Vector3Axis int64

type Vector3iAxis int64

type Vector4Axis int64

type Vector4iAxis int64

type ProjectionPlanes int64

/*
Performs a case-sensitive comparison to another string. Returns [code]-1[/code] if less than, [code]1[/code] if greater than, or [code]0[/code] if equal. "Less than" and "greater than" are determined by the [url=https://en.wikipedia.org/wiki/List_of_Unicode_characters]Unicode code points[/url] of each string, which roughly matches the alphabetical order.
With different string lengths, returns [code]1[/code] if this string is longer than the [param to] string, or [code]-1[/code] if shorter. Note that the length of empty strings is [i]always[/i] [code]0[/code].
To get a [bool] result from a string comparison, use the [code]==[/code] operator instead. See also [method nocasecmp_to], [method filecasecmp_to], and [method naturalcasecmp_to].
*/
//go:nosplit
func (self String) CasecmpTo(to String) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(to))
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.casecmp_to(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Performs a [b]case-insensitive[/b] comparison to another string. Returns [code]-1[/code] if less than, [code]1[/code] if greater than, or [code]0[/code] if equal. "Less than" or "greater than" are determined by the [url=https://en.wikipedia.org/wiki/List_of_Unicode_characters]Unicode code points[/url] of each string, which roughly matches the alphabetical order. Internally, lowercase characters are converted to uppercase for the comparison.
With different string lengths, returns [code]1[/code] if this string is longer than the [param to] string, or [code]-1[/code] if shorter. Note that the length of empty strings is [i]always[/i] [code]0[/code].
To get a [bool] result from a string comparison, use the [code]==[/code] operator instead. See also [method casecmp_to], [method filenocasecmp_to], and [method naturalnocasecmp_to].
*/
//go:nosplit
func (self String) NocasecmpTo(to String) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(to))
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.nocasecmp_to(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Performs a [b]case-sensitive[/b], [i]natural order[/i] comparison to another string. Returns [code]-1[/code] if less than, [code]1[/code] if greater than, or [code]0[/code] if equal. "Less than" or "greater than" are determined by the [url=https://en.wikipedia.org/wiki/List_of_Unicode_characters]Unicode code points[/url] of each string, which roughly matches the alphabetical order.
When used for sorting, natural order comparison orders sequences of numbers by the combined value of each digit as is often expected, instead of the single digit's value. A sorted sequence of numbered strings will be [code]["1", "2", "3", ...][/code], not [code]["1", "10", "2", "3", ...][/code].
With different string lengths, returns [code]1[/code] if this string is longer than the [param to] string, or [code]-1[/code] if shorter. Note that the length of empty strings is [i]always[/i] [code]0[/code].
To get a [bool] result from a string comparison, use the [code]==[/code] operator instead. See also [method naturalnocasecmp_to], [method filecasecmp_to], and [method nocasecmp_to].
*/
//go:nosplit
func (self String) NaturalcasecmpTo(to String) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(to))
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.naturalcasecmp_to(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Performs a [b]case-insensitive[/b], [i]natural order[/i] comparison to another string. Returns [code]-1[/code] if less than, [code]1[/code] if greater than, or [code]0[/code] if equal. "Less than" or "greater than" are determined by the [url=https://en.wikipedia.org/wiki/List_of_Unicode_characters]Unicode code points[/url] of each string, which roughly matches the alphabetical order. Internally, lowercase characters are converted to uppercase for the comparison.
When used for sorting, natural order comparison orders sequences of numbers by the combined value of each digit as is often expected, instead of the single digit's value. A sorted sequence of numbered strings will be [code]["1", "2", "3", ...][/code], not [code]["1", "10", "2", "3", ...][/code].
With different string lengths, returns [code]1[/code] if this string is longer than the [param to] string, or [code]-1[/code] if shorter. Note that the length of empty strings is [i]always[/i] [code]0[/code].
To get a [bool] result from a string comparison, use the [code]==[/code] operator instead. See also [method naturalcasecmp_to], [method filenocasecmp_to], and [method casecmp_to].
*/
//go:nosplit
func (self String) NaturalnocasecmpTo(to String) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(to))
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.naturalnocasecmp_to(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Like [method naturalcasecmp_to] but prioritizes strings that begin with periods ([code].[/code]) and underscores ([code]_[/code]) before any other character. Useful when sorting folders or file names.
To get a [bool] result from a string comparison, use the [code]==[/code] operator instead. See also [method filenocasecmp_to], [method naturalcasecmp_to], and [method casecmp_to].
*/
//go:nosplit
func (self String) FilecasecmpTo(to String) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(to))
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.filecasecmp_to(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Like [method naturalnocasecmp_to] but prioritizes strings that begin with periods ([code].[/code]) and underscores ([code]_[/code]) before any other character. Useful when sorting folders or file names.
To get a [bool] result from a string comparison, use the [code]==[/code] operator instead. See also [method filecasecmp_to], [method naturalnocasecmp_to], and [method nocasecmp_to].
*/
//go:nosplit
func (self String) FilenocasecmpTo(to String) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(to))
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.filenocasecmp_to(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns the number of characters in the string. Empty strings ([code]""[/code]) always return [code]0[/code]. See also [method is_empty].
*/
//go:nosplit
func (self String) Length() Int {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.length(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns part of the string from the position [param from] with length [param len]. If [param len] is [code]-1[/code] (as by default), returns the rest of the string starting from the given position.
*/
//go:nosplit
func (self String) Substr(ctx Lifetime, from Int, len Int) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, from)
	callframe.Arg(frame, len)
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.substr(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Splits the string using a [param delimiter] and returns the substring at index [param slice]. Returns the original string if [param delimiter] does not occur in the string. Returns an empty string if the [param slice] does not exist.
This is faster than [method split], if you only need one substring.
[b]Example:[/b]
[codeblock]
print("i/am/example/hi".get_slice("/", 2)) # Prints "example"
[/codeblock]
*/
//go:nosplit
func (self String) GetSlice(ctx Lifetime, delimiter String, slice Int) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(delimiter))
	callframe.Arg(frame, slice)
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.get_slice(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Splits the string using a Unicode character with code [param delimiter] and returns the substring at index [param slice]. Returns an empty string if the [param slice] does not exist.
This is faster than [method split], if you only need one substring.
*/
//go:nosplit
func (self String) GetSlicec(ctx Lifetime, delimiter Int, slice Int) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, delimiter)
	callframe.Arg(frame, slice)
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.get_slicec(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns the total number of slices when the string is split with the given [param delimiter] (see [method split]).
*/
//go:nosplit
func (self String) GetSliceCount(delimiter String) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(delimiter))
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.get_slice_count(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns the index of the [b]first[/b] occurrence of [param what] in this string, or [code]-1[/code] if there are none. The search's start can be specified with [param from], continuing to the end of the string.
[codeblocks]
[gdscript]
print("Team".find("I")) # Prints -1

print("Potato".find("t"))    # Prints 2
print("Potato".find("t", 3)) # Prints 4
print("Potato".find("t", 5)) # Prints -1
[/gdscript]
[csharp]
GD.Print("Team".Find("I")); // Prints -1

GD.Print("Potato".Find("t"));    // Prints 2
GD.Print("Potato".Find("t", 3)); // Prints 4
GD.Print("Potato".Find("t", 5)); // Prints -1
[/csharp]
[/codeblocks]
[b]Note:[/b] If you just want to know whether the string contains [param what], use [method contains]. In GDScript, you may also use the [code]in[/code] operator.
*/
//go:nosplit
func (self String) Find(what String, from Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(what))
	callframe.Arg(frame, from)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.find(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns the index of the [b]first[/b] [b]case-insensitive[/b] occurrence of [param what] in this string, or [code]-1[/code] if there are none. The starting search index can be specified with [param from], continuing to the end of the string.
*/
//go:nosplit
func (self String) Findn(what String, from Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(what))
	callframe.Arg(frame, from)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.findn(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns the number of occurrences of the substring [param what] between [param from] and [param to] positions. If [param to] is 0, the search continues until the end of the string.
*/
//go:nosplit
func (self String) Count(what String, from Int, to Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(what))
	callframe.Arg(frame, from)
	callframe.Arg(frame, to)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.count(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 3)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns the number of occurrences of the substring [param what] between [param from] and [param to] positions, [b]ignoring case[/b]. If [param to] is 0, the search continues until the end of the string.
*/
//go:nosplit
func (self String) Countn(what String, from Int, to Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(what))
	callframe.Arg(frame, from)
	callframe.Arg(frame, to)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.countn(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 3)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns the index of the [b]last[/b] occurrence of [param what] in this string, or [code]-1[/code] if there are none. The search's start can be specified with [param from], continuing to the beginning of the string. This method is the reverse of [method find].
*/
//go:nosplit
func (self String) Rfind(what String, from Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(what))
	callframe.Arg(frame, from)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.rfind(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns the index of the [b]last[/b] [b]case-insensitive[/b] occurrence of [param what] in this string, or [code]-1[/code] if there are none. The starting search index can be specified with [param from], continuing to the beginning of the string. This method is the reverse of [method findn].
*/
//go:nosplit
func (self String) Rfindn(what String, from Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(what))
	callframe.Arg(frame, from)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.rfindn(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Does a simple expression match (also called "glob" or "globbing"), where [code]*[/code] matches zero or more arbitrary characters and [code]?[/code] matches any single character except a period ([code].[/code]). An empty string or empty expression always evaluates to [code]false[/code].
*/
//go:nosplit
func (self String) Match(expr String) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(expr))
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.match(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Does a simple [b]case-insensitive[/b] expression match, where [code]*[/code] matches zero or more arbitrary characters and [code]?[/code] matches any single character except a period ([code].[/code]). An empty string or empty expression always evaluates to [code]false[/code].
*/
//go:nosplit
func (self String) Matchn(expr String) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(expr))
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.matchn(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns [code]true[/code] if the string begins with the given [param text]. See also [method ends_with].
*/
//go:nosplit
func (self String) BeginsWith(text String) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(text))
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.begins_with(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns [code]true[/code] if the string ends with the given [param text]. See also [method begins_with].
*/
//go:nosplit
func (self String) EndsWith(text String) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(text))
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.ends_with(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns [code]true[/code] if all characters of this string can be found in [param text] in their original order.
[codeblock]
var text = "Wow, incredible!"

print("inedible".is_subsequence_of(text)) # Prints true
print("Word!".is_subsequence_of(text))    # Prints true
print("Window".is_subsequence_of(text))   # Prints false
print("".is_subsequence_of(text))         # Prints true
[/codeblock]
*/
//go:nosplit
func (self String) IsSubsequenceOf(text String) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(text))
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.is_subsequence_of(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns [code]true[/code] if all characters of this string can be found in [param text] in their original order, [b]ignoring case[/b].
*/
//go:nosplit
func (self String) IsSubsequenceOfn(text String) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(text))
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.is_subsequence_ofn(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns an array containing the bigrams (pairs of consecutive characters) of this string.
[codeblock]
print("Get up!".bigrams()) # Prints ["Ge", "et", "t ", " u", "up", "p!"]
[/codeblock]
*/
//go:nosplit
func (self String) Bigrams(ctx Lifetime) PackedStringArray {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.bigrams(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[PackedStringArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns the similarity index ([url=https://en.wikipedia.org/wiki/S%C3%B8rensen%E2%80%93Dice_coefficient]Sorensen-Dice coefficient[/url]) of this string compared to another. A result of [code]1.0[/code] means totally similar, while [code]0.0[/code] means totally dissimilar.
[codeblock]
print("ABC123".similarity("ABC123")) # Prints 1.0
print("ABC123".similarity("XYZ456")) # Prints 0.0
print("ABC123".similarity("123ABC")) # Prints 0.8
print("ABC123".similarity("abc123")) # Prints 0.4
[/codeblock]
*/
//go:nosplit
func (self String) Similarity(text String) Float {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(text))
	var r_ret = callframe.Ret[Float](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.similarity(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Formats the string by replacing all occurrences of [param placeholder] with the elements of [param values].
[param values] can be a [Dictionary] or an [Array]. Any underscores in [param placeholder] will be replaced with the corresponding keys in advance. Array elements use their index as keys.
[codeblock]
# Prints "Waiting for Godot is a play by Samuel Beckett, and Godot Engine is named after it."
var use_array_values = "Waiting for {0} is a play by {1}, and {0} Engine is named after it."
print(use_array_values.format(["Godot", "Samuel Beckett"]))

# Prints "User 42 is Godot."
print("User {id} is {name}.".format({"id": 42, "name": "Godot"}))
[/codeblock]
Some additional handling is performed when [param values] is an [Array]. If [param placeholder] does not contain an underscore, the elements of the [param values] array will be used to replace one occurrence of the placeholder in order; If an element of [param values] is another 2-element array, it'll be interpreted as a key-value pair.
[codeblock]
# Prints "User 42 is Godot."
print("User {} is {}.".format([42, "Godot"], "{}"))
print("User {id} is {name}.".format([["id", 42], ["name", "Godot"]]))
[/codeblock]
See also the [url=$DOCS_URL/tutorials/scripting/gdscript/gdscript_format_string.html]GDScript format string[/url] tutorial.
[b]Note:[/b] The replacement of placeholders is not done all at once, instead each placeholder is replaced in the order they are passed, this means that if one of the replacement strings contains a key it will also be replaced. This can be very powerful, but can also cause unexpected results if you are not careful. If you do not need to perform replacement in the replacement strings, make sure your replacements do not contain placeholders to ensure reliable results.
[codeblock]
print("{0} {1}".format(["{1}", "x"]))                       # Prints "x x".
print("{0} {1}".format(["x", "{0}"]))                       # Prints "x {0}".
print("{foo} {bar}".format({"foo": "{bar}", "bar": "baz"})) # Prints "baz baz".
print("{foo} {bar}".format({"bar": "baz", "foo": "{bar}"})) # Prints "{bar} baz".
[/codeblock]
[b]Note:[/b] In C#, it's recommended to [url=https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/interpolated]interpolate strings with "$"[/url], instead.
*/
//go:nosplit
func (self String) Format(ctx Lifetime, values Variant, placeholder String) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(values))
	callframe.Arg(frame, mmm.Get(placeholder))
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.format(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Replaces all occurrences of [param what] inside the string with the given [param forwhat].
*/
//go:nosplit
func (self String) Replace(ctx Lifetime, what String, forwhat String) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(what))
	callframe.Arg(frame, mmm.Get(forwhat))
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.replace(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Replaces all [b]case-insensitive[/b] occurrences of [param what] inside the string with the given [param forwhat].
*/
//go:nosplit
func (self String) Replacen(ctx Lifetime, what String, forwhat String) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(what))
	callframe.Arg(frame, mmm.Get(forwhat))
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.replacen(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Repeats this string a number of times. [param count] needs to be greater than [code]0[/code]. Otherwise, returns an empty string.
*/
//go:nosplit
func (self String) Repeat(ctx Lifetime, count Int) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, count)
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.repeat(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns the copy of this string in reverse order. This operation works on unicode codepoints, rather than sequences of codepoints, and may break things like compound letters or emojis.
*/
//go:nosplit
func (self String) Reverse(ctx Lifetime) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.reverse(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Inserts [param what] at the given [param position] in the string.
*/
//go:nosplit
func (self String) Insert(ctx Lifetime, position Int, what String) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, position)
	callframe.Arg(frame, mmm.Get(what))
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.insert(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns a string with [param chars] characters erased starting from [param position]. If [param chars] goes beyond the string's length given the specified [param position], fewer characters will be erased from the returned string. Returns an empty string if either [param position] or [param chars] is negative. Returns the original string unmodified if [param chars] is [code]0[/code].
*/
//go:nosplit
func (self String) Erase(ctx Lifetime, position Int, chars Int) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, position)
	callframe.Arg(frame, chars)
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.erase(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Changes the appearance of the string: replaces underscores ([code]_[/code]) with spaces, adds spaces before uppercase letters in the middle of a word, converts all letters to lowercase, then converts the first one and each one following a space to uppercase.
[codeblocks]
[gdscript]
"move_local_x".capitalize()   # Returns "Move Local X"
"sceneFile_path".capitalize() # Returns "Scene File Path"
"2D, FPS, PNG".capitalize()   # Returns "2d, Fps, Png"
[/gdscript]
[csharp]
"move_local_x".Capitalize();   // Returns "Move Local X"
"sceneFile_path".Capitalize(); // Returns "Scene File Path"
"2D, FPS, PNG".Capitalize();   // Returns "2d, Fps, Png"
[/csharp]
[/codeblocks]
*/
//go:nosplit
func (self String) Capitalize(ctx Lifetime) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.capitalize(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns the string converted to [code]camelCase[/code].
*/
//go:nosplit
func (self String) ToCamelCase(ctx Lifetime) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.to_camel_case(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns the string converted to [code]PascalCase[/code].
*/
//go:nosplit
func (self String) ToPascalCase(ctx Lifetime) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.to_pascal_case(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns the string converted to [code]snake_case[/code].
[b]Note:[/b] Numbers followed by a [i]single[/i] letter are not separated in the conversion to keep some words (such as "2D") together.
[codeblocks]
[gdscript]
"Node2D".to_snake_case()               # Returns "node_2d"
"2nd place".to_snake_case()            # Returns "2_nd_place"
"Texture3DAssetFolder".to_snake_case() # Returns "texture_3d_asset_folder"
[/gdscript]
[csharp]
"Node2D".ToSnakeCase();               // Returns "node_2d"
"2nd place".ToSnakeCase();            // Returns "2_nd_place"
"Texture3DAssetFolder".ToSnakeCase(); // Returns "texture_3d_asset_folder"
[/csharp]
[/codeblocks]
*/
//go:nosplit
func (self String) ToSnakeCase(ctx Lifetime) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.to_snake_case(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Splits the string using a [param delimiter] and returns an array of the substrings. If [param delimiter] is an empty string, each substring will be a single character. This method is the opposite of [method join].
If [param allow_empty] is [code]false[/code], empty strings between adjacent delimiters are excluded from the array.
If [param maxsplit] is greater than [code]0[/code], the number of splits may not exceed [param maxsplit]. By default, the entire string is split.
[b]Example:[/b]
[codeblocks]
[gdscript]
var some_array = "One,Two,Three,Four".split(",", true, 2)

print(some_array.size()) # Prints 3
print(some_array[0])     # Prints "One"
print(some_array[1])     # Prints "Two"
print(some_array[2])     # Prints "Three,Four"
[/gdscript]
[csharp]
// C#'s `Split()` does not support the `maxsplit` parameter.
var someArray = "One,Two,Three".Split(",");

GD.Print(someArray[0]); // Prints "One"
GD.Print(someArray[1]); // Prints "Two"
GD.Print(someArray[2]); // Prints "Three"
[/csharp]
[/codeblocks]
[b]Note:[/b] If you only need one substring from the array, consider using [method get_slice] which is faster. If you need to split strings with more complex rules, use the [RegEx] class instead.
*/
//go:nosplit
func (self String) Split(ctx Lifetime, delimiter String, allow_empty bool, maxsplit Int) PackedStringArray {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(delimiter))
	callframe.Arg(frame, allow_empty)
	callframe.Arg(frame, maxsplit)
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.split(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 3)
	var ret = mmm.New[PackedStringArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Splits the string using a [param delimiter] and returns an array of the substrings, starting from the end of the string. The splits in the returned array appear in the same order as the original string. If [param delimiter] is an empty string, each substring will be a single character.
If [param allow_empty] is [code]false[/code], empty strings between adjacent delimiters are excluded from the array.
If [param maxsplit] is greater than [code]0[/code], the number of splits may not exceed [param maxsplit]. By default, the entire string is split, which is mostly identical to [method split].
[b]Example:[/b]
[codeblocks]
[gdscript]
var some_string = "One,Two,Three,Four"
var some_array = some_string.rsplit(",", true, 1)

print(some_array.size()) # Prints 2
print(some_array[0])     # Prints "One,Two,Three"
print(some_array[1])     # Prints "Four"
[/gdscript]
[csharp]
// In C#, there is no String.RSplit() method.
[/csharp]
[/codeblocks]
*/
//go:nosplit
func (self String) Rsplit(ctx Lifetime, delimiter String, allow_empty bool, maxsplit Int) PackedStringArray {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(delimiter))
	callframe.Arg(frame, allow_empty)
	callframe.Arg(frame, maxsplit)
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.rsplit(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 3)
	var ret = mmm.New[PackedStringArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Splits the string into floats by using a [param delimiter] and returns a [PackedFloat64Array].
If [param allow_empty] is [code]false[/code], empty or invalid [float] conversions between adjacent delimiters are excluded.
[codeblock]
var a = "1,2,4.5".split_floats(",")         # a is [1.0, 2.0, 4.5]
var c = "1| ||4.5".split_floats("|")        # c is [1.0, 0.0, 0.0, 4.5]
var b = "1| ||4.5".split_floats("|", false) # b is [1.0, 4.5]
[/codeblock]
*/
//go:nosplit
func (self String) SplitFloats(ctx Lifetime, delimiter String, allow_empty bool) PackedFloat64Array {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(delimiter))
	callframe.Arg(frame, allow_empty)
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.split_floats(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[PackedFloat64Array](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns the concatenation of [param parts]' elements, with each element separated by the string calling this method. This method is the opposite of [method split].
[b]Example:[/b]
[codeblocks]
[gdscript]
var fruits = ["Apple", "Orange", "Pear", "Kiwi"]

print(", ".join(fruits))  # Prints "Apple, Orange, Pear, Kiwi"
print("---".join(fruits)) # Prints "Apple---Orange---Pear---Kiwi"
[/gdscript]
[csharp]
var fruits = new string[] {"Apple", "Orange", "Pear", "Kiwi"};

// In C#, this method is static.
GD.Print(string.Join(", ", fruits));  // Prints "Apple, Orange, Pear, Kiwi"
GD.Print(string.Join("---", fruits)); // Prints "Apple---Orange---Pear---Kiwi"
[/csharp]
[/codeblocks]
*/
//go:nosplit
func (self String) Join(ctx Lifetime, parts PackedStringArray) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(parts))
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.join(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns the string converted to [code]UPPERCASE[/code].
*/
//go:nosplit
func (self String) ToUpper(ctx Lifetime) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.to_upper(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns the string converted to [code]lowercase[/code].
*/
//go:nosplit
func (self String) ToLower(ctx Lifetime) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.to_lower(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns the first [param length] characters from the beginning of the string. If [param length] is negative, strips the last [param length] characters from the string's end.
[codeblock]
print("Hello World!".left(3))  # Prints "Hel"
print("Hello World!".left(-4)) # Prints "Hello Wo"
[/codeblock]
*/
//go:nosplit
func (self String) Left(ctx Lifetime, length Int) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, length)
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.left(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns the last [param length] characters from the end of the string. If [param length] is negative, strips the first [param length] characters from the string's beginning.
[codeblock]
print("Hello World!".right(3))  # Prints "ld!"
print("Hello World!".right(-4)) # Prints "o World!"
[/codeblock]
*/
//go:nosplit
func (self String) Right(ctx Lifetime, length Int) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, length)
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.right(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Strips all non-printable characters from the beginning and the end of the string. These include spaces, tabulations ([code]\t[/code]), and newlines ([code]\n[/code] [code]\r[/code]).
If [param left] is [code]false[/code], ignores the string's beginning. Likewise, if [param right] is [code]false[/code], ignores the string's end.
*/
//go:nosplit
func (self String) StripEdges(ctx Lifetime, left bool, right bool) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, left)
	callframe.Arg(frame, right)
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.strip_edges(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Strips all escape characters from the string. These include all non-printable control characters of the first page of the ASCII table (values from 0 to 31), such as tabulation ([code]\t[/code]) and newline ([code]\n[/code], [code]\r[/code]) characters, but [i]not[/i] spaces.
*/
//go:nosplit
func (self String) StripEscapes(ctx Lifetime) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.strip_escapes(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Removes a set of characters defined in [param chars] from the string's beginning. See also [method rstrip].
[b]Note:[/b] [param chars] is not a prefix. Use [method trim_prefix] to remove a single prefix, rather than a set of characters.
*/
//go:nosplit
func (self String) Lstrip(ctx Lifetime, chars String) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(chars))
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.lstrip(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Removes a set of characters defined in [param chars] from the string's end. See also [method lstrip].
[b]Note:[/b] [param chars] is not a suffix. Use [method trim_suffix] to remove a single suffix, rather than a set of characters.
*/
//go:nosplit
func (self String) Rstrip(ctx Lifetime, chars String) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(chars))
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.rstrip(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
If the string is a valid file name or path, returns the file extension without the leading period ([code].[/code]). Otherwise, returns an empty string.
[codeblock]
var a = "/path/to/file.txt".get_extension() # a is "txt"
var b = "cool.txt".get_extension()          # b is "txt"
var c = "cool.font.tres".get_extension()    # c is "tres"
var d = ".pack1".get_extension()            # d is "pack1"

var e = "file.txt.".get_extension()  # e is ""
var f = "file.txt..".get_extension() # f is ""
var g = "txt".get_extension()        # g is ""
var h = "".get_extension()           # h is ""
[/codeblock]
*/
//go:nosplit
func (self String) GetExtension(ctx Lifetime) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.get_extension(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
If the string is a valid file path, returns the full file path, without the extension.
[codeblock]
var base = "/path/to/file.txt".get_basename() # base is "/path/to/file"
[/codeblock]
*/
//go:nosplit
func (self String) GetBasename(ctx Lifetime) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.get_basename(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Concatenates [param file] at the end of the string as a subpath, adding [code]/[/code] if necessary.
[b]Example:[/b] [code]"this/is".path_join("path") == "this/is/path"[/code].
*/
//go:nosplit
func (self String) PathJoin(ctx Lifetime, file String) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(file))
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.path_join(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns the character code at position [param at].
*/
//go:nosplit
func (self String) UnicodeAt(at Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, at)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.unicode_at(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Indents every line of the string with the given [param prefix]. Empty lines are not indented. See also [method dedent] to remove indentation.
For example, the string can be indented with two tabulations using [code]"\t\t"[/code], or four spaces using [code]"    "[/code].
*/
//go:nosplit
func (self String) Indent(ctx Lifetime, prefix String) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(prefix))
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.indent(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns a copy of the string with indentation (leading tabs and spaces) removed. See also [method indent] to add indentation.
*/
//go:nosplit
func (self String) Dedent(ctx Lifetime) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.dedent(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns the 32-bit hash value representing the string's contents.
[b]Note:[/b] Strings with equal hash values are [i]not[/i] guaranteed to be the same, as a result of hash collisions. On the contrary, strings with different hash values are guaranteed to be different.
*/
//go:nosplit
func (self String) Hash() Int {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.hash(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns the [url=https://en.wikipedia.org/wiki/MD5]MD5 hash[/url] of the string as another [String].
*/
//go:nosplit
func (self String) Md5Text(ctx Lifetime) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.md5_text(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns the [url=https://en.wikipedia.org/wiki/SHA-1]SHA-1[/url] hash of the string as another [String].
*/
//go:nosplit
func (self String) Sha1Text(ctx Lifetime) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.sha1_text(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns the [url=https://en.wikipedia.org/wiki/SHA-2]SHA-256[/url] hash of the string as another [String].
*/
//go:nosplit
func (self String) Sha256Text(ctx Lifetime) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.sha256_text(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns the [url=https://en.wikipedia.org/wiki/MD5]MD5 hash[/url] of the string as a [PackedByteArray].
*/
//go:nosplit
func (self String) Md5Buffer(ctx Lifetime) PackedByteArray {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.md5_buffer(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[PackedByteArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns the [url=https://en.wikipedia.org/wiki/SHA-1]SHA-1[/url] hash of the string as a [PackedByteArray].
*/
//go:nosplit
func (self String) Sha1Buffer(ctx Lifetime) PackedByteArray {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.sha1_buffer(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[PackedByteArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns the [url=https://en.wikipedia.org/wiki/SHA-2]SHA-256[/url] hash of the string as a [PackedByteArray].
*/
//go:nosplit
func (self String) Sha256Buffer(ctx Lifetime) PackedByteArray {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.sha256_buffer(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[PackedByteArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns [code]true[/code] if the string's length is [code]0[/code] ([code]""[/code]). See also [method length].
*/
//go:nosplit
func (self String) IsEmpty() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.is_empty(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns [code]true[/code] if the string contains [param what]. In GDScript, this corresponds to the [code]in[/code] operator.
[codeblocks]
[gdscript]
print("Node".contains("de")) # Prints true
print("team".contains("I"))  # Prints false
print("I" in "team")         # Prints false
[/gdscript]
[csharp]
GD.Print("Node".Contains("de")); // Prints true
GD.Print("team".Contains("I"));  // Prints false
[/csharp]
[/codeblocks]
If you need to know where [param what] is within the string, use [method find]. See also [method containsn].
*/
//go:nosplit
func (self String) Contains(what String) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(what))
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.contains(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns [code]true[/code] if the string contains [param what], [b]ignoring case[/b].
If you need to know where [param what] is within the string, use [method findn]. See also [method contains].
*/
//go:nosplit
func (self String) Containsn(what String) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(what))
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.containsn(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns [code]true[/code] if the string is a path to a file or directory, and its starting point is explicitly defined. This method is the opposite of [method is_relative_path].
This includes all paths starting with [code]"res://"[/code], [code]"user://"[/code], [code]"C:\"[/code], [code]"/"[/code], etc.
*/
//go:nosplit
func (self String) IsAbsolutePath() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.is_absolute_path(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns [code]true[/code] if the string is a path, and its starting point is dependent on context. The path could begin from the current directory, or the current [Node] (if the string is derived from a [NodePath]), and may sometimes be prefixed with [code]"./"[/code]. This method is the opposite of [method is_absolute_path].
*/
//go:nosplit
func (self String) IsRelativePath() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.is_relative_path(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
If the string is a valid file path, converts the string into a canonical path. This is the shortest possible path, without [code]"./"[/code], and all the unnecessary [code]".."[/code] and [code]"/"[/code].
[codeblock]
var simple_path = "./path/to///../file".simplify_path()
print(simple_path) # Prints "path/file"
[/codeblock]
*/
//go:nosplit
func (self String) SimplifyPath(ctx Lifetime) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.simplify_path(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
If the string is a valid file path, returns the base directory name.
[codeblock]
var dir_path = "/path/to/file.txt".get_base_dir() # dir_path is "/path/to"
[/codeblock]
*/
//go:nosplit
func (self String) GetBaseDir(ctx Lifetime) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.get_base_dir(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
If the string is a valid file path, returns the file name, including the extension.
[codeblock]
var file = "/path/to/icon.png".get_file() # file is "icon.png"
[/codeblock]
*/
//go:nosplit
func (self String) GetFile(ctx Lifetime) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.get_file(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns a copy of the string with special characters escaped using the XML standard. If [param escape_quotes] is [code]true[/code], the single quote ([code]'[/code]) and double quote ([code]"[/code]) characters are also escaped.
*/
//go:nosplit
func (self String) XmlEscape(ctx Lifetime, escape_quotes bool) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, escape_quotes)
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.xml_escape(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns a copy of the string with escaped characters replaced by their meanings according to the XML standard.
*/
//go:nosplit
func (self String) XmlUnescape(ctx Lifetime) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.xml_unescape(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Encodes the string to URL-friendly format. This method is meant to properly encode the parameters in a URL when sending an HTTP request. See also [method uri_decode].
[codeblocks]
[gdscript]
var prefix = "$DOCS_URL/?highlight="
var url = prefix + "Godot Engine:docs".uri_encode()

print(url) # Prints "$DOCS_URL/?highlight=Godot%20Engine%3%docs"
[/gdscript]
[csharp]
var prefix = "$DOCS_URL/?highlight=";
var url = prefix + "Godot Engine:docs".URIEncode();

GD.Print(url); // Prints "$DOCS_URL/?highlight=Godot%20Engine%3%docs"
[/csharp]
[/codeblocks]
*/
//go:nosplit
func (self String) UriEncode(ctx Lifetime) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.uri_encode(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Decodes the string from its URL-encoded format. This method is meant to properly decode the parameters in a URL when receiving an HTTP request. See also [method uri_encode].
[codeblocks]
[gdscript]
var url = "$DOCS_URL/?highlight=Godot%20Engine%3%docs"
print(url.uri_decode()) # Prints "$DOCS_URL/?highlight=Godot Engine:docs"
[/gdscript]
[csharp]
var url = "$DOCS_URL/?highlight=Godot%20Engine%3%docs"
GD.Print(url.URIDecode()) // Prints "$DOCS_URL/?highlight=Godot Engine:docs"
[/csharp]
[/codeblocks]
*/
//go:nosplit
func (self String) UriDecode(ctx Lifetime) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.uri_decode(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns a copy of the string with special characters escaped using the C language standard.
*/
//go:nosplit
func (self String) CEscape(ctx Lifetime) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.c_escape(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns a copy of the string with escaped characters replaced by their meanings. Supported escape sequences are [code]\'[/code], [code]\"[/code], [code]\\[/code], [code]\a[/code], [code]\b[/code], [code]\f[/code], [code]\n[/code], [code]\r[/code], [code]\t[/code], [code]\v[/code].
[b]Note:[/b] Unlike the GDScript parser, this method doesn't support the [code]\uXXXX[/code] escape sequence.
*/
//go:nosplit
func (self String) CUnescape(ctx Lifetime) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.c_unescape(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns a copy of the string with special characters escaped using the JSON standard. Because it closely matches the C standard, it is possible to use [method c_unescape] to unescape the string, if necessary.
*/
//go:nosplit
func (self String) JsonEscape(ctx Lifetime) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.json_escape(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns a copy of the string with all characters that are not allowed in [member Node.name] ([code].[/code] [code]:[/code] [code]@[/code] [code]/[/code] [code]"[/code] [code]%[/code]) replaced with underscores.
*/
//go:nosplit
func (self String) ValidateNodeName(ctx Lifetime) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.validate_node_name(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns a copy of the string with all characters that are not allowed in [method is_valid_filename] replaced with underscores.
*/
//go:nosplit
func (self String) ValidateFilename(ctx Lifetime) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.validate_filename(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns [code]true[/code] if this string is a valid identifier. A valid identifier may contain only letters, digits and underscores ([code]_[/code]), and the first character may not be a digit.
[codeblock]
print("node_2d".is_valid_identifier())    # Prints true
print("TYPE_FLOAT".is_valid_identifier()) # Prints true
print("1st_method".is_valid_identifier()) # Prints false
print("MyMethod#2".is_valid_identifier()) # Prints false
[/codeblock]
*/
//go:nosplit
func (self String) IsValidIdentifier() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.is_valid_identifier(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns [code]true[/code] if this string represents a valid integer. A valid integer only contains digits, and may be prefixed with a positive ([code]+[/code]) or negative ([code]-[/code]) sign. See also [method to_int].
[codeblock]
print("7".is_valid_int())    # Prints true
print("1.65".is_valid_int()) # Prints false
print("Hi".is_valid_int())   # Prints false
print("+3".is_valid_int())   # Prints true
print("-12".is_valid_int())  # Prints true
[/codeblock]
*/
//go:nosplit
func (self String) IsValidInt() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.is_valid_int(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns [code]true[/code] if this string represents a valid floating-point number. A valid float may contain only digits, one decimal point ([code].[/code]), and the exponent letter ([code]e[/code]). It may also be prefixed with a positive ([code]+[/code]) or negative ([code]-[/code]) sign. Any valid integer is also a valid float (see [method is_valid_int]). See also [method to_float].
[codeblock]
print("1.7".is_valid_float())   # Prints true
print("24".is_valid_float())    # Prints true
print("7e3".is_valid_float())   # Prints true
print("Hello".is_valid_float()) # Prints false
[/codeblock]
*/
//go:nosplit
func (self String) IsValidFloat() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.is_valid_float(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns [code]true[/code] if this string is a valid hexadecimal number. A valid hexadecimal number only contains digits or letters [code]A[/code] to [code]F[/code] (either uppercase or lowercase), and may be prefixed with a positive ([code]+[/code]) or negative ([code]-[/code]) sign.
If [param with_prefix] is [code]true[/code], the hexadecimal number needs to prefixed by [code]"0x"[/code] to be considered valid.
[codeblock]
print("A08E".is_valid_hex_number())    # Prints true
print("-AbCdEf".is_valid_hex_number()) # Prints true
print("2.5".is_valid_hex_number())     # Prints false

print("0xDEADC0DE".is_valid_hex_number(true)) # Prints true
[/codeblock]
*/
//go:nosplit
func (self String) IsValidHexNumber(with_prefix bool) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, with_prefix)
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.is_valid_hex_number(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns [code]true[/code] if this string is a valid color in hexadecimal HTML notation. The string must be a hexadecimal value (see [method is_valid_hex_number]) of either 3, 4, 6 or 8 digits, and may be prefixed by a hash sign ([code]#[/code]). Other HTML notations for colors, such as names or [code]hsl()[/code], are not considered valid. See also [method Color.html].
*/
//go:nosplit
func (self String) IsValidHtmlColor() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.is_valid_html_color(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns [code]true[/code] if this string represents a well-formatted IPv4 or IPv6 address. This method considers [url=https://en.wikipedia.org/wiki/Reserved_IP_addresses]reserved IP addresses[/url] such as [code]"0.0.0.0"[/code] and [code]"ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff"[/code] as valid.
*/
//go:nosplit
func (self String) IsValidIpAddress() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.is_valid_ip_address(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns [code]true[/code] if this string does not contain characters that are not allowed in file names ([code]:[/code] [code]/[/code] [code]\[/code] [code]?[/code] [code]*[/code] [code]"[/code] [code]|[/code] [code]%[/code] [code]<[/code] [code]>[/code]).
*/
//go:nosplit
func (self String) IsValidFilename() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.is_valid_filename(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Converts the string representing an integer number into an [int]. This method removes any non-number character and stops at the first decimal point ([code].[/code]). See also [method is_valid_int].
[codeblock]
var a = "123".to_int()    # a is 123
var b = "x1y2z3".to_int() # b is 123
var c = "-1.2.3".to_int() # c is -1
var d = "Hello!".to_int() # d is 0
[/codeblock]
*/
//go:nosplit
func (self String) ToInt() Int {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.to_int(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Converts the string representing a decimal number into a [float]. This method stops on the first non-number character, except the first decimal point ([code].[/code]) and the exponent letter ([code]e[/code]). See also [method is_valid_float].
[codeblock]
var a = "12.35".to_float()  # a is 12.35
var b = "1.2.3".to_float()  # b is 1.2
var c = "12xy3".to_float()  # c is 12.0
var d = "1e3".to_float()    # d is 1000.0
var e = "Hello!".to_float() # e is 0.0
[/codeblock]
*/
//go:nosplit
func (self String) ToFloat() Float {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Float](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.to_float(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Converts the string representing a hexadecimal number into an [int]. The string may be optionally prefixed with [code]"0x"[/code], and an additional [code]-[/code] prefix for negative numbers.
[codeblocks]
[gdscript]
print("0xff".hex_to_int()) # Prints 255
print("ab".hex_to_int())   # Prints 171
[/gdscript]
[csharp]
GD.Print("0xff".HexToInt()); // Prints 255
GD.Print("ab".HexToInt());   // Prints 171
[/csharp]
[/codeblocks]
*/
//go:nosplit
func (self String) HexToInt() Int {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.hex_to_int(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Converts the string representing a binary number into an [int]. The string may optionally be prefixed with [code]"0b"[/code], and an additional [code]-[/code] prefix for negative numbers.
[codeblocks]
[gdscript]
print("101".bin_to_int())   # Prints 5
print("0b101".bin_to_int()) # Prints 5
print("-0b10".bin_to_int()) # Prints -2
[/gdscript]
[csharp]
GD.Print("101".BinToInt());   // Prints 5
GD.Print("0b101".BinToInt()); // Prints 5
GD.Print("-0b10".BinToInt()); // Prints -2
[/csharp]
[/codeblocks]
*/
//go:nosplit
func (self String) BinToInt() Int {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.bin_to_int(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Formats the string to be at least [param min_length] long by adding [param character]s to the left of the string, if necessary. See also [method rpad].
*/
//go:nosplit
func (self String) Lpad(ctx Lifetime, min_length Int, character String) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, min_length)
	callframe.Arg(frame, mmm.Get(character))
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.lpad(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Formats the string to be at least [param min_length] long, by adding [param character]s to the right of the string, if necessary. See also [method lpad].
*/
//go:nosplit
func (self String) Rpad(ctx Lifetime, min_length Int, character String) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, min_length)
	callframe.Arg(frame, mmm.Get(character))
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.rpad(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Formats the string representing a number to have an exact number of [param digits] [i]after[/i] the decimal point.
*/
//go:nosplit
func (self String) PadDecimals(ctx Lifetime, digits Int) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, digits)
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.pad_decimals(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Formats the string representing a number to have an exact number of [param digits] [i]before[/i] the decimal point.
*/
//go:nosplit
func (self String) PadZeros(ctx Lifetime, digits Int) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, digits)
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.pad_zeros(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Removes the given [param prefix] from the start of the string, or returns the string unchanged.
*/
//go:nosplit
func (self String) TrimPrefix(ctx Lifetime, prefix String) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(prefix))
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.trim_prefix(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Removes the given [param suffix] from the end of the string, or returns the string unchanged.
*/
//go:nosplit
func (self String) TrimSuffix(ctx Lifetime, suffix String) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(suffix))
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.trim_suffix(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Converts the string to an [url=https://en.wikipedia.org/wiki/ASCII]ASCII[/url]/Latin-1 encoded [PackedByteArray]. This method is slightly faster than [method to_utf8_buffer], but replaces all unsupported characters with spaces. This is the inverse of [method PackedByteArray.get_string_from_ascii].
*/
//go:nosplit
func (self String) ToAsciiBuffer(ctx Lifetime) PackedByteArray {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.to_ascii_buffer(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[PackedByteArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Converts the string to a [url=https://en.wikipedia.org/wiki/UTF-8]UTF-8[/url] encoded [PackedByteArray]. This method is slightly slower than [method to_ascii_buffer], but supports all UTF-8 characters. For most cases, prefer using this method. This is the inverse of [method PackedByteArray.get_string_from_utf8].
*/
//go:nosplit
func (self String) ToUtf8Buffer(ctx Lifetime) PackedByteArray {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.to_utf8_buffer(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[PackedByteArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Converts the string to a [url=https://en.wikipedia.org/wiki/UTF-16]UTF-16[/url] encoded [PackedByteArray]. This is the inverse of [method PackedByteArray.get_string_from_utf16].
*/
//go:nosplit
func (self String) ToUtf16Buffer(ctx Lifetime) PackedByteArray {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.to_utf16_buffer(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[PackedByteArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Converts the string to a [url=https://en.wikipedia.org/wiki/UTF-32]UTF-32[/url] encoded [PackedByteArray]. This is the inverse of [method PackedByteArray.get_string_from_utf32].
*/
//go:nosplit
func (self String) ToUtf32Buffer(ctx Lifetime) PackedByteArray {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.to_utf32_buffer(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[PackedByteArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Decodes a hexadecimal string as a [PackedByteArray].
[codeblocks]
[gdscript]
var text = "hello world"
var encoded = text.to_utf8_buffer().hex_encode() # outputs "68656c6c6f20776f726c64"
print(buf.hex_decode().get_string_from_utf8())
[/gdscript]
[csharp]
var text = "hello world";
var encoded = text.ToUtf8Buffer().HexEncode(); // outputs "68656c6c6f20776f726c64"
GD.Print(buf.HexDecode().GetStringFromUtf8());
[/csharp]
[/codeblocks]
*/
//go:nosplit
func (self String) HexDecode(ctx Lifetime) PackedByteArray {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.hex_decode(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[PackedByteArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Converts the string to a [url=https://en.wikipedia.org/wiki/Wide_character]wide character[/url] ([code]wchar_t[/code], UTF-16 on Windows, UTF-32 on other platforms) encoded [PackedByteArray]. This is the inverse of [method PackedByteArray.get_string_from_wchar].
*/
//go:nosplit
func (self String) ToWcharBuffer(ctx Lifetime) PackedByteArray {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.String.to_wchar_buffer(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[PackedByteArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Converts the given [param number] to a string representation, in scientific notation.
[codeblocks]
[gdscript]
var n = -5.2e8
print(n)                        # Prints -520000000
print(String.num_scientific(n)) # Prints -5.2e+08
[/gdscript]
[csharp]
// This method is not implemented in C#.
// Use `string.ToString()` with "e" to achieve similar results.
var n = -5.2e8f;
GD.Print(n);                // Prints -520000000
GD.Print(n.ToString("e1")); // Prints -5.2e+008
[/csharp]
[/codeblocks]
[b]Note:[/b] In C#, this method is not implemented. To achieve similar results, see C#'s [url=https://learn.microsoft.com/en-us/dotnet/standard/base-types/standard-numeric-format-strings]Standard numeric format strings[/url]
*/
//go:nosplit
func (self String) NumScientific(ctx Lifetime, number Float) String {
	var frame = callframe.New()
	callframe.Arg(frame, number)
	var r_ret = callframe.Ret[uintptr](frame)
	ctx.API.builtin.String.num_scientific(0, frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Converts a [float] to a string representation of a decimal number, with the number of decimal places specified in [param decimals].
If [param decimals] is [code]-1[/code] as by default, the string representation may only have up to 14 significant digits, with digits before the decimal point having priority over digits after.
Trailing zeros are not included in the string. The last digit is rounded, not truncated.
[b]Example:[/b]
[codeblock]
String.num(3.141593)     # Returns "3.141593"
String.num(3.141593, 3)  # Returns "3.142"
String.num(3.14159300)   # Returns "3.141593"

# Here, the last digit will be rounded up,
# which reduces the total digit count, since trailing zeros are removed:
String.num(42.129999, 5) # Returns "42.13"

# If `decimals` is not specified, the maximum number of significant digits is 14:
String.num(-0.0000012345432123454321)     # Returns "-0.00000123454321"
String.num(-10000.0000012345432123454321) # Returns "-10000.0000012345"
[/codeblock]
*/
//go:nosplit
func (self String) Num(ctx Lifetime, number Float, decimals Int) String {
	var frame = callframe.New()
	callframe.Arg(frame, number)
	callframe.Arg(frame, decimals)
	var r_ret = callframe.Ret[uintptr](frame)
	ctx.API.builtin.String.num(0, frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Converts the given [param number] to a string representation, with the given [param base].
By default, [param base] is set to decimal ([code]10[/code]). Other common bases in programming include binary ([code]2[/code]), [url=https://en.wikipedia.org/wiki/Octal]octal[/url] ([code]8[/code]), hexadecimal ([code]16[/code]).
If [param capitalize_hex] is [code]true[/code], digits higher than 9 are represented in uppercase.
*/
//go:nosplit
func (self String) NumInt64(ctx Lifetime, number Int, base Int, capitalize_hex bool) String {
	var frame = callframe.New()
	callframe.Arg(frame, number)
	callframe.Arg(frame, base)
	callframe.Arg(frame, capitalize_hex)
	var r_ret = callframe.Ret[uintptr](frame)
	ctx.API.builtin.String.num_int64(0, frame.Array(0), r_ret.Uintptr(), 3)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Converts the given unsigned [int] to a string representation, with the given [param base].
By default, [param base] is set to decimal ([code]10[/code]). Other common bases in programming include binary ([code]2[/code]), [url=https://en.wikipedia.org/wiki/Octal]octal[/url] ([code]8[/code]), hexadecimal ([code]16[/code]).
If [param capitalize_hex] is [code]true[/code], digits higher than 9 are represented in uppercase.
*/
//go:nosplit
func (self String) NumUint64(ctx Lifetime, number Int, base Int, capitalize_hex bool) String {
	var frame = callframe.New()
	callframe.Arg(frame, number)
	callframe.Arg(frame, base)
	callframe.Arg(frame, capitalize_hex)
	var r_ret = callframe.Ret[uintptr](frame)
	ctx.API.builtin.String.num_uint64(0, frame.Array(0), r_ret.Uintptr(), 3)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns a single Unicode character from the decimal [param char]. You may use [url=https://unicodelookup.com/]unicodelookup.com[/url] or [url=https://www.unicode.org/charts/]unicode.org[/url] as points of reference.
[codeblock]
print(String.chr(65))     # Prints "A"
print(String.chr(129302)) # Prints "" (robot face emoji)
[/codeblock]
*/
//go:nosplit
func (self String) Chr(ctx Lifetime, char Int) String {
	var frame = callframe.New()
	callframe.Arg(frame, char)
	var r_ret = callframe.Ret[uintptr](frame)
	ctx.API.builtin.String.chr(0, frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Converts [param size] which represents a number of bytes into a human-readable form.
The result is in [url=https://en.wikipedia.org/wiki/Binary_prefix#IEC_prefixes]IEC prefix format[/url], which may end in either [code]"B"[/code], [code]"KiB"[/code], [code]"MiB"[/code], [code]"GiB"[/code], [code]"TiB"[/code], [code]"PiB"[/code], or [code]"EiB"[/code].
*/
//go:nosplit
func (self String) HumanizeSize(ctx Lifetime, size Int) String {
	var frame = callframe.New()
	callframe.Arg(frame, size)
	var r_ret = callframe.Ret[uintptr](frame)
	ctx.API.builtin.String.humanize_size(0, frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Performs a case-sensitive comparison to another string. Returns [code]-1[/code] if less than, [code]1[/code] if greater than, or [code]0[/code] if equal. "Less than" and "greater than" are determined by the [url=https://en.wikipedia.org/wiki/List_of_Unicode_characters]Unicode code points[/url] of each string, which roughly matches the alphabetical order.
With different string lengths, returns [code]1[/code] if this string is longer than the [param to] string, or [code]-1[/code] if shorter. Note that the length of empty strings is [i]always[/i] [code]0[/code].
To get a [bool] result from a string comparison, use the [code]==[/code] operator instead. See also [method nocasecmp_to], [method filecasecmp_to], and [method naturalcasecmp_to].
*/
//go:nosplit
func (self StringName) CasecmpTo(to String) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(to))
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.casecmp_to(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Performs a [b]case-insensitive[/b] comparison to another string. Returns [code]-1[/code] if less than, [code]1[/code] if greater than, or [code]0[/code] if equal. "Less than" or "greater than" are determined by the [url=https://en.wikipedia.org/wiki/List_of_Unicode_characters]Unicode code points[/url] of each string, which roughly matches the alphabetical order. Internally, lowercase characters are converted to uppercase for the comparison.
With different string lengths, returns [code]1[/code] if this string is longer than the [param to] string, or [code]-1[/code] if shorter. Note that the length of empty strings is [i]always[/i] [code]0[/code].
To get a [bool] result from a string comparison, use the [code]==[/code] operator instead. See also [method casecmp_to], [method filenocasecmp_to], and [method naturalnocasecmp_to].
*/
//go:nosplit
func (self StringName) NocasecmpTo(to String) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(to))
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.nocasecmp_to(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Performs a [b]case-sensitive[/b], [i]natural order[/i] comparison to another string. Returns [code]-1[/code] if less than, [code]1[/code] if greater than, or [code]0[/code] if equal. "Less than" or "greater than" are determined by the [url=https://en.wikipedia.org/wiki/List_of_Unicode_characters]Unicode code points[/url] of each string, which roughly matches the alphabetical order.
When used for sorting, natural order comparison orders sequences of numbers by the combined value of each digit as is often expected, instead of the single digit's value. A sorted sequence of numbered strings will be [code]["1", "2", "3", ...][/code], not [code]["1", "10", "2", "3", ...][/code].
With different string lengths, returns [code]1[/code] if this string is longer than the [param to] string, or [code]-1[/code] if shorter. Note that the length of empty strings is [i]always[/i] [code]0[/code].
To get a [bool] result from a string comparison, use the [code]==[/code] operator instead. See also [method naturalnocasecmp_to], [method filecasecmp_to], and [method nocasecmp_to].
*/
//go:nosplit
func (self StringName) NaturalcasecmpTo(to String) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(to))
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.naturalcasecmp_to(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Performs a [b]case-insensitive[/b], [i]natural order[/i] comparison to another string. Returns [code]-1[/code] if less than, [code]1[/code] if greater than, or [code]0[/code] if equal. "Less than" or "greater than" are determined by the [url=https://en.wikipedia.org/wiki/List_of_Unicode_characters]Unicode code points[/url] of each string, which roughly matches the alphabetical order. Internally, lowercase characters are converted to uppercase for the comparison.
When used for sorting, natural order comparison orders sequences of numbers by the combined value of each digit as is often expected, instead of the single digit's value. A sorted sequence of numbered strings will be [code]["1", "2", "3", ...][/code], not [code]["1", "10", "2", "3", ...][/code].
With different string lengths, returns [code]1[/code] if this string is longer than the [param to] string, or [code]-1[/code] if shorter. Note that the length of empty strings is [i]always[/i] [code]0[/code].
To get a [bool] result from a string comparison, use the [code]==[/code] operator instead. See also [method naturalcasecmp_to], [method filenocasecmp_to], and [method casecmp_to].
*/
//go:nosplit
func (self StringName) NaturalnocasecmpTo(to String) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(to))
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.naturalnocasecmp_to(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Like [method naturalcasecmp_to] but prioritizes strings that begin with periods ([code].[/code]) and underscores ([code]_[/code]) before any other character. Useful when sorting folders or file names.
To get a [bool] result from a string comparison, use the [code]==[/code] operator instead. See also [method filenocasecmp_to], [method naturalcasecmp_to], and [method casecmp_to].
*/
//go:nosplit
func (self StringName) FilecasecmpTo(to String) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(to))
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.filecasecmp_to(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Like [method naturalnocasecmp_to] but prioritizes strings that begin with periods ([code].[/code]) and underscores ([code]_[/code]) before any other character. Useful when sorting folders or file names.
To get a [bool] result from a string comparison, use the [code]==[/code] operator instead. See also [method filecasecmp_to], [method naturalnocasecmp_to], and [method nocasecmp_to].
*/
//go:nosplit
func (self StringName) FilenocasecmpTo(to String) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(to))
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.filenocasecmp_to(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns the number of characters in the string. Empty strings ([code]""[/code]) always return [code]0[/code]. See also [method is_empty].
*/
//go:nosplit
func (self StringName) Length() Int {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.length(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns part of the string from the position [param from] with length [param len]. If [param len] is [code]-1[/code] (as by default), returns the rest of the string starting from the given position.
*/
//go:nosplit
func (self StringName) Substr(ctx Lifetime, from Int, len Int) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, from)
	callframe.Arg(frame, len)
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.substr(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Splits the string using a [param delimiter] and returns the substring at index [param slice]. Returns an empty string if the [param slice] does not exist.
This is faster than [method split], if you only need one substring.
[b]Example:[/b]
[codeblock]
print("i/am/example/hi".get_slice("/", 2)) # Prints "example"
[/codeblock]
*/
//go:nosplit
func (self StringName) GetSlice(ctx Lifetime, delimiter String, slice Int) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(delimiter))
	callframe.Arg(frame, slice)
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.get_slice(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Splits the string using a Unicode character with code [param delimiter] and returns the substring at index [param slice]. Returns an empty string if the [param slice] does not exist.
This is faster than [method split], if you only need one substring.
*/
//go:nosplit
func (self StringName) GetSlicec(ctx Lifetime, delimiter Int, slice Int) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, delimiter)
	callframe.Arg(frame, slice)
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.get_slicec(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns the total number of slices when the string is split with the given [param delimiter] (see [method split]).
*/
//go:nosplit
func (self StringName) GetSliceCount(delimiter String) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(delimiter))
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.get_slice_count(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns the index of the [b]first[/b] occurrence of [param what] in this string, or [code]-1[/code] if there are none. The search's start can be specified with [param from], continuing to the end of the string.
[codeblocks]
[gdscript]
print("Team".find("I")) # Prints -1

print("Potato".find("t"))    # Prints 2
print("Potato".find("t", 3)) # Prints 4
print("Potato".find("t", 5)) # Prints -1
[/gdscript]
[csharp]
GD.Print("Team".Find("I")); // Prints -1

GD.Print("Potato".Find("t"));    // Prints 2
GD.Print("Potato".Find("t", 3)); // Prints 4
GD.Print("Potato".Find("t", 5)); // Prints -1
[/csharp]
[/codeblocks]
[b]Note:[/b] If you just want to know whether the string contains [param what], use [method contains]. In GDScript, you may also use the [code]in[/code] operator.
*/
//go:nosplit
func (self StringName) Find(what String, from Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(what))
	callframe.Arg(frame, from)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.find(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns the index of the [b]first[/b] [b]case-insensitive[/b] occurrence of [param what] in this string, or [code]-1[/code] if there are none. The starting search index can be specified with [param from], continuing to the end of the string.
*/
//go:nosplit
func (self StringName) Findn(what String, from Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(what))
	callframe.Arg(frame, from)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.findn(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns the number of occurrences of the substring [param what] between [param from] and [param to] positions. If [param to] is 0, the search continues until the end of the string.
*/
//go:nosplit
func (self StringName) Count(what String, from Int, to Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(what))
	callframe.Arg(frame, from)
	callframe.Arg(frame, to)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.count(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 3)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns the number of occurrences of the substring [param what] between [param from] and [param to] positions, [b]ignoring case[/b]. If [param to] is 0, the search continues until the end of the string.
*/
//go:nosplit
func (self StringName) Countn(what String, from Int, to Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(what))
	callframe.Arg(frame, from)
	callframe.Arg(frame, to)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.countn(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 3)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns the index of the [b]last[/b] occurrence of [param what] in this string, or [code]-1[/code] if there are none. The search's start can be specified with [param from], continuing to the beginning of the string. This method is the reverse of [method find].
*/
//go:nosplit
func (self StringName) Rfind(what String, from Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(what))
	callframe.Arg(frame, from)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.rfind(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns the index of the [b]last[/b] [b]case-insensitive[/b] occurrence of [param what] in this string, or [code]-1[/code] if there are none. The starting search index can be specified with [param from], continuing to the beginning of the string. This method is the reverse of [method findn].
*/
//go:nosplit
func (self StringName) Rfindn(what String, from Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(what))
	callframe.Arg(frame, from)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.rfindn(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Does a simple expression match (also called "glob" or "globbing"), where [code]*[/code] matches zero or more arbitrary characters and [code]?[/code] matches any single character except a period ([code].[/code]). An empty string or empty expression always evaluates to [code]false[/code].
*/
//go:nosplit
func (self StringName) Match(expr String) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(expr))
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.match(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Does a simple [b]case-insensitive[/b] expression match, where [code]*[/code] matches zero or more arbitrary characters and [code]?[/code] matches any single character except a period ([code].[/code]). An empty string or empty expression always evaluates to [code]false[/code].
*/
//go:nosplit
func (self StringName) Matchn(expr String) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(expr))
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.matchn(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns [code]true[/code] if the string begins with the given [param text]. See also [method ends_with].
*/
//go:nosplit
func (self StringName) BeginsWith(text String) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(text))
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.begins_with(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns [code]true[/code] if the string ends with the given [param text]. See also [method begins_with].
*/
//go:nosplit
func (self StringName) EndsWith(text String) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(text))
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.ends_with(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns [code]true[/code] if all characters of this string can be found in [param text] in their original order.
[codeblock]
var text = "Wow, incredible!"

print("inedible".is_subsequence_of(text)) # Prints true
print("Word!".is_subsequence_of(text))    # Prints true
print("Window".is_subsequence_of(text))   # Prints false
print("".is_subsequence_of(text))         # Prints true
[/codeblock]
*/
//go:nosplit
func (self StringName) IsSubsequenceOf(text String) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(text))
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.is_subsequence_of(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns [code]true[/code] if all characters of this string can be found in [param text] in their original order, [b]ignoring case[/b].
*/
//go:nosplit
func (self StringName) IsSubsequenceOfn(text String) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(text))
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.is_subsequence_ofn(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns an array containing the bigrams (pairs of consecutive characters) of this string.
[codeblock]
print("Get up!".bigrams()) # Prints ["Ge", "et", "t ", " u", "up", "p!"]
[/codeblock]
*/
//go:nosplit
func (self StringName) Bigrams(ctx Lifetime) PackedStringArray {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.bigrams(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[PackedStringArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns the similarity index ([url=https://en.wikipedia.org/wiki/S%C3%B8rensen%E2%80%93Dice_coefficient]Sorensen-Dice coefficient[/url]) of this string compared to another. A result of [code]1.0[/code] means totally similar, while [code]0.0[/code] means totally dissimilar.
[codeblock]
print("ABC123".similarity("ABC123")) # Prints 1.0
print("ABC123".similarity("XYZ456")) # Prints 0.0
print("ABC123".similarity("123ABC")) # Prints 0.8
print("ABC123".similarity("abc123")) # Prints 0.4
[/codeblock]
*/
//go:nosplit
func (self StringName) Similarity(text String) Float {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(text))
	var r_ret = callframe.Ret[Float](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.similarity(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Formats the string by replacing all occurrences of [param placeholder] with the elements of [param values].
[param values] can be a [Dictionary] or an [Array]. Any underscores in [param placeholder] will be replaced with the corresponding keys in advance. Array elements use their index as keys.
[codeblock]
# Prints "Waiting for Godot is a play by Samuel Beckett, and Godot Engine is named after it."
var use_array_values = "Waiting for {0} is a play by {1}, and {0} Engine is named after it."
print(use_array_values.format(["Godot", "Samuel Beckett"]))

# Prints "User 42 is Godot."
print("User {id} is {name}.".format({"id": 42, "name": "Godot"}))
[/codeblock]
Some additional handling is performed when [param values] is an [Array]. If [param placeholder] does not contain an underscore, the elements of the [param values] array will be used to replace one occurrence of the placeholder in order; If an element of [param values] is another 2-element array, it'll be interpreted as a key-value pair.
[codeblock]
# Prints "User 42 is Godot."
print("User {} is {}.".format([42, "Godot"], "{}"))
print("User {id} is {name}.".format([["id", 42], ["name", "Godot"]]))
[/codeblock]
See also the [url=$DOCS_URL/tutorials/scripting/gdscript/gdscript_format_string.html]GDScript format string[/url] tutorial.
[b]Note:[/b] In C#, it's recommended to [url=https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/interpolated]interpolate strings with "$"[/url], instead.
*/
//go:nosplit
func (self StringName) Format(ctx Lifetime, values Variant, placeholder String) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(values))
	callframe.Arg(frame, mmm.Get(placeholder))
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.format(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Replaces all occurrences of [param what] inside the string with the given [param forwhat].
*/
//go:nosplit
func (self StringName) Replace(ctx Lifetime, what String, forwhat String) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(what))
	callframe.Arg(frame, mmm.Get(forwhat))
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.replace(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Replaces all [b]case-insensitive[/b] occurrences of [param what] inside the string with the given [param forwhat].
*/
//go:nosplit
func (self StringName) Replacen(ctx Lifetime, what String, forwhat String) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(what))
	callframe.Arg(frame, mmm.Get(forwhat))
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.replacen(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Repeats this string a number of times. [param count] needs to be greater than [code]0[/code]. Otherwise, returns an empty string.
*/
//go:nosplit
func (self StringName) Repeat(ctx Lifetime, count Int) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, count)
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.repeat(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns the copy of this string in reverse order. This operation works on unicode codepoints, rather than sequences of codepoints, and may break things like compound letters or emojis.
*/
//go:nosplit
func (self StringName) Reverse(ctx Lifetime) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.reverse(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Inserts [param what] at the given [param position] in the string.
*/
//go:nosplit
func (self StringName) Insert(ctx Lifetime, position Int, what String) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, position)
	callframe.Arg(frame, mmm.Get(what))
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.insert(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns a string with [param chars] characters erased starting from [param position]. If [param chars] goes beyond the string's length given the specified [param position], fewer characters will be erased from the returned string. Returns an empty string if either [param position] or [param chars] is negative. Returns the original string unmodified if [param chars] is [code]0[/code].
*/
//go:nosplit
func (self StringName) Erase(ctx Lifetime, position Int, chars Int) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, position)
	callframe.Arg(frame, chars)
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.erase(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Changes the appearance of the string: replaces underscores ([code]_[/code]) with spaces, adds spaces before uppercase letters in the middle of a word, converts all letters to lowercase, then converts the first one and each one following a space to uppercase.
[codeblocks]
[gdscript]
"move_local_x".capitalize()   # Returns "Move Local X"
"sceneFile_path".capitalize() # Returns "Scene File Path"
"2D, FPS, PNG".capitalize()   # Returns "2d, Fps, Png"
[/gdscript]
[csharp]
"move_local_x".Capitalize();   // Returns "Move Local X"
"sceneFile_path".Capitalize(); // Returns "Scene File Path"
"2D, FPS, PNG".Capitalize();   // Returns "2d, Fps, Png"
[/csharp]
[/codeblocks]
*/
//go:nosplit
func (self StringName) Capitalize(ctx Lifetime) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.capitalize(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns the string converted to [code]camelCase[/code].
*/
//go:nosplit
func (self StringName) ToCamelCase(ctx Lifetime) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.to_camel_case(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns the string converted to [code]PascalCase[/code].
*/
//go:nosplit
func (self StringName) ToPascalCase(ctx Lifetime) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.to_pascal_case(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns the string converted to [code]snake_case[/code].
[b]Note:[/b] Numbers followed by a [i]single[/i] letter are not separated in the conversion to keep some words (such as "2D") together.
[codeblocks]
[gdscript]
"Node2D".to_snake_case()               # Returns "node_2d"
"2nd place".to_snake_case()            # Returns "2_nd_place"
"Texture3DAssetFolder".to_snake_case() # Returns "texture_3d_asset_folder"
[/gdscript]
[csharp]
"Node2D".ToSnakeCase();               // Returns "node_2d"
"2nd place".ToSnakeCase();            // Returns "2_nd_place"
"Texture3DAssetFolder".ToSnakeCase(); // Returns "texture_3d_asset_folder"
[/csharp]
[/codeblocks]
*/
//go:nosplit
func (self StringName) ToSnakeCase(ctx Lifetime) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.to_snake_case(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Splits the string using a [param delimiter] and returns an array of the substrings. If [param delimiter] is an empty string, each substring will be a single character. This method is the opposite of [method join].
If [param allow_empty] is [code]false[/code], empty strings between adjacent delimiters are excluded from the array.
If [param maxsplit] is greater than [code]0[/code], the number of splits may not exceed [param maxsplit]. By default, the entire string is split.
[b]Example:[/b]
[codeblocks]
[gdscript]
var some_array = "One,Two,Three,Four".split(",", true, 2)

print(some_array.size()) # Prints 3
print(some_array[0])     # Prints "One"
print(some_array[1])     # Prints "Two"
print(some_array[2])     # Prints "Three,Four"
[/gdscript]
[csharp]
// C#'s `Split()` does not support the `maxsplit` parameter.
var someArray = "One,Two,Three".Split(",");

GD.Print(someArray[0]); // Prints "One"
GD.Print(someArray[1]); // Prints "Two"
GD.Print(someArray[2]); // Prints "Three"
[/csharp]
[/codeblocks]
[b]Note:[/b] If you only need one substring from the array, consider using [method get_slice] which is faster. If you need to split strings with more complex rules, use the [RegEx] class instead.
*/
//go:nosplit
func (self StringName) Split(ctx Lifetime, delimiter String, allow_empty bool, maxsplit Int) PackedStringArray {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(delimiter))
	callframe.Arg(frame, allow_empty)
	callframe.Arg(frame, maxsplit)
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.split(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 3)
	var ret = mmm.New[PackedStringArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Splits the string using a [param delimiter] and returns an array of the substrings, starting from the end of the string. The splits in the returned array appear in the same order as the original string. If [param delimiter] is an empty string, each substring will be a single character.
If [param allow_empty] is [code]false[/code], empty strings between adjacent delimiters are excluded from the array.
If [param maxsplit] is greater than [code]0[/code], the number of splits may not exceed [param maxsplit]. By default, the entire string is split, which is mostly identical to [method split].
[b]Example:[/b]
[codeblocks]
[gdscript]
var some_string = "One,Two,Three,Four"
var some_array = some_string.rsplit(",", true, 1)

print(some_array.size()) # Prints 2
print(some_array[0])     # Prints "One,Two,Three"
print(some_array[1])     # Prints "Four"
[/gdscript]
[csharp]
// In C#, there is no String.RSplit() method.
[/csharp]
[/codeblocks]
*/
//go:nosplit
func (self StringName) Rsplit(ctx Lifetime, delimiter String, allow_empty bool, maxsplit Int) PackedStringArray {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(delimiter))
	callframe.Arg(frame, allow_empty)
	callframe.Arg(frame, maxsplit)
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.rsplit(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 3)
	var ret = mmm.New[PackedStringArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Splits the string into floats by using a [param delimiter] and returns a [PackedFloat64Array].
If [param allow_empty] is [code]false[/code], empty or invalid [float] conversions between adjacent delimiters are excluded.
[codeblock]
var a = "1,2,4.5".split_floats(",")         # a is [1.0, 2.0, 4.5]
var c = "1| ||4.5".split_floats("|")        # c is [1.0, 0.0, 0.0, 4.5]
var b = "1| ||4.5".split_floats("|", false) # b is [1.0, 4.5]
[/codeblock]
*/
//go:nosplit
func (self StringName) SplitFloats(ctx Lifetime, delimiter String, allow_empty bool) PackedFloat64Array {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(delimiter))
	callframe.Arg(frame, allow_empty)
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.split_floats(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[PackedFloat64Array](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns the concatenation of [param parts]' elements, with each element separated by the string calling this method. This method is the opposite of [method split].
[b]Example:[/b]
[codeblocks]
[gdscript]
var fruits = ["Apple", "Orange", "Pear", "Kiwi"]

print(", ".join(fruits))  # Prints "Apple, Orange, Pear, Kiwi"
print("---".join(fruits)) # Prints "Apple---Orange---Pear---Kiwi"
[/gdscript]
[csharp]
var fruits = new string[] {"Apple", "Orange", "Pear", "Kiwi"};

// In C#, this method is static.
GD.Print(string.Join(", ", fruits));  // Prints "Apple, Orange, Pear, Kiwi"
GD.Print(string.Join("---", fruits)); // Prints "Apple---Orange---Pear---Kiwi"
[/csharp]
[/codeblocks]
*/
//go:nosplit
func (self StringName) Join(ctx Lifetime, parts PackedStringArray) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(parts))
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.join(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns the string converted to [code]UPPERCASE[/code].
*/
//go:nosplit
func (self StringName) ToUpper(ctx Lifetime) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.to_upper(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns the string converted to [code]lowercase[/code].
*/
//go:nosplit
func (self StringName) ToLower(ctx Lifetime) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.to_lower(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns the first [param length] characters from the beginning of the string. If [param length] is negative, strips the last [param length] characters from the string's end.
[codeblock]
print("Hello World!".left(3))  # Prints "Hel"
print("Hello World!".left(-4)) # Prints "Hello Wo"
[/codeblock]
*/
//go:nosplit
func (self StringName) Left(ctx Lifetime, length Int) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, length)
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.left(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns the last [param length] characters from the end of the string. If [param length] is negative, strips the first [param length] characters from the string's beginning.
[codeblock]
print("Hello World!".right(3))  # Prints "ld!"
print("Hello World!".right(-4)) # Prints "o World!"
[/codeblock]
*/
//go:nosplit
func (self StringName) Right(ctx Lifetime, length Int) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, length)
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.right(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Strips all non-printable characters from the beginning and the end of the string. These include spaces, tabulations ([code]\t[/code]), and newlines ([code]\n[/code] [code]\r[/code]).
If [param left] is [code]false[/code], ignores the string's beginning. Likewise, if [param right] is [code]false[/code], ignores the string's end.
*/
//go:nosplit
func (self StringName) StripEdges(ctx Lifetime, left bool, right bool) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, left)
	callframe.Arg(frame, right)
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.strip_edges(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Strips all escape characters from the string. These include all non-printable control characters of the first page of the ASCII table (values from 0 to 31), such as tabulation ([code]\t[/code]) and newline ([code]\n[/code], [code]\r[/code]) characters, but [i]not[/i] spaces.
*/
//go:nosplit
func (self StringName) StripEscapes(ctx Lifetime) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.strip_escapes(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Removes a set of characters defined in [param chars] from the string's beginning. See also [method rstrip].
[b]Note:[/b] [param chars] is not a prefix. Use [method trim_prefix] to remove a single prefix, rather than a set of characters.
*/
//go:nosplit
func (self StringName) Lstrip(ctx Lifetime, chars String) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(chars))
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.lstrip(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Removes a set of characters defined in [param chars] from the string's end. See also [method lstrip].
[b]Note:[/b] [param chars] is not a suffix. Use [method trim_suffix] to remove a single suffix, rather than a set of characters.
*/
//go:nosplit
func (self StringName) Rstrip(ctx Lifetime, chars String) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(chars))
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.rstrip(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
If the string is a valid file name or path, returns the file extension without the leading period ([code].[/code]). Otherwise, returns an empty string.
[codeblock]
var a = "/path/to/file.txt".get_extension() # a is "txt"
var b = "cool.txt".get_extension()          # b is "txt"
var c = "cool.font.tres".get_extension()    # c is "tres"
var d = ".pack1".get_extension()            # d is "pack1"

var e = "file.txt.".get_extension()  # e is ""
var f = "file.txt..".get_extension() # f is ""
var g = "txt".get_extension()        # g is ""
var h = "".get_extension()           # h is ""
[/codeblock]
*/
//go:nosplit
func (self StringName) GetExtension(ctx Lifetime) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.get_extension(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
If the string is a valid file path, returns the full file path, without the extension.
[codeblock]
var base = "/path/to/file.txt".get_basename() # base is "/path/to/file"
[/codeblock]
*/
//go:nosplit
func (self StringName) GetBasename(ctx Lifetime) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.get_basename(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Concatenates [param file] at the end of the string as a subpath, adding [code]/[/code] if necessary.
[b]Example:[/b] [code]"this/is".path_join("path") == "this/is/path"[/code].
*/
//go:nosplit
func (self StringName) PathJoin(ctx Lifetime, file String) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(file))
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.path_join(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns the character code at position [param at].
*/
//go:nosplit
func (self StringName) UnicodeAt(at Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, at)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.unicode_at(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Indents every line of the string with the given [param prefix]. Empty lines are not indented. See also [method dedent] to remove indentation.
For example, the string can be indented with two tabulations using [code]"\t\t"[/code], or four spaces using [code]"    "[/code].
*/
//go:nosplit
func (self StringName) Indent(ctx Lifetime, prefix String) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(prefix))
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.indent(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns a copy of the string with indentation (leading tabs and spaces) removed. See also [method indent] to add indentation.
*/
//go:nosplit
func (self StringName) Dedent(ctx Lifetime) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.dedent(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns the [url=https://en.wikipedia.org/wiki/MD5]MD5 hash[/url] of the string as another [String].
*/
//go:nosplit
func (self StringName) Md5Text(ctx Lifetime) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.md5_text(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns the [url=https://en.wikipedia.org/wiki/SHA-1]SHA-1[/url] hash of the string as another [String].
*/
//go:nosplit
func (self StringName) Sha1Text(ctx Lifetime) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.sha1_text(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns the [url=https://en.wikipedia.org/wiki/SHA-2]SHA-256[/url] hash of the string as another [String].
*/
//go:nosplit
func (self StringName) Sha256Text(ctx Lifetime) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.sha256_text(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns the [url=https://en.wikipedia.org/wiki/MD5]MD5 hash[/url] of the string as a [PackedByteArray].
*/
//go:nosplit
func (self StringName) Md5Buffer(ctx Lifetime) PackedByteArray {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.md5_buffer(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[PackedByteArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns the [url=https://en.wikipedia.org/wiki/SHA-1]SHA-1[/url] hash of the string as a [PackedByteArray].
*/
//go:nosplit
func (self StringName) Sha1Buffer(ctx Lifetime) PackedByteArray {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.sha1_buffer(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[PackedByteArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns the [url=https://en.wikipedia.org/wiki/SHA-2]SHA-256[/url] hash of the string as a [PackedByteArray].
*/
//go:nosplit
func (self StringName) Sha256Buffer(ctx Lifetime) PackedByteArray {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.sha256_buffer(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[PackedByteArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns [code]true[/code] if the string's length is [code]0[/code] ([code]""[/code]). See also [method length].
*/
//go:nosplit
func (self StringName) IsEmpty() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.is_empty(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns [code]true[/code] if the string contains [param what]. In GDScript, this corresponds to the [code]in[/code] operator.
[codeblocks]
[gdscript]
print("Node".contains("de")) # Prints true
print("team".contains("I"))  # Prints false
print("I" in "team")         # Prints false
[/gdscript]
[csharp]
GD.Print("Node".Contains("de")); // Prints true
GD.Print("team".Contains("I"));  // Prints false
[/csharp]
[/codeblocks]
If you need to know where [param what] is within the string, use [method find]. See also [method containsn].
*/
//go:nosplit
func (self StringName) Contains(what String) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(what))
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.contains(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns [code]true[/code] if the string contains [param what], [b]ignoring case[/b].
If you need to know where [param what] is within the string, use [method findn]. See also [method contains].
*/
//go:nosplit
func (self StringName) Containsn(what String) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(what))
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.containsn(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns [code]true[/code] if the string is a path to a file or directory, and its starting point is explicitly defined. This method is the opposite of [method is_relative_path].
This includes all paths starting with [code]"res://"[/code], [code]"user://"[/code], [code]"C:\"[/code], [code]"/"[/code], etc.
*/
//go:nosplit
func (self StringName) IsAbsolutePath() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.is_absolute_path(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns [code]true[/code] if the string is a path, and its starting point is dependent on context. The path could begin from the current directory, or the current [Node] (if the string is derived from a [NodePath]), and may sometimes be prefixed with [code]"./"[/code]. This method is the opposite of [method is_absolute_path].
*/
//go:nosplit
func (self StringName) IsRelativePath() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.is_relative_path(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
If the string is a valid file path, converts the string into a canonical path. This is the shortest possible path, without [code]"./"[/code], and all the unnecessary [code]".."[/code] and [code]"/"[/code].
[codeblock]
var simple_path = "./path/to///../file".simplify_path()
print(simple_path) # Prints "path/file"
[/codeblock]
*/
//go:nosplit
func (self StringName) SimplifyPath(ctx Lifetime) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.simplify_path(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
If the string is a valid file path, returns the base directory name.
[codeblock]
var dir_path = "/path/to/file.txt".get_base_dir() # dir_path is "/path/to"
[/codeblock]
*/
//go:nosplit
func (self StringName) GetBaseDir(ctx Lifetime) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.get_base_dir(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
If the string is a valid file path, returns the file name, including the extension.
[codeblock]
var file = "/path/to/icon.png".get_file() # file is "icon.png"
[/codeblock]
*/
//go:nosplit
func (self StringName) GetFile(ctx Lifetime) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.get_file(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns a copy of the string with special characters escaped using the XML standard. If [param escape_quotes] is [code]true[/code], the single quote ([code]'[/code]) and double quote ([code]"[/code]) characters are also escaped.
*/
//go:nosplit
func (self StringName) XmlEscape(ctx Lifetime, escape_quotes bool) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, escape_quotes)
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.xml_escape(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns a copy of the string with escaped characters replaced by their meanings according to the XML standard.
*/
//go:nosplit
func (self StringName) XmlUnescape(ctx Lifetime) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.xml_unescape(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Encodes the string to URL-friendly format. This method is meant to properly encode the parameters in a URL when sending an HTTP request.
[codeblocks]
[gdscript]
var prefix = "$DOCS_URL/?highlight="
var url = prefix + "Godot Engine:docs".uri_encode()

print(url) # Prints "$DOCS_URL/?highlight=Godot%20Engine%3%docs"
[/gdscript]
[csharp]
var prefix = "$DOCS_URL/?highlight=";
var url = prefix + "Godot Engine:docs".URIEncode();

GD.Print(url); // Prints "$DOCS_URL/?highlight=Godot%20Engine%3%docs"
[/csharp]
[/codeblocks]
*/
//go:nosplit
func (self StringName) UriEncode(ctx Lifetime) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.uri_encode(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Decodes the string from its URL-encoded format. This method is meant to properly decode the parameters in a URL when receiving an HTTP request.
[codeblocks]
[gdscript]
var url = "$DOCS_URL/?highlight=Godot%20Engine%3%docs"
print(url.uri_decode()) # Prints "$DOCS_URL/?highlight=Godot Engine:docs"
[/gdscript]
[csharp]
var url = "$DOCS_URL/?highlight=Godot%20Engine%3%docs"
GD.Print(url.URIDecode()) // Prints "$DOCS_URL/?highlight=Godot Engine:docs"
[/csharp]
[/codeblocks]
*/
//go:nosplit
func (self StringName) UriDecode(ctx Lifetime) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.uri_decode(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns a copy of the string with special characters escaped using the C language standard.
*/
//go:nosplit
func (self StringName) CEscape(ctx Lifetime) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.c_escape(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns a copy of the string with escaped characters replaced by their meanings. Supported escape sequences are [code]\'[/code], [code]\"[/code], [code]\\[/code], [code]\a[/code], [code]\b[/code], [code]\f[/code], [code]\n[/code], [code]\r[/code], [code]\t[/code], [code]\v[/code].
[b]Note:[/b] Unlike the GDScript parser, this method doesn't support the [code]\uXXXX[/code] escape sequence.
*/
//go:nosplit
func (self StringName) CUnescape(ctx Lifetime) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.c_unescape(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns a copy of the string with special characters escaped using the JSON standard. Because it closely matches the C standard, it is possible to use [method c_unescape] to unescape the string, if necessary.
*/
//go:nosplit
func (self StringName) JsonEscape(ctx Lifetime) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.json_escape(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns a copy of the string with all characters that are not allowed in [member Node.name] ([code].[/code] [code]:[/code] [code]@[/code] [code]/[/code] [code]"[/code] [code]%[/code]) replaced with underscores.
*/
//go:nosplit
func (self StringName) ValidateNodeName(ctx Lifetime) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.validate_node_name(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns a copy of the string with all characters that are not allowed in [method is_valid_filename] replaced with underscores.
*/
//go:nosplit
func (self StringName) ValidateFilename(ctx Lifetime) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.validate_filename(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns [code]true[/code] if this string is a valid identifier. A valid identifier may contain only letters, digits and underscores ([code]_[/code]), and the first character may not be a digit.
[codeblock]
print("node_2d".is_valid_identifier())    # Prints true
print("TYPE_FLOAT".is_valid_identifier()) # Prints true
print("1st_method".is_valid_identifier()) # Prints false
print("MyMethod#2".is_valid_identifier()) # Prints false
[/codeblock]
*/
//go:nosplit
func (self StringName) IsValidIdentifier() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.is_valid_identifier(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns [code]true[/code] if this string represents a valid integer. A valid integer only contains digits, and may be prefixed with a positive ([code]+[/code]) or negative ([code]-[/code]) sign. See also [method to_int].
[codeblock]
print("7".is_valid_int())    # Prints true
print("1.65".is_valid_int()) # Prints false
print("Hi".is_valid_int())   # Prints false
print("+3".is_valid_int())   # Prints true
print("-12".is_valid_int())  # Prints true
[/codeblock]
*/
//go:nosplit
func (self StringName) IsValidInt() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.is_valid_int(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns [code]true[/code] if this string represents a valid floating-point number. A valid float may contain only digits, one decimal point ([code].[/code]), and the exponent letter ([code]e[/code]). It may also be prefixed with a positive ([code]+[/code]) or negative ([code]-[/code]) sign. Any valid integer is also a valid float (see [method is_valid_int]). See also [method to_float].
[codeblock]
print("1.7".is_valid_float())   # Prints true
print("24".is_valid_float())    # Prints true
print("7e3".is_valid_float())   # Prints true
print("Hello".is_valid_float()) # Prints false
[/codeblock]
*/
//go:nosplit
func (self StringName) IsValidFloat() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.is_valid_float(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns [code]true[/code] if this string is a valid hexadecimal number. A valid hexadecimal number only contains digits or letters [code]A[/code] to [code]F[/code] (either uppercase or lowercase), and may be prefixed with a positive ([code]+[/code]) or negative ([code]-[/code]) sign.
If [param with_prefix] is [code]true[/code], the hexadecimal number needs to prefixed by [code]"0x"[/code] to be considered valid.
[codeblock]
print("A08E".is_valid_hex_number())    # Prints true
print("-AbCdEf".is_valid_hex_number()) # Prints true
print("2.5".is_valid_hex_number())     # Prints false

print("0xDEADC0DE".is_valid_hex_number(true)) # Prints true
[/codeblock]
*/
//go:nosplit
func (self StringName) IsValidHexNumber(with_prefix bool) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, with_prefix)
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.is_valid_hex_number(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns [code]true[/code] if this string is a valid color in hexadecimal HTML notation. The string must be a hexadecimal value (see [method is_valid_hex_number]) of either 3, 4, 6 or 8 digits, and may be prefixed by a hash sign ([code]#[/code]). Other HTML notations for colors, such as names or [code]hsl()[/code], are not considered valid. See also [method Color.html].
*/
//go:nosplit
func (self StringName) IsValidHtmlColor() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.is_valid_html_color(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns [code]true[/code] if this string represents a well-formatted IPv4 or IPv6 address. This method considers [url=https://en.wikipedia.org/wiki/Reserved_IP_addresses]reserved IP addresses[/url] such as [code]"0.0.0.0"[/code] and [code]"ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff"[/code] as valid.
*/
//go:nosplit
func (self StringName) IsValidIpAddress() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.is_valid_ip_address(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns [code]true[/code] if this string does not contain characters that are not allowed in file names ([code]:[/code] [code]/[/code] [code]\[/code] [code]?[/code] [code]*[/code] [code]"[/code] [code]|[/code] [code]%[/code] [code]<[/code] [code]>[/code]).
*/
//go:nosplit
func (self StringName) IsValidFilename() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.is_valid_filename(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Converts the string representing an integer number into an [int]. This method removes any non-number character and stops at the first decimal point ([code].[/code]). See also [method is_valid_int].
[codeblock]
var a = "123".to_int()    # a is 123
var b = "x1y2z3".to_int() # b is 123
var c = "-1.2.3".to_int() # c is -1
var d = "Hello!".to_int() # d is 0
[/codeblock]
*/
//go:nosplit
func (self StringName) ToInt() Int {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.to_int(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Converts the string representing a decimal number into a [float]. This method stops on the first non-number character, except the first decimal point ([code].[/code]) and the exponent letter ([code]e[/code]). See also [method is_valid_float].
[codeblock]
var a = "12.35".to_float() # a is 12.35
var b = "1.2.3".to_float() # b is 1.2
var c = "12xy3".to_float() # c is 12.0
var d = "1e3".to_float()   # d is 1000.0
var e = "Hello!".to_int()  # e is 0.0
[/codeblock]
*/
//go:nosplit
func (self StringName) ToFloat() Float {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Float](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.to_float(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Converts the string representing a hexadecimal number into an [int]. The string may be optionally prefixed with [code]"0x"[/code], and an additional [code]-[/code] prefix for negative numbers.
[codeblocks]
[gdscript]
print("0xff".hex_to_int()) # Prints 255
print("ab".hex_to_int())   # Prints 171
[/gdscript]
[csharp]
GD.Print("0xff".HexToInt()); // Prints 255
GD.Print("ab".HexToInt());   // Prints 171
[/csharp]
[/codeblocks]
*/
//go:nosplit
func (self StringName) HexToInt() Int {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.hex_to_int(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Converts the string representing a binary number into an [int]. The string may optionally be prefixed with [code]"0b"[/code], and an additional [code]-[/code] prefix for negative numbers.
[codeblocks]
[gdscript]
print("101".bin_to_int())   # Prints 5
print("0b101".bin_to_int()) # Prints 5
print("-0b10".bin_to_int()) # Prints -2
[/gdscript]
[csharp]
GD.Print("101".BinToInt());   // Prints 5
GD.Print("0b101".BinToInt()); // Prints 5
GD.Print("-0b10".BinToInt()); // Prints -2
[/csharp]
[/codeblocks]
*/
//go:nosplit
func (self StringName) BinToInt() Int {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.bin_to_int(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Formats the string to be at least [param min_length] long by adding [param character]s to the left of the string, if necessary. See also [method rpad].
*/
//go:nosplit
func (self StringName) Lpad(ctx Lifetime, min_length Int, character String) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, min_length)
	callframe.Arg(frame, mmm.Get(character))
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.lpad(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Formats the string to be at least [param min_length] long, by adding [param character]s to the right of the string, if necessary. See also [method lpad].
*/
//go:nosplit
func (self StringName) Rpad(ctx Lifetime, min_length Int, character String) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, min_length)
	callframe.Arg(frame, mmm.Get(character))
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.rpad(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Formats the string representing a number to have an exact number of [param digits] [i]after[/i] the decimal point.
*/
//go:nosplit
func (self StringName) PadDecimals(ctx Lifetime, digits Int) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, digits)
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.pad_decimals(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Formats the string representing a number to have an exact number of [param digits] [i]before[/i] the decimal point.
*/
//go:nosplit
func (self StringName) PadZeros(ctx Lifetime, digits Int) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, digits)
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.pad_zeros(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Removes the given [param prefix] from the start of the string, or returns the string unchanged.
*/
//go:nosplit
func (self StringName) TrimPrefix(ctx Lifetime, prefix String) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(prefix))
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.trim_prefix(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Removes the given [param suffix] from the end of the string, or returns the string unchanged.
*/
//go:nosplit
func (self StringName) TrimSuffix(ctx Lifetime, suffix String) String {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(suffix))
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.trim_suffix(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Converts the string to an [url=https://en.wikipedia.org/wiki/ASCII]ASCII[/url]/Latin-1 encoded [PackedByteArray]. This method is slightly faster than [method to_utf8_buffer], but replaces all unsupported characters with spaces.
*/
//go:nosplit
func (self StringName) ToAsciiBuffer(ctx Lifetime) PackedByteArray {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.to_ascii_buffer(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[PackedByteArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Converts the string to a [url=https://en.wikipedia.org/wiki/UTF-8]UTF-8[/url] encoded [PackedByteArray]. This method is slightly slower than [method to_ascii_buffer], but supports all UTF-8 characters. For most cases, prefer using this method.
*/
//go:nosplit
func (self StringName) ToUtf8Buffer(ctx Lifetime) PackedByteArray {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.to_utf8_buffer(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[PackedByteArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Converts the string to a [url=https://en.wikipedia.org/wiki/UTF-16]UTF-16[/url] encoded [PackedByteArray].
*/
//go:nosplit
func (self StringName) ToUtf16Buffer(ctx Lifetime) PackedByteArray {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.to_utf16_buffer(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[PackedByteArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Converts the string to a [url=https://en.wikipedia.org/wiki/UTF-32]UTF-32[/url] encoded [PackedByteArray].
*/
//go:nosplit
func (self StringName) ToUtf32Buffer(ctx Lifetime) PackedByteArray {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.to_utf32_buffer(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[PackedByteArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Decodes a hexadecimal string as a [PackedByteArray].
[codeblocks]
[gdscript]
var text = "hello world"
var encoded = text.to_utf8_buffer().hex_encode() # outputs "68656c6c6f20776f726c64"
print(buf.hex_decode().get_string_from_utf8())
[/gdscript]
[csharp]
var text = "hello world";
var encoded = text.ToUtf8Buffer().HexEncode(); // outputs "68656c6c6f20776f726c64"
GD.Print(buf.HexDecode().GetStringFromUtf8());
[/csharp]
[/codeblocks]
*/
//go:nosplit
func (self StringName) HexDecode(ctx Lifetime) PackedByteArray {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.hex_decode(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[PackedByteArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Converts the string to a [url=https://en.wikipedia.org/wiki/Wide_character]wide character[/url] ([code]wchar_t[/code], UTF-16 on Windows, UTF-32 on other platforms) encoded [PackedByteArray].
*/
//go:nosplit
func (self StringName) ToWcharBuffer(ctx Lifetime) PackedByteArray {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.to_wchar_buffer(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[PackedByteArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns the 32-bit hash value representing the string's contents.
[b]Note:[/b] Strings with equal hash values are [i]not[/i] guaranteed to be the same, as a result of hash collisions. On the contrary, strings with different hash values are guaranteed to be different.
*/
//go:nosplit
func (self StringName) Hash() Int {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.StringName.hash(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns [code]true[/code] if the node path is absolute. Unlike a relative path, an absolute path is represented by a leading slash character ([code]/[/code]) and always begins from the [SceneTree]. It can be used to reliably access nodes from the root node (e.g. [code]"/root/Global"[/code] if an autoload named "Global" exists).
*/
//go:nosplit
func (self NodePath) IsAbsolute() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.NodePath.is_absolute(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns the number of node names in the path. Property subnames are not included.
For example, [code]"../RigidBody2D/Sprite2D:texture"[/code] contains 3 node names.
*/
//go:nosplit
func (self NodePath) GetNameCount() Int {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.NodePath.get_name_count(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns the node name indicated by [param idx], starting from 0. If [param idx] is out of bounds, an error is generated. See also [method get_subname_count] and [method get_name_count].
[codeblocks]
[gdscript]
var sprite_path = NodePath("../RigidBody2D/Sprite2D")
print(sprite_path.get_name(0)) # Prints "..".
print(sprite_path.get_name(1)) # Prints "RigidBody2D".
print(sprite_path.get_name(2)) # Prints "Sprite".
[/gdscript]
[csharp]
var spritePath = new NodePath("../RigidBody2D/Sprite2D");
GD.Print(spritePath.GetName(0)); // Prints "..".
GD.Print(spritePath.GetName(1)); // Prints "PathFollow2D".
GD.Print(spritePath.GetName(2)); // Prints "Sprite".
[/csharp]
[/codeblocks]
*/
//go:nosplit
func (self NodePath) GetName(ctx Lifetime, idx Int) StringName {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, idx)
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.NodePath.get_name(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[StringName](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns the number of property names ("subnames") in the path. Each subname in the node path is listed after a colon character ([code]:[/code]).
For example, [code]"Level/RigidBody2D/Sprite2D:texture:resource_name"[/code] contains 2 subnames.
*/
//go:nosplit
func (self NodePath) GetSubnameCount() Int {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.NodePath.get_subname_count(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns the 32-bit hash value representing the node path's contents.
[b]Note:[/b] Node paths with equal hash values are [i]not[/i] guaranteed to be the same, as a result of hash collisions. Node paths with different hash values are guaranteed to be different.
*/
//go:nosplit
func (self NodePath) Hash() Int {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.NodePath.hash(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns the property name indicated by [param idx], starting from 0. If [param idx] is out of bounds, an error is generated. See also [method get_subname_count].
[codeblocks]
[gdscript]
var path_to_name = NodePath("Sprite2D:texture:resource_name")
print(path_to_name.get_subname(0)) # Prints "texture".
print(path_to_name.get_subname(1)) # Prints "resource_name".
[/gdscript]
[csharp]
var pathToName = new NodePath("Sprite2D:texture:resource_name");
GD.Print(pathToName.GetSubname(0)); // Prints "texture".
GD.Print(pathToName.GetSubname(1)); // Prints "resource_name".
[/csharp]
[/codeblocks]
*/
//go:nosplit
func (self NodePath) GetSubname(ctx Lifetime, idx Int) StringName {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, idx)
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.NodePath.get_subname(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[StringName](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns all node names concatenated with a slash character ([code]/[/code]) as a single [StringName].
*/
//go:nosplit
func (self NodePath) GetConcatenatedNames(ctx Lifetime) StringName {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.NodePath.get_concatenated_names(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[StringName](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns all property subnames concatenated with a colon character ([code]:[/code]) as a single [StringName].
[codeblocks]
[gdscript]
var node_path = ^"Sprite2D:texture:resource_name"
print(node_path.get_concatenated_subnames()) # Prints "texture:resource_name".
[/gdscript]
[csharp]
var nodePath = new NodePath("Sprite2D:texture:resource_name");
GD.Print(nodePath.GetConcatenatedSubnames()); // Prints "texture:resource_name".
[/csharp]
[/codeblocks]
*/
//go:nosplit
func (self NodePath) GetConcatenatedSubnames(ctx Lifetime) StringName {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.NodePath.get_concatenated_subnames(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[StringName](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns the slice of the [NodePath], from [param begin] (inclusive) to [param end] (exclusive), as a new [NodePath].
The absolute value of [param begin] and [param end] will be clamped to the sum of [method get_name_count] and [method get_subname_count], so the default value for [param end] makes it slice to the end of the [NodePath] by default (i.e. [code]path.slice(1)[/code] is a shorthand for [code]path.slice(1, path.get_name_count() + path.get_subname_count())[/code]).
If either [param begin] or [param end] are negative, they will be relative to the end of the [NodePath] (i.e. [code]path.slice(0, -2)[/code] is a shorthand for [code]path.slice(0, path.get_name_count() + path.get_subname_count() - 2)[/code]).
*/
//go:nosplit
func (self NodePath) Slice(ctx Lifetime, begin Int, end Int) NodePath {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, begin)
	callframe.Arg(frame, end)
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.NodePath.slice(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[NodePath](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns a copy of this node path with a colon character ([code]:[/code]) prefixed, transforming it to a pure property path with no node names (relative to the current node).
[codeblocks]
[gdscript]
# node_path points to the "x" property of the child node named "position".
var node_path = ^"position:x"

# property_path points to the "position" in the "x" axis of this node.
var property_path = node_path.get_as_property_path()
print(property_path) # Prints ":position:x"
[/gdscript]
[csharp]
// nodePath points to the "x" property of the child node named "position".
var nodePath = new NodePath("position:x");

// propertyPath points to the "position" in the "x" axis of this node.
NodePath propertyPath = nodePath.GetAsPropertyPath();
GD.Print(propertyPath); // Prints ":position:x".
[/csharp]
[/codeblocks]
*/
//go:nosplit
func (self NodePath) GetAsPropertyPath(ctx Lifetime) NodePath {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.NodePath.get_as_property_path(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[NodePath](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns [code]true[/code] if the node path has been constructed from an empty [String] ([code]""[/code]).
*/
//go:nosplit
func (self NodePath) IsEmpty() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.NodePath.is_empty(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Creates a new [Callable] for the method named [param method] in the specified [param variant]. To represent a method of a built-in [Variant] type, a custom callable is used (see [method is_custom]). If [param variant] is [Object], then a standard callable will be created instead.
[b]Note:[/b] This method is always necessary for the [Dictionary] type, as property syntax is used to access its entries. You may also use this method when [param variant]'s type is not known in advance (for polymorphism).
*/
//go:nosplit
func (self Callable) Create(ctx Lifetime, variant Variant, method StringName) Callable {
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(variant))
	callframe.Arg(frame, mmm.Get(method))
	var r_ret = callframe.Ret[[2]uintptr](frame)
	ctx.API.builtin.Callable.create(0, frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[Callable](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Calls the method represented by this [Callable]. Unlike [method call], this method expects all arguments to be contained inside the [param arguments] [Array].
*/
//go:nosplit
func (self Callable) Callv(ctx Lifetime, arguments Array) Variant {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(arguments))
	var r_ret = callframe.Ret[[3]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Callable.callv(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns [code]true[/code] if this [Callable] has no target to call the method on.
*/
//go:nosplit
func (self Callable) IsNull() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Callable.is_null(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns [code]true[/code] if this [Callable] is a custom callable. Custom callables are used:
- for binding/unbinding arguments (see [method bind] and [method unbind]);
- for representing methods of built-in [Variant] types (see [method create]);
- for representing global, lambda, and RPC functions in GDScript;
- for other purposes in the core, GDExtension, and C#.
*/
//go:nosplit
func (self Callable) IsCustom() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Callable.is_custom(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns [code]true[/code] if this [Callable] is a standard callable. This method is the opposite of [method is_custom]. Returns [code]false[/code] if this callable is a lambda function.
*/
//go:nosplit
func (self Callable) IsStandard() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Callable.is_standard(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns [code]true[/code] if the callable's object exists and has a valid method name assigned, or is a custom callable.
*/
//go:nosplit
func (self Callable) IsValid() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Callable.is_valid(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns the object on which this [Callable] is called.
*/
//go:nosplit
func (self Callable) GetObject(ctx Lifetime) Object {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Callable.get_object(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret Object
	ret.SetPointer(PointerWithOwnershipTransferredToGo(ctx,r_ret.Get()))
	frame.Free()
	return ret
}
/*
Returns the ID of this [Callable]'s object (see [method Object.get_instance_id]).
*/
//go:nosplit
func (self Callable) GetObjectId() Int {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Callable.get_object_id(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns the name of the method represented by this [Callable]. If the callable is a GDScript lambda function, returns the function's name or [code]"<anonymous lambda>"[/code].
*/
//go:nosplit
func (self Callable) GetMethod(ctx Lifetime) StringName {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Callable.get_method(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[StringName](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns the total number of arguments this [Callable] should take, including optional arguments. This means that any arguments bound with [method bind] are [i]subtracted[/i] from the result, and any arguments unbound with [method unbind] are [i]added[/i] to the result.
*/
//go:nosplit
func (self Callable) GetArgumentCount() Int {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Callable.get_argument_count(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns the total amount of arguments bound (or unbound) via successive [method bind] or [method unbind] calls. If the amount of arguments unbound is greater than the ones bound, this function returns a value less than zero.
*/
//go:nosplit
func (self Callable) GetBoundArgumentsCount() Int {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Callable.get_bound_arguments_count(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Return the bound arguments (as long as [method get_bound_arguments_count] is greater than zero), or empty (if [method get_bound_arguments_count] is less than or equal to zero).
*/
//go:nosplit
func (self Callable) GetBoundArguments(ctx Lifetime) Array {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Callable.get_bound_arguments(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[Array](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns the 32-bit hash value of this [Callable]'s object.
[b]Note:[/b] [Callable]s with equal content will always produce identical hash values. However, the reverse is not true. Returning identical hash values does [i]not[/i] imply the callables are equal, because different callables can have identical hash values due to hash collisions. The engine uses a 32-bit hash algorithm for [method hash].
*/
//go:nosplit
func (self Callable) Hash() Int {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Callable.hash(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns a copy of this [Callable] with one or more arguments bound, reading them from an array. When called, the bound arguments are passed [i]after[/i] the arguments supplied by [method call]. See also [method unbind].
[b]Note:[/b] When this method is chained with other similar methods, the order in which the argument list is modified is read from right to left.
*/
//go:nosplit
func (self Callable) Bindv(ctx Lifetime, arguments Array) Callable {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(arguments))
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Callable.bindv(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[Callable](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns a copy of this [Callable] with a number of arguments unbound. In other words, when the new callable is called the last few arguments supplied by the user are ignored, according to [param argcount]. The remaining arguments are passed to the callable. This allows to use the original callable in a context that attempts to pass more arguments than this callable can handle, e.g. a signal with a fixed number of arguments. See also [method bind].
[b]Note:[/b] When this method is chained with other similar methods, the order in which the argument list is modified is read from right to left.
[codeblock]
func _ready():
    foo.unbind(1).call(1, 2) # Calls foo(1).
    foo.bind(3, 4).unbind(1).call(1, 2) # Calls foo(1, 3, 4), note that it does not change the arguments from bind.
[/codeblock]
*/
//go:nosplit
func (self Callable) Unbind(ctx Lifetime, argcount Int) Callable {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, argcount)
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Callable.unbind(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[Callable](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Calls the method represented by this [Callable]. Arguments can be passed and should match the method's signature.
*/
//go:nosplit
func (self Callable) Call(ctx Lifetime, args ...Variant) Variant {
	var selfPtr = self
	var frame = callframe.New()
	for _, arg := range args {
		callframe.Arg(frame, mmm.Get(arg))
	}
	var r_ret = callframe.Ret[[3]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Callable.call(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), int32(len(args))+0)
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Calls the method represented by this [Callable] in deferred mode, i.e. at the end of the current frame. Arguments can be passed and should match the method's signature.
[codeblocks]
[gdscript]
func _ready():
    grab_focus.call_deferred()
[/gdscript]
[csharp]
public override void _Ready()
{
    Callable.From(GrabFocus).CallDeferred();
}
[/csharp]
[/codeblocks]
[b]Note:[/b] Deferred calls are processed at idle time. Idle time happens mainly at the end of process and physics frames. In it, deferred calls will be run until there are none left, which means you can defer calls from other deferred calls and they'll still be run in the current idle time cycle. This means you should not call a method deferred from itself (or from a method called by it), as this causes infinite recursion the same way as if you had called the method directly.
See also [method Object.call_deferred].
*/
//go:nosplit
func (self Callable) CallDeferred(args ...Variant)  {
	var selfPtr = self
	var frame = callframe.New()
	for _, arg := range args {
		callframe.Arg(frame, mmm.Get(arg))
	}
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Callable.call_deferred(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), int32(len(args))+0)
	frame.Free()
}
/*
Perform an RPC (Remote Procedure Call) on all connected peers. This is used for multiplayer and is normally not available, unless the function being called has been marked as [i]RPC[/i] (using [annotation @GDScript.@rpc] or [method Node.rpc_config]). Calling this method on unsupported functions will result in an error. See [method Node.rpc].
*/
//go:nosplit
func (self Callable) Rpc(args ...Variant)  {
	var selfPtr = self
	var frame = callframe.New()
	for _, arg := range args {
		callframe.Arg(frame, mmm.Get(arg))
	}
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Callable.rpc(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), int32(len(args))+0)
	frame.Free()
}
/*
Perform an RPC (Remote Procedure Call) on a specific peer ID (see multiplayer documentation for reference). This is used for multiplayer and is normally not available unless the function being called has been marked as [i]RPC[/i] (using [annotation @GDScript.@rpc] or [method Node.rpc_config]). Calling this method on unsupported functions will result in an error. See [method Node.rpc_id].
*/
//go:nosplit
func (self Callable) RpcId(peer_id Int, args ...Variant)  {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, peer_id)
	for _, arg := range args {
		callframe.Arg(frame, mmm.Get(arg))
	}
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Callable.rpc_id(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), int32(len(args))+1)
	frame.Free()
}
/*
Returns a copy of this [Callable] with one or more arguments bound. When called, the bound arguments are passed [i]after[/i] the arguments supplied by [method call]. See also [method unbind].
[b]Note:[/b] When this method is chained with other similar methods, the order in which the argument list is modified is read from right to left.
*/
//go:nosplit
func (self Callable) Bind(ctx Lifetime, args ...Variant) Callable {
	var selfPtr = self
	var frame = callframe.New()
	for _, arg := range args {
		callframe.Arg(frame, mmm.Get(arg))
	}
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Callable.bind(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), int32(len(args))+0)
	var ret = mmm.New[Callable](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns [code]true[/code] if the signal's name does not exist in its object, or the object is not valid.
*/
//go:nosplit
func (self Signal) IsNull() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Signal.is_null(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns the object emitting this signal.
*/
//go:nosplit
func (self Signal) GetObject(ctx Lifetime) Object {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Signal.get_object(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret Object
	ret.SetPointer(PointerWithOwnershipTransferredToGo(ctx,r_ret.Get()))
	frame.Free()
	return ret
}
/*
Returns the ID of the object emitting this signal (see [method Object.get_instance_id]).
*/
//go:nosplit
func (self Signal) GetObjectId() Int {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Signal.get_object_id(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns the name of this signal.
*/
//go:nosplit
func (self Signal) GetName(ctx Lifetime) StringName {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Signal.get_name(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[StringName](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Connects this signal to the specified [param callable]. Optional [param flags] can be also added to configure the connection's behavior (see [enum Object.ConnectFlags] constants). You can provide additional arguments to the connected [param callable] by using [method Callable.bind].
A signal can only be connected once to the same [Callable]. If the signal is already connected, returns [constant ERR_INVALID_PARAMETER] and pushes an error message, unless the signal is connected with [constant Object.CONNECT_REFERENCE_COUNTED]. To prevent this, use [method is_connected] first to check for existing connections.
[codeblock]
for button in $Buttons.get_children():
    button.pressed.connect(_on_pressed.bind(button))

func _on_pressed(button):
    print(button.name, " was pressed")
[/codeblock]
*/
//go:nosplit
func (self Signal) Connect(callable Callable, flags Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(callable))
	callframe.Arg(frame, flags)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Signal.connect(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Disconnects this signal from the specified [Callable]. If the connection does not exist, generates an error. Use [method is_connected] to make sure that the connection exists.
*/
//go:nosplit
func (self Signal) Disconnect(callable Callable)  {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(callable))
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Signal.disconnect(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	frame.Free()
}
/*
Returns [code]true[/code] if the specified [Callable] is connected to this signal.
*/
//go:nosplit
func (self Signal) IsConnected(callable Callable) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(callable))
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Signal.is_connected(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns an [Array] of connections for this signal. Each connection is represented as a [Dictionary] that contains three entries:
- [code]signal[/code] is a reference to this signal;
- [code]callable[/code] is a reference to the connected [Callable];
- [code]flags[/code] is a combination of [enum Object.ConnectFlags].
*/
//go:nosplit
func (self Signal) GetConnections(ctx Lifetime) Array {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Signal.get_connections(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[Array](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Emits this signal. All [Callable]s connected to this signal will be triggered. This method supports a variable number of arguments, so parameters can be passed as a comma separated list.
*/
//go:nosplit
func (self Signal) Emit(args ...Variant)  {
	var selfPtr = self
	var frame = callframe.New()
	for _, arg := range args {
		callframe.Arg(frame, mmm.Get(arg))
	}
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Signal.emit(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), int32(len(args))+0)
	frame.Free()
}
/*
Returns the number of entries in the dictionary. Empty dictionaries ([code]{ }[/code]) always return [code]0[/code]. See also [method is_empty].
*/
//go:nosplit
func (self Dictionary) Size() Int {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Dictionary.size(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns [code]true[/code] if the dictionary is empty (its size is [code]0[/code]). See also [method size].
*/
//go:nosplit
func (self Dictionary) IsEmpty() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Dictionary.is_empty(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Clears the dictionary, removing all entries from it.
*/
//go:nosplit
func (self Dictionary) Clear()  {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Dictionary.clear(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	frame.Free()
}
/*
Adds entries from [param dictionary] to this dictionary. By default, duplicate keys are not copied over, unless [param overwrite] is [code]true[/code].
[codeblocks]
[gdscript]
var dict = { "item": "sword", "quantity": 2 }
var other_dict = { "quantity": 15, "color": "silver" }

# Overwriting of existing keys is disabled by default.
dict.merge(other_dict)
print(dict)  # { "item": "sword", "quantity": 2, "color": "silver" }

# With overwriting of existing keys enabled.
dict.merge(other_dict, true)
print(dict)  # { "item": "sword", "quantity": 15, "color": "silver" }
[/gdscript]
[csharp]
var dict = new Godot.Collections.Dictionary
{
    ["item"] = "sword",
    ["quantity"] = 2,
};

var otherDict = new Godot.Collections.Dictionary
{
    ["quantity"] = 15,
    ["color"] = "silver",
};

// Overwriting of existing keys is disabled by default.
dict.Merge(otherDict);
GD.Print(dict); // { "item": "sword", "quantity": 2, "color": "silver" }

// With overwriting of existing keys enabled.
dict.Merge(otherDict, true);
GD.Print(dict); // { "item": "sword", "quantity": 15, "color": "silver" }
[/csharp]
[/codeblocks]
[b]Note:[/b] [method merge] is [i]not[/i] recursive. Nested dictionaries are considered as keys that can be overwritten or not depending on the value of [param overwrite], but they will never be merged together.
*/
//go:nosplit
func (self Dictionary) Merge(dictionary Dictionary, overwrite bool)  {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(dictionary))
	callframe.Arg(frame, overwrite)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Dictionary.merge(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	frame.Free()
}
/*
Returns a copy of this dictionary merged with the other [param dictionary]. By default, duplicate keys are not copied over, unless [param overwrite] is [code]true[/code]. See also [method merge].
This method is useful for quickly making dictionaries with default values:
[codeblock]
var base = { "fruit": "apple", "vegetable": "potato" }
var extra = { "fruit": "orange", "dressing": "vinegar" }
# Prints { "fruit": "orange", "vegetable": "potato", "dressing": "vinegar" }
print(extra.merged(base))
# Prints { "fruit": "apple", "vegetable": "potato", "dressing": "vinegar" }
print(extra.merged(base, true))
[/codeblock]
*/
//go:nosplit
func (self Dictionary) Merged(ctx Lifetime, dictionary Dictionary, overwrite bool) Dictionary {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(dictionary))
	callframe.Arg(frame, overwrite)
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Dictionary.merged(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[Dictionary](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns [code]true[/code] if the dictionary contains an entry with the given [param key].
[codeblocks]
[gdscript]
var my_dict = {
    "Godot" : 4,
    210 : null,
}

print(my_dict.has("Godot")) # Prints true
print(my_dict.has(210))     # Prints true
print(my_dict.has(4))       # Prints false
[/gdscript]
[csharp]
var myDict = new Godot.Collections.Dictionary
{
    { "Godot", 4 },
    { 210, default },
};

GD.Print(myDict.ContainsKey("Godot")); // Prints true
GD.Print(myDict.ContainsKey(210));     // Prints true
GD.Print(myDict.ContainsKey(4));       // Prints false
[/csharp]
[/codeblocks]
In GDScript, this is equivalent to the [code]in[/code] operator:
[codeblock]
if "Godot" in {"Godot": 4}:
    print("The key is here!") # Will be printed.
[/codeblock]
[b]Note:[/b] This method returns [code]true[/code] as long as the [param key] exists, even if its corresponding value is [code]null[/code].
*/
//go:nosplit
func (self Dictionary) Has(key Variant) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(key))
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Dictionary.has(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns [code]true[/code] if the dictionary contains all keys in the given [param keys] array.
[codeblock]
var data = {"width" : 10, "height" : 20}
data.has_all(["height", "width"]) # Returns true
[/codeblock]
*/
//go:nosplit
func (self Dictionary) HasAll(keys Array) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(keys))
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Dictionary.has_all(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Finds and returns the first key whose associated value is equal to [param value], or [code]null[/code] if it is not found.
[b]Note:[/b] [code]null[/code] is also a valid key. If inside the dictionary, [method find_key] may give misleading results.
*/
//go:nosplit
func (self Dictionary) FindKey(ctx Lifetime, value Variant) Variant {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(value))
	var r_ret = callframe.Ret[[3]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Dictionary.find_key(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Removes the dictionary entry by key, if it exists. Returns [code]true[/code] if the given [param key] existed in the dictionary, otherwise [code]false[/code].
[b]Note:[/b] Do not erase entries while iterating over the dictionary. You can iterate over the [method keys] array instead.
*/
//go:nosplit
func (self Dictionary) Erase(key Variant) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(key))
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Dictionary.erase(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns a hashed 32-bit integer value representing the dictionary contents.
[codeblocks]
[gdscript]
var dict1 = {"A": 10, "B": 2}
var dict2 = {"A": 10, "B": 2}

print(dict1.hash() == dict2.hash()) # Prints true
[/gdscript]
[csharp]
var dict1 = new Godot.Collections.Dictionary{{"A", 10}, {"B", 2}};
var dict2 = new Godot.Collections.Dictionary{{"A", 10}, {"B", 2}};

// Godot.Collections.Dictionary has no Hash() method. Use GD.Hash() instead.
GD.Print(GD.Hash(dict1) == GD.Hash(dict2)); // Prints true
[/csharp]
[/codeblocks]
[b]Note:[/b] Dictionaries with the same entries but in a different order will not have the same hash.
[b]Note:[/b] Dictionaries with equal hash values are [i]not[/i] guaranteed to be the same, because of hash collisions. On the contrary, dictionaries with different hash values are guaranteed to be different.
*/
//go:nosplit
func (self Dictionary) Hash() Int {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Dictionary.hash(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns the list of keys in the dictionary.
*/
//go:nosplit
func (self Dictionary) Keys(ctx Lifetime) Array {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Dictionary.keys(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[Array](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns the list of values in this dictionary.
*/
//go:nosplit
func (self Dictionary) Values(ctx Lifetime) Array {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Dictionary.values(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[Array](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Creates and returns a new copy of the dictionary. If [param deep] is [code]true[/code], inner [Dictionary] and [Array] keys and values are also copied, recursively.
*/
//go:nosplit
func (self Dictionary) Duplicate(ctx Lifetime, deep bool) Dictionary {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, deep)
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Dictionary.duplicate(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[Dictionary](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns the corresponding value for the given [param key] in the dictionary. If the [param key] does not exist, returns [param default], or [code]null[/code] if the parameter is omitted.
*/
//go:nosplit
func (self Dictionary) Get(ctx Lifetime, key Variant, def Variant) Variant {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(key))
	callframe.Arg(frame, mmm.Get(def))
	var r_ret = callframe.Ret[[3]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Dictionary.get(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Gets a value and ensures the key is set. If the [param key] exists in the dictionary, this behaves like [method get]. Otherwise, the [param default] value is inserted into the dictionary and returned.
*/
//go:nosplit
func (self Dictionary) GetOrAdd(ctx Lifetime, key Variant, def Variant) Variant {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(key))
	callframe.Arg(frame, mmm.Get(def))
	var r_ret = callframe.Ret[[3]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Dictionary.get_or_add(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Makes the dictionary read-only, i.e. disables modification of the dictionary's contents. Does not apply to nested content, e.g. content of nested dictionaries.
*/
//go:nosplit
func (self Dictionary) MakeReadOnly()  {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Dictionary.make_read_only(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	frame.Free()
}
/*
Returns [code]true[/code] if the dictionary is read-only. See [method make_read_only]. Dictionaries are automatically read-only if declared with [code]const[/code] keyword.
*/
//go:nosplit
func (self Dictionary) IsReadOnly() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Dictionary.is_read_only(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns [code]true[/code] if the two dictionaries contain the same keys and values, inner [Dictionary] and [Array] keys and values are compared recursively.
*/
//go:nosplit
func (self Dictionary) RecursiveEqual(dictionary Dictionary, recursion_count Int) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(dictionary))
	callframe.Arg(frame, recursion_count)
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Dictionary.recursive_equal(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns the number of elements in the array. Empty arrays ([code][][/code]) always return [code]0[/code]. See also [method is_empty].
*/
//go:nosplit
func (self Array) Size() Int {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Array.size(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns [code]true[/code] if the array is empty ([code][][/code]). See also [method size].
*/
//go:nosplit
func (self Array) IsEmpty() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Array.is_empty(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Removes all elements from the array. This is equivalent to using [method resize] with a size of [code]0[/code].
*/
//go:nosplit
func (self Array) Clear()  {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Array.clear(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	frame.Free()
}
/*
Returns a hashed 32-bit integer value representing the array and its contents.
[b]Note:[/b] Arrays with equal hash values are [i]not[/i] guaranteed to be the same, as a result of hash collisions. On the countrary, arrays with different hash values are guaranteed to be different.
*/
//go:nosplit
func (self Array) Hash() Int {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Array.hash(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Assigns elements of another [param array] into the array. Resizes the array to match [param array]. Performs type conversions if the array is typed.
*/
//go:nosplit
func (self Array) Assign(array Array)  {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(array))
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Array.assign(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	frame.Free()
}
/*
Appends an element at the end of the array. See also [method push_front].
*/
//go:nosplit
func (self Array) PushBack(value Variant)  {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(value))
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Array.push_back(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	frame.Free()
}
/*
Adds an element at the beginning of the array. See also [method push_back].
[b]Note:[/b] This method shifts every other element's index forward, which may have a noticeable performance cost, especially on larger arrays.
*/
//go:nosplit
func (self Array) PushFront(value Variant)  {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(value))
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Array.push_front(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	frame.Free()
}
/*
Appends [param value] at the end of the array (alias of [method push_back]).
*/
//go:nosplit
func (self Array) Append(value Variant)  {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(value))
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Array.append(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	frame.Free()
}
/*
Appends another [param array] at the end of this array.
[codeblock]
var numbers = [1, 2, 3]
var extra = [4, 5, 6]
numbers.append_array(extra)
print(nums) # Prints [1, 2, 3, 4, 5, 6]
[/codeblock]
*/
//go:nosplit
func (self Array) AppendArray(array Array)  {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(array))
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Array.append_array(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	frame.Free()
}
/*
Sets the array's number of elements to [param size]. If [param size] is smaller than the array's current size, the elements at the end are removed. If [param size] is greater, new default elements (usually [code]null[/code]) are added, depending on the array's type.
Returns [constant OK] on success, or one of the other [enum Error] constants if this method fails.
[b]Note:[/b] Calling this method once and assigning the new values is faster than calling [method append] for every new element.
*/
//go:nosplit
func (self Array) Resize(size Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, size)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Array.resize(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Inserts a new element ([param value]) at a given index ([param position]) in the array. [param position] should be between [code]0[/code] and the array's [method size].
Returns [constant OK] on success, or one of the other [enum Error] constants if this method fails.
[b]Note:[/b] Every element's index after [param position] needs to be shifted forward, which may have a noticeable performance cost, especially on larger arrays.
*/
//go:nosplit
func (self Array) Insert(position Int, value Variant) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, position)
	callframe.Arg(frame, mmm.Get(value))
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Array.insert(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Removes the element from the array at the given index ([param position]). If the index is out of bounds, this method fails.
If you need to return the removed element, use [method pop_at]. To remove an element by value, use [method erase] instead.
[b]Note:[/b] This method shifts every element's index after [param position] back, which may have a noticeable performance cost, especially on larger arrays.
[b]Note:[/b] The [param position] cannot be negative. To remove an element relative to the end of the array, use [code]arr.remove_at(arr.size() - (i + 1))[/code]. To remove the last element from the array, use [code]arr.resize(arr.size() - 1)[/code].
*/
//go:nosplit
func (self Array) RemoveAt(position Int)  {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, position)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Array.remove_at(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	frame.Free()
}
/*
Assigns the given [param value] to all elements in the array.
This method can often be combined with [method resize] to create an array with a given size and initialized elements:
[codeblocks]
[gdscript]
var array = []
array.resize(5)
array.fill(2)
print(array) # Prints [2, 2, 2, 2, 2]
[/gdscript]
[csharp]
var array = new Godot.Collections.Array();
array.Resize(5);
array.Fill(2);
GD.Print(array); // Prints [2, 2, 2, 2, 2]
[/csharp]
[/codeblocks]
[b]Note:[/b] If [param value] is a [Variant] passed by reference ([Object]-derived, [Array], [Dictionary], etc.), the array will be filled with references to the same [param value], which are not duplicates.
*/
//go:nosplit
func (self Array) Fill(value Variant)  {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(value))
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Array.fill(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	frame.Free()
}
/*
Finds and removes the first occurrence of [param value] from the array. If [param value] does not exist in the array, nothing happens. To remove an element by index, use [method remove_at] instead.
[b]Note:[/b] This method shifts every element's index after the removed [param value] back, which may have a noticeable performance cost, especially on larger arrays.
[b]Note:[/b] Erasing elements while iterating over arrays is [b]not[/b] supported and will result in unpredictable behavior.
*/
//go:nosplit
func (self Array) Erase(value Variant)  {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(value))
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Array.erase(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	frame.Free()
}
/*
Returns the first element of the array. If the array is empty, fails and returns [code]null[/code]. See also [method back].
[b]Note:[/b] Unlike with the [code][][/code] operator ([code]array[0][/code]), an error is generated without stopping project execution.
*/
//go:nosplit
func (self Array) Front(ctx Lifetime) Variant {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[3]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Array.front(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns the last element of the array. If the array is empty, fails and returns [code]null[/code]. See also [method front].
[b]Note:[/b] Unlike with the [code][][/code] operator ([code]array[-1][/code]), an error is generated without stopping project execution.
*/
//go:nosplit
func (self Array) Back(ctx Lifetime) Variant {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[3]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Array.back(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns a random element from the array. Generates an error and returns [code]null[/code] if the array is empty.
[codeblocks]
[gdscript]
# May print 1, 2, 3.25, or "Hi".
print([1, 2, 3.25, "Hi"].pick_random())
[/gdscript]
[csharp]
var array = new Godot.Collections.Array { 1, 2, 3.25f, "Hi" };
GD.Print(array.PickRandom()); // May print 1, 2, 3.25, or "Hi".
[/csharp]
[/codeblocks]
[b]Note:[/b] Like many similar functions in the engine (such as [method @GlobalScope.randi] or [method shuffle]), this method uses a common, global random seed. To get a predictable outcome from this method, see [method @GlobalScope.seed].
*/
//go:nosplit
func (self Array) PickRandom(ctx Lifetime) Variant {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[3]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Array.pick_random(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns the index of the [b]first[/b] occurrence of [param what] in this array, or [code]-1[/code] if there are none. The search's start can be specified with [param from], continuing to the end of the array.
[b]Note:[/b] If you just want to know whether the array contains [param what], use [method has] ([code]Contains[/code] in C#). In GDScript, you may also use the [code]in[/code] operator.
[b]Note:[/b] For performance reasons, the search is affected by [param what]'s [enum Variant.Type]. For example, [code]7[/code] ([int]) and [code]7.0[/code] ([float]) are not considered equal for this method.
*/
//go:nosplit
func (self Array) Find(what Variant, from Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(what))
	callframe.Arg(frame, from)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Array.find(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns the index of the [b]last[/b] occurrence of [param what] in this array, or [code]-1[/code] if there are none. The search's start can be specified with [param from], continuing to the beginning of the array. This method is the reverse of [method find].
*/
//go:nosplit
func (self Array) Rfind(what Variant, from Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(what))
	callframe.Arg(frame, from)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Array.rfind(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns the number of times an element is in the array.
*/
//go:nosplit
func (self Array) Count(value Variant) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(value))
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Array.count(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns [code]true[/code] if the array contains the given [param value].
[codeblocks]
[gdscript]
print(["inside", 7].has("inside"))  # Prints true
print(["inside", 7].has("outside")) # Prints false
print(["inside", 7].has(7))         # Prints true
print(["inside", 7].has("7"))       # Prints false
[/gdscript]
[csharp]
var arr = new Godot.Collections.Array { "inside", 7 };
// By C# convention, this method is renamed to `Contains`.
GD.Print(arr.Contains("inside"));  // Prints true
GD.Print(arr.Contains("outside")); // Prints false
GD.Print(arr.Contains(7));         // Prints true
GD.Print(arr.Contains("7"));       // Prints false
[/csharp]
[/codeblocks]
In GDScript, this is equivalent to the [code]in[/code] operator:
[codeblock]
if 4 in [2, 4, 6, 8]:
    print("4 is here!") # Will be printed.
[/codeblock]
[b]Note:[/b] For performance reasons, the search is affected by the [param value]'s [enum Variant.Type]. For example, [code]7[/code] ([int]) and [code]7.0[/code] ([float]) are not considered equal for this method.
*/
//go:nosplit
func (self Array) Has(value Variant) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(value))
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Array.has(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Removes and returns the last element of the array. Returns [code]null[/code] if the array is empty, without generating an error. See also [method pop_front].
*/
//go:nosplit
func (self Array) PopBack(ctx Lifetime) Variant {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[3]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Array.pop_back(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Removes and returns the first element of the array. Returns [code]null[/code] if the array is empty, without generating an error. See also [method pop_back].
[b]Note:[/b] This method shifts every other element's index back, which may have a noticeable performance cost, especially on larger arrays.
*/
//go:nosplit
func (self Array) PopFront(ctx Lifetime) Variant {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[3]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Array.pop_front(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Removes and returns the element of the array at index [param position]. If negative, [param position] is considered relative to the end of the array. Returns [code]null[/code] if the array is empty. If [param position] is out of bounds, an error message is also generated.
[b]Note:[/b] This method shifts every element's index after [param position] back, which may have a noticeable performance cost, especially on larger arrays.
*/
//go:nosplit
func (self Array) PopAt(ctx Lifetime, position Int) Variant {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, position)
	var r_ret = callframe.Ret[[3]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Array.pop_at(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Sorts the array in ascending order. The final order is dependent on the "less than" ([code]<[/code]) comparison between elements.
[codeblocks]
[gdscript]
var numbers = [10, 5, 2.5, 8]
numbers.sort()
print(numbers) # Prints [2.5, 5, 8, 10]
[/gdscript]
[csharp]
var numbers = new Godot.Collections.Array { 10, 5, 2.5, 8 };
numbers.Sort();
GD.Print(numbers); // Prints [2.5, 5, 8, 10]
[/csharp]
[/codeblocks]
[b]Note:[/b] The sorting algorithm used is not [url=https://en.wikipedia.org/wiki/Sorting_algorithm#Stability]stable[/url]. This means that equivalent elements (such as [code]2[/code] and [code]2.0[/code]) may have their order changed when calling [method sort].
*/
//go:nosplit
func (self Array) Sort()  {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Array.sort(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	frame.Free()
}
/*
Sorts the array using a custom [Callable].
[param func] is called as many times as necessary, receiving two array elements as arguments. The function should return [code]true[/code] if the first element should be moved [i]behind[/i] the second one, otherwise it should return [code]false[/code].
[codeblock]
func sort_ascending(a, b):
    if a[1] < b[1]:
        return true
    return false

func _ready():
    var my_items = [["Tomato", 5], ["Apple", 9], ["Rice", 4]]
    my_items.sort_custom(sort_ascending)
    print(my_items) # Prints [["Rice", 4], ["Tomato", 5], ["Apple", 9]]

    # Sort descending, using a lambda function.
    my_items.sort_custom(func(a, b): return a[0] > b[0])
    print(my_items) # Prints [["Apple", 9], ["Tomato", 5], ["Rice", 4]]
[/codeblock]
It may also be necessary to use this method to sort strings by natural order, with [method String.naturalnocasecmp_to], as in the following example:
[codeblock]
var files = ["newfile1", "newfile2", "newfile10", "newfile11"]
files.sort_custom(func(a, b): return a.naturalnocasecmp_to(b) < 0)
print(files) # Prints ["newfile1", "newfile2", "newfile10", "newfile11"]
[/codeblock]
[b]Note:[/b] In C#, this method is not supported.
[b]Note:[/b] The sorting algorithm used is not [url=https://en.wikipedia.org/wiki/Sorting_algorithm#Stability]stable[/url]. This means that values considered equal may have their order changed when calling this method.
[b]Note:[/b] You should not randomize the return value of [param func], as the heapsort algorithm expects a consistent result. Randomizing the return value will result in unexpected behavior.
*/
//go:nosplit
func (self Array) SortCustom(fn Callable)  {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(fn))
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Array.sort_custom(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	frame.Free()
}
/*
Shuffles all elements of the array in a random order.
[b]Note:[/b] Like many similar functions in the engine (such as [method @GlobalScope.randi] or [method pick_random]), this method uses a common, global random seed. To get a predictable outcome from this method, see [method @GlobalScope.seed].
*/
//go:nosplit
func (self Array) Shuffle()  {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Array.shuffle(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	frame.Free()
}
/*
Returns the index of [param value] in the sorted array. If it cannot be found, returns where [param value] should be inserted to keep the array sorted. The algorithm used is [url=https://en.wikipedia.org/wiki/Binary_search_algorithm]binary search[/url].
If [param before] is [code]true[/code] (as by default), the returned index comes before all existing elements equal to [param value] in the array.
[codeblock]
var numbers = [2, 4, 8, 10]
var idx = numbers.bsearch(7)

numbers.insert(idx, 7)
print(numbers) # Prints [2, 4, 7, 8, 10]

var fruits = ["Apple", "Lemon", "Lemon", "Orange"]
print(fruits.bsearch("Lemon", true))  # Prints 1, points at the first "Lemon".
print(fruits.bsearch("Lemon", false)) # Prints 3, points at "Orange".
[/codeblock]
[b]Note:[/b] Calling [method bsearch] on an [i]unsorted[/i] array will result in unexpected behavior. Use [method sort] before calling this method.
*/
//go:nosplit
func (self Array) Bsearch(value Variant, before bool) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(value))
	callframe.Arg(frame, before)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Array.bsearch(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns the index of [param value] in the sorted array. If it cannot be found, returns where [param value] should be inserted to keep the array sorted (using [param func] for the comparisons). The algorithm used is [url=https://en.wikipedia.org/wiki/Binary_search_algorithm]binary search[/url].
Similar to [method sort_custom], [param func] is called as many times as necessary, receiving one array element and [param value] as arguments. The function should return [code]true[/code] if the array element should be [i]behind[/i] [param value], otherwise it should return [code]false[/code].
If [param before] is [code]true[/code] (as by default), the returned index comes before all existing elements equal to [param value] in the array.
[codeblock]
func sort_by_amount(a, b):
    if a[1] < b[1]:
        return true
    return false

func _ready():
    var my_items = [["Tomato", 2], ["Kiwi", 5], ["Rice", 9]]

    var apple = ["Apple", 5]
    # "Apple" is inserted before "Kiwi".
    my_items.insert(my_items.bsearch_custom(apple, sort_by_amount, true), apple)

    var banana = ["Banana", 5]
    # "Banana" is inserted after "Kiwi".
    my_items.insert(my_items.bsearch_custom(banana, sort_by_amount, false), banana)

    # Prints [["Tomato", 2], ["Apple", 5], ["Kiwi", 5], ["Banana", 5], ["Rice", 9]]
    print(my_items)
[/codeblock]
[b]Note:[/b] Calling [method bsearch_custom] on an [i]unsorted[/i] array will result in unexpected behavior. Use [method sort_custom] with [param func] before calling this method.
*/
//go:nosplit
func (self Array) BsearchCustom(value Variant, fn Callable, before bool) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(value))
	callframe.Arg(frame, mmm.Get(fn))
	callframe.Arg(frame, before)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Array.bsearch_custom(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 3)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Reverses the order of all elements in the array.
*/
//go:nosplit
func (self Array) Reverse()  {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Array.reverse(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	frame.Free()
}
/*
Returns a new copy of the array.
By default, a [b]shallow[/b] copy is returned: all nested [Array] and [Dictionary] elements are shared with the original array. Modifying them in one array will also affect them in the other.[br]If [param deep] is [code]true[/code], a [b]deep[/b] copy is returned: all nested arrays and dictionaries are also duplicated (recursively).
*/
//go:nosplit
func (self Array) Duplicate(ctx Lifetime, deep bool) Array {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, deep)
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Array.duplicate(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[Array](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns a new [Array] containing this array's elements, from index [param begin] (inclusive) to [param end] (exclusive), every [param step] elements.
If either [param begin] or [param end] are negative, their value is relative to the end of the array.
If [param step] is negative, this method iterates through the array in reverse, returning a slice ordered backwards. For this to work, [param begin] must be greater than [param end].
If [param deep] is [code]true[/code], all nested [Array] and [Dictionary] elements in the slice are duplicated from the original, recursively. See also [method duplicate]).
[codeblock]
var letters = ["A", "B", "C", "D", "E", "F"]

print(letters.slice(0, 2))  # Prints ["A", "B"]
print(letters.slice(2, -2)) # Prints ["C", "D"]
print(letters.slice(-2, 6)) # Prints ["E", "F"]

print(letters.slice(0, 6, 2))  # Prints ["A", "C", "E"]
print(letters.slice(4, 1, -1)) # Prints ["E", "D", "C"]
[/codeblock]
*/
//go:nosplit
func (self Array) Slice(ctx Lifetime, begin Int, end Int, step Int, deep bool) Array {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, begin)
	callframe.Arg(frame, end)
	callframe.Arg(frame, step)
	callframe.Arg(frame, deep)
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Array.slice(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 4)
	var ret = mmm.New[Array](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Calls the given [Callable] on each element in the array and returns a new, filtered [Array].
The [param method] receives one of the array elements as an argument, and should return [code]true[/code] to add the element to the filtered array, or [code]false[/code] to exclude it.
[codeblock]
func is_even(number):
    return number % 2 == 0

func _ready():
    print([1, 4, 5, 8].filter(is_even)) # Prints [4, 8]

    # Same as above, but using a lambda function.
    print([1, 4, 5, 8].filter(func(number): return number % 2 == 0))
[/codeblock]
See also [method any], [method all], [method map] and [method reduce].
*/
//go:nosplit
func (self Array) Filter(ctx Lifetime, method Callable) Array {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(method))
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Array.filter(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[Array](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Calls the given [Callable] for each element in the array and returns a new array filled with values returned by the [param method].
The [param method] should take one [Variant] parameter (the current array element) and can return any [Variant].
[codeblock]
func double(number):
    return number * 2

func _ready():
    print([1, 2, 3].map(double)) # Prints [2, 4, 6]

    # Same as above, but using a lambda function.
    print([1, 2, 3].map(func(element): return element * 2))
[/codeblock]
See also [method filter], [method reduce], [method any] and [method all].
*/
//go:nosplit
func (self Array) Map(ctx Lifetime, method Callable) Array {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(method))
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Array.map_(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = mmm.New[Array](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Calls the given [Callable] for each element in array, accumulates the result in [param accum], then returns it.
The [param method] takes two arguments: the current value of [param accum] and the current array element. If [param accum] is [code]null[/code] (as by default), the iteration will start from the second element, with the first one used as initial value of [param accum].
[codeblock]
func sum(accum, number):
    return accum + number

func _ready():
    print([1, 2, 3].reduce(sum, 0))  # Prints 6
    print([1, 2, 3].reduce(sum, 10)) # Prints 16

    # Same as above, but using a lambda function.
    print([1, 2, 3].reduce(func(accum, number): return accum + number, 10))
[/codeblock]
If [method max] is not desirable, this method may also be used to implement a custom comparator:
[codeblock]
func _ready():
    var arr = [Vector2(5, 0), Vector2(3, 4), Vector2(1, 2)]

    var longest_vec = arr.reduce(func(max, vec): return vec if is_length_greater(vec, max) else max)
    print(longest_vec) # Prints Vector2(3, 4).

func is_length_greater(a, b):
    return a.length() > b.length()
[/codeblock]
See also [method map], [method filter], [method any] and [method all].
*/
//go:nosplit
func (self Array) Reduce(ctx Lifetime, method Callable, accum Variant) Variant {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(method))
	callframe.Arg(frame, mmm.Get(accum))
	var r_ret = callframe.Ret[[3]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Array.reduce(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Calls the given [Callable] on each element in the array and returns [code]true[/code] if the [Callable] returns [code]true[/code] for [i]one or more[/i] elements in the array. If the [Callable] returns [code]false[/code] for all elements in the array, this method returns [code]false[/code].
The [param method] should take one [Variant] parameter (the current array element) and return a [bool].
[codeblock]
func greater_than_5(number):
    return number > 5

func _ready():
    print([6, 10, 6].any(greater_than_5)) # Prints true (3 elements evaluate to true).
    print([4, 10, 4].any(greater_than_5)) # Prints true (1 elements evaluate to true).
    print([4, 4, 4].any(greater_than_5))  # Prints false (0 elements evaluate to true).
    print([].any(greater_than_5))         # Prints false (0 elements evaluate to true).

    # Same as the first line above, but using a lambda function.
    print([6, 10, 6].any(func(number): return number > 5)) # Prints true
[/codeblock]
See also [method all], [method filter], [method map] and [method reduce].
[b]Note:[/b] Unlike relying on the size of an array returned by [method filter], this method will return as early as possible to improve performance (especially with large arrays).
[b]Note:[/b] For an empty array, this method always returns [code]false[/code].
*/
//go:nosplit
func (self Array) Any(method Callable) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(method))
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Array.any(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Calls the given [Callable] on each element in the array and returns [code]true[/code] if the [Callable] returns [code]true[/code] for [i]all[/i] elements in the array. If the [Callable] returns [code]false[/code] for one array element or more, this method returns [code]false[/code].
The [param method] should take one [Variant] parameter (the current array element) and return a [bool].
[codeblocks]
[gdscript]
func greater_than_5(number):
    return number > 5

func _ready():
    print([6, 10, 6].all(greater_than_5)) # Prints true (3/3 elements evaluate to true).
    print([4, 10, 4].all(greater_than_5)) # Prints false (1/3 elements evaluate to true).
    print([4, 4, 4].all(greater_than_5))  # Prints false (0/3 elements evaluate to true).
    print([].all(greater_than_5))         # Prints true (0/0 elements evaluate to true).

    # Same as the first line above, but using a lambda function.
    print([6, 10, 6].all(func(element): return element > 5)) # Prints true
[/gdscript]
[csharp]
private static bool GreaterThan5(int number)
{
    return number > 5;
}

public override void _Ready()
{
    // Prints true (3/3 elements evaluate to true).
    GD.Print(new Godot.Collections.Array>int< { 6, 10, 6 }.All(GreaterThan5));
    // Prints false (1/3 elements evaluate to true).
    GD.Print(new Godot.Collections.Array>int< { 4, 10, 4 }.All(GreaterThan5));
    // Prints false (0/3 elements evaluate to true).
    GD.Print(new Godot.Collections.Array>int< { 4, 4, 4 }.All(GreaterThan5));
    // Prints true (0/0 elements evaluate to true).
    GD.Print(new Godot.Collections.Array>int< { }.All(GreaterThan5));

    // Same as the first line above, but using a lambda function.
    GD.Print(new Godot.Collections.Array>int< { 6, 10, 6 }.All(element => element > 5)); // Prints true
}
[/csharp]
[/codeblocks]
See also [method any], [method filter], [method map] and [method reduce].
[b]Note:[/b] Unlike relying on the size of an array returned by [method filter], this method will return as early as possible to improve performance (especially with large arrays).
[b]Note:[/b] For an empty array, this method [url=https://en.wikipedia.org/wiki/Vacuous_truth]always[/url] returns [code]true[/code].
*/
//go:nosplit
func (self Array) All(method Callable) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(method))
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Array.all(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns the maximum value contained in the array, if all elements can be compared. Otherwise, returns [code]null[/code]. See also [method min].
To find the maximum value using a custom comparator, you can use [method reduce].
*/
//go:nosplit
func (self Array) Max(ctx Lifetime) Variant {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[3]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Array.max(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns the minimum value contained in the array, if all elements can be compared. Otherwise, returns [code]null[/code]. See also [method max].
*/
//go:nosplit
func (self Array) Min(ctx Lifetime) Variant {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[3]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Array.min(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns [code]true[/code] if the array is typed. Typed arrays can only contain elements of a specific type, as defined by the typed array constructor. The methods of a typed array are still expected to return a generic [Variant].
In GDScript, it is possible to define a typed array with static typing:
[codeblock]
var numbers: Array[float] = [0.2, 4.2, -2.0]
print(numbers.is_typed()) # Prints true
[/codeblock]
*/
//go:nosplit
func (self Array) IsTyped() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Array.is_typed(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns [code]true[/code] if this array is typed the same as the given [param array]. See also [method is_typed].
*/
//go:nosplit
func (self Array) IsSameTyped(array Array) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(array))
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Array.is_same_typed(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns the built-in [Variant] type of the typed array as a [enum Variant.Type] constant. If the array is not typed, returns [constant TYPE_NIL]. See also [method is_typed].
*/
//go:nosplit
func (self Array) GetTypedBuiltin() Int {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Array.get_typed_builtin(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns the [b]built-in[/b] class name of the typed array, if the built-in [Variant] type [constant TYPE_OBJECT]. Otherwise, returns an empty [StringName]. See also [method is_typed] and [method Object.get_class].
*/
//go:nosplit
func (self Array) GetTypedClassName(ctx Lifetime) StringName {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Array.get_typed_class_name(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[StringName](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns the [Script] instance associated with this typed array, or [code]null[/code] if it does not exist. See also [method is_typed].
*/
//go:nosplit
func (self Array) GetTypedScript(ctx Lifetime) Variant {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[3]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Array.get_typed_script(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Makes the array read-only. The array's elements cannot be overridden with different values, and their order cannot change. Does not apply to nested elements, such as dictionaries.
In GDScript, arrays are automatically read-only if declared with the [code]const[/code] keyword.
*/
//go:nosplit
func (self Array) MakeReadOnly()  {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Array.make_read_only(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	frame.Free()
}
/*
Returns [code]true[/code] if the array is read-only. See [method make_read_only].
In GDScript, arrays are automatically read-only if declared with the [code]const[/code] keyword.
*/
//go:nosplit
func (self Array) IsReadOnly() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(self).builtin.Array.is_read_only(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns the number of elements in the array.
*/
//go:nosplit
func (self *PackedByteArray) Size() Int {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedByteArray.size(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns [code]true[/code] if the array is empty.
*/
//go:nosplit
func (self *PackedByteArray) IsEmpty() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedByteArray.is_empty(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Changes the byte at the given index.
*/
//go:nosplit
func (self *PackedByteArray) Set(index Int, value Int)  {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, index)
	callframe.Arg(frame, value)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedByteArray.set(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Appends an element at the end of the array.
*/
//go:nosplit
func (self *PackedByteArray) PushBack(value Int) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedByteArray.push_back(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Appends an element at the end of the array (alias of [method push_back]).
*/
//go:nosplit
func (self *PackedByteArray) Append(value Int) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedByteArray.append(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Appends a [PackedByteArray] at the end of this array.
*/
//go:nosplit
func (self *PackedByteArray) AppendArray(array PackedByteArray)  {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(array))
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedByteArray.append_array(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Removes an element from the array by index.
*/
//go:nosplit
func (self *PackedByteArray) RemoveAt(index Int)  {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, index)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedByteArray.remove_at(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Inserts a new element at a given position in the array. The position must be valid, or at the end of the array ([code]idx == size()[/code]).
*/
//go:nosplit
func (self *PackedByteArray) Insert(at_index Int, value Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, at_index)
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedByteArray.insert(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Assigns the given value to all elements in the array. This can typically be used together with [method resize] to create an array with a given size and initialized elements.
*/
//go:nosplit
func (self *PackedByteArray) Fill(value Int)  {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedByteArray.fill(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Sets the size of the array. If the array is grown, reserves elements at the end of the array. If the array is shrunk, truncates the array to the new size. Calling [method resize] once and assigning the new values is faster than adding new elements one by one.
*/
//go:nosplit
func (self *PackedByteArray) Resize(new_size Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, new_size)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedByteArray.resize(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Clears the array. This is equivalent to using [method resize] with a size of [code]0[/code].
*/
//go:nosplit
func (self *PackedByteArray) Clear()  {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedByteArray.clear(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Returns [code]true[/code] if the array contains [param value].
*/
//go:nosplit
func (self *PackedByteArray) Has(value Int) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedByteArray.has(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Reverses the order of the elements in the array.
*/
//go:nosplit
func (self *PackedByteArray) Reverse()  {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedByteArray.reverse(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Returns the slice of the [PackedByteArray], from [param begin] (inclusive) to [param end] (exclusive), as a new [PackedByteArray].
The absolute value of [param begin] and [param end] will be clamped to the array size, so the default value for [param end] makes it slice to the size of the array by default (i.e. [code]arr.slice(1)[/code] is a shorthand for [code]arr.slice(1, arr.size())[/code]).
If either [param begin] or [param end] are negative, they will be relative to the end of the array (i.e. [code]arr.slice(0, -2)[/code] is a shorthand for [code]arr.slice(0, arr.size() - 2)[/code]).
*/
//go:nosplit
func (self *PackedByteArray) Slice(ctx Lifetime, begin Int, end Int) PackedByteArray {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, begin)
	callframe.Arg(frame, end)
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedByteArray.slice(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	var ret = mmm.New[PackedByteArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Sorts the elements of the array in ascending order.
*/
//go:nosplit
func (self *PackedByteArray) Sort()  {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedByteArray.sort(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Finds the index of an existing value (or the insertion index that maintains sorting order, if the value is not yet present in the array) using binary search. Optionally, a [param before] specifier can be passed. If [code]false[/code], the returned index comes after all existing entries of the value in the array.
[b]Note:[/b] Calling [method bsearch] on an unsorted array results in unexpected behavior.
*/
//go:nosplit
func (self *PackedByteArray) Bsearch(value Int, before bool) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	callframe.Arg(frame, before)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedByteArray.bsearch(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Creates a copy of the array, and returns it.
*/
//go:nosplit
func (self *PackedByteArray) Duplicate(ctx Lifetime) PackedByteArray {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedByteArray.duplicate(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	var ret = mmm.New[PackedByteArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Searches the array for a value and returns its index or [code]-1[/code] if not found. Optionally, the initial search index can be passed.
*/
//go:nosplit
func (self *PackedByteArray) Find(value Int, from Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	callframe.Arg(frame, from)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedByteArray.find(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Searches the array in reverse order. Optionally, a start search index can be passed. If negative, the start index is considered relative to the end of the array.
*/
//go:nosplit
func (self *PackedByteArray) Rfind(value Int, from Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	callframe.Arg(frame, from)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedByteArray.rfind(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns the number of times an element is in the array.
*/
//go:nosplit
func (self *PackedByteArray) Count(value Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedByteArray.count(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Converts ASCII/Latin-1 encoded array to [String]. Fast alternative to [method get_string_from_utf8] if the content is ASCII/Latin-1 only. Unlike the UTF-8 function this function maps every byte to a character in the array. Multibyte sequences will not be interpreted correctly. For parsing user input always use [method get_string_from_utf8]. This is the inverse of [method String.to_ascii_buffer].
*/
//go:nosplit
func (self *PackedByteArray) GetStringFromAscii(ctx Lifetime) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedByteArray.get_string_from_ascii(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Converts UTF-8 encoded array to [String]. Slower than [method get_string_from_ascii] but supports UTF-8 encoded data. Use this function if you are unsure about the source of the data. For user input this function should always be preferred. Returns empty string if source array is not valid UTF-8 string. This is the inverse of [method String.to_utf8_buffer].
*/
//go:nosplit
func (self *PackedByteArray) GetStringFromUtf8(ctx Lifetime) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedByteArray.get_string_from_utf8(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Converts UTF-16 encoded array to [String]. If the BOM is missing, system endianness is assumed. Returns empty string if source array is not valid UTF-16 string. This is the inverse of [method String.to_utf16_buffer].
*/
//go:nosplit
func (self *PackedByteArray) GetStringFromUtf16(ctx Lifetime) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedByteArray.get_string_from_utf16(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Converts UTF-32 encoded array to [String]. System endianness is assumed. Returns empty string if source array is not valid UTF-32 string. This is the inverse of [method String.to_utf32_buffer].
*/
//go:nosplit
func (self *PackedByteArray) GetStringFromUtf32(ctx Lifetime) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedByteArray.get_string_from_utf32(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Converts wide character ([code]wchar_t[/code], UTF-16 on Windows, UTF-32 on other platforms) encoded array to [String]. Returns empty string if source array is not valid wide string. This is the inverse of [method String.to_wchar_buffer].
*/
//go:nosplit
func (self *PackedByteArray) GetStringFromWchar(ctx Lifetime) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedByteArray.get_string_from_wchar(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns a hexadecimal representation of this array as a [String].
[codeblocks]
[gdscript]
var array = PackedByteArray([11, 46, 255])
print(array.hex_encode()) # Prints: 0b2eff
[/gdscript]
[csharp]
var array = new byte[] {11, 46, 255};
GD.Print(array.HexEncode()); // Prints: 0b2eff
[/csharp]
[/codeblocks]
*/
//go:nosplit
func (self *PackedByteArray) HexEncode(ctx Lifetime) String {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedByteArray.hex_encode(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns a new [PackedByteArray] with the data compressed. Set the compression mode using one of [enum FileAccess.CompressionMode]'s constants.
*/
//go:nosplit
func (self *PackedByteArray) Compress(ctx Lifetime, compression_mode Int) PackedByteArray {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, compression_mode)
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedByteArray.compress(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	var ret = mmm.New[PackedByteArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns a new [PackedByteArray] with the data decompressed. Set [param buffer_size] to the size of the uncompressed data. Set the compression mode using one of [enum FileAccess.CompressionMode]'s constants.
[b]Note:[/b] Decompression is not guaranteed to work with data not compressed by Godot, for example if data compressed with the deflate compression mode lacks a checksum or header.
*/
//go:nosplit
func (self *PackedByteArray) Decompress(ctx Lifetime, buffer_size Int, compression_mode Int) PackedByteArray {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, buffer_size)
	callframe.Arg(frame, compression_mode)
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedByteArray.decompress(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	var ret = mmm.New[PackedByteArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns a new [PackedByteArray] with the data decompressed. Set the compression mode using one of [enum FileAccess.CompressionMode]'s constants. [b]This method only accepts brotli, gzip, and deflate compression modes.[/b]
This method is potentially slower than [method decompress], as it may have to re-allocate its output buffer multiple times while decompressing, whereas [method decompress] knows it's output buffer size from the beginning.
GZIP has a maximal compression ratio of 1032:1, meaning it's very possible for a small compressed payload to decompress to a potentially very large output. To guard against this, you may provide a maximum size this function is allowed to allocate in bytes via [param max_output_size]. Passing -1 will allow for unbounded output. If any positive value is passed, and the decompression exceeds that amount in bytes, then an error will be returned.
[b]Note:[/b] Decompression is not guaranteed to work with data not compressed by Godot, for example if data compressed with the deflate compression mode lacks a checksum or header.
*/
//go:nosplit
func (self *PackedByteArray) DecompressDynamic(ctx Lifetime, max_output_size Int, compression_mode Int) PackedByteArray {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, max_output_size)
	callframe.Arg(frame, compression_mode)
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedByteArray.decompress_dynamic(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	var ret = mmm.New[PackedByteArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Decodes a 8-bit unsigned integer number from the bytes starting at [param byte_offset]. Fails if the byte count is insufficient. Returns [code]0[/code] if a valid number can't be decoded.
*/
//go:nosplit
func (self *PackedByteArray) DecodeU8(byte_offset Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, byte_offset)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedByteArray.decode_u8(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Decodes a 8-bit signed integer number from the bytes starting at [param byte_offset]. Fails if the byte count is insufficient. Returns [code]0[/code] if a valid number can't be decoded.
*/
//go:nosplit
func (self *PackedByteArray) DecodeS8(byte_offset Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, byte_offset)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedByteArray.decode_s8(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Decodes a 16-bit unsigned integer number from the bytes starting at [param byte_offset]. Fails if the byte count is insufficient. Returns [code]0[/code] if a valid number can't be decoded.
*/
//go:nosplit
func (self *PackedByteArray) DecodeU16(byte_offset Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, byte_offset)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedByteArray.decode_u16(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Decodes a 16-bit signed integer number from the bytes starting at [param byte_offset]. Fails if the byte count is insufficient. Returns [code]0[/code] if a valid number can't be decoded.
*/
//go:nosplit
func (self *PackedByteArray) DecodeS16(byte_offset Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, byte_offset)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedByteArray.decode_s16(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Decodes a 32-bit unsigned integer number from the bytes starting at [param byte_offset]. Fails if the byte count is insufficient. Returns [code]0[/code] if a valid number can't be decoded.
*/
//go:nosplit
func (self *PackedByteArray) DecodeU32(byte_offset Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, byte_offset)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedByteArray.decode_u32(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Decodes a 32-bit signed integer number from the bytes starting at [param byte_offset]. Fails if the byte count is insufficient. Returns [code]0[/code] if a valid number can't be decoded.
*/
//go:nosplit
func (self *PackedByteArray) DecodeS32(byte_offset Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, byte_offset)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedByteArray.decode_s32(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Decodes a 64-bit unsigned integer number from the bytes starting at [param byte_offset]. Fails if the byte count is insufficient. Returns [code]0[/code] if a valid number can't be decoded.
*/
//go:nosplit
func (self *PackedByteArray) DecodeU64(byte_offset Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, byte_offset)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedByteArray.decode_u64(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Decodes a 64-bit signed integer number from the bytes starting at [param byte_offset]. Fails if the byte count is insufficient. Returns [code]0[/code] if a valid number can't be decoded.
*/
//go:nosplit
func (self *PackedByteArray) DecodeS64(byte_offset Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, byte_offset)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedByteArray.decode_s64(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Decodes a 16-bit floating-point number from the bytes starting at [param byte_offset]. Fails if the byte count is insufficient. Returns [code]0.0[/code] if a valid number can't be decoded.
*/
//go:nosplit
func (self *PackedByteArray) DecodeHalf(byte_offset Int) Float {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, byte_offset)
	var r_ret = callframe.Ret[Float](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedByteArray.decode_half(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Decodes a 32-bit floating-point number from the bytes starting at [param byte_offset]. Fails if the byte count is insufficient. Returns [code]0.0[/code] if a valid number can't be decoded.
*/
//go:nosplit
func (self *PackedByteArray) DecodeFloat(byte_offset Int) Float {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, byte_offset)
	var r_ret = callframe.Ret[Float](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedByteArray.decode_float(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Decodes a 64-bit floating-point number from the bytes starting at [param byte_offset]. Fails if the byte count is insufficient. Returns [code]0.0[/code] if a valid number can't be decoded.
*/
//go:nosplit
func (self *PackedByteArray) DecodeDouble(byte_offset Int) Float {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, byte_offset)
	var r_ret = callframe.Ret[Float](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedByteArray.decode_double(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns [code]true[/code] if a valid [Variant] value can be decoded at the [param byte_offset]. Returns [code]false[/code] otherwise or when the value is [Object]-derived and [param allow_objects] is [code]false[/code].
*/
//go:nosplit
func (self *PackedByteArray) HasEncodedVar(byte_offset Int, allow_objects bool) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, byte_offset)
	callframe.Arg(frame, allow_objects)
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedByteArray.has_encoded_var(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Decodes a [Variant] from the bytes starting at [param byte_offset]. Returns [code]null[/code] if a valid variant can't be decoded or the value is [Object]-derived and [param allow_objects] is [code]false[/code].
*/
//go:nosplit
func (self *PackedByteArray) DecodeVar(ctx Lifetime, byte_offset Int, allow_objects bool) Variant {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, byte_offset)
	callframe.Arg(frame, allow_objects)
	var r_ret = callframe.Ret[[3]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedByteArray.decode_var(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Decodes a size of a [Variant] from the bytes starting at [param byte_offset]. Requires at least 4 bytes of data starting at the offset, otherwise fails.
*/
//go:nosplit
func (self *PackedByteArray) DecodeVarSize(byte_offset Int, allow_objects bool) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, byte_offset)
	callframe.Arg(frame, allow_objects)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedByteArray.decode_var_size(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns a copy of the data converted to a [PackedInt32Array], where each block of 4 bytes has been converted to a signed 32-bit integer (C++ [code]int32_t[/code]).
The size of the input array must be a multiple of 4 (size of 32-bit integer). The size of the new array will be [code]byte_array.size() / 4[/code].
If the original data can't be converted to signed 32-bit integers, the resulting data is undefined.
*/
//go:nosplit
func (self *PackedByteArray) ToInt32Array(ctx Lifetime) PackedInt32Array {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedByteArray.to_int32_array(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	var ret = mmm.New[PackedInt32Array](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns a copy of the data converted to a [PackedInt64Array], where each block of 8 bytes has been converted to a signed 64-bit integer (C++ [code]int64_t[/code], Godot [int]).
The size of the input array must be a multiple of 8 (size of 64-bit integer). The size of the new array will be [code]byte_array.size() / 8[/code].
If the original data can't be converted to signed 64-bit integers, the resulting data is undefined.
*/
//go:nosplit
func (self *PackedByteArray) ToInt64Array(ctx Lifetime) PackedInt64Array {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedByteArray.to_int64_array(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	var ret = mmm.New[PackedInt64Array](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns a copy of the data converted to a [PackedFloat32Array], where each block of 4 bytes has been converted to a 32-bit float (C++ [code skip-lint]float[/code]).
The size of the input array must be a multiple of 4 (size of 32-bit float). The size of the new array will be [code]byte_array.size() / 4[/code].
If the original data can't be converted to 32-bit floats, the resulting data is undefined.
*/
//go:nosplit
func (self *PackedByteArray) ToFloat32Array(ctx Lifetime) PackedFloat32Array {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedByteArray.to_float32_array(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	var ret = mmm.New[PackedFloat32Array](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns a copy of the data converted to a [PackedFloat64Array], where each block of 8 bytes has been converted to a 64-bit float (C++ [code]double[/code], Godot [float]).
The size of the input array must be a multiple of 8 (size of 64-bit double). The size of the new array will be [code]byte_array.size() / 8[/code].
If the original data can't be converted to 64-bit floats, the resulting data is undefined.
*/
//go:nosplit
func (self *PackedByteArray) ToFloat64Array(ctx Lifetime) PackedFloat64Array {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedByteArray.to_float64_array(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	var ret = mmm.New[PackedFloat64Array](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Encodes a 8-bit unsigned integer number (byte) at the index of [param byte_offset] bytes. The array must have at least 1 byte of space, starting at the offset.
*/
//go:nosplit
func (self *PackedByteArray) EncodeU8(byte_offset Int, value Int)  {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, byte_offset)
	callframe.Arg(frame, value)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedByteArray.encode_u8(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Encodes a 8-bit signed integer number (signed byte) at the index of [param byte_offset] bytes. The array must have at least 1 byte of space, starting at the offset.
*/
//go:nosplit
func (self *PackedByteArray) EncodeS8(byte_offset Int, value Int)  {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, byte_offset)
	callframe.Arg(frame, value)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedByteArray.encode_s8(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Encodes a 16-bit unsigned integer number as bytes at the index of [param byte_offset] bytes. The array must have at least 2 bytes of space, starting at the offset.
*/
//go:nosplit
func (self *PackedByteArray) EncodeU16(byte_offset Int, value Int)  {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, byte_offset)
	callframe.Arg(frame, value)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedByteArray.encode_u16(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Encodes a 16-bit signed integer number as bytes at the index of [param byte_offset] bytes. The array must have at least 2 bytes of space, starting at the offset.
*/
//go:nosplit
func (self *PackedByteArray) EncodeS16(byte_offset Int, value Int)  {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, byte_offset)
	callframe.Arg(frame, value)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedByteArray.encode_s16(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Encodes a 32-bit unsigned integer number as bytes at the index of [param byte_offset] bytes. The array must have at least 4 bytes of space, starting at the offset.
*/
//go:nosplit
func (self *PackedByteArray) EncodeU32(byte_offset Int, value Int)  {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, byte_offset)
	callframe.Arg(frame, value)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedByteArray.encode_u32(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Encodes a 32-bit signed integer number as bytes at the index of [param byte_offset] bytes. The array must have at least 4 bytes of space, starting at the offset.
*/
//go:nosplit
func (self *PackedByteArray) EncodeS32(byte_offset Int, value Int)  {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, byte_offset)
	callframe.Arg(frame, value)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedByteArray.encode_s32(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Encodes a 64-bit unsigned integer number as bytes at the index of [param byte_offset] bytes. The array must have at least 8 bytes of space, starting at the offset.
*/
//go:nosplit
func (self *PackedByteArray) EncodeU64(byte_offset Int, value Int)  {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, byte_offset)
	callframe.Arg(frame, value)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedByteArray.encode_u64(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Encodes a 64-bit signed integer number as bytes at the index of [param byte_offset] bytes. The array must have at least 8 bytes of space, starting at the offset.
*/
//go:nosplit
func (self *PackedByteArray) EncodeS64(byte_offset Int, value Int)  {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, byte_offset)
	callframe.Arg(frame, value)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedByteArray.encode_s64(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Encodes a 16-bit floating-point number as bytes at the index of [param byte_offset] bytes. The array must have at least 2 bytes of space, starting at the offset.
*/
//go:nosplit
func (self *PackedByteArray) EncodeHalf(byte_offset Int, value Float)  {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, byte_offset)
	callframe.Arg(frame, value)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedByteArray.encode_half(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Encodes a 32-bit floating-point number as bytes at the index of [param byte_offset] bytes. The array must have at least 4 bytes of space, starting at the offset.
*/
//go:nosplit
func (self *PackedByteArray) EncodeFloat(byte_offset Int, value Float)  {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, byte_offset)
	callframe.Arg(frame, value)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedByteArray.encode_float(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Encodes a 64-bit floating-point number as bytes at the index of [param byte_offset] bytes. The array must have at least 8 bytes of allocated space, starting at the offset.
*/
//go:nosplit
func (self *PackedByteArray) EncodeDouble(byte_offset Int, value Float)  {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, byte_offset)
	callframe.Arg(frame, value)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedByteArray.encode_double(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Encodes a [Variant] at the index of [param byte_offset] bytes. A sufficient space must be allocated, depending on the encoded variant's size. If [param allow_objects] is [code]false[/code], [Object]-derived values are not permitted and will instead be serialized as ID-only.
*/
//go:nosplit
func (self *PackedByteArray) EncodeVar(byte_offset Int, value Variant, allow_objects bool) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, byte_offset)
	callframe.Arg(frame, mmm.Get(value))
	callframe.Arg(frame, allow_objects)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedByteArray.encode_var(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 3)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns the number of elements in the array.
*/
//go:nosplit
func (self *PackedInt32Array) Size() Int {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedInt32Array.size(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns [code]true[/code] if the array is empty.
*/
//go:nosplit
func (self *PackedInt32Array) IsEmpty() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedInt32Array.is_empty(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Changes the integer at the given index.
*/
//go:nosplit
func (self *PackedInt32Array) Set(index Int, value Int)  {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, index)
	callframe.Arg(frame, value)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedInt32Array.set(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Appends a value to the array.
*/
//go:nosplit
func (self *PackedInt32Array) PushBack(value Int) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedInt32Array.push_back(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Appends an element at the end of the array (alias of [method push_back]).
*/
//go:nosplit
func (self *PackedInt32Array) Append(value Int) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedInt32Array.append(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Appends a [PackedInt32Array] at the end of this array.
*/
//go:nosplit
func (self *PackedInt32Array) AppendArray(array PackedInt32Array)  {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(array))
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedInt32Array.append_array(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Removes an element from the array by index.
*/
//go:nosplit
func (self *PackedInt32Array) RemoveAt(index Int)  {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, index)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedInt32Array.remove_at(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Inserts a new integer at a given position in the array. The position must be valid, or at the end of the array ([code]idx == size()[/code]).
*/
//go:nosplit
func (self *PackedInt32Array) Insert(at_index Int, value Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, at_index)
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedInt32Array.insert(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Assigns the given value to all elements in the array. This can typically be used together with [method resize] to create an array with a given size and initialized elements.
*/
//go:nosplit
func (self *PackedInt32Array) Fill(value Int)  {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedInt32Array.fill(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Sets the size of the array. If the array is grown, reserves elements at the end of the array. If the array is shrunk, truncates the array to the new size. Calling [method resize] once and assigning the new values is faster than adding new elements one by one.
*/
//go:nosplit
func (self *PackedInt32Array) Resize(new_size Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, new_size)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedInt32Array.resize(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Clears the array. This is equivalent to using [method resize] with a size of [code]0[/code].
*/
//go:nosplit
func (self *PackedInt32Array) Clear()  {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedInt32Array.clear(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Returns [code]true[/code] if the array contains [param value].
*/
//go:nosplit
func (self *PackedInt32Array) Has(value Int) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedInt32Array.has(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Reverses the order of the elements in the array.
*/
//go:nosplit
func (self *PackedInt32Array) Reverse()  {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedInt32Array.reverse(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Returns the slice of the [PackedInt32Array], from [param begin] (inclusive) to [param end] (exclusive), as a new [PackedInt32Array].
The absolute value of [param begin] and [param end] will be clamped to the array size, so the default value for [param end] makes it slice to the size of the array by default (i.e. [code]arr.slice(1)[/code] is a shorthand for [code]arr.slice(1, arr.size())[/code]).
If either [param begin] or [param end] are negative, they will be relative to the end of the array (i.e. [code]arr.slice(0, -2)[/code] is a shorthand for [code]arr.slice(0, arr.size() - 2)[/code]).
*/
//go:nosplit
func (self *PackedInt32Array) Slice(ctx Lifetime, begin Int, end Int) PackedInt32Array {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, begin)
	callframe.Arg(frame, end)
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedInt32Array.slice(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	var ret = mmm.New[PackedInt32Array](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns a copy of the data converted to a [PackedByteArray], where each element have been encoded as 4 bytes.
The size of the new array will be [code]int32_array.size() * 4[/code].
*/
//go:nosplit
func (self *PackedInt32Array) ToByteArray(ctx Lifetime) PackedByteArray {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedInt32Array.to_byte_array(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	var ret = mmm.New[PackedByteArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Sorts the elements of the array in ascending order.
*/
//go:nosplit
func (self *PackedInt32Array) Sort()  {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedInt32Array.sort(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Finds the index of an existing value (or the insertion index that maintains sorting order, if the value is not yet present in the array) using binary search. Optionally, a [param before] specifier can be passed. If [code]false[/code], the returned index comes after all existing entries of the value in the array.
[b]Note:[/b] Calling [method bsearch] on an unsorted array results in unexpected behavior.
*/
//go:nosplit
func (self *PackedInt32Array) Bsearch(value Int, before bool) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	callframe.Arg(frame, before)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedInt32Array.bsearch(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Creates a copy of the array, and returns it.
*/
//go:nosplit
func (self *PackedInt32Array) Duplicate(ctx Lifetime) PackedInt32Array {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedInt32Array.duplicate(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	var ret = mmm.New[PackedInt32Array](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Searches the array for a value and returns its index or [code]-1[/code] if not found. Optionally, the initial search index can be passed.
*/
//go:nosplit
func (self *PackedInt32Array) Find(value Int, from Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	callframe.Arg(frame, from)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedInt32Array.find(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Searches the array in reverse order. Optionally, a start search index can be passed. If negative, the start index is considered relative to the end of the array.
*/
//go:nosplit
func (self *PackedInt32Array) Rfind(value Int, from Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	callframe.Arg(frame, from)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedInt32Array.rfind(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns the number of times an element is in the array.
*/
//go:nosplit
func (self *PackedInt32Array) Count(value Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedInt32Array.count(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns the number of elements in the array.
*/
//go:nosplit
func (self *PackedInt64Array) Size() Int {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedInt64Array.size(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns [code]true[/code] if the array is empty.
*/
//go:nosplit
func (self *PackedInt64Array) IsEmpty() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedInt64Array.is_empty(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Changes the integer at the given index.
*/
//go:nosplit
func (self *PackedInt64Array) Set(index Int, value Int)  {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, index)
	callframe.Arg(frame, value)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedInt64Array.set(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Appends a value to the array.
*/
//go:nosplit
func (self *PackedInt64Array) PushBack(value Int) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedInt64Array.push_back(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Appends an element at the end of the array (alias of [method push_back]).
*/
//go:nosplit
func (self *PackedInt64Array) Append(value Int) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedInt64Array.append(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Appends a [PackedInt64Array] at the end of this array.
*/
//go:nosplit
func (self *PackedInt64Array) AppendArray(array PackedInt64Array)  {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(array))
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedInt64Array.append_array(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Removes an element from the array by index.
*/
//go:nosplit
func (self *PackedInt64Array) RemoveAt(index Int)  {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, index)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedInt64Array.remove_at(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Inserts a new integer at a given position in the array. The position must be valid, or at the end of the array ([code]idx == size()[/code]).
*/
//go:nosplit
func (self *PackedInt64Array) Insert(at_index Int, value Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, at_index)
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedInt64Array.insert(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Assigns the given value to all elements in the array. This can typically be used together with [method resize] to create an array with a given size and initialized elements.
*/
//go:nosplit
func (self *PackedInt64Array) Fill(value Int)  {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedInt64Array.fill(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Sets the size of the array. If the array is grown, reserves elements at the end of the array. If the array is shrunk, truncates the array to the new size. Calling [method resize] once and assigning the new values is faster than adding new elements one by one.
*/
//go:nosplit
func (self *PackedInt64Array) Resize(new_size Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, new_size)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedInt64Array.resize(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Clears the array. This is equivalent to using [method resize] with a size of [code]0[/code].
*/
//go:nosplit
func (self *PackedInt64Array) Clear()  {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedInt64Array.clear(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Returns [code]true[/code] if the array contains [param value].
*/
//go:nosplit
func (self *PackedInt64Array) Has(value Int) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedInt64Array.has(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Reverses the order of the elements in the array.
*/
//go:nosplit
func (self *PackedInt64Array) Reverse()  {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedInt64Array.reverse(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Returns the slice of the [PackedInt64Array], from [param begin] (inclusive) to [param end] (exclusive), as a new [PackedInt64Array].
The absolute value of [param begin] and [param end] will be clamped to the array size, so the default value for [param end] makes it slice to the size of the array by default (i.e. [code]arr.slice(1)[/code] is a shorthand for [code]arr.slice(1, arr.size())[/code]).
If either [param begin] or [param end] are negative, they will be relative to the end of the array (i.e. [code]arr.slice(0, -2)[/code] is a shorthand for [code]arr.slice(0, arr.size() - 2)[/code]).
*/
//go:nosplit
func (self *PackedInt64Array) Slice(ctx Lifetime, begin Int, end Int) PackedInt64Array {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, begin)
	callframe.Arg(frame, end)
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedInt64Array.slice(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	var ret = mmm.New[PackedInt64Array](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns a copy of the data converted to a [PackedByteArray], where each element have been encoded as 8 bytes.
The size of the new array will be [code]int64_array.size() * 8[/code].
*/
//go:nosplit
func (self *PackedInt64Array) ToByteArray(ctx Lifetime) PackedByteArray {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedInt64Array.to_byte_array(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	var ret = mmm.New[PackedByteArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Sorts the elements of the array in ascending order.
*/
//go:nosplit
func (self *PackedInt64Array) Sort()  {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedInt64Array.sort(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Finds the index of an existing value (or the insertion index that maintains sorting order, if the value is not yet present in the array) using binary search. Optionally, a [param before] specifier can be passed. If [code]false[/code], the returned index comes after all existing entries of the value in the array.
[b]Note:[/b] Calling [method bsearch] on an unsorted array results in unexpected behavior.
*/
//go:nosplit
func (self *PackedInt64Array) Bsearch(value Int, before bool) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	callframe.Arg(frame, before)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedInt64Array.bsearch(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Creates a copy of the array, and returns it.
*/
//go:nosplit
func (self *PackedInt64Array) Duplicate(ctx Lifetime) PackedInt64Array {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedInt64Array.duplicate(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	var ret = mmm.New[PackedInt64Array](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Searches the array for a value and returns its index or [code]-1[/code] if not found. Optionally, the initial search index can be passed.
*/
//go:nosplit
func (self *PackedInt64Array) Find(value Int, from Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	callframe.Arg(frame, from)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedInt64Array.find(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Searches the array in reverse order. Optionally, a start search index can be passed. If negative, the start index is considered relative to the end of the array.
*/
//go:nosplit
func (self *PackedInt64Array) Rfind(value Int, from Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	callframe.Arg(frame, from)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedInt64Array.rfind(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns the number of times an element is in the array.
*/
//go:nosplit
func (self *PackedInt64Array) Count(value Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedInt64Array.count(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns the number of elements in the array.
*/
//go:nosplit
func (self *PackedFloat32Array) Size() Int {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedFloat32Array.size(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns [code]true[/code] if the array is empty.
*/
//go:nosplit
func (self *PackedFloat32Array) IsEmpty() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedFloat32Array.is_empty(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Changes the float at the given index.
*/
//go:nosplit
func (self *PackedFloat32Array) Set(index Int, value Float)  {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, index)
	callframe.Arg(frame, value)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedFloat32Array.set(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Appends an element at the end of the array.
*/
//go:nosplit
func (self *PackedFloat32Array) PushBack(value Float) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedFloat32Array.push_back(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Appends an element at the end of the array (alias of [method push_back]).
*/
//go:nosplit
func (self *PackedFloat32Array) Append(value Float) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedFloat32Array.append(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Appends a [PackedFloat32Array] at the end of this array.
*/
//go:nosplit
func (self *PackedFloat32Array) AppendArray(array PackedFloat32Array)  {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(array))
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedFloat32Array.append_array(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Removes an element from the array by index.
*/
//go:nosplit
func (self *PackedFloat32Array) RemoveAt(index Int)  {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, index)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedFloat32Array.remove_at(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Inserts a new element at a given position in the array. The position must be valid, or at the end of the array ([code]idx == size()[/code]).
*/
//go:nosplit
func (self *PackedFloat32Array) Insert(at_index Int, value Float) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, at_index)
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedFloat32Array.insert(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Assigns the given value to all elements in the array. This can typically be used together with [method resize] to create an array with a given size and initialized elements.
*/
//go:nosplit
func (self *PackedFloat32Array) Fill(value Float)  {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedFloat32Array.fill(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Sets the size of the array. If the array is grown, reserves elements at the end of the array. If the array is shrunk, truncates the array to the new size. Calling [method resize] once and assigning the new values is faster than adding new elements one by one.
*/
//go:nosplit
func (self *PackedFloat32Array) Resize(new_size Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, new_size)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedFloat32Array.resize(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Clears the array. This is equivalent to using [method resize] with a size of [code]0[/code].
*/
//go:nosplit
func (self *PackedFloat32Array) Clear()  {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedFloat32Array.clear(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Returns [code]true[/code] if the array contains [param value].
[b]Note:[/b] [constant @GDScript.NAN] doesn't behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included.
*/
//go:nosplit
func (self *PackedFloat32Array) Has(value Float) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedFloat32Array.has(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Reverses the order of the elements in the array.
*/
//go:nosplit
func (self *PackedFloat32Array) Reverse()  {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedFloat32Array.reverse(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Returns the slice of the [PackedFloat32Array], from [param begin] (inclusive) to [param end] (exclusive), as a new [PackedFloat32Array].
The absolute value of [param begin] and [param end] will be clamped to the array size, so the default value for [param end] makes it slice to the size of the array by default (i.e. [code]arr.slice(1)[/code] is a shorthand for [code]arr.slice(1, arr.size())[/code]).
If either [param begin] or [param end] are negative, they will be relative to the end of the array (i.e. [code]arr.slice(0, -2)[/code] is a shorthand for [code]arr.slice(0, arr.size() - 2)[/code]).
*/
//go:nosplit
func (self *PackedFloat32Array) Slice(ctx Lifetime, begin Int, end Int) PackedFloat32Array {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, begin)
	callframe.Arg(frame, end)
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedFloat32Array.slice(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	var ret = mmm.New[PackedFloat32Array](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns a copy of the data converted to a [PackedByteArray], where each element have been encoded as 4 bytes.
The size of the new array will be [code]float32_array.size() * 4[/code].
*/
//go:nosplit
func (self *PackedFloat32Array) ToByteArray(ctx Lifetime) PackedByteArray {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedFloat32Array.to_byte_array(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	var ret = mmm.New[PackedByteArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Sorts the elements of the array in ascending order.
[b]Note:[/b] [constant @GDScript.NAN] doesn't behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included.
*/
//go:nosplit
func (self *PackedFloat32Array) Sort()  {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedFloat32Array.sort(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Finds the index of an existing value (or the insertion index that maintains sorting order, if the value is not yet present in the array) using binary search. Optionally, a [param before] specifier can be passed. If [code]false[/code], the returned index comes after all existing entries of the value in the array.
[b]Note:[/b] Calling [method bsearch] on an unsorted array results in unexpected behavior.
[b]Note:[/b] [constant @GDScript.NAN] doesn't behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included.
*/
//go:nosplit
func (self *PackedFloat32Array) Bsearch(value Float, before bool) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	callframe.Arg(frame, before)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedFloat32Array.bsearch(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Creates a copy of the array, and returns it.
*/
//go:nosplit
func (self *PackedFloat32Array) Duplicate(ctx Lifetime) PackedFloat32Array {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedFloat32Array.duplicate(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	var ret = mmm.New[PackedFloat32Array](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Searches the array for a value and returns its index or [code]-1[/code] if not found. Optionally, the initial search index can be passed.
[b]Note:[/b] [constant @GDScript.NAN] doesn't behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included.
*/
//go:nosplit
func (self *PackedFloat32Array) Find(value Float, from Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	callframe.Arg(frame, from)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedFloat32Array.find(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Searches the array in reverse order. Optionally, a start search index can be passed. If negative, the start index is considered relative to the end of the array.
[b]Note:[/b] [constant @GDScript.NAN] doesn't behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included.
*/
//go:nosplit
func (self *PackedFloat32Array) Rfind(value Float, from Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	callframe.Arg(frame, from)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedFloat32Array.rfind(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns the number of times an element is in the array.
[b]Note:[/b] [constant @GDScript.NAN] doesn't behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included.
*/
//go:nosplit
func (self *PackedFloat32Array) Count(value Float) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedFloat32Array.count(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns the number of elements in the array.
*/
//go:nosplit
func (self *PackedFloat64Array) Size() Int {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedFloat64Array.size(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns [code]true[/code] if the array is empty.
*/
//go:nosplit
func (self *PackedFloat64Array) IsEmpty() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedFloat64Array.is_empty(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Changes the float at the given index.
*/
//go:nosplit
func (self *PackedFloat64Array) Set(index Int, value Float)  {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, index)
	callframe.Arg(frame, value)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedFloat64Array.set(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Appends an element at the end of the array.
*/
//go:nosplit
func (self *PackedFloat64Array) PushBack(value Float) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedFloat64Array.push_back(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Appends an element at the end of the array (alias of [method push_back]).
*/
//go:nosplit
func (self *PackedFloat64Array) Append(value Float) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedFloat64Array.append(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Appends a [PackedFloat64Array] at the end of this array.
*/
//go:nosplit
func (self *PackedFloat64Array) AppendArray(array PackedFloat64Array)  {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(array))
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedFloat64Array.append_array(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Removes an element from the array by index.
*/
//go:nosplit
func (self *PackedFloat64Array) RemoveAt(index Int)  {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, index)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedFloat64Array.remove_at(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Inserts a new element at a given position in the array. The position must be valid, or at the end of the array ([code]idx == size()[/code]).
*/
//go:nosplit
func (self *PackedFloat64Array) Insert(at_index Int, value Float) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, at_index)
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedFloat64Array.insert(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Assigns the given value to all elements in the array. This can typically be used together with [method resize] to create an array with a given size and initialized elements.
*/
//go:nosplit
func (self *PackedFloat64Array) Fill(value Float)  {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedFloat64Array.fill(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Sets the size of the array. If the array is grown, reserves elements at the end of the array. If the array is shrunk, truncates the array to the new size. Calling [method resize] once and assigning the new values is faster than adding new elements one by one.
*/
//go:nosplit
func (self *PackedFloat64Array) Resize(new_size Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, new_size)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedFloat64Array.resize(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Clears the array. This is equivalent to using [method resize] with a size of [code]0[/code].
*/
//go:nosplit
func (self *PackedFloat64Array) Clear()  {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedFloat64Array.clear(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Returns [code]true[/code] if the array contains [param value].
[b]Note:[/b] [constant @GDScript.NAN] doesn't behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included.
*/
//go:nosplit
func (self *PackedFloat64Array) Has(value Float) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedFloat64Array.has(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Reverses the order of the elements in the array.
*/
//go:nosplit
func (self *PackedFloat64Array) Reverse()  {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedFloat64Array.reverse(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Returns the slice of the [PackedFloat64Array], from [param begin] (inclusive) to [param end] (exclusive), as a new [PackedFloat64Array].
The absolute value of [param begin] and [param end] will be clamped to the array size, so the default value for [param end] makes it slice to the size of the array by default (i.e. [code]arr.slice(1)[/code] is a shorthand for [code]arr.slice(1, arr.size())[/code]).
If either [param begin] or [param end] are negative, they will be relative to the end of the array (i.e. [code]arr.slice(0, -2)[/code] is a shorthand for [code]arr.slice(0, arr.size() - 2)[/code]).
*/
//go:nosplit
func (self *PackedFloat64Array) Slice(ctx Lifetime, begin Int, end Int) PackedFloat64Array {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, begin)
	callframe.Arg(frame, end)
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedFloat64Array.slice(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	var ret = mmm.New[PackedFloat64Array](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns a copy of the data converted to a [PackedByteArray], where each element have been encoded as 8 bytes.
The size of the new array will be [code]float64_array.size() * 8[/code].
*/
//go:nosplit
func (self *PackedFloat64Array) ToByteArray(ctx Lifetime) PackedByteArray {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedFloat64Array.to_byte_array(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	var ret = mmm.New[PackedByteArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Sorts the elements of the array in ascending order.
[b]Note:[/b] [constant @GDScript.NAN] doesn't behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included.
*/
//go:nosplit
func (self *PackedFloat64Array) Sort()  {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedFloat64Array.sort(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Finds the index of an existing value (or the insertion index that maintains sorting order, if the value is not yet present in the array) using binary search. Optionally, a [param before] specifier can be passed. If [code]false[/code], the returned index comes after all existing entries of the value in the array.
[b]Note:[/b] Calling [method bsearch] on an unsorted array results in unexpected behavior.
[b]Note:[/b] [constant @GDScript.NAN] doesn't behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included.
*/
//go:nosplit
func (self *PackedFloat64Array) Bsearch(value Float, before bool) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	callframe.Arg(frame, before)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedFloat64Array.bsearch(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Creates a copy of the array, and returns it.
*/
//go:nosplit
func (self *PackedFloat64Array) Duplicate(ctx Lifetime) PackedFloat64Array {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedFloat64Array.duplicate(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	var ret = mmm.New[PackedFloat64Array](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Searches the array for a value and returns its index or [code]-1[/code] if not found. Optionally, the initial search index can be passed.
[b]Note:[/b] [constant @GDScript.NAN] doesn't behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included.
*/
//go:nosplit
func (self *PackedFloat64Array) Find(value Float, from Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	callframe.Arg(frame, from)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedFloat64Array.find(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Searches the array in reverse order. Optionally, a start search index can be passed. If negative, the start index is considered relative to the end of the array.
[b]Note:[/b] [constant @GDScript.NAN] doesn't behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included.
*/
//go:nosplit
func (self *PackedFloat64Array) Rfind(value Float, from Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	callframe.Arg(frame, from)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedFloat64Array.rfind(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns the number of times an element is in the array.
[b]Note:[/b] [constant @GDScript.NAN] doesn't behave the same as other numbers. Therefore, the results from this method may not be accurate if NaNs are included.
*/
//go:nosplit
func (self *PackedFloat64Array) Count(value Float) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedFloat64Array.count(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns the number of elements in the array.
*/
//go:nosplit
func (self *PackedStringArray) Size() Int {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedStringArray.size(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns [code]true[/code] if the array is empty.
*/
//go:nosplit
func (self *PackedStringArray) IsEmpty() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedStringArray.is_empty(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Changes the [String] at the given index.
*/
//go:nosplit
func (self *PackedStringArray) Set(index Int, value String)  {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, index)
	callframe.Arg(frame, mmm.Get(value))
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedStringArray.set(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Appends a string element at end of the array.
*/
//go:nosplit
func (self *PackedStringArray) PushBack(value String) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(value))
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedStringArray.push_back(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Appends an element at the end of the array (alias of [method push_back]).
*/
//go:nosplit
func (self *PackedStringArray) Append(value String) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(value))
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedStringArray.append(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Appends a [PackedStringArray] at the end of this array.
*/
//go:nosplit
func (self *PackedStringArray) AppendArray(array PackedStringArray)  {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(array))
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedStringArray.append_array(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Removes an element from the array by index.
*/
//go:nosplit
func (self *PackedStringArray) RemoveAt(index Int)  {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, index)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedStringArray.remove_at(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Inserts a new element at a given position in the array. The position must be valid, or at the end of the array ([code]idx == size()[/code]).
*/
//go:nosplit
func (self *PackedStringArray) Insert(at_index Int, value String) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, at_index)
	callframe.Arg(frame, mmm.Get(value))
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedStringArray.insert(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Assigns the given value to all elements in the array. This can typically be used together with [method resize] to create an array with a given size and initialized elements.
*/
//go:nosplit
func (self *PackedStringArray) Fill(value String)  {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(value))
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedStringArray.fill(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Sets the size of the array. If the array is grown, reserves elements at the end of the array. If the array is shrunk, truncates the array to the new size. Calling [method resize] once and assigning the new values is faster than adding new elements one by one.
*/
//go:nosplit
func (self *PackedStringArray) Resize(new_size Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, new_size)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedStringArray.resize(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Clears the array. This is equivalent to using [method resize] with a size of [code]0[/code].
*/
//go:nosplit
func (self *PackedStringArray) Clear()  {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedStringArray.clear(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Returns [code]true[/code] if the array contains [param value].
*/
//go:nosplit
func (self *PackedStringArray) Has(value String) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(value))
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedStringArray.has(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Reverses the order of the elements in the array.
*/
//go:nosplit
func (self *PackedStringArray) Reverse()  {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedStringArray.reverse(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Returns the slice of the [PackedStringArray], from [param begin] (inclusive) to [param end] (exclusive), as a new [PackedStringArray].
The absolute value of [param begin] and [param end] will be clamped to the array size, so the default value for [param end] makes it slice to the size of the array by default (i.e. [code]arr.slice(1)[/code] is a shorthand for [code]arr.slice(1, arr.size())[/code]).
If either [param begin] or [param end] are negative, they will be relative to the end of the array (i.e. [code]arr.slice(0, -2)[/code] is a shorthand for [code]arr.slice(0, arr.size() - 2)[/code]).
*/
//go:nosplit
func (self *PackedStringArray) Slice(ctx Lifetime, begin Int, end Int) PackedStringArray {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, begin)
	callframe.Arg(frame, end)
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedStringArray.slice(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	var ret = mmm.New[PackedStringArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns a [PackedByteArray] with each string encoded as bytes.
*/
//go:nosplit
func (self *PackedStringArray) ToByteArray(ctx Lifetime) PackedByteArray {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedStringArray.to_byte_array(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	var ret = mmm.New[PackedByteArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Sorts the elements of the array in ascending order.
*/
//go:nosplit
func (self *PackedStringArray) Sort()  {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedStringArray.sort(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Finds the index of an existing value (or the insertion index that maintains sorting order, if the value is not yet present in the array) using binary search. Optionally, a [param before] specifier can be passed. If [code]false[/code], the returned index comes after all existing entries of the value in the array.
[b]Note:[/b] Calling [method bsearch] on an unsorted array results in unexpected behavior.
*/
//go:nosplit
func (self *PackedStringArray) Bsearch(value String, before bool) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(value))
	callframe.Arg(frame, before)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedStringArray.bsearch(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Creates a copy of the array, and returns it.
*/
//go:nosplit
func (self *PackedStringArray) Duplicate(ctx Lifetime) PackedStringArray {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedStringArray.duplicate(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	var ret = mmm.New[PackedStringArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Searches the array for a value and returns its index or [code]-1[/code] if not found. Optionally, the initial search index can be passed.
*/
//go:nosplit
func (self *PackedStringArray) Find(value String, from Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(value))
	callframe.Arg(frame, from)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedStringArray.find(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Searches the array in reverse order. Optionally, a start search index can be passed. If negative, the start index is considered relative to the end of the array.
*/
//go:nosplit
func (self *PackedStringArray) Rfind(value String, from Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(value))
	callframe.Arg(frame, from)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedStringArray.rfind(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns the number of times an element is in the array.
*/
//go:nosplit
func (self *PackedStringArray) Count(value String) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(value))
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedStringArray.count(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns the number of elements in the array.
*/
//go:nosplit
func (self *PackedVector2Array) Size() Int {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedVector2Array.size(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns [code]true[/code] if the array is empty.
*/
//go:nosplit
func (self *PackedVector2Array) IsEmpty() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedVector2Array.is_empty(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Changes the [Vector2] at the given index.
*/
//go:nosplit
func (self *PackedVector2Array) Set(index Int, value Vector2)  {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, index)
	callframe.Arg(frame, value)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedVector2Array.set(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Inserts a [Vector2] at the end.
*/
//go:nosplit
func (self *PackedVector2Array) PushBack(value Vector2) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedVector2Array.push_back(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Appends an element at the end of the array (alias of [method push_back]).
*/
//go:nosplit
func (self *PackedVector2Array) Append(value Vector2) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedVector2Array.append(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Appends a [PackedVector2Array] at the end of this array.
*/
//go:nosplit
func (self *PackedVector2Array) AppendArray(array PackedVector2Array)  {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(array))
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedVector2Array.append_array(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Removes an element from the array by index.
*/
//go:nosplit
func (self *PackedVector2Array) RemoveAt(index Int)  {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, index)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedVector2Array.remove_at(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Inserts a new element at a given position in the array. The position must be valid, or at the end of the array ([code]idx == size()[/code]).
*/
//go:nosplit
func (self *PackedVector2Array) Insert(at_index Int, value Vector2) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, at_index)
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedVector2Array.insert(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Assigns the given value to all elements in the array. This can typically be used together with [method resize] to create an array with a given size and initialized elements.
*/
//go:nosplit
func (self *PackedVector2Array) Fill(value Vector2)  {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedVector2Array.fill(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Sets the size of the array. If the array is grown, reserves elements at the end of the array. If the array is shrunk, truncates the array to the new size. Calling [method resize] once and assigning the new values is faster than adding new elements one by one.
*/
//go:nosplit
func (self *PackedVector2Array) Resize(new_size Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, new_size)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedVector2Array.resize(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Clears the array. This is equivalent to using [method resize] with a size of [code]0[/code].
*/
//go:nosplit
func (self *PackedVector2Array) Clear()  {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedVector2Array.clear(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Returns [code]true[/code] if the array contains [param value].
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included.
*/
//go:nosplit
func (self *PackedVector2Array) Has(value Vector2) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedVector2Array.has(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Reverses the order of the elements in the array.
*/
//go:nosplit
func (self *PackedVector2Array) Reverse()  {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedVector2Array.reverse(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Returns the slice of the [PackedVector2Array], from [param begin] (inclusive) to [param end] (exclusive), as a new [PackedVector2Array].
The absolute value of [param begin] and [param end] will be clamped to the array size, so the default value for [param end] makes it slice to the size of the array by default (i.e. [code]arr.slice(1)[/code] is a shorthand for [code]arr.slice(1, arr.size())[/code]).
If either [param begin] or [param end] are negative, they will be relative to the end of the array (i.e. [code]arr.slice(0, -2)[/code] is a shorthand for [code]arr.slice(0, arr.size() - 2)[/code]).
*/
//go:nosplit
func (self *PackedVector2Array) Slice(ctx Lifetime, begin Int, end Int) PackedVector2Array {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, begin)
	callframe.Arg(frame, end)
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedVector2Array.slice(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	var ret = mmm.New[PackedVector2Array](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns a [PackedByteArray] with each vector encoded as bytes.
*/
//go:nosplit
func (self *PackedVector2Array) ToByteArray(ctx Lifetime) PackedByteArray {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedVector2Array.to_byte_array(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	var ret = mmm.New[PackedByteArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Sorts the elements of the array in ascending order.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included.
*/
//go:nosplit
func (self *PackedVector2Array) Sort()  {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedVector2Array.sort(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Finds the index of an existing value (or the insertion index that maintains sorting order, if the value is not yet present in the array) using binary search. Optionally, a [param before] specifier can be passed. If [code]false[/code], the returned index comes after all existing entries of the value in the array.
[b]Note:[/b] Calling [method bsearch] on an unsorted array results in unexpected behavior.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included.
*/
//go:nosplit
func (self *PackedVector2Array) Bsearch(value Vector2, before bool) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	callframe.Arg(frame, before)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedVector2Array.bsearch(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Creates a copy of the array, and returns it.
*/
//go:nosplit
func (self *PackedVector2Array) Duplicate(ctx Lifetime) PackedVector2Array {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedVector2Array.duplicate(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	var ret = mmm.New[PackedVector2Array](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Searches the array for a value and returns its index or [code]-1[/code] if not found. Optionally, the initial search index can be passed.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included.
*/
//go:nosplit
func (self *PackedVector2Array) Find(value Vector2, from Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	callframe.Arg(frame, from)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedVector2Array.find(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Searches the array in reverse order. Optionally, a start search index can be passed. If negative, the start index is considered relative to the end of the array.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included.
*/
//go:nosplit
func (self *PackedVector2Array) Rfind(value Vector2, from Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	callframe.Arg(frame, from)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedVector2Array.rfind(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns the number of times an element is in the array.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included.
*/
//go:nosplit
func (self *PackedVector2Array) Count(value Vector2) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedVector2Array.count(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns the number of elements in the array.
*/
//go:nosplit
func (self *PackedVector3Array) Size() Int {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedVector3Array.size(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns [code]true[/code] if the array is empty.
*/
//go:nosplit
func (self *PackedVector3Array) IsEmpty() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedVector3Array.is_empty(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Changes the [Vector3] at the given index.
*/
//go:nosplit
func (self *PackedVector3Array) Set(index Int, value Vector3)  {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, index)
	callframe.Arg(frame, value)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedVector3Array.set(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Inserts a [Vector3] at the end.
*/
//go:nosplit
func (self *PackedVector3Array) PushBack(value Vector3) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedVector3Array.push_back(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Appends an element at the end of the array (alias of [method push_back]).
*/
//go:nosplit
func (self *PackedVector3Array) Append(value Vector3) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedVector3Array.append(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Appends a [PackedVector3Array] at the end of this array.
*/
//go:nosplit
func (self *PackedVector3Array) AppendArray(array PackedVector3Array)  {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(array))
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedVector3Array.append_array(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Removes an element from the array by index.
*/
//go:nosplit
func (self *PackedVector3Array) RemoveAt(index Int)  {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, index)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedVector3Array.remove_at(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Inserts a new element at a given position in the array. The position must be valid, or at the end of the array ([code]idx == size()[/code]).
*/
//go:nosplit
func (self *PackedVector3Array) Insert(at_index Int, value Vector3) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, at_index)
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedVector3Array.insert(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Assigns the given value to all elements in the array. This can typically be used together with [method resize] to create an array with a given size and initialized elements.
*/
//go:nosplit
func (self *PackedVector3Array) Fill(value Vector3)  {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedVector3Array.fill(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Sets the size of the array. If the array is grown, reserves elements at the end of the array. If the array is shrunk, truncates the array to the new size. Calling [method resize] once and assigning the new values is faster than adding new elements one by one.
*/
//go:nosplit
func (self *PackedVector3Array) Resize(new_size Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, new_size)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedVector3Array.resize(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Clears the array. This is equivalent to using [method resize] with a size of [code]0[/code].
*/
//go:nosplit
func (self *PackedVector3Array) Clear()  {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedVector3Array.clear(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Returns [code]true[/code] if the array contains [param value].
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included.
*/
//go:nosplit
func (self *PackedVector3Array) Has(value Vector3) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedVector3Array.has(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Reverses the order of the elements in the array.
*/
//go:nosplit
func (self *PackedVector3Array) Reverse()  {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedVector3Array.reverse(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Returns the slice of the [PackedVector3Array], from [param begin] (inclusive) to [param end] (exclusive), as a new [PackedVector3Array].
The absolute value of [param begin] and [param end] will be clamped to the array size, so the default value for [param end] makes it slice to the size of the array by default (i.e. [code]arr.slice(1)[/code] is a shorthand for [code]arr.slice(1, arr.size())[/code]).
If either [param begin] or [param end] are negative, they will be relative to the end of the array (i.e. [code]arr.slice(0, -2)[/code] is a shorthand for [code]arr.slice(0, arr.size() - 2)[/code]).
*/
//go:nosplit
func (self *PackedVector3Array) Slice(ctx Lifetime, begin Int, end Int) PackedVector3Array {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, begin)
	callframe.Arg(frame, end)
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedVector3Array.slice(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	var ret = mmm.New[PackedVector3Array](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns a [PackedByteArray] with each vector encoded as bytes.
*/
//go:nosplit
func (self *PackedVector3Array) ToByteArray(ctx Lifetime) PackedByteArray {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedVector3Array.to_byte_array(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	var ret = mmm.New[PackedByteArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Sorts the elements of the array in ascending order.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included.
*/
//go:nosplit
func (self *PackedVector3Array) Sort()  {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedVector3Array.sort(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Finds the index of an existing value (or the insertion index that maintains sorting order, if the value is not yet present in the array) using binary search. Optionally, a [param before] specifier can be passed. If [code]false[/code], the returned index comes after all existing entries of the value in the array.
[b]Note:[/b] Calling [method bsearch] on an unsorted array results in unexpected behavior.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included.
*/
//go:nosplit
func (self *PackedVector3Array) Bsearch(value Vector3, before bool) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	callframe.Arg(frame, before)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedVector3Array.bsearch(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Creates a copy of the array, and returns it.
*/
//go:nosplit
func (self *PackedVector3Array) Duplicate(ctx Lifetime) PackedVector3Array {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedVector3Array.duplicate(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	var ret = mmm.New[PackedVector3Array](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Searches the array for a value and returns its index or [code]-1[/code] if not found. Optionally, the initial search index can be passed.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included.
*/
//go:nosplit
func (self *PackedVector3Array) Find(value Vector3, from Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	callframe.Arg(frame, from)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedVector3Array.find(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Searches the array in reverse order. Optionally, a start search index can be passed. If negative, the start index is considered relative to the end of the array.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included.
*/
//go:nosplit
func (self *PackedVector3Array) Rfind(value Vector3, from Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	callframe.Arg(frame, from)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedVector3Array.rfind(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns the number of times an element is in the array.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included.
*/
//go:nosplit
func (self *PackedVector3Array) Count(value Vector3) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedVector3Array.count(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns the number of elements in the array.
*/
//go:nosplit
func (self *PackedColorArray) Size() Int {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedColorArray.size(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns [code]true[/code] if the array is empty.
*/
//go:nosplit
func (self *PackedColorArray) IsEmpty() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedColorArray.is_empty(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Changes the [Color] at the given index.
*/
//go:nosplit
func (self *PackedColorArray) Set(index Int, value Color)  {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, index)
	callframe.Arg(frame, value)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedColorArray.set(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Appends a value to the array.
*/
//go:nosplit
func (self *PackedColorArray) PushBack(value Color) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedColorArray.push_back(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Appends an element at the end of the array (alias of [method push_back]).
*/
//go:nosplit
func (self *PackedColorArray) Append(value Color) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedColorArray.append(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Appends a [PackedColorArray] at the end of this array.
*/
//go:nosplit
func (self *PackedColorArray) AppendArray(array PackedColorArray)  {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(array))
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedColorArray.append_array(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Removes an element from the array by index.
*/
//go:nosplit
func (self *PackedColorArray) RemoveAt(index Int)  {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, index)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedColorArray.remove_at(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Inserts a new element at a given position in the array. The position must be valid, or at the end of the array ([code]idx == size()[/code]).
*/
//go:nosplit
func (self *PackedColorArray) Insert(at_index Int, value Color) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, at_index)
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedColorArray.insert(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Assigns the given value to all elements in the array. This can typically be used together with [method resize] to create an array with a given size and initialized elements.
*/
//go:nosplit
func (self *PackedColorArray) Fill(value Color)  {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedColorArray.fill(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Sets the size of the array. If the array is grown, reserves elements at the end of the array. If the array is shrunk, truncates the array to the new size. Calling [method resize] once and assigning the new values is faster than adding new elements one by one.
*/
//go:nosplit
func (self *PackedColorArray) Resize(new_size Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, new_size)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedColorArray.resize(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Clears the array. This is equivalent to using [method resize] with a size of [code]0[/code].
*/
//go:nosplit
func (self *PackedColorArray) Clear()  {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedColorArray.clear(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Returns [code]true[/code] if the array contains [param value].
*/
//go:nosplit
func (self *PackedColorArray) Has(value Color) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedColorArray.has(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Reverses the order of the elements in the array.
*/
//go:nosplit
func (self *PackedColorArray) Reverse()  {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedColorArray.reverse(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Returns the slice of the [PackedColorArray], from [param begin] (inclusive) to [param end] (exclusive), as a new [PackedColorArray].
The absolute value of [param begin] and [param end] will be clamped to the array size, so the default value for [param end] makes it slice to the size of the array by default (i.e. [code]arr.slice(1)[/code] is a shorthand for [code]arr.slice(1, arr.size())[/code]).
If either [param begin] or [param end] are negative, they will be relative to the end of the array (i.e. [code]arr.slice(0, -2)[/code] is a shorthand for [code]arr.slice(0, arr.size() - 2)[/code]).
*/
//go:nosplit
func (self *PackedColorArray) Slice(ctx Lifetime, begin Int, end Int) PackedColorArray {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, begin)
	callframe.Arg(frame, end)
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedColorArray.slice(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	var ret = mmm.New[PackedColorArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns a [PackedByteArray] with each color encoded as bytes.
*/
//go:nosplit
func (self *PackedColorArray) ToByteArray(ctx Lifetime) PackedByteArray {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedColorArray.to_byte_array(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	var ret = mmm.New[PackedByteArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Sorts the elements of the array in ascending order.
*/
//go:nosplit
func (self *PackedColorArray) Sort()  {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedColorArray.sort(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Finds the index of an existing value (or the insertion index that maintains sorting order, if the value is not yet present in the array) using binary search. Optionally, a [param before] specifier can be passed. If [code]false[/code], the returned index comes after all existing entries of the value in the array.
[b]Note:[/b] Calling [method bsearch] on an unsorted array results in unexpected behavior.
*/
//go:nosplit
func (self *PackedColorArray) Bsearch(value Color, before bool) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	callframe.Arg(frame, before)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedColorArray.bsearch(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Creates a copy of the array, and returns it.
*/
//go:nosplit
func (self *PackedColorArray) Duplicate(ctx Lifetime) PackedColorArray {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedColorArray.duplicate(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	var ret = mmm.New[PackedColorArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Searches the array for a value and returns its index or [code]-1[/code] if not found. Optionally, the initial search index can be passed.
*/
//go:nosplit
func (self *PackedColorArray) Find(value Color, from Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	callframe.Arg(frame, from)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedColorArray.find(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Searches the array in reverse order. Optionally, a start search index can be passed. If negative, the start index is considered relative to the end of the array.
*/
//go:nosplit
func (self *PackedColorArray) Rfind(value Color, from Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	callframe.Arg(frame, from)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedColorArray.rfind(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns the number of times an element is in the array.
*/
//go:nosplit
func (self *PackedColorArray) Count(value Color) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedColorArray.count(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns the number of elements in the array.
*/
//go:nosplit
func (self *PackedVector4Array) Size() Int {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedVector4Array.size(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns [code]true[/code] if the array is empty.
*/
//go:nosplit
func (self *PackedVector4Array) IsEmpty() bool {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedVector4Array.is_empty(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Changes the [Vector4] at the given index.
*/
//go:nosplit
func (self *PackedVector4Array) Set(index Int, value Vector4)  {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, index)
	callframe.Arg(frame, value)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedVector4Array.set(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Inserts a [Vector4] at the end.
*/
//go:nosplit
func (self *PackedVector4Array) PushBack(value Vector4) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedVector4Array.push_back(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Appends an element at the end of the array (alias of [method push_back]).
*/
//go:nosplit
func (self *PackedVector4Array) Append(value Vector4) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedVector4Array.append(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Appends a [PackedVector4Array] at the end of this array.
*/
//go:nosplit
func (self *PackedVector4Array) AppendArray(array PackedVector4Array)  {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(array))
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedVector4Array.append_array(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Removes an element from the array by index.
*/
//go:nosplit
func (self *PackedVector4Array) RemoveAt(index Int)  {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, index)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedVector4Array.remove_at(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Inserts a new element at a given position in the array. The position must be valid, or at the end of the array ([code]idx == size()[/code]).
*/
//go:nosplit
func (self *PackedVector4Array) Insert(at_index Int, value Vector4) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, at_index)
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedVector4Array.insert(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Assigns the given value to all elements in the array. This can typically be used together with [method resize] to create an array with a given size and initialized elements.
*/
//go:nosplit
func (self *PackedVector4Array) Fill(value Vector4)  {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedVector4Array.fill(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Sets the size of the array. If the array is grown, reserves elements at the end of the array. If the array is shrunk, truncates the array to the new size.
*/
//go:nosplit
func (self *PackedVector4Array) Resize(new_size Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, new_size)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedVector4Array.resize(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Clears the array. This is equivalent to using [method resize] with a size of [code]0[/code].
*/
//go:nosplit
func (self *PackedVector4Array) Clear()  {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedVector4Array.clear(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Returns [code]true[/code] if the array contains [param value].
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included.
*/
//go:nosplit
func (self *PackedVector4Array) Has(value Vector4) bool {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[bool](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedVector4Array.has(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Reverses the order of the elements in the array.
*/
//go:nosplit
func (self *PackedVector4Array) Reverse()  {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedVector4Array.reverse(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Returns the slice of the [PackedVector4Array], from [param begin] (inclusive) to [param end] (exclusive), as a new [PackedVector4Array].
The absolute value of [param begin] and [param end] will be clamped to the array size, so the default value for [param end] makes it slice to the size of the array by default (i.e. [code]arr.slice(1)[/code] is a shorthand for [code]arr.slice(1, arr.size())[/code]).
If either [param begin] or [param end] are negative, they will be relative to the end of the array (i.e. [code]arr.slice(0, -2)[/code] is a shorthand for [code]arr.slice(0, arr.size() - 2)[/code]).
*/
//go:nosplit
func (self *PackedVector4Array) Slice(ctx Lifetime, begin Int, end Int) PackedVector4Array {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, begin)
	callframe.Arg(frame, end)
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedVector4Array.slice(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	var ret = mmm.New[PackedVector4Array](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns a [PackedByteArray] with each vector encoded as bytes.
*/
//go:nosplit
func (self *PackedVector4Array) ToByteArray(ctx Lifetime) PackedByteArray {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedVector4Array.to_byte_array(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	var ret = mmm.New[PackedByteArray](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Sorts the elements of the array in ascending order.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included.
*/
//go:nosplit
func (self *PackedVector4Array) Sort()  {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret callframe.Nil
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedVector4Array.sort(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	frame.Free()
}
/*
Finds the index of an existing value (or the insertion index that maintains sorting order, if the value is not yet present in the array) using binary search. Optionally, a [param before] specifier can be passed. If [code]false[/code], the returned index comes after all existing entries of the value in the array.
[b]Note:[/b] Calling [method bsearch] on an unsorted array results in unexpected behavior.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included.
*/
//go:nosplit
func (self *PackedVector4Array) Bsearch(value Vector4, before bool) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	callframe.Arg(frame, before)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedVector4Array.bsearch(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Creates a copy of the array, and returns it.
*/
//go:nosplit
func (self *PackedVector4Array) Duplicate(ctx Lifetime) PackedVector4Array {
	var selfPtr = self
	var frame = callframe.New()
	var r_ret = callframe.Ret[[2]uintptr](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedVector4Array.duplicate(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 0)
	mmm.Set(selfPtr, p_self.Get())
	var ret = mmm.New[PackedVector4Array](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Searches the array for a value and returns its index or [code]-1[/code] if not found. Optionally, the initial search index can be passed.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included.
*/
//go:nosplit
func (self *PackedVector4Array) Find(value Vector4, from Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	callframe.Arg(frame, from)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedVector4Array.find(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Searches the array in reverse order. Optionally, a start search index can be passed. If negative, the start index is considered relative to the end of the array.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included.
*/
//go:nosplit
func (self *PackedVector4Array) Rfind(value Vector4, from Int) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	callframe.Arg(frame, from)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedVector4Array.rfind(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 2)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns the number of times an element is in the array.
[b]Note:[/b] Vectors with [constant @GDScript.NAN] elements don't behave the same as other vectors. Therefore, the results from this method may not be accurate if NaNs are included.
*/
//go:nosplit
func (self *PackedVector4Array) Count(value Vector4) Int {
	var selfPtr = self
	var frame = callframe.New()
	callframe.Arg(frame, value)
	var r_ret = callframe.Ret[Int](frame)
	var p_self = callframe.Arg(frame, mmm.Get(selfPtr))
	mmm.API(*self).builtin.PackedVector4Array.count(p_self.Uintptr(), frame.Array(0), r_ret.Uintptr(), 1)
	mmm.Set(selfPtr, p_self.Get())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
type ObjectConnectFlags int64

/*
Returns the object's built-in class name, as a [String]. See also [method is_class].
[b]Note:[/b] This method ignores [code]class_name[/code] declarations. If this object's script has defined a [code]class_name[/code], the base, built-in class name is returned instead.
*/
//go:nosplit
func (self Object) GetClass(ctx Lifetime) String {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_get_class, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns [code]true[/code] if the object inherits from the given [param class]. See also [method get_class].
[codeblocks]
[gdscript]
var sprite2d = Sprite2D.new()
sprite2d.is_class("Sprite2D") # Returns true
sprite2d.is_class("Node")     # Returns true
sprite2d.is_class("Node3D")   # Returns false
[/gdscript]
[csharp]
var sprite2D = new Sprite2D();
sprite2D.IsClass("Sprite2D"); // Returns true
sprite2D.IsClass("Node");     // Returns true
sprite2D.IsClass("Node3D");   // Returns false
[/csharp]
[/codeblocks]
[b]Note:[/b] This method ignores [code]class_name[/code] declarations in the object's script.
*/
//go:nosplit
func (self Object) IsClass(class String) bool {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(class))
	var r_ret = callframe.Ret[bool](frame)
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_is_class, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Assigns [param value] to the given [param property]. If the property does not exist or the given [param value]'s type doesn't match, nothing happens.
[codeblocks]
[gdscript]
var node = Node2D.new()
node.set("global_scale", Vector2(8, 2.5))
print(node.global_scale) # Prints (8, 2.5)
[/gdscript]
[csharp]
var node = new Node2D();
node.Set(Node2D.PropertyName.GlobalScale, new Vector2(8, 2.5));
GD.Print(node.GlobalScale); // Prints Vector2(8, 2.5)
[/csharp]
[/codeblocks]
[b]Note:[/b] In C#, [param property] must be in snake_case when referring to built-in Godot properties. Prefer using the names exposed in the [code]PropertyName[/code] class to avoid allocating a new [StringName] on each call.
*/
//go:nosplit
func (self Object) Set(property StringName, value Variant)  {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(property))
	callframe.Arg(frame, mmm.Get(value))
	var r_ret callframe.Nil
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_set, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	frame.Free()
}
/*
Returns the [Variant] value of the given [param property]. If the [param property] does not exist, this method returns [code]null[/code].
[codeblocks]
[gdscript]
var node = Node2D.new()
node.rotation = 1.5
var a = node.get("rotation") # a is 1.5
[/gdscript]
[csharp]
var node = new Node2D();
node.Rotation = 1.5f;
var a = node.Get(Node2D.PropertyName.Rotation); // a is 1.5
[/csharp]
[/codeblocks]
[b]Note:[/b] In C#, [param property] must be in snake_case when referring to built-in Godot properties. Prefer using the names exposed in the [code]PropertyName[/code] class to avoid allocating a new [StringName] on each call.
*/
//go:nosplit
func (self Object) Get(ctx Lifetime, property StringName) Variant {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(property))
	var r_ret = callframe.Ret[[3]uintptr](frame)
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_get, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Assigns a new [param value] to the property identified by the [param property_path]. The path should be a [NodePath] relative to this object, and can use the colon character ([code]:[/code]) to access nested properties.
[codeblocks]
[gdscript]
var node = Node2D.new()
node.set_indexed("position", Vector2(42, 0))
node.set_indexed("position:y", -10)
print(node.position) # Prints (42, -10)
[/gdscript]
[csharp]
var node = new Node2D();
node.SetIndexed("position", new Vector2(42, 0));
node.SetIndexed("position:y", -10);
GD.Print(node.Position); // Prints (42, -10)
[/csharp]
[/codeblocks]
[b]Note:[/b] In C#, [param property_path] must be in snake_case when referring to built-in Godot properties. Prefer using the names exposed in the [code]PropertyName[/code] class to avoid allocating a new [StringName] on each call.
*/
//go:nosplit
func (self Object) SetIndexed(property_path NodePath, value Variant)  {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(property_path))
	callframe.Arg(frame, mmm.Get(value))
	var r_ret callframe.Nil
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_set_indexed, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	frame.Free()
}
/*
Gets the object's property indexed by the given [param property_path]. The path should be a [NodePath] relative to the current object and can use the colon character ([code]:[/code]) to access nested properties.
[b]Examples:[/b] [code]"position:x"[/code] or [code]"material:next_pass:blend_mode"[/code].
[codeblocks]
[gdscript]
var node = Node2D.new()
node.position = Vector2(5, -10)
var a = node.get_indexed("position")   # a is Vector2(5, -10)
var b = node.get_indexed("position:y") # b is -10
[/gdscript]
[csharp]
var node = new Node2D();
node.Position = new Vector2(5, -10);
var a = node.GetIndexed("position");   // a is Vector2(5, -10)
var b = node.GetIndexed("position:y"); // b is -10
[/csharp]
[/codeblocks]
[b]Note:[/b] In C#, [param property_path] must be in snake_case when referring to built-in Godot properties. Prefer using the names exposed in the [code]PropertyName[/code] class to avoid allocating a new [StringName] on each call.
[b]Note:[/b] This method does not support actual paths to nodes in the [SceneTree], only sub-property paths. In the context of nodes, use [method Node.get_node_and_resource] instead.
*/
//go:nosplit
func (self Object) GetIndexed(ctx Lifetime, property_path NodePath) Variant {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(property_path))
	var r_ret = callframe.Ret[[3]uintptr](frame)
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_get_indexed, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns the object's property list as an [Array] of dictionaries. Each [Dictionary] contains the following entries:
- [code]name[/code] is the property's name, as a [String];
- [code]class_name[/code] is an empty [StringName], unless the property is [constant TYPE_OBJECT] and it inherits from a class;
- [code]type[/code] is the property's type, as an [int] (see [enum Variant.Type]);
- [code]hint[/code] is [i]how[/i] the property is meant to be edited (see [enum PropertyHint]);
- [code]hint_string[/code] depends on the hint (see [enum PropertyHint]);
- [code]usage[/code] is a combination of [enum PropertyUsageFlags].
[b]Note:[/b] In GDScript, all class members are treated as properties. In C# and GDExtension, it may be necessary to explicitly mark class members as Godot properties using decorators or attributes.
*/
//go:nosplit
func (self Object) GetPropertyList(ctx Lifetime) ArrayOf[Dictionary] {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_get_property_list, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = mmm.New[Array](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return TypedArray[Dictionary](ret)
}
/*
Returns this object's methods and their signatures as an [Array] of dictionaries. Each [Dictionary] contains the following entries:
- [code]name[/code] is the name of the method, as a [String];
- [code]args[/code] is an [Array] of dictionaries representing the arguments;
- [code]default_args[/code] is the default arguments as an [Array] of variants;
- [code]flags[/code] is a combination of [enum MethodFlags];
- [code]id[/code] is the method's internal identifier [int];
- [code]return[/code] is the returned value, as a [Dictionary];
[b]Note:[/b] The dictionaries of [code]args[/code] and [code]return[/code] are formatted identically to the results of [method get_property_list], although not all entries are used.
*/
//go:nosplit
func (self Object) GetMethodList(ctx Lifetime) ArrayOf[Dictionary] {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_get_method_list, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = mmm.New[Array](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return TypedArray[Dictionary](ret)
}
/*
Returns [code]true[/code] if the given [param property] has a custom default value. Use [method property_get_revert] to get the [param property]'s default value.
[b]Note:[/b] This method is used by the Inspector dock to display a revert icon. The object must implement [method _property_can_revert] to customize the default value. If [method _property_can_revert] is not implemented, this method returns [code]false[/code].
*/
//go:nosplit
func (self Object) PropertyCanRevert(property StringName) bool {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(property))
	var r_ret = callframe.Ret[bool](frame)
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_property_can_revert, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns the custom default value of the given [param property]. Use [method property_can_revert] to check if the [param property] has a custom default value.
[b]Note:[/b] This method is used by the Inspector dock to display a revert icon. The object must implement [method _property_get_revert] to customize the default value. If [method _property_get_revert] is not implemented, this method returns [code]null[/code].
*/
//go:nosplit
func (self Object) PropertyGetRevert(ctx Lifetime, property StringName) Variant {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(property))
	var r_ret = callframe.Ret[[3]uintptr](frame)
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_property_get_revert, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Sends the given [param what] notification to all classes inherited by the object, triggering calls to [method _notification], starting from the highest ancestor (the [Object] class) and going down to the object's script.
If [param reversed] is [code]true[/code], the call order is reversed.
[codeblocks]
[gdscript]
var player = Node2D.new()
player.set_script(load("res://player.gd"))

player.notification(NOTIFICATION_ENTER_TREE)
# The call order is Object -> Node -> Node2D -> player.gd.

player.notification(NOTIFICATION_ENTER_TREE, true)
# The call order is player.gd -> Node2D -> Node -> Object.
[/gdscript]
[csharp]
var player = new Node2D();
player.SetScript(GD.Load("res://player.gd"));

player.Notification(NotificationEnterTree);
// The call order is GodotObject -> Node -> Node2D -> player.gd.

player.Notification(NotificationEnterTree, true);
// The call order is player.gd -> Node2D -> Node -> GodotObject.
[/csharp]
[/codeblocks]
*/
//go:nosplit
func (self Object) Notification(what Int, reversed bool)  {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	callframe.Arg(frame, what)
	callframe.Arg(frame, reversed)
	var r_ret callframe.Nil
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_notification, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	frame.Free()
}
/*
Returns a [String] representing the object. Defaults to [code]"<ClassName#RID>"[/code]. Override [method _to_string] to customize the string representation of the object.
*/
//go:nosplit
func (self Object) ToString(ctx Lifetime) String {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_to_string, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns the object's unique instance ID. This ID can be saved in [EncodedObjectAsID], and can be used to retrieve this object instance with [method @GlobalScope.instance_from_id].
[b]Note:[/b] This ID is only useful during the current session. It won't correspond to a similar object if the ID is sent over a network, or loaded from a file at a later time.
*/
//go:nosplit
func (self Object) GetInstanceId() Int {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_get_instance_id, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Attaches [param script] to the object, and instantiates it. As a result, the script's [method _init] is called. A [Script] is used to extend the object's functionality.
If a script already exists, its instance is detached, and its property values and state are lost. Built-in property values are still kept.
*/
//go:nosplit
func (self Object) SetScript(script Variant)  {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(script))
	var r_ret callframe.Nil
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_set_script, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	frame.Free()
}
/*
Returns the object's [Script] instance, or [code]null[/code] if no script is attached.
*/
//go:nosplit
func (self Object) GetScript(ctx Lifetime) Variant {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	var r_ret = callframe.Ret[[3]uintptr](frame)
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_get_script, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Adds or changes the entry [param name] inside the object's metadata. The metadata [param value] can be any [Variant], although some types cannot be serialized correctly.
If [param value] is [code]null[/code], the entry is removed. This is the equivalent of using [method remove_meta]. See also [method has_meta] and [method get_meta].
[b]Note:[/b] A metadata's name must be a valid identifier as per [method StringName.is_valid_identifier] method.
[b]Note:[/b] Metadata that has a name starting with an underscore ([code]_[/code]) is considered editor-only. Editor-only metadata is not displayed in the Inspector and should not be edited, although it can still be found by this method.
*/
//go:nosplit
func (self Object) SetMeta(name StringName, value Variant)  {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(name))
	callframe.Arg(frame, mmm.Get(value))
	var r_ret callframe.Nil
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_set_meta, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	frame.Free()
}
/*
Removes the given entry [param name] from the object's metadata. See also [method has_meta], [method get_meta] and [method set_meta].
[b]Note:[/b] A metadata's name must be a valid identifier as per [method StringName.is_valid_identifier] method.
[b]Note:[/b] Metadata that has a name starting with an underscore ([code]_[/code]) is considered editor-only. Editor-only metadata is not displayed in the Inspector and should not be edited, although it can still be found by this method.
*/
//go:nosplit
func (self Object) RemoveMeta(name StringName)  {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(name))
	var r_ret callframe.Nil
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_remove_meta, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	frame.Free()
}
/*
Returns the object's metadata value for the given entry [param name]. If the entry does not exist, returns [param default]. If [param default] is [code]null[/code], an error is also generated.
[b]Note:[/b] A metadata's name must be a valid identifier as per [method StringName.is_valid_identifier] method.
[b]Note:[/b] Metadata that has a name starting with an underscore ([code]_[/code]) is considered editor-only. Editor-only metadata is not displayed in the Inspector and should not be edited, although it can still be found by this method.
*/
//go:nosplit
func (self Object) GetMeta(ctx Lifetime, name StringName, def Variant) Variant {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(name))
	callframe.Arg(frame, mmm.Get(def))
	var r_ret = callframe.Ret[[3]uintptr](frame)
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_get_meta, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns [code]true[/code] if a metadata entry is found with the given [param name]. See also [method get_meta], [method set_meta] and [method remove_meta].
[b]Note:[/b] A metadata's name must be a valid identifier as per [method StringName.is_valid_identifier] method.
[b]Note:[/b] Metadata that has a name starting with an underscore ([code]_[/code]) is considered editor-only. Editor-only metadata is not displayed in the Inspector and should not be edited, although it can still be found by this method.
*/
//go:nosplit
func (self Object) HasMeta(name StringName) bool {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(name))
	var r_ret = callframe.Ret[bool](frame)
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_has_meta, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns the object's metadata entry names as a [PackedStringArray].
*/
//go:nosplit
func (self Object) GetMetaList(ctx Lifetime) ArrayOf[StringName] {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_get_meta_list, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = mmm.New[Array](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return TypedArray[StringName](ret)
}
/*
Adds a user-defined [param signal]. Optional arguments for the signal can be added as an [Array] of dictionaries, each defining a [code]name[/code] [String] and a [code]type[/code] [int] (see [enum Variant.Type]). See also [method has_user_signal] and [method remove_user_signal].
[codeblocks]
[gdscript]
add_user_signal("hurt", [
    { "name": "damage", "type": TYPE_INT },
    { "name": "source", "type": TYPE_OBJECT }
])
[/gdscript]
[csharp]
AddUserSignal("Hurt", new Godot.Collections.Array()
{
    new Godot.Collections.Dictionary()
    {
        { "name", "damage" },
        { "type", (int)Variant.Type.Int }
    },
    new Godot.Collections.Dictionary()
    {
        { "name", "source" },
        { "type", (int)Variant.Type.Object }
    }
});
[/csharp]
[/codeblocks]
*/
//go:nosplit
func (self Object) AddUserSignal(signal String, arguments Array)  {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(signal))
	callframe.Arg(frame, mmm.Get(arguments))
	var r_ret callframe.Nil
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_add_user_signal, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	frame.Free()
}
/*
Returns [code]true[/code] if the given user-defined [param signal] name exists. Only signals added with [method add_user_signal] are included. See also [method remove_user_signal].
*/
//go:nosplit
func (self Object) HasUserSignal(signal StringName) bool {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(signal))
	var r_ret = callframe.Ret[bool](frame)
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_has_user_signal, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Removes the given user signal [param signal] from the object. See also [method add_user_signal] and [method has_user_signal].
*/
//go:nosplit
func (self Object) RemoveUserSignal(signal StringName)  {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(signal))
	var r_ret callframe.Nil
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_remove_user_signal, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	frame.Free()
}
/*
Assigns [param value] to the given [param property], at the end of the current frame. This is equivalent to calling [method set] through [method call_deferred].
[codeblocks]
[gdscript]
var node = Node2D.new()
add_child(node)

node.rotation = 1.5
node.set_deferred("rotation", 3.0)
print(node.rotation) # Prints 1.5

await get_tree().process_frame
print(node.rotation) # Prints 3.0
[/gdscript]
[csharp]
var node = new Node2D();
node.Rotation = 1.5f;
node.SetDeferred(Node2D.PropertyName.Rotation, 3f);
GD.Print(node.Rotation); // Prints 1.5

await ToSignal(GetTree(), SceneTree.SignalName.ProcessFrame);
GD.Print(node.Rotation); // Prints 3.0
[/csharp]
[/codeblocks]
[b]Note:[/b] In C#, [param property] must be in snake_case when referring to built-in Godot properties. Prefer using the names exposed in the [code]PropertyName[/code] class to avoid allocating a new [StringName] on each call.
*/
//go:nosplit
func (self Object) SetDeferred(property StringName, value Variant)  {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(property))
	callframe.Arg(frame, mmm.Get(value))
	var r_ret callframe.Nil
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_set_deferred, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	frame.Free()
}
/*
Calls the [param method] on the object and returns the result. Unlike [method call], this method expects all parameters to be contained inside [param arg_array].
[codeblocks]
[gdscript]
var node = Node3D.new()
node.callv("rotate", [Vector3(1.0, 0.0, 0.0), 1.571])
[/gdscript]
[csharp]
var node = new Node3D();
node.Callv(Node3D.MethodName.Rotate, new Godot.Collections.Array { new Vector3(1f, 0f, 0f), 1.571f });
[/csharp]
[/codeblocks]
[b]Note:[/b] In C#, [param method] must be in snake_case when referring to built-in Godot methods. Prefer using the names exposed in the [code]MethodName[/code] class to avoid allocating a new [StringName] on each call.
*/
//go:nosplit
func (self Object) Callv(ctx Lifetime, method StringName, arg_array Array) Variant {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(method))
	callframe.Arg(frame, mmm.Get(arg_array))
	var r_ret = callframe.Ret[[3]uintptr](frame)
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_callv, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = mmm.New[Variant](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns [code]true[/code] if the given [param method] name exists in the object.
[b]Note:[/b] In C#, [param method] must be in snake_case when referring to built-in Godot methods. Prefer using the names exposed in the [code]MethodName[/code] class to avoid allocating a new [StringName] on each call.
*/
//go:nosplit
func (self Object) HasMethod(method StringName) bool {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(method))
	var r_ret = callframe.Ret[bool](frame)
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_has_method, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns the number of arguments of the given [param method] by name.
[b]Note:[/b] In C#, [param method] must be in snake_case when referring to built-in Godot methods. Prefer using the names exposed in the [code]MethodName[/code] class to avoid allocating a new [StringName] on each call.
*/
//go:nosplit
func (self Object) GetMethodArgumentCount(method StringName) Int {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(method))
	var r_ret = callframe.Ret[Int](frame)
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_get_method_argument_count, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns [code]true[/code] if the given [param signal] name exists in the object.
[b]Note:[/b] In C#, [param signal] must be in snake_case when referring to built-in Godot methods. Prefer using the names exposed in the [code]SignalName[/code] class to avoid allocating a new [StringName] on each call.
*/
//go:nosplit
func (self Object) HasSignal(signal StringName) bool {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(signal))
	var r_ret = callframe.Ret[bool](frame)
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_has_signal, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns the list of existing signals as an [Array] of dictionaries.
[b]Note:[/b] Due of the implementation, each [Dictionary] is formatted very similarly to the returned values of [method get_method_list].
*/
//go:nosplit
func (self Object) GetSignalList(ctx Lifetime) ArrayOf[Dictionary] {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_get_signal_list, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = mmm.New[Array](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return TypedArray[Dictionary](ret)
}
/*
Returns an [Array] of connections for the given [param signal] name. Each connection is represented as a [Dictionary] that contains three entries:
- [code skip-lint]signal[/code] is a reference to the [Signal];
- [code]callable[/code] is a reference to the connected [Callable];
- [code]flags[/code] is a combination of [enum ConnectFlags].
*/
//go:nosplit
func (self Object) GetSignalConnectionList(ctx Lifetime, signal StringName) ArrayOf[Dictionary] {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(signal))
	var r_ret = callframe.Ret[uintptr](frame)
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_get_signal_connection_list, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = mmm.New[Array](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return TypedArray[Dictionary](ret)
}
/*
Returns an [Array] of signal connections received by this object. Each connection is represented as a [Dictionary] that contains three entries:
- [code]signal[/code] is a reference to the [Signal];
- [code]callable[/code] is a reference to the [Callable];
- [code]flags[/code] is a combination of [enum ConnectFlags].
*/
//go:nosplit
func (self Object) GetIncomingConnections(ctx Lifetime) ArrayOf[Dictionary] {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	var r_ret = callframe.Ret[uintptr](frame)
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_get_incoming_connections, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = mmm.New[Array](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return TypedArray[Dictionary](ret)
}
/*
Connects a [param signal] by name to a [param callable]. Optional [param flags] can be also added to configure the connection's behavior (see [enum ConnectFlags] constants).
A signal can only be connected once to the same [Callable]. If the signal is already connected, this method returns [constant ERR_INVALID_PARAMETER] and pushes an error message, unless the signal is connected with [constant CONNECT_REFERENCE_COUNTED]. To prevent this, use [method is_connected] first to check for existing connections.
If the [param callable]'s object is freed, the connection will be lost.
[b]Examples with recommended syntax:[/b]
Connecting signals is one of the most common operations in Godot and the API gives many options to do so, which are described further down. The code block below shows the recommended approach.
[codeblocks]
[gdscript]
func _ready():
    var button = Button.new()
    # `button_down` here is a Signal variant type, and we thus call the Signal.connect() method, not Object.connect().
    # See discussion below for a more in-depth overview of the API.
    button.button_down.connect(_on_button_down)

    # This assumes that a `Player` class exists, which defines a `hit` signal.
    var player = Player.new()
    # We use Signal.connect() again, and we also use the Callable.bind() method,
    # which returns a new Callable with the parameter binds.
    player.hit.connect(_on_player_hit.bind("sword", 100))

func _on_button_down():
    print("Button down!")

func _on_player_hit(weapon_type, damage):
    print("Hit with weapon %s for %d damage." % [weapon_type, damage])
[/gdscript]
[csharp]
public override void _Ready()
{
    var button = new Button();
    // C# supports passing signals as events, so we can use this idiomatic construct:
    button.ButtonDown += OnButtonDown;

    // This assumes that a `Player` class exists, which defines a `Hit` signal.
    var player = new Player();
    // We can use lambdas when we need to bind additional parameters.
    player.Hit += () => OnPlayerHit("sword", 100);
}

private void OnButtonDown()
{
    GD.Print("Button down!");
}

private void OnPlayerHit(string weaponType, int damage)
{
    GD.Print($"Hit with weapon {weaponType} for {damage} damage.");
}
[/csharp]
[/codeblocks]
[b][code skip-lint]Object.connect()[/code] or [code skip-lint]Signal.connect()[/code]?[/b]
As seen above, the recommended method to connect signals is not [method Object.connect]. The code block below shows the four options for connecting signals, using either this legacy method or the recommended [method Signal.connect], and using either an implicit [Callable] or a manually defined one.
[codeblocks]
[gdscript]
func _ready():
    var button = Button.new()
    # Option 1: Object.connect() with an implicit Callable for the defined function.
    button.connect("button_down", _on_button_down)
    # Option 2: Object.connect() with a constructed Callable using a target object and method name.
    button.connect("button_down", Callable(self, "_on_button_down"))
    # Option 3: Signal.connect() with an implicit Callable for the defined function.
    button.button_down.connect(_on_button_down)
    # Option 4: Signal.connect() with a constructed Callable using a target object and method name.
    button.button_down.connect(Callable(self, "_on_button_down"))

func _on_button_down():
    print("Button down!")
[/gdscript]
[csharp]
public override void _Ready()
{
    var button = new Button();
    // Option 1: In C#, we can use signals as events and connect with this idiomatic syntax:
    button.ButtonDown += OnButtonDown;
    // Option 2: GodotObject.Connect() with a constructed Callable from a method group.
    button.Connect(Button.SignalName.ButtonDown, Callable.From(OnButtonDown));
    // Option 3: GodotObject.Connect() with a constructed Callable using a target object and method name.
    button.Connect(Button.SignalName.ButtonDown, new Callable(this, MethodName.OnButtonDown));
}

private void OnButtonDown()
{
    GD.Print("Button down!");
}
[/csharp]
[/codeblocks]
While all options have the same outcome ([code]button[/code]'s [signal BaseButton.button_down] signal will be connected to [code]_on_button_down[/code]), [b]option 3[/b] offers the best validation: it will print a compile-time error if either the [code]button_down[/code] [Signal] or the [code]_on_button_down[/code] [Callable] are not defined. On the other hand, [b]option 2[/b] only relies on string names and will only be able to validate either names at runtime: it will print a runtime error if [code]"button_down"[/code] doesn't correspond to a signal, or if [code]"_on_button_down"[/code] is not a registered method in the object [code]self[/code]. The main reason for using options 1, 2, or 4 would be if you actually need to use strings (e.g. to connect signals programmatically based on strings read from a configuration file). Otherwise, option 3 is the recommended (and fastest) method.
[b]Binding and passing parameters:[/b]
The syntax to bind parameters is through [method Callable.bind], which returns a copy of the [Callable] with its parameters bound.
When calling [method emit_signal] or [method Signal.emit], the signal parameters can be also passed. The examples below show the relationship between these signal parameters and bound parameters.
[codeblocks]
[gdscript]
func _ready():
    # This assumes that a `Player` class exists, which defines a `hit` signal.
    var player = Player.new()
    # Using Callable.bind().
    player.hit.connect(_on_player_hit.bind("sword", 100))

    # Parameters added when emitting the signal are passed first.
    player.hit.emit("Dark lord", 5)

# We pass two arguments when emitting (`hit_by`, `level`),
# and bind two more arguments when connecting (`weapon_type`, `damage`).
func _on_player_hit(hit_by, level, weapon_type, damage):
    print("Hit by %s (level %d) with weapon %s for %d damage." % [hit_by, level, weapon_type, damage])
[/gdscript]
[csharp]
public override void _Ready()
{
    // This assumes that a `Player` class exists, which defines a `Hit` signal.
    var player = new Player();
    // Using lambda expressions that create a closure that captures the additional parameters.
    // The lambda only receives the parameters defined by the signal's delegate.
    player.Hit += (hitBy, level) => OnPlayerHit(hitBy, level, "sword", 100);

    // Parameters added when emitting the signal are passed first.
    player.EmitSignal(SignalName.Hit, "Dark lord", 5);
}

// We pass two arguments when emitting (`hit_by`, `level`),
// and bind two more arguments when connecting (`weapon_type`, `damage`).
private void OnPlayerHit(string hitBy, int level, string weaponType, int damage)
{
    GD.Print($"Hit by {hitBy} (level {level}) with weapon {weaponType} for {damage} damage.");
}
[/csharp]
[/codeblocks]
*/
//go:nosplit
func (self Object) Connect(signal StringName, callable Callable, flags Int) int64 {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(signal))
	callframe.Arg(frame, mmm.Get(callable))
	callframe.Arg(frame, flags)
	var r_ret = callframe.Ret[int64](frame)
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_connect, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Disconnects a [param signal] by name from a given [param callable]. If the connection does not exist, generates an error. Use [method is_connected] to make sure that the connection exists.
*/
//go:nosplit
func (self Object) Disconnect(signal StringName, callable Callable)  {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(signal))
	callframe.Arg(frame, mmm.Get(callable))
	var r_ret callframe.Nil
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_disconnect, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	frame.Free()
}
/*
Returns [code]true[/code] if a connection exists between the given [param signal] name and [param callable].
[b]Note:[/b] In C#, [param signal] must be in snake_case when referring to built-in Godot methods. Prefer using the names exposed in the [code]SignalName[/code] class to avoid allocating a new [StringName] on each call.
*/
//go:nosplit
func (self Object) IsConnected(signal StringName, callable Callable) bool {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(signal))
	callframe.Arg(frame, mmm.Get(callable))
	var r_ret = callframe.Ret[bool](frame)
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_is_connected, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
If set to [code]true[/code], the object becomes unable to emit signals. As such, [method emit_signal] and signal connections will not work, until it is set to [code]false[/code].
*/
//go:nosplit
func (self Object) SetBlockSignals(enable bool)  {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	callframe.Arg(frame, enable)
	var r_ret callframe.Nil
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_set_block_signals, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	frame.Free()
}
/*
Returns [code]true[/code] if the object is blocking its signals from being emitted. See [method set_block_signals].
*/
//go:nosplit
func (self Object) IsBlockingSignals() bool {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_is_blocking_signals, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Emits the [signal property_list_changed] signal. This is mainly used to refresh the editor, so that the Inspector and editor plugins are properly updated.
*/
//go:nosplit
func (self Object) NotifyPropertyListChanged()  {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	var r_ret callframe.Nil
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_notify_property_list_changed, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	frame.Free()
}
/*
If set to [code]true[/code], allows the object to translate messages with [method tr] and [method tr_n]. Enabled by default. See also [method can_translate_messages].
*/
//go:nosplit
func (self Object) SetMessageTranslation(enable bool)  {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	callframe.Arg(frame, enable)
	var r_ret callframe.Nil
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_set_message_translation, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	frame.Free()
}
/*
Returns [code]true[/code] if the object is allowed to translate messages with [method tr] and [method tr_n]. See also [method set_message_translation].
*/
//go:nosplit
func (self Object) CanTranslateMessages() bool {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_can_translate_messages, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Translates a [param message], using the translation catalogs configured in the Project Settings. Further [param context] can be specified to help with the translation. Note that most [Control] nodes automatically translate their strings, so this method is mostly useful for formatted strings or custom drawn text.
If [method can_translate_messages] is [code]false[/code], or no translation is available, this method returns the [param message] without changes. See [method set_message_translation].
For detailed examples, see [url=$DOCS_URL/tutorials/i18n/internationalizing_games.html]Internationalizing games[/url].
[b]Note:[/b] This method can't be used without an [Object] instance, as it requires the [method can_translate_messages] method. To translate strings in a static context, use [method TranslationServer.translate].
*/
//go:nosplit
func (self Object) Tr(ctx Lifetime, message StringName, context StringName) String {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(message))
	callframe.Arg(frame, mmm.Get(context))
	var r_ret = callframe.Ret[uintptr](frame)
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_tr, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Translates a [param message] or [param plural_message], using the translation catalogs configured in the Project Settings. Further [param context] can be specified to help with the translation.
If [method can_translate_messages] is [code]false[/code], or no translation is available, this method returns [param message] or [param plural_message], without changes. See [method set_message_translation].
The [param n] is the number, or amount, of the message's subject. It is used by the translation system to fetch the correct plural form for the current language.
For detailed examples, see [url=$DOCS_URL/tutorials/i18n/localization_using_gettext.html]Localization using gettext[/url].
[b]Note:[/b] Negative and [float] numbers may not properly apply to some countable subjects. It's recommended to handle these cases with [method tr].
[b]Note:[/b] This method can't be used without an [Object] instance, as it requires the [method can_translate_messages] method. To translate strings in a static context, use [method TranslationServer.translate_plural].
*/
//go:nosplit
func (self Object) TrN(ctx Lifetime, message StringName, plural_message StringName, n Int, context StringName) String {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	callframe.Arg(frame, mmm.Get(message))
	callframe.Arg(frame, mmm.Get(plural_message))
	callframe.Arg(frame, n)
	callframe.Arg(frame, mmm.Get(context))
	var r_ret = callframe.Ret[uintptr](frame)
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_tr_n, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = mmm.New[String](ctx.Lifetime, ctx.API, r_ret.Get())
	frame.Free()
	return ret
}
/*
Returns [code]true[/code] if the [method Node.queue_free] method was called for the object.
*/
//go:nosplit
func (self Object) IsQueuedForDeletion() bool {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_is_queued_for_deletion, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
If this method is called during [constant NOTIFICATION_PREDELETE], this object will reject being freed and will remain allocated. This is mostly an internal function used for error handling to avoid the user from freeing objects when they are not intended to.
*/
//go:nosplit
func (self Object) CancelFree()  {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	var r_ret callframe.Nil
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.Object.Bind_cancel_free, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	frame.Free()
}
func (self Object) Virtual(name string) reflect.Value { return reflect.Value{} }
type RefCounted struct {_ [0]*RefCounted; ptr Pointer}

//go:nosplit
func (self RefCounted) AsPointer() Pointer { return self.ptr }


//go:nosplit
func (self *RefCounted) SetPointer(ptr Pointer) { self.ptr = ptr }


//go:nosplit
func (self RefCounted) AsObject() Object { return *(*Object)(unsafe.Pointer(&self)) }

/*
Initializes the internal reference counter. Use this only if you really know what you are doing.
Returns whether the initialization was successful.
*/
//go:nosplit
func (self RefCounted) InitRef() bool {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.RefCounted.Bind_init_ref, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Increments the internal reference counter. Use this only if you really know what you are doing.
Returns [code]true[/code] if the increment was successful, [code]false[/code] otherwise.
*/
//go:nosplit
func (self RefCounted) Reference() bool {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.RefCounted.Bind_reference, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Decrements the internal reference counter. Use this only if you really know what you are doing.
Returns [code]true[/code] if the object should be freed after the decrement, [code]false[/code] otherwise.
*/
//go:nosplit
func (self RefCounted) Unreference() bool {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	var r_ret = callframe.Ret[bool](frame)
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.RefCounted.Bind_unreference, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
/*
Returns the current reference count.
*/
//go:nosplit
func (self RefCounted) GetReferenceCount() Int {
	var selfPtr = self.AsPointer()
	var frame = callframe.New()
	var r_ret = callframe.Ret[Int](frame)
	mmm.API(selfPtr).Object.MethodBindPointerCall(mmm.API(selfPtr).Methods.RefCounted.Bind_get_reference_count, self.AsObject(), frame.Array(0), r_ret.Uintptr())
	var ret = r_ret.Get()
	frame.Free()
	return ret
}
func (self RefCounted) Virtual(name string) reflect.Value { return reflect.Value{} }
